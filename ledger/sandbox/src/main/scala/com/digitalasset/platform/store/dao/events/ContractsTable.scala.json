[
  {
    "id" : "f9419141-f474-4e96-8a63-e94c567bfab9",
    "prId" : 5541,
    "comments" : [
      {
        "id" : "e47aa1d0-e1a4-4794-87ba-30e7c46b72da",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The query doesn't guard against inserting a divulged contract that has been divulged in previous transactions, i.e. I think we need a `merge` rather than an `insert`.",
        "createdAt" : "2020-04-16T08:16:37Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c91c063f-ce2b-4790-81fa-7737c7cf4ebc",
        "parentId" : "e47aa1d0-e1a4-4794-87ba-30e7c46b72da",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Right, I'll need to work on this a bit, since PostgreSQL and H2 require us to use different idioms to express this. Thanks!",
        "createdAt" : "2020-04-16T09:15:56Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "93276550-1421-403b-acff-1e366dfb6200",
        "parentId" : "e47aa1d0-e1a4-4794-87ba-30e7c46b72da",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Stumbled on this while running the data migration tests.",
        "createdAt" : "2020-04-17T09:01:08Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d7f9fb1c-8e4a-4f55-a0ec-e3c8a49dc2b2",
        "parentId" : "e47aa1d0-e1a4-4794-87ba-30e7c46b72da",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5541/commits/df4daa6be42762ae7ecf498ef08daa34b386ff55",
        "createdAt" : "2020-04-17T13:20:04Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2034352017063fbc2c958c5a086273e66ed0ad47",
    "line" : 125,
    "diffHunk" : "@@ -0,0 +1,140 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import java.time.Instant\n+\n+import anorm.{BatchSql, NamedParameter}\n+import com.daml.platform.store.Conversions._\n+import com.daml.platform.store.serialization.KeyHasher.{hashKey => hash}\n+import com.daml.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+\n+private[events] object ContractsTable {\n+\n+  private val insertContractQuery =\n+    \"insert into participant_contracts(contract_id, template_id, create_argument, create_ledger_effective_time, create_key_hash, create_stakeholders) values ({contract_id}, {template_id}, {create_argument}, {create_ledger_effective_time}, {create_key_hash}, {create_stakeholders})\"\n+  private def insertContractQuery(\n+      contractId: ContractId,\n+      templateId: Identifier,\n+      createArgument: Value,\n+      createLedgerEffectiveTime: Option[Instant],\n+      stakeholders: Set[Party],\n+      key: Option[Key],\n+  ): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"contract_id\" -> contractId,\n+      \"template_id\" -> templateId,\n+      \"create_argument\" -> serialize(\n+        value = createArgument,\n+        errorContext = s\"Cannot serialize create argument for $contractId\",\n+      ),\n+      \"create_ledger_effective_time\" -> createLedgerEffectiveTime,\n+      \"create_stakeholders\" -> stakeholders.toArray[String],\n+      \"create_key_hash\" -> key.map(hash),\n+    )\n+\n+  private val deleteContractQuery =\n+    s\"delete from participant_contracts where contract_id = {contract_id}\"\n+  private def deleteContract(contractId: ContractId): Vector[NamedParameter] =\n+    Vector[NamedParameter](\"contract_id\" -> contractId)\n+\n+  case class PreparedBatches private (\n+      insertions: Option[(Set[ContractId], BatchSql)],\n+      deletions: Option[(Set[ContractId], BatchSql)],\n+  )\n+\n+  private case class AccumulatingBatches(\n+      insertions: Map[ContractId, Vector[NamedParameter]],\n+      deletions: Map[ContractId, Vector[NamedParameter]],\n+  ) {\n+\n+    def insert(contractId: ContractId, insertion: Vector[NamedParameter]): AccumulatingBatches =\n+      copy(insertions = insertions.updated(contractId, insertion))\n+\n+    // If the batch contains the contractId, remove the insertion.\n+    // Otherwise, add a delete. This prevents the insertion of transient contracts.\n+    def delete(contractId: ContractId, deletion: => Vector[NamedParameter]): AccumulatingBatches =\n+      if (insertions.contains(contractId))\n+        copy(insertions = insertions - contractId)\n+      else\n+        copy(deletions = deletions.updated(contractId, deletion))\n+\n+    private def prepareNonEmpty(\n+        query: String,\n+        contractIdToParameters: Map[ContractId, Vector[NamedParameter]],\n+    ): Option[(Set[ContractId], BatchSql)] = {\n+      if (contractIdToParameters.nonEmpty) {\n+        val contractIds = contractIdToParameters.keySet\n+        val parameters = contractIdToParameters.valuesIterator.toSeq\n+        val batch = BatchSql(query, parameters.head, parameters.tail: _*)\n+        Some(contractIds -> batch)\n+      } else {\n+        None\n+      }\n+    }\n+\n+    def prepare: PreparedBatches =\n+      PreparedBatches(\n+        insertions = prepareNonEmpty(insertContractQuery, insertions),\n+        deletions = prepareNonEmpty(deleteContractQuery, deletions),\n+      )\n+\n+  }\n+\n+  def prepareBatchInsert(\n+      ledgerEffectiveTime: Instant,\n+      transaction: Transaction,\n+      divulgedContracts: Iterable[(ContractId, Contract)],\n+  ): PreparedBatches = {\n+\n+    // Add the locally created contracts, ensuring that _transient_\n+    // contracts are not inserted in the first place\n+    val locallyCreatedContracts =\n+      transaction\n+        .fold(AccumulatingBatches(Map.empty, Map.empty)) {\n+          case (batches, (_, node: Create)) =>\n+            batches.insert(\n+              contractId = node.coid,\n+              insertion = insertContractQuery(\n+                contractId = node.coid,\n+                templateId = node.coinst.template,\n+                createArgument = node.coinst.arg,\n+                createLedgerEffectiveTime = Some(ledgerEffectiveTime),\n+                stakeholders = node.stakeholders,\n+                key = node.key.map(k => Key.assertBuild(node.coinst.template, k.key.value)),\n+              )\n+            )\n+          case (batches, (_, node: Exercise)) if node.consuming =>\n+            batches.delete(\n+              contractId = node.targetCoid,\n+              deletion = deleteContract(node.targetCoid),\n+            )\n+          case (batches, _) =>\n+            batches // ignore any event which is neither a create nor a consuming exercise\n+        }\n+\n+    // Divulged contracts are inserted _after_ locally created contracts to make sure they are\n+    // not skipped if consumed in this transaction due to the logic that prevents the insertion\n+    // of transient contracts (a divulged contract _must_ be inserted, regardless of whether it's\n+    // consumed or not).\n+    val divulgedContractsInsertions =\n+      divulgedContracts.iterator.collect {\n+        case (contractId, contract) if !locallyCreatedContracts.insertions.contains(contractId) =>\n+          contractId -> insertContractQuery("
  }
]