[
  {
    "id" : "84210b57-fb00-42be-afb7-fb33669289e4",
    "prId" : 1426,
    "comments" : [
      {
        "id" : "135719f8-e93d-4403-af7d-72c6c2dace3b",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "what do you think @gerolf-da ?",
        "createdAt" : "2019-05-28T12:20:12Z",
        "updatedAt" : "2019-05-28T13:07:19Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5ec4f645-ab60-4b68-b2dc-af631784aa40",
        "parentId" : "135719f8-e93d-4403-af7d-72c6c2dace3b",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The completion service should only emit events for \"local\" transactions.",
        "createdAt" : "2019-05-28T12:40:13Z",
        "updatedAt" : "2019-05-28T13:07:19Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b2087ef6864ee9b2a582a8119a092cbf231851c2",
    "line" : null,
    "diffHunk" : "@@ -53,106 +56,83 @@ class SandboxCommandCompletionService private (\n       \"Received request for completion subscription {}: {}\",\n       subscriptionId: Any,\n       request)\n-    val offsetOrError =\n-      request.offset.fold[Future[Option[Ref.LedgerString]]](Future.successful(None))(\n-        o =>\n-          LedgerOffsetValidator\n-            .validate(o, \"offset\")\n-            .fold(\n-              Future.failed, {\n-                case domain.LedgerOffset.Absolute(value) => Future.successful(Some(value))\n-                case domain.LedgerOffset.LedgerBegin => Future.successful(None)\n-                case domain.LedgerOffset.LedgerEnd =>\n-                  ledgerBackend.getCurrentLedgerEnd.map(Some.apply)\n-              }\n-          ))\n-\n-    Source\n-      .fromFuture(offsetOrError)\n-      .flatMapConcat(completionSourceWithOffset(request, _, subscriptionId))\n+\n+    val offsetOrError = for {\n+      offset <- FieldValidations.requirePresence(request.offset, \"offset\")\n+      convertedOffset <- LedgerOffsetValidator.validate(offset, \"offset\")\n+    } yield convertedOffset\n+\n+    offsetOrError.fold(\n+      Source.failed,\n+      offset => completionSourceWithOffset(request, offset, subscriptionId))\n   }\n \n   private def completionSourceWithOffset(\n       request: CompletionStreamRequest,\n-      requestedOffset: Option[LedgerSyncOffset],\n+      requestedOffset: domain.LedgerOffset,\n       subscriptionId: String): Source[CompletionStreamResponse, NotUsed] = {\n-    val requestingParties = request.parties.toSet\n-    val requestedApplicationId = request.applicationId\n-    ledgerBackend\n-      .ledgerSyncEvents(requestedOffset)\n-      .map { syncEvent =>\n-        val checkpoint =\n-          Some(\n-            Checkpoint(\n-              Some(fromInstant(syncEvent.recordTime)),\n-              Some(LedgerOffset(LedgerOffset.Value.Absolute(syncEvent.offset)))))\n-\n-        syncEvent match {\n-          case tx: LedgerSyncEvent.AcceptedTransaction\n-              if isRequested(\n-                requestedApplicationId,\n-                requestingParties,\n-                tx.applicationId,\n-                tx.submitter) =>\n+    //TODO: put these into a proper validator\n+    val requestingParties = request.parties.toSet.map(Ref.Party.assertFromString)\n+    val requestedApplicationId: domain.ApplicationId =\n+      domain.ApplicationId(Ref.LedgerString.assertFromString(request.applicationId))\n+\n+    completionsService\n+      .getCompletions(requestedOffset, requestedApplicationId, requestingParties)\n+      .map { ce =>\n+        val checkpoint = Some(\n+          Checkpoint(\n+            Some(fromInstant(ce.recordTime)),\n+            Some(LedgerOffset(LedgerOffset.Value.Absolute(ce.offset.value)))))\n+\n+        ce match {\n+          case CompletionEvent.CommandAccepted(_, _, commandId, transactionId) =>\n+            //TODO: code smell, if we don't send anything for empty command IDs, why do we get the event at all?"
  },
  {
    "id" : "a0b33aaa-cb4b-4e1f-9850-d805f9fed60e",
    "prId" : 1426,
    "comments" : [
      {
        "id" : "4d1ac074-1e5c-4c6f-9314-5de7cf3fe1df",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Can you add the validator in this PR? We already do party validation in other places and I think it'd be great to clean it up at once.",
        "createdAt" : "2019-05-28T13:23:56Z",
        "updatedAt" : "2019-05-28T13:27:43Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7c8a7a9a-5878-46bc-aad7-bf3459f81c38",
        "parentId" : "4d1ac074-1e5c-4c6f-9314-5de7cf3fe1df",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "alright, will do that.",
        "createdAt" : "2019-05-28T13:29:20Z",
        "updatedAt" : "2019-05-28T13:29:20Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "04c3f54d-81a4-463d-82aa-1eaf2982b62c",
        "parentId" : "4d1ac074-1e5c-4c6f-9314-5de7cf3fe1df",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "we agreed to do it as a follow-up PR instead, to unblock further work ",
        "createdAt" : "2019-05-28T13:53:57Z",
        "updatedAt" : "2019-05-28T13:53:58Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b2087ef6864ee9b2a582a8119a092cbf231851c2",
    "line" : 101,
    "diffHunk" : "@@ -53,106 +56,82 @@ class SandboxCommandCompletionService private (\n       \"Received request for completion subscription {}: {}\",\n       subscriptionId: Any,\n       request)\n-    val offsetOrError =\n-      request.offset.fold[Future[Option[Ref.LedgerString]]](Future.successful(None))(\n-        o =>\n-          LedgerOffsetValidator\n-            .validate(o, \"offset\")\n-            .fold(\n-              Future.failed, {\n-                case domain.LedgerOffset.Absolute(value) => Future.successful(Some(value))\n-                case domain.LedgerOffset.LedgerBegin => Future.successful(None)\n-                case domain.LedgerOffset.LedgerEnd =>\n-                  ledgerBackend.getCurrentLedgerEnd.map(Some.apply)\n-              }\n-          ))\n-\n-    Source\n-      .fromFuture(offsetOrError)\n-      .flatMapConcat(completionSourceWithOffset(request, _, subscriptionId))\n+\n+    val offsetOrError = for {\n+      offset <- FieldValidations.requirePresence(request.offset, \"offset\")\n+      convertedOffset <- LedgerOffsetValidator.validate(offset, \"offset\")\n+    } yield convertedOffset\n+\n+    offsetOrError.fold(\n+      Source.failed,\n+      offset => completionSourceWithOffset(request, offset, subscriptionId))\n   }\n \n   private def completionSourceWithOffset(\n       request: CompletionStreamRequest,\n-      requestedOffset: Option[LedgerSyncOffset],\n+      requestedOffset: domain.LedgerOffset,\n       subscriptionId: String): Source[CompletionStreamResponse, NotUsed] = {\n-    val requestingParties = request.parties.toSet\n-    val requestedApplicationId = request.applicationId\n-    ledgerBackend\n-      .ledgerSyncEvents(requestedOffset)\n-      .map { syncEvent =>\n-        val checkpoint =\n-          Some(\n-            Checkpoint(\n-              Some(fromInstant(syncEvent.recordTime)),\n-              Some(LedgerOffset(LedgerOffset.Value.Absolute(syncEvent.offset)))))\n-\n-        syncEvent match {\n-          case tx: LedgerSyncEvent.AcceptedTransaction\n-              if isRequested(\n-                requestedApplicationId,\n-                requestingParties,\n-                tx.applicationId,\n-                tx.submitter) =>\n+    //TODO: put these into a proper validator"
  }
]