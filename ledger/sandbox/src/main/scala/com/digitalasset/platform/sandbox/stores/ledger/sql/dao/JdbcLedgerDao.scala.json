[
  {
    "id" : "9e0f12e2-94bb-44b7-a76c-e15b880cdcf1",
    "prId" : 3682,
    "comments" : [
      {
        "id" : "b9bd7bd9-00e2-413f-b707-624bbf6ef17a",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "This is no longer true. Is it still safe?",
        "createdAt" : "2019-11-29T16:21:30Z",
        "updatedAt" : "2019-12-06T10:21:32Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7f149621-2d39-4cf3-9806-2019882eeeec",
        "parentId" : "b9bd7bd9-00e2-413f-b707-624bbf6ef17a",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "start and end are still fixed at the beginning.",
        "createdAt" : "2019-11-29T16:23:03Z",
        "updatedAt" : "2019-12-06T10:21:32Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a917d19a-bb15-4096-bffc-2c600a28865a",
        "parentId" : "b9bd7bd9-00e2-413f-b707-624bbf6ef17a",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Oh, of course, just not _here_.",
        "createdAt" : "2019-11-29T16:24:41Z",
        "updatedAt" : "2019-12-06T10:21:32Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1e6c4f1300f95e21d8c8f244ae99ddeb3b6b2d13",
    "line" : null,
    "diffHunk" : "@@ -1222,28 +1225,26 @@ private class JdbcLedgerDao(\n       .toSet\n \n   private val SQL_GET_LEDGER_ENTRIES = SQL(\n-    \"select * from ledger_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n+    \"select * from ledger_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc limit {pageSize} offset {queryOffset}\")\n \n   // Note that here we are reading, non transactionally, the stream in chunks. The reason why this is\n   // safe is that\n   // * The ledger entries are never removed;\n   // * We fix the ledger end at the beginning."
  },
  {
    "id" : "6c1c553c-535e-48ff-bea1-0cc0feb09bdf",
    "prId" : 3682,
    "comments" : [
      {
        "id" : "3a2f3cdf-2169-4e12-8162-8a0b3c94e54d",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I'd love for this to be pulled out into its own file and wrapped in unit tests, mostly for documentation purposes. It's hard to grok just by reading the code.",
        "createdAt" : "2019-11-29T16:21:51Z",
        "updatedAt" : "2019-12-06T10:21:32Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1e6c4f1300f95e21d8c8f244ae99ddeb3b6b2d13",
    "line" : null,
    "diffHunk" : "@@ -1222,28 +1225,26 @@ private class JdbcLedgerDao(\n       .toSet\n \n   private val SQL_GET_LEDGER_ENTRIES = SQL(\n-    \"select * from ledger_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n+    \"select * from ledger_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc limit {pageSize} offset {queryOffset}\")\n \n   // Note that here we are reading, non transactionally, the stream in chunks. The reason why this is\n   // safe is that\n   // * The ledger entries are never removed;\n   // * We fix the ledger end at the beginning.\n   private def paginatingStream[T]("
  },
  {
    "id" : "ee1409f4-e16d-4c76-a412-38ab873894b1",
    "prId" : 3553,
    "comments" : [
      {
        "id" : "f914eff8-f699-4874-b3a3-b245aba417f9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The description is used for a metric and shouldn't contain spaces or data specific to a request (e.g. submissionId).\r\n```suggestion\r\n    dbDispatcher.executeSql(\"store_configuration_entry\", Some(\"submissionId=$submissionId\")) {\r\n```",
        "createdAt" : "2019-11-25T08:47:40Z",
        "updatedAt" : "2019-11-27T14:09:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "04d3118b43225ee033b4c9bba93102cdc650df6a",
    "line" : null,
    "diffHunk" : "@@ -141,6 +147,141 @@ private class JdbcLedgerDao(\n     ()\n   }\n \n+  private val SQL_UPDATE_CURRENT_CONFIGURATION = SQL(\n+    \"update parameters set configuration={configuration}\"\n+  )\n+  private val SQL_SELECT_CURRENT_CONFIGURATION = SQL(\"select configuration from parameters\")\n+\n+  private val SQL_GET_CONFIGURATION_ENTRIES = SQL(\n+    \"select * from configuration_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n+\n+  private def updateCurrentConfiguration(configBytes: Array[Byte])(\n+      implicit conn: Connection): Unit = {\n+    SQL_UPDATE_CURRENT_CONFIGURATION\n+      .on(\"configuration\" -> configBytes)\n+      .execute()\n+    ()\n+  }\n+\n+  private def selectLedgerConfiguration(implicit conn: Connection) =\n+    SQL_SELECT_CURRENT_CONFIGURATION\n+      .as(byteArray(\"configuration\").?.single)\n+      .flatMap(Configuration.decode(_).toOption)\n+\n+  override def lookupLedgerConfiguration(): Future[Option[Configuration]] =\n+    dbDispatcher.executeSql(\"lookup configuration\")(implicit conn => selectLedgerConfiguration)\n+\n+  private val configurationEntryParser: RowParser[(Long, ConfigurationEntry)] =\n+    (long(\"ledger_offset\") ~\n+      str(\"typ\") ~\n+      str(\"submission_id\") ~\n+      str(\"participant_id\") ~\n+      str(\"rejection_reason\")(emptyStringToNullColumn).? ~\n+      byteArray(\"configuration\"))\n+      .map(flatten)\n+      .map {\n+        case (offset, typ, submissionId, participantIdRaw, rejectionReason, configBytes) =>\n+          val config = Configuration\n+            .decode(configBytes)\n+            .fold(err => sys.error(s\"Failed to decode configuration: $err\"), identity)\n+          val participantId = LedgerString\n+            .fromString(participantIdRaw)\n+            .fold(\n+              err => sys.error(s\"Failed to decode participant id in configuration entry: $err\"),\n+              identity)\n+\n+          offset ->\n+            (typ match {\n+              case \"accept\" =>\n+                ConfigurationEntry.Accepted(\n+                  submissionId = submissionId,\n+                  participantId = participantId,\n+                  configuration = config\n+                )\n+              case \"reject\" =>\n+                ConfigurationEntry.Rejected(\n+                  submissionId = submissionId,\n+                  participantId = participantId,\n+                  rejectionReason = rejectionReason.getOrElse(\"<missing reason>\"),\n+                  proposedConfiguration = config\n+                )\n+\n+              case _ =>\n+                sys.error(s\"getConfigurationEntries: Unknown configuration entry type: $typ\")\n+            })\n+      }\n+\n+  override def getConfigurationEntries(\n+      startInclusive: Long,\n+      endExclusive: Long): Source[(Long, ConfigurationEntry), NotUsed] =\n+    paginatingStream(\n+      startInclusive,\n+      endExclusive,\n+      PageSize,\n+      (startI, endE) => {\n+        dbDispatcher.executeSql(s\"load configuration entries [$startI, $endE[\") { implicit conn =>\n+          SQL_GET_CONFIGURATION_ENTRIES\n+            .on(\"startInclusive\" -> startI, \"endExclusive\" -> endE)\n+            .as(configurationEntryParser.*)\n+        }\n+      }\n+    ).flatMapConcat(Source(_))\n+\n+  private val SQL_INSERT_CONFIGURATION_ENTRY =\n+    SQL(\n+      \"\"\"insert into configuration_entries(ledger_offset, recorded_at, submission_id, participant_id, typ, rejection_reason, configuration)\n+        |values({ledger_offset}, {recorded_at}, {submission_id}, {participant_id}, {typ}, {rejection_reason}, {configuration})\n+        |\"\"\".stripMargin)\n+\n+  override def storeConfigurationEntry(\n+      offset: LedgerOffset,\n+      newLedgerEnd: LedgerOffset,\n+      externalOffset: Option[ExternalOffset],\n+      recordedAt: Instant,\n+      submissionId: String,\n+      participantId: ParticipantId,\n+      configuration: Configuration,\n+      rejectionReason: Option[String]\n+  ): Future[PersistenceResponse] = {\n+    dbDispatcher.executeSql(s\"store configuration entry submissionId=$submissionId\") {"
  },
  {
    "id" : "5db2b3c4-c1a9-4518-b624-0084d025fdd0",
    "prId" : 3553,
    "comments" : [
      {
        "id" : "97fece94-034f-489a-98e8-1ca2595e12f4",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    dbDispatcher.executeSql(\"lookup_configuration\")(implicit conn => selectLedgerConfiguration)\r\n```",
        "createdAt" : "2019-11-26T20:56:12Z",
        "updatedAt" : "2019-11-27T14:09:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "04d3118b43225ee033b4c9bba93102cdc650df6a",
    "line" : null,
    "diffHunk" : "@@ -141,6 +147,141 @@ private class JdbcLedgerDao(\n     ()\n   }\n \n+  private val SQL_UPDATE_CURRENT_CONFIGURATION = SQL(\n+    \"update parameters set configuration={configuration}\"\n+  )\n+  private val SQL_SELECT_CURRENT_CONFIGURATION = SQL(\"select configuration from parameters\")\n+\n+  private val SQL_GET_CONFIGURATION_ENTRIES = SQL(\n+    \"select * from configuration_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n+\n+  private def updateCurrentConfiguration(configBytes: Array[Byte])(\n+      implicit conn: Connection): Unit = {\n+    SQL_UPDATE_CURRENT_CONFIGURATION\n+      .on(\"configuration\" -> configBytes)\n+      .execute()\n+    ()\n+  }\n+\n+  private def selectLedgerConfiguration(implicit conn: Connection) =\n+    SQL_SELECT_CURRENT_CONFIGURATION\n+      .as(byteArray(\"configuration\").?.single)\n+      .flatMap(Configuration.decode(_).toOption)\n+\n+  override def lookupLedgerConfiguration(): Future[Option[Configuration]] =\n+    dbDispatcher.executeSql(\"lookup configuration\")(implicit conn => selectLedgerConfiguration)"
  },
  {
    "id" : "1d728ad7-b0fc-4d71-b495-f48765bcc67d",
    "prId" : 3553,
    "comments" : [
      {
        "id" : "b3f606c4-f852-4e74-a83f-97148433cc7c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n        dbDispatcher.executeSql(\"load_configuration_entries\", Some(s\"bounds: [$startI, $endE[\") { implicit conn =>\r\n```",
        "createdAt" : "2019-11-26T20:58:11Z",
        "updatedAt" : "2019-11-27T14:09:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "04d3118b43225ee033b4c9bba93102cdc650df6a",
    "line" : null,
    "diffHunk" : "@@ -141,6 +147,141 @@ private class JdbcLedgerDao(\n     ()\n   }\n \n+  private val SQL_UPDATE_CURRENT_CONFIGURATION = SQL(\n+    \"update parameters set configuration={configuration}\"\n+  )\n+  private val SQL_SELECT_CURRENT_CONFIGURATION = SQL(\"select configuration from parameters\")\n+\n+  private val SQL_GET_CONFIGURATION_ENTRIES = SQL(\n+    \"select * from configuration_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n+\n+  private def updateCurrentConfiguration(configBytes: Array[Byte])(\n+      implicit conn: Connection): Unit = {\n+    SQL_UPDATE_CURRENT_CONFIGURATION\n+      .on(\"configuration\" -> configBytes)\n+      .execute()\n+    ()\n+  }\n+\n+  private def selectLedgerConfiguration(implicit conn: Connection) =\n+    SQL_SELECT_CURRENT_CONFIGURATION\n+      .as(byteArray(\"configuration\").?.single)\n+      .flatMap(Configuration.decode(_).toOption)\n+\n+  override def lookupLedgerConfiguration(): Future[Option[Configuration]] =\n+    dbDispatcher.executeSql(\"lookup configuration\")(implicit conn => selectLedgerConfiguration)\n+\n+  private val configurationEntryParser: RowParser[(Long, ConfigurationEntry)] =\n+    (long(\"ledger_offset\") ~\n+      str(\"typ\") ~\n+      str(\"submission_id\") ~\n+      str(\"participant_id\") ~\n+      str(\"rejection_reason\")(emptyStringToNullColumn).? ~\n+      byteArray(\"configuration\"))\n+      .map(flatten)\n+      .map {\n+        case (offset, typ, submissionId, participantIdRaw, rejectionReason, configBytes) =>\n+          val config = Configuration\n+            .decode(configBytes)\n+            .fold(err => sys.error(s\"Failed to decode configuration: $err\"), identity)\n+          val participantId = LedgerString\n+            .fromString(participantIdRaw)\n+            .fold(\n+              err => sys.error(s\"Failed to decode participant id in configuration entry: $err\"),\n+              identity)\n+\n+          offset ->\n+            (typ match {\n+              case \"accept\" =>\n+                ConfigurationEntry.Accepted(\n+                  submissionId = submissionId,\n+                  participantId = participantId,\n+                  configuration = config\n+                )\n+              case \"reject\" =>\n+                ConfigurationEntry.Rejected(\n+                  submissionId = submissionId,\n+                  participantId = participantId,\n+                  rejectionReason = rejectionReason.getOrElse(\"<missing reason>\"),\n+                  proposedConfiguration = config\n+                )\n+\n+              case _ =>\n+                sys.error(s\"getConfigurationEntries: Unknown configuration entry type: $typ\")\n+            })\n+      }\n+\n+  override def getConfigurationEntries(\n+      startInclusive: Long,\n+      endExclusive: Long): Source[(Long, ConfigurationEntry), NotUsed] =\n+    paginatingStream(\n+      startInclusive,\n+      endExclusive,\n+      PageSize,\n+      (startI, endE) => {\n+        dbDispatcher.executeSql(s\"load configuration entries [$startI, $endE[\") { implicit conn =>"
  },
  {
    "id" : "c3821a4a-0afe-471a-8b36-ba89553cc9fa",
    "prId" : 3553,
    "comments" : [
      {
        "id" : "de85a864-c3f9-4cd8-a65e-bcdc8c67b3f2",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I like to do the decoding of the protobuf messages as part of processing the akka stream (compare `getLedgerEntries`), because then\r\n1) the decoding only happens when demand for more messages is requested from the sink (i.e. the API consumer)\r\n2) we don't do all the work upfront just to find out that the stream was broken.\r\n\r\nAdmittedly this is less of a problem for configuration than for transactions, but it'll ultimately be more sane to use the same \"process\".\r\n\r\nFor now, don't worry about it.",
        "createdAt" : "2019-11-26T21:03:11Z",
        "updatedAt" : "2019-11-27T14:09:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5d83c0cf-9749-4a0b-8911-6229acf4be8a",
        "parentId" : "de85a864-c3f9-4cd8-a65e-bcdc8c67b3f2",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "agree with the reasoning. I'll leave it as is for now though to land this beast...",
        "createdAt" : "2019-11-27T09:31:33Z",
        "updatedAt" : "2019-11-27T14:09:02Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "04d3118b43225ee033b4c9bba93102cdc650df6a",
    "line" : 72,
    "diffHunk" : "@@ -141,6 +147,141 @@ private class JdbcLedgerDao(\n     ()\n   }\n \n+  private val SQL_UPDATE_CURRENT_CONFIGURATION = SQL(\n+    \"update parameters set configuration={configuration}\"\n+  )\n+  private val SQL_SELECT_CURRENT_CONFIGURATION = SQL(\"select configuration from parameters\")\n+\n+  private val SQL_GET_CONFIGURATION_ENTRIES = SQL(\n+    \"select * from configuration_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n+\n+  private def updateCurrentConfiguration(configBytes: Array[Byte])(\n+      implicit conn: Connection): Unit = {\n+    SQL_UPDATE_CURRENT_CONFIGURATION\n+      .on(\"configuration\" -> configBytes)\n+      .execute()\n+    ()\n+  }\n+\n+  private def selectLedgerConfiguration(implicit conn: Connection) =\n+    SQL_SELECT_CURRENT_CONFIGURATION\n+      .as(byteArray(\"configuration\").?.single)\n+      .flatMap(Configuration.decode(_).toOption)\n+\n+  override def lookupLedgerConfiguration(): Future[Option[Configuration]] =\n+    dbDispatcher.executeSql(\"lookup configuration\")(implicit conn => selectLedgerConfiguration)\n+\n+  private val configurationEntryParser: RowParser[(Long, ConfigurationEntry)] =\n+    (long(\"ledger_offset\") ~\n+      str(\"typ\") ~\n+      str(\"submission_id\") ~\n+      str(\"participant_id\") ~\n+      str(\"rejection_reason\")(emptyStringToNullColumn).? ~\n+      byteArray(\"configuration\"))\n+      .map(flatten)\n+      .map {\n+        case (offset, typ, submissionId, participantIdRaw, rejectionReason, configBytes) =>\n+          val config = Configuration"
  },
  {
    "id" : "2f1b897c-8b01-470a-820d-d3da7a13b9c4",
    "prId" : 3362,
    "comments" : [
      {
        "id" : "03ee7e95-e757-4e2c-9541-bbd3381fdda1",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "We may want to name this so that it's clear this is the execution context in which Protobuf deserialization happens.",
        "createdAt" : "2019-11-06T15:35:23Z",
        "updatedAt" : "2019-11-08T07:39:39Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "aa4724fa-c276-4c0f-92f0-1dbd191295cb",
        "parentId" : "03ee7e95-e757-4e2c-9541-bbd3381fdda1",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "yeah, i wasn't sure whether we should use a separate cached threadpool just for that. Right now I'm passing down the actorsystem's dispatcher, which also doesn't seem right, as it'll block scheduling of actor/stream work.",
        "createdAt" : "2019-11-06T17:57:52Z",
        "updatedAt" : "2019-11-08T07:39:39Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7225b1c6bd5a021028f65be952dc7015e923d713",
    "line" : 15,
    "diffHunk" : "@@ -63,7 +63,8 @@ private class JdbcLedgerDao(\n     valueSerializer: ValueSerializer,\n     keyHasher: KeyHasher,\n     dbType: DbType,\n-    loggerFactory: NamedLoggerFactory)\n+    loggerFactory: NamedLoggerFactory,\n+    executionContext: ExecutionContext)"
  },
  {
    "id" : "af6dc562-7704-4790-92fd-306e778cbf3f",
    "prId" : 3310,
    "comments" : [
      {
        "id" : "685a378a-ad7b-4638-b3d9-033634a86f94",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Making this also a metric removes quite a bit of useful information from the log though :(",
        "createdAt" : "2019-11-01T08:55:42Z",
        "updatedAt" : "2019-11-01T16:59:59Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a3111a2c-97ff-4479-8fc1-d7b0c63e8c45",
        "parentId" : "685a378a-ad7b-4638-b3d9-033634a86f94",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3310/commits/c4516473b10ead76cd7473e13afdc8a83e5b986d",
        "createdAt" : "2019-11-01T15:57:44Z",
        "updatedAt" : "2019-11-01T16:59:59Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "da69019b20e9b758d06008c4b2a5ab303bd1e4b6",
    "line" : null,
    "diffHunk" : "@@ -705,25 +705,23 @@ private class JdbcLedgerDao(\n     }.toMap\n \n     dbDispatcher\n-      .executeSql(\n-        s\"store initial state from scenario [${activeContracts.size} contracts, ${ledgerEntries.size} ledger entries\") {\n-        implicit conn =>\n-          // First, store all ledger entries without updating the ACS\n-          // We can't use the storeLedgerEntry(), as that one does update the ACS\n-          ledgerEntries.foreach {\n-            case (i, le) =>\n-              le match {\n-                case tx: LedgerEntry.Transaction => storeTransaction(i, tx)\n-                case rj: LedgerEntry.Rejection => storeRejection(i, rj)\n-                case cp: LedgerEntry.Checkpoint => storeCheckpoint(i, cp)\n-              }\n-          }\n+      .executeSql(\"store_initial_state_from_scenario\") { implicit conn =>"
  },
  {
    "id" : "afced86e-5f0e-4286-9ea8-1cc5a16fbc3f",
    "prId" : 3207,
    "comments" : [
      {
        "id" : "2cbf1bb4-f418-4355-8c4a-948346bec2df",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Can we execute these ~five~ six queries as a single transaction/roundtrip to the database? I'm also a bit worried by the length of this method.",
        "createdAt" : "2019-10-16T16:35:38Z",
        "updatedAt" : "2019-10-28T11:53:23Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "574d8cd5-2727-4b6a-8976-4737a28d58e2",
        "parentId" : "2cbf1bb4-f418-4355-8c4a-948346bec2df",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "it already is a single transaction, but we can only batch execute inserts for a single table. We could however merge the tables `contract_witnesses`, `contract_signatories`, and `contract_observers` and have 3 separate columns or a \"denominator\" column only containing `w`, `s`, and `o` respectively.",
        "createdAt" : "2019-10-17T07:03:18Z",
        "updatedAt" : "2019-10-28T11:53:23Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1c711ce4-354c-42a6-a135-706d90ca2c1b",
        "parentId" : "2cbf1bb4-f418-4355-8c4a-948346bec2df",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I think it's fine as is right now, thanks.",
        "createdAt" : "2019-10-17T09:30:44Z",
        "updatedAt" : "2019-10-28T11:53:23Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "28bd9d4759b6852330b2524547277ae6809f6843",
    "line" : 66,
    "diffHunk" : "@@ -372,6 +378,46 @@ private class JdbcLedgerDao(\n         )\n       }\n     }\n+\n+    // Part 5: insert signatories into the 'contract_signatories' table\n+    val namedSignatoriesParams = contracts\n+      .flatMap(\n+        c =>\n+          c.signatories.map(\n+            w =>\n+              Seq[NamedParameter](\n+                \"contract_id\" -> c.id.coid,\n+                \"signatory\" -> w\n+            ))\n+      )\n+      .toArray\n+\n+    if (!namedSignatoriesParams.isEmpty) {\n+      executeBatchSql(\n+        SQL_INSERT_CONTRACT_SIGNATORIES,\n+        namedSignatoriesParams\n+      )\n+    }\n+\n+    // Part 6: insert observers into the 'contract_observers' table"
  },
  {
    "id" : "c3889288-ee36-40fa-95f5-27d3bdae57ed",
    "prId" : 3207,
    "comments" : [
      {
        "id" : "d0c9d942-b34b-47e4-99b7-1d9128d457bc",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "This comment should probably move to where `SQL_SELECT_ACTIVE_CONTRACTS` is defined",
        "createdAt" : "2019-10-17T16:32:21Z",
        "updatedAt" : "2019-10-28T11:53:23Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "863bb502-bff6-4039-8341-24c9fa0831e1",
        "parentId" : "d0c9d942-b34b-47e4-99b7-1d9128d457bc",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "👍 ",
        "createdAt" : "2019-10-18T08:43:32Z",
        "updatedAt" : "2019-10-28T11:53:23Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "28bd9d4759b6852330b2524547277ae6809f6843",
    "line" : null,
    "diffHunk" : "@@ -1057,19 +1093,8 @@ private class JdbcLedgerDao(\n     SQL(\n       // the distinct keyword is required, because a single contract can be visible by 2 parties,"
  },
  {
    "id" : "3b58fa31-07e2-4100-8806-b62e2ebad03d",
    "prId" : 3207,
    "comments" : [
      {
        "id" : "26170a4b-e828-43e0-a5df-1b8e7dae9cb3",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "What are the chances that we'll decide to relax DAML party identifier restrictions so that `%` is a valid character, while forgetting about his line?",
        "createdAt" : "2019-10-17T16:34:26Z",
        "updatedAt" : "2019-10-28T11:53:23Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "95a58995-0189-424e-a89f-ac674313efec",
        "parentId" : "26170a4b-e828-43e0-a5df-1b8e7dae9cb3",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Non-zero 😈 ",
        "createdAt" : "2019-10-18T11:43:04Z",
        "updatedAt" : "2019-10-28T11:53:23Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "28bd9d4759b6852330b2524547277ae6809f6843",
    "line" : 215,
    "diffHunk" : "@@ -1299,13 +1324,18 @@ object JdbcLedgerDao {\n       dbType,\n       loggerFactory)\n \n+  private val PARTY_SEPARATOR = '%'"
  },
  {
    "id" : "9d68a70c-2b51-4202-b61d-ef2fd3df3193",
    "prId" : 3180,
    "comments" : [
      {
        "id" : "8d1d8e20-64cf-451d-a454-082718e09025",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "For consistency's sake, `ck` should rather be `coke`. :smile: ",
        "createdAt" : "2019-10-15T09:14:22Z",
        "updatedAt" : "2019-10-15T09:15:16Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "087fdf6ae541a8e9e9a1727d95b7e993edb6ffe9",
    "line" : 7,
    "diffHunk" : "@@ -142,6 +142,18 @@ private class JdbcLedgerDao(\n     SQL(\n       \"select contract_id from contract_keys where package_id={package_id} and name={name} and value_hash={value_hash}\")\n \n+  private val SQL_SELECT_CONTRACT_KEY_FOR_PARTY =\n+    SQL(\n+      \"\"\"select ck.contract_id from contract_keys ck\n+        |left join contract_witnesses cowi on ck.contract_id = cowi.contract_id and cowi.witness = {party}"
  },
  {
    "id" : "529f1ba0-6d0d-4f02-a71d-6b91a8136431",
    "prId" : 2739,
    "comments" : [
      {
        "id" : "d5006ed4-8225-4d35-84de-8ba04413a359",
        "parentId" : null,
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Hi Robert - might we worth renaming referencedContracts to divulgedContracts for consistency with the Update event which Jussi recent tweaked.",
        "createdAt" : "2019-09-10T05:53:58Z",
        "updatedAt" : "2019-09-11T10:46:28Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ac3bcd307e2d601598569750bf6c67817e64928e",
    "line" : null,
    "diffHunk" : "@@ -348,7 +370,8 @@ private class JdbcLedgerDao(\n       offset: Long,\n       tx: Transaction,\n       localImplicitDisclosure: Relation[EventId, Party],\n-      globalImplicitDisclosure: Relation[AbsoluteContractId, Party])(\n+      globalImplicitDisclosure: Relation[AbsoluteContractId, Party],\n+      referencedContracts: List[(Value.AbsoluteContractId, AbsoluteContractInst)])("
  },
  {
    "id" : "e2eef6da-77af-40f6-ba92-03ad6fcdd497",
    "prId" : 2719,
    "comments" : [
      {
        "id" : "d0dbd573-7054-499a-aa53-66e040e2441f",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Would this force one extra roundtrip to the database for every call that saves the offset?",
        "createdAt" : "2019-09-02T11:12:34Z",
        "updatedAt" : "2019-09-02T13:20:59Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "495480bc-5d78-41bb-aaba-dcfa7db598a6",
        "parentId" : "d0dbd573-7054-499a-aa53-66e040e2441f",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "yes it would for each state update.",
        "createdAt" : "2019-09-02T11:22:49Z",
        "updatedAt" : "2019-09-02T13:20:59Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1480720df5055a1ee7c519e9ce61312cf6635c63",
    "line" : 7,
    "diffHunk" : "@@ -107,6 +107,17 @@ private class JdbcLedgerDao(\n     ()\n   }\n \n+  private val SQL_UPDATE_EXTERNAL_LEDGER_END = SQL(\n+    \"update parameters set external_ledger_end = {ExternalLedgerEnd}\")\n+\n+  private def updateExternalLedgerEnd(externalLedgerEnd: LedgerString)("
  },
  {
    "id" : "ab24360b-6e7b-45e1-ba57-61376077617c",
    "prId" : 2698,
    "comments" : [
      {
        "id" : "a33e1afc-54a3-499c-9c92-3caee7b6ba93",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Not very important, but this looks like a leftover from some iteration in which you performed some extra operation along with the batch execution for debugging purposes. :slightly_smiling_face: ",
        "createdAt" : "2019-08-29T09:01:23Z",
        "updatedAt" : "2019-08-29T09:39:31Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6b8cbfeb-2bcd-4d66-9642-04cb4f580571",
        "parentId" : "a33e1afc-54a3-499c-9c92-3caee7b6ba93",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Thanks ;-)",
        "createdAt" : "2019-08-29T09:14:26Z",
        "updatedAt" : "2019-08-29T09:39:31Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d7ff6e4dffb1e7c0751771a6bfce7aae17d4a6b5",
    "line" : null,
    "diffHunk" : "@@ -1056,7 +1056,9 @@ private class JdbcLedgerDao(\n                   \"package\" -> p._1.toByteArray\n               )\n             )\n-          val updated = executeBatchSql(dbType.SQL_INSERT_PACKAGE, params).map(math.max(0, _)).sum\n+          val updated = {\n+            executeBatchSql(dbType.SQL_INSERT_PACKAGE, params).map(math.max(0, _)).sum"
  },
  {
    "id" : "7d2dd087-e095-42e1-b4f8-0c04311da11f",
    "prId" : 2425,
    "comments" : [
      {
        "id" : "5df78966-98ca-480f-8287-4adb249c1526",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "The workflow identifier can be empty. Not sure of how this can be represented at this level (I guess the choice is between `Option` and `null` - which you can get with `.orNull` from the `Option`).",
        "createdAt" : "2019-08-14T11:07:18Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ea8928f2-0f00-4d25-b9ae-306d122adf42",
        "parentId" : "5df78966-98ca-480f-8287-4adb249c1526",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Unfortunately we always stored it as empty string rather than null. Hence #2446.",
        "createdAt" : "2019-08-14T11:42:09Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "91367e34-0b9d-41d5-bf78-2593baa28612",
        "parentId" : "5df78966-98ca-480f-8287-4adb249c1526",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I see, disregard my comment.",
        "createdAt" : "2019-08-14T11:55:44Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1fee0715b6e5ad68a7c644fcc1d5e65f71f5a8ed",
    "line" : null,
    "diffHunk" : "@@ -500,8 +500,7 @@ private class JdbcLedgerDao(\n         \"command_id\" -> (tx.commandId: Option[String]),\n         \"application_id\" -> (tx.applicationId: Option[String]),\n         \"submitter\" -> (tx.submittingParty: Option[String]),\n-        \"workflow_id\" -> tx.workflowId\n-          .getOrElse(\"unspecified workflow\"), // TODO: Not allowed to insert an empty string - not a valid ledger string\n+        \"workflow_id\" -> tx.workflowId.getOrElse(\"\"),"
  },
  {
    "id" : "c9c89085-5fa6-4c04-ae5b-2c01089b45e2",
    "prId" : 2425,
    "comments" : [
      {
        "id" : "7be9f241-33f4-4a4e-a119-ee47310f1bb9",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm a bit doubtful about this approach. I would rather use different implementations of some holder of queries for specific implementations rather than manually dispatching with cases.",
        "createdAt" : "2019-08-23T15:21:36Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c82625c0-fb57-4c53-8413-220db1dc1760",
        "parentId" : "7be9f241-33f4-4a4e-a119-ee47310f1bb9",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Conversation continued below",
        "createdAt" : "2019-08-26T08:55:30Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1fee0715b6e5ad68a7c644fcc1d5e65f71f5a8ed",
    "line" : 12,
    "diffHunk" : "@@ -45,13 +45,15 @@ import scala.concurrent.Future\n import scala.util.Try\n import scala.util.control.NonFatal\n \n-private class PostgresLedgerDao(\n+private class JdbcLedgerDao(\n     dbDispatcher: DbDispatcher,\n     contractSerializer: ContractSerializer,\n     transactionSerializer: TransactionSerializer,\n     valueSerializer: ValueSerializer,\n-    keyHasher: KeyHasher)\n+    keyHasher: KeyHasher,\n+    dbType: JdbcLedgerDao.DbType)"
  },
  {
    "id" : "90672279-7975-4076-a16b-3f994a2b7659",
    "prId" : 2425,
    "comments" : [
      {
        "id" : "cc538edb-035a-4dce-9f70-a52b66864ca0",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I know this approach existed before this contribution, but it would be probably be a good idea to address this now: I'm not sure that relying on error messages is a very robust approach. Does H2 have some way of dealing with the errors that are dealt with using checks against this error string?",
        "createdAt" : "2019-08-23T15:28:01Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7794dc26-d2be-4d35-8b03-b92c8199b72e",
        "parentId" : "cc538edb-035a-4dce-9f70-a52b66864ca0",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "As discussed at stand-up this is a bigger change, so for now I added a TODO.",
        "createdAt" : "2019-08-26T08:57:39Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1fee0715b6e5ad68a7c644fcc1d5e65f71f5a8ed",
    "line" : null,
    "diffHunk" : "@@ -329,29 +331,59 @@ private class PostgresLedgerDao(\n   // stores the offset at which the contract was first disclosed.\n   // We therefore don't need to update anything if there is already some data for the given (contract, party) tuple.\n   private val SQL_BATCH_INSERT_DIVULGENCES =\n-    \"\"\"insert into contract_divulgences(contract_id, party, ledger_offset, transaction_id)\n-      |values({contract_id}, {party}, {ledger_offset}, {transaction_id})\n-      |on conflict on constraint contract_divulgences_idx\n-      |do nothing\"\"\".stripMargin\n+    dbType match {\n+      case Postgres =>\n+        \"\"\"insert into contract_divulgences(contract_id, party, ledger_offset, transaction_id)\n+          |values({contract_id}, {party}, {ledger_offset}, {transaction_id})\n+          |on conflict on constraint contract_divulgences_idx\n+          |do nothing\"\"\".stripMargin\n+      case H2Database =>\n+        \"\"\"insert into contract_divulgences(contract_id, party, ledger_offset, transaction_id)\n+          |select {contract_id}, {party}, {ledger_offset}, {transaction_id}\n+          |where not exists(select * from contract_divulgences where contract_id = {contract_id} and party = {party})\n+          |\"\"\".stripMargin\n+    }\n \n   private val SQL_BATCH_INSERT_DIVULGENCES_FROM_TRANSACTION_ID =\n-    \"\"\"insert into contract_divulgences(contract_id, party, ledger_offset, transaction_id)\n-      |select {contract_id}, {party}, ledger_offset, {transaction_id}\n-      |from ledger_entries\n-      |where transaction_id={transaction_id}\n-      |on conflict on constraint contract_divulgences_idx\n-      |do nothing\"\"\".stripMargin\n+    dbType match {\n+      case Postgres =>\n+        \"\"\"insert into contract_divulgences(contract_id, party, ledger_offset, transaction_id)\n+          |select {contract_id}, {party}, ledger_offset, {transaction_id}\n+          |from ledger_entries\n+          |where transaction_id={transaction_id}\n+          |on conflict on constraint contract_divulgences_idx\n+          |do nothing\"\"\".stripMargin\n+      case H2Database =>\n+        \"\"\"insert into contract_divulgences(contract_id, party, ledger_offset, transaction_id)\n+          |select {contract_id}, {party}, ledger_offset, {transaction_id}\n+          |from ledger_entries\n+          |where transaction_id={transaction_id}\n+          |and not exists(select * from contract_divulgences where contract_id = {contract_id} and party = {party})\n+          |\"\"\".stripMargin\n+    }\n \n   private val SQL_INSERT_CHECKPOINT =\n     SQL(\n       \"insert into ledger_entries(typ, ledger_offset, recorded_at) values('checkpoint', {ledger_offset}, {recorded_at})\")\n \n   private val SQL_IMPLICITLY_INSERT_PARTIES =\n-    \"\"\"insert into parties(party, explicit, ledger_offset)\n-        |values({name}, {explicit}, {ledger_offset})\n-        |on conflict (party)\n-        |do nothing\n-        |\"\"\".stripMargin\n+    dbType match {\n+      case Postgres =>\n+        \"\"\"insert into parties(party, explicit, ledger_offset)\n+          |values({name}, {explicit}, {ledger_offset})\n+          |on conflict (party)\n+          |do nothing\"\"\".stripMargin\n+      case H2Database =>\n+        \"\"\"insert into parties(party, explicit, ledger_offset)\n+          |select {name}, {explicit}, {ledger_offset}\n+          |where {name} not in (select party from parties)\"\"\".stripMargin\n+    }\n+\n+  private val DUPLICATE_KEY_ERROR ="
  },
  {
    "id" : "60a0c718-dad1-4421-b7b9-2bf32403c876",
    "prId" : 2425,
    "comments" : [
      {
        "id" : "a7712cd6-7740-4aa5-9919-07a12e2e5666",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "To clarify my previous comment, I would make queries part of the implementation of this trait.",
        "createdAt" : "2019-08-23T15:28:56Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "00795358-834f-4e4f-8874-abe6cd230e7f",
        "parentId" : "a7712cd6-7740-4aa5-9919-07a12e2e5666",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The downside of this is that many queries will be duplicated, and modifying a query in a DB-specific trait makes it easy to not modify the respective query in all the other traits.",
        "createdAt" : "2019-08-26T07:15:05Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1ab8febf-a38c-47be-94fa-213c312db9cb",
        "parentId" : "a7712cd6-7740-4aa5-9919-07a12e2e5666",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "For reference, I initially started out on the inheritance approach which duplicated a lot of code: https://github.com/digital-asset/daml/commit/754fd7b60985325571850c65c28171d35242d1a4#diff-3c124d60ef536a91fb6039a3d6b350aa and got worried about the maintainability of multiple DAOs.\r\n\r\nBut we should be able to come up with something more scoped, i.e. only overriding \"non-standard\" SQL statements. Let me take a stab at this and see how this turns out. This may be what @stefanobaghino-da means too.\r\n\r\nAnother alternative could be to try to avoid Postgres-special syntax. For the \"on conflict .. do nothing\" this can mean standardizing on the H2db approach of adding a where clause filter to achieve the same effect. I did not do so since I was worried about causing perf regressions on the Postgres side. This would turn\r\n\r\n```\r\n  private val SQL_INSERT_PACKAGE =\r\n    dbType match {\r\n      case Postgres =>\r\n        \"\"\"insert into packages(package_id, upload_id, source_description, size, known_since, ledger_offset, package)\r\n          |select {package_id}, {upload_id}, {source_description}, {size}, {known_since}, ledger_end, {package}\r\n          |from parameters\r\n          |on conflict (package_id) do nothing\r\n          |\"\"\".stripMargin\r\n      case H2Database =>\r\n        \"\"\"insert into packages(package_id, upload_id, source_description, size, known_since, ledger_offset, package)\r\n          |select {package_id}, {upload_id}, {source_description}, {size}, {known_since}, ledger_end, {package}\r\n          |from parameters\r\n          |where {package_id} not in (select package_id from packages)\r\n          |\"\"\".stripMargin\r\n    }\r\n```\r\n\r\nto:\r\n\r\n```\r\n  private val SQL_INSERT_PACKAGE =\r\n    \"\"\"insert into packages(package_id, upload_id, source_description, size, known_since, ledger_offset, package)\r\n      |select {package_id}, {upload_id}, {source_description}, {size}, {known_since}, ledger_end, {package}\r\n      |from parameters\r\n      |where {package_id} not in (select package_id from packages)\"\"\".stripMargin\r\n```",
        "createdAt" : "2019-08-26T07:34:34Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1e94ce0b-feaf-462f-8970-94ffbf5aab78",
        "parentId" : "a7712cd6-7740-4aa5-9919-07a12e2e5666",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "@stefanobaghino-da , I moved the Statement overrides into the trait. Please take a look at https://github.com/digital-asset/daml/pull/2425/commits/87be58d48544dab10c8d9432ae925aa773580725",
        "createdAt" : "2019-08-26T08:55:59Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "781ab58c-9a24-4782-9f86-2eb7c0ce2817",
        "parentId" : "a7712cd6-7740-4aa5-9919-07a12e2e5666",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Yeah, I prefer this approach much more, thanks.",
        "createdAt" : "2019-08-26T09:24:35Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a688e2ca-12e3-43f8-a740-f8abc67d67dd",
        "parentId" : "a7712cd6-7740-4aa5-9919-07a12e2e5666",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I've added a single comment on that commit, feel free to fulfill the requirement or disregard it, it's not that important.",
        "createdAt" : "2019-08-26T09:25:09Z",
        "updatedAt" : "2019-08-28T11:21:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1fee0715b6e5ad68a7c644fcc1d5e65f71f5a8ed",
    "line" : 163,
    "diffHunk" : "@@ -1127,17 +1168,30 @@ private class PostgresLedgerDao(\n \n }\n \n-object PostgresLedgerDao {\n+object JdbcLedgerDao {\n   def apply(\n       dbDispatcher: DbDispatcher,\n       contractSerializer: ContractSerializer,\n       transactionSerializer: TransactionSerializer,\n       valueSerializer: ValueSerializer,\n-      keyHasher: KeyHasher): LedgerDao =\n-    new PostgresLedgerDao(\n+      keyHasher: KeyHasher,\n+      dbType: JdbcLedgerDao.DbType): LedgerDao =\n+    new JdbcLedgerDao(\n       dbDispatcher,\n       contractSerializer,\n       transactionSerializer,\n       valueSerializer,\n-      keyHasher)\n+      keyHasher,\n+      dbType)\n+\n+  sealed trait DbType {"
  }
]