[
  {
    "id" : "ad45effa-fa60-49e8-bb64-cc4e1a49d6ff",
    "prId" : 802,
    "comments" : [
      {
        "id" : "a03838d4-152d-4dcd-8f34-beb4ae63e6b7",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please also use `transactionPipeline` in this method, so the offset is handled here properly as well.",
        "createdAt" : "2019-05-02T08:50:07Z",
        "updatedAt" : "2019-05-02T12:16:13Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1477fe1f-9091-4c1a-9f62-a65632262cb5",
        "parentId" : "a03838d4-152d-4dcd-8f34-beb4ae63e6b7",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "good catch. That logic is ultra inefficient with Postgres btw. I will create an issue to address that. ",
        "createdAt" : "2019-05-02T09:08:37Z",
        "updatedAt" : "2019-05-02T12:16:13Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c60af557-cb39-48a4-8426-0ba79d9a7643",
        "parentId" : "a03838d4-152d-4dcd-8f34-beb4ae63e6b7",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "I changed it @gerolf-da. Please take a look.",
        "createdAt" : "2019-05-02T09:19:20Z",
        "updatedAt" : "2019-05-02T12:16:13Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "759cd2a4da914f1a5d19588e3d55225ad0c688dd",
    "line" : 103,
    "diffHunk" : "@@ -173,50 +178,6 @@ class SandboxTransactionService private (val ledgerBackend: LedgerBackend, paral\n   override lazy val offsetOrdering: Ordering[LedgerOffset.Absolute] =\n     Ordering.by(abs => BigInt(abs.value))\n \n-  private def runTransactionPipeline(\n-      requestingParties: List[Party],\n-      begin: LedgerOffset,\n-      end: Option[LedgerOffset]): Source[AcceptedTransaction, NotUsed] = {\n-\n-    Source.fromFuture(ledgerBackend.getCurrentLedgerEnd).flatMapConcat { ledgerEnd =>\n-      OffsetSection(begin, end)(getOffsetHelper(ledgerEnd)) match {\n-        case Failure(exception) => Source.failed(exception)\n-        case Success(value) =>\n-          value match {\n-            case OffsetSection.Empty => Source.empty\n-            case OffsetSection.NonEmpty(subscribeFrom, subscribeUntil) =>\n-              ledgerBackend\n-                .ledgerSyncEvents(Some(subscribeFrom))\n-                .takeWhile(\n-                  {\n-                    case item =>\n-                      // the offset we get from LedgerBackend is the actual offset of the entry. We need to return the next one\n-                      // however on the API so clients can resubscribe with the received offset without getting duplicates\n-                      subscribeUntil.fold(true)(until => until != (item.offset.toLong + 1).toString)\n-                  },\n-                  inclusive = true\n-                )\n-                .collect {\n-                  case t: AcceptedTransaction => t.copy(offset = (t.offset.toLong + 1).toString)\n-                } //again, returning the next offset one\n-          }\n-      }\n-    }\n-  }\n-\n-  private def getOffsetHelper(ledgerEnd: String) = {\n-    new OffsetHelper[String] {\n-      override def fromOpaque(opaque: String): Try[String] = Success(opaque)\n-\n-      override def getLedgerBeginning(): String = \"0\"\n-\n-      override def getLedgerEnd(): String = ledgerEnd\n-\n-      override def compare(o1: String, o2: String): Int =\n-        java.lang.Long.compare(o1.toLong, o2.toLong)\n-    }\n-  }\n-\n   private def lookUpByTransactionId("
  }
]