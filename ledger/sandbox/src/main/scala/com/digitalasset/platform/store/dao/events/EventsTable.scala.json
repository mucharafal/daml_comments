[
  {
    "id" : "3cc4826c-4c3a-49df-8b6b-84bb8a956243",
    "prId" : 6782,
    "comments" : [
      {
        "id" : "e886b25e-9f46-4b1e-88b6-fffb94d04551",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n            offset = \"\", // only the last response will have an offset.\r\n```",
        "createdAt" : "2020-07-17T13:31:06Z",
        "updatedAt" : "2020-07-17T15:54:15Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0d9f8a73-3e06-4dac-93f4-1af6c00019e1",
        "parentId" : "e886b25e-9f46-4b1e-88b6-fffb94d04551",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "See 94da15c.",
        "createdAt" : "2020-07-17T15:54:51Z",
        "updatedAt" : "2020-07-17T15:54:51Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "37d073f6e3bbc3340e8e4215d470126f6f187e7f",
    "line" : null,
    "diffHunk" : "@@ -90,7 +90,7 @@ private[events] object EventsTable\n       events.map {\n         case entry if entry.event.isCreated =>\n           GetActiveContractsResponse(\n-            offset = ApiOffset.toApiString(entry.eventOffset),\n+            offset = \"\", // settings this explicitly to an empty string because only the last response will have an offset."
  },
  {
    "id" : "0fdfee4e-d097-42bf-a477-fe4b52e78455",
    "prId" : 5917,
    "comments" : [
      {
        "id" : "5162e5cd-1110-43a7-864b-cbbf4633c897",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Inconsistent formatting.",
        "createdAt" : "2020-05-08T17:53:11Z",
        "updatedAt" : "2020-05-08T18:55:14Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9dd57bc7-2583-4aca-8b1d-f06ac91a1d9a",
        "parentId" : "5162e5cd-1110-43a7-864b-cbbf4633c897",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5917/commits/d60c0309b379ff33145a608db55129beb8db7fbf",
        "createdAt" : "2020-05-08T18:55:39Z",
        "updatedAt" : "2020-05-08T18:55:39Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b924b0df2cdd7cf19f2aa64e3afdcc719f4fc149",
    "line" : null,
    "diffHunk" : "@@ -55,13 +53,42 @@ private[events] trait EventsTable {\n \n   object Entry {\n \n+    private def deserialize[E](\n+        rawEntries: Vector[Entry[Raw[E]]],\n+        verbose: Boolean,\n+        timer: Timer,\n+    ): Vector[Entry[E]] =\n+      Timed.value(\n+        timer,\n+        rawEntries.map(entry => entry.copy(event = entry.event.applyDeserialization(verbose))))"
  },
  {
    "id" : "9ad1f26b-6975-4eda-8132-40cce44ca72f",
    "prId" : 5917,
    "comments" : [
      {
        "id" : "f409fe94-9223-4250-a667-86d8e265eb96",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Intermediate collection, is this avoidable?",
        "createdAt" : "2020-05-08T17:54:49Z",
        "updatedAt" : "2020-05-08T18:55:14Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "13ce2a22-d2cf-4def-a358-b4d3fdf3ac29",
        "parentId" : "f409fe94-9223-4250-a667-86d8e265eb96",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5917/commits/86c7d7dfba472df0384b8c3d90fb7e793832d8f9",
        "createdAt" : "2020-05-08T18:55:50Z",
        "updatedAt" : "2020-05-08T18:55:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b924b0df2cdd7cf19f2aa64e3afdcc719f4fc149",
    "line" : null,
    "diffHunk" : "@@ -55,13 +53,42 @@ private[events] trait EventsTable {\n \n   object Entry {\n \n+    private def deserialize[E](\n+        rawEntries: Vector[Entry[Raw[E]]],\n+        verbose: Boolean,\n+        timer: Timer,\n+    ): Vector[Entry[E]] =\n+      Timed.value(\n+        timer,\n+        rawEntries.map(entry => entry.copy(event = entry.event.applyDeserialization(verbose))))\n+\n     private def instantToTimestamp(t: Instant): Timestamp =\n       Timestamp(seconds = t.getEpochSecond, nanos = t.getNano)\n \n-    private def flatTransaction(events: Seq[Entry[Event]]): Option[ApiTransaction] =\n+    private def permanent(entries: Vector[Entry[Raw.FlatEvent]]): Set[String] = {\n+      entries.foldLeft(Set.empty[String]) { (contractIds, entry) =>\n+        if (entry.event.isCreated || !contractIds.contains(entry.event.contractId)) {\n+          contractIds + entry.event.contractId\n+        } else {\n+          contractIds - entry.event.contractId\n+        }\n+      }\n+    }\n+\n+    private def removeTransient(\n+        entries: Vector[Entry[Raw.FlatEvent]]): Vector[Entry[Raw.FlatEvent]] = {\n+      val toKeep = permanent(entries)\n+      entries.filter(entry => toKeep(entry.event.contractId))\n+    }\n+\n+    private def flatTransaction(\n+        events: Vector[Entry[Raw.FlatEvent]],\n+        verbose: Boolean,\n+        deserializationTimer: Timer,\n+    ): Option[ApiTransaction] =\n       events.headOption.flatMap { first =>\n-        val flatEvents =\n-          TransactionConversion.removeTransient(events.iterator.map(_.event).toVector)\n+        val withoutTransients = removeTransient(events)\n+        val flatEvents = deserialize(withoutTransients, verbose, deserializationTimer).map(_.event)"
  },
  {
    "id" : "8a87243c-b249-4d03-90ea-df2e60d3df30",
    "prId" : 5331,
    "comments" : [
      {
        "id" : "86a6ffc2-4b95-497c-9355-c054f4b2f3b7",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Hm, seems like `transactionTree` has a built-in mechanism for what is effectively `Option#map`. Why not return `Option[ApiTransactionTree]` and let the caller do the mapping?\r\nThe caller would use it like `transactionTree(events).map(tx => GetTransactionResponse(Some(tx)))`.\r\nNot a big deal, but would replace some \"special\" code with a well known concept of the scala stdlib.",
        "createdAt" : "2020-04-01T09:48:24Z",
        "updatedAt" : "2020-04-01T09:51:13Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cb393dce-86c0-45f5-8185-948c28dfbccf",
        "parentId" : "86a6ffc2-4b95-497c-9355-c054f4b2f3b7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Makes sense, thanks, do you mind if I do it in the follow-up PR? It's almost ready. :slightly_smiling_face: ",
        "createdAt" : "2020-04-01T09:53:13Z",
        "updatedAt" : "2020-04-01T09:53:13Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a9de805e-4931-42f1-8c51-c08493ef5f39",
        "parentId" : "86a6ffc2-4b95-497c-9355-c054f4b2f3b7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5346/commits/5cef040718d07428092f4a959ae5e76027830ed4",
        "createdAt" : "2020-04-01T14:35:06Z",
        "updatedAt" : "2020-04-01T14:35:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "485206a07de779f8720982a0b271eca7ceb27c78",
    "line" : 41,
    "diffHunk" : "@@ -137,6 +118,37 @@ private[events] trait EventsTable {\n \n     }\n \n+    private def transactionTree[R](makeResponse: ApiTransactionTree => R)("
  },
  {
    "id" : "f2c6e7f4-c1ae-44b4-a9a4-8bac98c77b8f",
    "prId" : 5187,
    "comments" : [
      {
        "id" : "b77727fc-d29f-4521-9d63-20e61d5a655a",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This seems totally unnnnnnnnnnnecessary.",
        "createdAt" : "2020-03-25T16:32:03Z",
        "updatedAt" : "2020-03-25T16:57:47Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c2140b0c-05b7-4778-8249-bc1fe2bfce5e",
        "parentId" : "b77727fc-d29f-4521-9d63-20e61d5a655a",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Indeed, probably a leftover while moving code around, thanks. Addressed by https://github.com/digital-asset/daml/pull/5187/commits/d3d7540935cb4a71dead935e287d3145a3ef4233",
        "createdAt" : "2020-03-25T16:58:12Z",
        "updatedAt" : "2020-03-25T16:58:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d3d7540935cb4a71dead935e287d3145a3ef4233",
    "line" : null,
    "diffHunk" : "@@ -59,14 +60,16 @@ private[events] trait EventsTable {\n     private def instantToTimestamp(t: Instant): Timestamp =\n       Timestamp(seconds = t.getEpochSecond, nanos = t.getNano)\n \n-    def toFlatTransaction(events: List[Entry[Event]]): Option[GetFlatTransactionResponse] = {\n+    private def flatTransaction[R](makeResponse: ApiTransaction => R)(\n+        events: Seq[Entry[Event]],\n+    ): Option[R] =\n       events.headOption.flatMap { first =>\n-        val flatEvents =\n-          TransactionConversion.removeTransient(events.iterator.map(_.event).toVector)\n-        if (flatEvents.nonEmpty || first.commandId.nonEmpty)\n-          Some(\n-            GetFlatTransactionResponse(\n-              transaction = Some(\n+        {"
  },
  {
    "id" : "e74b1218-bf80-46e1-bb0c-0f4896f534b7",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "2aedfd52-525a-4b9a-a335-b43ca7f49a75",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Considering the query, this can be just `str`, otherwise we have a redundant `getOrElse` both in the query and in the mapping.",
        "createdAt" : "2020-03-19T16:25:24Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0ec4a28f-1136-4f67-9f39-a6b9fe94b4d6",
        "parentId" : "2aedfd52-525a-4b9a-a335-b43ca7f49a75",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm not sure that's possible. This field is `NULL` if the transaction is not local and we don't get the `commandId` from the `ReadService`.",
        "createdAt" : "2020-03-19T17:30:36Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : null,
    "diffHunk" : "@@ -6,486 +6,275 @@ package com.digitalasset.platform.store.dao.events\n import java.io.InputStream\n import java.util.Date\n \n-import anorm.{\n-  BatchSql,\n-  NamedParameter,\n-  Row,\n-  RowParser,\n-  SimpleSql,\n-  SqlParser,\n-  SqlStringInterpolation,\n-  ~\n-}\n+import anorm.{RowParser, ~}\n+import anorm.SqlParser.{array, binaryStream, bool, date, get, str}\n import com.daml.ledger.participant.state.v1.Offset\n import com.digitalasset.daml.lf.data.Ref.QualifiedName\n-import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event}\n+import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event, ExercisedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.{\n+  TreeEvent,\n+  Transaction => ApiTransaction,\n+  TransactionTree => ApiTransactionTree\n+}\n+import com.digitalasset.ledger.api.v1.transaction_service.{\n+  GetFlatTransactionResponse,\n+  GetTransactionResponse\n+}\n import com.digitalasset.ledger.api.v1.value.Identifier\n-import com.digitalasset.ledger.{ApplicationId, CommandId, TransactionId, WorkflowId}\n-import com.digitalasset.platform.events.EventIdFormatter.fromTransactionId\n+import com.digitalasset.platform.ApiOffset\n+import com.digitalasset.platform.api.v1.event.EventOps.TreeEventOps\n+import com.digitalasset.platform.index.TransactionConversion\n import com.digitalasset.platform.participant.util.LfEngineToApi\n-import com.digitalasset.platform.store.Conversions._\n-import com.digitalasset.platform.store.serialization.ValueSerializer\n-import com.digitalasset.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+import com.digitalasset.platform.store.Conversions.offset\n+import com.digitalasset.platform.store.serialization.ValueSerializer.{\n+  deserializeValue => deserialize\n+}\n+import com.google.protobuf.timestamp.Timestamp\n \n /**\n   * Data access object for a table representing raw transactions nodes that\n   * are going to be streamed off through the Ledger API. By joining these items\n   * with a [[WitnessesTable]] events can be filtered based on their visibility to\n   * a party.\n   */\n-private[events] object EventsTable {\n+private[events] object EventsTable\n+    extends EventsTable\n+    with EventsTableInsert\n+    with EventsTableFlatEvents\n+    with EventsTableTreeEvents\n \n-  private def cantSerialize(attribute: String, forContract: ContractId): String =\n-    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+private[events] trait EventsTable {\n \n-  private def serializeCreateArgOrThrow(node: Create): Array[Byte] =\n-    serialize(\n-      value = node.coinst.arg,\n-      errorContext = cantSerialize(attribute = \"create argument\", forContract = node.coid),\n-    )\n+  case class Entry[E](\n+      eventOffset: Offset,\n+      transactionId: String,\n+      ledgerEffectiveTime: Date,\n+      commandId: String,\n+      workflowId: String,\n+      event: E,\n+  )\n \n-  private def serializeNullableKeyOrThrow(node: Create): Option[Array[Byte]] =\n-    node.key.map(\n-      k =>\n-        serialize(\n-          value = k.key,\n-          errorContext = cantSerialize(attribute = \"key\", forContract = node.coid),\n-      ))\n+  object Entry {\n \n-  private def serializeExerciseArgOrThrow(node: Exercise): Array[Byte] =\n-    serialize(\n-      value = node.chosenValue,\n-      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = node.targetCoid),\n-    )\n+    def toFlatTransaction(events: List[Entry[Event]]): Option[GetFlatTransactionResponse] = {\n+      events.headOption.flatMap { first =>\n+        val flatEvents =\n+          TransactionConversion.removeTransient(events.iterator.map(_.event).toVector)\n+        if (flatEvents.nonEmpty || first.commandId.nonEmpty)\n+          Some(\n+            GetFlatTransactionResponse(\n+              transaction = Some(\n+                ApiTransaction(\n+                  transactionId = first.transactionId,\n+                  commandId = first.commandId,\n+                  effectiveAt =\n+                    Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),\n+                  workflowId = first.workflowId,\n+                  offset = ApiOffset.toApiString(first.eventOffset),\n+                  events = flatEvents,\n+                )\n+              )\n+            )\n+          )\n+        else None\n \n-  private def serializeNullableExerciseResultOrThrow(node: Exercise): Option[Array[Byte]] =\n-    node.exerciseResult.map(exerciseResult =>\n-      serialize(\n-        value = exerciseResult,\n-        errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n-    ))\n+      }\n+    }\n \n-  private val insertCreate: String =\n-    \"\"\"insert into participant_events(\n-          |  event_id,\n-          |  event_offset,\n-          |  contract_id,\n-          |  transaction_id,\n-          |  workflow_id,\n-          |  ledger_effective_time,\n-          |  template_package_id,\n-          |  template_name,\n-          |  node_index,\n-          |  is_root,\n-          |  command_id,\n-          |  application_id,\n-          |  submitter,\n-          |  create_argument,\n-          |  create_signatories,\n-          |  create_observers,\n-          |  create_agreement_text,\n-          |  create_consumed_at,\n-          |  create_key_value\n-          |) values (\n-          |  {event_id},\n-          |  {event_offset},\n-          |  {contract_id},\n-          |  {transaction_id},\n-          |  {workflow_id},\n-          |  {ledger_effective_time},\n-          |  {template_package_id},\n-          |  {template_name},\n-          |  {node_index},\n-          |  {is_root},\n-          |  {command_id},\n-          |  {application_id},\n-          |  {submitter},\n-          |  {create_argument},\n-          |  {create_signatories},\n-          |  {create_observers},\n-          |  {create_agreement_text},\n-          |  null,\n-          |  {create_key_value}\n-          |)\n-          |\"\"\".stripMargin\n+    def toTransactionTree(events: List[Entry[TreeEvent]]): Option[GetTransactionResponse] =\n+      events.headOption.map(\n+        first => {\n+          val (eventsById, rootEventIds) = treeOf(events)\n+          GetTransactionResponse(\n+            transaction = Some(\n+              ApiTransactionTree(\n+                transactionId = first.transactionId,\n+                commandId = first.commandId,\n+                workflowId = first.workflowId,\n+                effectiveAt =\n+                  Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),\n+                offset = ApiOffset.toApiString(first.eventOffset),\n+                eventsById = eventsById,\n+                rootEventIds = rootEventIds,\n+                traceContext = None,\n+              ))\n+          )\n+        }\n+      )\n \n-  private def create(\n-      applicationId: Option[ApplicationId],\n-      workflowId: Option[WorkflowId],\n-      commandId: Option[CommandId],\n-      transactionId: TransactionId,\n-      nodeId: NodeId,\n-      submitter: Option[Party],\n-      roots: Set[NodeId],\n-      ledgerEffectiveTime: Date,\n-      offset: Offset,\n-      create: Create,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n-      \"event_offset\" -> offset,\n-      \"contract_id\" -> create.coid.coid.toString,\n-      \"transaction_id\" -> transactionId.toString,\n-      \"workflow_id\" -> workflowId.map(_.toString),\n-      \"ledger_effective_time\" -> ledgerEffectiveTime,\n-      \"template_package_id\" -> create.coinst.template.packageId.toString,\n-      \"template_name\" -> create.coinst.template.qualifiedName.toString,\n-      \"node_index\" -> nodeId.index,\n-      \"is_root\" -> roots(nodeId),\n-      \"command_id\" -> commandId.map(_.toString),\n-      \"application_id\" -> applicationId.map(_.toString),\n-      \"submitter\" -> submitter.map(_.toString),\n-      \"create_argument\" -> serializeCreateArgOrThrow(create),\n-      \"create_signatories\" -> create.signatories.map(_.toString).toArray,\n-      \"create_observers\" -> create.stakeholders.diff(create.signatories).map(_.toString).toArray,\n-      \"create_agreement_text\" -> Some(create.coinst.agreementText).filter(_.nonEmpty),\n-      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n-    )\n+    private def treeOf(events: List[Entry[TreeEvent]]): (Map[String, TreeEvent], Seq[String]) = {\n \n-  private val insertExercise =\n-    \"\"\"insert into participant_events(\n-          |  event_id,\n-          |  event_offset,\n-          |  contract_id,\n-          |  transaction_id,\n-          |  workflow_id,\n-          |  ledger_effective_time,\n-          |  template_package_id,\n-          |  template_name,\n-          |  node_index,\n-          |  is_root,\n-          |  command_id,\n-          |  application_id,\n-          |  submitter,\n-          |  exercise_consuming,\n-          |  exercise_choice,\n-          |  exercise_argument,\n-          |  exercise_result,\n-          |  exercise_actors,\n-          |  exercise_child_event_ids\n-          |) values (\n-          |  {event_id},\n-          |  {event_offset},\n-          |  {contract_id},\n-          |  {transaction_id},\n-          |  {workflow_id},\n-          |  {ledger_effective_time},\n-          |  {template_package_id},\n-          |  {template_name},\n-          |  {node_index},\n-          |  {is_root},\n-          |  {command_id},\n-          |  {application_id},\n-          |  {submitter},\n-          |  {exercise_consuming},\n-          |  {exercise_choice},\n-          |  {exercise_argument},\n-          |  {exercise_result},\n-          |  {exercise_actors},\n-          |  {exercise_child_event_ids}\n-          |)\n-          |\"\"\".stripMargin\n+      // Get all the visible events in this transactions to filter children in each event\n+      val visible = events.iterator.map(_.event.eventId).toSet\n \n-  private def exercise(\n-      applicationId: Option[ApplicationId],\n-      workflowId: Option[WorkflowId],\n-      commandId: Option[CommandId],\n-      transactionId: TransactionId,\n-      nodeId: NodeId,\n-      submitter: Option[Party],\n-      roots: Set[NodeId],\n-      ledgerEffectiveTime: Date,\n-      offset: Offset,\n-      exercise: Exercise,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n-      \"event_offset\" -> offset,\n-      \"contract_id\" -> exercise.targetCoid.coid.toString,\n-      \"transaction_id\" -> transactionId.toString,\n-      \"workflow_id\" -> workflowId.map(_.toString),\n-      \"ledger_effective_time\" -> ledgerEffectiveTime,\n-      \"template_package_id\" -> exercise.templateId.packageId.toString,\n-      \"template_name\" -> exercise.templateId.qualifiedName.toString,\n-      \"node_index\" -> nodeId.index,\n-      \"is_root\" -> roots(nodeId),\n-      \"command_id\" -> commandId.map(_.toString),\n-      \"application_id\" -> applicationId.map(_.toString),\n-      \"submitter\" -> submitter.map(_.toString),\n-      \"exercise_consuming\" -> exercise.consuming,\n-      \"exercise_choice\" -> exercise.choiceId.toString,\n-      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n-      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n-      \"exercise_actors\" -> exercise.actingParties.map(_.toString).toArray,\n-      \"exercise_child_event_ids\" -> exercise.children\n-        .map(fromTransactionId(transactionId, _): String)\n-        .toArray,\n-    )\n+      // All events in this transaction by their identifier, with their children\n+      // filtered according to those visible for this request\n+      val eventsById =\n+        events.iterator.map(r => r.event.eventId -> r.event.filterChildEventIds(visible)).toMap\n \n-  private val updateArchived =\n-    \"\"\"update participant_events set create_consumed_at={consumed_at} where contract_id={contract_id}\"\"\"\n+      // Roots are all the visible events in this transaction\n+      // that don't appear in any event's children\n+      val rootEventIds =\n+        visible.diff(eventsById.valuesIterator.flatMap(_.childEventIds).toSet).toSeq\n \n-  private def archive(\n-      contractId: ContractId,\n-      consumedAt: Offset,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"consumed_at\" -> consumedAt,\n-      \"contract_id\" -> contractId.coid.toString,\n-    )\n+      (eventsById, rootEventIds)\n \n-  sealed abstract case class PreparedBatches(\n-      creates: Option[BatchSql],\n-      exercises: Option[BatchSql],\n-      archives: Option[BatchSql],\n-  ) {\n-    final def isEmpty: Boolean = creates.isEmpty && exercises.isEmpty && archives.isEmpty\n-    final def foreach[U](f: BatchSql => U): Unit = {\n-      creates.foreach(f)\n-      exercises.foreach(f)\n-      archives.foreach(f)\n     }\n-  }\n \n-  private final case class AccumulatingBatches(\n-      creates: Vector[Vector[NamedParameter]],\n-      exercises: Vector[Vector[NamedParameter]],\n-      archives: Vector[Vector[NamedParameter]],\n-  ) {\n-\n-    def addCreate(create: Vector[NamedParameter]): AccumulatingBatches =\n-      copy(creates = creates :+ create)\n-\n-    def addExercise(exercise: Vector[NamedParameter]): AccumulatingBatches =\n-      copy(exercises = exercises :+ exercise)\n+  }\n \n-    def addArchive(archive: Vector[NamedParameter]): AccumulatingBatches =\n-      copy(archives = archives :+ archive)\n+  private type SharedRow =\n+    Offset ~ String ~ String ~ String ~ Date ~ String ~ String ~ Option[String] ~ Option[String] ~ Array[\n+      String]\n+  private val sharedRow: RowParser[SharedRow] =\n+    offset(\"event_offset\") ~\n+      str(\"transaction_id\") ~\n+      str(\"event_id\") ~\n+      str(\"contract_id\") ~\n+      date(\"ledger_effective_time\") ~\n+      str(\"template_package_id\") ~\n+      str(\"template_name\") ~\n+      get[Option[String]](\"command_id\") ~"
  },
  {
    "id" : "507164d7-e0aa-4ae1-a000-605fb3c46e30",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "5dbc2456-8977-4268-a5ef-69a87e227519",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "You could write this as `str(\"workflow_id\").?`, but I guess you're not a fan of the `?`?",
        "createdAt" : "2020-03-19T16:26:49Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "05f5b6d4-a5fa-4f25-aff6-09c0293d0ae7",
        "parentId" : "5dbc2456-8977-4268-a5ef-69a87e227519",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm a fan, I just forgot about it. Thanks!",
        "createdAt" : "2020-03-19T17:31:00Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6e256d8e-6636-431d-ab82-70df0335c17c",
        "parentId" : "5dbc2456-8977-4268-a5ef-69a87e227519",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5089/commits/20b31325b05ac203ae029e2c86b29c026ff66ce6",
        "createdAt" : "2020-03-19T20:10:30Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : null,
    "diffHunk" : "@@ -6,486 +6,275 @@ package com.digitalasset.platform.store.dao.events\n import java.io.InputStream\n import java.util.Date\n \n-import anorm.{\n-  BatchSql,\n-  NamedParameter,\n-  Row,\n-  RowParser,\n-  SimpleSql,\n-  SqlParser,\n-  SqlStringInterpolation,\n-  ~\n-}\n+import anorm.{RowParser, ~}\n+import anorm.SqlParser.{array, binaryStream, bool, date, get, str}\n import com.daml.ledger.participant.state.v1.Offset\n import com.digitalasset.daml.lf.data.Ref.QualifiedName\n-import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event}\n+import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event, ExercisedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.{\n+  TreeEvent,\n+  Transaction => ApiTransaction,\n+  TransactionTree => ApiTransactionTree\n+}\n+import com.digitalasset.ledger.api.v1.transaction_service.{\n+  GetFlatTransactionResponse,\n+  GetTransactionResponse\n+}\n import com.digitalasset.ledger.api.v1.value.Identifier\n-import com.digitalasset.ledger.{ApplicationId, CommandId, TransactionId, WorkflowId}\n-import com.digitalasset.platform.events.EventIdFormatter.fromTransactionId\n+import com.digitalasset.platform.ApiOffset\n+import com.digitalasset.platform.api.v1.event.EventOps.TreeEventOps\n+import com.digitalasset.platform.index.TransactionConversion\n import com.digitalasset.platform.participant.util.LfEngineToApi\n-import com.digitalasset.platform.store.Conversions._\n-import com.digitalasset.platform.store.serialization.ValueSerializer\n-import com.digitalasset.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+import com.digitalasset.platform.store.Conversions.offset\n+import com.digitalasset.platform.store.serialization.ValueSerializer.{\n+  deserializeValue => deserialize\n+}\n+import com.google.protobuf.timestamp.Timestamp\n \n /**\n   * Data access object for a table representing raw transactions nodes that\n   * are going to be streamed off through the Ledger API. By joining these items\n   * with a [[WitnessesTable]] events can be filtered based on their visibility to\n   * a party.\n   */\n-private[events] object EventsTable {\n+private[events] object EventsTable\n+    extends EventsTable\n+    with EventsTableInsert\n+    with EventsTableFlatEvents\n+    with EventsTableTreeEvents\n \n-  private def cantSerialize(attribute: String, forContract: ContractId): String =\n-    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+private[events] trait EventsTable {\n \n-  private def serializeCreateArgOrThrow(node: Create): Array[Byte] =\n-    serialize(\n-      value = node.coinst.arg,\n-      errorContext = cantSerialize(attribute = \"create argument\", forContract = node.coid),\n-    )\n+  case class Entry[E](\n+      eventOffset: Offset,\n+      transactionId: String,\n+      ledgerEffectiveTime: Date,\n+      commandId: String,\n+      workflowId: String,\n+      event: E,\n+  )\n \n-  private def serializeNullableKeyOrThrow(node: Create): Option[Array[Byte]] =\n-    node.key.map(\n-      k =>\n-        serialize(\n-          value = k.key,\n-          errorContext = cantSerialize(attribute = \"key\", forContract = node.coid),\n-      ))\n+  object Entry {\n \n-  private def serializeExerciseArgOrThrow(node: Exercise): Array[Byte] =\n-    serialize(\n-      value = node.chosenValue,\n-      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = node.targetCoid),\n-    )\n+    def toFlatTransaction(events: List[Entry[Event]]): Option[GetFlatTransactionResponse] = {\n+      events.headOption.flatMap { first =>\n+        val flatEvents =\n+          TransactionConversion.removeTransient(events.iterator.map(_.event).toVector)\n+        if (flatEvents.nonEmpty || first.commandId.nonEmpty)\n+          Some(\n+            GetFlatTransactionResponse(\n+              transaction = Some(\n+                ApiTransaction(\n+                  transactionId = first.transactionId,\n+                  commandId = first.commandId,\n+                  effectiveAt =\n+                    Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),\n+                  workflowId = first.workflowId,\n+                  offset = ApiOffset.toApiString(first.eventOffset),\n+                  events = flatEvents,\n+                )\n+              )\n+            )\n+          )\n+        else None\n \n-  private def serializeNullableExerciseResultOrThrow(node: Exercise): Option[Array[Byte]] =\n-    node.exerciseResult.map(exerciseResult =>\n-      serialize(\n-        value = exerciseResult,\n-        errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n-    ))\n+      }\n+    }\n \n-  private val insertCreate: String =\n-    \"\"\"insert into participant_events(\n-          |  event_id,\n-          |  event_offset,\n-          |  contract_id,\n-          |  transaction_id,\n-          |  workflow_id,\n-          |  ledger_effective_time,\n-          |  template_package_id,\n-          |  template_name,\n-          |  node_index,\n-          |  is_root,\n-          |  command_id,\n-          |  application_id,\n-          |  submitter,\n-          |  create_argument,\n-          |  create_signatories,\n-          |  create_observers,\n-          |  create_agreement_text,\n-          |  create_consumed_at,\n-          |  create_key_value\n-          |) values (\n-          |  {event_id},\n-          |  {event_offset},\n-          |  {contract_id},\n-          |  {transaction_id},\n-          |  {workflow_id},\n-          |  {ledger_effective_time},\n-          |  {template_package_id},\n-          |  {template_name},\n-          |  {node_index},\n-          |  {is_root},\n-          |  {command_id},\n-          |  {application_id},\n-          |  {submitter},\n-          |  {create_argument},\n-          |  {create_signatories},\n-          |  {create_observers},\n-          |  {create_agreement_text},\n-          |  null,\n-          |  {create_key_value}\n-          |)\n-          |\"\"\".stripMargin\n+    def toTransactionTree(events: List[Entry[TreeEvent]]): Option[GetTransactionResponse] =\n+      events.headOption.map(\n+        first => {\n+          val (eventsById, rootEventIds) = treeOf(events)\n+          GetTransactionResponse(\n+            transaction = Some(\n+              ApiTransactionTree(\n+                transactionId = first.transactionId,\n+                commandId = first.commandId,\n+                workflowId = first.workflowId,\n+                effectiveAt =\n+                  Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),\n+                offset = ApiOffset.toApiString(first.eventOffset),\n+                eventsById = eventsById,\n+                rootEventIds = rootEventIds,\n+                traceContext = None,\n+              ))\n+          )\n+        }\n+      )\n \n-  private def create(\n-      applicationId: Option[ApplicationId],\n-      workflowId: Option[WorkflowId],\n-      commandId: Option[CommandId],\n-      transactionId: TransactionId,\n-      nodeId: NodeId,\n-      submitter: Option[Party],\n-      roots: Set[NodeId],\n-      ledgerEffectiveTime: Date,\n-      offset: Offset,\n-      create: Create,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n-      \"event_offset\" -> offset,\n-      \"contract_id\" -> create.coid.coid.toString,\n-      \"transaction_id\" -> transactionId.toString,\n-      \"workflow_id\" -> workflowId.map(_.toString),\n-      \"ledger_effective_time\" -> ledgerEffectiveTime,\n-      \"template_package_id\" -> create.coinst.template.packageId.toString,\n-      \"template_name\" -> create.coinst.template.qualifiedName.toString,\n-      \"node_index\" -> nodeId.index,\n-      \"is_root\" -> roots(nodeId),\n-      \"command_id\" -> commandId.map(_.toString),\n-      \"application_id\" -> applicationId.map(_.toString),\n-      \"submitter\" -> submitter.map(_.toString),\n-      \"create_argument\" -> serializeCreateArgOrThrow(create),\n-      \"create_signatories\" -> create.signatories.map(_.toString).toArray,\n-      \"create_observers\" -> create.stakeholders.diff(create.signatories).map(_.toString).toArray,\n-      \"create_agreement_text\" -> Some(create.coinst.agreementText).filter(_.nonEmpty),\n-      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n-    )\n+    private def treeOf(events: List[Entry[TreeEvent]]): (Map[String, TreeEvent], Seq[String]) = {\n \n-  private val insertExercise =\n-    \"\"\"insert into participant_events(\n-          |  event_id,\n-          |  event_offset,\n-          |  contract_id,\n-          |  transaction_id,\n-          |  workflow_id,\n-          |  ledger_effective_time,\n-          |  template_package_id,\n-          |  template_name,\n-          |  node_index,\n-          |  is_root,\n-          |  command_id,\n-          |  application_id,\n-          |  submitter,\n-          |  exercise_consuming,\n-          |  exercise_choice,\n-          |  exercise_argument,\n-          |  exercise_result,\n-          |  exercise_actors,\n-          |  exercise_child_event_ids\n-          |) values (\n-          |  {event_id},\n-          |  {event_offset},\n-          |  {contract_id},\n-          |  {transaction_id},\n-          |  {workflow_id},\n-          |  {ledger_effective_time},\n-          |  {template_package_id},\n-          |  {template_name},\n-          |  {node_index},\n-          |  {is_root},\n-          |  {command_id},\n-          |  {application_id},\n-          |  {submitter},\n-          |  {exercise_consuming},\n-          |  {exercise_choice},\n-          |  {exercise_argument},\n-          |  {exercise_result},\n-          |  {exercise_actors},\n-          |  {exercise_child_event_ids}\n-          |)\n-          |\"\"\".stripMargin\n+      // Get all the visible events in this transactions to filter children in each event\n+      val visible = events.iterator.map(_.event.eventId).toSet\n \n-  private def exercise(\n-      applicationId: Option[ApplicationId],\n-      workflowId: Option[WorkflowId],\n-      commandId: Option[CommandId],\n-      transactionId: TransactionId,\n-      nodeId: NodeId,\n-      submitter: Option[Party],\n-      roots: Set[NodeId],\n-      ledgerEffectiveTime: Date,\n-      offset: Offset,\n-      exercise: Exercise,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n-      \"event_offset\" -> offset,\n-      \"contract_id\" -> exercise.targetCoid.coid.toString,\n-      \"transaction_id\" -> transactionId.toString,\n-      \"workflow_id\" -> workflowId.map(_.toString),\n-      \"ledger_effective_time\" -> ledgerEffectiveTime,\n-      \"template_package_id\" -> exercise.templateId.packageId.toString,\n-      \"template_name\" -> exercise.templateId.qualifiedName.toString,\n-      \"node_index\" -> nodeId.index,\n-      \"is_root\" -> roots(nodeId),\n-      \"command_id\" -> commandId.map(_.toString),\n-      \"application_id\" -> applicationId.map(_.toString),\n-      \"submitter\" -> submitter.map(_.toString),\n-      \"exercise_consuming\" -> exercise.consuming,\n-      \"exercise_choice\" -> exercise.choiceId.toString,\n-      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n-      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n-      \"exercise_actors\" -> exercise.actingParties.map(_.toString).toArray,\n-      \"exercise_child_event_ids\" -> exercise.children\n-        .map(fromTransactionId(transactionId, _): String)\n-        .toArray,\n-    )\n+      // All events in this transaction by their identifier, with their children\n+      // filtered according to those visible for this request\n+      val eventsById =\n+        events.iterator.map(r => r.event.eventId -> r.event.filterChildEventIds(visible)).toMap\n \n-  private val updateArchived =\n-    \"\"\"update participant_events set create_consumed_at={consumed_at} where contract_id={contract_id}\"\"\"\n+      // Roots are all the visible events in this transaction\n+      // that don't appear in any event's children\n+      val rootEventIds =\n+        visible.diff(eventsById.valuesIterator.flatMap(_.childEventIds).toSet).toSeq\n \n-  private def archive(\n-      contractId: ContractId,\n-      consumedAt: Offset,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"consumed_at\" -> consumedAt,\n-      \"contract_id\" -> contractId.coid.toString,\n-    )\n+      (eventsById, rootEventIds)\n \n-  sealed abstract case class PreparedBatches(\n-      creates: Option[BatchSql],\n-      exercises: Option[BatchSql],\n-      archives: Option[BatchSql],\n-  ) {\n-    final def isEmpty: Boolean = creates.isEmpty && exercises.isEmpty && archives.isEmpty\n-    final def foreach[U](f: BatchSql => U): Unit = {\n-      creates.foreach(f)\n-      exercises.foreach(f)\n-      archives.foreach(f)\n     }\n-  }\n \n-  private final case class AccumulatingBatches(\n-      creates: Vector[Vector[NamedParameter]],\n-      exercises: Vector[Vector[NamedParameter]],\n-      archives: Vector[Vector[NamedParameter]],\n-  ) {\n-\n-    def addCreate(create: Vector[NamedParameter]): AccumulatingBatches =\n-      copy(creates = creates :+ create)\n-\n-    def addExercise(exercise: Vector[NamedParameter]): AccumulatingBatches =\n-      copy(exercises = exercises :+ exercise)\n+  }\n \n-    def addArchive(archive: Vector[NamedParameter]): AccumulatingBatches =\n-      copy(archives = archives :+ archive)\n+  private type SharedRow =\n+    Offset ~ String ~ String ~ String ~ Date ~ String ~ String ~ Option[String] ~ Option[String] ~ Array[\n+      String]\n+  private val sharedRow: RowParser[SharedRow] =\n+    offset(\"event_offset\") ~\n+      str(\"transaction_id\") ~\n+      str(\"event_id\") ~\n+      str(\"contract_id\") ~\n+      date(\"ledger_effective_time\") ~\n+      str(\"template_package_id\") ~\n+      str(\"template_name\") ~\n+      get[Option[String]](\"command_id\") ~\n+      get[Option[String]](\"workflow_id\") ~"
  },
  {
    "id" : "957a78cd-e0f7-413b-b11c-c93666aff363",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "66f4e0f2-f4fb-419c-9e15-d472eb2b4756",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "`rootEventIds` need to be sorted by the corresponding `node_id`.",
        "createdAt" : "2020-03-19T16:28:48Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6e3ef43b-d76e-40fe-adb2-9910053a02f9",
        "parentId" : "66f4e0f2-f4fb-419c-9e15-d472eb2b4756",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Yes, thanks.",
        "createdAt" : "2020-03-19T17:31:27Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ca9e7ec8-6f57-434d-a879-0a852d7c54e4",
        "parentId" : "66f4e0f2-f4fb-419c-9e15-d472eb2b4756",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Since I'm already ordering by `node_index` on the database I'll change `rootEventIds` to preserve the order and use that.",
        "createdAt" : "2020-03-19T18:36:29Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "25602656-8e23-4d5e-90bc-453347accbc0",
        "parentId" : "66f4e0f2-f4fb-419c-9e15-d472eb2b4756",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5089/commits/267c5948c2d99274b1a7c3baa15e2f98b5d6b884",
        "createdAt" : "2020-03-19T20:06:13Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : 116,
    "diffHunk" : "@@ -6,486 +6,275 @@ package com.digitalasset.platform.store.dao.events\n import java.io.InputStream\n import java.util.Date\n \n-import anorm.{\n-  BatchSql,\n-  NamedParameter,\n-  Row,\n-  RowParser,\n-  SimpleSql,\n-  SqlParser,\n-  SqlStringInterpolation,\n-  ~\n-}\n+import anorm.{RowParser, ~}\n+import anorm.SqlParser.{array, binaryStream, bool, date, get, str}\n import com.daml.ledger.participant.state.v1.Offset\n import com.digitalasset.daml.lf.data.Ref.QualifiedName\n-import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event}\n+import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event, ExercisedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.{\n+  TreeEvent,\n+  Transaction => ApiTransaction,\n+  TransactionTree => ApiTransactionTree\n+}\n+import com.digitalasset.ledger.api.v1.transaction_service.{\n+  GetFlatTransactionResponse,\n+  GetTransactionResponse\n+}\n import com.digitalasset.ledger.api.v1.value.Identifier\n-import com.digitalasset.ledger.{ApplicationId, CommandId, TransactionId, WorkflowId}\n-import com.digitalasset.platform.events.EventIdFormatter.fromTransactionId\n+import com.digitalasset.platform.ApiOffset\n+import com.digitalasset.platform.api.v1.event.EventOps.TreeEventOps\n+import com.digitalasset.platform.index.TransactionConversion\n import com.digitalasset.platform.participant.util.LfEngineToApi\n-import com.digitalasset.platform.store.Conversions._\n-import com.digitalasset.platform.store.serialization.ValueSerializer\n-import com.digitalasset.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+import com.digitalasset.platform.store.Conversions.offset\n+import com.digitalasset.platform.store.serialization.ValueSerializer.{\n+  deserializeValue => deserialize\n+}\n+import com.google.protobuf.timestamp.Timestamp\n \n /**\n   * Data access object for a table representing raw transactions nodes that\n   * are going to be streamed off through the Ledger API. By joining these items\n   * with a [[WitnessesTable]] events can be filtered based on their visibility to\n   * a party.\n   */\n-private[events] object EventsTable {\n+private[events] object EventsTable\n+    extends EventsTable\n+    with EventsTableInsert\n+    with EventsTableFlatEvents\n+    with EventsTableTreeEvents\n \n-  private def cantSerialize(attribute: String, forContract: ContractId): String =\n-    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+private[events] trait EventsTable {\n \n-  private def serializeCreateArgOrThrow(node: Create): Array[Byte] =\n-    serialize(\n-      value = node.coinst.arg,\n-      errorContext = cantSerialize(attribute = \"create argument\", forContract = node.coid),\n-    )\n+  case class Entry[E](\n+      eventOffset: Offset,\n+      transactionId: String,\n+      ledgerEffectiveTime: Date,\n+      commandId: String,\n+      workflowId: String,\n+      event: E,\n+  )\n \n-  private def serializeNullableKeyOrThrow(node: Create): Option[Array[Byte]] =\n-    node.key.map(\n-      k =>\n-        serialize(\n-          value = k.key,\n-          errorContext = cantSerialize(attribute = \"key\", forContract = node.coid),\n-      ))\n+  object Entry {\n \n-  private def serializeExerciseArgOrThrow(node: Exercise): Array[Byte] =\n-    serialize(\n-      value = node.chosenValue,\n-      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = node.targetCoid),\n-    )\n+    def toFlatTransaction(events: List[Entry[Event]]): Option[GetFlatTransactionResponse] = {\n+      events.headOption.flatMap { first =>\n+        val flatEvents =\n+          TransactionConversion.removeTransient(events.iterator.map(_.event).toVector)\n+        if (flatEvents.nonEmpty || first.commandId.nonEmpty)\n+          Some(\n+            GetFlatTransactionResponse(\n+              transaction = Some(\n+                ApiTransaction(\n+                  transactionId = first.transactionId,\n+                  commandId = first.commandId,\n+                  effectiveAt =\n+                    Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),\n+                  workflowId = first.workflowId,\n+                  offset = ApiOffset.toApiString(first.eventOffset),\n+                  events = flatEvents,\n+                )\n+              )\n+            )\n+          )\n+        else None\n \n-  private def serializeNullableExerciseResultOrThrow(node: Exercise): Option[Array[Byte]] =\n-    node.exerciseResult.map(exerciseResult =>\n-      serialize(\n-        value = exerciseResult,\n-        errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n-    ))\n+      }\n+    }\n \n-  private val insertCreate: String =\n-    \"\"\"insert into participant_events(\n-          |  event_id,\n-          |  event_offset,\n-          |  contract_id,\n-          |  transaction_id,\n-          |  workflow_id,\n-          |  ledger_effective_time,\n-          |  template_package_id,\n-          |  template_name,\n-          |  node_index,\n-          |  is_root,\n-          |  command_id,\n-          |  application_id,\n-          |  submitter,\n-          |  create_argument,\n-          |  create_signatories,\n-          |  create_observers,\n-          |  create_agreement_text,\n-          |  create_consumed_at,\n-          |  create_key_value\n-          |) values (\n-          |  {event_id},\n-          |  {event_offset},\n-          |  {contract_id},\n-          |  {transaction_id},\n-          |  {workflow_id},\n-          |  {ledger_effective_time},\n-          |  {template_package_id},\n-          |  {template_name},\n-          |  {node_index},\n-          |  {is_root},\n-          |  {command_id},\n-          |  {application_id},\n-          |  {submitter},\n-          |  {create_argument},\n-          |  {create_signatories},\n-          |  {create_observers},\n-          |  {create_agreement_text},\n-          |  null,\n-          |  {create_key_value}\n-          |)\n-          |\"\"\".stripMargin\n+    def toTransactionTree(events: List[Entry[TreeEvent]]): Option[GetTransactionResponse] =\n+      events.headOption.map(\n+        first => {\n+          val (eventsById, rootEventIds) = treeOf(events)\n+          GetTransactionResponse(\n+            transaction = Some(\n+              ApiTransactionTree(\n+                transactionId = first.transactionId,\n+                commandId = first.commandId,\n+                workflowId = first.workflowId,\n+                effectiveAt =\n+                  Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),\n+                offset = ApiOffset.toApiString(first.eventOffset),\n+                eventsById = eventsById,\n+                rootEventIds = rootEventIds,\n+                traceContext = None,\n+              ))\n+          )\n+        }\n+      )\n \n-  private def create(\n-      applicationId: Option[ApplicationId],\n-      workflowId: Option[WorkflowId],\n-      commandId: Option[CommandId],\n-      transactionId: TransactionId,\n-      nodeId: NodeId,\n-      submitter: Option[Party],\n-      roots: Set[NodeId],\n-      ledgerEffectiveTime: Date,\n-      offset: Offset,\n-      create: Create,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n-      \"event_offset\" -> offset,\n-      \"contract_id\" -> create.coid.coid.toString,\n-      \"transaction_id\" -> transactionId.toString,\n-      \"workflow_id\" -> workflowId.map(_.toString),\n-      \"ledger_effective_time\" -> ledgerEffectiveTime,\n-      \"template_package_id\" -> create.coinst.template.packageId.toString,\n-      \"template_name\" -> create.coinst.template.qualifiedName.toString,\n-      \"node_index\" -> nodeId.index,\n-      \"is_root\" -> roots(nodeId),\n-      \"command_id\" -> commandId.map(_.toString),\n-      \"application_id\" -> applicationId.map(_.toString),\n-      \"submitter\" -> submitter.map(_.toString),\n-      \"create_argument\" -> serializeCreateArgOrThrow(create),\n-      \"create_signatories\" -> create.signatories.map(_.toString).toArray,\n-      \"create_observers\" -> create.stakeholders.diff(create.signatories).map(_.toString).toArray,\n-      \"create_agreement_text\" -> Some(create.coinst.agreementText).filter(_.nonEmpty),\n-      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n-    )\n+    private def treeOf(events: List[Entry[TreeEvent]]): (Map[String, TreeEvent], Seq[String]) = {\n \n-  private val insertExercise =\n-    \"\"\"insert into participant_events(\n-          |  event_id,\n-          |  event_offset,\n-          |  contract_id,\n-          |  transaction_id,\n-          |  workflow_id,\n-          |  ledger_effective_time,\n-          |  template_package_id,\n-          |  template_name,\n-          |  node_index,\n-          |  is_root,\n-          |  command_id,\n-          |  application_id,\n-          |  submitter,\n-          |  exercise_consuming,\n-          |  exercise_choice,\n-          |  exercise_argument,\n-          |  exercise_result,\n-          |  exercise_actors,\n-          |  exercise_child_event_ids\n-          |) values (\n-          |  {event_id},\n-          |  {event_offset},\n-          |  {contract_id},\n-          |  {transaction_id},\n-          |  {workflow_id},\n-          |  {ledger_effective_time},\n-          |  {template_package_id},\n-          |  {template_name},\n-          |  {node_index},\n-          |  {is_root},\n-          |  {command_id},\n-          |  {application_id},\n-          |  {submitter},\n-          |  {exercise_consuming},\n-          |  {exercise_choice},\n-          |  {exercise_argument},\n-          |  {exercise_result},\n-          |  {exercise_actors},\n-          |  {exercise_child_event_ids}\n-          |)\n-          |\"\"\".stripMargin\n+      // Get all the visible events in this transactions to filter children in each event\n+      val visible = events.iterator.map(_.event.eventId).toSet\n \n-  private def exercise(\n-      applicationId: Option[ApplicationId],\n-      workflowId: Option[WorkflowId],\n-      commandId: Option[CommandId],\n-      transactionId: TransactionId,\n-      nodeId: NodeId,\n-      submitter: Option[Party],\n-      roots: Set[NodeId],\n-      ledgerEffectiveTime: Date,\n-      offset: Offset,\n-      exercise: Exercise,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n-      \"event_offset\" -> offset,\n-      \"contract_id\" -> exercise.targetCoid.coid.toString,\n-      \"transaction_id\" -> transactionId.toString,\n-      \"workflow_id\" -> workflowId.map(_.toString),\n-      \"ledger_effective_time\" -> ledgerEffectiveTime,\n-      \"template_package_id\" -> exercise.templateId.packageId.toString,\n-      \"template_name\" -> exercise.templateId.qualifiedName.toString,\n-      \"node_index\" -> nodeId.index,\n-      \"is_root\" -> roots(nodeId),\n-      \"command_id\" -> commandId.map(_.toString),\n-      \"application_id\" -> applicationId.map(_.toString),\n-      \"submitter\" -> submitter.map(_.toString),\n-      \"exercise_consuming\" -> exercise.consuming,\n-      \"exercise_choice\" -> exercise.choiceId.toString,\n-      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n-      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n-      \"exercise_actors\" -> exercise.actingParties.map(_.toString).toArray,\n-      \"exercise_child_event_ids\" -> exercise.children\n-        .map(fromTransactionId(transactionId, _): String)\n-        .toArray,\n-    )\n+      // All events in this transaction by their identifier, with their children\n+      // filtered according to those visible for this request\n+      val eventsById =\n+        events.iterator.map(r => r.event.eventId -> r.event.filterChildEventIds(visible)).toMap\n \n-  private val updateArchived =\n-    \"\"\"update participant_events set create_consumed_at={consumed_at} where contract_id={contract_id}\"\"\"\n+      // Roots are all the visible events in this transaction\n+      // that don't appear in any event's children\n+      val rootEventIds =\n+        visible.diff(eventsById.valuesIterator.flatMap(_.childEventIds).toSet).toSeq\n \n-  private def archive(\n-      contractId: ContractId,\n-      consumedAt: Offset,\n-  ): Vector[NamedParameter] =\n-    Vector[NamedParameter](\n-      \"consumed_at\" -> consumedAt,\n-      \"contract_id\" -> contractId.coid.toString,\n-    )\n+      (eventsById, rootEventIds)"
  },
  {
    "id" : "0981c6af-15d2-4fcf-b078-d497439bba8c",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "5da612c4-ac78-4c84-89c6-42e89d206dd1",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Very nice!",
        "createdAt" : "2020-03-19T20:13:57Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : 106,
    "diffHunk" : "@@ -72,6 +81,52 @@ private[events] trait EventsTable {\n       }\n     }\n \n+    def toTransactionTree(events: List[Entry[TreeEvent]]): Option[GetTransactionResponse] =\n+      events.headOption.map(\n+        first => {\n+          val (eventsById, rootEventIds) = treeOf(events)\n+          GetTransactionResponse(\n+            transaction = Some(\n+              ApiTransactionTree(\n+                transactionId = first.transactionId,\n+                commandId = first.commandId,\n+                workflowId = first.workflowId,\n+                effectiveAt =\n+                  Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),\n+                offset = ApiOffset.toApiString(first.eventOffset),\n+                eventsById = eventsById,\n+                rootEventIds = rootEventIds,\n+                traceContext = None,\n+              ))\n+          )\n+        }\n+      )\n+\n+    private def treeOf(events: List[Entry[TreeEvent]]): (Map[String, TreeEvent], Seq[String]) = {\n+\n+      // The identifiers of all visible events in this transactions, preserving\n+      // the order in which they are retrieved from the index\n+      val visible = events.map(_.event.eventId)\n+\n+      // All events in this transaction by their identifier, with their children\n+      // filtered according to those visible for this request\n+      val eventsById =\n+        events.iterator\n+          .map(_.event)\n+          .map(e => e.eventId -> e.filterChildEventIds(visible.toSet))"
  },
  {
    "id" : "9183d249-94d5-4980-83f2-6dc71d8f60a5",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "039a0594-9700-425d-b4be-79fc18a092a2",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "`Date#getTime` returns number of milliseconds since epoch. I would suggest reading `Entry#ledgerEffectiveTime` as `java.time.Instant` and then use `Instant#getEpochSecond` and `Instant#getNano` to construct the protobuf `Timestamp`. Same goes for the `effectiveAt` in `toFlatTransaction`.\r\n```suggestion\r\n                  Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getEpochSecond, nanos = first.ledgerEffectiveTime.getNano)),\r\n```",
        "createdAt" : "2020-03-19T20:18:41Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d867bd06-7441-4c17-9cc6-bf13a776f4e5",
        "parentId" : "039a0594-9700-425d-b4be-79fc18a092a2",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Very good catch, it's missing from the tests, adding this.",
        "createdAt" : "2020-03-20T08:05:47Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1bf43ca4-cbc9-42d5-a856-0480c29c7e29",
        "parentId" : "039a0594-9700-425d-b4be-79fc18a092a2",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5089/commits/f4d624df866815c079a899a2c45497bb6b7ee6e5",
        "createdAt" : "2020-03-20T11:09:00Z",
        "updatedAt" : "2020-03-20T11:09:01Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : null,
    "diffHunk" : "@@ -72,6 +81,52 @@ private[events] trait EventsTable {\n       }\n     }\n \n+    def toTransactionTree(events: List[Entry[TreeEvent]]): Option[GetTransactionResponse] =\n+      events.headOption.map(\n+        first => {\n+          val (eventsById, rootEventIds) = treeOf(events)\n+          GetTransactionResponse(\n+            transaction = Some(\n+              ApiTransactionTree(\n+                transactionId = first.transactionId,\n+                commandId = first.commandId,\n+                workflowId = first.workflowId,\n+                effectiveAt =\n+                  Some(Timestamp.of(seconds = first.ledgerEffectiveTime.getTime, nanos = 0)),"
  }
]