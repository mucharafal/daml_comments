[
  {
    "id" : "217d1f30-185f-4c0b-a2ed-590e6a502aaa",
    "prId" : 6216,
    "comments" : [
      {
        "id" : "a9add213-fe50-483f-b654-db46a4a1d017",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "What is this dummy implicit for?",
        "createdAt" : "2020-06-04T06:39:51Z",
        "updatedAt" : "2020-06-04T06:42:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c38903c3-0679-49f2-980b-b053e1b8fbd5",
        "parentId" : "a9add213-fe50-483f-b654-db46a4a1d017",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "It makes the first two `add` overloads have different erasures in bytecode.",
        "createdAt" : "2020-06-04T13:55:07Z",
        "updatedAt" : "2020-06-04T13:55:07Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dfeee677-5dc4-45a3-89b3-ca3dd5ab9da8",
        "parentId" : "a9add213-fe50-483f-b654-db46a4a1d017",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Mh, ok. Would a simple change of name have worked, though?",
        "createdAt" : "2020-06-04T18:13:49Z",
        "updatedAt" : "2020-06-04T18:13:49Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3ffdcf29-c4c6-4fcd-a740-33ae3045f0e0",
        "parentId" : "a9add213-fe50-483f-b654-db46a4a1d017",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Yes, it would.\r\n\r\nWe do something similar for the superclass of all Scala-codegenned record types, since we have methods share names with possible field names:\r\n\r\nhttps://github.com/digital-asset/daml/blob/e23a488596d412b804dc4fd7af821d2c5b8dd5df/language-support/scala/bindings/src/main/scala/com/digitalasset/ledger/client/binding/binding/Template.scala#L22-L25",
        "createdAt" : "2020-06-04T19:49:08Z",
        "updatedAt" : "2020-06-04T19:49:08Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "47a4eea06961bd477c6a3c7678ee238fe9c1556f",
    "line" : 17,
    "diffHunk" : "@@ -111,23 +111,24 @@ private[events] trait EventsTableInsert { this: EventsTable =>\n   }\n \n   private case class AccumulatingBatches(\n-      creates: Vector[RawBatch.Event.Created],\n-      exercises: Vector[RawBatch.Event.Exercised],\n+      creates: Vector[RawBatch.Event[RawBatch.Event.Created]],\n+      exercises: Vector[RawBatch.Event[RawBatch.Event.Exercised]],\n       archives: Vector[Vector[NamedParameter]],\n   ) {\n \n-    def add(create: RawBatch.Event.Created): AccumulatingBatches =\n+    def add(create: RawBatch.Event[RawBatch.Event.Created]): AccumulatingBatches =\n       copy(creates = creates :+ create)\n \n-    def add(exercise: RawBatch.Event.Exercised): AccumulatingBatches =\n+    def add(exercise: RawBatch.Event[RawBatch.Event.Exercised])(\n+        implicit dummy: DummyImplicit): AccumulatingBatches ="
  },
  {
    "id" : "d4378768-8e95-46b9-aef7-1237acc5b3b7",
    "prId" : 6172,
    "comments" : [
      {
        "id" : "caa60abb-8c24-4440-9433-fbfb4bd1c06e",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "`NodeId` is a `final case class`, this is probably unnecessarily generic.",
        "createdAt" : "2020-06-02T07:26:28Z",
        "updatedAt" : "2020-06-03T00:22:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f43b78b0-1be9-4245-a03c-f60aeab4b723",
        "parentId" : "caa60abb-8c24-4440-9433-fbfb4bd1c06e",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Scala seems to think that `Nid` and `NodeId` are distinct, which is [exploitable in type-checking](https://typelevel.org/blog/2017/02/13/more-types-than-classes.html).",
        "createdAt" : "2020-06-02T16:14:00Z",
        "updatedAt" : "2020-06-03T00:22:54Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b62007bb-9a14-44dd-9bcb-a638e4abb813",
        "parentId" : "caa60abb-8c24-4440-9433-fbfb4bd1c06e",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "To expand, there is no need for separate maps here at all, I would have rather mapped the party sets directly into the transaction structure. However, the transaction structure isn't sufficiently generic for that, so we have the nasty Perlish technique of \"pass a map that associates the extra data in\" instead.\r\n\r\nThen I ask myself, \"given that I don't want to hypergeneralize lf.Transaction, how can I make clear that these three arguments are related in a specific way, and they do not merely contain NodeIds, but NodeIds that are specifically related to each other?\" And this is the most obvious tool available.\r\n\r\n[I expand on a similar case for similarly final class String.](https://typelevel.org/blog/2017/09/05/three-types-of-strings.html)",
        "createdAt" : "2020-06-02T16:29:46Z",
        "updatedAt" : "2020-06-03T00:22:54Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a07d02c332d46c90c777addcbdff06f74cd74a61",
    "line" : 79,
    "diffHunk" : "@@ -160,13 +158,15 @@ private[events] trait EventsTableInsert { this: EventsTable =>\n     * @throws RuntimeException If a value cannot be serialized into an array of bytes\n     */\n   @throws[RuntimeException]\n-  def prepareBatchInsert(\n+  def prepareBatchInsert[Nid <: NodeId]("
  },
  {
    "id" : "83932fbf-100a-4e89-8411-5835aba4dd2e",
    "prId" : 6143,
    "comments" : [
      {
        "id" : "77e8da03-8221-4919-aaac-2e43600c903e",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I believe @S11001001 had a good idea why this was here, but I don't know what it was.",
        "createdAt" : "2020-06-08T13:13:50Z",
        "updatedAt" : "2020-06-08T14:24:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89af6d420800adee764159fb1c3073fae07859e9",
    "line" : 16,
    "diffHunk" : "@@ -159,17 +158,17 @@ private[events] trait EventsTableInsert { this: EventsTable =>\n     * @throws RuntimeException If a value cannot be serialized into an array of bytes\n     */\n   @throws[RuntimeException]\n-  def prepareBatchInsert[Nid <: NodeId](\n+  def prepareBatchInsert("
  },
  {
    "id" : "4712efcf-875c-4073-8dd5-789c423b21a3",
    "prId" : 5522,
    "comments" : [
      {
        "id" : "a224a569-a848-42bd-aa47-e2b1fc88b85f",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "ðŸ¥³ ",
        "createdAt" : "2020-04-09T15:31:07Z",
        "updatedAt" : "2020-04-09T17:51:17Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "32605ff4e62f3d2a5d12fabe7d6ba254e4d24056",
    "line" : 5,
    "diffHunk" : "@@ -3,7 +3,7 @@\n \n package com.daml.platform.store.dao.events\n \n-import java.util.Date\n+import java.time.Instant"
  },
  {
    "id" : "7a87c729-937c-4a76-8253-5acd18a64c29",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "665103aa-f574-42bf-91c2-9b2784f053ec",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'd almost prefer a 2 line query with the column names in the first line and the query parameter names in the second line, neatly lined up to see that there's no line swapping going on. In this formatting it's basically impossible to match parameter to column name.",
        "createdAt" : "2020-03-19T16:32:41Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "71d0d329-9d37-4f89-aa0b-39bf91913349",
        "parentId" : "665103aa-f574-42bf-91c2-9b2784f053ec",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I can do it, thanks.",
        "createdAt" : "2020-03-19T17:31:57Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9cdddc9e-23e2-4821-98ee-307b051b87f1",
        "parentId" : "665103aa-f574-42bf-91c2-9b2784f053ec",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "It's still a bit difficult to manage, I'll put the argument names in a list and build the string.",
        "createdAt" : "2020-03-19T19:39:52Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04e780fb-634d-4150-a598-903d1ec923d6",
        "parentId" : "665103aa-f574-42bf-91c2-9b2784f053ec",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5089/commits/8c4b4a1adebe3bb428c1d2bcbbf06667e55d69c1",
        "createdAt" : "2020-03-19T20:06:27Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,329 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.store.dao.events\n+\n+import java.util.Date\n+\n+import anorm.{BatchSql, NamedParameter}\n+import com.daml.ledger.participant.state.v1.Offset\n+import com.digitalasset.ledger.{ApplicationId, CommandId, TransactionId, WorkflowId}\n+import com.digitalasset.platform.events.EventIdFormatter.fromTransactionId\n+import com.digitalasset.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+\n+private[events] trait EventsTableInsert { this: EventsTable =>\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(node: Create): Array[Byte] =\n+    serialize(\n+      value = node.coinst.arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = node.coid),\n+    )\n+\n+  private def serializeNullableKeyOrThrow(node: Create): Option[Array[Byte]] =\n+    node.key.map(\n+      k =>\n+        serialize(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = node.coid),\n+      ))\n+\n+  private def serializeExerciseArgOrThrow(node: Exercise): Array[Byte] =\n+    serialize(\n+      value = node.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = node.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(node: Exercise): Option[Array[Byte]] =\n+    node.exerciseResult.map(exerciseResult =>\n+      serialize(\n+        value = exerciseResult,\n+        errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n+    ))\n+\n+  private val insertCreate: String =\n+    \"\"\"insert into participant_events("
  },
  {
    "id" : "dc56402c-a1db-41e3-8205-149d330bb45e",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "f2c89b20-4e86-42d5-b580-39a50ce983dd",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "You can import `Conversions._` to get the `ToStatement[Ref.LedgerString]` so you don't need to call `toString` here. This will then also import similar implicits for `ContractIdString` and you might want to consider adding one for `EventId` as well. The conversions import should also save you from having to do `commandId.map(_.toString)` further below.\r\nSee this implicit: https://github.com/digital-asset/daml/blob/c2c0557970eb0ddfe10dfe63a1f9106404250d55/ledger/sandbox/src/main/scala/com/digitalasset/platform/store/Conversions.scala#L65-L67",
        "createdAt" : "2020-03-19T16:36:33Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "55b25e55-b961-4199-a881-3873ed7de156",
        "parentId" : "f2c89b20-4e86-42d5-b580-39a50ce983dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Ah, that's the trick! Thanks!",
        "createdAt" : "2020-03-19T17:32:21Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "76f895d2-ad14-4697-9720-57d3d5b3bb4c",
        "parentId" : "f2c89b20-4e86-42d5-b580-39a50ce983dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm adding a new conversion for `QualifiedName`s.\r\n\r\nUnfortunately this doesn't seem to work out of the box on options, looking into it.",
        "createdAt" : "2020-03-19T17:59:18Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c4fe8147-764b-4d71-888b-ccfaa3c7a109",
        "parentId" : "f2c89b20-4e86-42d5-b580-39a50ce983dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Adding this to `Conversions` seems to fix it:\r\n\r\n```\r\n  implicit def partyMetaParameter(\r\n      implicit strParamMetaData: ParameterMetaData[String],\r\n  ): ParameterMetaData[Ref.Party] =\r\n    subStringMetaParameter(strParamMetaData)\r\n```",
        "createdAt" : "2020-03-19T18:06:45Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9ff52996-123a-4301-b1aa-aa08df0de808",
        "parentId" : "f2c89b20-4e86-42d5-b580-39a50ce983dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Mh, looks like `Array`s of sub-types of `String` are another thing that doesn't seem to work.\r\n\r\ne.g.\r\n```\r\nledger/sandbox/src/main/scala/com/digitalasset/platform/store/dao/events/EventsTableInsert.scala:198: error: No ClassTag available for com.digitalasset.daml.lf.data.Ref.Party\r\n      \"exercise_actors\" -> exercise.actingParties.toArray,\r\n```\r\n\r\nWorking on it.",
        "createdAt" : "2020-03-19T18:11:18Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3ea7fbcd-da36-4d27-901a-f87c605d400e",
        "parentId" : "f2c89b20-4e86-42d5-b580-39a50ce983dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Solved with a type hint.",
        "createdAt" : "2020-03-19T18:57:36Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9dc1cc6d-3c38-4ba2-ac41-a48377dd4f7d",
        "parentId" : "f2c89b20-4e86-42d5-b580-39a50ce983dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5089/commits/066ef1ea6dc71a12663782b5967f508be3791b15",
        "createdAt" : "2020-03-19T20:04:28Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,329 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.store.dao.events\n+\n+import java.util.Date\n+\n+import anorm.{BatchSql, NamedParameter}\n+import com.daml.ledger.participant.state.v1.Offset\n+import com.digitalasset.ledger.{ApplicationId, CommandId, TransactionId, WorkflowId}\n+import com.digitalasset.platform.events.EventIdFormatter.fromTransactionId\n+import com.digitalasset.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+\n+private[events] trait EventsTableInsert { this: EventsTable =>\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(node: Create): Array[Byte] =\n+    serialize(\n+      value = node.coinst.arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = node.coid),\n+    )\n+\n+  private def serializeNullableKeyOrThrow(node: Create): Option[Array[Byte]] =\n+    node.key.map(\n+      k =>\n+        serialize(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = node.coid),\n+      ))\n+\n+  private def serializeExerciseArgOrThrow(node: Exercise): Array[Byte] =\n+    serialize(\n+      value = node.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = node.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(node: Exercise): Option[Array[Byte]] =\n+    node.exerciseResult.map(exerciseResult =>\n+      serialize(\n+        value = exerciseResult,\n+        errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n+    ))\n+\n+  private val insertCreate: String =\n+    \"\"\"insert into participant_events(\n+      |  event_id,\n+      |  event_offset,\n+      |  contract_id,\n+      |  transaction_id,\n+      |  workflow_id,\n+      |  ledger_effective_time,\n+      |  template_package_id,\n+      |  template_name,\n+      |  node_index,\n+      |  is_root,\n+      |  command_id,\n+      |  application_id,\n+      |  submitter,\n+      |  create_argument,\n+      |  create_signatories,\n+      |  create_observers,\n+      |  create_agreement_text,\n+      |  create_consumed_at,\n+      |  create_key_value\n+      |) values (\n+      |  {event_id},\n+      |  {event_offset},\n+      |  {contract_id},\n+      |  {transaction_id},\n+      |  {workflow_id},\n+      |  {ledger_effective_time},\n+      |  {template_package_id},\n+      |  {template_name},\n+      |  {node_index},\n+      |  {is_root},\n+      |  {command_id},\n+      |  {application_id},\n+      |  {submitter},\n+      |  {create_argument},\n+      |  {create_signatories},\n+      |  {create_observers},\n+      |  {create_agreement_text},\n+      |  null,\n+      |  {create_key_value}\n+      |)\n+      |\"\"\".stripMargin\n+\n+  private def create(\n+      applicationId: Option[ApplicationId],\n+      workflowId: Option[WorkflowId],\n+      commandId: Option[CommandId],\n+      transactionId: TransactionId,\n+      nodeId: NodeId,\n+      submitter: Option[Party],\n+      roots: Set[NodeId],\n+      ledgerEffectiveTime: Date,\n+      offset: Offset,\n+      create: Create,\n+  ): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n+      \"event_offset\" -> offset.toInputStream,\n+      \"contract_id\" -> create.coid.coid.toString,\n+      \"transaction_id\" -> transactionId.toString,"
  },
  {
    "id" : "bb908824-af20-4115-8f04-31e1c5cdba3a",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "0eadaf64-06dc-4506-a9e4-cc720bd04415",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This will also set `create_consumed_at` for all existing ~non-consuming~ exercise events.",
        "createdAt" : "2020-03-19T16:40:01Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f933d430-2c79-40e9-897a-f6908acd4037",
        "parentId" : "0eadaf64-06dc-4506-a9e4-cc720bd04415",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Ouch, very nice catch, thanks!",
        "createdAt" : "2020-03-19T17:33:10Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0eaee31a-8f12-4d73-a73b-9a1d8d42b1a3",
        "parentId" : "0eadaf64-06dc-4506-a9e4-cc720bd04415",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5089/commits/0be63d500117b2b540d478d599b4f2664d883bb4",
        "createdAt" : "2020-03-19T20:04:56Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,329 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.store.dao.events\n+\n+import java.util.Date\n+\n+import anorm.{BatchSql, NamedParameter}\n+import com.daml.ledger.participant.state.v1.Offset\n+import com.digitalasset.ledger.{ApplicationId, CommandId, TransactionId, WorkflowId}\n+import com.digitalasset.platform.events.EventIdFormatter.fromTransactionId\n+import com.digitalasset.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+\n+private[events] trait EventsTableInsert { this: EventsTable =>\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(node: Create): Array[Byte] =\n+    serialize(\n+      value = node.coinst.arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = node.coid),\n+    )\n+\n+  private def serializeNullableKeyOrThrow(node: Create): Option[Array[Byte]] =\n+    node.key.map(\n+      k =>\n+        serialize(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = node.coid),\n+      ))\n+\n+  private def serializeExerciseArgOrThrow(node: Exercise): Array[Byte] =\n+    serialize(\n+      value = node.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = node.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(node: Exercise): Option[Array[Byte]] =\n+    node.exerciseResult.map(exerciseResult =>\n+      serialize(\n+        value = exerciseResult,\n+        errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n+    ))\n+\n+  private val insertCreate: String =\n+    \"\"\"insert into participant_events(\n+      |  event_id,\n+      |  event_offset,\n+      |  contract_id,\n+      |  transaction_id,\n+      |  workflow_id,\n+      |  ledger_effective_time,\n+      |  template_package_id,\n+      |  template_name,\n+      |  node_index,\n+      |  is_root,\n+      |  command_id,\n+      |  application_id,\n+      |  submitter,\n+      |  create_argument,\n+      |  create_signatories,\n+      |  create_observers,\n+      |  create_agreement_text,\n+      |  create_consumed_at,\n+      |  create_key_value\n+      |) values (\n+      |  {event_id},\n+      |  {event_offset},\n+      |  {contract_id},\n+      |  {transaction_id},\n+      |  {workflow_id},\n+      |  {ledger_effective_time},\n+      |  {template_package_id},\n+      |  {template_name},\n+      |  {node_index},\n+      |  {is_root},\n+      |  {command_id},\n+      |  {application_id},\n+      |  {submitter},\n+      |  {create_argument},\n+      |  {create_signatories},\n+      |  {create_observers},\n+      |  {create_agreement_text},\n+      |  null,\n+      |  {create_key_value}\n+      |)\n+      |\"\"\".stripMargin\n+\n+  private def create(\n+      applicationId: Option[ApplicationId],\n+      workflowId: Option[WorkflowId],\n+      commandId: Option[CommandId],\n+      transactionId: TransactionId,\n+      nodeId: NodeId,\n+      submitter: Option[Party],\n+      roots: Set[NodeId],\n+      ledgerEffectiveTime: Date,\n+      offset: Offset,\n+      create: Create,\n+  ): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n+      \"event_offset\" -> offset.toInputStream,\n+      \"contract_id\" -> create.coid.coid.toString,\n+      \"transaction_id\" -> transactionId.toString,\n+      \"workflow_id\" -> workflowId.map(_.toString),\n+      \"ledger_effective_time\" -> ledgerEffectiveTime,\n+      \"template_package_id\" -> create.coinst.template.packageId.toString,\n+      \"template_name\" -> create.coinst.template.qualifiedName.toString,\n+      \"node_index\" -> nodeId.index,\n+      \"is_root\" -> roots(nodeId),\n+      \"command_id\" -> commandId.map(_.toString),\n+      \"application_id\" -> applicationId.map(_.toString),\n+      \"submitter\" -> submitter.map(_.toString),\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_signatories\" -> create.signatories.map(_.toString).toArray,\n+      \"create_observers\" -> create.stakeholders.diff(create.signatories).map(_.toString).toArray,\n+      \"create_agreement_text\" -> Some(create.coinst.agreementText).filter(_.nonEmpty),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+\n+  private val insertExercise =\n+    \"\"\"insert into participant_events(\n+      |  event_id,\n+      |  event_offset,\n+      |  contract_id,\n+      |  transaction_id,\n+      |  workflow_id,\n+      |  ledger_effective_time,\n+      |  template_package_id,\n+      |  template_name,\n+      |  node_index,\n+      |  is_root,\n+      |  command_id,\n+      |  application_id,\n+      |  submitter,\n+      |  exercise_consuming,\n+      |  exercise_choice,\n+      |  exercise_argument,\n+      |  exercise_result,\n+      |  exercise_actors,\n+      |  exercise_child_event_ids\n+      |) values (\n+      |  {event_id},\n+      |  {event_offset},\n+      |  {contract_id},\n+      |  {transaction_id},\n+      |  {workflow_id},\n+      |  {ledger_effective_time},\n+      |  {template_package_id},\n+      |  {template_name},\n+      |  {node_index},\n+      |  {is_root},\n+      |  {command_id},\n+      |  {application_id},\n+      |  {submitter},\n+      |  {exercise_consuming},\n+      |  {exercise_choice},\n+      |  {exercise_argument},\n+      |  {exercise_result},\n+      |  {exercise_actors},\n+      |  {exercise_child_event_ids}\n+      |)\n+      |\"\"\".stripMargin\n+\n+  private def exercise(\n+      applicationId: Option[ApplicationId],\n+      workflowId: Option[WorkflowId],\n+      commandId: Option[CommandId],\n+      transactionId: TransactionId,\n+      nodeId: NodeId,\n+      submitter: Option[Party],\n+      roots: Set[NodeId],\n+      ledgerEffectiveTime: Date,\n+      offset: Offset,\n+      exercise: Exercise,\n+  ): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n+      \"event_offset\" -> offset.toInputStream,\n+      \"contract_id\" -> exercise.targetCoid.coid.toString,\n+      \"transaction_id\" -> transactionId.toString,\n+      \"workflow_id\" -> workflowId.map(_.toString),\n+      \"ledger_effective_time\" -> ledgerEffectiveTime,\n+      \"template_package_id\" -> exercise.templateId.packageId.toString,\n+      \"template_name\" -> exercise.templateId.qualifiedName.toString,\n+      \"node_index\" -> nodeId.index,\n+      \"is_root\" -> roots(nodeId),\n+      \"command_id\" -> commandId.map(_.toString),\n+      \"application_id\" -> applicationId.map(_.toString),\n+      \"submitter\" -> submitter.map(_.toString),\n+      \"exercise_consuming\" -> exercise.consuming,\n+      \"exercise_choice\" -> exercise.choiceId.toString,\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+      \"exercise_actors\" -> exercise.actingParties.map(_.toString).toArray,\n+      \"exercise_child_event_ids\" -> exercise.children\n+        .map(fromTransactionId(transactionId, _): String)\n+        .toArray,\n+    )\n+\n+  private val updateArchived =\n+    \"\"\"update participant_events set create_consumed_at={consumed_at} where contract_id={contract_id}\"\"\""
  },
  {
    "id" : "10a21951-9b47-41a5-86a5-2b98b5118f7f",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "e735853b-557a-421d-a5bc-d2674ea914ac",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Using `List` and `::` might be more efficient, considering we only do the accumulation here and then later pass as `head` and `tail` to `BatchSql`.",
        "createdAt" : "2020-03-19T16:44:50Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "26af316e-21ae-4253-a300-ff8aa6a94b85",
        "parentId" : "e735853b-557a-421d-a5bc-d2674ea914ac",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Are you sure? We are appending to the end of the vector.",
        "createdAt" : "2020-03-19T17:33:44Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,329 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.store.dao.events\n+\n+import java.util.Date\n+\n+import anorm.{BatchSql, NamedParameter}\n+import com.daml.ledger.participant.state.v1.Offset\n+import com.digitalasset.ledger.{ApplicationId, CommandId, TransactionId, WorkflowId}\n+import com.digitalasset.platform.events.EventIdFormatter.fromTransactionId\n+import com.digitalasset.platform.store.serialization.ValueSerializer.{serializeValue => serialize}\n+\n+private[events] trait EventsTableInsert { this: EventsTable =>\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(node: Create): Array[Byte] =\n+    serialize(\n+      value = node.coinst.arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = node.coid),\n+    )\n+\n+  private def serializeNullableKeyOrThrow(node: Create): Option[Array[Byte]] =\n+    node.key.map(\n+      k =>\n+        serialize(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = node.coid),\n+      ))\n+\n+  private def serializeExerciseArgOrThrow(node: Exercise): Array[Byte] =\n+    serialize(\n+      value = node.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = node.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(node: Exercise): Option[Array[Byte]] =\n+    node.exerciseResult.map(exerciseResult =>\n+      serialize(\n+        value = exerciseResult,\n+        errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n+    ))\n+\n+  private val insertCreate: String =\n+    \"\"\"insert into participant_events(\n+      |  event_id,\n+      |  event_offset,\n+      |  contract_id,\n+      |  transaction_id,\n+      |  workflow_id,\n+      |  ledger_effective_time,\n+      |  template_package_id,\n+      |  template_name,\n+      |  node_index,\n+      |  is_root,\n+      |  command_id,\n+      |  application_id,\n+      |  submitter,\n+      |  create_argument,\n+      |  create_signatories,\n+      |  create_observers,\n+      |  create_agreement_text,\n+      |  create_consumed_at,\n+      |  create_key_value\n+      |) values (\n+      |  {event_id},\n+      |  {event_offset},\n+      |  {contract_id},\n+      |  {transaction_id},\n+      |  {workflow_id},\n+      |  {ledger_effective_time},\n+      |  {template_package_id},\n+      |  {template_name},\n+      |  {node_index},\n+      |  {is_root},\n+      |  {command_id},\n+      |  {application_id},\n+      |  {submitter},\n+      |  {create_argument},\n+      |  {create_signatories},\n+      |  {create_observers},\n+      |  {create_agreement_text},\n+      |  null,\n+      |  {create_key_value}\n+      |)\n+      |\"\"\".stripMargin\n+\n+  private def create(\n+      applicationId: Option[ApplicationId],\n+      workflowId: Option[WorkflowId],\n+      commandId: Option[CommandId],\n+      transactionId: TransactionId,\n+      nodeId: NodeId,\n+      submitter: Option[Party],\n+      roots: Set[NodeId],\n+      ledgerEffectiveTime: Date,\n+      offset: Offset,\n+      create: Create,\n+  ): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n+      \"event_offset\" -> offset.toInputStream,\n+      \"contract_id\" -> create.coid.coid.toString,\n+      \"transaction_id\" -> transactionId.toString,\n+      \"workflow_id\" -> workflowId.map(_.toString),\n+      \"ledger_effective_time\" -> ledgerEffectiveTime,\n+      \"template_package_id\" -> create.coinst.template.packageId.toString,\n+      \"template_name\" -> create.coinst.template.qualifiedName.toString,\n+      \"node_index\" -> nodeId.index,\n+      \"is_root\" -> roots(nodeId),\n+      \"command_id\" -> commandId.map(_.toString),\n+      \"application_id\" -> applicationId.map(_.toString),\n+      \"submitter\" -> submitter.map(_.toString),\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_signatories\" -> create.signatories.map(_.toString).toArray,\n+      \"create_observers\" -> create.stakeholders.diff(create.signatories).map(_.toString).toArray,\n+      \"create_agreement_text\" -> Some(create.coinst.agreementText).filter(_.nonEmpty),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+\n+  private val insertExercise =\n+    \"\"\"insert into participant_events(\n+      |  event_id,\n+      |  event_offset,\n+      |  contract_id,\n+      |  transaction_id,\n+      |  workflow_id,\n+      |  ledger_effective_time,\n+      |  template_package_id,\n+      |  template_name,\n+      |  node_index,\n+      |  is_root,\n+      |  command_id,\n+      |  application_id,\n+      |  submitter,\n+      |  exercise_consuming,\n+      |  exercise_choice,\n+      |  exercise_argument,\n+      |  exercise_result,\n+      |  exercise_actors,\n+      |  exercise_child_event_ids\n+      |) values (\n+      |  {event_id},\n+      |  {event_offset},\n+      |  {contract_id},\n+      |  {transaction_id},\n+      |  {workflow_id},\n+      |  {ledger_effective_time},\n+      |  {template_package_id},\n+      |  {template_name},\n+      |  {node_index},\n+      |  {is_root},\n+      |  {command_id},\n+      |  {application_id},\n+      |  {submitter},\n+      |  {exercise_consuming},\n+      |  {exercise_choice},\n+      |  {exercise_argument},\n+      |  {exercise_result},\n+      |  {exercise_actors},\n+      |  {exercise_child_event_ids}\n+      |)\n+      |\"\"\".stripMargin\n+\n+  private def exercise(\n+      applicationId: Option[ApplicationId],\n+      workflowId: Option[WorkflowId],\n+      commandId: Option[CommandId],\n+      transactionId: TransactionId,\n+      nodeId: NodeId,\n+      submitter: Option[Party],\n+      roots: Set[NodeId],\n+      ledgerEffectiveTime: Date,\n+      offset: Offset,\n+      exercise: Exercise,\n+  ): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"event_id\" -> fromTransactionId(transactionId, nodeId).toString,\n+      \"event_offset\" -> offset.toInputStream,\n+      \"contract_id\" -> exercise.targetCoid.coid.toString,\n+      \"transaction_id\" -> transactionId.toString,\n+      \"workflow_id\" -> workflowId.map(_.toString),\n+      \"ledger_effective_time\" -> ledgerEffectiveTime,\n+      \"template_package_id\" -> exercise.templateId.packageId.toString,\n+      \"template_name\" -> exercise.templateId.qualifiedName.toString,\n+      \"node_index\" -> nodeId.index,\n+      \"is_root\" -> roots(nodeId),\n+      \"command_id\" -> commandId.map(_.toString),\n+      \"application_id\" -> applicationId.map(_.toString),\n+      \"submitter\" -> submitter.map(_.toString),\n+      \"exercise_consuming\" -> exercise.consuming,\n+      \"exercise_choice\" -> exercise.choiceId.toString,\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+      \"exercise_actors\" -> exercise.actingParties.map(_.toString).toArray,\n+      \"exercise_child_event_ids\" -> exercise.children\n+        .map(fromTransactionId(transactionId, _): String)\n+        .toArray,\n+    )\n+\n+  private val updateArchived =\n+    \"\"\"update participant_events set create_consumed_at={consumed_at} where contract_id={contract_id}\"\"\"\n+\n+  private def archive(\n+      contractId: ContractId,\n+      consumedAt: Offset,\n+  ): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"consumed_at\" -> consumedAt.toInputStream,\n+      \"contract_id\" -> contractId.coid.toString,\n+    )\n+\n+  sealed abstract case class PreparedBatches(\n+      creates: Option[BatchSql],\n+      exercises: Option[BatchSql],\n+      archives: Option[BatchSql],\n+  ) {\n+    final def isEmpty: Boolean = creates.isEmpty && exercises.isEmpty && archives.isEmpty\n+    final def foreach[U](f: BatchSql => U): Unit = {\n+      creates.foreach(f)\n+      exercises.foreach(f)\n+      archives.foreach(f)\n+    }\n+  }\n+\n+  private case class AccumulatingBatches(\n+      creates: Vector[Vector[NamedParameter]],\n+      exercises: Vector[Vector[NamedParameter]],\n+      archives: Vector[Vector[NamedParameter]],\n+  ) {\n+\n+    def addCreate(create: Vector[NamedParameter]): AccumulatingBatches =\n+      copy(creates = creates :+ create)"
  },
  {
    "id" : "1b84c12a-3625-4a22-974b-98c7125646d0",
    "prId" : 5089,
    "comments" : [
      {
        "id" : "8e4cb33c-4c26-4720-92d1-894f0d6028f4",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I like it. Thanks!",
        "createdAt" : "2020-03-19T20:21:12Z",
        "updatedAt" : "2020-03-20T11:06:26Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b5d117bbf4b07fc2d8a6a4f8540241ce2ece5a56",
    "line" : 83,
    "diffHunk" : "@@ -43,49 +44,33 @@ private[events] trait EventsTableInsert { this: EventsTable =>\n         errorContext = cantSerialize(attribute = \"exercise result\", forContract = node.targetCoid),\n     ))\n \n+  private def insertEvent(columnNameAndValues: (String, String)*): String = {\n+    val (columns, values) = columnNameAndValues.unzip\n+    s\"insert into participant_events(${columns.mkString(\", \")}) values (${values.mkString(\", \")})\"\n+  }\n+\n   private val insertCreate: String =\n-    \"\"\"insert into participant_events(\n-      |  event_id,\n-      |  event_offset,\n-      |  contract_id,\n-      |  transaction_id,\n-      |  workflow_id,\n-      |  ledger_effective_time,\n-      |  template_package_id,\n-      |  template_name,\n-      |  node_index,\n-      |  is_root,\n-      |  command_id,\n-      |  application_id,\n-      |  submitter,\n-      |  create_argument,\n-      |  create_signatories,\n-      |  create_observers,\n-      |  create_agreement_text,\n-      |  create_consumed_at,\n-      |  create_key_value\n-      |) values (\n-      |  {event_id},\n-      |  {event_offset},\n-      |  {contract_id},\n-      |  {transaction_id},\n-      |  {workflow_id},\n-      |  {ledger_effective_time},\n-      |  {template_package_id},\n-      |  {template_name},\n-      |  {node_index},\n-      |  {is_root},\n-      |  {command_id},\n-      |  {application_id},\n-      |  {submitter},\n-      |  {create_argument},\n-      |  {create_signatories},\n-      |  {create_observers},\n-      |  {create_agreement_text},\n-      |  null,\n-      |  {create_key_value}\n-      |)\n-      |\"\"\".stripMargin\n+    insertEvent(\n+      \"event_id\" -> \"{event_id}\",\n+      \"event_offset\" -> \"{event_offset}\",\n+      \"contract_id\" -> \"{contract_id}\",\n+      \"transaction_id\" -> \"{transaction_id}\",\n+      \"workflow_id\" -> \"{workflow_id}\",\n+      \"ledger_effective_time\" -> \"{ledger_effective_time}\",\n+      \"template_package_id\" -> \"{template_package_id}\",\n+      \"template_name\" -> \"{template_name}\",\n+      \"node_index\" -> \"{node_index}\",\n+      \"is_root\" -> \"{is_root}\",\n+      \"command_id\" -> \"{command_id}\",\n+      \"application_id\" -> \"{application_id}\",\n+      \"submitter\" -> \"{submitter}\",\n+      \"create_argument\" -> \"{create_argument}\",\n+      \"create_signatories\" -> \"{create_signatories}\",\n+      \"create_observers\" -> \"{create_observers}\",\n+      \"create_agreement_text\" -> \"{create_agreement_text}\",\n+      \"create_consumed_at\" -> \"null\",\n+      \"create_key_value\" -> \"{create_key_value}\"\n+    )"
  }
]