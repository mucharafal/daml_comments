[
  {
    "id" : "0070c4ce-c2c0-4338-b252-4b9bf2272dcf",
    "prId" : 2662,
    "comments" : [
      {
        "id" : "4fb93dba-e360-43fd-92de-80ab69f628a3",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Probably not too pressing, but it would probably better to force `activeContracts` and `ledgerEntries` to be `IndexedSeq`s to rule off calls to `size`s that could be linear.",
        "createdAt" : "2019-08-26T15:17:10Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bb5ede8f-33a8-45ba-ae35-b8d5f961a531",
        "parentId" : "4fb93dba-e360-43fd-92de-80ab69f628a3",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'm not worried about this particular case, because it only happens on startup if you happen to run a scenario (i.e. non-production and/or single time occurrence only).",
        "createdAt" : "2019-08-27T07:06:21Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe3fd2846c655373040f8b5281532a6483f923e8",
    "line" : null,
    "diffHunk" : "@@ -603,23 +603,25 @@ private class PostgresLedgerDao(\n     }.toMap\n \n     dbDispatcher\n-      .executeSql { implicit conn =>\n-        // First, store all ledger entries without updating the ACS\n-        // We can't use the storeLedgerEntry(), as that one does update the ACS\n-        ledgerEntries.foreach {\n-          case (i, le) =>\n-            le match {\n-              case tx: LedgerEntry.Transaction => storeTransaction(i, tx)\n-              case rj: LedgerEntry.Rejection => storeRejection(i, rj)\n-              case cp: LedgerEntry.Checkpoint => storeCheckpoint(i, cp)\n-            }\n-        }\n+      .executeSql(\n+        s\"store initial state from scenario [${activeContracts.size} contracts, ${ledgerEntries.size} ledger entries\") {"
  },
  {
    "id" : "8541c593-3705-4235-aabe-0b4d97e40c51",
    "prId" : 2662,
    "comments" : [
      {
        "id" : "53300774-bb5c-45c4-b877-4381743dccfa",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "How is a `TransactionId` printed? If it's a tagged type, would it be better to unwrap it for readability?",
        "createdAt" : "2019-08-26T15:18:12Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f3d26e9c-b7d7-407c-bb96-a956b9acbd7b",
        "parentId" : "53300774-bb5c-45c4-b877-4381743dccfa",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The `toString` is the same as the underlying value:\r\n```\r\nscala> First(3)\r\nres0: Int @@ scalaz.Tags.First = 3\r\n\r\nscala> res0.toString\r\nres1: String = 3\r\n```",
        "createdAt" : "2019-08-27T06:50:35Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe3fd2846c655373040f8b5281532a6483f923e8",
    "line" : null,
    "diffHunk" : "@@ -770,7 +772,7 @@ private class PostgresLedgerDao(\n \n   override def lookupTransaction(\n       transactionId: TransactionId): Future[Option[(LedgerOffset, LedgerEntry.Transaction)]] = {\n-    dbDispatcher.executeSql { implicit conn =>\n+    dbDispatcher.executeSql(s\"lookup transaction [$transactionId]\") { implicit conn =>"
  },
  {
    "id" : "918c41c8-ab5c-4294-8268-0fcb7baa22a8",
    "prId" : 2662,
    "comments" : [
      {
        "id" : "1470d677-e376-4fad-ab46-931c375b8de6",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Same doubt as before: how is an `AbsoluteContractId` printed? If it's a tagged type, would it be better to unwrap it for readability?",
        "createdAt" : "2019-08-26T15:18:36Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "af0edb4c-4a97-4854-bf9d-a074fe2273a8",
        "parentId" : "1470d677-e376-4fad-ab46-931c375b8de6",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "`AbsoluteContractId` is a case class that wraps a `LedgerString` (which is a more fancy `java.lang.String`), so I'll log that wrapped string specifically. Thanks.",
        "createdAt" : "2019-08-27T06:53:05Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "29b4b7f5-3cec-4a23-a25a-bf559a265ad3",
        "parentId" : "1470d677-e376-4fad-ab46-931c375b8de6",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Addressed in f0a779ed1.",
        "createdAt" : "2019-08-27T07:07:13Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe3fd2846c655373040f8b5281532a6483f923e8",
    "line" : null,
    "diffHunk" : "@@ -815,7 +817,7 @@ private class PostgresLedgerDao(\n       .map(mapContractDetails)\n \n   override def lookupActiveContract(contractId: AbsoluteContractId): Future[Option[Contract]] =\n-    dbDispatcher.executeSql { implicit conn =>\n+    dbDispatcher.executeSql(s\"lookup active contract [$contractId]\") { implicit conn =>"
  },
  {
    "id" : "b9dee88e-0fe9-4304-b1dd-c42e635dbdc8",
    "prId" : 2662,
    "comments" : [
      {
        "id" : "f397cff4-eeee-499d-8c94-ae8c76604899",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I usually see round parentheses to denote an exclusive boundary end. Is this a typo or a different notation I wasn't aware of?",
        "createdAt" : "2019-08-26T15:19:49Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ffd0d76c-03f4-4fee-8f63-3d7fa6c5526f",
        "parentId" : "f397cff4-eeee-499d-8c94-ae8c76604899",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Turns out, the [notation](https://en.wikipedia.org/wiki/Interval_%28mathematics%29#Including_or_excluding_endpoints) is actually mixed with parenthesis and square brackets:\r\n```\r\n    (0, 5) = 1, 2, 3, 4\r\n    (0, 5] = 1, 2, 3, 4, 5\r\n    [0, 5) = 0, 1, 2, 3, 4\r\n    [0, 5] = 0, 1, 2, 3, 4, 5\r\n```",
        "createdAt" : "2019-08-27T06:56:27Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe3fd2846c655373040f8b5281532a6483f923e8",
    "line" : null,
    "diffHunk" : "@@ -922,11 +924,12 @@ private class PostgresLedgerDao(\n       PageSize,\n       (startI, endE) => {\n         Source\n-          .fromFuture(dbDispatcher.executeSql { implicit conn =>\n-            SQL_GET_LEDGER_ENTRIES\n-              .on(\"startInclusive\" -> startI, \"endExclusive\" -> endE)\n-              .as(EntryParser.*)\n-              .map(toLedgerEntry)\n+          .fromFuture(dbDispatcher.executeSql(s\"load ledger entries [$startI, $endE[\") {"
  },
  {
    "id" : "26f59cc8-0885-4429-a2cb-4c5b9daf0e0b",
    "prId" : 2662,
    "comments" : [
      {
        "id" : "b37347b2-0cf6-466f-91b6-f1b841958792",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Could be a candidate for unwrapping. Not sure though, I can't see types properly in GitHub. :slightly_smiling_face: ",
        "createdAt" : "2019-08-26T15:21:48Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a40fc6c4-a500-47af-8b38-32689d1eb854",
        "parentId" : "b37347b2-0cf6-466f-91b6-f1b841958792",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "No need here, as `Party` eventually is a `LedgerString`.",
        "createdAt" : "2019-08-27T06:57:19Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe3fd2846c655373040f8b5281532a6483f923e8",
    "line" : null,
    "diffHunk" : "@@ -992,7 +995,7 @@ private class PostgresLedgerDao(\n   override def storeParty(\n       party: Party,\n       displayName: Option[String]): Future[PersistenceResponse] = {\n-    dbDispatcher.executeSql { implicit conn =>\n+    dbDispatcher.executeSql(s\"store party [$party]\") { implicit conn =>"
  },
  {
    "id" : "470917d1-5ac3-465b-b5fa-2ab441b3b220",
    "prId" : 2662,
    "comments" : [
      {
        "id" : "403bf6f9-ca24-4f00-8496-1a21b71a6c3b",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "At this point I hope my point about unwrapping is valid, otherwise I wasted a lot of your time with these comments. :smile: ",
        "createdAt" : "2019-08-26T15:22:27Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fe9044a0-c60f-4d77-8ca5-3e26b7ce05c4",
        "parentId" : "403bf6f9-ca24-4f00-8496-1a21b71a6c3b",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "`PackageId` is also of the `LedgerString` variety. No unwrapping needed.",
        "createdAt" : "2019-08-27T07:08:09Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe3fd2846c655373040f8b5281532a6483f923e8",
    "line" : null,
    "diffHunk" : "@@ -1056,7 +1059,7 @@ private class PostgresLedgerDao(\n     }\n \n   override def getLfArchive(packageId: PackageId): Future[Option[Archive]] =\n-    dbDispatcher.executeSql { implicit conn =>\n+    dbDispatcher.executeSql(s\"load archive [$packageId]\") { implicit conn =>"
  },
  {
    "id" : "27f6b50a-14ac-47da-8f93-0a72533d20c8",
    "prId" : 2446,
    "comments" : [
      {
        "id" : "3d1659d1-7dca-4dcb-b1c0-506f95136eb4",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "@stefanobaghino-da : omg. that definitely shouldn't made it... I'll remove it.",
        "createdAt" : "2019-08-07T14:15:02Z",
        "updatedAt" : "2019-08-08T10:56:33Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e4f8624c98f2a7d75d6eaedcbf5fa454d8bb70d5",
    "line" : null,
    "diffHunk" : "@@ -923,11 +922,23 @@ private class PostgresLedgerDao(\n       PageSize,\n       (startI, endE) => {\n         Source\n-          .fromFuture(dbDispatcher.executeSql { implicit conn =>\n-            SQL_GET_LEDGER_ENTRIES\n-              .on(\"startInclusive\" -> startI, \"endExclusive\" -> endE)\n-              .as(EntryParser.*)\n-              .map(toLedgerEntry)\n+          .fromFuture(dbDispatcher.executeSql {\n+            implicit conn =>\n+              val query = SQL_GET_LEDGER_ENTRIES\n+                .on(\"startInclusive\" -> startI, \"endExclusive\" -> endE)\n+\n+              logger.error(s\"failing query: start=[$startI], end=[$endE]\")"
  },
  {
    "id" : "a290b65e-fa40-43f7-80aa-49d3d93fe05c",
    "prId" : 2316,
    "comments" : [
      {
        "id" : "23da480b-9462-4b25-a5fb-17d595808bc1",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should this really be a warning? About what is the reader of the log being warned? What can they do, once they read the warning? Do we always expect this data to be available?",
        "createdAt" : "2019-07-29T12:08:16Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f1ca15dc-f66e-4b2b-b2e6-346a189c4b87",
        "parentId" : "23da480b-9462-4b25-a5fb-17d595808bc1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "~If I'm not mistaken the most likely occurrence of this would be asking data to a ledger version that did not expose stakeholders. If that's the case, we can probably lower the log level, maybe to debug. Thoughts?~\r\n\r\nEDIT: as discussed offline, I was thinking of the Ledger API, where these fields could have not been available. Since we're reading the transaction directly, this is clearly an error condition.",
        "createdAt" : "2019-07-29T12:26:55Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a4adc35-a4d9-4b4e-981f-13b51f6a8399",
        "parentId" : "23da480b-9462-4b25-a5fb-17d595808bc1",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should we consider this to be an actual error (i.e. crash)?",
        "createdAt" : "2019-07-30T07:22:26Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c1e41369-7dc5-44d2-a612-080ed2fb3640",
        "parentId" : "23da480b-9462-4b25-a5fb-17d595808bc1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "As discussed offline, I was thinking of the Ledger API, where these fields could have not been available. Since we're reading the transaction directly, this is clearly an error condition.",
        "createdAt" : "2019-07-30T07:39:19Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5584bd05-d260-4cab-9a43-7a15d6e3efef",
        "parentId" : "23da480b-9462-4b25-a5fb-17d595808bc1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Fixed by https://github.com/digital-asset/daml/pull/2316/commits/47b714a3ed00ebad6f3ae49f66e85e66dbcf2c20",
        "createdAt" : "2019-07-30T07:43:38Z",
        "updatedAt" : "2019-07-30T07:43:39Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "47b714a3ed00ebad6f3ae49f66e85e66dbcf2c20",
    "line" : null,
    "diffHunk" : "@@ -826,29 +828,47 @@ private class PostgresLedgerDao(\n           Option[WorkflowId],\n           Date,\n           InputStream,\n-          Option[InputStream]))(implicit conn: Connection) =\n+          Option[InputStream],\n+          InputStream))(implicit conn: Connection) =\n     contractResult match {\n-      case (coid, transactionId, workflowId, ledgerEffectiveTime, contractStream, keyStreamO) =>\n+      case (coid, transactionId, workflowId, ledgerEffectiveTime, contractStream, keyStreamO, tx) =>\n         val witnesses = lookupWitnesses(coid)\n         val divulgences = lookupDivulgences(coid)\n+        val absoluteCoid = AbsoluteContractId(coid)\n+\n+        val (signatories, observers) =\n+          transactionSerializer\n+            .deserializeTransaction(ByteStreams.toByteArray(tx))\n+            .getOrElse(sys.error(s\"failed to deserialize transaction! cid:$coid\"))\n+            .nodes\n+            .collectFirst {\n+              case (_, NodeCreate(coid, _, _, signatories, stakeholders, _))\n+                  if coid == absoluteCoid =>\n+                (signatories, stakeholders diff signatories)\n+            } getOrElse {\n+            logger.warn(s\"Unable to read stakeholders for contract $coid, returning empty result\")"
  },
  {
    "id" : "a058a663-21eb-478c-aaa1-445e0b86664a",
    "prId" : 2316,
    "comments" : [
      {
        "id" : "88d89a7c-c1ed-410b-b36a-a656bdae1138",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This makes every contract lookup when validating exercises much more expensive. Not sure what to do about it though.",
        "createdAt" : "2019-07-29T12:16:13Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2ae9b411-bf06-4e15-bab9-e665dd2415fc",
        "parentId" : "88d89a7c-c1ed-410b-b36a-a656bdae1138",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I believe the only possible solution would be to add two columns holding the stakeholders. Would this be feasible? If so, what would the right procedure be to add new \"metadata\" columns?",
        "createdAt" : "2019-07-29T12:20:18Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "be63dab2-b878-4949-8796-4fd838240a3a",
        "parentId" : "88d89a7c-c1ed-410b-b36a-a656bdae1138",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "One easy place to add it to is `ContractInst` (which already gets serialized), but it might not be right place actually. For example, `NodeCreate` holds the stakeholders at the same level as the contract value of type `ContractInst`.\r\n\r\n@S11001001, @remyhaemmerle-da: what do you think?",
        "createdAt" : "2019-07-29T12:33:41Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "825af59f-6ecd-4440-a44d-910207b82651",
        "parentId" : "88d89a7c-c1ed-410b-b36a-a656bdae1138",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Created issue to discuss about this: for the moment, I believe we can merge this. https://github.com/digital-asset/daml/issues/2330",
        "createdAt" : "2019-07-30T07:17:43Z",
        "updatedAt" : "2019-07-30T07:40:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "47b714a3ed00ebad6f3ae49f66e85e66dbcf2c20",
    "line" : 83,
    "diffHunk" : "@@ -826,29 +828,47 @@ private class PostgresLedgerDao(\n           Option[WorkflowId],\n           Date,\n           InputStream,\n-          Option[InputStream]))(implicit conn: Connection) =\n+          Option[InputStream],\n+          InputStream))(implicit conn: Connection) =\n     contractResult match {\n-      case (coid, transactionId, workflowId, ledgerEffectiveTime, contractStream, keyStreamO) =>\n+      case (coid, transactionId, workflowId, ledgerEffectiveTime, contractStream, keyStreamO, tx) =>\n         val witnesses = lookupWitnesses(coid)\n         val divulgences = lookupDivulgences(coid)\n+        val absoluteCoid = AbsoluteContractId(coid)\n+\n+        val (signatories, observers) =\n+          transactionSerializer\n+            .deserializeTransaction(ByteStreams.toByteArray(tx))"
  },
  {
    "id" : "83654530-4513-4e06-a86e-e319ee072324",
    "prId" : 2131,
    "comments" : [
      {
        "id" : "b93f4886-2b09-4cf7-9301-d643a358e2b3",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```scala\r\nassert(0 == Array(1,1,1,1).map(math.min(0, _)).sum)\r\nassert(-1 == Array(1,10,-1,42).map(math.min(0, _)).sum)\r\n```\r\nI'm not sure this is the logic you want to implement.",
        "createdAt" : "2019-07-15T08:50:07Z",
        "updatedAt" : "2019-07-29T11:11:32Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a45d5ba3-9b5e-49b9-868c-4e5a2b15024c",
        "parentId" : "b93f4886-2b09-4cf7-9301-d643a358e2b3",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I believe the failing test in CI is because of this. You can run\r\n```bash\r\nbazel test //ledger/sandbox:sandbox-scala-tests_test_suite_src_test_suite_scala_com_digitalasset_platform_sandbox_stores_ledger_sql_PostgresDaoSpec.scala\r\n```\r\nto test locally.",
        "createdAt" : "2019-07-15T12:02:27Z",
        "updatedAt" : "2019-07-29T11:11:32Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "32b9c53286fc57cb866c7a586b41bb9fdf2064f6",
    "line" : null,
    "diffHunk" : "@@ -1073,15 +1074,15 @@ private class PostgresLedgerDao(\n                     \"package\" -> p._1.toByteArray\n                 )\n               )\n-            executeBatchSql(\n-              SQL_INSERT_PACKAGE,\n-              namedPackageParams\n-            )\n-            PersistenceResponse.Ok\n-          }.recover {\n-            case NonFatal(e) if e.getMessage.contains(\"duplicate key\") =>\n-              conn.rollback()\n+            import scala.math.min\n+            val changeCount = executeBatchSql(SQL_INSERT_PACKAGE, namedPackageParams)\n+              .map(min(0, _))"
  },
  {
    "id" : "132600c1-cc16-4fef-82d4-b19e75acfc2a",
    "prId" : 2131,
    "comments" : [
      {
        "id" : "eafe219b-644d-4604-ac1d-5f8ecb80ef30",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I really didn't like this, the whole logic relies on the error message as a _stable API_. Good riddance!",
        "createdAt" : "2019-07-15T12:15:02Z",
        "updatedAt" : "2019-07-29T11:11:32Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "32b9c53286fc57cb866c7a586b41bb9fdf2064f6",
    "line" : 50,
    "diffHunk" : "@@ -1073,15 +1074,15 @@ private class PostgresLedgerDao(\n                     \"package\" -> p._1.toByteArray\n                 )\n               )\n-            executeBatchSql(\n-              SQL_INSERT_PACKAGE,\n-              namedPackageParams\n-            )\n-            PersistenceResponse.Ok\n-          }.recover {\n-            case NonFatal(e) if e.getMessage.contains(\"duplicate key\") =>"
  },
  {
    "id" : "e0634209-73f1-4bc8-8645-c046ad4691b3",
    "prId" : 2131,
    "comments" : [
      {
        "id" : "87270065-9c80-4604-8ab9-8f883a6d79d4",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I would suggest to change the return type of this to make sure the consumer can understand better. Ideally it would be `Map[PackageId, PersistenceResponse]` but I'm not sure it would be possible to get this information easily. I guess `Map[PersistenceResponse, Int]` will do.",
        "createdAt" : "2019-07-15T12:17:00Z",
        "updatedAt" : "2019-07-29T11:11:32Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "32b9c53286fc57cb866c7a586b41bb9fdf2064f6",
    "line" : null,
    "diffHunk" : "@@ -1073,15 +1074,15 @@ private class PostgresLedgerDao(\n                     \"package\" -> p._1.toByteArray\n                 )\n               )\n-            executeBatchSql(\n-              SQL_INSERT_PACKAGE,\n-              namedPackageParams\n-            )\n-            PersistenceResponse.Ok\n-          }.recover {\n-            case NonFatal(e) if e.getMessage.contains(\"duplicate key\") =>\n-              conn.rollback()\n+            import scala.math.min\n+            val changeCount = executeBatchSql(SQL_INSERT_PACKAGE, namedPackageParams)\n+              .map(min(0, _))\n+              .sum\n+            if (changeCount == packages.length) {\n+              PersistenceResponse.Ok"
  },
  {
    "id" : "ae6b5e14-90c5-4675-b2cf-a8e961557b5f",
    "prId" : 2131,
    "comments" : [
      {
        "id" : "1ea7c279-a981-4d2e-bf7f-31b1e471144c",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Why the `max(0, _)`? I can't find nice docs for `BatchSql`, but it looks like it should return the number of changed rows for each batch element (which should be exactly 0 or 1). Does it return something like -1 in some cases?",
        "createdAt" : "2019-07-16T14:20:26Z",
        "updatedAt" : "2019-07-29T11:11:32Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9176525f-95aa-4774-9614-fd8657a888f1",
        "parentId" : "1ea7c279-a981-4d2e-bf7f-31b1e471144c",
        "author" : {
          "login" : "da-tanabe",
          "name" : "Davin K. Tanabe",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19478290?u=c4eed11976b50dbaed21ccb17371a74a7e802541&v=4"
        },
        "body" : "Under the hood, anorm calls this method: https://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html#executeBatch()\r\n\r\nIt returns either a nonnegative number or one of two error codes, both of which are negative values. (One of those cases is `SUCCESS_NO_INFO`, so not sure what the right behavior is for this case… :-/ )",
        "createdAt" : "2019-07-17T13:02:05Z",
        "updatedAt" : "2019-07-29T11:11:32Z",
        "lastEditedBy" : {
          "login" : "da-tanabe",
          "name" : "Davin K. Tanabe",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19478290?u=c4eed11976b50dbaed21ccb17371a74a7e802541&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "32b9c53286fc57cb866c7a586b41bb9fdf2064f6",
    "line" : null,
    "diffHunk" : "@@ -1073,15 +1074,18 @@ private class PostgresLedgerDao(\n                     \"package\" -> p._1.toByteArray\n                 )\n               )\n-            executeBatchSql(\n-              SQL_INSERT_PACKAGE,\n-              namedPackageParams\n-            )\n-            PersistenceResponse.Ok\n-          }.recover {\n-            case NonFatal(e) if e.getMessage.contains(\"duplicate key\") =>\n-              conn.rollback()\n-              PersistenceResponse.Duplicate\n+            import scala.math.max\n+            val changeCount: Int = executeBatchSql(SQL_INSERT_PACKAGE, namedPackageParams)\n+              .map(max(0, _))"
  },
  {
    "id" : "7102d197-7745-44e6-8978-9df2f1aabc5e",
    "prId" : 1985,
    "comments" : [
      {
        "id" : "30203625-c29f-490e-95ff-a29581346ac0",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please open a github issue for this and reference the issue here in a code comment.",
        "createdAt" : "2019-07-05T13:20:34Z",
        "updatedAt" : "2019-07-05T14:48:28Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0863fc77-1b19-4127-8d1b-708cacd51e45",
        "parentId" : "30203625-c29f-490e-95ff-a29581346ac0",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Issue #2026 ",
        "createdAt" : "2019-07-05T14:38:46Z",
        "updatedAt" : "2019-07-05T14:48:28Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a76d1f28b41fc02600441b5d40c9b25038667c33",
    "line" : 4,
    "diffHunk" : "@@ -963,6 +963,8 @@ private class PostgresLedgerDao(\n     dbDispatcher.executeSql { implicit conn =>\n       SQL_SELECT_PARTIES\n         .as(PartyDataParser.*)\n+        // TODO: isLocal should be based on equality of participantId reported in an"
  },
  {
    "id" : "1e539a2e-9845-48f6-8853-b2b4ee91ace1",
    "prId" : 1818,
    "comments" : [
      {
        "id" : "a1ca9343-d0df-4ba6-bc53-3792a0ca4a60",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "nitpick: in general you want to do as little as possible within `dbDispatcher.executeSql` to avoid occupying the SQL dedicated threads with CPU heavy stuff. As a rule of thumb, only code requiring a connection should be within such blocks.",
        "createdAt" : "2019-06-28T08:22:24Z",
        "updatedAt" : "2019-07-02T12:24:58Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "94890df5-1b83-45e4-806d-4bfd6e5d73cd",
        "parentId" : "a1ca9343-d0df-4ba6-bc53-3792a0ca4a60",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Makes sense, I will move the task of creating the submission ID to `SqlLedger`.",
        "createdAt" : "2019-06-28T08:38:33Z",
        "updatedAt" : "2019-07-02T12:24:58Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bae23a0a96200d0ece436a646cceb68a50511f37",
    "line" : null,
    "diffHunk" : "@@ -963,6 +966,93 @@ private class PostgresLedgerDao(\n     }\n   }\n \n+  // Note: package upload is idempotent\n+  private val SQL_INSERT_PACKAGE =\n+    \"\"\"insert into packages(package_id, submission_id, source_description, size, known_since, ledger_offset, package)\n+          |select {package_id}, {submission_id}, {source_description}, {size}, {known_since}, ledger_end, {package}\n+          |from parameters\n+          |on conflict (package_id)\n+          |do nothing\n+          |\"\"\".stripMargin\n+\n+  private val SQL_SELECT_PACKAGES =\n+    SQL(\"\"\"select package_id, source_description, known_since, size\n+          |from packages\n+          |\"\"\".stripMargin)\n+\n+  private val SQL_SELECT_PACKAGE =\n+    SQL(\"\"\"select package\n+          |from packages\n+          |where package_id = {package_id}\n+          |\"\"\".stripMargin)\n+\n+  case class ParsedPackageData(\n+      packageId: String,\n+      sourceDescription: Option[String],\n+      size: Long,\n+      knownSince: Date)\n+\n+  private val PackageDataParser: RowParser[ParsedPackageData] =\n+    Macro.parser[ParsedPackageData](\n+      \"package_id\",\n+      \"source_description\",\n+      \"size\",\n+      \"known_since\"\n+    )\n+\n+  override def listLfPackages: Future[Map[PackageId, PackageDetails]] =\n+    dbDispatcher.executeSql { implicit conn =>\n+      SQL_SELECT_PACKAGES\n+        .as(PackageDataParser.*)\n+        .map(\n+          d =>\n+            PackageId.assertFromString(d.packageId) -> PackageDetails(\n+              d.size,\n+              d.knownSince.toInstant,\n+              d.sourceDescription))\n+        .toMap\n+    }\n+\n+  override def getLfArchive(packageId: PackageId): Future[Option[Archive]] =\n+    dbDispatcher.executeSql { implicit conn =>\n+      SQL_SELECT_PACKAGE\n+        .on(\n+          \"package_id\" -> packageId\n+        )\n+        .as[Option[Array[Byte]]](SqlParser.byteArray(\"package\").singleOpt)\n+        .map(data => Archive.parseFrom(Decode.damlLfCodedInputStreamFromBytes(data)))\n+    }\n+\n+  override def uploadLfPackages(\n+      packages: List[(Archive, PackageDetails)]): Future[UploadPackagesResult] = {\n+    dbDispatcher.executeSql { implicit conn =>\n+      Try {\n+        val submissionId = UUID.randomUUID().toString"
  },
  {
    "id" : "afd67844-5934-42fc-b8d9-0aae0a262a1c",
    "prId" : 1818,
    "comments" : [
      {
        "id" : "7acec0c6-51e9-445b-90b6-4d13fcaa12ee",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "returning an `UploadPackagesResult` should not be the concern of this class. That way you can avoid the `Try/rollback` logic, and just call `transform` on the resulting `Future` to do the mapping to `UploadPackagesResult`",
        "createdAt" : "2019-06-28T08:25:13Z",
        "updatedAt" : "2019-07-02T12:24:58Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7019fe88-4454-479b-98a8-ec257f0eee3c",
        "parentId" : "7acec0c6-51e9-445b-90b6-4d13fcaa12ee",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "I see this is not necessary for the packages. It was done for party management, to differentiate duplicate parties from other database errors. Would you have party allocation method return `Future[Unit]`, and map all failures to `PartyAllocationResult.AlreadyExists`? Or create a custom Ok/Duplicate/OtherError sum type?",
        "createdAt" : "2019-06-28T08:37:29Z",
        "updatedAt" : "2019-07-02T12:24:58Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a371e55c-ad2e-4deb-9433-096c05d71b0b",
        "parentId" : "7acec0c6-51e9-445b-90b6-4d13fcaa12ee",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Oh I see. In that case I would probably follow that pattern like here: https://github.com/digital-asset/daml/blob/c23af0eaa04a63bdda6e58c964a1b824448c7f96/ledger/sandbox/src/main/scala/com/digitalasset/platform/sandbox/stores/ledger/sql/dao/PostgresLedgerDao.scala#L553",
        "createdAt" : "2019-06-28T09:00:32Z",
        "updatedAt" : "2019-07-02T12:24:58Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bae23a0a96200d0ece436a646cceb68a50511f37",
    "line" : 119,
    "diffHunk" : "@@ -963,6 +966,93 @@ private class PostgresLedgerDao(\n     }\n   }\n \n+  // Note: package upload is idempotent\n+  private val SQL_INSERT_PACKAGE =\n+    \"\"\"insert into packages(package_id, submission_id, source_description, size, known_since, ledger_offset, package)\n+          |select {package_id}, {submission_id}, {source_description}, {size}, {known_since}, ledger_end, {package}\n+          |from parameters\n+          |on conflict (package_id)\n+          |do nothing\n+          |\"\"\".stripMargin\n+\n+  private val SQL_SELECT_PACKAGES =\n+    SQL(\"\"\"select package_id, source_description, known_since, size\n+          |from packages\n+          |\"\"\".stripMargin)\n+\n+  private val SQL_SELECT_PACKAGE =\n+    SQL(\"\"\"select package\n+          |from packages\n+          |where package_id = {package_id}\n+          |\"\"\".stripMargin)\n+\n+  case class ParsedPackageData(\n+      packageId: String,\n+      sourceDescription: Option[String],\n+      size: Long,\n+      knownSince: Date)\n+\n+  private val PackageDataParser: RowParser[ParsedPackageData] =\n+    Macro.parser[ParsedPackageData](\n+      \"package_id\",\n+      \"source_description\",\n+      \"size\",\n+      \"known_since\"\n+    )\n+\n+  override def listLfPackages: Future[Map[PackageId, PackageDetails]] =\n+    dbDispatcher.executeSql { implicit conn =>\n+      SQL_SELECT_PACKAGES\n+        .as(PackageDataParser.*)\n+        .map(\n+          d =>\n+            PackageId.assertFromString(d.packageId) -> PackageDetails(\n+              d.size,\n+              d.knownSince.toInstant,\n+              d.sourceDescription))\n+        .toMap\n+    }\n+\n+  override def getLfArchive(packageId: PackageId): Future[Option[Archive]] =\n+    dbDispatcher.executeSql { implicit conn =>\n+      SQL_SELECT_PACKAGE\n+        .on(\n+          \"package_id\" -> packageId\n+        )\n+        .as[Option[Array[Byte]]](SqlParser.byteArray(\"package\").singleOpt)\n+        .map(data => Archive.parseFrom(Decode.damlLfCodedInputStreamFromBytes(data)))\n+    }\n+\n+  override def uploadLfPackages(\n+      packages: List[(Archive, PackageDetails)]): Future[UploadPackagesResult] = {\n+    dbDispatcher.executeSql { implicit conn =>\n+      Try {\n+        val submissionId = UUID.randomUUID().toString\n+        val namedPackageParams = packages\n+          .map(\n+            p =>\n+              Seq[NamedParameter](\n+                \"package_id\" -> p._1.getHash,\n+                \"submission_id\" -> submissionId,\n+                \"source_description\" -> p._2.sourceDescription,\n+                \"size\" -> p._2.size,\n+                \"known_since\" -> p._2.knownSince,\n+                \"package\" -> p._1.toByteArray\n+            )\n+          )\n+        executeBatchSql(\n+          SQL_INSERT_PACKAGE,\n+          namedPackageParams\n+        )\n+        UploadPackagesResult.Ok\n+      }.recover {\n+        case NonFatal(e) =>\n+          conn.rollback()"
  },
  {
    "id" : "e2073b2f-aea1-424f-8965-e91c1a251078",
    "prId" : 1452,
    "comments" : [
      {
        "id" : "85b55f15-bd37-4eaa-a178-e8e169a305c6",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Maybe I'm mistaken, but the ledger_end is updated AFTER inserting the transaction and updating the active contracts, which means the party gets the offset of the previous entry (checkpoint, rejection, ...). Or am I missing something?",
        "createdAt" : "2019-06-07T11:33:09Z",
        "updatedAt" : "2019-06-07T21:22:35Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c4371c5d-d352-453c-bf69-6a689d5004fc",
        "parentId" : "85b55f15-bd37-4eaa-a178-e8e169a305c6",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "From the table definition:\r\n```\r\n  -- True iff the party was added explicitly through an API call\r\n  explicit bool not null,\r\n  -- For implicitly added parties: the offset of the transaction that introduced the party\r\n  -- For explicitly added parties: the ledger end at the time when the party was added\r\n  ledger_offset bigint\r\n```\r\n\r\nThe above SQL statement is only for explicitly inserting parties through the ledger API, which is done outside of the persistence queue used for ledger entries.\r\nThe main purpose of this field is to allow a future migration to insert \"party added\" ledger entries at the correct place. This will not be an easy migration, as inserting new ledger entries in the middle of the stream means transactions will get new offsets.",
        "createdAt" : "2019-06-07T11:59:11Z",
        "updatedAt" : "2019-06-07T21:22:35Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c3005f34-c542-4c30-94bd-52686881e001",
        "parentId" : "85b55f15-bd37-4eaa-a178-e8e169a305c6",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "oh, right. sorry I missed that. thank you for the explanation.",
        "createdAt" : "2019-06-07T12:35:05Z",
        "updatedAt" : "2019-06-07T21:22:35Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "21be6910a5debd0672b0db0815d8993c33b21e53",
    "line" : 97,
    "diffHunk" : "@@ -871,6 +898,56 @@ private class PostgresLedgerDao(\n         DirectExecutionContext)\n   }\n \n+  private val SQL_SELECT_PARTIES =\n+    SQL(\"select party, display_name, ledger_offset, explicit from parties\")\n+\n+  case class ParsedPartyData(\n+      party: String,\n+      displayName: Option[String],\n+      ledgerOffset: Long,\n+      explicit: Boolean)\n+\n+  private val PartyDataParser: RowParser[ParsedPartyData] =\n+    Macro.parser[ParsedPartyData](\n+      \"party\",\n+      \"display_name\",\n+      \"ledger_offset\",\n+      \"explicit\"\n+    )\n+\n+  override def getParties: Future[List[PartyDetails]] =\n+    dbDispatcher.executeSql { implicit conn =>\n+      SQL_SELECT_PARTIES\n+        .as(PartyDataParser.*)\n+        .map(d => PartyDetails(Party.assertFromString(d.party), d.displayName, true))\n+    }\n+\n+  private val SQL_INSERT_PARTY =\n+    SQL(\"\"\"insert into parties(party, display_name, ledger_offset, explicit)\n+        |select {party}, {display_name}, ledger_end, 'true'\n+        |from parameters\"\"\".stripMargin)"
  },
  {
    "id" : "ce4df366-d475-4719-bb07-ed99798adb09",
    "prId" : 959,
    "comments" : [
      {
        "id" : "4a249535-2036-41b9-b905-272f9a25ac4a",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "@gaboraranyossy-da There is now a new DAO method to store the initial state from the scenario loader. Previously, we just processed all `LedgerEntry`s produced by the loader (recomputing the ACS from scratch), but these do not contain the blinding info required to updated the ACS. This new method is given the in-memory ACS and the list of `LedgerEntry`s",
        "createdAt" : "2019-05-07T06:37:39Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2adca513-26bf-4fd5-8c34-5c92a397d61a",
        "parentId" : "4a249535-2036-41b9-b905-272f9a25ac4a",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Ok. Shouldn't we depend on the `ActiveContracts` trait instead?",
        "createdAt" : "2019-05-07T07:03:09Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8986b3b5-d744-43bf-b621-e59ad795b76f",
        "parentId" : "4a249535-2036-41b9-b905-272f9a25ac4a",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "The `ActiveContracts` trait only defines methods to modify the ACS, and query individual contracts.\r\n\r\nThe `storeInitialState` method is specifically for copying the initial ACS that was produced by the scenario loader, and needs access to the full list of active contracts and contract keys.\r\n\r\nI could extends the trait to contain methods to return the full content of the ACS, but that sounds unnecessary. Let me know if you would still prefer that.",
        "createdAt" : "2019-05-07T07:52:05Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fe74820b-2541-4f25-8a05-e4bad42cfec0",
        "parentId" : "4a249535-2036-41b9-b905-272f9a25ac4a",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "i'd add it to the interface as well. We should not depend on implementations if possible. ",
        "createdAt" : "2019-05-07T08:22:47Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "95f72f77-8f1a-405f-88d6-6e383ccc0da5",
        "parentId" : "4a249535-2036-41b9-b905-272f9a25ac4a",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "I have changed the interface of this method to take a `immutable.Seq[Contract]` instead of `ActiveContractsInMemory `.",
        "createdAt" : "2019-05-10T21:32:30Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7e93ba5b-b70b-4b2f-9453-57f9eb41b889",
        "parentId" : "4a249535-2036-41b9-b905-272f9a25ac4a",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "ok, that sounds good",
        "createdAt" : "2019-05-13T08:38:55Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e4dc5b75fb95575adb8e21bb2ae04bcccdc97acf",
    "line" : 428,
    "diffHunk" : "@@ -446,6 +481,13 @@ private class PostgresLedgerDao(\n       }\n   }\n \n+  override def storeInitialState(\n+      acs: ActiveContractsInMemory,\n+      ledgerEntries: immutable.Seq[LedgerEntry]\n+  ): Future[Unit] = {"
  },
  {
    "id" : "e3faac64-1e9c-4888-a263-21d7e9694093",
    "prId" : 754,
    "comments" : [
      {
        "id" : "09d5e111-6aa9-4b23-9ee9-dcaff441eb5d",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "i think this relies on the assumption that the stream is monotonically growing. if it was not monotonically growing, you could end up with different results with the pagination as opposed to the single query.\r\n\r\nif i'm correct, please note this fact in the code.",
        "createdAt" : "2019-04-29T09:15:40Z",
        "updatedAt" : "2019-04-29T10:11:33Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "11d78246-d2e0-4d27-aa27-be3a15713569",
        "parentId" : "09d5e111-6aa9-4b23-9ee9-dcaff441eb5d",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "yes it does. I added a note as you requested.",
        "createdAt" : "2019-04-29T09:20:34Z",
        "updatedAt" : "2019-04-29T10:11:33Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a7c5c82f7085b44368f72d6bcc130128e8519aa5",
    "line" : 13,
    "diffHunk" : "@@ -658,18 +658,41 @@ private class PostgresLedgerDao(\n   private val SQL_GET_LEDGER_ENTRIES = SQL(\n     \"select * from ledger_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n \n-  //TODO we should use paging instead, check if Alpakka can do that?\n+  private def paginatingStream[T](\n+      startInclusive: Long,\n+      endExclusive: Long,\n+      pageSize: Int,\n+      queryPage: (Long, Long) => Source[T, NotUsed]): Source[T, NotUsed] ="
  },
  {
    "id" : "cd23597a-c20a-46f2-8a28-45c64ed4b034",
    "prId" : 754,
    "comments" : [
      {
        "id" : "76de1cea-dac7-4487-b8f5-c926bfde6877",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "```suggestion\r\n  // Note that here we are reading, non transactionally, the stream in chunks. The reason why this is\r\n  // safe is that\r\n  // * The ledger entries are never removed;\r\n  // * We fix the ledger end at the beginning.\r\n```",
        "createdAt" : "2019-04-29T10:08:51Z",
        "updatedAt" : "2019-04-29T10:11:33Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a7c5c82f7085b44368f72d6bcc130128e8519aa5",
    "line" : null,
    "diffHunk" : "@@ -658,18 +658,42 @@ private class PostgresLedgerDao(\n   private val SQL_GET_LEDGER_ENTRIES = SQL(\n     \"select * from ledger_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive} order by ledger_offset asc\")\n \n-  //TODO we should use paging instead, check if Alpakka can do that?\n+  // queryPage has to return values monotonically increasing by their offsets!"
  },
  {
    "id" : "2e17da04-4105-421b-8cf8-9a3374dacc34",
    "prId" : 752,
    "comments" : [
      {
        "id" : "0a6841b8-5b8e-4270-a25a-07a888c4cb7e",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "I will address this in a follow-up PR",
        "createdAt" : "2019-04-29T15:09:19Z",
        "updatedAt" : "2019-04-29T16:12:32Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "274ca7de6c735c916257d57e61908ae8f5777ca0",
    "line" : null,
    "diffHunk" : "@@ -82,10 +80,13 @@ private class PostgresLedgerDao(\n       )\n       .map(_ => ())(DirectExecutionContext)\n \n-  private def updateParameter(key: String, value: String)(implicit conn: Connection): Unit = {\n-    SQL_UPDATE_PARAM\n-      .on(\"k\" -> key)\n-      .on(\"v\" -> value)\n+  //TODO: casting is not nice, shall we have a table for the params instead?"
  },
  {
    "id" : "e8625ee3-8203-4bb5-a979-0dd3b0584089",
    "prId" : 752,
    "comments" : [
      {
        "id" : "11d96dee-6918-49ca-aa10-40440e55a317",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "```suggestion\r\n  // TODO: casting is not nice, shall we have a table for the params instead?\r\n  // Note that the ledger entries grow monotonically, however we store many ledger entries in parallel,\r\n  // and thus we need to make sure to only update the ledger end when the ledger entry we're committing\r\n  // is advancing it.\r\n```",
        "createdAt" : "2019-04-29T16:08:22Z",
        "updatedAt" : "2019-04-29T16:12:32Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "274ca7de6c735c916257d57e61908ae8f5777ca0",
    "line" : null,
    "diffHunk" : "@@ -82,10 +80,13 @@ private class PostgresLedgerDao(\n       )\n       .map(_ => ())(DirectExecutionContext)\n \n-  private def updateParameter(key: String, value: String)(implicit conn: Connection): Unit = {\n-    SQL_UPDATE_PARAM\n-      .on(\"k\" -> key)\n-      .on(\"v\" -> value)\n+  //TODO: casting is not nice, shall we have a table for the params instead?"
  },
  {
    "id" : "59a57dea-0e0e-4293-a26a-5bfe75f444c7",
    "prId" : 611,
    "comments" : [
      {
        "id" : "4438b199-0f01-4a00-a8a3-d75d05905bc6",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "I will address this in a follow-up PR",
        "createdAt" : "2019-04-23T11:20:11Z",
        "updatedAt" : "2019-04-24T10:54:57Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dd787143-d02c-46cc-acc9-dad42ef2c649",
        "parentId" : "4438b199-0f01-4a00-a8a3-d75d05905bc6",
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "what do you mean with paging -- chunk the results rather than getting them all at a time?",
        "createdAt" : "2019-04-24T09:00:46Z",
        "updatedAt" : "2019-04-24T10:54:57Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a891f2be-9933-4df1-8edc-c4dfceb7c0a6",
        "parentId" : "4438b199-0f01-4a00-a8a3-d75d05905bc6",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Precisely. Here it's perfectly possible and it's a much better approach. See: https://github.com/digital-asset/daml/pull/641",
        "createdAt" : "2019-04-24T09:09:02Z",
        "updatedAt" : "2019-04-24T10:54:57Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "80a155bf0253163f8e06e1fb42f82f22e3ae95fe",
    "line" : 219,
    "diffHunk" : "@@ -632,6 +659,22 @@ private class PostgresLedgerDao(\n       .toSet\n       .map(Ref.Party.assertFromString)\n \n+  private val SQL_GET_LEDGER_ENTRIES = SQL(\n+    \"select * from ledger_entries where ledger_offset>={startInclusive} and ledger_offset<{endExclusive}\")\n+\n+  //TODO we should use paging instead, check if Alpakka can do that?"
  },
  {
    "id" : "a24ba4a6-d3dd-44dc-9eba-c8f888446bf8",
    "prId" : 444,
    "comments" : [
      {
        "id" : "683824c1-f3e4-4fff-a2de-78aca4184514",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "We could cache this in a member field. `MessageDigest` might cache itself too, but it's safer to do it ourselves.",
        "createdAt" : "2019-04-16T05:57:50Z",
        "updatedAt" : "2019-04-16T07:25:47Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4ffa0f39-23bf-4fe5-8b27-341056c0359f",
        "parentId" : "683824c1-f3e4-4fff-a2de-78aca4184514",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Using a single instance of `MessageDigest` would mean the `keyHash` function would not be thread safe, I don't think that's a good idea. `keyHash` is called by both `lookupKey` and `storeLedgerEntry`.",
        "createdAt" : "2019-04-16T07:21:51Z",
        "updatedAt" : "2019-04-16T07:25:47Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ee5e7b80-b1c2-40a2-986a-0a90eabb88fa",
        "parentId" : "683824c1-f3e4-4fff-a2de-78aca4184514",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Oops, I missed that. Nevermind then ",
        "createdAt" : "2019-04-16T07:36:29Z",
        "updatedAt" : "2019-04-16T07:36:29Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2caa7f293aac7972574e45eb2989deaffe86da96",
    "line" : 62,
    "diffHunk" : "@@ -95,6 +98,64 @@ private class PostgresLedgerDao(\n           .as(SqlParser.str(\"value\").singleOpt)\n     )\n \n+  private val SQL_INSERT_CONTRACT_KEY =\n+    SQL(\n+      \"insert into contract_keys(package_id, name, value_hash, contract_id) values({package_id}, {name}, {value_hash}, {contract_id})\")\n+\n+  private val SQL_SELECT_CONTRACT_KEY =\n+    SQL(\n+      \"select contract_id from contract_keys where package_id={package_id} and name={name} and value_hash={value_hash}\")\n+\n+  private val SQL_REMOVE_CONTRACT_KEY =\n+    SQL(\n+      \"delete from contract_keys where package_id={package_id} and name={name} and value_hash={value_hash}\")\n+\n+  /**\n+    * TODO: This hash is currently not stable. The default value serializer uses protobuf serialization, which may change.\n+    * See https://github.com/digital-asset/daml/issues/497\n+    */\n+  private[this] def keyHash(key: GlobalKey): String = {\n+    val digest = MessageDigest.getInstance(\"SHA-256\")"
  },
  {
    "id" : "5afa31dd-4d57-4599-96f2-493c6177f7e5",
    "prId" : 444,
    "comments" : [
      {
        "id" : "7563addc-d026-4ed3-990b-d136f055c637",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "use `sys.error` and `identity` instead",
        "createdAt" : "2019-04-16T05:58:21Z",
        "updatedAt" : "2019-04-16T07:25:47Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2caa7f293aac7972574e45eb2989deaffe86da96",
    "line" : null,
    "diffHunk" : "@@ -95,6 +98,64 @@ private class PostgresLedgerDao(\n           .as(SqlParser.str(\"value\").singleOpt)\n     )\n \n+  private val SQL_INSERT_CONTRACT_KEY =\n+    SQL(\n+      \"insert into contract_keys(package_id, name, value_hash, contract_id) values({package_id}, {name}, {value_hash}, {contract_id})\")\n+\n+  private val SQL_SELECT_CONTRACT_KEY =\n+    SQL(\n+      \"select contract_id from contract_keys where package_id={package_id} and name={name} and value_hash={value_hash}\")\n+\n+  private val SQL_REMOVE_CONTRACT_KEY =\n+    SQL(\n+      \"delete from contract_keys where package_id={package_id} and name={name} and value_hash={value_hash}\")\n+\n+  /**\n+    * TODO: This hash is currently not stable. The default value serializer uses protobuf serialization, which may change.\n+    * See https://github.com/digital-asset/daml/issues/497\n+    */\n+  private[this] def keyHash(key: GlobalKey): String = {\n+    val digest = MessageDigest.getInstance(\"SHA-256\")\n+    valueSerializer\n+      .serialiseValue(key.key)\n+      .map(ba => digest.digest(ba).map(\"%02x\" format _).mkString)\n+      .fold[String](e => throw new RuntimeException(e.toString), s => s)"
  },
  {
    "id" : "304a7fce-c8a1-4a7d-b1fa-0b55c562911f",
    "prId" : 444,
    "comments" : [
      {
        "id" : "d877d8f4-be5f-4daf-8f09-edf210d39ad0",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "why is the `orNull` needed?",
        "createdAt" : "2019-04-16T05:59:43Z",
        "updatedAt" : "2019-04-16T07:25:47Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "651baa59-8b56-4fe4-ba65-8c513f96736f",
        "parentId" : "d877d8f4-be5f-4daf-8f09-edf210d39ad0",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "I thought this was how SQL `NULL` values are passed, but it looks like there is an implicit conversion from `Option`.",
        "createdAt" : "2019-04-16T07:43:02Z",
        "updatedAt" : "2019-04-16T07:43:02Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2caa7f293aac7972574e45eb2989deaffe86da96",
    "line" : null,
    "diffHunk" : "@@ -131,7 +195,15 @@ private class PostgresLedgerDao(\n               \"create_offset\" -> offset,\n               \"contract\" -> contractSerializer\n                 .serialiseContractInstance(c.coinst)\n-                .getOrElse(sys.error(s\"failed to serialise contract! cid:${c.contractId.coid}\"))\n+                .getOrElse(sys.error(s\"failed to serialise contract! cid:${c.contractId.coid}\")),\n+              \"key\" -> c.key\n+                .map(\n+                  k =>\n+                    valueSerializer\n+                      .serialiseValue(k.key)\n+                      .getOrElse(sys.error(\n+                        s\"failed to serialise contract key value! cid:${c.contractId.coid}\")))\n+                .orNull"
  },
  {
    "id" : "eed98cbc-8e92-4fcf-b6ee-a026bc8135fe",
    "prId" : 444,
    "comments" : [
      {
        "id" : "fce01209-db2e-4b58-a285-86df3d703a5f",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "use `foreach` instead of `map` to show clearer intention",
        "createdAt" : "2019-04-16T06:00:33Z",
        "updatedAt" : "2019-04-16T07:25:47Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2caa7f293aac7972574e45eb2989deaffe86da96",
    "line" : null,
    "diffHunk" : "@@ -212,20 +309,21 @@ private class PostgresLedgerDao(\n       def acsLookupContract(acs: Unit, cid: AbsoluteContractId) =\n         lookupActiveContractSync(cid).map(_.toActiveContract)\n \n-      //TODO: Implement check whether the given contract key exists\n-      def acsKeyExists(acc: Unit, key: GlobalKey): Boolean = false\n+      def acsKeyExists(acc: Unit, key: GlobalKey): Boolean = selectContractKey(key).isDefined\n \n-      //TODO: store contract key\n       def acsAddContract(\n           acs: Unit,\n           cid: AbsoluteContractId,\n           c: ActiveContracts.ActiveContract,\n-          keyO: Option[GlobalKey]): Unit =\n+          keyO: Option[GlobalKey]): Unit = {\n         storeContract(offset, Contract.fromActiveContract(cid, c))\n+        keyO.map(key => storeContractKey(key, cid))"
  },
  {
    "id" : "8fba1dfb-9834-4c57-8d85-890cf9373bb8",
    "prId" : 444,
    "comments" : [
      {
        "id" : "7081b5d1-a024-4c44-9e7e-f1af7433d54c",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "same as above",
        "createdAt" : "2019-04-16T06:00:48Z",
        "updatedAt" : "2019-04-16T07:25:47Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2caa7f293aac7972574e45eb2989deaffe86da96",
    "line" : null,
    "diffHunk" : "@@ -212,20 +309,21 @@ private class PostgresLedgerDao(\n       def acsLookupContract(acs: Unit, cid: AbsoluteContractId) =\n         lookupActiveContractSync(cid).map(_.toActiveContract)\n \n-      //TODO: Implement check whether the given contract key exists\n-      def acsKeyExists(acc: Unit, key: GlobalKey): Boolean = false\n+      def acsKeyExists(acc: Unit, key: GlobalKey): Boolean = selectContractKey(key).isDefined\n \n-      //TODO: store contract key\n       def acsAddContract(\n           acs: Unit,\n           cid: AbsoluteContractId,\n           c: ActiveContracts.ActiveContract,\n-          keyO: Option[GlobalKey]): Unit =\n+          keyO: Option[GlobalKey]): Unit = {\n         storeContract(offset, Contract.fromActiveContract(cid, c))\n+        keyO.map(key => storeContractKey(key, cid))\n+        ()\n+      }\n \n-      //TODO: remove contract key\n       def acsRemoveContract(acs: Unit, cid: AbsoluteContractId, keyO: Option[GlobalKey]): Unit = {\n         archiveContract(offset, cid)\n+        keyO.map(key => removeContractKey(key))"
  }
]