[
  {
    "id" : "ef7d5ba4-3750-4e2c-82e0-05ffa1a92365",
    "prId" : 6143,
    "comments" : [
      {
        "id" : "dd28a885-358f-463d-a3eb-3498be8d8755",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Why not propagate `CommittedTransaction` into here as well?",
        "createdAt" : "2020-05-29T07:52:45Z",
        "updatedAt" : "2020-06-08T14:24:10Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b7de4066-cef8-4b5b-8e46-cf0bec2bd3d9",
        "parentId" : "dd28a885-358f-463d-a3eb-3498be8d8755",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done.",
        "createdAt" : "2020-05-29T10:17:05Z",
        "updatedAt" : "2020-06-08T14:24:10Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "89af6d420800adee764159fb1c3073fae07859e9",
    "line" : null,
    "diffHunk" : "@@ -73,7 +75,7 @@ private[dao] object PostCommitValidation {\n       * 2. refer exclusively to contracts with a ledger effective time smaller than or equal to the transaction's?\n       */\n     private def validateCausalMonotonicity(\n-        transaction: Transaction,\n+        transaction: Tx.Transaction,"
  },
  {
    "id" : "8ff05d6d-1954-4dbf-b6bd-89e3a317c4a4",
    "prId" : 5815,
    "comments" : [
      {
        "id" : "9895174b-f1bf-4bac-9cf9-20a748dc6da0",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n    RejectionReason.Inconsistent(\"Unknown contract\")\r\n```",
        "createdAt" : "2020-05-04T09:10:39Z",
        "updatedAt" : "2020-05-04T10:58:15Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "94bc7bf5-8f5d-4e00-af21-8a5bc8a7d0cc",
        "parentId" : "9895174b-f1bf-4bac-9cf9-20a748dc6da0",
        "author" : {
          "login" : "simonmaxen-da",
          "name" : "Simon Maxen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/56595114?u=cfde0812fcba2729e1d8f0b715136950eee6f84f&v=4"
        },
        "body" : "Done",
        "createdAt" : "2020-05-04T09:23:56Z",
        "updatedAt" : "2020-05-04T10:58:15Z",
        "lastEditedBy" : {
          "login" : "simonmaxen-da",
          "name" : "Simon Maxen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/56595114?u=cfde0812fcba2729e1d8f0b715136950eee6f84f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4f79124066af85f3ee832b964b57bafe3f460ad2",
    "line" : null,
    "diffHunk" : "@@ -227,7 +227,7 @@ object PostCommitValidation {\n     )\n \n   private[events] val UnknownContract: RejectionReason =\n-    RejectionReason.Inconsistent\n+    RejectionReason.Inconsistent(\"Unknown Contract\")"
  },
  {
    "id" : "a70941c2-cdd2-4bc9-b5d5-34b128fb4c04",
    "prId" : 5737,
    "comments" : [
      {
        "id" : "f7dffd79-9192-4565-aedc-b31103f2c74f",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should this comment go above line 85? Looks like the querying is happening there.",
        "createdAt" : "2020-04-27T15:36:11Z",
        "updatedAt" : "2020-04-28T15:00:56Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab5056a9-9dd7-491a-896f-9eca50358409",
        "parentId" : "f7dffd79-9192-4565-aedc-b31103f2c74f",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Yes, some code moved and this is a leftover, thanks.",
        "createdAt" : "2020-04-27T15:48:38Z",
        "updatedAt" : "2020-04-28T15:00:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "79316bef-cf5f-4e14-b74f-6d96944ce73b",
        "parentId" : "f7dffd79-9192-4565-aedc-b31103f2c74f",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5737/commits/66a98902caf5384b1d9f95a612b06ccdb7e3f86b",
        "createdAt" : "2020-04-27T16:48:09Z",
        "updatedAt" : "2020-04-28T15:00:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "01da7393b32f8eb4cf5f4866f745997007cb8fdd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,230 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import java.sql.Connection\n+import java.time.Instant\n+\n+import com.daml.ledger.api.domain.RejectionReason\n+\n+/**\n+  * Performs post-commit validation on transactions for Sandbox Classic.\n+  * This is intended exclusively as a temporary replacement for\n+  * [[com.daml.platform.store.ActiveLedgerState]] and [[com.daml.platform.store.ActiveLedgerStateManager]]\n+  * so that the old post-commit validation backed by the old participant schema can be\n+  * dropped and the DAML-on-X-backed implementation of the Sandbox can skip it entirely.\n+  *\n+  * Post-commit validation is relevant for two reasons:\n+  * - keys can be referenced by two concurrent interpretations, potentially leading to\n+  *   either create nodes with duplicate active keys or lookup-by-key nodes referring to\n+  *   inactive keys\n+  * - the transaction's ledger effective time is determined after interpretation,\n+  *   meaning that causal monotonicity cannot be verified while interpreting a command\n+  */\n+sealed trait PostCommitValidation {\n+\n+  def validate(\n+      transaction: Transaction,\n+      transactionLedgerEffectiveTime: Instant,\n+      divulged: Set[ContractId],\n+      submitter: Party,\n+  )(implicit connection: Connection): Set[RejectionReason]\n+\n+}\n+\n+object PostCommitValidation {\n+\n+  /**\n+    * Accept unconditionally a transaction.\n+    *\n+    * Designed to be used by a ledger integration that\n+    * already performs post-commit validation.\n+    */\n+  object Skip extends PostCommitValidation {\n+    override def validate(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+        submitter: Party,\n+    )(implicit connection: Connection): Set[RejectionReason] =\n+      Set.empty\n+  }\n+\n+  final class BackedBy(data: PostCommitValidationData) extends PostCommitValidation {\n+\n+    def validate(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+        submitter: Party,\n+    )(implicit connection: Connection): Set[RejectionReason] = {\n+\n+      val causalMonotonicityRejection =\n+        validateCausalMonotonicity(transaction, transactionLedgerEffectiveTime, divulged)\n+\n+      val invalidKeyUsageRejection =\n+        validateKeyUsages(transaction, submitter)\n+\n+      causalMonotonicityRejection.union(invalidKeyUsageRejection)\n+    }\n+\n+    /**\n+      * Do all exercise, fetch and lookup-by-key nodes\n+      * 1. exist, and\n+      * 2. refer exclusively to contracts with a ledger effective time smaller than or equal to the transaction's?\n+      */\n+    private def validateCausalMonotonicity(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+    )(implicit connection: Connection): Set[RejectionReason] = {\n+\n+      // Collect all the identifiers of contracts that have not been divulged in the current transaction\n+      val maximumLedgerEffectiveTime =\n+        data.lookupMaximumLedgerTime(\n+          transaction.fold(Set.empty[ContractId]) {\n+            case (ids, (_, e: Exercise)) if !divulged(e.targetCoid) => ids + e.targetCoid\n+            case (ids, (_, f: Fetch)) if !divulged(f.coid) => ids + f.coid\n+            case (ids, (_, l: LookupByKey)) => l.result.filterNot(divulged).fold(ids)(ids + _)\n+            case (ids, _) => ids\n+          }\n+        )\n+\n+      // Query the committed contracts store for the maximum ledger effective time of the"
  },
  {
    "id" : "f3f5c071-861d-4574-92eb-baf7b8bef565",
    "prId" : 5737,
    "comments" : [
      {
        "id" : "7c287f8a-72f3-491a-99d1-e38b5f505c2b",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should `indexed transactions` rather be `indexed contracts` or `indexed keys`?",
        "createdAt" : "2020-04-27T15:38:58Z",
        "updatedAt" : "2020-04-28T15:00:56Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "633da792-097d-4d75-ac13-79ce256ae067",
        "parentId" : "7c287f8a-72f3-491a-99d1-e38b5f505c2b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Absolutely, thanks!",
        "createdAt" : "2020-04-27T15:48:46Z",
        "updatedAt" : "2020-04-28T15:00:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b90cfd9b-f0ff-417a-aa0d-4d59ce6715a0",
        "parentId" : "7c287f8a-72f3-491a-99d1-e38b5f505c2b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5737/commits/83d123331c49e94ed8209fd263cde54edac3957a",
        "createdAt" : "2020-04-27T16:48:33Z",
        "updatedAt" : "2020-04-28T15:00:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "01da7393b32f8eb4cf5f4866f745997007cb8fdd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,230 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import java.sql.Connection\n+import java.time.Instant\n+\n+import com.daml.ledger.api.domain.RejectionReason\n+\n+/**\n+  * Performs post-commit validation on transactions for Sandbox Classic.\n+  * This is intended exclusively as a temporary replacement for\n+  * [[com.daml.platform.store.ActiveLedgerState]] and [[com.daml.platform.store.ActiveLedgerStateManager]]\n+  * so that the old post-commit validation backed by the old participant schema can be\n+  * dropped and the DAML-on-X-backed implementation of the Sandbox can skip it entirely.\n+  *\n+  * Post-commit validation is relevant for two reasons:\n+  * - keys can be referenced by two concurrent interpretations, potentially leading to\n+  *   either create nodes with duplicate active keys or lookup-by-key nodes referring to\n+  *   inactive keys\n+  * - the transaction's ledger effective time is determined after interpretation,\n+  *   meaning that causal monotonicity cannot be verified while interpreting a command\n+  */\n+sealed trait PostCommitValidation {\n+\n+  def validate(\n+      transaction: Transaction,\n+      transactionLedgerEffectiveTime: Instant,\n+      divulged: Set[ContractId],\n+      submitter: Party,\n+  )(implicit connection: Connection): Set[RejectionReason]\n+\n+}\n+\n+object PostCommitValidation {\n+\n+  /**\n+    * Accept unconditionally a transaction.\n+    *\n+    * Designed to be used by a ledger integration that\n+    * already performs post-commit validation.\n+    */\n+  object Skip extends PostCommitValidation {\n+    override def validate(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+        submitter: Party,\n+    )(implicit connection: Connection): Set[RejectionReason] =\n+      Set.empty\n+  }\n+\n+  final class BackedBy(data: PostCommitValidationData) extends PostCommitValidation {\n+\n+    def validate(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+        submitter: Party,\n+    )(implicit connection: Connection): Set[RejectionReason] = {\n+\n+      val causalMonotonicityRejection =\n+        validateCausalMonotonicity(transaction, transactionLedgerEffectiveTime, divulged)\n+\n+      val invalidKeyUsageRejection =\n+        validateKeyUsages(transaction, submitter)\n+\n+      causalMonotonicityRejection.union(invalidKeyUsageRejection)\n+    }\n+\n+    /**\n+      * Do all exercise, fetch and lookup-by-key nodes\n+      * 1. exist, and\n+      * 2. refer exclusively to contracts with a ledger effective time smaller than or equal to the transaction's?\n+      */\n+    private def validateCausalMonotonicity(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+    )(implicit connection: Connection): Set[RejectionReason] = {\n+\n+      // Collect all the identifiers of contracts that have not been divulged in the current transaction\n+      val maximumLedgerEffectiveTime =\n+        data.lookupMaximumLedgerTime(\n+          transaction.fold(Set.empty[ContractId]) {\n+            case (ids, (_, e: Exercise)) if !divulged(e.targetCoid) => ids + e.targetCoid\n+            case (ids, (_, f: Fetch)) if !divulged(f.coid) => ids + f.coid\n+            case (ids, (_, l: LookupByKey)) => l.result.filterNot(divulged).fold(ids)(ids + _)\n+            case (ids, _) => ids\n+          }\n+        )\n+\n+      // Query the committed contracts store for the maximum ledger effective time of the\n+      // collected contracts and returns an error if that is strictly greater than the\n+      // ledger effective time of the current transaction.\n+      maximumLedgerEffectiveTime\n+        .map(\n+          _.filter(_.isAfter(transactionLedgerEffectiveTime)).fold(Set.empty[RejectionReason])(\n+            contractLedgerEffectiveTime => {\n+              Set(\n+                CausalMonotonicityViolation(\n+                  contractLedgerEffectiveTime = contractLedgerEffectiveTime,\n+                  transactionLedgerEffectiveTime = transactionLedgerEffectiveTime,\n+                )\n+              )\n+            }\n+          )\n+        )\n+        .getOrElse(Set(UnknownContract))\n+    }\n+\n+    private def validateKeyUsages(transaction: Transaction, submitter: Party)(\n+        implicit connection: Connection): Set[RejectionReason] = {\n+      transaction\n+        .fold(State.empty(data, submitter)) {\n+          case (state, (_, node)) => validateKeyUsages(node, state)\n+        }\n+        .errors\n+    }\n+\n+    private def validateKeyUsages(\n+        node: Node,\n+        state: State,\n+    )(implicit connection: Connection): State = {\n+\n+      node match {\n+        case c: Create =>\n+          state.validateCreate(c.key.map(convert(c.coinst.template, _)), c.coid)\n+        case l: LookupByKey =>\n+          state.validateLookupByKey(convert(l.templateId, l.key), l.result)\n+        case e: Exercise if e.consuming =>\n+          state.removeKeyIfDefined(e.key.map(convert(e.templateId, _)))\n+        case _ =>\n+          // fetch and non-consuming exercise nodes don't need to validate\n+          // anything with regards to contract keys and do not alter the\n+          // state in a way which is relevant for the validation of\n+          // subsequent nodes\n+          state\n+      }\n+    }\n+  }\n+\n+  /**\n+    * Represents the state of an ongoing validation.\n+    * It must be carried over as the transaction is\n+    * validated one node at a time in pre-order\n+    * traversal for this to make sense.\n+    *\n+    * @param errors Accumulates errors retrieved so far while validating\n+    * @param contracts All contracts created as part of the current transaction\n+    * @param removed Ensures indexed transactions are not referred to if they are removed in the current transaction"
  },
  {
    "id" : "e6a5e654-f212-4913-9cc2-5f29fb843278",
    "prId" : 5737,
    "comments" : [
      {
        "id" : "824d0561-3db8-46ee-a9af-be415d669668",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This case is duplicated with the case 2 lines down it seems. Did you want to have a special case for contracts in `createdInTransaction`?",
        "createdAt" : "2020-04-28T15:41:49Z",
        "updatedAt" : "2020-04-29T06:58:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dd12fcff-9de7-4ec9-a87f-fed20fc28913",
        "parentId" : "824d0561-3db8-46ee-a9af-be415d669668",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5774/commits/012d19624820ee6c898c3be68401bd948a67ceda in #5774.",
        "createdAt" : "2020-04-29T09:03:27Z",
        "updatedAt" : "2020-04-29T09:03:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "01da7393b32f8eb4cf5f4866f745997007cb8fdd",
    "line" : 118,
    "diffHunk" : "@@ -0,0 +1,248 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import java.sql.Connection\n+import java.time.Instant\n+\n+import com.daml.ledger.api.domain.RejectionReason\n+\n+/**\n+  * Performs post-commit validation on transactions for Sandbox Classic.\n+  * This is intended exclusively as a temporary replacement for\n+  * [[com.daml.platform.store.ActiveLedgerState]] and [[com.daml.platform.store.ActiveLedgerStateManager]]\n+  * so that the old post-commit validation backed by the old participant schema can be\n+  * dropped and the DAML-on-X-backed implementation of the Sandbox can skip it entirely.\n+  *\n+  * Post-commit validation is relevant for two reasons:\n+  * - keys can be referenced by two concurrent interpretations, potentially leading to\n+  *   either create nodes with duplicate active keys or lookup-by-key nodes referring to\n+  *   inactive keys\n+  * - the transaction's ledger effective time is determined after interpretation,\n+  *   meaning that causal monotonicity cannot be verified while interpreting a command\n+  */\n+sealed trait PostCommitValidation {\n+\n+  def validate(\n+      transaction: Transaction,\n+      transactionLedgerEffectiveTime: Instant,\n+      divulged: Set[ContractId],\n+      submitter: Party,\n+  )(implicit connection: Connection): Set[RejectionReason]\n+\n+}\n+\n+object PostCommitValidation {\n+\n+  /**\n+    * Accept unconditionally a transaction.\n+    *\n+    * Designed to be used by a ledger integration that\n+    * already performs post-commit validation.\n+    */\n+  object Skip extends PostCommitValidation {\n+    override def validate(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+        submitter: Party,\n+    )(implicit connection: Connection): Set[RejectionReason] =\n+      Set.empty\n+  }\n+\n+  final class BackedBy(data: PostCommitValidationData) extends PostCommitValidation {\n+\n+    def validate(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+        submitter: Party,\n+    )(implicit connection: Connection): Set[RejectionReason] = {\n+\n+      val causalMonotonicityRejection =\n+        validateCausalMonotonicity(transaction, transactionLedgerEffectiveTime, divulged)\n+\n+      val invalidKeyUsageRejection =\n+        validateKeyUsages(transaction, submitter)\n+\n+      causalMonotonicityRejection.union(invalidKeyUsageRejection)\n+    }\n+\n+    /**\n+      * Do all exercise, fetch and lookup-by-key nodes\n+      * 1. exist, and\n+      * 2. refer exclusively to contracts with a ledger effective time smaller than or equal to the transaction's?\n+      */\n+    private def validateCausalMonotonicity(\n+        transaction: Transaction,\n+        transactionLedgerEffectiveTime: Instant,\n+        divulged: Set[ContractId],\n+    )(implicit connection: Connection): Set[RejectionReason] = {\n+      val referredContracts = collectReferredContracts(transaction, divulged)\n+      if (referredContracts.isEmpty) {\n+        Set.empty\n+      } else {\n+        data\n+          .lookupMaximumLedgerTime(referredContracts)\n+          .map(validateCausalMonotonicity(_, transactionLedgerEffectiveTime))\n+          .getOrElse(Set(UnknownContract))\n+      }\n+    }\n+\n+    private def validateCausalMonotonicity(\n+        maximumLedgerEffectiveTime: Option[Instant],\n+        transactionLedgerEffectiveTime: Instant,\n+    ): Set[RejectionReason] =\n+      maximumLedgerEffectiveTime\n+        .filter(_.isAfter(transactionLedgerEffectiveTime))\n+        .fold(Set.empty[RejectionReason])(\n+          contractLedgerEffectiveTime => {\n+            Set(\n+              CausalMonotonicityViolation(\n+                contractLedgerEffectiveTime = contractLedgerEffectiveTime,\n+                transactionLedgerEffectiveTime = transactionLedgerEffectiveTime,\n+              )\n+            )\n+          }\n+        )\n+\n+    private def collectReferredContracts(\n+        transaction: Transaction,\n+        divulged: Set[ContractId],\n+    ): Set[ContractId] = {\n+      val (createdInTransaction, referred) =\n+        transaction.fold((Set.empty[ContractId], Set.empty[ContractId])) {\n+          case ((created, ids), (_, c: Create)) =>\n+            (created + c.coid, ids)\n+          case ((created, ids), (_, e: Exercise)) if !divulged(e.targetCoid) =>"
  }
]