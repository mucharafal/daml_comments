[
  {
    "id" : "c952f57c-22c5-426f-a30b-d25c1801181d",
    "prId" : 2717,
    "comments" : [
      {
        "id" : "a53b38ce-6d92-444b-ade8-3924c6be0926",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Make this `opt[LedgerString]` and use `LedgerString.fromString` to construct it or fail with an appropriate error message.",
        "createdAt" : "2019-09-02T08:00:21Z",
        "updatedAt" : "2019-09-02T09:57:05Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9e4c28846d5c0b7684d2f68a70323dbd421c628c",
    "line" : 78,
    "diffHunk" : "@@ -28,43 +28,45 @@ object Cli {\n         Some(TlsConfiguration(enabled = true, None, None, Some(new File(path)))))(c =>\n         Some(c.copy(trustCertCollectionFile = Some(new File(path))))))\n \n-  private val cmdArgParser = new scopt.OptionParser[Config](\"reference-server\") {\n-    head(\n-      \"A fully compliant DAML Ledger API server backed by an in-memory store.\\n\" +\n-        \"Due to its lack of persistence it is not meant for production, but to serve as a blueprint for other DAML Ledger API server implementations.\")\n-    opt[Int](\"port\")\n-      .optional()\n-      .action((p, c) => c.copy(port = p))\n-      .text(\"Server port. If not set, a random port is allocated.\")\n-    opt[File](\"port-file\")\n-      .optional()\n-      .action((f, c) => c.copy(portFile = Some(f)))\n-      .text(\"File to write the allocated port number to. Used to inform clients in CI about the allocated port.\")\n-    opt[String](\"pem\")\n-      .optional()\n-      .text(\"TLS: The pem file to be used as the private key.\")\n-      .action(pemConfig)\n-    opt[String](\"crt\")\n-      .optional()\n-      .text(\"TLS: The crt file to be used as the cert chain. Required if any other TLS parameters are set.\")\n-      .action(crtConfig)\n-    opt[String](\"cacrt\")\n-      .optional()\n-      .text(\"TLS: The crt file to be used as the the trusted root CA.\")\n-      .action(cacrtConfig)\n-    opt[Int](\"maxInboundMessageSize\")\n-      .action((x, c) => c.copy(maxInboundMessageSize = x))\n-      .text(\n-        s\"Max inbound message size in bytes. Defaults to ${Config.DefaultMaxInboundMessageSize}.\")\n-    opt[String](\"jdbc-url\")\n-      .text(\"The JDBC URL to the postgres database used for the indexer and the index\")\n-      .action((u, c) => c.copy(jdbcUrl = u))\n-    arg[File](\"<archive>...\")\n-      .unbounded()\n-      .action((f, c) => c.copy(archiveFiles = f :: c.archiveFiles))\n-      .text(\"DAR files to load. Scenarios are ignored. The servers starts with an empty ledger by default.\")\n-  }\n+  private def cmdArgParser(binaryName: String, description: String) =\n+    new scopt.OptionParser[Config](binaryName) {\n+      head(description)\n+      opt[Int](\"port\")\n+        .optional()\n+        .action((p, c) => c.copy(port = p))\n+        .text(\"Server port. If not set, a random port is allocated.\")\n+      opt[File](\"port-file\")\n+        .optional()\n+        .action((f, c) => c.copy(portFile = Some(f)))\n+        .text(\"File to write the allocated port number to. Used to inform clients in CI about the allocated port.\")\n+      opt[String](\"pem\")\n+        .optional()\n+        .text(\"TLS: The pem file to be used as the private key.\")\n+        .action(pemConfig)\n+      opt[String](\"crt\")\n+        .optional()\n+        .text(\"TLS: The crt file to be used as the cert chain. Required if any other TLS parameters are set.\")\n+        .action(crtConfig)\n+      opt[String](\"cacrt\")\n+        .optional()\n+        .text(\"TLS: The crt file to be used as the the trusted root CA.\")\n+        .action(cacrtConfig)\n+      opt[Int](\"maxInboundMessageSize\")\n+        .action((x, c) => c.copy(maxInboundMessageSize = x))\n+        .text(\n+          s\"Max inbound message size in bytes. Defaults to ${Config.DefaultMaxInboundMessageSize}.\")\n+      opt[String](\"jdbc-url\")\n+        .text(\"The JDBC URL to the postgres database used for the indexer and the index\")\n+        .action((u, c) => c.copy(jdbcUrl = u))\n+      opt[String](\"participant-id\")"
  }
]