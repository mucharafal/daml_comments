[
  {
    "id" : "2556a9b7-f5e0-49ca-a0b3-566dee6ccfbd",
    "prId" : 3655,
    "comments" : [
      {
        "id" : "f85953a6-f752-4374-9cfb-238d015c000e",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Are we following the Scala style guide? In case we are this should be `MaxTransientFailureCount`:\r\nhttps://docs.scala-lang.org/style/naming-conventions.html#constants-values-variable-and-methods",
        "createdAt" : "2019-11-29T10:09:49Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "27a9a567-23ba-47b7-a525-6f92754e9946",
        "parentId" : "f85953a6-f752-4374-9cfb-238d015c000e",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Yup, you're right.",
        "createdAt" : "2019-11-29T10:19:16Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6faa9af0e976c271138c3d4af75a805e9497ba39",
    "line" : null,
    "diffHunk" : "@@ -77,13 +96,8 @@ final class SqlExecutor(noOfThread: Int, loggerFactory: NamedLoggerFactory, metr\n   }\n \n   override def close(): Unit = executor.shutdown()\n-\n }\n \n object SqlExecutor {\n-  def apply(\n-      noOfThread: Int,\n-      loggerFactory: NamedLoggerFactory,\n-      metrics: MetricRegistry): SqlExecutor =\n-    new SqlExecutor(noOfThread, loggerFactory, metrics)\n+  val maxTransientFailureCount: Int = 3"
  },
  {
    "id" : "56b5de8d-9189-4e7b-a6b0-d3bc219f7a68",
    "prId" : 3359,
    "comments" : [
      {
        "id" : "1bb561cb-8e20-436e-9d93-2e7e28cf1c7e",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Great, thanks, very good catch!\r\n\r\nNo pun intended. :smile: ",
        "createdAt" : "2019-11-07T12:43:10Z",
        "updatedAt" : "2019-11-07T14:26:30Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "57b56f34c1c450872c0e56b48c140c1fe8a5ccab",
    "line" : 19,
    "diffHunk" : "@@ -46,23 +46,29 @@ final class SqlExecutor(noOfThread: Int, loggerFactory: NamedLoggerFactory, mm:\n       waitAllTimer.update(waitNanos, TimeUnit.NANOSECONDS)\n       val startExec = System.nanoTime()\n       try {\n-\n         // Actual execution\n-        val res = block\n+        promise.success(block)\n+      } catch {\n+        case NonFatal(e) =>\n+          logger.error(\n+            s\"$description: Got an exception while executing a SQL query. Rolled back the transaction.\",\n+            e)\n+          promise.failure(e)\n+        case t: Throwable =>\n+          logger.error(s\"$description: got a fatal error!\", t) //fatal errors don't make it for some reason to the setUncaughtExceptionHandler above\n+          throw t\n+      }\n \n+      // decouple metrics updating from sql execution above"
  },
  {
    "id" : "f73eaa2e-8a3e-4231-bcf3-bd89c2208f5c",
    "prId" : 3359,
    "comments" : [
      {
        "id" : "20f81868-c403-4d5a-87c0-1c2a1e682d9d",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I may be wrong here, but if `promise` is immutable then you'll have to return it from this expression and then call `.future` on that in the end.",
        "createdAt" : "2019-11-07T12:44:44Z",
        "updatedAt" : "2019-11-07T14:26:30Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "91a6f0f7-421d-42ff-a0aa-016394b62773",
        "parentId" : "20f81868-c403-4d5a-87c0-1c2a1e682d9d",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I believe promises are necessarily mutable; you return the `promise.future` immediately and then can complete it later.",
        "createdAt" : "2019-11-07T12:47:10Z",
        "updatedAt" : "2019-11-07T14:26:30Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a4eb1ad6-858a-4665-b868-a1e198ce1b1e",
        "parentId" : "20f81868-c403-4d5a-87c0-1c2a1e682d9d",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "According to [the Scala documentation](https://docs.scala-lang.org/overviews/core/futures.html#promises), it's mutable by design.",
        "createdAt" : "2019-11-07T12:48:23Z",
        "updatedAt" : "2019-11-07T14:26:30Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5e13d8aa-4611-43f3-89a0-a3a9714cebe7",
        "parentId" : "20f81868-c403-4d5a-87c0-1c2a1e682d9d",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Indeed",
        "createdAt" : "2019-11-07T14:25:56Z",
        "updatedAt" : "2019-11-07T14:26:30Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "57b56f34c1c450872c0e56b48c140c1fe8a5ccab",
    "line" : 7,
    "diffHunk" : "@@ -46,23 +46,29 @@ final class SqlExecutor(noOfThread: Int, loggerFactory: NamedLoggerFactory, mm:\n       waitAllTimer.update(waitNanos, TimeUnit.NANOSECONDS)\n       val startExec = System.nanoTime()\n       try {\n-\n         // Actual execution\n-        val res = block\n+        promise.success(block)"
  },
  {
    "id" : "d12f0c7c-3290-491e-8c78-53d2c1df504e",
    "prId" : 3310,
    "comments" : [
      {
        "id" : "cbb661c1-14eb-4f4d-ae5c-2a7daa711e89",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The `sql_all_*` timer objects are better bound outside the method, because otherwise you go through the whole create-metric-name-for-lookup-and-optionally-create-timer procedure in the background.",
        "createdAt" : "2019-11-01T08:58:44Z",
        "updatedAt" : "2019-11-01T16:59:59Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "53d5c7ce-5da4-48c1-9c76-42afe9add81a",
        "parentId" : "cbb661c1-14eb-4f4d-ae5c-2a7daa711e89",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3310/commits/c4516473b10ead76cd7473e13afdc8a83e5b986d",
        "createdAt" : "2019-11-01T15:57:51Z",
        "updatedAt" : "2019-11-01T16:59:59Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "da69019b20e9b758d06008c4b2a5ab303bd1e4b6",
    "line" : null,
    "diffHunk" : "@@ -30,19 +32,17 @@ class SqlExecutor(noOfThread: Int, loggerFactory: NamedLoggerFactory) extends Au\n \n   def runQuery[A](description: => String, block: () => A): Future[A] = {\n     val promise = Promise[A]\n-    val startWait = System.nanoTime()\n+    val waitTimer = mm.unmanagedTimer(s\"sql_${description}_wait\")\n+    val waitAllTimer = mm.unmanagedTimer(\"sql_all_wait\")"
  },
  {
    "id" : "16b260c2-7486-4510-9892-bac6d36624bc",
    "prId" : 2662,
    "comments" : [
      {
        "id" : "47c051ce-7ea8-419c-8991-a3ed97eeb456",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "If you decide to make `description` _call-by-name_ it would be better to use check that the level is enabled before accessing `description`. This would come for free if we're using [scala-logging](https://github.com/lightbend/scala-logging), do we use it?\r\n\r\nAlso the rest of the time tracking operations are relevant only if trace level logging is enabled. Rather then dotting this method with `if`s it would probably be better instead to dispatch to either of two underlying implementations based on the log level, one with time tracking and the other without.",
        "createdAt" : "2019-08-26T15:34:02Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "25a3298c-f46a-4ea5-b4c9-5a49788464b0",
        "parentId" : "47c051ce-7ea8-419c-8991-a3ed97eeb456",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Given the suggestion at the second paragraph of the previous comment, it would probably be better to not use scala-logging but Logback directly to avoid macros injecting unnecessary conditionals in our code.",
        "createdAt" : "2019-08-26T15:40:04Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7325a970-e57a-40d7-8d5b-0bb897617e87",
        "parentId" : "47c051ce-7ea8-419c-8991-a3ed97eeb456",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'll use call-by-name. I'm not worried about the overhead of the timing aspect. After all, we're talking about a network hop to the DB (with potentially high latency).",
        "createdAt" : "2019-08-27T07:01:03Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bea1e758-1603-45b0-b022-dda1a08a2470",
        "parentId" : "47c051ce-7ea8-419c-8991-a3ed97eeb456",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Don't forget that `logger` can write to the most surprising places. :wink: ",
        "createdAt" : "2019-08-27T07:30:30Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d14f51d9-7f11-4492-96e9-3f5420c505c4",
        "parentId" : "47c051ce-7ea8-419c-8991-a3ed97eeb456",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Sorry, misread your comments. I wrapped the logging in `isTraceEnabled` in 7ae9da263.",
        "createdAt" : "2019-08-27T08:00:09Z",
        "updatedAt" : "2019-08-30T08:59:53Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe3fd2846c655373040f8b5281532a6483f923e8",
    "line" : null,
    "diffHunk" : "@@ -28,11 +28,18 @@ class SqlExecutor(noOfThread: Int) extends AutoCloseable {\n         .build()\n     )\n \n-  def runQuery[A](block: () => A): Future[A] = {\n+  def runQuery[A](description: String, block: () => A): Future[A] = {\n     val promise = Promise[A]\n+    val startWait = System.nanoTime()\n     executor.execute(() => {\n       try {\n-        promise.success(block())\n+        val elapsedWait = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startWait)\n+        val start = System.nanoTime()\n+        val res = block()\n+        val elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start)\n+        logger.trace("
  }
]