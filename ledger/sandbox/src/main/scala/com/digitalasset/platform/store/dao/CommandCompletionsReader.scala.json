[
  {
    "id" : "26de747c-f885-4c95-b54d-d7d48c234987",
    "prId" : 4681,
    "comments" : [
      {
        "id" : "b7489526-81c8-4f54-9ca9-6237eaa1f32b",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Instead of having to go into the response again for the offset, `CommandCompletionsTable.parser` could return the tuple of offset and response in the first place.",
        "createdAt" : "2020-02-25T14:08:31Z",
        "updatedAt" : "2020-02-25T14:40:00Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2922f1d2-4ae0-477f-be3e-6aa58f825a02",
        "parentId" : "b7489526-81c8-4f54-9ca9-6237eaa1f32b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I had this in a previous version but `offset` has to be repeated just because it's needed by the `Dispatcher`. Ideally I would only return the response, which is what will happen in a coming PR. But thanks for raising this, it makes sense.",
        "createdAt" : "2020-02-25T14:23:32Z",
        "updatedAt" : "2020-02-25T14:40:00Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "877ea5fa91f11308feaa2e732233aa13ed38dd18",
    "line" : 26,
    "diffHunk" : "@@ -8,18 +8,21 @@ import akka.stream.scaladsl.Source\n import com.digitalasset.daml.lf.data.Ref\n import com.digitalasset.ledger.ApplicationId\n import com.digitalasset.ledger.api.v1.command_completion_service.CompletionStreamResponse\n-import com.digitalasset.platform.store.CompletionFromTransaction\n \n private[dao] object CommandCompletionsReader {\n \n-  // Uses an existing LedgerReadDao to read completions from the ledger entries stream\n-  // TODO Replace this to tap directly into the index\n-  def apply(reader: LedgerReadDao): CommandCompletionsReader[LedgerDao#LedgerOffset] =\n-    (from: Long, to: Long, appId: ApplicationId, parties: Set[Ref.Party]) =>\n-      reader\n-        .getLedgerEntries(from, to)\n-        .map { case (offset, entry) => (offset + 1, entry) }\n-        .collect(CompletionFromTransaction(appId, parties))\n+  private def offsetFor(response: CompletionStreamResponse): LedgerDao#LedgerOffset =\n+    response.checkpoint.get.offset.get.getAbsolute.toLong\n+\n+  def apply(dispatcher: DbDispatcher): CommandCompletionsReader[LedgerDao#LedgerOffset] =\n+    (from: Long, to: Long, appId: ApplicationId, parties: Set[Ref.Party]) => {\n+      val query = CommandCompletionsTable.prepareGet(from, to, appId, parties)\n+      Source\n+        .future(dispatcher.executeSql(\"get_completions\") { implicit connection =>\n+          query.as(CommandCompletionsTable.parser.*)\n+        })\n+        .mapConcat(_.map(response => offsetFor(response) -> response))"
  }
]