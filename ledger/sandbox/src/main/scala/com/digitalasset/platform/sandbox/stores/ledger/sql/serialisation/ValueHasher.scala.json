[
  {
    "id" : "f51b14a7-b469-478e-8350-80c835a49a9a",
    "prId" : 544,
    "comments" : [
      {
        "id" : "fac30e72-d0a2-4068-98ab-4318c5cfde1c",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "you could return `d` once in the end",
        "createdAt" : "2019-04-16T15:07:29Z",
        "updatedAt" : "2019-04-25T20:02:12Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7269aafff2faa4deed3b744d1ee458a5ec75e33",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,117 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores.ledger.sql.serialisation\n+\n+import java.nio.ByteBuffer\n+import java.security.MessageDigest\n+\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, VersionedValue}\n+\n+sealed abstract class HashToken extends Product with Serializable\n+final case class HashTokenText(value: String) extends HashToken\n+final case class HashTokenBool(value: Boolean) extends HashToken\n+final case class HashTokenInt(value: Int) extends HashToken\n+final case class HashTokenLong(value: Long) extends HashToken\n+final case class HashTokenBigDecimal(value: BigDecimal) extends HashToken\n+final case class HashTokenCollectionBegin(length: Int) extends HashToken\n+final case class HashTokenCollectionEnd() extends HashToken\n+\n+object ValueHasher {\n+\n+  /**\n+    * Computes a hash by folding over the given DAML-LF value.\n+    * The value is traversed in a stable way, producing \"hash tokens\" for any encountered primitive values.\n+    *\n+    * @param value the DAML-LF value to hash\n+    * @param z initial hash value\n+    * @param op operation to append a hash token\n+    * @return the final hash value\n+    */\n+  def foldLeft[T](value: Value[AbsoluteContractId], z: T, op: (T, HashToken) => T): T = {\n+    import com.digitalasset.daml.lf.value.Value._\n+\n+    value match {\n+      case ValueContractId(v) => op(z, HashTokenText(v.coid))\n+      case ValueInt64(v)      => op(z, HashTokenLong(v))\n+      case ValueDecimal(v)    => op(z, HashTokenBigDecimal(v))\n+      case ValueText(v)       => op(z, HashTokenText(v))\n+      case ValueTimestamp(v)  => op(z, HashTokenLong(v.micros))\n+      case ValueParty(v)      => op(z, HashTokenText(v.underlyingString))\n+      case ValueBool(v)       => op(z, HashTokenBool(v))\n+      case ValueDate(v)       => op(z, HashTokenInt(v.days))\n+      case ValueUnit          => op(z, HashTokenText(\"()\"))\n+\n+      // Record: [CollectionBegin(), Token(field value)*, CollectionEnd()]\n+      case ValueRecord(_, fs) =>\n+        val z1 = op(z, HashTokenCollectionBegin(fs.length))\n+        val z2 = fs.foldLeft[T](z1)((t, v) => foldLeft(v._2, t, op))\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Optional: [CollectionBegin(), Text(\"Some\" or \"None\"), Token(value), CollectionEnd()]\n+      case ValueOptional(Some(v)) =>\n+        val z1 = op(z, HashTokenCollectionBegin(2))\n+        val z2 = op(z1, HashTokenText(\"Some\"))\n+        val z3 = foldLeft(v, z2, op)\n+        op(z3, HashTokenCollectionEnd())\n+      case ValueOptional(None) =>\n+        val z1 = op(z, HashTokenCollectionBegin(1))\n+        val z2 = op(z1, HashTokenText(\"None\"))\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Variant: [CollectionBegin(), Text(variant), Token(value), CollectionEnd()]\n+      case ValueVariant(_, variant, v) =>\n+        val z1 = op(z, HashTokenCollectionBegin(1))\n+        val z2 = op(z1, HashTokenText(variant))\n+        val z3 = foldLeft(v, z2, op)\n+        op(z3, HashTokenCollectionEnd())\n+\n+      // List: [CollectionBegin(), Token(value)*, CollectionEnd()]\n+      case ValueList(xs) =>\n+        val arr = xs.toImmArray\n+        val z1 = op(z, HashTokenCollectionBegin(xs.length))\n+        val z2 = arr.foldLeft[T](z1)((t, v) => foldLeft(v, t, op))\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Map: [CollectionBegin(), (Text(key), Token(value))*, CollectionEnd()]\n+      case ValueMap(xs) =>\n+        val arr = xs.toImmArray\n+        val z1 = op(z, HashTokenCollectionBegin(arr.length))\n+        val z2 = arr.foldLeft[T](z1)((t, v) => {\n+          val zz1 = op(t, HashTokenText(v._1))\n+          foldLeft(v._2, zz1, op)\n+        })\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Tuple: same as Map\n+      case ValueTuple(xs) =>\n+        val z1 = op(z, HashTokenCollectionBegin(xs.length))\n+        val z2 = xs.foldLeft[T](z1)((t, v) => {\n+          val zz1 = op(t, HashTokenText(v._1))\n+          foldLeft(v._2, zz1, op)\n+        })\n+        op(z2, HashTokenCollectionEnd())\n+    }\n+  }\n+\n+  def hashValue(value: VersionedValue[AbsoluteContractId]): Array[Byte] = {\n+    val languageVersion = ???\n+    val valueVersion = value.version\n+\n+    // TODO: The way bytes are pushed to the digest is probably super inefficient\n+    // TODO: Prefix variable length primitives with their size (text, bigdecimal)!\n+    val digest = foldLeft[MessageDigest](value.value, MessageDigest.getInstance(\"SHA-256\"), (d, token) => token match {\n+      case HashTokenText(v)                 => d.update(v.getBytes(\"UTF8\")); d"
  },
  {
    "id" : "c1ea1cff-eedf-4e13-87f9-b7b6939f4f22",
    "prId" : 544,
    "comments" : [
      {
        "id" : "92a475f7-2031-4284-b0fa-26367ec5803a",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "I am not convinced we need this abstraction. Although it's an elegant approach to define an ADT for these cases, but are we planning to use these somewhere else too?",
        "createdAt" : "2019-04-16T15:11:45Z",
        "updatedAt" : "2019-04-25T20:02:12Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b07d97cb-b6f2-47d7-992e-111669bb0cb1",
        "parentId" : "92a475f7-2031-4284-b0fa-26367ec5803a",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "What would you do? Not use the two step approach, and have the `foldLeft` function directly push bytes to a `MessageDigest` or byte stream?",
        "createdAt" : "2019-04-16T15:14:04Z",
        "updatedAt" : "2019-04-25T20:02:12Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3e213487-2d47-4047-b16d-98b03448a442",
        "parentId" : "92a475f7-2031-4284-b0fa-26367ec5803a",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Yes, something like that. And if you need to share code between the path, just have them as small methods. But consider this as a minor comment and leave it as it is if you like. What you have is elegant and easy to understand, it might be a bit more generic though to what we actually need.",
        "createdAt" : "2019-04-16T15:18:06Z",
        "updatedAt" : "2019-04-25T20:02:12Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7269aafff2faa4deed3b744d1ee458a5ec75e33",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,117 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores.ledger.sql.serialisation\n+\n+import java.nio.ByteBuffer\n+import java.security.MessageDigest\n+\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, VersionedValue}\n+\n+sealed abstract class HashToken extends Product with Serializable"
  },
  {
    "id" : "7de90a19-decd-4ab2-b21d-5eb3a1744be3",
    "prId" : 544,
    "comments" : [
      {
        "id" : "d39610e0-6c1f-4551-8a9d-0b270be74827",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "typo, should be `Token(value)`",
        "createdAt" : "2019-04-16T15:13:21Z",
        "updatedAt" : "2019-04-25T20:02:12Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7269aafff2faa4deed3b744d1ee458a5ec75e33",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,117 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores.ledger.sql.serialisation\n+\n+import java.nio.ByteBuffer\n+import java.security.MessageDigest\n+\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, VersionedValue}\n+\n+sealed abstract class HashToken extends Product with Serializable\n+final case class HashTokenText(value: String) extends HashToken\n+final case class HashTokenBool(value: Boolean) extends HashToken\n+final case class HashTokenInt(value: Int) extends HashToken\n+final case class HashTokenLong(value: Long) extends HashToken\n+final case class HashTokenBigDecimal(value: BigDecimal) extends HashToken\n+final case class HashTokenCollectionBegin(length: Int) extends HashToken\n+final case class HashTokenCollectionEnd() extends HashToken\n+\n+object ValueHasher {\n+\n+  /**\n+    * Computes a hash by folding over the given DAML-LF value.\n+    * The value is traversed in a stable way, producing \"hash tokens\" for any encountered primitive values.\n+    *\n+    * @param value the DAML-LF value to hash\n+    * @param z initial hash value\n+    * @param op operation to append a hash token\n+    * @return the final hash value\n+    */\n+  def foldLeft[T](value: Value[AbsoluteContractId], z: T, op: (T, HashToken) => T): T = {\n+    import com.digitalasset.daml.lf.value.Value._\n+\n+    value match {\n+      case ValueContractId(v) => op(z, HashTokenText(v.coid))\n+      case ValueInt64(v)      => op(z, HashTokenLong(v))\n+      case ValueDecimal(v)    => op(z, HashTokenBigDecimal(v))\n+      case ValueText(v)       => op(z, HashTokenText(v))\n+      case ValueTimestamp(v)  => op(z, HashTokenLong(v.micros))\n+      case ValueParty(v)      => op(z, HashTokenText(v.underlyingString))\n+      case ValueBool(v)       => op(z, HashTokenBool(v))\n+      case ValueDate(v)       => op(z, HashTokenInt(v.days))\n+      case ValueUnit          => op(z, HashTokenText(\"()\"))\n+\n+      // Record: [CollectionBegin(), Token(field value)*, CollectionEnd()]"
  },
  {
    "id" : "67d65ddb-5eff-456f-8ac7-6a07688b7c99",
    "prId" : 544,
    "comments" : [
      {
        "id" : "acd9aa49-58d5-45d2-ba8b-eea4e76c9002",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "you can omit the `Text(\"some\" or \"none\")`",
        "createdAt" : "2019-04-16T15:13:33Z",
        "updatedAt" : "2019-04-25T20:02:12Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7269aafff2faa4deed3b744d1ee458a5ec75e33",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,117 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores.ledger.sql.serialisation\n+\n+import java.nio.ByteBuffer\n+import java.security.MessageDigest\n+\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, VersionedValue}\n+\n+sealed abstract class HashToken extends Product with Serializable\n+final case class HashTokenText(value: String) extends HashToken\n+final case class HashTokenBool(value: Boolean) extends HashToken\n+final case class HashTokenInt(value: Int) extends HashToken\n+final case class HashTokenLong(value: Long) extends HashToken\n+final case class HashTokenBigDecimal(value: BigDecimal) extends HashToken\n+final case class HashTokenCollectionBegin(length: Int) extends HashToken\n+final case class HashTokenCollectionEnd() extends HashToken\n+\n+object ValueHasher {\n+\n+  /**\n+    * Computes a hash by folding over the given DAML-LF value.\n+    * The value is traversed in a stable way, producing \"hash tokens\" for any encountered primitive values.\n+    *\n+    * @param value the DAML-LF value to hash\n+    * @param z initial hash value\n+    * @param op operation to append a hash token\n+    * @return the final hash value\n+    */\n+  def foldLeft[T](value: Value[AbsoluteContractId], z: T, op: (T, HashToken) => T): T = {\n+    import com.digitalasset.daml.lf.value.Value._\n+\n+    value match {\n+      case ValueContractId(v) => op(z, HashTokenText(v.coid))\n+      case ValueInt64(v)      => op(z, HashTokenLong(v))\n+      case ValueDecimal(v)    => op(z, HashTokenBigDecimal(v))\n+      case ValueText(v)       => op(z, HashTokenText(v))\n+      case ValueTimestamp(v)  => op(z, HashTokenLong(v.micros))\n+      case ValueParty(v)      => op(z, HashTokenText(v.underlyingString))\n+      case ValueBool(v)       => op(z, HashTokenBool(v))\n+      case ValueDate(v)       => op(z, HashTokenInt(v.days))\n+      case ValueUnit          => op(z, HashTokenText(\"()\"))\n+\n+      // Record: [CollectionBegin(), Token(field value)*, CollectionEnd()]\n+      case ValueRecord(_, fs) =>\n+        val z1 = op(z, HashTokenCollectionBegin(fs.length))\n+        val z2 = fs.foldLeft[T](z1)((t, v) => foldLeft(v._2, t, op))\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Optional: [CollectionBegin(), Text(\"Some\" or \"None\"), Token(value), CollectionEnd()]"
  },
  {
    "id" : "ded7e4d5-ef1c-49df-8e66-06431a58b069",
    "prId" : 544,
    "comments" : [
      {
        "id" : "6ec068f4-e3aa-4f96-a775-1c812be99431",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "you don't need to support serialization for this -- just crash if you encounter one.",
        "createdAt" : "2019-04-16T15:14:48Z",
        "updatedAt" : "2019-04-25T20:02:12Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7269aafff2faa4deed3b744d1ee458a5ec75e33",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,117 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores.ledger.sql.serialisation\n+\n+import java.nio.ByteBuffer\n+import java.security.MessageDigest\n+\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, VersionedValue}\n+\n+sealed abstract class HashToken extends Product with Serializable\n+final case class HashTokenText(value: String) extends HashToken\n+final case class HashTokenBool(value: Boolean) extends HashToken\n+final case class HashTokenInt(value: Int) extends HashToken\n+final case class HashTokenLong(value: Long) extends HashToken\n+final case class HashTokenBigDecimal(value: BigDecimal) extends HashToken\n+final case class HashTokenCollectionBegin(length: Int) extends HashToken\n+final case class HashTokenCollectionEnd() extends HashToken\n+\n+object ValueHasher {\n+\n+  /**\n+    * Computes a hash by folding over the given DAML-LF value.\n+    * The value is traversed in a stable way, producing \"hash tokens\" for any encountered primitive values.\n+    *\n+    * @param value the DAML-LF value to hash\n+    * @param z initial hash value\n+    * @param op operation to append a hash token\n+    * @return the final hash value\n+    */\n+  def foldLeft[T](value: Value[AbsoluteContractId], z: T, op: (T, HashToken) => T): T = {\n+    import com.digitalasset.daml.lf.value.Value._\n+\n+    value match {\n+      case ValueContractId(v) => op(z, HashTokenText(v.coid))\n+      case ValueInt64(v)      => op(z, HashTokenLong(v))\n+      case ValueDecimal(v)    => op(z, HashTokenBigDecimal(v))\n+      case ValueText(v)       => op(z, HashTokenText(v))\n+      case ValueTimestamp(v)  => op(z, HashTokenLong(v.micros))\n+      case ValueParty(v)      => op(z, HashTokenText(v.underlyingString))\n+      case ValueBool(v)       => op(z, HashTokenBool(v))\n+      case ValueDate(v)       => op(z, HashTokenInt(v.days))\n+      case ValueUnit          => op(z, HashTokenText(\"()\"))\n+\n+      // Record: [CollectionBegin(), Token(field value)*, CollectionEnd()]\n+      case ValueRecord(_, fs) =>\n+        val z1 = op(z, HashTokenCollectionBegin(fs.length))\n+        val z2 = fs.foldLeft[T](z1)((t, v) => foldLeft(v._2, t, op))\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Optional: [CollectionBegin(), Text(\"Some\" or \"None\"), Token(value), CollectionEnd()]\n+      case ValueOptional(Some(v)) =>\n+        val z1 = op(z, HashTokenCollectionBegin(2))\n+        val z2 = op(z1, HashTokenText(\"Some\"))\n+        val z3 = foldLeft(v, z2, op)\n+        op(z3, HashTokenCollectionEnd())\n+      case ValueOptional(None) =>\n+        val z1 = op(z, HashTokenCollectionBegin(1))\n+        val z2 = op(z1, HashTokenText(\"None\"))\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Variant: [CollectionBegin(), Text(variant), Token(value), CollectionEnd()]\n+      case ValueVariant(_, variant, v) =>\n+        val z1 = op(z, HashTokenCollectionBegin(1))\n+        val z2 = op(z1, HashTokenText(variant))\n+        val z3 = foldLeft(v, z2, op)\n+        op(z3, HashTokenCollectionEnd())\n+\n+      // List: [CollectionBegin(), Token(value)*, CollectionEnd()]\n+      case ValueList(xs) =>\n+        val arr = xs.toImmArray\n+        val z1 = op(z, HashTokenCollectionBegin(xs.length))\n+        val z2 = arr.foldLeft[T](z1)((t, v) => foldLeft(v, t, op))\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Map: [CollectionBegin(), (Text(key), Token(value))*, CollectionEnd()]\n+      case ValueMap(xs) =>\n+        val arr = xs.toImmArray\n+        val z1 = op(z, HashTokenCollectionBegin(arr.length))\n+        val z2 = arr.foldLeft[T](z1)((t, v) => {\n+          val zz1 = op(t, HashTokenText(v._1))\n+          foldLeft(v._2, zz1, op)\n+        })\n+        op(z2, HashTokenCollectionEnd())\n+\n+      // Tuple: same as Map\n+      case ValueTuple(xs) =>"
  }
]