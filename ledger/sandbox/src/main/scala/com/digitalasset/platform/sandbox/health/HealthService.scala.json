[
  {
    "id" : "f85e5492-0103-445e-aad5-9ef02f7b0a16",
    "prId" : 3573,
    "comments" : [
      {
        "id" : "f5202b2e-667d-4aa3-a285-d608868659d2",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'd prefer if we could stick with the scalapb rpc implementation for services, otherwise we start having a mix of how services are implemented.",
        "createdAt" : "2019-11-21T16:47:44Z",
        "updatedAt" : "2019-11-22T13:38:57Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "165d102b-9166-459f-9276-6d796b2f6ac3",
        "parentId" : "f5202b2e-667d-4aa3-a285-d608868659d2",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "On it.",
        "createdAt" : "2019-11-21T17:01:50Z",
        "updatedAt" : "2019-11-22T13:38:57Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "09ab1517-5bec-4c92-90b3-875aaba49d2f",
        "parentId" : "f5202b2e-667d-4aa3-a285-d608868659d2",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-11-21T17:24:38Z",
        "updatedAt" : "2019-11-22T13:38:57Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4848f40af9b3e4bc6651d495959322efdfdbaa78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,77 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.health\n+\n+import akka.Done\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.digitalasset.grpc.{GrpcException, GrpcStatus}\n+import com.digitalasset.platform.sandbox.health.HealthService._\n+import io.grpc.health.v1.{HealthCheckRequest, HealthCheckResponse, HealthGrpc}\n+import io.grpc.stub.StreamObserver\n+import io.grpc.{Context, Status}\n+\n+import scala.concurrent.ExecutionContext\n+import scala.concurrent.duration.{DurationInt, FiniteDuration}\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+class HealthService(watchThrottleFrequency: FiniteDuration = 1.second)(\n+    implicit materializer: Materializer,\n+    executionContext: ExecutionContext\n+) extends HealthGrpc.HealthImplBase {"
  },
  {
    "id" : "ecda1048-7a0c-4baa-a5e6-e9aa59826a08",
    "prId" : 3573,
    "comments" : [
      {
        "id" : "8e64d490-6467-443a-acb7-2534133941eb",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Thanks. If you add `\"@com_github_grpc_grpc//src/proto/grpc/health/v1:health_proto_descriptor\",` to `//ledger/ledger-api-akka:ledger-api-akka-srcs` [0], you can implement the generated trait `HealthAkkaGrpc` (c.f. `GrpcTransactionService` [1]) to only have to implement the abstract method `watchSource` without having to mess around with the stream observer.\r\n\r\n[0] https://github.com/digital-asset/daml/blob/9f9d2d0458013cb8f75dfc5c630a1b711c38359a/ledger/ledger-api-akka/BUILD.bazel#L7-L9\r\n[1] https://github.com/digital-asset/daml/blob/9f9d2d0458013cb8f75dfc5c630a1b711c38359a/ledger/ledger-api-common/src/main/scala/com/digitalasset/platform/server/api/services/grpc/GrpcTransactionService.scala#L41",
        "createdAt" : "2019-11-21T17:53:15Z",
        "updatedAt" : "2019-11-22T13:38:57Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4848f40af9b3e4bc6651d495959322efdfdbaa78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.health\n+\n+import akka.Done\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.digitalasset.grpc.adapter.utils.DirectExecutionContext\n+import com.digitalasset.grpc.{GrpcException, GrpcStatus}\n+import com.digitalasset.platform.api.grpc.GrpcApiService\n+import io.grpc.health.v1.health.{HealthCheckRequest, HealthCheckResponse, HealthGrpc}\n+import io.grpc.stub.StreamObserver\n+import io.grpc.{Context, ServerServiceDefinition, Status}\n+\n+import scala.concurrent.duration.{DurationInt, FiniteDuration}\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.control.NonFatal\n+import scala.util.{Failure, Success}\n+\n+class HealthService(watchThrottleFrequency: FiniteDuration = 1.second)(\n+    implicit materializer: Materializer,\n+    executionContext: ExecutionContext,\n+) extends HealthGrpc.Health\n+    with GrpcApiService {\n+  private val servingResponse = HealthCheckResponse(HealthCheckResponse.ServingStatus.SERVING)\n+\n+  override def bindService(): ServerServiceDefinition =\n+    HealthGrpc.bindService(this, DirectExecutionContext)\n+\n+  override def close(): Unit = ()\n+\n+  override def check(request: HealthCheckRequest): Future[HealthCheckResponse] =\n+    Future.successful(servingResponse)\n+\n+  override def watch("
  }
]