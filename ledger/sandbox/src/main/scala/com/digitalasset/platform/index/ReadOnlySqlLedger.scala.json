[
  {
    "id" : "494bc26b-f376-4124-9c72-49f1dd2261a3",
    "prId" : 6721,
    "comments" : [
      {
        "id" : "1248409a-821e-4eaf-a8e9-8885a0c74007",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Does it make sense to handle the retry at this level? Would it make more sense to throw an exception here and let the caller decide what to do with this?",
        "createdAt" : "2020-07-15T10:08:59Z",
        "updatedAt" : "2020-07-16T15:42:46Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3eb95450-c04d-41c1-9597-848f0b46137b",
        "parentId" : "1248409a-821e-4eaf-a8e9-8885a0c74007",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "So the question is how we control the retry mechanism. At this point, we know fairly well what went \"wrong\".\r\n\r\nAlternatively we could slap a retry around the entire index initialization process and not really care about specific errors.\r\n\r\nWhat do you think?",
        "createdAt" : "2020-07-15T10:24:58Z",
        "updatedAt" : "2020-07-16T15:42:46Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3f26d247-241e-4eca-92b9-4d7006d29ed4",
        "parentId" : "1248409a-821e-4eaf-a8e9-8885a0c74007",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm only a bit concerned of ending up with retry logic scattered across many classes. We can still signal a specific failure using a specific exception and handle it appropriately. Feel free to leave this here if you think it's better to deal with failures as close as possible to the source.",
        "createdAt" : "2020-07-15T11:06:24Z",
        "updatedAt" : "2020-07-16T15:42:46Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3dc2f060-9aae-49bd-a956-26c3d6ee2e60",
        "parentId" : "1248409a-821e-4eaf-a8e9-8885a0c74007",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "If we do decide to leave the retry here, should we stop retrying at some point?",
        "createdAt" : "2020-07-16T08:22:42Z",
        "updatedAt" : "2020-07-16T15:42:46Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3e951f5c-a529-4f49-b11a-0e175225a583",
        "parentId" : "1248409a-821e-4eaf-a8e9-8885a0c74007",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "@stefanobaghino-da: I'm open to suggestions on where initialization errors should be handled. I think this falls into a similar category as waiting for the DB to be available (see #6146). There we currently retry 600 times with a retry delay of 1 second. We can do something similar here.\r\n\r\nSince this is only run on startup I think it makes sense to have some leniency during the startup sequence between a read-only api server and the indexer, so not failing the entire process.",
        "createdAt" : "2020-07-16T09:21:24Z",
        "updatedAt" : "2020-07-16T15:42:46Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9317365d3249dfafc8dea2cd1562eb4cf29b0de3",
    "line" : null,
    "diffHunk" : "@@ -67,7 +67,12 @@ object ReadOnlySqlLedger {\n             Future.failed(\n               new LedgerIdMismatchException(foundLedgerId, initialLedgerId) with StartupException)\n           case None =>\n-            Future.successful(initialLedgerId)\n+            logger.info(\"Ledger ID not found in the index database. Retrying again in 5 seconds.\")\n+            val promise = Promise[LedgerId]()\n+            mat.scheduleOnce(5.seconds, () => {\n+              promise.completeWith(verifyLedgerId(ledgerDao, initialLedgerId))\n+            })\n+            promise.future"
  },
  {
    "id" : "f16c5a5f-61c8-470c-a78e-e97b80ce8675",
    "prId" : 6497,
    "comments" : [
      {
        "id" : "550c6424-5720-48d3-a790-dbefd3b69602",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n        case Some(`initialLedgerId`) =>\r\n          logger.info(s\"Found existing ledger with ID: $initialLedgerId\")\r\n```",
        "createdAt" : "2020-06-29T08:03:49Z",
        "updatedAt" : "2020-06-29T12:37:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e04ba8b02c573c9662e687359ab1660af5532190",
    "line" : null,
    "diffHunk" : "@@ -9,88 +9,86 @@ import akka.actor.Cancellable\n import akka.stream._\n import akka.stream.scaladsl.{Keep, RestartSource, Sink, Source}\n import akka.{Done, NotUsed}\n-import com.daml.dec.{DirectExecutionContext => DEC}\n import com.daml.ledger.api.domain.LedgerId\n import com.daml.ledger.api.health.HealthStatus\n import com.daml.ledger.participant.state.v1.Offset\n import com.daml.logging.{ContextualizedLogger, LoggingContext}\n import com.daml.metrics.Metrics\n+import com.daml.platform.akkastreams.dispatcher.Dispatcher\n import com.daml.platform.common.LedgerIdMismatchException\n import com.daml.platform.configuration.ServerRole\n-import com.daml.platform.store.dao.{JdbcLedgerDao, LedgerReadDao}\n import com.daml.platform.store.dao.events.LfValueTranslation\n+import com.daml.platform.store.dao.{JdbcLedgerDao, LedgerReadDao}\n import com.daml.platform.store.{BaseLedger, ReadOnlyLedger}\n import com.daml.resources.ProgramResource.StartupException\n-import com.daml.resources.ResourceOwner\n+import com.daml.resources.{Resource, ResourceOwner}\n \n import scala.concurrent.duration._\n import scala.concurrent.{Await, ExecutionContext, Future}\n \n object ReadOnlySqlLedger {\n \n+  private val logger = ContextualizedLogger.get(this.getClass)\n+\n   //jdbcUrl must have the user/password encoded in form of: \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n-  def owner(\n+  final class Owner(\n       serverRole: ServerRole,\n       jdbcUrl: String,\n-      ledgerId: LedgerId,\n+      initialLedgerId: LedgerId,\n       eventsPageSize: Int,\n       metrics: Metrics,\n       lfValueTranslationCache: LfValueTranslation.Cache,\n-  )(implicit mat: Materializer, logCtx: LoggingContext): ResourceOwner[ReadOnlyLedger] =\n-    for {\n-      ledgerReadDao <- JdbcLedgerDao.readOwner(\n-        serverRole,\n-        jdbcUrl,\n-        eventsPageSize,\n-        metrics,\n-        lfValueTranslationCache,\n-      )\n-      factory = new Factory(ledgerReadDao)\n-      ledger <- ResourceOwner.forFutureCloseable(() => factory.createReadOnlySqlLedger(ledgerId))\n-    } yield ledger\n-\n-  private class Factory(ledgerDao: LedgerReadDao)(implicit logCtx: LoggingContext) {\n-\n-    private val logger = ContextualizedLogger.get(this.getClass)\n-\n-    /**\n-      * Creates a DB backed Ledger implementation.\n-      *\n-      * @return a compliant read-only Ledger implementation\n-      */\n-    def createReadOnlySqlLedger(initialLedgerId: LedgerId)(\n-        implicit mat: Materializer\n-    ): Future[ReadOnlySqlLedger] = {\n-      implicit val ec: ExecutionContext = DEC\n+  )(implicit mat: Materializer, logCtx: LoggingContext)\n+      extends ResourceOwner[ReadOnlyLedger] {\n+    override def acquire()(\n+        implicit executionContext: ExecutionContext\n+    ): Resource[ReadOnlyLedger] =\n       for {\n-        ledgerId <- initialize(initialLedgerId)\n-        ledgerEnd <- ledgerDao.lookupLedgerEnd()\n-      } yield new ReadOnlySqlLedger(ledgerId, ledgerEnd, ledgerDao)\n-    }\n-\n-    private def initialize(initialLedgerId: LedgerId): Future[LedgerId] =\n-      ledgerDao\n-        .lookupLedgerId()\n-        .flatMap {\n-          case Some(foundLedgerId @ `initialLedgerId`) =>\n-            logger.info(s\"Found existing ledger with ID: $foundLedgerId\")\n-            Future.successful(foundLedgerId)\n-          case Some(foundLedgerId) =>\n-            Future.failed(\n-              new LedgerIdMismatchException(foundLedgerId, initialLedgerId) with StartupException)\n-          case None =>\n-            Future.successful(initialLedgerId)\n-        }(DEC)\n+        ledgerDao <- JdbcLedgerDao\n+          .readOwner(\n+            serverRole,\n+            jdbcUrl,\n+            eventsPageSize,\n+            metrics,\n+            lfValueTranslationCache,\n+          )\n+          .acquire()\n+        ledgerId <- Resource.fromFuture(initialize(ledgerDao, initialLedgerId))\n+        ledgerEnd <- Resource.fromFuture(ledgerDao.lookupLedgerEnd())\n+        dispatcher <- ResourceOwner\n+          .forCloseable(() => Dispatcher[Offset](\"sql-ledger\", Offset.beforeBegin, ledgerEnd))\n+          .acquire()\n+        ledger <- ResourceOwner\n+          .forCloseable(() => new ReadOnlySqlLedger(ledgerId, ledgerDao, dispatcher))\n+          .acquire()\n+      } yield ledger\n   }\n \n+  private def initialize(\n+      ledgerDao: LedgerReadDao,\n+      initialLedgerId: LedgerId,\n+  )(implicit executionContext: ExecutionContext, logCtx: LoggingContext): Future[LedgerId] =\n+    ledgerDao\n+      .lookupLedgerId()\n+      .flatMap {\n+        case Some(foundLedgerId @ `initialLedgerId`) =>\n+          logger.info(s\"Found existing ledger with ID: $foundLedgerId\")"
  },
  {
    "id" : "9f99feb9-5762-481b-bfa9-649717ea5593",
    "prId" : 6497,
    "comments" : [
      {
        "id" : "4da51ad5-baa8-4a4b-9c80-87ef3c8402d4",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n  private def matchOrCreateLedgerId(\r\n```\r\nOr something along those lines.",
        "createdAt" : "2020-06-29T08:08:48Z",
        "updatedAt" : "2020-06-29T12:37:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e04ba8b02c573c9662e687359ab1660af5532190",
    "line" : null,
    "diffHunk" : "@@ -9,88 +9,86 @@ import akka.actor.Cancellable\n import akka.stream._\n import akka.stream.scaladsl.{Keep, RestartSource, Sink, Source}\n import akka.{Done, NotUsed}\n-import com.daml.dec.{DirectExecutionContext => DEC}\n import com.daml.ledger.api.domain.LedgerId\n import com.daml.ledger.api.health.HealthStatus\n import com.daml.ledger.participant.state.v1.Offset\n import com.daml.logging.{ContextualizedLogger, LoggingContext}\n import com.daml.metrics.Metrics\n+import com.daml.platform.akkastreams.dispatcher.Dispatcher\n import com.daml.platform.common.LedgerIdMismatchException\n import com.daml.platform.configuration.ServerRole\n-import com.daml.platform.store.dao.{JdbcLedgerDao, LedgerReadDao}\n import com.daml.platform.store.dao.events.LfValueTranslation\n+import com.daml.platform.store.dao.{JdbcLedgerDao, LedgerReadDao}\n import com.daml.platform.store.{BaseLedger, ReadOnlyLedger}\n import com.daml.resources.ProgramResource.StartupException\n-import com.daml.resources.ResourceOwner\n+import com.daml.resources.{Resource, ResourceOwner}\n \n import scala.concurrent.duration._\n import scala.concurrent.{Await, ExecutionContext, Future}\n \n object ReadOnlySqlLedger {\n \n+  private val logger = ContextualizedLogger.get(this.getClass)\n+\n   //jdbcUrl must have the user/password encoded in form of: \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n-  def owner(\n+  final class Owner(\n       serverRole: ServerRole,\n       jdbcUrl: String,\n-      ledgerId: LedgerId,\n+      initialLedgerId: LedgerId,\n       eventsPageSize: Int,\n       metrics: Metrics,\n       lfValueTranslationCache: LfValueTranslation.Cache,\n-  )(implicit mat: Materializer, logCtx: LoggingContext): ResourceOwner[ReadOnlyLedger] =\n-    for {\n-      ledgerReadDao <- JdbcLedgerDao.readOwner(\n-        serverRole,\n-        jdbcUrl,\n-        eventsPageSize,\n-        metrics,\n-        lfValueTranslationCache,\n-      )\n-      factory = new Factory(ledgerReadDao)\n-      ledger <- ResourceOwner.forFutureCloseable(() => factory.createReadOnlySqlLedger(ledgerId))\n-    } yield ledger\n-\n-  private class Factory(ledgerDao: LedgerReadDao)(implicit logCtx: LoggingContext) {\n-\n-    private val logger = ContextualizedLogger.get(this.getClass)\n-\n-    /**\n-      * Creates a DB backed Ledger implementation.\n-      *\n-      * @return a compliant read-only Ledger implementation\n-      */\n-    def createReadOnlySqlLedger(initialLedgerId: LedgerId)(\n-        implicit mat: Materializer\n-    ): Future[ReadOnlySqlLedger] = {\n-      implicit val ec: ExecutionContext = DEC\n+  )(implicit mat: Materializer, logCtx: LoggingContext)\n+      extends ResourceOwner[ReadOnlyLedger] {\n+    override def acquire()(\n+        implicit executionContext: ExecutionContext\n+    ): Resource[ReadOnlyLedger] =\n       for {\n-        ledgerId <- initialize(initialLedgerId)\n-        ledgerEnd <- ledgerDao.lookupLedgerEnd()\n-      } yield new ReadOnlySqlLedger(ledgerId, ledgerEnd, ledgerDao)\n-    }\n-\n-    private def initialize(initialLedgerId: LedgerId): Future[LedgerId] =\n-      ledgerDao\n-        .lookupLedgerId()\n-        .flatMap {\n-          case Some(foundLedgerId @ `initialLedgerId`) =>\n-            logger.info(s\"Found existing ledger with ID: $foundLedgerId\")\n-            Future.successful(foundLedgerId)\n-          case Some(foundLedgerId) =>\n-            Future.failed(\n-              new LedgerIdMismatchException(foundLedgerId, initialLedgerId) with StartupException)\n-          case None =>\n-            Future.successful(initialLedgerId)\n-        }(DEC)\n+        ledgerDao <- JdbcLedgerDao\n+          .readOwner(\n+            serverRole,\n+            jdbcUrl,\n+            eventsPageSize,\n+            metrics,\n+            lfValueTranslationCache,\n+          )\n+          .acquire()\n+        ledgerId <- Resource.fromFuture(initialize(ledgerDao, initialLedgerId))\n+        ledgerEnd <- Resource.fromFuture(ledgerDao.lookupLedgerEnd())\n+        dispatcher <- ResourceOwner\n+          .forCloseable(() => Dispatcher[Offset](\"sql-ledger\", Offset.beforeBegin, ledgerEnd))\n+          .acquire()\n+        ledger <- ResourceOwner\n+          .forCloseable(() => new ReadOnlySqlLedger(ledgerId, ledgerDao, dispatcher))\n+          .acquire()\n+      } yield ledger\n   }\n \n+  private def initialize("
  },
  {
    "id" : "ffa2e3c4-b357-422f-ac0d-bf4acbd45f16",
    "prId" : 4607,
    "comments" : [
      {
        "id" : "9ffef7b0-3c7c-4978-acdd-35a6d432e7c5",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n          case Some(`initialLedgerId`) =>\r\n```",
        "createdAt" : "2020-02-19T16:25:40Z",
        "updatedAt" : "2020-02-19T20:48:13Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dab614ca-52e3-4f40-a554-388cd905e0c9",
        "parentId" : "9ffef7b0-3c7c-4978-acdd-35a6d432e7c5",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Done; went with:\r\n\r\n```suggestion\r\n          case Some(foundLedgerId @ `initialLedgerId`) =>\r\n```",
        "createdAt" : "2020-02-19T20:08:36Z",
        "updatedAt" : "2020-02-19T20:48:13Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2631a6f3d08f69f84454f5b30c7ebcb7581b0e28",
    "line" : null,
    "diffHunk" : "@@ -60,59 +62,29 @@ object ReadOnlySqlLedger {\n       *\n       * @return a compliant read-only Ledger implementation\n       */\n-    def createReadOnlySqlLedger(initialLedgerId: Option[LedgerId])(\n+    def createReadOnlySqlLedger(initialLedgerId: LedgerId)(\n         implicit mat: Materializer\n     ): Future[ReadOnlySqlLedger] = {\n-\n       implicit val ec: ExecutionContext = DEC\n-\n       for {\n         ledgerId <- initialize(initialLedgerId)\n         ledgerEnd <- ledgerDao.lookupLedgerEnd()\n-      } yield {\n-\n-        new ReadOnlySqlLedger(ledgerId, ledgerEnd, ledgerDao)\n-      }\n+      } yield new ReadOnlySqlLedger(ledgerId, ledgerEnd, ledgerDao)\n     }\n \n-    private def initialize(initialLedgerId: Option[LedgerId]): Future[LedgerId] = {\n-      // Note that here we only store the ledger entry and we do not update anything else, such as the\n-      // headRef. We also are not concerns with heartbeats / checkpoints. This is OK since this initialization\n-      // step happens before we start up the sql ledger at all, so it's running in isolation.\n-\n-      initialLedgerId match {\n-        case Some(initialId) =>\n-          ledgerDao\n-            .lookupLedgerId()\n-            .flatMap {\n-              case Some(foundLedgerId) if foundLedgerId == initialId =>\n-                ledgerFound(foundLedgerId)\n-              case Some(foundLedgerId) =>\n-                val errorMsg =\n-                  s\"Ledger id mismatch. Ledger id given ('$initialId') is not equal to the existing one ('$foundLedgerId')!\"\n-                logger.error(errorMsg)\n-                Future.failed(new IllegalArgumentException(errorMsg))\n-              case None =>\n-                Future.successful(initialId)\n-\n-            }(DEC)\n-\n-        case None =>\n-          logger.info(\"No ledger id given. Looking for existing ledger in database.\")\n-          ledgerDao\n-            .lookupLedgerId()\n-            .flatMap {\n-              case Some(foundLedgerId) => ledgerFound(foundLedgerId)\n-              case None =>\n-                Future.failed(new IllegalStateException(\"Underlying ledger not yet initialized\"))\n-            }(DEC)\n-      }\n-    }\n-\n-    private def ledgerFound(foundLedgerId: LedgerId) = {\n-      logger.info(s\"Found existing ledger with id: ${foundLedgerId.unwrap}\")\n-      Future.successful(foundLedgerId)\n-    }\n+    private def initialize(initialLedgerId: LedgerId): Future[LedgerId] =\n+      ledgerDao\n+        .lookupLedgerId()\n+        .flatMap {\n+          case Some(foundLedgerId) if foundLedgerId == initialLedgerId =>"
  }
]