[
  {
    "id" : "b9eefdbc-9dde-407d-a0d1-42743e96b8bd",
    "prId" : 6646,
    "comments" : [
      {
        "id" : "bb64cced-b2dd-426c-8c95-d1a933bc2813",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "What happens if there are two concurrent calls to `setTimeModel`? Or is this a \"preemptive\" check and the problem should get caught by the `WriteService`? Is it even a problem?",
        "createdAt" : "2020-07-08T12:15:36Z",
        "updatedAt" : "2020-07-08T13:16:41Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e0103c40-cd24-4e3a-b80a-0dd3044325ce",
        "parentId" : "bb64cced-b2dd-426c-8c95-d1a933bc2813",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The `WriteService` implementation definitely has the last word on this.",
        "createdAt" : "2020-07-08T12:18:58Z",
        "updatedAt" : "2020-07-08T13:16:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7d93fa5fb876e41f24d6d98a451a08e0f381e545",
    "line" : 21,
    "diffHunk" : "@@ -82,23 +83,24 @@ final class ApiConfigManagementService private (\n       // Lookup latest configuration to check generation and to extend it with the new time model.\n       optConfigAndOffset <- index.lookupConfiguration()\n       pollOffset = optConfigAndOffset.map(_._1)\n-      currentConfig = optConfigAndOffset\n-        .map(_._2)\n-        .getOrElse(ledgerConfiguration.initialConfiguration)\n+      currentConfig = optConfigAndOffset.map(_._2)\n \n       // Verify that we're modifying the current configuration.\n-      _ <- if (request.configurationGeneration != currentConfig.generation) {\n+      expectedGeneration = currentConfig"
  },
  {
    "id" : "534d514d-23eb-44ea-86ab-e5f3d5dcd11e",
    "prId" : 6646,
    "comments" : [
      {
        "id" : "56f9c31c-fc17-484e-b20e-711784497f7c",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Is it sensible to return a config, even if no config is actually set? I see that you need to return a generation, but the model could in principle be left empty. Would this break other tests?",
        "createdAt" : "2020-07-08T12:35:32Z",
        "updatedAt" : "2020-07-08T13:16:41Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0c9bcb10-405c-4ce5-ab6a-6cbc21d546f6",
        "parentId" : "56f9c31c-fc17-484e-b20e-711784497f7c",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I agree, but this would be a bigger change and I suggest we leave it until after we release. Perhaps @rautenrieth-da can weigh in.",
        "createdAt" : "2020-07-08T12:39:28Z",
        "updatedAt" : "2020-07-08T13:16:41Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8efc9b8f-265c-407a-ae60-0f06b9458f97",
        "parentId" : "56f9c31c-fc17-484e-b20e-711784497f7c",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : ":+1: ",
        "createdAt" : "2020-07-08T12:43:45Z",
        "updatedAt" : "2020-07-08T13:16:41Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f4cc3a0f-ea05-43f3-aba5-b0330750351a",
        "parentId" : "56f9c31c-fc17-484e-b20e-711784497f7c",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "https://github.com/digital-asset/daml/issues/6668",
        "createdAt" : "2020-07-09T12:04:23Z",
        "updatedAt" : "2020-07-09T12:04:38Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7d93fa5fb876e41f24d6d98a451a08e0f381e545",
    "line" : 6,
    "diffHunk" : "@@ -44,7 +44,8 @@ final class ApiConfigManagementService private (\n \n   private val logger = ContextualizedLogger.get(this.getClass)\n \n-  private val defaultConfigResponse = configToResponse(ledgerConfiguration.initialConfiguration)\n+  private val defaultConfigResponse = configToResponse(\n+    ledgerConfiguration.initialConfiguration.copy(generation = LedgerConfiguration.NoGeneration))"
  },
  {
    "id" : "9064c28c-76e1-47eb-a6de-77d554f79a8e",
    "prId" : 5591,
    "comments" : [
      {
        "id" : "8ee55c02-8fb4-4531-8e8c-9bf7ca431dcd",
        "parentId" : null,
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Can we lower the logging level to info? In distributed ledgers, the participant administrator is not necessarily authorized to define the time model (owned by the domain administrators). In such cases submission would fail expectedly. In such cases a warning would indicate an incorrectly operating node which is not necessarily the case.\r\n\r\nFor Canton it would be great if: if the ledger returned `NotSupported` we only emitted a message at info level and warn on other `SubmissionResult`s.",
        "createdAt" : "2020-04-21T07:15:15Z",
        "updatedAt" : "2020-04-21T13:49:25Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b3107c88-3665-41ae-9347-e54369c6e524",
        "parentId" : "8ee55c02-8fb4-4531-8e8c-9bf7ca431dcd",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Done. `NotSupported` will emit a message at info level.",
        "createdAt" : "2020-04-21T12:25:53Z",
        "updatedAt" : "2020-04-21T13:49:25Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7af86c69-b911-4924-99b5-a4f7bf1540c6",
        "parentId" : "8ee55c02-8fb4-4531-8e8c-9bf7ca431dcd",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Thanks Robert. Much obliged.",
        "createdAt" : "2020-04-21T12:59:50Z",
        "updatedAt" : "2020-04-21T13:49:25Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c88cb69f1442ab96bd253fb3a6720778c58fb8f0",
    "line" : 80,
    "diffHunk" : "@@ -56,6 +61,48 @@ final class ApiConfigManagementService private (\n       .map(_.fold(defaultConfigResponse) { case (_, conf) => configToResponse(conf) })(DE)\n       .andThen(logger.logErrorsOnCall[GetTimeModelResponse])(DE)\n \n+  /** After a short delay, this method checks if there exists a ledger configuration,\n+    *  and submits a default configuration if no ledger configuration exists.\n+    *\n+    *  There are several reasons why the change could be rejected:\n+    *  - The participant is not authorized to set the configuration\n+    *  - There already is a configuration, it just didn't appear in the index yet\n+    *  This method therefore does not try to re-submit the initial configuration in case of failure.\n+    */\n+  private def submitInitialConfig(initialConfig: Configuration) = {\n+    implicit val executionContext: ExecutionContext = DE\n+    Delayed.Future.by(\n+      Duration.fromNanos(ledgerConfiguration.initialConfigurationSubmitDelay.toNanos))(\n+      for {\n+        optConfig <- index.lookupConfiguration()\n+        _ <- if (optConfig.isDefined)\n+          Future.successful(())\n+        else {\n+          val submissionId = SubmissionId.assertFromString(UUID.randomUUID.toString)\n+          logger.info(\n+            s\"No ledger configuration found, submitting an initial configuration $submissionId\")\n+          FutureConverters\n+            .toScala(\n+              writeService.submitConfiguration(\n+                Timestamp.assertFromInstant(timeProvider.getCurrentTime.plusSeconds(60)),\n+                submissionId,\n+                initialConfig\n+              ))\n+            .map {\n+              case SubmissionResult.Acknowledged =>\n+                logger.info(s\"Initial configuration submission $submissionId was successful\")\n+                ()\n+              case result =>\n+                logger.warn("
  },
  {
    "id" : "2bed9024-795a-4e48-8278-7e9c615edf57",
    "prId" : 5591,
    "comments" : [
      {
        "id" : "77917326-9593-4a07-8fb0-f715e779eac8",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Can you make it more obvious that we are doing some work after instantiation, please? I.e., a comment to `ApiConfigManagementService` would be good or moving this call up before the method's declaration but below the first comment. E.g.:\r\n```scala\r\n  // After a short delay, we check if there exists a ledger configuration, and submit a default configuration if no ledger configuration exists.\r\n  submitInitialConfig()\r\n\r\n  /** ...\r\n    *  ...\r\n    */\r\n  private def submitInitialConfig(): Unit = ...\r\n```",
        "createdAt" : "2020-04-21T12:41:11Z",
        "updatedAt" : "2020-04-21T13:49:25Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c88cb69f1442ab96bd253fb3a6720778c58fb8f0",
    "line" : null,
    "diffHunk" : "@@ -56,6 +61,51 @@ final class ApiConfigManagementService private (\n       .map(_.fold(defaultConfigResponse) { case (_, conf) => configToResponse(conf) })(DE)\n       .andThen(logger.logErrorsOnCall[GetTimeModelResponse])(DE)\n \n+  /** After a short delay, this method checks if there exists a ledger configuration,\n+    *  and submits a default configuration if no ledger configuration exists.\n+    *\n+    *  There are several reasons why the change could be rejected:\n+    *  - The participant is not authorized to set the configuration\n+    *  - There already is a configuration, it just didn't appear in the index yet\n+    *  This method therefore does not try to re-submit the initial configuration in case of failure.\n+    */\n+  private def submitInitialConfig(initialConfig: Configuration) = {\n+    implicit val executionContext: ExecutionContext = DE\n+    Delayed.Future.by(\n+      Duration.fromNanos(ledgerConfiguration.initialConfigurationSubmitDelay.toNanos))(\n+      for {\n+        optConfig <- index.lookupConfiguration()\n+        _ <- if (optConfig.isDefined)\n+          Future.successful(())\n+        else {\n+          val submissionId = SubmissionId.assertFromString(UUID.randomUUID.toString)\n+          logger.info(\n+            s\"No ledger configuration found, submitting an initial configuration $submissionId\")\n+          FutureConverters\n+            .toScala(\n+              writeService.submitConfiguration(\n+                Timestamp.assertFromInstant(timeProvider.getCurrentTime.plusSeconds(60)),\n+                submissionId,\n+                initialConfig\n+              ))\n+            .map {\n+              case SubmissionResult.Acknowledged =>\n+                logger.info(s\"Initial configuration submission $submissionId was successful\")\n+                ()\n+              case SubmissionResult.NotSupported =>\n+                logger.info(s\"Setting an initial ledger configuration is not supported\")\n+                ()\n+              case result =>\n+                logger.warn(\n+                  s\"Initial configuration submission $submissionId failed. Reason: ${result.description}\")\n+                ()\n+            }(DE)\n+        }\n+      } yield ()\n+    )\n+  }\n+  submitInitialConfig(ledgerConfiguration.initialConfiguration)"
  },
  {
    "id" : "0b5256b5-3f11-4cd8-9d87-debf154793fd",
    "prId" : 5591,
    "comments" : [
      {
        "id" : "b10f2987-1ad1-4839-8bf9-38888445e16d",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n                logger.info(\"Setting an initial ledger configuration is not supported\")\r\n```",
        "createdAt" : "2020-04-21T12:45:23Z",
        "updatedAt" : "2020-04-21T13:49:25Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c88cb69f1442ab96bd253fb3a6720778c58fb8f0",
    "line" : null,
    "diffHunk" : "@@ -56,6 +61,51 @@ final class ApiConfigManagementService private (\n       .map(_.fold(defaultConfigResponse) { case (_, conf) => configToResponse(conf) })(DE)\n       .andThen(logger.logErrorsOnCall[GetTimeModelResponse])(DE)\n \n+  /** After a short delay, this method checks if there exists a ledger configuration,\n+    *  and submits a default configuration if no ledger configuration exists.\n+    *\n+    *  There are several reasons why the change could be rejected:\n+    *  - The participant is not authorized to set the configuration\n+    *  - There already is a configuration, it just didn't appear in the index yet\n+    *  This method therefore does not try to re-submit the initial configuration in case of failure.\n+    */\n+  private def submitInitialConfig(initialConfig: Configuration) = {\n+    implicit val executionContext: ExecutionContext = DE\n+    Delayed.Future.by(\n+      Duration.fromNanos(ledgerConfiguration.initialConfigurationSubmitDelay.toNanos))(\n+      for {\n+        optConfig <- index.lookupConfiguration()\n+        _ <- if (optConfig.isDefined)\n+          Future.successful(())\n+        else {\n+          val submissionId = SubmissionId.assertFromString(UUID.randomUUID.toString)\n+          logger.info(\n+            s\"No ledger configuration found, submitting an initial configuration $submissionId\")\n+          FutureConverters\n+            .toScala(\n+              writeService.submitConfiguration(\n+                Timestamp.assertFromInstant(timeProvider.getCurrentTime.plusSeconds(60)),\n+                submissionId,\n+                initialConfig\n+              ))\n+            .map {\n+              case SubmissionResult.Acknowledged =>\n+                logger.info(s\"Initial configuration submission $submissionId was successful\")\n+                ()\n+              case SubmissionResult.NotSupported =>\n+                logger.info(s\"Setting an initial ledger configuration is not supported\")"
  },
  {
    "id" : "d8f780f0-d89b-476e-9234-f49dd849c28d",
    "prId" : 5591,
    "comments" : [
      {
        "id" : "cc37c8fc-bdde-4a38-b25c-669d5c68ca9f",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You don't really need this parameter, i.e., you could just declare it as a `val` for better readability.",
        "createdAt" : "2020-04-21T12:45:49Z",
        "updatedAt" : "2020-04-21T13:49:25Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c88cb69f1442ab96bd253fb3a6720778c58fb8f0",
    "line" : null,
    "diffHunk" : "@@ -56,6 +61,51 @@ final class ApiConfigManagementService private (\n       .map(_.fold(defaultConfigResponse) { case (_, conf) => configToResponse(conf) })(DE)\n       .andThen(logger.logErrorsOnCall[GetTimeModelResponse])(DE)\n \n+  /** After a short delay, this method checks if there exists a ledger configuration,\n+    *  and submits a default configuration if no ledger configuration exists.\n+    *\n+    *  There are several reasons why the change could be rejected:\n+    *  - The participant is not authorized to set the configuration\n+    *  - There already is a configuration, it just didn't appear in the index yet\n+    *  This method therefore does not try to re-submit the initial configuration in case of failure.\n+    */\n+  private def submitInitialConfig(initialConfig: Configuration) = {"
  }
]