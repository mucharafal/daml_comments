[
  {
    "id" : "3232aee1-dd66-4118-aa4c-03c365b4459c",
    "prId" : 6289,
    "comments" : [
      {
        "id" : "72b627c9-df34-4e42-ab98-011131a6711e",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Would it make sense to create a type parametrized weighting scheme for this instead? I.e., do you expect such weighting to be used for more caches than the 2 defined here?",
        "createdAt" : "2020-06-12T08:15:52Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "88fbf388af498692afc5283d2a171d201046eb70",
    "line" : 128,
    "diffHunk" : "@@ -217,4 +248,31 @@ object LfValueTranslation {\n \n   }\n \n+  object ContractCache {\n+\n+    private implicit object `Key Weight` extends caching.Weight[Key] {"
  },
  {
    "id" : "7e8542cd-3bb9-4032-8c6f-0daa2bd43c26",
    "prId" : 6289,
    "comments" : [
      {
        "id" : "848b8c23-2f61-4a28-a46a-69c673627ef4",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "This singular name is a bit confusing here. Maybe call it `Caches` or `CachedEntities` or similar to be explicit that it is holding more than one cache?",
        "createdAt" : "2020-06-12T08:21:40Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "88fbf388af498692afc5283d2a171d201046eb70",
    "line" : 76,
    "diffHunk" : "@@ -171,10 +176,34 @@ final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n \n object LfValueTranslation {\n \n-  type Cache = caching.Cache[Cache.Key, Cache.Value]\n+  final case class Cache(events: EventCache, contracts: ContractCache)"
  },
  {
    "id" : "2bde7d26-8d98-48ad-b8ca-3d67cb474a6f",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "7e87f115-1af6-4727-85df-755eb184568b",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Probably worth explaining why the weight here is 0. I had to read the comment three times before I understood.",
        "createdAt" : "2020-05-20T14:49:14Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "74a8de21-7c58-452c-ac03-00822072cefe",
        "parentId" : "7e87f115-1af6-4727-85df-755eb184568b",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Is there any way to change the interface to `Cache` so this wouldn't create a weighted cache? I expect the performance of Caffeine would be better if we didn't use weighting at all in this situation, and instead used size-based eviction.",
        "createdAt" : "2020-05-20T14:57:31Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "094e9b39-f763-402c-a671-2aeda114e45e",
        "parentId" : "7e87f115-1af6-4727-85df-755eb184568b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I played around with it a bit but it's starting to play around with implicits and adding too many methods, I'd prefer simply improving the comment right now and leave this for another PR.",
        "createdAt" : "2020-05-20T17:51:53Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0d4b7beb-aae9-4123-89a7-28e97df509c3",
        "parentId" : "7e87f115-1af6-4727-85df-755eb184568b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Created https://github.com/digital-asset/daml/issues/6057",
        "createdAt" : "2020-05-20T17:55:38Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "552eee1a-d093-4e91-8950-3aceba83a43b",
        "parentId" : "7e87f115-1af6-4727-85df-755eb184568b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Comment improved in https://github.com/digital-asset/daml/pull/6052/commits/c99211fe5b22dad2ebd66ee97263517279f3f005",
        "createdAt" : "2020-05-20T17:55:51Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(contractId: ContractId, arg: LfValue): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = contractId),\n+    )\n+\n+  private def serializeCreateArgOrThrow(c: Create): Array[Byte] =\n+    serializeCreateArgOrThrow(c.coid, c.coinst.arg)\n+\n+  private def serializeNullableKeyOrThrow(c: Create): Option[Array[Byte]] =\n+    c.key.map(\n+      k =>\n+        ValueSerializer.serializeValue(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = c.coid),\n+      )\n+    )\n+\n+  private def serializeExerciseArgOrThrow(e: Exercise): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = e.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = e.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(e: Exercise): Option[Array[Byte]] =\n+    e.exerciseResult.map(\n+      exerciseResult =>\n+        ValueSerializer.serializeValue(\n+          value = exerciseResult,\n+          errorContext = cantSerialize(attribute = \"exercise result\", forContract = e.targetCoid),\n+      )\n+    )\n+\n+  // Doesn't go through caching, for now caching is limited to events\n+  def serialize(contractId: ContractId, createArgument: LfValue): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(contractId, createArgument),\n+    )\n+\n+  def serialize(eventId: EventId, create: Create): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Create(create.coinst.arg, create.key.map(_.key)),\n+    )\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+  }\n+\n+  def serialize(eventId: EventId, exercise: Exercise): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Exercise(exercise.chosenValue, exercise.exerciseResult),\n+    )\n+    Vector[NamedParameter](\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+    )\n+  }\n+\n+  private def toApiValue(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiValue =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to value\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiValue(\n+          verbose = verbose,\n+          value = value,\n+        ),\n+    )\n+\n+  private def toApiRecord(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiRecord =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to record\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiRecord(\n+          verbose = verbose,\n+          recordValue = value,\n+        ),\n+    )\n+\n+  def deserialize[E](raw: Raw.Created[E], verbose: Boolean): CreatedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val create =\n+      cache\n+        .getIfPresent(key = key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Create(\n+            argument = ValueSerializer.deserializeValue(raw.createArgument),\n+            key = raw.createKeyValue.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertCreate()\n+    raw.partial.copy(\n+      createArguments = Some(\n+        toApiRecord(\n+          value = create.argument,\n+          verbose = verbose,\n+          attribute = \"create argument\",\n+        )\n+      ),\n+      contractKey = create.key.map(\n+        key =>\n+          toApiValue(\n+            value = key,\n+            verbose = verbose,\n+            attribute = \"create key\",\n+        )\n+      ),\n+    )\n+  }\n+\n+  def deserialize(raw: Raw.TreeEvent.Exercised, verbose: Boolean): ExercisedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val exercise =\n+      cache\n+        .getIfPresent(key = key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Exercise(\n+            argument = ValueSerializer.deserializeValue(raw.exerciseArgument),\n+            result = raw.exerciseResult.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertExercise()\n+    raw.partial.copy(\n+      choiceArgument = Some(\n+        toApiValue(\n+          value = exercise.argument,\n+          verbose = verbose,\n+          attribute = \"exercise argument\",\n+        )\n+      ),\n+      exerciseResult = exercise.result.map(\n+        result =>\n+          toApiValue(\n+            value = result,\n+            verbose = verbose,\n+            attribute = \"exercise result\",\n+        )\n+      ),\n+    )\n+  }\n+\n+}\n+\n+object LfValueTranslation {\n+\n+  type Cache = caching.Cache[Cache.Key, Cache.Value]\n+\n+  object Cache {\n+\n+    // To avoid the overhead of measuring the size of objects, we just assign a weight of 1 to values"
  },
  {
    "id" : "a6fc9509-742e-42bd-a61b-73796232c442",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "efaf8888-e99c-41af-8a25-53a80f907aa0",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Thank you for using a typed exception. 😀 ",
        "createdAt" : "2020-05-20T14:49:42Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : 198,
    "diffHunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(contractId: ContractId, arg: LfValue): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = contractId),\n+    )\n+\n+  private def serializeCreateArgOrThrow(c: Create): Array[Byte] =\n+    serializeCreateArgOrThrow(c.coid, c.coinst.arg)\n+\n+  private def serializeNullableKeyOrThrow(c: Create): Option[Array[Byte]] =\n+    c.key.map(\n+      k =>\n+        ValueSerializer.serializeValue(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = c.coid),\n+      )\n+    )\n+\n+  private def serializeExerciseArgOrThrow(e: Exercise): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = e.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = e.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(e: Exercise): Option[Array[Byte]] =\n+    e.exerciseResult.map(\n+      exerciseResult =>\n+        ValueSerializer.serializeValue(\n+          value = exerciseResult,\n+          errorContext = cantSerialize(attribute = \"exercise result\", forContract = e.targetCoid),\n+      )\n+    )\n+\n+  // Doesn't go through caching, for now caching is limited to events\n+  def serialize(contractId: ContractId, createArgument: LfValue): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(contractId, createArgument),\n+    )\n+\n+  def serialize(eventId: EventId, create: Create): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Create(create.coinst.arg, create.key.map(_.key)),\n+    )\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+  }\n+\n+  def serialize(eventId: EventId, exercise: Exercise): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Exercise(exercise.chosenValue, exercise.exerciseResult),\n+    )\n+    Vector[NamedParameter](\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+    )\n+  }\n+\n+  private def toApiValue(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiValue =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to value\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiValue(\n+          verbose = verbose,\n+          value = value,\n+        ),\n+    )\n+\n+  private def toApiRecord(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiRecord =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to record\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiRecord(\n+          verbose = verbose,\n+          recordValue = value,\n+        ),\n+    )\n+\n+  def deserialize[E](raw: Raw.Created[E], verbose: Boolean): CreatedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val create =\n+      cache\n+        .getIfPresent(key = key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Create(\n+            argument = ValueSerializer.deserializeValue(raw.createArgument),\n+            key = raw.createKeyValue.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertCreate()\n+    raw.partial.copy(\n+      createArguments = Some(\n+        toApiRecord(\n+          value = create.argument,\n+          verbose = verbose,\n+          attribute = \"create argument\",\n+        )\n+      ),\n+      contractKey = create.key.map(\n+        key =>\n+          toApiValue(\n+            value = key,\n+            verbose = verbose,\n+            attribute = \"create key\",\n+        )\n+      ),\n+    )\n+  }\n+\n+  def deserialize(raw: Raw.TreeEvent.Exercised, verbose: Boolean): ExercisedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val exercise =\n+      cache\n+        .getIfPresent(key = key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Exercise(\n+            argument = ValueSerializer.deserializeValue(raw.exerciseArgument),\n+            result = raw.exerciseResult.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertExercise()\n+    raw.partial.copy(\n+      choiceArgument = Some(\n+        toApiValue(\n+          value = exercise.argument,\n+          verbose = verbose,\n+          attribute = \"exercise argument\",\n+        )\n+      ),\n+      exerciseResult = exercise.result.map(\n+        result =>\n+          toApiValue(\n+            value = result,\n+            verbose = verbose,\n+            attribute = \"exercise result\",\n+        )\n+      ),\n+    )\n+  }\n+\n+}\n+\n+object LfValueTranslation {\n+\n+  type Cache = caching.Cache[Cache.Key, Cache.Value]\n+\n+  object Cache {\n+\n+    // To avoid the overhead of measuring the size of objects, we just assign a weight of 1 to values\n+    private implicit object `Key Weight` extends caching.Weight[Key] {\n+      override def weigh(value: Key): caching.Cache.Size = 0\n+    }\n+\n+    // To avoid the overhead of measuring the size of objects, we just assign a weight of 1 to values\n+    private implicit object `Value Weight` extends caching.Weight[Value] {\n+      override def weigh(value: Value): caching.Cache.Size = 1\n+    }\n+\n+    def newInstance(configuration: caching.Configuration): Cache =\n+      caching.Cache.from(configuration)\n+\n+    def newInstrumentedInstance(configuration: caching.Configuration, metrics: Metrics): Cache =\n+      caching.Cache.from(\n+        configuration = configuration,\n+        metrics = metrics.daml.index.db.translation.cache,\n+      )\n+\n+    final class UnexpectedTypeException(value: Value)\n+        extends RuntimeException(s\"Unexpected value $value\")"
  },
  {
    "id" : "0affc934-56c5-402c-ad80-e55166ee7d43",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "9da5f2cb-1da4-4f95-828c-b418becc9bae",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "We can avoid wrapping in Vector in this case.",
        "createdAt" : "2020-05-20T14:50:55Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1b9a2053-aa0a-4f4f-a072-f5562cd99331",
        "parentId" : "9da5f2cb-1da4-4f95-828c-b418becc9bae",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Address https://github.com/digital-asset/daml/pull/6052/commits/d3c67a7f69d52e9397de6b9a03adf4e945f85bb6",
        "createdAt" : "2020-05-20T15:10:40Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(contractId: ContractId, arg: LfValue): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = contractId),\n+    )\n+\n+  private def serializeCreateArgOrThrow(c: Create): Array[Byte] =\n+    serializeCreateArgOrThrow(c.coid, c.coinst.arg)\n+\n+  private def serializeNullableKeyOrThrow(c: Create): Option[Array[Byte]] =\n+    c.key.map(\n+      k =>\n+        ValueSerializer.serializeValue(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = c.coid),\n+      )\n+    )\n+\n+  private def serializeExerciseArgOrThrow(e: Exercise): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = e.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = e.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(e: Exercise): Option[Array[Byte]] =\n+    e.exerciseResult.map(\n+      exerciseResult =>\n+        ValueSerializer.serializeValue(\n+          value = exerciseResult,\n+          errorContext = cantSerialize(attribute = \"exercise result\", forContract = e.targetCoid),\n+      )\n+    )\n+\n+  // Doesn't go through caching, for now caching is limited to events\n+  def serialize(contractId: ContractId, createArgument: LfValue): Vector[NamedParameter] ="
  },
  {
    "id" : "b9116cb2-b265-4bf1-af78-d59c60a6594d",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "84d19fb7-fc41-488b-b9a2-6e7084330a9f",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Could this `extends AnyVal`?",
        "createdAt" : "2020-05-20T14:51:09Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a0d889cd-529f-44be-8b97-4c5e2d500566",
        "parentId" : "84d19fb7-fc41-488b-b9a2-6e7084330a9f",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Also, instead of making `Key` here, perhaps we could make `EventId` a proper type and just use that? (Potentially as a separate piece of work.)",
        "createdAt" : "2020-05-20T14:54:06Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4a2998c4-c906-4374-b3ef-96177e249670",
        "parentId" : "84d19fb7-fc41-488b-b9a2-6e7084330a9f",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "> Could this `extends AnyVal`?\r\n\r\nKeys must extends `AnyRef`.",
        "createdAt" : "2020-05-20T16:58:41Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "970942c9-ed4a-4c3f-9cfa-461afa3e492a",
        "parentId" : "84d19fb7-fc41-488b-b9a2-6e7084330a9f",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "> Also, instead of making `Key` here, perhaps we could make `EventId` a proper type and just use that? (Potentially as a separate piece of work.)\r\n\r\nIt is already, I'm using string here because I also have those coming from the database.",
        "createdAt" : "2020-05-20T16:59:30Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : 200,
    "diffHunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(contractId: ContractId, arg: LfValue): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = contractId),\n+    )\n+\n+  private def serializeCreateArgOrThrow(c: Create): Array[Byte] =\n+    serializeCreateArgOrThrow(c.coid, c.coinst.arg)\n+\n+  private def serializeNullableKeyOrThrow(c: Create): Option[Array[Byte]] =\n+    c.key.map(\n+      k =>\n+        ValueSerializer.serializeValue(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = c.coid),\n+      )\n+    )\n+\n+  private def serializeExerciseArgOrThrow(e: Exercise): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = e.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = e.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(e: Exercise): Option[Array[Byte]] =\n+    e.exerciseResult.map(\n+      exerciseResult =>\n+        ValueSerializer.serializeValue(\n+          value = exerciseResult,\n+          errorContext = cantSerialize(attribute = \"exercise result\", forContract = e.targetCoid),\n+      )\n+    )\n+\n+  // Doesn't go through caching, for now caching is limited to events\n+  def serialize(contractId: ContractId, createArgument: LfValue): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(contractId, createArgument),\n+    )\n+\n+  def serialize(eventId: EventId, create: Create): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Create(create.coinst.arg, create.key.map(_.key)),\n+    )\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+  }\n+\n+  def serialize(eventId: EventId, exercise: Exercise): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Exercise(exercise.chosenValue, exercise.exerciseResult),\n+    )\n+    Vector[NamedParameter](\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+    )\n+  }\n+\n+  private def toApiValue(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiValue =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to value\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiValue(\n+          verbose = verbose,\n+          value = value,\n+        ),\n+    )\n+\n+  private def toApiRecord(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiRecord =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to record\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiRecord(\n+          verbose = verbose,\n+          recordValue = value,\n+        ),\n+    )\n+\n+  def deserialize[E](raw: Raw.Created[E], verbose: Boolean): CreatedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val create =\n+      cache\n+        .getIfPresent(key = key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Create(\n+            argument = ValueSerializer.deserializeValue(raw.createArgument),\n+            key = raw.createKeyValue.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertCreate()\n+    raw.partial.copy(\n+      createArguments = Some(\n+        toApiRecord(\n+          value = create.argument,\n+          verbose = verbose,\n+          attribute = \"create argument\",\n+        )\n+      ),\n+      contractKey = create.key.map(\n+        key =>\n+          toApiValue(\n+            value = key,\n+            verbose = verbose,\n+            attribute = \"create key\",\n+        )\n+      ),\n+    )\n+  }\n+\n+  def deserialize(raw: Raw.TreeEvent.Exercised, verbose: Boolean): ExercisedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val exercise =\n+      cache\n+        .getIfPresent(key = key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Exercise(\n+            argument = ValueSerializer.deserializeValue(raw.exerciseArgument),\n+            result = raw.exerciseResult.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertExercise()\n+    raw.partial.copy(\n+      choiceArgument = Some(\n+        toApiValue(\n+          value = exercise.argument,\n+          verbose = verbose,\n+          attribute = \"exercise argument\",\n+        )\n+      ),\n+      exerciseResult = exercise.result.map(\n+        result =>\n+          toApiValue(\n+            value = result,\n+            verbose = verbose,\n+            attribute = \"exercise result\",\n+        )\n+      ),\n+    )\n+  }\n+\n+}\n+\n+object LfValueTranslation {\n+\n+  type Cache = caching.Cache[Cache.Key, Cache.Value]\n+\n+  object Cache {\n+\n+    // To avoid the overhead of measuring the size of objects, we just assign a weight of 1 to values\n+    private implicit object `Key Weight` extends caching.Weight[Key] {\n+      override def weigh(value: Key): caching.Cache.Size = 0\n+    }\n+\n+    // To avoid the overhead of measuring the size of objects, we just assign a weight of 1 to values\n+    private implicit object `Value Weight` extends caching.Weight[Value] {\n+      override def weigh(value: Value): caching.Cache.Size = 1\n+    }\n+\n+    def newInstance(configuration: caching.Configuration): Cache =\n+      caching.Cache.from(configuration)\n+\n+    def newInstrumentedInstance(configuration: caching.Configuration, metrics: Metrics): Cache =\n+      caching.Cache.from(\n+        configuration = configuration,\n+        metrics = metrics.daml.index.db.translation.cache,\n+      )\n+\n+    final class UnexpectedTypeException(value: Value)\n+        extends RuntimeException(s\"Unexpected value $value\")\n+\n+    final case class Key(eventId: String)"
  },
  {
    "id" : "4dd82c45-023b-4198-b2df-5995a3db6d21",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "7f4d1f97-1efd-4784-817c-79380a78ad75",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Why not just use `.get(key, _ => …)`?",
        "createdAt" : "2020-05-20T14:51:47Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8d2612ab-3123-46d0-b087-5cada9466fa9",
        "parentId" : "7f4d1f97-1efd-4784-817c-79380a78ad75",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Because I don't want to recompute most recently queried events, only the most recently indexed ones.",
        "createdAt" : "2020-05-20T16:57:46Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(contractId: ContractId, arg: LfValue): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = contractId),\n+    )\n+\n+  private def serializeCreateArgOrThrow(c: Create): Array[Byte] =\n+    serializeCreateArgOrThrow(c.coid, c.coinst.arg)\n+\n+  private def serializeNullableKeyOrThrow(c: Create): Option[Array[Byte]] =\n+    c.key.map(\n+      k =>\n+        ValueSerializer.serializeValue(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = c.coid),\n+      )\n+    )\n+\n+  private def serializeExerciseArgOrThrow(e: Exercise): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = e.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = e.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(e: Exercise): Option[Array[Byte]] =\n+    e.exerciseResult.map(\n+      exerciseResult =>\n+        ValueSerializer.serializeValue(\n+          value = exerciseResult,\n+          errorContext = cantSerialize(attribute = \"exercise result\", forContract = e.targetCoid),\n+      )\n+    )\n+\n+  // Doesn't go through caching, for now caching is limited to events\n+  def serialize(contractId: ContractId, createArgument: LfValue): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(contractId, createArgument),\n+    )\n+\n+  def serialize(eventId: EventId, create: Create): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Create(create.coinst.arg, create.key.map(_.key)),\n+    )\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+  }\n+\n+  def serialize(eventId: EventId, exercise: Exercise): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Exercise(exercise.chosenValue, exercise.exerciseResult),\n+    )\n+    Vector[NamedParameter](\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+    )\n+  }\n+\n+  private def toApiValue(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiValue =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to value\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiValue(\n+          verbose = verbose,\n+          value = value,\n+        ),\n+    )\n+\n+  private def toApiRecord(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiRecord =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to record\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiRecord(\n+          verbose = verbose,\n+          recordValue = value,\n+        ),\n+    )\n+\n+  def deserialize[E](raw: Raw.Created[E], verbose: Boolean): CreatedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val create =\n+      cache\n+        .getIfPresent(key = key)"
  },
  {
    "id" : "66194578-049f-46a3-bcaa-abcebfc89a94",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "22b5e9de-4764-4b42-9a32-6f36f5780948",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Not sure about the readability of `key = key`. Why not just `key`?",
        "createdAt" : "2020-05-20T14:52:03Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "db986e12-7296-44f9-be16-a01a030dde70",
        "parentId" : "22b5e9de-4764-4b42-9a32-6f36f5780948",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I was using `get` before with two parameters and this just ended up staying here, I think your comment makes a lot of sense, fixing. :slightly_smiling_face: ",
        "createdAt" : "2020-05-20T17:30:18Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "66a2d125-5efe-4433-a466-5468952eea9b",
        "parentId" : "22b5e9de-4764-4b42-9a32-6f36f5780948",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6052/commits/77fa2e4228f21557d434345547e8557511dd4dd7",
        "createdAt" : "2020-05-20T17:31:48Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(contractId: ContractId, arg: LfValue): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = contractId),\n+    )\n+\n+  private def serializeCreateArgOrThrow(c: Create): Array[Byte] =\n+    serializeCreateArgOrThrow(c.coid, c.coinst.arg)\n+\n+  private def serializeNullableKeyOrThrow(c: Create): Option[Array[Byte]] =\n+    c.key.map(\n+      k =>\n+        ValueSerializer.serializeValue(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = c.coid),\n+      )\n+    )\n+\n+  private def serializeExerciseArgOrThrow(e: Exercise): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = e.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = e.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(e: Exercise): Option[Array[Byte]] =\n+    e.exerciseResult.map(\n+      exerciseResult =>\n+        ValueSerializer.serializeValue(\n+          value = exerciseResult,\n+          errorContext = cantSerialize(attribute = \"exercise result\", forContract = e.targetCoid),\n+      )\n+    )\n+\n+  // Doesn't go through caching, for now caching is limited to events\n+  def serialize(contractId: ContractId, createArgument: LfValue): Vector[NamedParameter] =\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(contractId, createArgument),\n+    )\n+\n+  def serialize(eventId: EventId, create: Create): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Create(create.coinst.arg, create.key.map(_.key)),\n+    )\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+  }\n+\n+  def serialize(eventId: EventId, exercise: Exercise): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Exercise(exercise.chosenValue, exercise.exerciseResult),\n+    )\n+    Vector[NamedParameter](\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+    )\n+  }\n+\n+  private def toApiValue(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiValue =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to value\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiValue(\n+          verbose = verbose,\n+          value = value,\n+        ),\n+    )\n+\n+  private def toApiRecord(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiRecord =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to record\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiRecord(\n+          verbose = verbose,\n+          recordValue = value,\n+        ),\n+    )\n+\n+  def deserialize[E](raw: Raw.Created[E], verbose: Boolean): CreatedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val create =\n+      cache\n+        .getIfPresent(key = key)"
  },
  {
    "id" : "f369c726-b5b0-463e-9cc6-3b9b5579220a",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "8c8669c7-9a4b-4971-9e27-6a0e06c8eaca",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n  private def cannotSerialize(attribute: String, forContract: ContractId): String =\r\n```",
        "createdAt" : "2020-05-25T13:59:23Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c67d9ac7-9d38-4639-85f9-68ac8560310f",
        "parentId" : "8c8669c7-9a4b-4971-9e27-6a0e06c8eaca",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Thanks, seems unnecessary though.",
        "createdAt" : "2020-05-26T07:22:42Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : 18,
    "diffHunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String ="
  },
  {
    "id" : "00aaa9ce-fd58-439c-abbd-cb42d56897ae",
    "prId" : 6052,
    "comments" : [
      {
        "id" : "13e5f143-2f61-419e-adcb-8a2111042b25",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Just construct a count-based caffeine cache, i.e., use `.maximumSize(...)` instead of `.maximumWeight(...)` and a weighter when creating the cache:\r\nhttps://github.com/ben-manes/caffeine/blob/4451d4443f1db71d3dc11925a1bca9a5206dd539/caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java#L368",
        "createdAt" : "2020-05-25T14:05:45Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2b255976-1d81-4d39-aaf5-c5bb541d613d",
        "parentId" : "13e5f143-2f61-419e-adcb-8a2111042b25",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I tried this already, unfortunately this starts to get out of scope with several changes needed to make sure we have an alternative that doesn't take an implicit `Weight` and that everything typechecks. I agree it's a meaningful improvement but I'd prefer not making everything in one PR which is already reasonably large.",
        "createdAt" : "2020-05-26T07:25:34Z",
        "updatedAt" : "2020-05-26T07:28:28Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9945ea44fabe5fe18e6608839b2ce57f04cbb4ee",
    "line" : 185,
    "diffHunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import anorm.NamedParameter\n+import com.daml.caching\n+import com.daml.ledger.api.v1.value.{Record => ApiRecord, Value => ApiValue}\n+import com.daml.ledger.EventId\n+import com.daml.ledger.api.v1.event.{CreatedEvent, ExercisedEvent}\n+import com.daml.metrics.Metrics\n+import com.daml.platform.participant.util.LfEngineToApi\n+import com.daml.platform.store.dao.events.{Value => LfValue}\n+import com.daml.platform.store.serialization.ValueSerializer\n+\n+final class LfValueTranslation(val cache: LfValueTranslation.Cache) {\n+\n+  private def cantSerialize(attribute: String, forContract: ContractId): String =\n+    s\"Cannot serialize $attribute for ${forContract.coid}\"\n+\n+  private def serializeCreateArgOrThrow(contractId: ContractId, arg: LfValue): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = arg,\n+      errorContext = cantSerialize(attribute = \"create argument\", forContract = contractId),\n+    )\n+\n+  private def serializeCreateArgOrThrow(c: Create): Array[Byte] =\n+    serializeCreateArgOrThrow(c.coid, c.coinst.arg)\n+\n+  private def serializeNullableKeyOrThrow(c: Create): Option[Array[Byte]] =\n+    c.key.map(\n+      k =>\n+        ValueSerializer.serializeValue(\n+          value = k.key,\n+          errorContext = cantSerialize(attribute = \"key\", forContract = c.coid),\n+      )\n+    )\n+\n+  private def serializeExerciseArgOrThrow(e: Exercise): Array[Byte] =\n+    ValueSerializer.serializeValue(\n+      value = e.chosenValue,\n+      errorContext = cantSerialize(attribute = \"exercise argument\", forContract = e.targetCoid),\n+    )\n+\n+  private def serializeNullableExerciseResultOrThrow(e: Exercise): Option[Array[Byte]] =\n+    e.exerciseResult.map(\n+      exerciseResult =>\n+        ValueSerializer.serializeValue(\n+          value = exerciseResult,\n+          errorContext = cantSerialize(attribute = \"exercise result\", forContract = e.targetCoid),\n+      )\n+    )\n+\n+  // Doesn't go through caching, for now caching is limited to events\n+  def serialize(contractId: ContractId, createArgument: LfValue): NamedParameter =\n+    (\"create_argument\", serializeCreateArgOrThrow(contractId, createArgument))\n+\n+  def serialize(eventId: EventId, create: Create): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Create(create.coinst.arg, create.key.map(_.key)),\n+    )\n+    Vector[NamedParameter](\n+      \"create_argument\" -> serializeCreateArgOrThrow(create),\n+      \"create_key_value\" -> serializeNullableKeyOrThrow(create),\n+    )\n+  }\n+\n+  def serialize(eventId: EventId, exercise: Exercise): Vector[NamedParameter] = {\n+    cache.put(\n+      key = LfValueTranslation.Cache.Key(eventId),\n+      value = LfValueTranslation.Cache.Value.Exercise(exercise.chosenValue, exercise.exerciseResult),\n+    )\n+    Vector[NamedParameter](\n+      \"exercise_argument\" -> serializeExerciseArgOrThrow(exercise),\n+      \"exercise_result\" -> serializeNullableExerciseResultOrThrow(exercise),\n+    )\n+  }\n+\n+  private def toApiValue(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiValue =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to value\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiValue(\n+          verbose = verbose,\n+          value = value,\n+        ),\n+    )\n+\n+  private def toApiRecord(\n+      value: LfValue,\n+      verbose: Boolean,\n+      attribute: => String,\n+  ): ApiRecord =\n+    LfEngineToApi.assertOrRuntimeEx(\n+      failureContext = s\"attempting to deserialize persisted $attribute to record\",\n+      LfEngineToApi\n+        .lfVersionedValueToApiRecord(\n+          verbose = verbose,\n+          recordValue = value,\n+        ),\n+    )\n+\n+  def deserialize[E](raw: Raw.Created[E], verbose: Boolean): CreatedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val create =\n+      cache\n+        .getIfPresent(key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Create(\n+            argument = ValueSerializer.deserializeValue(raw.createArgument),\n+            key = raw.createKeyValue.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertCreate()\n+    raw.partial.copy(\n+      createArguments = Some(\n+        toApiRecord(\n+          value = create.argument,\n+          verbose = verbose,\n+          attribute = \"create argument\",\n+        )\n+      ),\n+      contractKey = create.key.map(\n+        key =>\n+          toApiValue(\n+            value = key,\n+            verbose = verbose,\n+            attribute = \"create key\",\n+        )\n+      ),\n+    )\n+  }\n+\n+  def deserialize(raw: Raw.TreeEvent.Exercised, verbose: Boolean): ExercisedEvent = {\n+    val key = LfValueTranslation.Cache.Key(raw.partial.eventId)\n+    val exercise =\n+      cache\n+        .getIfPresent(key)\n+        .getOrElse(\n+          LfValueTranslation.Cache.Value.Exercise(\n+            argument = ValueSerializer.deserializeValue(raw.exerciseArgument),\n+            result = raw.exerciseResult.map(ValueSerializer.deserializeValue)\n+          )\n+        )\n+        .assertExercise()\n+    raw.partial.copy(\n+      choiceArgument = Some(\n+        toApiValue(\n+          value = exercise.argument,\n+          verbose = verbose,\n+          attribute = \"exercise argument\",\n+        )\n+      ),\n+      exerciseResult = exercise.result.map(\n+        result =>\n+          toApiValue(\n+            value = result,\n+            verbose = verbose,\n+            attribute = \"exercise result\",\n+        )\n+      ),\n+    )\n+  }\n+\n+}\n+\n+object LfValueTranslation {\n+\n+  type Cache = caching.Cache[Cache.Key, Cache.Value]\n+\n+  object Cache {\n+\n+    private implicit object `Key Weight` extends caching.Weight[Key] {\n+      override def weigh(value: Key): caching.Cache.Size =\n+        0 // make sure that only the value is counted\n+    }\n+\n+    private implicit object `Value Weight` extends caching.Weight[Value] {\n+      override def weigh(value: Value): caching.Cache.Size =\n+        1 // TODO replace this with something to avoid weights entirely"
  }
]