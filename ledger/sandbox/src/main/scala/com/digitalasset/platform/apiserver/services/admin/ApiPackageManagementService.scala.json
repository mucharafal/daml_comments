[
  {
    "id" : "3794d814-a177-4c7a-8dcc-3673019907b7",
    "prId" : 4097,
    "comments" : [
      {
        "id" : "4a043392-84cb-497e-ab5e-35f2b51eb8df",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Perhaps avoid shadowing here by renaming this `result` to `completed` or something?",
        "createdAt" : "2020-01-21T08:43:22Z",
        "updatedAt" : "2020-01-21T09:13:27Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a5a7f34-be6e-41ce-b0e6-fe83ef0ea79a",
        "parentId" : "4a043392-84cb-497e-ab5e-35f2b51eb8df",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Didn't notice that, thanks.",
        "createdAt" : "2020-01-21T09:10:25Z",
        "updatedAt" : "2020-01-21T09:13:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "98849d39-ee6f-496d-8b83-0709f253d303",
        "parentId" : "4a043392-84cb-497e-ab5e-35f2b51eb8df",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/4097/commits/80ef9a78495c345ca3a7442bc7c2397f4901c132",
        "createdAt" : "2020-01-21T09:14:00Z",
        "updatedAt" : "2020-01-21T09:14:01Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "80ef9a78495c345ca3a7442bc7c2397f4901c132",
    "line" : null,
    "diffHunk" : "@@ -40,76 +40,76 @@ final class ApiPackageManagementService private (\n     extends PackageManagementService\n     with GrpcApiService {\n \n-  private val logging = PassThroughLogger.get[this.type]\n+  private val logger = ContextualizedLogger.get(this.getClass)\n \n   override def close(): Unit = ()\n \n   override def bindService(): ServerServiceDefinition =\n     PackageManagementServiceGrpc.bindService(this, DE)\n \n   override def listKnownPackages(\n-      request: ListKnownPackagesRequest): Future[ListKnownPackagesResponse] =\n-    logging {\n-      packagesIndex\n-        .listLfPackages()\n-        .map { pkgs =>\n-          ListKnownPackagesResponse(pkgs.toSeq.map {\n-            case (pkgId, details) =>\n-              PackageDetails(\n-                pkgId.toString,\n-                details.size,\n-                Some(Timestamp(details.knownSince.getEpochSecond, details.knownSince.getNano)),\n-                details.sourceDescription.getOrElse(\"\"))\n-          })\n-        }(DE)\n-    }\n+      request: ListKnownPackagesRequest): Future[ListKnownPackagesResponse] = {\n+    packagesIndex\n+      .listLfPackages()\n+      .map { pkgs =>\n+        ListKnownPackagesResponse(pkgs.toSeq.map {\n+          case (pkgId, details) =>\n+            PackageDetails(\n+              pkgId.toString,\n+              details.size,\n+              Some(Timestamp(details.knownSince.getEpochSecond, details.knownSince.getNano)),\n+              details.sourceDescription.getOrElse(\"\"))\n+        })\n+      }(DE)\n+      .andThen(logger.logErrorsOnCall[ListKnownPackagesResponse])(DE)\n+  }\n \n-  override def uploadDarFile(request: UploadDarFileRequest): Future[UploadDarFileResponse] =\n-    logging {\n-      val submissionId =\n-        if (request.submissionId.isEmpty)\n-          SubmissionId.assertFromString(UUID.randomUUID().toString)\n-        else\n-          SubmissionId.assertFromString(request.submissionId)\n+  override def uploadDarFile(request: UploadDarFileRequest): Future[UploadDarFileResponse] = {\n+    val submissionId =\n+      if (request.submissionId.isEmpty)\n+        SubmissionId.assertFromString(UUID.randomUUID().toString)\n+      else\n+        SubmissionId.assertFromString(request.submissionId)\n \n-      // Amount of time we wait for the ledger to commit the request before we\n-      // give up on polling for the result.\n-      // TODO(JM): This constant should be replaced by user-provided maximum record time\n-      // which should be wired through the stack and verified during validation, just like\n-      // with transactions. I'm leaving this for another PR.\n-      val timeToLive = 30.seconds\n+    // Amount of time we wait for the ledger to commit the request before we\n+    // give up on polling for the result.\n+    // TODO(JM): This constant should be replaced by user-provided maximum record time\n+    // which should be wired through the stack and verified during validation, just like\n+    // with transactions. I'm leaving this for another PR.\n+    val timeToLive = 30.seconds\n \n-      implicit val ec: ExecutionContext = DE\n-      for {\n-        dar <- DarReader { case (_, x) => Try(Archive.parseFrom(x)) }\n-          .readArchive(\n-            \"package-upload\",\n-            new ZipInputStream(new ByteArrayInputStream(request.darFile.toByteArray)))\n-          .fold(\n-            err => Future.failed(ErrorFactories.invalidArgument(err.getMessage)),\n-            Future.successful\n-          )\n-        ledgerEndBeforeRequest <- transactionsService.currentLedgerEnd()\n-        result <- FutureConverters.toScala(\n-          packagesWrite.uploadPackages(submissionId, dar.all, None)\n+    implicit val ec: ExecutionContext = DE\n+    val response = for {\n+      dar <- DarReader { case (_, x) => Try(Archive.parseFrom(x)) }\n+        .readArchive(\n+          \"package-upload\",\n+          new ZipInputStream(new ByteArrayInputStream(request.darFile.toByteArray)))\n+        .fold(\n+          err => Future.failed(ErrorFactories.invalidArgument(err.getMessage)),\n+          Future.successful\n         )\n-        response <- result match {\n-          case SubmissionResult.Acknowledged =>\n-            pollUntilPersisted(submissionId, timeToLive, ledgerEndBeforeRequest).flatMap {\n-              case _: PackageEntry.PackageUploadAccepted =>\n-                Future.successful(UploadDarFileResponse())\n-              case PackageEntry.PackageUploadRejected(_, _, reason) =>\n-                Future.failed(ErrorFactories.invalidArgument(reason))\n-            }\n-          case r @ SubmissionResult.Overloaded =>\n-            Future.failed(ErrorFactories.resourceExhausted(r.description))\n-          case r @ SubmissionResult.InternalError(_) =>\n-            Future.failed(ErrorFactories.internal(r.reason))\n-          case r @ SubmissionResult.NotSupported =>\n-            Future.failed(ErrorFactories.unimplemented(r.description))\n-        }\n-      } yield response\n-    }\n+      ledgerEndBeforeRequest <- transactionsService.currentLedgerEnd()\n+      result <- FutureConverters.toScala(\n+        packagesWrite.uploadPackages(submissionId, dar.all, None)\n+      )\n+      result <- result match {"
  }
]