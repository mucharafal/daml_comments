[
  {
    "id" : "dc5764fb-f2d3-4b40-8ef6-f306241d9e27",
    "prId" : 2739,
    "comments" : [
      {
        "id" : "75b195d8-cb7b-4f47-b066-3e8474f71fb9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This also needs to remove the `cid` from divulged contracts, as a party can exercise a consuming choice on a divulged contract.",
        "createdAt" : "2019-09-04T07:09:57Z",
        "updatedAt" : "2019-09-11T10:46:28Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ac3bcd307e2d601598569750bf6c67817e64928e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.v1.AbsoluteContractInst\n+import com.digitalasset.daml.lf.data.Ref.{Party, TransactionIdString}\n+import com.digitalasset.daml.lf.data.Relation.Relation\n+import com.digitalasset.daml.lf.transaction.Node.GlobalKey\n+import com.digitalasset.daml.lf.transaction.GenTransaction\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.AbsoluteContractId\n+import com.digitalasset.ledger.WorkflowId\n+import com.digitalasset.ledger.api.domain.PartyDetails\n+import com.digitalasset.platform.sandbox.stores.ActiveLedgerState._\n+import com.digitalasset.platform.sandbox.stores.ledger.SequencingError\n+import scalaz.syntax.std.map._\n+\n+case class InMemoryActiveLedgerState(\n+    activeContracts: Map[AbsoluteContractId, ActiveContract],\n+    divulgedContracts: Map[AbsoluteContractId, DivulgedContract],\n+    keys: Map[GlobalKey, AbsoluteContractId],\n+    parties: Map[Party, PartyDetails])\n+    extends ActiveLedgerState[InMemoryActiveLedgerState] {\n+\n+  override def lookupActiveContract(cid: AbsoluteContractId): Option[ActiveContract] =\n+    activeContracts.get(cid)\n+\n+  override def lookupContract(cid: AbsoluteContractId): Option[Contract] =\n+    activeContracts.get(cid).orElse[Contract](divulgedContracts.get(cid))\n+\n+  override def keyExists(key: GlobalKey) = keys.contains(key)\n+\n+  /**\n+    * Updates divulgence information on the given active contract with information\n+    * from the already existing divulged contract.\n+    */\n+  private def copyDivulgences(ac: ActiveContract, dc: DivulgedContract): ActiveContract =\n+    ac.copy(divulgences = ac.divulgences.unionWith(dc.divulgences)((l, _) => l))\n+\n+  override def addContract(\n+      c: ActiveContract,\n+      keyO: Option[GlobalKey]): InMemoryActiveLedgerState = {\n+    val newKeys = keyO match {\n+      case None => keys\n+      case Some(key) => keys + (key -> c.id)\n+    }\n+    divulgedContracts.get(c.id) match {\n+      case None =>\n+        copy(\n+          activeContracts = activeContracts + (c.id -> c),\n+          keys = newKeys\n+        )\n+      case Some(dc) =>\n+        copy(\n+          activeContracts = activeContracts + (c.id -> copyDivulgences(c, dc)),\n+          divulgedContracts = divulgedContracts - c.id,\n+          keys = newKeys\n+        )\n+    }\n+  }\n+\n+  override def removeContract(cid: AbsoluteContractId, keyO: Option[GlobalKey]) = keyO match {"
  },
  {
    "id" : "57aec9ef-b2be-4b20-a730-e2a576eb1ac5",
    "prId" : 2739,
    "comments" : [
      {
        "id" : "b986ebc8-9ea0-4f45-8900-b9286aa48b2a",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please use the partial function syntax to pattern match on `e` and give `_1` and `_2` meaningful names.",
        "createdAt" : "2019-09-04T07:31:05Z",
        "updatedAt" : "2019-09-11T10:46:28Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ac3bcd307e2d601598569750bf6c67817e64928e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.v1.AbsoluteContractInst\n+import com.digitalasset.daml.lf.data.Ref.{Party, TransactionIdString}\n+import com.digitalasset.daml.lf.data.Relation.Relation\n+import com.digitalasset.daml.lf.transaction.Node.GlobalKey\n+import com.digitalasset.daml.lf.transaction.GenTransaction\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.AbsoluteContractId\n+import com.digitalasset.ledger.WorkflowId\n+import com.digitalasset.ledger.api.domain.PartyDetails\n+import com.digitalasset.platform.sandbox.stores.ActiveLedgerState._\n+import com.digitalasset.platform.sandbox.stores.ledger.SequencingError\n+import scalaz.syntax.std.map._\n+\n+case class InMemoryActiveLedgerState(\n+    activeContracts: Map[AbsoluteContractId, ActiveContract],\n+    divulgedContracts: Map[AbsoluteContractId, DivulgedContract],\n+    keys: Map[GlobalKey, AbsoluteContractId],\n+    parties: Map[Party, PartyDetails])\n+    extends ActiveLedgerState[InMemoryActiveLedgerState] {\n+\n+  override def lookupActiveContract(cid: AbsoluteContractId): Option[ActiveContract] =\n+    activeContracts.get(cid)\n+\n+  override def lookupContract(cid: AbsoluteContractId): Option[Contract] =\n+    activeContracts.get(cid).orElse[Contract](divulgedContracts.get(cid))\n+\n+  override def keyExists(key: GlobalKey) = keys.contains(key)\n+\n+  /**\n+    * Updates divulgence information on the given active contract with information\n+    * from the already existing divulged contract.\n+    */\n+  private def copyDivulgences(ac: ActiveContract, dc: DivulgedContract): ActiveContract =\n+    ac.copy(divulgences = ac.divulgences.unionWith(dc.divulgences)((l, _) => l))\n+\n+  override def addContract(\n+      c: ActiveContract,\n+      keyO: Option[GlobalKey]): InMemoryActiveLedgerState = {\n+    val newKeys = keyO match {\n+      case None => keys\n+      case Some(key) => keys + (key -> c.id)\n+    }\n+    divulgedContracts.get(c.id) match {\n+      case None =>\n+        copy(\n+          activeContracts = activeContracts + (c.id -> c),\n+          keys = newKeys\n+        )\n+      case Some(dc) =>\n+        copy(\n+          activeContracts = activeContracts + (c.id -> copyDivulgences(c, dc)),\n+          divulgedContracts = divulgedContracts - c.id,\n+          keys = newKeys\n+        )\n+    }\n+  }\n+\n+  override def removeContract(cid: AbsoluteContractId, keyO: Option[GlobalKey]) = keyO match {\n+    case None => copy(activeContracts = activeContracts - cid)\n+    case Some(key) => copy(activeContracts = activeContracts - cid, keys = keys - key)\n+  }\n+\n+  override def addParties(newParties: Set[Party]): InMemoryActiveLedgerState =\n+    copy(parties = newParties.map(p => p -> PartyDetails(p, None, true)).toMap ++ parties)\n+\n+  override def divulgeAlreadyCommittedContract(\n+      transactionId: TransactionIdString,\n+      global: Relation[AbsoluteContractId, Party],\n+      referencedContracts: List[(Value.AbsoluteContractId, AbsoluteContractInst)])\n+    : InMemoryActiveLedgerState =\n+    if (global.nonEmpty) {\n+      val referencedContractsM = referencedContracts.toMap\n+      // Note: each entry in `global` can refer to either:\n+      // - a known active contract, in which case its divulgence info is updated\n+      // - a divulged contract, in which case its divulgence info is updated\n+      // - an unknown contract, in which case a new divulged contract is stored\n+      val updatedAcs = activeContracts.intersectWith(global) { (ac, parties) =>\n+        ac copy (divulgences = ac.divulgeTo(parties, transactionId))\n+      }\n+      val updatedDcs = divulgedContracts.intersectWith(global) { (dc, parties) =>\n+        dc copy (divulgences = dc.divulgeTo(parties, transactionId))\n+      }\n+      val newDcs = global.foldLeft(Map.empty[AbsoluteContractId, DivulgedContract])(\n+        (m, e) =>"
  },
  {
    "id" : "066f7d4b-16fd-4b27-bb87-179ffde71bf6",
    "prId" : 2739,
    "comments" : [
      {
        "id" : "d03dcb54-db76-42d9-8415-4f8f48c91d3c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please rename `global` (there is no `local`?) to `divulgences` or something in that direction.",
        "createdAt" : "2019-09-04T07:33:08Z",
        "updatedAt" : "2019-09-11T10:46:28Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ac3bcd307e2d601598569750bf6c67817e64928e",
    "line" : 79,
    "diffHunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.v1.AbsoluteContractInst\n+import com.digitalasset.daml.lf.data.Ref.{Party, TransactionIdString}\n+import com.digitalasset.daml.lf.data.Relation.Relation\n+import com.digitalasset.daml.lf.transaction.Node.GlobalKey\n+import com.digitalasset.daml.lf.transaction.GenTransaction\n+import com.digitalasset.daml.lf.value.Value\n+import com.digitalasset.daml.lf.value.Value.AbsoluteContractId\n+import com.digitalasset.ledger.WorkflowId\n+import com.digitalasset.ledger.api.domain.PartyDetails\n+import com.digitalasset.platform.sandbox.stores.ActiveLedgerState._\n+import com.digitalasset.platform.sandbox.stores.ledger.SequencingError\n+import scalaz.syntax.std.map._\n+\n+case class InMemoryActiveLedgerState(\n+    activeContracts: Map[AbsoluteContractId, ActiveContract],\n+    divulgedContracts: Map[AbsoluteContractId, DivulgedContract],\n+    keys: Map[GlobalKey, AbsoluteContractId],\n+    parties: Map[Party, PartyDetails])\n+    extends ActiveLedgerState[InMemoryActiveLedgerState] {\n+\n+  override def lookupActiveContract(cid: AbsoluteContractId): Option[ActiveContract] =\n+    activeContracts.get(cid)\n+\n+  override def lookupContract(cid: AbsoluteContractId): Option[Contract] =\n+    activeContracts.get(cid).orElse[Contract](divulgedContracts.get(cid))\n+\n+  override def keyExists(key: GlobalKey) = keys.contains(key)\n+\n+  /**\n+    * Updates divulgence information on the given active contract with information\n+    * from the already existing divulged contract.\n+    */\n+  private def copyDivulgences(ac: ActiveContract, dc: DivulgedContract): ActiveContract =\n+    ac.copy(divulgences = ac.divulgences.unionWith(dc.divulgences)((l, _) => l))\n+\n+  override def addContract(\n+      c: ActiveContract,\n+      keyO: Option[GlobalKey]): InMemoryActiveLedgerState = {\n+    val newKeys = keyO match {\n+      case None => keys\n+      case Some(key) => keys + (key -> c.id)\n+    }\n+    divulgedContracts.get(c.id) match {\n+      case None =>\n+        copy(\n+          activeContracts = activeContracts + (c.id -> c),\n+          keys = newKeys\n+        )\n+      case Some(dc) =>\n+        copy(\n+          activeContracts = activeContracts + (c.id -> copyDivulgences(c, dc)),\n+          divulgedContracts = divulgedContracts - c.id,\n+          keys = newKeys\n+        )\n+    }\n+  }\n+\n+  override def removeContract(cid: AbsoluteContractId, keyO: Option[GlobalKey]) = keyO match {\n+    case None => copy(activeContracts = activeContracts - cid)\n+    case Some(key) => copy(activeContracts = activeContracts - cid, keys = keys - key)\n+  }\n+\n+  override def addParties(newParties: Set[Party]): InMemoryActiveLedgerState =\n+    copy(parties = newParties.map(p => p -> PartyDetails(p, None, true)).toMap ++ parties)\n+\n+  override def divulgeAlreadyCommittedContract(\n+      transactionId: TransactionIdString,\n+      global: Relation[AbsoluteContractId, Party],"
  }
]