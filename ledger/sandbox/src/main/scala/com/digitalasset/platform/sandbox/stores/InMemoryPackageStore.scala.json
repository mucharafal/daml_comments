[
  {
    "id" : "12612815-e7a1-4187-8c83-79c3e66925be",
    "prId" : 3806,
    "comments" : [
      {
        "id" : "70d86ab6-89c8-430a-9704-f7b99f4f80b0",
        "parentId" : null,
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Forgetmenot",
        "createdAt" : "2019-12-11T07:28:02Z",
        "updatedAt" : "2019-12-12T15:08:00Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a2923e68-dec3-4b25-83be-f8520412ae45",
        "parentId" : "70d86ab6-89c8-430a-9704-f7b99f4f80b0",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Fixed by dropping this and not extending IndexPackageService (which made no sense anyway).",
        "createdAt" : "2019-12-11T11:02:03Z",
        "updatedAt" : "2019-12-12T15:08:00Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "251fd5fc053893266c997d1d7451a1f25479df7b",
    "line" : null,
    "diffHunk" : "@@ -70,6 +73,9 @@ case class InMemoryPackageStore(\n     } yield packages\n   }\n \n+  // FIXME(JM): Move packageEntries into its own interface?\n+  def packageEntries(beginOffset: LedgerOffset.Absolute): Source[PackageEntry, NotUsed] = ???"
  },
  {
    "id" : "6c0d9907-84bc-49ac-a3b6-28e66dc09c71",
    "prId" : 1610,
    "comments" : [
      {
        "id" : "bbeb14bc-e9a7-4b32-87b5-dd7f2e66bd98",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    CompletableFuture.completedFuture(result match {\r\n```",
        "createdAt" : "2019-06-14T16:58:11Z",
        "updatedAt" : "2019-06-19T11:34:16Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e866b02c0df2f20dcee08439e1105fe577f0609",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,124 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores\n+\n+import java.io.{File, FileOutputStream}\n+import java.time.Instant\n+import java.util.concurrent.{CompletableFuture, CompletionStage}\n+import java.util.zip.ZipFile\n+\n+import com.daml.ledger.participant.state.index.v2.{IndexPackagesService, PackageDetails}\n+import com.daml.ledger.participant.state.v2.UploadDarResult\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.archive.{DarReader, Decode}\n+import com.digitalasset.daml.lf.data.Ref.PackageId\n+import com.digitalasset.daml.lf.data.TryOps.Bracket.bracket\n+import com.digitalasset.daml.lf.language.Ast\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import org.slf4j.LoggerFactory\n+import scalaz.std.either._\n+import scalaz.std.list._\n+import scalaz.syntax.traverse._\n+\n+import scala.collection.immutable.Map\n+import scala.collection.mutable\n+import scala.concurrent.Future\n+import scala.util.{Failure, Success, Try}\n+\n+class InMemoryPackageStore() extends IndexPackagesService {\n+  private val logger = LoggerFactory.getLogger(this.getClass)\n+\n+  private val packageInfos: mutable.Map[PackageId, PackageDetails] = mutable.Map()\n+  private val packages: mutable.Map[PackageId, Ast.Package] = mutable.Map()\n+  private val archives: mutable.Map[PackageId, Archive] = mutable.Map()\n+\n+  override def listLfPackages(): Future[Map[PackageId, PackageDetails]] =\n+    Future.successful(listLfPackagesSync())\n+\n+  def listLfPackagesSync(): Map[PackageId, PackageDetails] = this.synchronized {\n+    Map() ++ packageInfos\n+  }\n+\n+  override def getLfArchive(packageId: PackageId): Future[Option[Archive]] =\n+    Future.successful(getLfArchiveSync(packageId))\n+\n+  def getLfArchiveSync(packageId: PackageId): Option[Archive] = this.synchronized {\n+    archives.get(packageId)\n+  }\n+\n+  override def getLfPackage(packageId: PackageId): Future[Option[Ast.Package]] =\n+    Future.successful(getLfPackageSync(packageId))\n+\n+  def getLfPackageSync(packageId: PackageId): Option[Ast.Package] = this.synchronized {\n+    packages.get(packageId)\n+  }\n+\n+  def uploadDar(\n+      knownSince: Instant,\n+      sourceDescription: String,\n+      packageBytes: Array[Byte]): CompletionStage[UploadDarResult] = this.synchronized {\n+    // TODO this should probably be asynchronous\n+    val file = File.createTempFile(\"put-package\", \".dar\")\n+    val result = bracket(Try(new FileOutputStream(file)))(fos => Try(fos.close()))\n+      .flatMap { fos =>\n+        Try(fos.write(packageBytes))\n+      }\n+      .map { _ =>\n+        putDarFile(knownSince, sourceDescription, file)\n+      }\n+    result match {"
  },
  {
    "id" : "e48e8f11-caaa-4d33-97d6-ecb40b7a4c2e",
    "prId" : 1610,
    "comments" : [
      {
        "id" : "16dedb7d-bfb8-41f9-a79f-6f87c8b3cae4",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n              case err: ParseError => Left(s\"Could not parse archive ${archive.getHash}: $err\")\r\n```",
        "createdAt" : "2019-06-14T17:59:51Z",
        "updatedAt" : "2019-06-19T11:34:16Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e866b02c0df2f20dcee08439e1105fe577f0609",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,124 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores\n+\n+import java.io.{File, FileOutputStream}\n+import java.time.Instant\n+import java.util.concurrent.{CompletableFuture, CompletionStage}\n+import java.util.zip.ZipFile\n+\n+import com.daml.ledger.participant.state.index.v2.{IndexPackagesService, PackageDetails}\n+import com.daml.ledger.participant.state.v2.UploadDarResult\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.archive.{DarReader, Decode}\n+import com.digitalasset.daml.lf.data.Ref.PackageId\n+import com.digitalasset.daml.lf.data.TryOps.Bracket.bracket\n+import com.digitalasset.daml.lf.language.Ast\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import org.slf4j.LoggerFactory\n+import scalaz.std.either._\n+import scalaz.std.list._\n+import scalaz.syntax.traverse._\n+\n+import scala.collection.immutable.Map\n+import scala.collection.mutable\n+import scala.concurrent.Future\n+import scala.util.{Failure, Success, Try}\n+\n+class InMemoryPackageStore() extends IndexPackagesService {\n+  private val logger = LoggerFactory.getLogger(this.getClass)\n+\n+  private val packageInfos: mutable.Map[PackageId, PackageDetails] = mutable.Map()\n+  private val packages: mutable.Map[PackageId, Ast.Package] = mutable.Map()\n+  private val archives: mutable.Map[PackageId, Archive] = mutable.Map()\n+\n+  override def listLfPackages(): Future[Map[PackageId, PackageDetails]] =\n+    Future.successful(listLfPackagesSync())\n+\n+  def listLfPackagesSync(): Map[PackageId, PackageDetails] = this.synchronized {\n+    Map() ++ packageInfos\n+  }\n+\n+  override def getLfArchive(packageId: PackageId): Future[Option[Archive]] =\n+    Future.successful(getLfArchiveSync(packageId))\n+\n+  def getLfArchiveSync(packageId: PackageId): Option[Archive] = this.synchronized {\n+    archives.get(packageId)\n+  }\n+\n+  override def getLfPackage(packageId: PackageId): Future[Option[Ast.Package]] =\n+    Future.successful(getLfPackageSync(packageId))\n+\n+  def getLfPackageSync(packageId: PackageId): Option[Ast.Package] = this.synchronized {\n+    packages.get(packageId)\n+  }\n+\n+  def uploadDar(\n+      knownSince: Instant,\n+      sourceDescription: String,\n+      packageBytes: Array[Byte]): CompletionStage[UploadDarResult] = this.synchronized {\n+    // TODO this should probably be asynchronous\n+    val file = File.createTempFile(\"put-package\", \".dar\")\n+    val result = bracket(Try(new FileOutputStream(file)))(fos => Try(fos.close()))\n+      .flatMap { fos =>\n+        Try(fos.write(packageBytes))\n+      }\n+      .map { _ =>\n+        putDarFile(knownSince, sourceDescription, file)\n+      }\n+    result match {\n+      case Success(Right(details @ _)) =>\n+        // TODO(FM) I'd like to include the details above but i get a strange error\n+        // about mismatching PackageId type\n+        CompletableFuture.completedFuture(UploadDarResult.Ok)\n+      case Success(Left(err)) =>\n+        CompletableFuture.completedFuture(UploadDarResult.InvalidPackage(err))\n+      case Failure(exception) =>\n+        CompletableFuture.completedFuture(UploadDarResult.InvalidPackage(exception.getMessage))\n+    }\n+  }\n+\n+  def putDarFile(\n+      knownSince: Instant,\n+      sourceDescription: String,\n+      file: File): Either[String, Map[PackageId, PackageDetails]] = this.synchronized {\n+    DarReader { case (size, x) => Try(Archive.parseFrom(x)).map(ar => (size, ar)) }\n+      .readArchive(new ZipFile(file))\n+      .fold(t => Left(s\"Failed to parse DAR from $file: $t\"), dar => Right(dar.all))\n+      .flatMap {\n+        _ traverseU {\n+          case (size, archive) =>\n+            try {\n+              Right((size, archive, Decode.decodeArchive(archive)._2))\n+            } catch {\n+              case err: ParseError => Left(s\"Could not parse archive $archive.getHash: $err\")"
  }
]