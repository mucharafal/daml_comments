[
  {
    "id" : "9ae8160f-a663-4673-9f58-b2f52f2ddfb6",
    "prId" : 6289,
    "comments" : [
      {
        "id" : "eb4efcdc-f018-4a69-854d-21b36f66bad9",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n  private[this] def lookupActiveContractWithoutArgument(\r\n```\r\n1. if you limit the visibility to the instance to make the runtime works easier when it comes to inlining, consider that `private` is enough for methods (`private[this]` has an effect on `val`s)\r\n2. are you sure the name is correct? Probably `lookupCachedActiveContract` would be less ambiguous.",
        "createdAt" : "2020-06-11T07:25:17Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "88fbf388af498692afc5283d2a171d201046eb70",
    "line" : null,
    "diffHunk" : "@@ -55,6 +63,45 @@ private[dao] sealed abstract class ContractsReader(\n           )\n       })\n \n+  /** Lookup of a contract in the case the contract value is already known (loaded from a cache) */\n+  private[this] def lookupActiveContractWithoutArgument("
  },
  {
    "id" : "9d24f6ff-446a-4526-8c19-60d89b8add63",
    "prId" : 6289,
    "comments" : [
      {
        "id" : "b3b20adb-ca5d-4e98-9011-7e0836db07b7",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "The cache is already instrumented. Do we have some other way of recording hits and misses for contracts?",
        "createdAt" : "2020-06-11T07:27:30Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "42e4df8d-8a1e-476b-8699-5e1da565e413",
        "parentId" : "b3b20adb-ca5d-4e98-9011-7e0836db07b7",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "The cache is instrumented, but it only measures an overall hit/miss rate. I wanted to specifically measure the hit rate for contract arguments during active contract lookups.\r\n\r\nSince this is not a very important metric, we could also remove it.",
        "createdAt" : "2020-06-11T08:54:43Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9d81d8c7-3ddb-4e55-8ad4-6d626167fda1",
        "parentId" : "b3b20adb-ca5d-4e98-9011-7e0836db07b7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I don't know, I recognize the importance of having this in to measure the impact. If I'm not mistaken we are actually using the same cache to store both creates for events and contracts, so they are effectively stored twice. If that's true, would it not make more sense to simply store them separately?",
        "createdAt" : "2020-06-11T10:37:43Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "88fbf388af498692afc5283d2a171d201046eb70",
    "line" : null,
    "diffHunk" : "@@ -55,6 +63,45 @@ private[dao] sealed abstract class ContractsReader(\n           )\n       })\n \n+  /** Lookup of a contract in the case the contract value is already known (loaded from a cache) */\n+  private[this] def lookupActiveContractWithoutArgument(\n+      submitter: Party,\n+      contractId: ContractId,\n+      createArgument: Value,\n+  ): Future[Option[Contract]] =\n+    dispatcher\n+      .executeSql(metrics.daml.index.db.lookupActiveContractWithoutArgumentDbMetrics) {\n+        implicit connection =>\n+          SQL\"select participant_contracts.contract_id, template_id from #$contractsTable where contract_witness = $submitter and participant_contracts.contract_id = $contractId\"\n+            .as(contractWithoutValueRowParser.singleOpt)\n+      }\n+      .map(\n+        _.map(\n+          templateId =>\n+            toContract(\n+              contractId = contractId,\n+              templateId = templateId,\n+              createArgument = createArgument,\n+          )))\n+\n+  override def lookupActiveContract(\n+      submitter: Party,\n+      contractId: ContractId,\n+  ): Future[Option[Contract]] =\n+    // Depending on whether the contract argument is cached or not, submit a different query to the database\n+    translation.cache.getIfPresent(LfValueTranslation.Cache.ContractKey(contractId.coid)) match {\n+      case Some(createArgument) =>\n+        metrics.daml.index.db.lookupActiveContractArgumentCache.hitCount.inc()"
  },
  {
    "id" : "63506a14-8276-4c6b-a156-86aca802dedc",
    "prId" : 6289,
    "comments" : [
      {
        "id" : "1a90b937-23da-49f2-a002-a7159b47e640",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Based on the comment shouldn't this be rather called `lookupActiveContractWithValue` or `lookupActiveContractWithKnownValue` instead?",
        "createdAt" : "2020-06-12T08:24:21Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "89df873e-2905-4511-898c-e5a49e7dc684",
        "parentId" : "1a90b937-23da-49f2-a002-a7159b47e640",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Renamed methods for clarity",
        "createdAt" : "2020-06-15T08:23:54Z",
        "updatedAt" : "2020-06-15T08:23:54Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "271e5962-0d26-4ca7-8b17-bc281158ae12",
        "parentId" : "1a90b937-23da-49f2-a002-a7159b47e640",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Great, thanks!",
        "createdAt" : "2020-06-15T08:38:25Z",
        "updatedAt" : "2020-06-15T08:38:25Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "88fbf388af498692afc5283d2a171d201046eb70",
    "line" : null,
    "diffHunk" : "@@ -55,6 +63,41 @@ private[dao] sealed abstract class ContractsReader(\n           )\n       })\n \n+  /** Lookup of a contract in the case the contract value is already known (loaded from a cache) */\n+  private def lookupActiveContractWithoutArgument("
  },
  {
    "id" : "8ec689e1-6484-44f7-948d-c47461040189",
    "prId" : 6289,
    "comments" : [
      {
        "id" : "f4765dbc-fc4e-4008-85d7-aeb286933479",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "`contractId` parameter is unused here, please remove.",
        "createdAt" : "2020-06-12T08:25:59Z",
        "updatedAt" : "2020-06-15T07:48:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "88fbf388af498692afc5283d2a171d201046eb70",
    "line" : null,
    "diffHunk" : "@@ -135,4 +181,14 @@ object ContractsReader {\n       agreementText = \"\"\n     )\n \n+  private def toContract(\n+      contractId: ContractId,"
  },
  {
    "id" : "ea245b47-ec32-4cbe-bb16-3172a1fe7de0",
    "prId" : 5946,
    "comments" : [
      {
        "id" : "601ae29c-23d5-48f9-a220-758a10dc4379",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n            translationTimer = metrics.daml.index.db.lookupActiveContractDao.translationTimer,\r\n```",
        "createdAt" : "2020-05-13T07:24:38Z",
        "updatedAt" : "2020-05-13T14:44:33Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2c0312e0-73a0-4a48-9eb3-8fce23a56457",
        "parentId" : "601ae29c-23d5-48f9-a220-758a10dc4379",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I made the name generic to adapt to both sides, but when used I think it makes more time to keep the name specific.",
        "createdAt" : "2020-05-13T15:06:40Z",
        "updatedAt" : "2020-05-13T15:06:40Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e88f58ce119f393cede12d4bb759ad24582b1a06",
    "line" : 6,
    "diffHunk" : "@@ -50,8 +50,7 @@ private[dao] sealed abstract class ContractsReader(\n             contractId = contractId,\n             templateId = templateId,\n             createArgument = createArgument,\n-            deserializationTimer =\n-              metrics.daml.index.db.lookupActiveContractDao.deserializationTimer,\n+            deserializationTimer = metrics.daml.index.db.lookupActiveContractDao.translationTimer,"
  },
  {
    "id" : "cac3bd1a-8e8c-4c0d-acee-07c4b501b741",
    "prId" : 5917,
    "comments" : [
      {
        "id" : "954dc778-f549-4486-a238-0641f937d4ec",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Make this a method.",
        "createdAt" : "2020-05-08T17:52:32Z",
        "updatedAt" : "2020-05-08T18:55:14Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "41bfaad3-efc8-4f9e-8b15-74229ec58e25",
        "parentId" : "954dc778-f549-4486-a238-0641f937d4ec",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5917/commits/c2ee9e27e1fc976d0af7cb44885493f46602400e",
        "createdAt" : "2020-05-08T18:55:26Z",
        "updatedAt" : "2020-05-08T18:55:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b924b0df2cdd7cf19f2aa64e3afdcc719f4fc149",
    "line" : null,
    "diffHunk" : "@@ -22,20 +24,41 @@ private[dao] sealed abstract class ContractsReader(\n     val committedContracts: PostCommitValidationData,\n     dispatcher: DbDispatcher,\n     executionContext: ExecutionContext,\n+    metrics: Metrics,\n ) extends ContractStore {\n \n   import ContractsReader._\n \n+  private val lookupActiveContract = \"lookup_active_contract\"\n+\n+  private val lookupActiveContractDeserializationTimer =\n+    metrics.daml.index.db.deserialization(lookupActiveContract)\n+\n   protected def lookupContractKeyQuery(submitter: Party, key: Key): SimpleSql[Row]\n \n   override def lookupActiveContract(\n       submitter: Party,\n       contractId: ContractId,\n   ): Future[Option[Contract]] =\n-    dispatcher.executeSql(\"lookup_active_contract\") { implicit connection =>\n-      SQL\"select participant_contracts.contract_id, template_id, create_argument from #$contractsTable where contract_witness = $submitter and participant_contracts.contract_id = $contractId\"\n-        .as(contractRowParser.singleOpt)\n-    }\n+    dispatcher\n+      .executeSql(lookupActiveContract) { implicit connection =>\n+        SQL\"select participant_contracts.contract_id, template_id, create_argument from #$contractsTable where contract_witness = $submitter and participant_contracts.contract_id = $contractId\"\n+          .as(contractRowParser.singleOpt)\n+      }\n+      .map(_.map {\n+        case (templateId, createArgument) =>\n+          Contract(\n+            template = Identifier.assertFromString(templateId),\n+            arg = Timed.value(\n+              lookupActiveContractDeserializationTimer,\n+              deserialize(\n+                stream = createArgument,\n+                errorContext = s\"Failed to deserialize create argument for contract $contractId\",\n+              ),\n+            ),\n+            agreementText = \"\"\n+          )"
  },
  {
    "id" : "e901b062-6308-4395-9fff-938404233978",
    "prId" : 5541,
    "comments" : [
      {
        "id" : "a6607c50-06a8-43ad-aba2-0d9ba567d5ce",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "So I was going to make the suggestion below, before I found out that `contractsTable` is actually a join. Could you help me understand the motivation for that instead of putting the join into this query string directly?\r\n```suggestion\r\n      SQL\"select #$contractsTable.contract_id, template_id, create_argument from #$contractsTable where contract_witness = $submitter and #$contractsTable.contract_id = $contractId\"\r\n```",
        "createdAt" : "2020-04-16T07:51:28Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f644c0a8-f109-4f2d-8b1d-663a7eea764a",
        "parentId" : "a6607c50-06a8-43ad-aba2-0d9ba567d5ce",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "To make the query a bit shorter and not spell out the join twice.",
        "createdAt" : "2020-04-16T09:13:29Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fdfb5b7f-ea00-4f18-824e-85f25d2767e9",
        "parentId" : "a6607c50-06a8-43ad-aba2-0d9ba567d5ce",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Hm, I'm not sure the brevity is worth it tbh. I'd rather see a full page of query text rather than having to do mental dictionary lookups to the side.\r\nBut if this is the pattern we've been following so far (and I suspect it is), then let's continue with it.",
        "createdAt" : "2020-04-16T09:40:01Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2034352017063fbc2c958c5a086273e66ed0ad47",
    "line" : 33,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import java.time.Instant\n+\n+import anorm.SqlParser.{binaryStream, int, str}\n+import anorm.{Row, RowParser, SimpleSql, SqlStringInterpolation, ~}\n+import com.daml.ledger.participant.state.index.v2.ContractStore\n+import com.daml.platform.store.Conversions._\n+import com.daml.platform.store.{DbType, dao}\n+import com.daml.platform.store.dao.{DbDispatcher, events}\n+import com.daml.platform.store.serialization.KeyHasher.{hashKey => hash}\n+import com.daml.platform.store.serialization.ValueSerializer.{deserializeValue => deserialize}\n+\n+import scala.concurrent.Future\n+\n+/**\n+  * @see [[ContractsTable]]\n+  */\n+private[dao] sealed abstract class ContractsReader(dispatcher: DbDispatcher) extends ContractStore {\n+\n+  import ContractsReader._\n+\n+  protected def lookupContractKeyQuery(submitter: Party, key: dao.events.Key): SimpleSql[Row]\n+\n+  override def lookupActiveContract(\n+      submitter: Party,\n+      contractId: ContractId,\n+  ): Future[Option[Contract]] =\n+    dispatcher.executeSql(\"lookup_active_contract\") { implicit connection =>\n+      SQL\"select participant_contracts.contract_id, template_id, create_argument from #$contractsTable where contract_witness = $submitter and participant_contracts.contract_id = $contractId\""
  },
  {
    "id" : "27b9a14f-3fc0-4490-94f4-26751c8c4cb5",
    "prId" : 5541,
    "comments" : [
      {
        "id" : "136224f0-31fb-4fa2-9a4d-ac88fda4f5d6",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I wasn't sure whether this was actually true and wanted to confirm that. unfortunately you won't like the result :sob:\r\n`agreement` is a function that can be invoked during interpretation:\r\n![image](https://user-images.githubusercontent.com/29121423/79431181-5c7c6900-7fca-11ea-9b17-017fcca0db50.png)\r\n",
        "createdAt" : "2020-04-16T08:10:26Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5f360bd7-d23a-48d5-a56e-bec9e6e9fbb4",
        "parentId" : "136224f0-31fb-4fa2-9a4d-ac88fda4f5d6",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Then I'm a bit concerned that this didn't make any test fail.",
        "createdAt" : "2020-04-16T09:13:49Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "55f743dc-c473-4cc6-8f40-84118501614f",
        "parentId" : "136224f0-31fb-4fa2-9a4d-ac88fda4f5d6",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Good point. Looks like we don't have a test that uses the agreement text inside an exercise I suppose. Could you add one please?",
        "createdAt" : "2020-04-16T09:36:07Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "465c7856-2738-426a-950d-fcd3d70bc3c2",
        "parentId" : "136224f0-31fb-4fa2-9a4d-ac88fda4f5d6",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I was wrong in my assessment. The `agreement` expression is reified in the DAML LF template definition, and calling `agreement` in a choice body re-evaluates that expression. There is no need to store the agreement text together with the contract instance for the purpose of command interpretation.",
        "createdAt" : "2020-04-17T11:20:28Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2034352017063fbc2c958c5a086273e66ed0ad47",
    "line" : 84,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import java.time.Instant\n+\n+import anorm.SqlParser.{binaryStream, int, str}\n+import anorm.{Row, RowParser, SimpleSql, SqlStringInterpolation, ~}\n+import com.daml.ledger.participant.state.index.v2.ContractStore\n+import com.daml.platform.store.Conversions._\n+import com.daml.platform.store.{DbType, dao}\n+import com.daml.platform.store.dao.{DbDispatcher, events}\n+import com.daml.platform.store.serialization.KeyHasher.{hashKey => hash}\n+import com.daml.platform.store.serialization.ValueSerializer.{deserializeValue => deserialize}\n+\n+import scala.concurrent.Future\n+\n+/**\n+  * @see [[ContractsTable]]\n+  */\n+private[dao] sealed abstract class ContractsReader(dispatcher: DbDispatcher) extends ContractStore {\n+\n+  import ContractsReader._\n+\n+  protected def lookupContractKeyQuery(submitter: Party, key: dao.events.Key): SimpleSql[Row]\n+\n+  override def lookupActiveContract(\n+      submitter: Party,\n+      contractId: ContractId,\n+  ): Future[Option[Contract]] =\n+    dispatcher.executeSql(\"lookup_active_contract\") { implicit connection =>\n+      SQL\"select participant_contracts.contract_id, template_id, create_argument from #$contractsTable where contract_witness = $submitter and participant_contracts.contract_id = $contractId\"\n+        .as(contractRowParser.singleOpt)\n+    }\n+  override def lookupContractKey(\n+      submitter: Party,\n+      key: events.Key,\n+  ): Future[Option[events.ContractId]] =\n+    dispatcher.executeSql(\"lookup_contract_by_key\") { implicit connection =>\n+      lookupContractKeyQuery(submitter, key).as(contractId(\"contract_id\").singleOpt)\n+    }\n+\n+  override def lookupMaximumLedgerTime(ids: Set[ContractId]): Future[Option[Instant]] =\n+    if (ids.isEmpty) {\n+      Future.failed(emptyContractIds)\n+    } else {\n+      dispatcher.executeSql(\"lookup_maximum_ledger_time\") { implicit connection =>\n+        SQL\"select max(create_ledger_effective_time) as max_create_ledger_effective_time, count(*) as num_contracts from participant_contracts where participant_contracts.contract_id in ($ids)\"\n+          .as((instant(\"max_create_ledger_effective_time\").? ~ int(\"num_contracts\")).single.map {\n+            case result ~ retrievedContracts if retrievedContracts == ids.size => result\n+            case _ => throw notFound(ids)\n+          })\n+      }\n+    }\n+\n+}\n+\n+object ContractsReader {\n+\n+  private[dao] def apply(dispatcher: DbDispatcher, dbType: DbType): ContractsReader =\n+    dbType match {\n+      case DbType.Postgres => new Postgresql(dispatcher)\n+      case DbType.H2Database => new H2Database(dispatcher)\n+    }\n+\n+  private final class Postgresql(dispatcher: DbDispatcher) extends ContractsReader(dispatcher) {\n+    override protected def lookupContractKeyQuery(\n+        submitter: Party,\n+        key: events.Key,\n+    ): SimpleSql[Row] =\n+      SQL\"select participant_contracts.contract_id from #$contractsTable where $submitter =ANY(create_stakeholders) and contract_witness = $submitter and create_key_hash = ${hash(key)}\"\n+  }\n+\n+  private final class H2Database(dispatcher: DbDispatcher) extends ContractsReader(dispatcher) {\n+    override protected def lookupContractKeyQuery(\n+        submitter: Party,\n+        key: events.Key,\n+    ): SimpleSql[Row] =\n+      SQL\"select participant_contracts.contract_id from #$contractsTable where array_contains(create_stakeholders, $submitter) and contract_witness = $submitter and create_key_hash = ${hash(key)}\"\n+  }\n+\n+  // The contracts table _does not_ store agreement texts as they are\n+  // unnecessary for interpretation and validation. The contracts returned"
  },
  {
    "id" : "1fee5d3f-c75c-4b0c-8e45-d8e204618355",
    "prId" : 5541,
    "comments" : [
      {
        "id" : "723afc30-14c7-4399-aee0-153ba756fba9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I hope the `binaryStream` won't bite us with H2 again.",
        "createdAt" : "2020-04-16T08:11:41Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "032ac050-c605-4131-89a9-ca4e11ddfd3f",
        "parentId" : "723afc30-14c7-4399-aee0-153ba756fba9",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Rather than hoping, I'll convert this to a `byteArray`, thanks for raising this.",
        "createdAt" : "2020-04-16T09:14:27Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2034352017063fbc2c958c5a086273e66ed0ad47",
    "line" : 87,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao.events\n+\n+import java.time.Instant\n+\n+import anorm.SqlParser.{binaryStream, int, str}\n+import anorm.{Row, RowParser, SimpleSql, SqlStringInterpolation, ~}\n+import com.daml.ledger.participant.state.index.v2.ContractStore\n+import com.daml.platform.store.Conversions._\n+import com.daml.platform.store.{DbType, dao}\n+import com.daml.platform.store.dao.{DbDispatcher, events}\n+import com.daml.platform.store.serialization.KeyHasher.{hashKey => hash}\n+import com.daml.platform.store.serialization.ValueSerializer.{deserializeValue => deserialize}\n+\n+import scala.concurrent.Future\n+\n+/**\n+  * @see [[ContractsTable]]\n+  */\n+private[dao] sealed abstract class ContractsReader(dispatcher: DbDispatcher) extends ContractStore {\n+\n+  import ContractsReader._\n+\n+  protected def lookupContractKeyQuery(submitter: Party, key: dao.events.Key): SimpleSql[Row]\n+\n+  override def lookupActiveContract(\n+      submitter: Party,\n+      contractId: ContractId,\n+  ): Future[Option[Contract]] =\n+    dispatcher.executeSql(\"lookup_active_contract\") { implicit connection =>\n+      SQL\"select participant_contracts.contract_id, template_id, create_argument from #$contractsTable where contract_witness = $submitter and participant_contracts.contract_id = $contractId\"\n+        .as(contractRowParser.singleOpt)\n+    }\n+  override def lookupContractKey(\n+      submitter: Party,\n+      key: events.Key,\n+  ): Future[Option[events.ContractId]] =\n+    dispatcher.executeSql(\"lookup_contract_by_key\") { implicit connection =>\n+      lookupContractKeyQuery(submitter, key).as(contractId(\"contract_id\").singleOpt)\n+    }\n+\n+  override def lookupMaximumLedgerTime(ids: Set[ContractId]): Future[Option[Instant]] =\n+    if (ids.isEmpty) {\n+      Future.failed(emptyContractIds)\n+    } else {\n+      dispatcher.executeSql(\"lookup_maximum_ledger_time\") { implicit connection =>\n+        SQL\"select max(create_ledger_effective_time) as max_create_ledger_effective_time, count(*) as num_contracts from participant_contracts where participant_contracts.contract_id in ($ids)\"\n+          .as((instant(\"max_create_ledger_effective_time\").? ~ int(\"num_contracts\")).single.map {\n+            case result ~ retrievedContracts if retrievedContracts == ids.size => result\n+            case _ => throw notFound(ids)\n+          })\n+      }\n+    }\n+\n+}\n+\n+object ContractsReader {\n+\n+  private[dao] def apply(dispatcher: DbDispatcher, dbType: DbType): ContractsReader =\n+    dbType match {\n+      case DbType.Postgres => new Postgresql(dispatcher)\n+      case DbType.H2Database => new H2Database(dispatcher)\n+    }\n+\n+  private final class Postgresql(dispatcher: DbDispatcher) extends ContractsReader(dispatcher) {\n+    override protected def lookupContractKeyQuery(\n+        submitter: Party,\n+        key: events.Key,\n+    ): SimpleSql[Row] =\n+      SQL\"select participant_contracts.contract_id from #$contractsTable where $submitter =ANY(create_stakeholders) and contract_witness = $submitter and create_key_hash = ${hash(key)}\"\n+  }\n+\n+  private final class H2Database(dispatcher: DbDispatcher) extends ContractsReader(dispatcher) {\n+    override protected def lookupContractKeyQuery(\n+        submitter: Party,\n+        key: events.Key,\n+    ): SimpleSql[Row] =\n+      SQL\"select participant_contracts.contract_id from #$contractsTable where array_contains(create_stakeholders, $submitter) and contract_witness = $submitter and create_key_hash = ${hash(key)}\"\n+  }\n+\n+  // The contracts table _does not_ store agreement texts as they are\n+  // unnecessary for interpretation and validation. The contracts returned\n+  // from this table will _always_ have an empty agreement text.\n+  private val contractRowParser: RowParser[Contract] =\n+    str(\"contract_id\") ~ str(\"template_id\") ~ binaryStream(\"create_argument\") map {"
  }
]