[
  {
    "id" : "c8c0c6b7-a692-4bbe-bf41-b3e58f00900f",
    "prId" : 4885,
    "comments" : [
      {
        "id" : "0643490c-1e75-47fd-89fa-f8ff525edb04",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Can we add some curly braces here please?",
        "createdAt" : "2020-03-09T09:19:27Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d577304e-dc72-40d8-a79a-03604c08e836",
        "parentId" : "0643490c-1e75-47fd-89fa-f8ff525edb04",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Thanks. Addressed in 7c1c9299b.",
        "createdAt" : "2020-03-09T09:55:55Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "96a369b3afd668ff924abde055ac20086b2d1fba",
    "line" : null,
    "diffHunk" : "@@ -143,7 +154,8 @@ object TransactionConversion {\n     val (replaced, roots) =\n       tx.roots.foldLeft((false, IndexedSeq.empty[EventId])) {\n         case ((replaced, roots), eventId) =>\n-          if (disclosure.contains(eventId)) (replaced, roots :+ eventId)\n+          if (isCreateOrExercise(tx.nodes(eventId)) && disclosure.contains(eventId))"
  },
  {
    "id" : "40b1f331-ece4-4689-a622-61d4b0a0c79e",
    "prId" : 4885,
    "comments" : [
      {
        "id" : "cb2c7489-a935-42fa-989f-5143a5e9c1f8",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "No action to be taken here as well, but in the process of tightening the loop we are creating more and more convenience functions that could probably be made part of an allocation-free implicit value type (like `EventOps` and `TreeEventOps`) as they will come in handy along the way to keep the code tidy while not needlessly creating intermediate objects.",
        "createdAt" : "2020-03-09T10:26:27Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8f9b5b3b-d797-4961-a7dd-5391e94b429f",
        "parentId" : "cb2c7489-a935-42fa-989f-5143a5e9c1f8",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Not sure what you're saying. This doesn't create an intermediary object though. Or do you mean we should keep this sort of convenience function in `EventOps`?",
        "createdAt" : "2020-03-09T10:38:02Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ae85361e-01d1-436f-8242-265eb27140a4",
        "parentId" : "cb2c7489-a935-42fa-989f-5143a5e9c1f8",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Actually in this case the method doesn't operate on ledger api events, but on the daml lf transaction nodes.",
        "createdAt" : "2020-03-09T10:43:43Z",
        "updatedAt" : "2020-03-09T10:43:43Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "96a369b3afd668ff924abde055ac20086b2d1fba",
    "line" : 12,
    "diffHunk" : "@@ -119,9 +120,17 @@ object TransactionConversion {\n         }\n     ).filter(_.nonEmpty)\n \n+  private def isCreateOrExercise(n: Node): Boolean = {"
  },
  {
    "id" : "5b9016f4-7cee-4027-a58e-8b7e0cc97305",
    "prId" : 4763,
    "comments" : [
      {
        "id" : "cd706e7f-fff0-4800-a5ad-1aaa006e9af8",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "`Seq.empty` is just `Nil` in disguise. If you dislike the usage of `:::` further down below, we should rather switch explicitly to `Vector`.",
        "createdAt" : "2020-03-02T08:32:15Z",
        "updatedAt" : "2020-03-02T12:38:29Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "604aea2e-8540-4181-8083-fe41a3dfd8be",
        "parentId" : "cd706e7f-fff0-4800-a5ad-1aaa006e9af8",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I had to turn everything to `Seq` instead of `List` because it's what used in the API types.",
        "createdAt" : "2020-03-02T10:46:24Z",
        "updatedAt" : "2020-03-02T12:38:29Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "084f83f6a7e9794c09cd508e4c4c0898039e0bea",
    "line" : 166,
    "diffHunk" : "@@ -3,206 +3,233 @@\n \n package com.digitalasset.platform.index\n \n+import com.digitalasset.api.util.TimestampConversion\n import com.digitalasset.daml.lf.engine\n import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, VersionedValue}\n import com.digitalasset.daml.lf.value.{Value => Lf}\n+import com.digitalasset.ledger\n import com.digitalasset.ledger.api.domain\n-import com.digitalasset.ledger.api.domain.Event.{CreateOrArchiveEvent, CreateOrExerciseEvent}\n+import com.digitalasset.ledger.api.v1.event.Event.Event.{Archived, Created}\n+import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event, ExercisedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.{Transaction, TransactionTree, TreeEvent}\n+import com.digitalasset.platform.api.v1.event.EventOps.TreeEventOps\n import com.digitalasset.platform.common.PlatformTypes.{CreateEvent, ExerciseEvent}\n-import com.digitalasset.platform.participant.util.EventFilter\n-import com.digitalasset.platform.participant.util.EventFilter.TemplateAwareFilter\n+import com.digitalasset.platform.participant.util.LfEngineToApi\n import com.digitalasset.platform.server.services.transaction.TransactionFiltration.RichTransactionFilter\n import com.digitalasset.platform.server.services.transaction.TransientContractRemover\n import com.digitalasset.platform.store.entries.LedgerEntry\n-import scalaz.Tag\n \n import scala.annotation.tailrec\n-import scala.collection.breakOut\n \n-trait TransactionConversion {\n+object TransactionConversion {\n \n-  def ledgerEntryToDomainFlat(\n+  def ledgerEntryToFlatTransaction(\n       offset: domain.LedgerOffset.Absolute,\n       trans: LedgerEntry.Transaction,\n       filter: domain.TransactionFilter\n-  ): Option[domain.Transaction] = {\n-    val tx = trans.transaction.mapNodeId(domain.EventId(_))\n-    val events = engine.Event\n-      .collectEvents(tx, trans.explicitDisclosure.map { case (k, v) => domain.EventId(k) -> v })\n+  ): Option[Transaction] = {\n+    val events = engine.Event.collectEvents(trans.transaction, trans.explicitDisclosure)\n     val allEvents = events.roots.toSeq\n-      .foldLeft(List.empty[CreateOrArchiveEvent])((l, evId) =>\n-        l ::: flattenEvents(events.events, evId, verbose = true))\n+      .foldLeft(List.empty[Event])((l, evId) =>\n+        l ++ flattenEvents(events.events, evId, verbose = true))\n \n-    val eventFilter = TemplateAwareFilter(filter)\n     val filteredEvents = TransientContractRemover\n       .removeTransients(allEvents)\n-      .flatMap(EventFilter.filterCreateOrArchiveWitnesses(eventFilter, _).toList)\n+      .flatMap(EventFilter(_)(filter).toList)\n \n     val submitterIsSubscriber =\n-      trans.submittingParty.exists(eventFilter.isSubmitterSubscriber)\n+      trans.submittingParty.exists(filter.filtersByParty.keySet)\n \n     if (filteredEvents.nonEmpty || submitterIsSubscriber) {\n       Some(\n-        domain.Transaction(\n-          domain.TransactionId(trans.transactionId),\n-          if (submitterIsSubscriber) Tag.subst(trans.commandId) else None,\n-          trans.workflowId.map(domain.WorkflowId(_)),\n-          trans.recordedAt,\n+        Transaction(\n+          trans.transactionId,\n+          trans.commandId.filter(_ => submitterIsSubscriber).getOrElse(\"\"),\n+          trans.workflowId.getOrElse(\"\"),\n+          Some(TimestampConversion.fromInstant(trans.recordedAt)),\n           filteredEvents,\n-          offset,\n-          None\n+          offset.value\n         ))\n     } else None\n   }\n \n-  def ledgerEntryToDomainTree(\n+  def ledgerEntryToTransaction(\n       offset: domain.LedgerOffset.Absolute,\n       trans: LedgerEntry.Transaction,\n-      filter: domain.TransactionFilter): Option[domain.TransactionTree] = {\n+      filter: domain.TransactionFilter): Option[TransactionTree] = {\n \n-    val tx = trans.transaction.mapNodeId(domain.EventId(_))\n+    val tx = trans.transaction\n     filter.filter(tx).map { disclosureByNodeId =>\n       val allEvents = engine.Event\n         .collectEvents(tx, disclosureByNodeId)\n       val events = allEvents.events.map {\n         case (nodeId, value) =>\n-          (nodeId, value match {\n-            case e: ExerciseEvent[domain.EventId, AbsoluteContractId] =>\n-              lfExerciseToDomain(nodeId, e)\n-            case c: CreateEvent[AbsoluteContractId] =>\n-              lfCreateToDomain(nodeId, c, includeParentWitnesses = true)\n+          (nodeId: String, value match {\n+            case e: ExerciseEvent[ledger.EventId @unchecked, AbsoluteContractId @unchecked] =>\n+              lfExerciseToApi(nodeId, e)\n+            case c: CreateEvent[AbsoluteContractId @unchecked] =>\n+              lfCreateToApi(nodeId, c, includeParentWitnesses = true)\n           })\n       }\n \n       val (byId, roots) =\n         removeInvisibleRoots(events, allEvents.roots.toList)\n \n-      val subscriberIsSubmitter =\n-        trans.submittingParty.exists(TemplateAwareFilter(filter).isSubmitterSubscriber)\n-\n-      domain.TransactionTree(\n-        domain.TransactionId(trans.transactionId),\n-        if (subscriberIsSubmitter) Tag.subst(trans.commandId) else None,\n-        Tag.subst(trans.workflowId),\n-        trans.recordedAt,\n-        offset,\n+      val commandId =\n+        trans.commandId\n+          .filter(_ => trans.submittingParty.exists(filter.filtersByParty.keySet))\n+          .getOrElse(\"\")\n+\n+      TransactionTree(\n+        trans.transactionId,\n+        commandId,\n+        trans.workflowId.getOrElse(\"\"),\n+        Some(TimestampConversion.fromInstant(trans.recordedAt)),\n+        offset.value,\n         byId,\n-        roots,\n-        None\n+        roots\n       )\n     }\n   }\n \n   private case class InvisibleRootRemovalState(\n       rootsWereReplaced: Boolean,\n-      eventsById: Map[domain.EventId, CreateOrExerciseEvent],\n-      rootEventIds: List[domain.EventId])\n+      eventsById: Map[String, TreeEvent],\n+      rootEventIds: Seq[String])\n \n   // Remove root nodes that have empty witnesses and put their children in their place as roots.\n   // Do this while there are roots with no witnesses.\n   @tailrec\n   private def removeInvisibleRoots(\n-      eventsById: Map[domain.EventId, CreateOrExerciseEvent],\n-      rootEventIds: List[domain.EventId])\n-    : (Map[domain.EventId, CreateOrExerciseEvent], List[domain.EventId]) = {\n+      eventsById: Map[String, TreeEvent],\n+      rootEventIds: Seq[String]): (Map[String, TreeEvent], Seq[String]) = {\n \n     val result =\n-      rootEventIds.foldRight(InvisibleRootRemovalState(rootsWereReplaced = false, eventsById, Nil)) {\n+      rootEventIds.foldRight(\n+        InvisibleRootRemovalState(rootsWereReplaced = false, eventsById, Seq.empty)) {"
  },
  {
    "id" : "6613e61e-c76d-4370-8cca-92f2853d83ca",
    "prId" : 4763,
    "comments" : [
      {
        "id" : "f7c0c822-43d8-4759-9386-ae275f13a5bf",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should this not use the `verbose` parameter?",
        "createdAt" : "2020-03-02T10:17:34Z",
        "updatedAt" : "2020-03-02T12:38:29Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "08aac855-9285-4f8e-bfd2-d6ddf8089576",
        "parentId" : "f7c0c822-43d8-4759-9386-ae275f13a5bf",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Ah, good catch, thanks.",
        "createdAt" : "2020-03-02T10:45:11Z",
        "updatedAt" : "2020-03-02T12:38:29Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d6bee1dc-6b6f-403f-91cf-1c73db457507",
        "parentId" : "f7c0c822-43d8-4759-9386-ae275f13a5bf",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed in https://github.com/digital-asset/daml/pull/4763/commits/084f83f6a7e9794c09cd508e4c4c0898039e0bea",
        "createdAt" : "2020-03-02T12:41:15Z",
        "updatedAt" : "2020-03-02T12:41:16Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "084f83f6a7e9794c09cd508e4c4c0898039e0bea",
    "line" : null,
    "diffHunk" : "@@ -3,206 +3,240 @@\n \n package com.digitalasset.platform.index\n \n+import com.digitalasset.api.util.TimestampConversion\n import com.digitalasset.daml.lf.engine\n import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, VersionedValue}\n import com.digitalasset.daml.lf.value.{Value => Lf}\n+import com.digitalasset.ledger\n import com.digitalasset.ledger.api.domain\n-import com.digitalasset.ledger.api.domain.Event.{CreateOrArchiveEvent, CreateOrExerciseEvent}\n+import com.digitalasset.ledger.api.v1.event.Event.Event.{Archived, Created}\n+import com.digitalasset.ledger.api.v1.event.{ArchivedEvent, CreatedEvent, Event, ExercisedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.{Transaction, TransactionTree, TreeEvent}\n+import com.digitalasset.platform.api.v1.event.EventOps.TreeEventOps\n import com.digitalasset.platform.common.PlatformTypes.{CreateEvent, ExerciseEvent}\n-import com.digitalasset.platform.participant.util.EventFilter\n-import com.digitalasset.platform.participant.util.EventFilter.TemplateAwareFilter\n+import com.digitalasset.platform.participant.util.LfEngineToApi\n import com.digitalasset.platform.server.services.transaction.TransactionFiltration.RichTransactionFilter\n import com.digitalasset.platform.server.services.transaction.TransientContractRemover\n import com.digitalasset.platform.store.entries.LedgerEntry\n-import scalaz.Tag\n \n import scala.annotation.tailrec\n-import scala.collection.breakOut\n \n-trait TransactionConversion {\n+object TransactionConversion {\n \n-  def ledgerEntryToDomainFlat(\n+  def ledgerEntryToFlatTransaction(\n       offset: domain.LedgerOffset.Absolute,\n       trans: LedgerEntry.Transaction,\n-      filter: domain.TransactionFilter\n-  ): Option[domain.Transaction] = {\n-    val tx = trans.transaction.mapNodeId(domain.EventId(_))\n-    val events = engine.Event\n-      .collectEvents(tx, trans.explicitDisclosure.map { case (k, v) => domain.EventId(k) -> v })\n+      filter: domain.TransactionFilter,\n+      verbose: Boolean,\n+  ): Option[Transaction] = {\n+    val events = engine.Event.collectEvents(trans.transaction, trans.explicitDisclosure)\n     val allEvents = events.roots.toSeq\n-      .foldLeft(List.empty[CreateOrArchiveEvent])((l, evId) =>\n-        l ::: flattenEvents(events.events, evId, verbose = true))\n+      .foldLeft(List.empty[Event])((l, evId) => l ++ flattenEvents(events.events, evId, verbose))\n \n-    val eventFilter = TemplateAwareFilter(filter)\n     val filteredEvents = TransientContractRemover\n       .removeTransients(allEvents)\n-      .flatMap(EventFilter.filterCreateOrArchiveWitnesses(eventFilter, _).toList)\n+      .flatMap(EventFilter(_)(filter).toList)\n \n     val submitterIsSubscriber =\n-      trans.submittingParty.exists(eventFilter.isSubmitterSubscriber)\n+      trans.submittingParty.exists(filter.filtersByParty.keySet)\n \n     if (filteredEvents.nonEmpty || submitterIsSubscriber) {\n       Some(\n-        domain.Transaction(\n-          domain.TransactionId(trans.transactionId),\n-          if (submitterIsSubscriber) Tag.subst(trans.commandId) else None,\n-          trans.workflowId.map(domain.WorkflowId(_)),\n-          trans.recordedAt,\n+        Transaction(\n+          trans.transactionId,\n+          trans.commandId.filter(_ => submitterIsSubscriber).getOrElse(\"\"),\n+          trans.workflowId.getOrElse(\"\"),\n+          Some(TimestampConversion.fromInstant(trans.recordedAt)),\n           filteredEvents,\n-          offset,\n-          None\n+          offset.value\n         ))\n     } else None\n   }\n \n-  def ledgerEntryToDomainTree(\n+  def ledgerEntryToTransaction(\n       offset: domain.LedgerOffset.Absolute,\n       trans: LedgerEntry.Transaction,\n-      filter: domain.TransactionFilter): Option[domain.TransactionTree] = {\n+      filter: domain.TransactionFilter,\n+      verbose: Boolean,\n+  ): Option[TransactionTree] = {\n \n-    val tx = trans.transaction.mapNodeId(domain.EventId(_))\n+    val tx = trans.transaction\n     filter.filter(tx).map { disclosureByNodeId =>\n       val allEvents = engine.Event\n         .collectEvents(tx, disclosureByNodeId)\n       val events = allEvents.events.map {\n         case (nodeId, value) =>\n-          (nodeId, value match {\n-            case e: ExerciseEvent[domain.EventId, AbsoluteContractId] =>\n-              lfExerciseToDomain(nodeId, e)\n-            case c: CreateEvent[AbsoluteContractId] =>\n-              lfCreateToDomain(nodeId, c, includeParentWitnesses = true)\n+          (nodeId: String, value match {\n+            case e: ExerciseEvent[ledger.EventId @unchecked, AbsoluteContractId @unchecked] =>\n+              lfExerciseToApi(nodeId, e, verbose)\n+            case c: CreateEvent[AbsoluteContractId @unchecked] =>\n+              lfCreateToApi(nodeId, c, includeParentWitnesses = true, verbose)\n           })\n       }\n \n       val (byId, roots) =\n         removeInvisibleRoots(events, allEvents.roots.toList)\n \n-      val subscriberIsSubmitter =\n-        trans.submittingParty.exists(TemplateAwareFilter(filter).isSubmitterSubscriber)\n-\n-      domain.TransactionTree(\n-        domain.TransactionId(trans.transactionId),\n-        if (subscriberIsSubmitter) Tag.subst(trans.commandId) else None,\n-        Tag.subst(trans.workflowId),\n-        trans.recordedAt,\n-        offset,\n+      val commandId =\n+        trans.commandId\n+          .filter(_ => trans.submittingParty.exists(filter.filtersByParty.keySet))\n+          .getOrElse(\"\")\n+\n+      TransactionTree(\n+        trans.transactionId,\n+        commandId,\n+        trans.workflowId.getOrElse(\"\"),\n+        Some(TimestampConversion.fromInstant(trans.recordedAt)),\n+        offset.value,\n         byId,\n-        roots,\n-        None\n+        roots\n       )\n     }\n   }\n \n   private case class InvisibleRootRemovalState(\n       rootsWereReplaced: Boolean,\n-      eventsById: Map[domain.EventId, CreateOrExerciseEvent],\n-      rootEventIds: List[domain.EventId])\n+      eventsById: Map[String, TreeEvent],\n+      rootEventIds: Seq[String])\n \n   // Remove root nodes that have empty witnesses and put their children in their place as roots.\n   // Do this while there are roots with no witnesses.\n   @tailrec\n   private def removeInvisibleRoots(\n-      eventsById: Map[domain.EventId, CreateOrExerciseEvent],\n-      rootEventIds: List[domain.EventId])\n-    : (Map[domain.EventId, CreateOrExerciseEvent], List[domain.EventId]) = {\n+      eventsById: Map[String, TreeEvent],\n+      rootEventIds: Seq[String]): (Map[String, TreeEvent], Seq[String]) = {\n \n     val result =\n-      rootEventIds.foldRight(InvisibleRootRemovalState(rootsWereReplaced = false, eventsById, Nil)) {\n+      rootEventIds.foldRight(\n+        InvisibleRootRemovalState(rootsWereReplaced = false, eventsById, Seq.empty)) {\n         case (eventId, InvisibleRootRemovalState(hasInvisibleRoot, filteredEvents, newRoots)) =>\n           val event = eventsById\n             .getOrElse(\n               eventId,\n               throw new IllegalArgumentException(\n                 s\"Root event id $eventId is not present among transaction nodes ${eventsById.keySet}\"))\n           if (event.witnessParties.nonEmpty)\n-            InvisibleRootRemovalState(hasInvisibleRoot, filteredEvents, eventId :: newRoots)\n+            InvisibleRootRemovalState(hasInvisibleRoot, filteredEvents, eventId +: newRoots)\n           else\n             InvisibleRootRemovalState(\n               rootsWereReplaced = true,\n               filteredEvents - eventId,\n-              event.children ::: newRoots)\n+              event.childEventIds ++ newRoots)\n       }\n     if (result.rootsWereReplaced)\n       removeInvisibleRoots(result.eventsById, result.rootEventIds)\n     else (result.eventsById, result.rootEventIds)\n   }\n \n-  private def lfCreateToDomain(\n-      eventId: domain.EventId,\n-      create: CreateEvent[Lf.AbsoluteContractId],\n+  private def lfCreateToApiCreate(\n+      eventId: String,\n+      create: CreateEvent[AbsoluteContractId],\n       includeParentWitnesses: Boolean,\n-  ): domain.Event.CreatedEvent = {\n-    domain.Event.CreatedEvent(\n+      verbose: Boolean) = {\n+    CreatedEvent(\n       eventId,\n-      domain.ContractId(create.contractId.coid),\n-      create.templateId,\n-      create.argument.value match {\n-        case rec @ Lf.ValueRecord(_, _) => rec\n-        case _ => throw new RuntimeException(s\"Value is not an record.\")\n-      },\n-      if (includeParentWitnesses) create.witnesses\n-      else create.stakeholders,\n-      create.signatories,\n-      create.observers,\n-      create.agreementText,\n-      create.contractKey.map(_.key.value)\n+      create.contractId.coid,\n+      Some(LfEngineToApi.toApiIdentifier(create.templateId)),\n+      create.contractKey.map(\n+        ck =>\n+          LfEngineToApi.assertOrRuntimeEx(\n+            \"translating the contract key\",\n+            LfEngineToApi\n+              .lfValueToApiValue(verbose, ck.key.value))),\n+      Some(\n+        LfEngineToApi\n+          .lfValueToApiRecord(verbose = true, create.argument.value match {"
  }
]