[
  {
    "id" : "9cd74c18-3272-44d6-851f-824ec4662dcc",
    "prId" : 6612,
    "comments" : [
      {
        "id" : "c8acb5c2-65fd-4b4d-8d85-eaef5a3b97f4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I assume the order doesnâ€™t matter here or is there a reason why you swapped `nidCreate` and `nestedExercise`?",
        "createdAt" : "2020-07-06T10:01:54Z",
        "updatedAt" : "2020-07-06T10:23:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d7902db6-0b49-4bf9-9308-c0494dc1113b",
        "parentId" : "c8acb5c2-65fd-4b4d-8d85-eaef5a3b97f4",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "It's relevant for readability, pushing a fix.",
        "createdAt" : "2020-07-06T10:08:22Z",
        "updatedAt" : "2020-07-06T10:23:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ecf8dc38-4c4f-469a-b89c-b45f2ae1496f",
        "parentId" : "c8acb5c2-65fd-4b4d-8d85-eaef5a3b97f4",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6612/commits/c35fa284c8e3c5836a113b5da1cd34a84d795109",
        "createdAt" : "2020-07-06T10:10:06Z",
        "updatedAt" : "2020-07-06T10:23:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8516d8b5fd1f6e8616b9e89e1f3242d2f19a1a39",
    "line" : null,
    "diffHunk" : "@@ -6,129 +6,143 @@ package com.daml.platform.store.dao\n import java.time.Instant\n import java.util.UUID\n \n-import com.daml.lf.crypto\n import com.daml.lf.data.{ImmArray, Ref}\n+import com.daml.ledger.EventId\n+import com.daml.lf.transaction.GenTransaction\n import com.daml.lf.transaction.Node.{KeyWithMaintainers, NodeCreate, NodeExercises, NodeFetch}\n-import com.daml.lf.transaction.{Transaction => Tx}\n-import com.daml.lf.value.Value.{ContractId, ContractInst, ValueParty, VersionedValue}\n-import com.daml.lf.value.ValueVersion\n+import com.daml.lf.value.Value.{ContractId, ValueParty, ValueRecord, VersionedValue}\n import com.daml.lf.value.ValueVersions\n-import com.daml.platform.store.dao.events.TransactionBuilder\n import com.daml.platform.store.entries.LedgerEntry\n import org.scalatest.{AsyncFlatSpec, Inside, LoneElement, Matchers}\n \n+import scala.collection.immutable.HashMap\n+\n private[dao] trait JdbcLedgerDaoDivulgenceSpec extends LoneElement with Inside {\n   this: AsyncFlatSpec with Matchers with JdbcLedgerDaoSuite =>\n \n+  private final val someVersionedCreateArg = VersionedValue(\n+    ValueVersions.acceptedVersions.head,\n+    ValueRecord(\n+      Some(someRecordId),\n+      ImmArray(Some(Ref.Name.assertFromString(\"field\")) -> someValueText)))\n+\n   behavior of \"JdbcLedgerDao (divulgence)\"\n \n   it should \"preserve divulged contracts\" in {\n     val (create1, tx1) = {\n-      val builder = new TransactionBuilder\n-      val contractId = toCid(\"cid1\")\n-      builder.add(\n-        NodeCreate(\n-          coid = contractId,\n-          coinst = someContractInstance,\n-          optLocation = None,\n-          signatories = Set(alice),\n-          stakeholders = Set(alice),\n-          key = None\n-        )\n+      val nid = EventId.assertFromString(\"#0:0\")\n+      val cid = ContractId.assertFromString(\"#contract1\")\n+      val tx: GenTransaction.WithTxValue[EventId, ContractId] = GenTransaction(\n+        nodes = HashMap(\n+          nid ->\n+            NodeCreate(\n+              coid = cid,\n+              coinst = someContractInstance,\n+              optLocation = None,\n+              signatories = Set(alice),\n+              stakeholders = Set(alice),\n+              key = None\n+            )\n+        ),\n+        roots = ImmArray(nid),\n       )\n-      contractId -> builder.build()\n+      cid -> tx\n     }\n     val (create2, tx2) = {\n-      val builder = new TransactionBuilder\n-      val contractId = toCid(\"cid2\")\n-      builder.add(\n-        NodeCreate(\n-          coid = contractId,\n-          coinst = someContractInstance,\n-          optLocation = None,\n-          signatories = Set(bob),\n-          stakeholders = Set(bob),\n-          key = Some(\n-            KeyWithMaintainers(VersionedValue(ValueVersions.acceptedVersions.head, ValueParty(bob)), Set(bob))\n+      val nid = EventId.assertFromString(\"#1:0\")\n+      val cid = ContractId.assertFromString(\"#contract2\")\n+      val tx: GenTransaction.WithTxValue[EventId, ContractId] = GenTransaction(\n+        nodes = HashMap(\n+          nid -> NodeCreate[ContractId, VersionedValue[ContractId]](\n+            coid = cid,\n+            coinst = someContractInstance,\n+            optLocation = None,\n+            signatories = Set(bob),\n+            stakeholders = Set(bob),\n+            key = Some(\n+              KeyWithMaintainers(\n+                VersionedValue(ValueVersions.acceptedVersions.head, ValueParty(bob)),\n+                Set(bob))\n+            )\n           )\n-        )\n-      )\n-      contractId -> builder.build()\n-    }\n-    val tx3 = {\n-      val builder = new TransactionBuilder\n-      val rootExercise = builder.add(\n-        NodeExercises(\n-          targetCoid = create1,\n-          templateId = someTemplateId,\n-          choiceId = Ref.ChoiceName.assertFromString(\"SomeChoice\"),\n-          optLocation = None,\n-          consuming = true,\n-          actingParties = Set(bob),\n-          chosenValue = VersionedValue(ValueVersions.acceptedVersions.head, someValueRecord),\n-          stakeholders = Set(alice, bob),\n-          signatories = Set(alice),\n-          children = ImmArray.empty,\n-          exerciseResult = None,\n-          key = None,\n-        )\n-      )\n-      builder.add(\n-        NodeFetch(\n-          coid = create2,\n-          templateId = someTemplateId,\n-          optLocation = None,\n-          actingParties = Some(Set(bob)),\n-          signatories = Set(bob),\n-          stakeholders = Set(bob),\n-          key = Some(\n-            KeyWithMaintainers(VersionedValue(ValueVersions.acceptedVersions.head, ValueParty(bob)), Set(bob))\n-          ),\n-        ),\n-        parent = rootExercise,\n-      )\n-      val nestedExercise = builder.add(\n-        NodeExercises(\n-          targetCoid = create2,\n-          templateId = someTemplateId,\n-          choiceId = Ref.ChoiceName.assertFromString(\"SomeChoice\"),\n-          optLocation = None,\n-          consuming = true,\n-          actingParties = Set(bob),\n-          chosenValue = VersionedValue(ValueVersions.acceptedVersions.head, someValueRecord),\n-          stakeholders = Set(bob),\n-          signatories = Set(bob),\n-          children = ImmArray.empty,\n-          exerciseResult = None,\n-          key = Some(\n-            KeyWithMaintainers(VersionedValue(ValueVersions.acceptedVersions.head, ValueParty(bob)), Set(bob))\n-          ),\n         ),\n-        parent = rootExercise,\n+        roots = ImmArray(nid)\n       )\n-      builder.add(\n-        NodeCreate(\n-          coid = toCid(\"cid3\"),\n-          coinst = someContractInstance,\n-          optLocation = None,\n-          signatories = Set(bob),\n-          stakeholders = Set(alice, bob),\n-          key = Some(\n-            KeyWithMaintainers(VersionedValue(ValueVersions.acceptedVersions.head, ValueParty(bob)), Set(bob))\n-          )\n+      cid -> tx\n+    }\n+    val tx3: GenTransaction.WithTxValue[EventId, ContractId] = {\n+      val nidRootExercise = EventId.assertFromString(\"#2:0\")\n+      val nidFetch = EventId.assertFromString(\"#2:1\")\n+      val nidNestedExercise = EventId.assertFromString(\"#2:2\")\n+      val nidCreate = EventId.assertFromString(\"#2:3\")\n+      val cid = ContractId.assertFromString(\"#contract3\")\n+      GenTransaction(\n+        nodes = HashMap(\n+          nidRootExercise ->\n+            NodeExercises[EventId, ContractId, VersionedValue[ContractId]](\n+              targetCoid = create1,\n+              templateId = someTemplateId,\n+              choiceId = Ref.ChoiceName.assertFromString(\"SomeChoice\"),\n+              optLocation = None,\n+              consuming = true,\n+              actingParties = Set(bob),\n+              chosenValue = someVersionedCreateArg,\n+              stakeholders = Set(alice, bob),\n+              signatories = Set(alice),\n+              children = ImmArray(nidFetch, nidNestedExercise),\n+              exerciseResult = None,\n+              key = None,\n+            ),\n+          nidFetch ->\n+            NodeFetch[ContractId, VersionedValue[ContractId]](\n+              coid = create2,\n+              templateId = someTemplateId,\n+              optLocation = None,\n+              actingParties = Some(Set(bob)),\n+              signatories = Set(bob),\n+              stakeholders = Set(bob),\n+              key = Some(\n+                KeyWithMaintainers(\n+                  VersionedValue(ValueVersions.acceptedVersions.head, ValueParty(bob)),\n+                  Set(bob))\n+              ),\n+            ),\n+          nidCreate ->"
  },
  {
    "id" : "bfd01b71-8e1d-45bb-8e15-e8ad61fc3b91",
    "prId" : 6607,
    "comments" : [
      {
        "id" : "963131f4-9a81-48f3-bf47-dd81ed3af761",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Is `nestedExercise` missing the parent assignment?",
        "createdAt" : "2020-07-04T19:39:36Z",
        "updatedAt" : "2020-07-04T19:52:47Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "db86f6ef-8c05-451a-bf22-bd9d09b48e65",
        "parentId" : "963131f4-9a81-48f3-bf47-dd81ed3af761",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6607/commits/e64699148e955152ef4f31e54b1cb964b1c50fea",
        "createdAt" : "2020-07-04T19:53:18Z",
        "updatedAt" : "2020-07-04T19:53:18Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "070f7dd7949de123f813e57eec30911c7f400f3e",
    "line" : 88,
    "diffHunk" : "@@ -0,0 +1,182 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao\n+\n+import java.time.Instant\n+import java.util.UUID\n+\n+import com.daml.lf.data.{ImmArray, Ref}\n+import com.daml.lf.transaction.Node.{KeyWithMaintainers, NodeCreate, NodeExercises, NodeFetch}\n+import com.daml.lf.transaction.test.TransactionBuilder\n+import com.daml.lf.transaction.{Transaction => Tx}\n+import com.daml.lf.value.Value.{ContractInst, ValueParty, VersionedValue}\n+import com.daml.lf.value.ValueVersion\n+import com.daml.platform.store.entries.LedgerEntry\n+import org.scalatest.{AsyncFlatSpec, Inside, LoneElement, Matchers}\n+\n+private[dao] trait JdbcLedgerDaoDivulgenceSpec extends LoneElement with Inside {\n+  this: AsyncFlatSpec with Matchers with JdbcLedgerDaoSuite =>\n+\n+  behavior of \"JdbcLedgerDao (divulgence)\"\n+\n+  it should \"preserve divulged contracts\" in {\n+    val (create1, tx1) = {\n+      val builder = new TransactionBuilder\n+      val contractId = builder.newCid\n+      builder.add(\n+        NodeCreate(\n+          coid = contractId,\n+          coinst = someContractInstance,\n+          optLocation = None,\n+          signatories = Set(alice),\n+          stakeholders = Set(alice),\n+          key = None\n+        )\n+      )\n+      contractId -> Tx.CommittedTransaction(builder.build())\n+    }\n+    val (create2, tx2) = {\n+      val builder = new TransactionBuilder\n+      val contractId = builder.newCid\n+      builder.add(\n+        NodeCreate(\n+          coid = contractId,\n+          coinst = someContractInstance,\n+          optLocation = None,\n+          signatories = Set(bob),\n+          stakeholders = Set(bob),\n+          key = Some(\n+            KeyWithMaintainers(ValueParty(bob), Set(bob))\n+          )\n+        )\n+      )\n+      contractId -> Tx.CommittedTransaction(builder.build())\n+    }\n+    val tx3 = {\n+      val builder = new TransactionBuilder\n+      val rootExercise = builder.add(\n+        NodeExercises(\n+          targetCoid = create1,\n+          templateId = someTemplateId,\n+          choiceId = Ref.ChoiceName.assertFromString(\"SomeChoice\"),\n+          optLocation = None,\n+          consuming = true,\n+          actingParties = Set(bob),\n+          chosenValue = someValueRecord,\n+          stakeholders = Set(alice, bob),\n+          signatories = Set(alice),\n+          children = ImmArray.empty,\n+          exerciseResult = None,\n+          key = None,\n+        )\n+      )\n+      builder.add(\n+        NodeFetch(\n+          coid = create2,\n+          templateId = someTemplateId,\n+          optLocation = None,\n+          actingParties = Some(Set(bob)),\n+          signatories = Set(bob),\n+          stakeholders = Set(bob),\n+          key = Some(\n+            KeyWithMaintainers(ValueParty(bob), Set(bob))\n+          ),\n+        ),\n+        parent = rootExercise,\n+      )\n+      val nestedExercise = builder.add("
  },
  {
    "id" : "b2c88798-d9cb-4fe6-b86c-807f241e586c",
    "prId" : 6607,
    "comments" : [
      {
        "id" : "3c19a301-48f7-4912-b19b-fbe2afd71745",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The fetch node that is doing the divulgence fetches `create2`. Should this be used here as well?",
        "createdAt" : "2020-07-04T19:41:27Z",
        "updatedAt" : "2020-07-04T19:52:47Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "462e4252-1aee-4a17-b09b-b1239f56cdaa",
        "parentId" : "3c19a301-48f7-4912-b19b-fbe2afd71745",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6607/commits/070f7dd7949de123f813e57eec30911c7f400f3e",
        "createdAt" : "2020-07-04T19:53:28Z",
        "updatedAt" : "2020-07-04T19:53:29Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "070f7dd7949de123f813e57eec30911c7f400f3e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,182 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.platform.store.dao\n+\n+import java.time.Instant\n+import java.util.UUID\n+\n+import com.daml.lf.data.{ImmArray, Ref}\n+import com.daml.lf.transaction.Node.{KeyWithMaintainers, NodeCreate, NodeExercises, NodeFetch}\n+import com.daml.lf.transaction.test.TransactionBuilder\n+import com.daml.lf.transaction.{Transaction => Tx}\n+import com.daml.lf.value.Value.{ContractInst, ValueParty, VersionedValue}\n+import com.daml.lf.value.ValueVersion\n+import com.daml.platform.store.entries.LedgerEntry\n+import org.scalatest.{AsyncFlatSpec, Inside, LoneElement, Matchers}\n+\n+private[dao] trait JdbcLedgerDaoDivulgenceSpec extends LoneElement with Inside {\n+  this: AsyncFlatSpec with Matchers with JdbcLedgerDaoSuite =>\n+\n+  behavior of \"JdbcLedgerDao (divulgence)\"\n+\n+  it should \"preserve divulged contracts\" in {\n+    val (create1, tx1) = {\n+      val builder = new TransactionBuilder\n+      val contractId = builder.newCid\n+      builder.add(\n+        NodeCreate(\n+          coid = contractId,\n+          coinst = someContractInstance,\n+          optLocation = None,\n+          signatories = Set(alice),\n+          stakeholders = Set(alice),\n+          key = None\n+        )\n+      )\n+      contractId -> Tx.CommittedTransaction(builder.build())\n+    }\n+    val (create2, tx2) = {\n+      val builder = new TransactionBuilder\n+      val contractId = builder.newCid\n+      builder.add(\n+        NodeCreate(\n+          coid = contractId,\n+          coinst = someContractInstance,\n+          optLocation = None,\n+          signatories = Set(bob),\n+          stakeholders = Set(bob),\n+          key = Some(\n+            KeyWithMaintainers(ValueParty(bob), Set(bob))\n+          )\n+        )\n+      )\n+      contractId -> Tx.CommittedTransaction(builder.build())\n+    }\n+    val tx3 = {\n+      val builder = new TransactionBuilder\n+      val rootExercise = builder.add(\n+        NodeExercises(\n+          targetCoid = create1,\n+          templateId = someTemplateId,\n+          choiceId = Ref.ChoiceName.assertFromString(\"SomeChoice\"),\n+          optLocation = None,\n+          consuming = true,\n+          actingParties = Set(bob),\n+          chosenValue = someValueRecord,\n+          stakeholders = Set(alice, bob),\n+          signatories = Set(alice),\n+          children = ImmArray.empty,\n+          exerciseResult = None,\n+          key = None,\n+        )\n+      )\n+      builder.add(\n+        NodeFetch(\n+          coid = create2,\n+          templateId = someTemplateId,\n+          optLocation = None,\n+          actingParties = Some(Set(bob)),\n+          signatories = Set(bob),\n+          stakeholders = Set(bob),\n+          key = Some(\n+            KeyWithMaintainers(ValueParty(bob), Set(bob))\n+          ),\n+        ),\n+        parent = rootExercise,\n+      )\n+      val nestedExercise = builder.add(\n+        NodeExercises(\n+          targetCoid = create2,\n+          templateId = someTemplateId,\n+          choiceId = Ref.ChoiceName.assertFromString(\"SomeChoice\"),\n+          optLocation = None,\n+          consuming = true,\n+          actingParties = Set(bob),\n+          chosenValue = someValueRecord,\n+          stakeholders = Set(bob),\n+          signatories = Set(bob),\n+          children = ImmArray.empty,\n+          exerciseResult = None,\n+          key = Some(\n+            KeyWithMaintainers(ValueParty(bob), Set(bob))\n+          ),\n+        )\n+      )\n+      builder.add(\n+        NodeCreate(\n+          coid = builder.newCid,\n+          coinst = someContractInstance,\n+          optLocation = None,\n+          signatories = Set(bob),\n+          stakeholders = Set(alice, bob),\n+          key = Some(\n+            KeyWithMaintainers(ValueParty(bob), Set(bob))\n+          )\n+        ),\n+        parent = nestedExercise,\n+      )\n+      Tx.CommittedTransaction(builder.build())\n+    }\n+\n+    val someVersionedContractInstance =\n+      ContractInst(\n+        template = someContractInstance.template,\n+        agreementText = someContractInstance.agreementText,\n+        arg = VersionedValue(\n+          version = ValueVersion(\"6\"),\n+          value = someContractInstance.arg\n+        )\n+      )\n+\n+    val t1 = Instant.now()\n+    val t2 = t1.plusMillis(1)\n+    val t3 = t2.plusMillis(1)\n+    val appId = UUID.randomUUID.toString\n+    for {\n+      _ <- store(\n+        nextOffset() -> LedgerEntry.Transaction(\n+          commandId = Some(UUID.randomUUID.toString),\n+          transactionId = UUID.randomUUID.toString,\n+          applicationId = Some(appId),\n+          submittingParty = Some(alice),\n+          workflowId = None,\n+          ledgerEffectiveTime = t1,\n+          recordedAt = t1,\n+          transaction = tx1,\n+          explicitDisclosure = Map.empty,\n+        )\n+      )\n+      _ <- store(\n+        nextOffset() -> LedgerEntry.Transaction(\n+          commandId = Some(UUID.randomUUID.toString),\n+          transactionId = UUID.randomUUID.toString,\n+          applicationId = Some(appId),\n+          submittingParty = Some(bob),\n+          workflowId = None,\n+          ledgerEffectiveTime = t2,\n+          recordedAt = t2,\n+          transaction = tx2,\n+          explicitDisclosure = Map.empty,\n+        )\n+      )\n+      _ <- store(\n+        divulgedContracts = Map((create1, someVersionedContractInstance) -> Set(alice)),"
  }
]