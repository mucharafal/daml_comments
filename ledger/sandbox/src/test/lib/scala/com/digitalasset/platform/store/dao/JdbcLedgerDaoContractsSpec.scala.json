[
  {
    "id" : "6c412fc6-715c-4e09-b627-1b5e53c25431",
    "prId" : 5541,
    "comments" : [
      {
        "id" : "27636a38-fdeb-4df9-85f6-73c0d6cc8cfa",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "This can probably be compared to the `ledgerEffectiveTime` of `tx`.",
        "createdAt" : "2020-04-15T12:44:49Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3ae8de0f-4ca2-4a01-b607-1c1dabbb78b4",
        "parentId" : "27636a38-fdeb-4df9-85f6-73c0d6cc8cfa",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/5541/commits/abfc4cf353d52e71cce74396ea958554f7f06b30",
        "createdAt" : "2020-04-15T12:59:46Z",
        "updatedAt" : "2020-04-17T19:02:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2034352017063fbc2c958c5a086273e66ed0ad47",
    "line" : null,
    "diffHunk" : "@@ -4,78 +4,90 @@\n package com.daml.platform.store.dao\n \n import java.time.Instant\n+import java.util.UUID\n \n-import com.daml.lf.data.Ref.Party\n-import com.daml.lf.data.{ImmArray, Ref}\n-import com.daml.lf.transaction.GenTransaction\n-import com.daml.lf.transaction.Node.{KeyWithMaintainers, NodeCreate}\n-import com.daml.lf.value.Value.{AbsoluteContractId, ValueText, VersionedValue}\n-import com.daml.lf.value.ValueVersions\n-import com.daml.platform.store.PersistenceEntry\n-import com.daml.platform.store.entries.LedgerEntry\n-import org.scalatest.{AsyncFlatSpec, Matchers}\n+import com.daml.lf.value.Value.AbsoluteContractId\n+import org.scalatest.{AsyncFlatSpec, Inside, LoneElement, Matchers}\n \n-import scala.collection.immutable.HashMap\n-\n-private[dao] trait JdbcLedgerDaoContractsSpec {\n+private[dao] trait JdbcLedgerDaoContractsSpec extends LoneElement with Inside {\n   this: AsyncFlatSpec with Matchers with JdbcLedgerDaoSuite =>\n \n   behavior of \"JdbcLedgerDao (contracts)\"\n \n   it should \"be able to persist and load contracts\" in {\n-    val offset = nextOffset()\n-    val offsetString = offset.toLong\n-    val absCid = AbsoluteContractId.assertFromString(s\"#cId1-$offsetString\")\n-    val txId = s\"trId-$offsetString\"\n-    val workflowId = s\"workflowId-$offsetString\"\n-    val let = Instant.now\n-    val keyWithMaintainers = KeyWithMaintainers(\n-      VersionedValue(ValueVersions.acceptedVersions.head, ValueText(s\"key-$offsetString\")),\n-      Set(alice)\n-    )\n-    val event1 = event(txId, 1)\n-    val event2 = event(txId, 2)\n+    for {\n+      (_, tx) <- store(singleCreate)\n+      result <- ledgerDao.lookupActiveOrDivulgedContract(nonTransient(tx).loneElement, alice)\n+    } yield {\n+      // The agreement text is always empty when retrieved from the contract store\n+      result shouldEqual Some(someContractInstance.copy(agreementText = \"\"))\n+    }\n+  }\n+\n+  it should \"not find contracts that are not visible to the requester\" in {\n+    for {\n+      (_, tx) <- store(singleCreate)\n+      result <- ledgerDao.lookupActiveOrDivulgedContract(nonTransient(tx).loneElement, charlie)\n+    } yield {\n+      result shouldEqual None\n+    }\n+  }\n+\n+  it should \"prevent retrieving the maximum ledger time if some contracts are not found\" in {\n+    val randomContractId = AbsoluteContractId.assertFromString(s\"#random-${UUID.randomUUID}\")\n+    for {\n+      failure <- ledgerDao.lookupMaximumLedgerTime(Set(randomContractId)).failed\n+    } yield {\n+      failure shouldBe an[IllegalArgumentException]\n+      failure.getMessage should startWith(\n+        \"One or more of the following contract identifiers has been found\"\n+      )\n+    }\n+  }\n \n-    val transaction = LedgerEntry.Transaction(\n-      Some(\"commandId1\"),\n-      txId,\n-      Some(s\"appID-$offsetString\"),\n-      Some(\"Alice\"),\n-      Some(workflowId),\n-      let,\n-      let,\n-      GenTransaction(\n-        HashMap(\n-          event1 -> NodeCreate(\n-            nodeSeed = None,\n-            coid = absCid,\n-            coinst = someContractInstance,\n-            optLocation = None,\n-            signatories = Set(alice, bob),\n-            stakeholders = Set(alice, bob),\n-            key = Some(keyWithMaintainers)\n-          )),\n-        ImmArray(event1),\n-      ),\n-      Map(event1 -> Set[Party](\"Alice\", \"Bob\"), event2 -> Set[Party](\"Alice\", \"In\", \"Chains\"))\n-    )\n+  it should \"allow the retrieval of the maximum ledger time\" in {\n     for {\n-      result1 <- ledgerDao.lookupActiveOrDivulgedContract(absCid, alice)\n-      _ <- ledgerDao.storeLedgerEntry(\n-        offset,\n-        PersistenceEntry.Transaction(\n-          transaction,\n-          Map(\n-            absCid -> Set(Ref.Party.assertFromString(\"Alice\"), Ref.Party.assertFromString(\"Bob\"))),\n-          List.empty\n-        )\n+      (_, tx) <- store(singleCreate)\n+      result <- ledgerDao.lookupMaximumLedgerTime(nonTransient(tx))\n+    } yield {\n+      inside(result) {\n+        case Some(time) => time should be <= Instant.now\n+      }\n+    }\n+  }\n+\n+  it should \"allow the retrieval of the maximum ledger time even when there are divulged contracts\" in {\n+    val divulgedContractId = AbsoluteContractId.assertFromString(s\"#divulged-${UUID.randomUUID}\")\n+    for {\n+      (_, _) <- store(\n+        divulgedContracts = Map(\n+          (divulgedContractId, someContractInstance) -> Set(charlie)\n+        ),\n+        offsetAndTx = singleExercise(divulgedContractId)\n       )\n-      result2 <- ledgerDao.lookupActiveOrDivulgedContract(absCid, alice)\n+      (_, tx) <- store(singleCreate)\n+      contractIds = nonTransient(tx) + divulgedContractId\n+      result <- ledgerDao.lookupMaximumLedgerTime(contractIds)\n     } yield {\n-      result1 shouldEqual None\n-      result2 shouldEqual Some(someContractInstance)\n+      inside(result) {\n+        case Some(time) => time should be <= Instant.now"
  }
]