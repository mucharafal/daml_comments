[
  {
    "id" : "d2ef796f-862b-4170-8e81-cfcf288e2125",
    "prId" : 6751,
    "comments" : [
      {
        "id" : "edfe43f9-578a-46eb-823d-f012f1b5d90c",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "This is type-safe:\r\n\r\n```suggestion\r\n      extractAllTransactions(result) shouldBe empty\r\n```",
        "createdAt" : "2020-07-15T21:00:03Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd313d3fe5c71387852de6eeb3741784b6f50729",
    "line" : null,
    "diffHunk" : "@@ -426,6 +431,74 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n     }\n   }\n \n+  // Test case for #6698\n+  it should \"return empty source when offset range is from the future\" in {\n+    val commands: Vector[(Offset, LedgerEntry.Transaction)] = Vector.fill(3)(singleCreate)\n+    val beginOffsetFromTheFuture = nextOffset();\n+    val endOffsetFromTheFuture = nextOffset()\n+\n+    for {\n+      _ <- commands.traverse(x => store(x))\n+\n+      result <- ledgerDao.transactionsReader\n+        .getFlatTransactions(\n+          beginOffsetFromTheFuture,\n+          endOffsetFromTheFuture,\n+          Map(alice -> Set.empty[Identifier]),\n+          verbose = true)\n+        .runWith(Sink.seq)\n+\n+    } yield {\n+      extractAllTransactions(result) shouldBe Vector.empty[Transaction]"
  },
  {
    "id" : "24efb4eb-ea4f-4c04-8e5e-512a8dc74d3b",
    "prId" : 6751,
    "comments" : [
      {
        "id" : "b9f07067-71fa-476f-9c37-e6798df8084b",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      readTxs = extractAllTransactions(result)\r\n    } yield {\r\n```",
        "createdAt" : "2020-07-15T21:01:41Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd313d3fe5c71387852de6eeb3741784b6f50729",
    "line" : null,
    "diffHunk" : "@@ -426,6 +431,74 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n     }\n   }\n \n+  // Test case for #6698\n+  it should \"return empty source when offset range is from the future\" in {\n+    val commands: Vector[(Offset, LedgerEntry.Transaction)] = Vector.fill(3)(singleCreate)\n+    val beginOffsetFromTheFuture = nextOffset();\n+    val endOffsetFromTheFuture = nextOffset()\n+\n+    for {\n+      _ <- commands.traverse(x => store(x))\n+\n+      result <- ledgerDao.transactionsReader\n+        .getFlatTransactions(\n+          beginOffsetFromTheFuture,\n+          endOffsetFromTheFuture,\n+          Map(alice -> Set.empty[Identifier]),\n+          verbose = true)\n+        .runWith(Sink.seq)\n+\n+    } yield {\n+      extractAllTransactions(result) shouldBe Vector.empty[Transaction]\n+    }\n+  }\n+\n+  it should \"return all transactions in the specified offset range when iterating with pageSize = 2\" in {\n+    val pageSize = 2\n+\n+    def offsetGap(): Vector[(Offset, LedgerEntry.Transaction)] = {\n+      nextOffset()\n+      Vector.empty[(Offset, LedgerEntry.Transaction)]\n+    }\n+\n+    // the order of `nextOffset()` calls is important\n+    val beginOffset = nextOffset()\n+\n+    val commands: Vector[(Offset, LedgerEntry.Transaction)] =\n+      Vector(singleCreate) ++ offsetGap ++\n+        Vector.fill(2)(singleCreate) ++ offsetGap ++\n+        Vector.fill(3)(singleCreate) ++ offsetGap ++ offsetGap ++\n+        Vector.fill(5)(singleCreate)\n+\n+    val endOffset = nextOffset()\n+\n+    commands.size shouldBe 11\n+\n+    for {\n+      _ <- commands.traverse(x => store(x))\n+\n+      ledgerDao2 <- LoggingContext.newLoggingContext { implicit logCtx =>\n+        daoOwner(pageSize).acquire()\n+      }.asFuture\n+\n+      result <- ledgerDao2.transactionsReader\n+        .getFlatTransactions(\n+          beginOffset,\n+          endOffset,\n+          Map(alice -> Set.empty[Identifier]),\n+          verbose = true)\n+        .runWith(Sink.seq)\n+    } yield {\n+      inside(extractAllTransactions(result)) {\n+        case readTxs =>"
  },
  {
    "id" : "ab736ca6-daf5-42d3-b42c-80bd3cd79245",
    "prId" : 6751,
    "comments" : [
      {
        "id" : "c7b7848f-9617-45be-8484-00ffdfe7bc27",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I would discourage linking to an external source. The utility of the test case should be easy to understand from the test case itself. If it already does, an external link or reference is redundant.",
        "createdAt" : "2020-07-16T08:59:55Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd313d3fe5c71387852de6eeb3741784b6f50729",
    "line" : null,
    "diffHunk" : "@@ -426,6 +431,73 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n     }\n   }\n \n+  // Test case for #6698"
  },
  {
    "id" : "ae673c09-edfa-4679-a953-8ebd742fee70",
    "prId" : 6751,
    "comments" : [
      {
        "id" : "9f401201-818a-4062-9c0d-673833f8cb2a",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n    val beginOffsetFromTheFuture = nextOffset()\r\n```",
        "createdAt" : "2020-07-16T09:00:14Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd313d3fe5c71387852de6eeb3741784b6f50729",
    "line" : null,
    "diffHunk" : "@@ -426,6 +431,73 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n     }\n   }\n \n+  // Test case for #6698\n+  it should \"return empty source when offset range is from the future\" in {\n+    val commands: Vector[(Offset, LedgerEntry.Transaction)] = Vector.fill(3)(singleCreate)\n+    val beginOffsetFromTheFuture = nextOffset();"
  },
  {
    "id" : "2a3a9a30-fa63-4599-8811-76dc95603db7",
    "prId" : 6751,
    "comments" : [
      {
        "id" : "3b46b1e7-52d3-44a8-ab94-d881d14a9770",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n  it should \"return all transactions in the specified offset range when iterating with gaps in the offsets assigned to events and a page size that ensures a page ends in such a gap\" in {\r\n```\r\nIs it about the page size, the gaps, or a mix of the two? If the gaps are relevant, it's probably worth mentioning them in the test case description.",
        "createdAt" : "2020-07-16T09:02:00Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd313d3fe5c71387852de6eeb3741784b6f50729",
    "line" : null,
    "diffHunk" : "@@ -426,6 +431,73 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n     }\n   }\n \n+  // Test case for #6698\n+  it should \"return empty source when offset range is from the future\" in {\n+    val commands: Vector[(Offset, LedgerEntry.Transaction)] = Vector.fill(3)(singleCreate)\n+    val beginOffsetFromTheFuture = nextOffset();\n+    val endOffsetFromTheFuture = nextOffset()\n+\n+    for {\n+      _ <- commands.traverse(x => store(x))\n+\n+      result <- ledgerDao.transactionsReader\n+        .getFlatTransactions(\n+          beginOffsetFromTheFuture,\n+          endOffsetFromTheFuture,\n+          Map(alice -> Set.empty[Identifier]),\n+          verbose = true)\n+        .runWith(Sink.seq)\n+\n+    } yield {\n+      extractAllTransactions(result) shouldBe empty\n+    }\n+  }\n+\n+  it should \"return all transactions in the specified offset range when iterating with pageSize = 2\" in {"
  },
  {
    "id" : "7b905035-a369-4624-90ec-6bde87e5acbd",
    "prId" : 6751,
    "comments" : [
      {
        "id" : "68d10848-7a45-40f7-a354-480ac18cd6f0",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n    // Simulates a gap in the offsets assigned to events, as they\r\n    // can be assigned to party allocation, package uploads and\r\n    // configuration updates as well\r\n    def offsetGap(): Vector[(Offset, LedgerEntry.Transaction)] = {\r\n      nextOffset()\r\n      Vector.empty[(Offset, LedgerEntry.Transaction)]\r\n    }\r\n\r\n    // the order of `nextOffset()` calls is important\r\n    val beginOffset = nextOffset()\r\n\r\n    val commands: Vector[(Offset, LedgerEntry.Transaction)] =\r\n      Vector(singleCreate) ++ offsetGap ++\r\n        Vector.fill(2)(singleCreate) ++ offsetGap ++\r\n        Vector.fill(3)(singleCreate) ++ offsetGap ++ offsetGap ++\r\n        Vector.fill(5)(singleCreate)\r\n\r\n    val endOffset = nextOffset()\r\n\r\n    commands.size shouldBe 11\r\n\r\n    for {\r\n      _ <- commands.traverse(x => store(x))\r\n\r\n      ledgerDao <- LoggingContext.newLoggingContext { implicit logCtx =>\r\n        // eventsPageSize = 2 makes sure that a page is delimited\r\n        // by an offset that has is absent from the events table\r\n        daoOwner(eventsPageSize = 2).acquire()\r\n      }.asFuture\r\n\r\n      response <- ledgerDao.transactionsReader\r\n```\r\n1. I don't see another `ledgerDao` in this scope, what does the `2` stand for?\r\n2. `pageSize` is only used in a single place, I think that a named parameter makes it just as explicit without needing to go back to the beginning of the test for reference (or needing to keep track of bindings in your head)\r\n3. I'd recommend adding a comment to make sure the meaning of `offsetGap` is clear\r\n4. I'd recommend adding a comment to make sure that it's clear why `eventsPageSize = 2` makes this a good test case",
        "createdAt" : "2020-07-16T09:06:47Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "91e0351e-2727-4120-8f83-333ee0a0ffc7",
        "parentId" : "68d10848-7a45-40f7-a354-480ac18cd6f0",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "1. there is one ledgerDao in the scope, I wanted to show that this is not the default one.\r\nadding comments all over test is a bad practice, they will get obsolete pretty soon. ",
        "createdAt" : "2020-07-16T12:11:50Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "629c5237-d786-4def-bd73-1a3ae04df1b0",
        "parentId" : "68d10848-7a45-40f7-a354-480ac18cd6f0",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "If you don't want to comment then please find some other way to make the following points clear:\r\n1. why did we choose `eventPageSize` to be equal to 2\r\n2. why are we putting gaps in the events: what do they represent and how are they meaningful\r\n\r\nOtherwise the meaning of the test gets lost and the next person to read it may make wrong decisions with respects of the content of the test, possibly causing regressions.",
        "createdAt" : "2020-07-16T12:49:06Z",
        "updatedAt" : "2020-07-16T13:20:02Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd313d3fe5c71387852de6eeb3741784b6f50729",
    "line" : null,
    "diffHunk" : "@@ -426,6 +431,73 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n     }\n   }\n \n+  // Test case for #6698\n+  it should \"return empty source when offset range is from the future\" in {\n+    val commands: Vector[(Offset, LedgerEntry.Transaction)] = Vector.fill(3)(singleCreate)\n+    val beginOffsetFromTheFuture = nextOffset();\n+    val endOffsetFromTheFuture = nextOffset()\n+\n+    for {\n+      _ <- commands.traverse(x => store(x))\n+\n+      result <- ledgerDao.transactionsReader\n+        .getFlatTransactions(\n+          beginOffsetFromTheFuture,\n+          endOffsetFromTheFuture,\n+          Map(alice -> Set.empty[Identifier]),\n+          verbose = true)\n+        .runWith(Sink.seq)\n+\n+    } yield {\n+      extractAllTransactions(result) shouldBe empty\n+    }\n+  }\n+\n+  it should \"return all transactions in the specified offset range when iterating with pageSize = 2\" in {\n+    val pageSize = 2\n+\n+    def offsetGap(): Vector[(Offset, LedgerEntry.Transaction)] = {\n+      nextOffset()\n+      Vector.empty[(Offset, LedgerEntry.Transaction)]\n+    }\n+\n+    // the order of `nextOffset()` calls is important\n+    val beginOffset = nextOffset()\n+\n+    val commands: Vector[(Offset, LedgerEntry.Transaction)] =\n+      Vector(singleCreate) ++ offsetGap ++\n+        Vector.fill(2)(singleCreate) ++ offsetGap ++\n+        Vector.fill(3)(singleCreate) ++ offsetGap ++ offsetGap ++\n+        Vector.fill(5)(singleCreate)\n+\n+    val endOffset = nextOffset()\n+\n+    commands.size shouldBe 11\n+\n+    for {\n+      _ <- commands.traverse(x => store(x))\n+\n+      ledgerDao2 <- LoggingContext.newLoggingContext { implicit logCtx =>\n+        daoOwner(pageSize).acquire()\n+      }.asFuture\n+\n+      response <- ledgerDao2.transactionsReader"
  },
  {
    "id" : "47ce567a-4b36-45f4-aa1f-a2062eedd42d",
    "prId" : 5305,
    "comments" : [
      {
        "id" : "fe613bbc-7129-4db8-bdcb-cfa2646ac3ea",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Was this moved somehwere else?",
        "createdAt" : "2020-03-31T14:42:41Z",
        "updatedAt" : "2020-03-31T15:02:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5e39b5f2-c7cb-44d3-87d6-0e05fb1b7e89",
        "parentId" : "fe613bbc-7129-4db8-bdcb-cfa2646ac3ea",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Not really, the initialization of `eventsPageSize` has been moved to the data access object, which is initialized by the test suite. I would need a second data access object to test this. I thought of ways in which I could make this happen but then I realized I was basically testing `PaginatingAsyncStream` and `groupContiguous`. Let me know if you're ok to drop this.",
        "createdAt" : "2020-03-31T14:47:12Z",
        "updatedAt" : "2020-03-31T15:02:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c5099b7aadf381bd236b3cebf806dc55e7aeceb2",
    "line" : 12,
    "diffHunk" : "@@ -135,40 +135,13 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n             startExclusive = from,\n             endInclusive = to,\n             filter = Map(alice -> Set.empty, bob -> Set.empty, charlie -> Set.empty),\n-            pageSize = 100,\n             verbose = true,\n           ))\n     } yield {\n       comparable(result) should contain theSameElementsInOrderAs comparable(lookups)\n     }\n   }\n \n-  it should \"return the same result regardless of the page size\" in {"
  },
  {
    "id" : "235c35f5-eb41-4174-8ca0-6fe2b9d146f9",
    "prId" : 5285,
    "comments" : [
      {
        "id" : "d5c57e09-cbbf-4eb2-870b-729b573f58af",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n  it should \"return the same result regardless of the page size\" in {\r\n```",
        "createdAt" : "2020-03-31T07:44:42Z",
        "updatedAt" : "2020-03-31T08:44:05Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e26ca711868bcb2f98d3b48bc163c39c7b02dbc",
    "line" : null,
    "diffHunk" : "@@ -113,14 +123,313 @@ private[dao] trait JdbcLedgerDaoTransactionsSpec extends OptionValues with Insid\n     }\n   }\n \n-  it should \"hide a full transaction if all contracts are transient and the request does not come from the original submitter\" in {\n+  behavior of \"JdbcLedgerDao (getFlatTransactions)\"\n+\n+  it should \"match the results of lookupFlatTransactionById\" in {\n     for {\n-      (_, tx) <- store(fullyTransient)\n-      result <- ledgerDao.transactionsReader\n-        .lookupFlatTransactionById(tx.transactionId, Set(bob))\n+      (from, to, transactions) <- storeTestFixture()\n+      lookups <- lookupIndividually(transactions, Set(alice, bob, charlie))\n+      result <- transactionsOf(\n+        ledgerDao.transactionsReader\n+          .getFlatTransactions(\n+            startExclusive = from,\n+            endInclusive = to,\n+            filter = Map(alice -> Set.empty, bob -> Set.empty, charlie -> Set.empty),\n+            pageSize = 100,\n+            verbose = true,\n+          ))\n     } yield {\n-      result shouldBe None\n+      comparable(result) should contain theSameElementsInOrderAs comparable(lookups)\n+    }\n+  }\n+\n+  it should \"return the same result regardless the page size\" in {"
  }
]