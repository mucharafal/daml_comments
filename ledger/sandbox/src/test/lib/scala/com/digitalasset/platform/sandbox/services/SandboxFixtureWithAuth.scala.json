[
  {
    "id" : "4d0cae47-70c4-452c-ab40-a3f381e6ecc3",
    "prId" : 3598,
    "comments" : [
      {
        "id" : "c330cdb8-98dc-4d3b-8924-a901a2426311",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Isn't this handled by `SingleItemObserver`?",
        "createdAt" : "2019-11-22T19:57:07Z",
        "updatedAt" : "2019-11-25T22:18:48Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "96d1831f-d237-476b-b4ea-2638d65da8d5",
        "parentId" : "c330cdb8-98dc-4d3b-8924-a901a2426311",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "You're absolutely right, thanks.",
        "createdAt" : "2019-11-25T10:31:29Z",
        "updatedAt" : "2019-11-25T22:18:48Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1684a0e5-b1b6-4bbf-ac4d-2545dccdf482",
        "parentId" : "c330cdb8-98dc-4d3b-8924-a901a2426311",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/commit/e9f6274f26d54fa9fddc1941a4a9be751287e5ca",
        "createdAt" : "2019-11-25T10:34:19Z",
        "updatedAt" : "2019-11-25T22:18:48Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0861fc99c196c4f679d95440b2795fcd3c2e404c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,131 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.services\n+\n+import java.time.{Duration, Instant}\n+import java.util.UUID\n+\n+import com.digitalasset.grpc.{GrpcException, GrpcStatus}\n+import com.digitalasset.jwt.domain.DecodedJwt\n+import com.digitalasset.jwt.{HMAC256Verifier, JwtSigner}\n+import com.digitalasset.ledger.api.auth.{AuthServiceJWT, AuthServiceJWTCodec, AuthServiceJWTPayload}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.api.v1.transaction_filter.{Filters, TransactionFilter}\n+import com.digitalasset.ledger.client.auth.LedgerClientCallCredentials.authenticatingStub\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import io.grpc.Status\n+import io.grpc.stub.{AbstractStub, StreamObserver}\n+import org.scalatest.Suite\n+import scalaz.syntax.tag.ToTagOps\n+\n+import scala.concurrent.{Future, Promise}\n+\n+trait SandboxFixtureWithAuth extends SandboxFixture { self: Suite =>\n+\n+  protected def stub[A <: AbstractStub[A]](stub: A, token: Option[String]): A =\n+    token.fold(stub)(authenticatingStub(stub))\n+\n+  override protected def config: SandboxConfig =\n+    super.config.copy(\n+      authService = Some(\n+        AuthServiceJWT(HMAC256Verifier(jwtSecret)\n+          .getOrElse(sys.error(\"Failed to create HMAC256 verifier\")))))\n+\n+  protected def roToken(party: String) = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = false,\n+    actAs = Nil,\n+    readAs = List(party)\n+  )\n+\n+  protected def rwToken(party: String) = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = false,\n+    actAs = List(party),\n+    readAs = List(party)\n+  )\n+\n+  protected def adminToken = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = true,\n+    actAs = List(),\n+    readAs = List()\n+  )\n+\n+  protected lazy val wrappedLedgerId = ledgerId(Some(adminToken.asHeader()))\n+  protected lazy val unwrappedLedgerId = wrappedLedgerId.unwrap\n+\n+  private val jwtHeader = \"\"\"{\"alg\": \"HS256\", \"typ\": \"JWT\"}\"\"\"\n+  private val jwtSecret = UUID.randomUUID.toString\n+\n+  implicit protected class AuthServiceJWTPayloadExtensions(payload: AuthServiceJWTPayload) {\n+    def expiresIn(t: java.time.Duration): AuthServiceJWTPayload =\n+      payload.copy(exp = Some(Instant.now.plus(t)))\n+    def expiresInFiveSeconds: AuthServiceJWTPayload = expiresIn(Duration.ofSeconds(5))\n+    def expiresTomorrow: AuthServiceJWTPayload = expiresIn(Duration.ofDays(1))\n+    def expired: AuthServiceJWTPayload = expiresIn(Duration.ofDays(-1))\n+\n+    private def signed(secret: String): String =\n+      JwtSigner.HMAC256\n+        .sign(DecodedJwt(jwtHeader, AuthServiceJWTCodec.compactPrint(payload)), secret)\n+        .getOrElse(sys.error(\"Failed to generate token\"))\n+        .value\n+\n+    def asHeader(secret: String = jwtSecret) = s\"Bearer ${signed(secret)}\"\n+  }\n+\n+  /** Returns a future that fails iff the first event coming from the stream is itself a failure. */\n+  protected def streamResult[T](fn: StreamObserver[T] => Unit): Future[Unit] = {\n+    val promise = Promise[Unit]()\n+    fn(new StreamObserver[T] {\n+      def onNext(value: T): Unit = {\n+        val _ = promise.trySuccess(())\n+      }\n+      def onError(t: Throwable): Unit = {\n+        val _ = promise.tryFailure(t)\n+      }\n+      def onCompleted(): Unit = {\n+        val _ = promise.trySuccess(())\n+      }\n+    })\n+    promise.future\n+  }"
  },
  {
    "id" : "42d3fe33-c2a3-4acd-94f0-728a19401d3f",
    "prId" : 3598,
    "comments" : [
      {
        "id" : "798b730d-4a73-403d-a67a-dfe136ec9dcc",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "From a recent PR (https://github.com/digital-asset/daml/pull/3548/files#diff-f00a01a83ce733d3a2bf7e966718eb3dR105):\r\n```scala\r\n    def readonly(): AuthServiceJWTPayload =\r\n      payload.copy(readAs = payload.actAs ++ payload.readAs, actAs = List.empty)\r\n```\r\n\r\nWould replace the need for `rwToken` and `roToken`.",
        "createdAt" : "2019-11-25T13:28:03Z",
        "updatedAt" : "2019-11-25T22:18:48Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0861fc99c196c4f679d95440b2795fcd3c2e404c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,120 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.services\n+\n+import java.time.{Duration, Instant}\n+import java.util.UUID\n+\n+import com.digitalasset.grpc.{GrpcException, GrpcStatus}\n+import com.digitalasset.jwt.domain.DecodedJwt\n+import com.digitalasset.jwt.{HMAC256Verifier, JwtSigner}\n+import com.digitalasset.ledger.api.auth.{AuthServiceJWT, AuthServiceJWTCodec, AuthServiceJWTPayload}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.api.v1.transaction_filter.{Filters, TransactionFilter}\n+import com.digitalasset.ledger.client.auth.LedgerClientCallCredentials.authenticatingStub\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.digitalasset.platform.testing.SingleItemObserver\n+import io.grpc.Status\n+import io.grpc.stub.{AbstractStub, StreamObserver}\n+import org.scalatest.Suite\n+import scalaz.syntax.tag.ToTagOps\n+\n+import scala.concurrent.{ExecutionContext, Future, Promise}\n+\n+trait SandboxFixtureWithAuth extends SandboxFixture { self: Suite =>\n+\n+  protected def stub[A <: AbstractStub[A]](stub: A, token: Option[String]): A =\n+    token.fold(stub)(authenticatingStub(stub))\n+\n+  override protected def config: SandboxConfig =\n+    super.config.copy(\n+      authService = Some(\n+        AuthServiceJWT(HMAC256Verifier(jwtSecret)\n+          .getOrElse(sys.error(\"Failed to create HMAC256 verifier\")))))\n+\n+  protected def roToken(party: String) = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = false,\n+    actAs = Nil,\n+    readAs = List(party)\n+  )\n+\n+  protected def rwToken(party: String) = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = false,\n+    actAs = List(party),\n+    readAs = List(party)\n+  )\n+\n+  protected def adminToken = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = true,\n+    actAs = List(),\n+    readAs = List()\n+  )\n+\n+  protected lazy val wrappedLedgerId = ledgerId(Some(adminToken.asHeader()))\n+  protected lazy val unwrappedLedgerId = wrappedLedgerId.unwrap\n+\n+  private val jwtHeader = \"\"\"{\"alg\": \"HS256\", \"typ\": \"JWT\"}\"\"\"\n+  private val jwtSecret = UUID.randomUUID.toString\n+\n+  implicit protected class AuthServiceJWTPayloadExtensions(payload: AuthServiceJWTPayload) {\n+    def expiresIn(t: java.time.Duration): AuthServiceJWTPayload ="
  }
]