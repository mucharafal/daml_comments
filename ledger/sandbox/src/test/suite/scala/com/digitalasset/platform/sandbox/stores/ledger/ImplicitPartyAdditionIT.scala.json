[
  {
    "id" : "a5f03cdf-3c90-4458-8d27-4854c5f8cdf5",
    "prId" : 5232,
    "comments" : [
      {
        "id" : "7769021b-d4f1-4866-af81-3d15a69f10e8",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Perhaps a comment explaining why we use this version?",
        "createdAt" : "2020-03-30T07:41:34Z",
        "updatedAt" : "2020-03-30T12:47:37Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b9ed322c-f347-4c72-a3fb-3aa9dba19f8a",
        "parentId" : "7769021b-d4f1-4866-af81-3d15a69f10e8",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "In fact such piece of code should never use explicit version. \r\nShould call `ValueVersions.assignVersion`.\r\n\r\nfixed",
        "createdAt" : "2020-03-30T09:59:55Z",
        "updatedAt" : "2020-03-30T12:47:37Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c6abb1ddeaaaca45f76e15787825b533f45f1d7",
    "line" : null,
    "diffHunk" : "@@ -183,7 +183,7 @@ object ImplicitPartyAdditionIT {\n   )\n \n   private def textValue(t: String) =\n-    VersionedValue(ValueVersions.acceptedVersions.head, ValueText(t))\n+    VersionedValue(ValueVersion(\"5\"), ValueText(t))"
  },
  {
    "id" : "defe5ded-66fe-4a0a-bd4c-0478ec7d727f",
    "prId" : 5086,
    "comments" : [
      {
        "id" : "c1541094-4a63-4f9e-9f53-bb0c12a34838",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "IntelliJ likes to complain when you don't add type annotations to non-private variables. These three caused warnings, which was annoying.",
        "createdAt" : "2020-03-19T13:37:02Z",
        "updatedAt" : "2020-03-19T13:37:22Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9d1b1b66c734bed39a23915de3614e618ba21b97",
    "line" : 88,
    "diffHunk" : "@@ -95,44 +70,6 @@ class ImplicitPartyAdditionIT\n     }\n   }\n \n-  private def publishSingleNodeTx(\n-      ledger: Ledger,\n-      submitter: String,\n-      commandId: String,\n-      node: Transaction.AbsNode,\n-  ): Future[SubmissionResult] = {\n-    val event1: Transaction.NodeId = Transaction.NodeId(0)\n-\n-    val let = Time.Timestamp.assertFromInstant(LET)\n-\n-    val transaction: Transaction.AbsTransaction = GenTransaction(\n-      HashMap(event1 -> node),\n-      ImmArray(event1),\n-    )\n-\n-    val submitterInfo = SubmitterInfo(\n-      Ref.Party.assertFromString(submitter),\n-      Ref.LedgerString.assertFromString(\"appId\"),\n-      Ref.LedgerString.assertFromString(commandId),\n-      Time.Timestamp.assertFromInstant(MRT),\n-      DeduplicateUntil,\n-    )\n-\n-    val transactionMeta = TransactionMeta(\n-      ledgerEffectiveTime = let,\n-      workflowId = Some(Ref.LedgerString.assertFromString(\"wfid\")),\n-      submissionTime = let.addMicros(1000),\n-      submissionSeed = None,\n-      optUsedPackages = None,\n-    )\n-\n-    ledger.publishTransaction(submitterInfo, transactionMeta, transaction)\n-  }\n-\n-  val LET = Instant.EPOCH.plusSeconds(10)\n-  val MRT = Instant.EPOCH.plusSeconds(10)\n-  val DeduplicateUntil = Instant.now.plusSeconds(3600)"
  },
  {
    "id" : "ce288088-ae50-4dfb-8c79-6b6d8986571e",
    "prId" : 1452,
    "comments" : [
      {
        "id" : "0bd7717e-0dad-414f-a9da-8b43cf8d6170",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Can you add cases for the other `GenNode` types as well?",
        "createdAt" : "2019-06-07T11:41:36Z",
        "updatedAt" : "2019-06-07T21:22:35Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a3174db4-3ea4-4633-886e-f359c3ac7664",
        "parentId" : "0bd7717e-0dad-414f-a9da-8b43cf8d6170",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Added a test case for `NodeFetch`. `NodeLookupByKey` should not (and does not, in the current implementation) add any new parties.",
        "createdAt" : "2019-06-07T21:38:10Z",
        "updatedAt" : "2019-06-07T21:38:10Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "21be6910a5debd0672b0db0815d8993c33b21e53",
    "line" : 157,
    "diffHunk" : "@@ -0,0 +1,187 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores.ledger\n+\n+import java.time.Instant\n+\n+import akka.stream.scaladsl.Sink\n+import com.daml.ledger.participant.state.v2.{SubmissionResult, SubmitterInfo, TransactionMeta}\n+import com.digitalasset.api.util.TimeProvider\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.data.{ImmArray, Ref}\n+import com.digitalasset.daml.lf.transaction.Node.{\n+  GenNode,\n+  KeyWithMaintainers,\n+  NodeCreate,\n+  NodeExercises\n+}\n+import com.digitalasset.daml.lf.transaction.Transaction.{NodeId, TContractId, Value}\n+import com.digitalasset.daml.lf.transaction.GenTransaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractInst,\n+  ValueText,\n+  VersionedValue\n+}\n+import com.digitalasset.daml.lf.value.ValueVersions\n+import com.digitalasset.ledger.api.testing.utils.{\n+  AkkaBeforeAndAfterAll,\n+  Resource,\n+  SuiteResourceManagementAroundEach\n+}\n+import com.digitalasset.platform.sandbox.{LedgerResource, MetricsAround}\n+import com.digitalasset.platform.testing.MultiResourceBase\n+import org.scalatest.concurrent.{AsyncTimeLimitedTests, ScalaFutures}\n+import org.scalatest.time.Span\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+import com.digitalasset.ledger.api.domain.LedgerId\n+\n+import scala.concurrent.Future\n+import scala.concurrent.duration._\n+import scala.language.implicitConversions\n+\n+sealed abstract class BackendType\n+\n+object BackendType {\n+\n+  case object InMemory extends BackendType\n+\n+  case object Postgres extends BackendType\n+\n+}\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+class ImplicitPartyAdditionIT\n+    extends AsyncWordSpec\n+    with AkkaBeforeAndAfterAll\n+    with MultiResourceBase[BackendType, Ledger]\n+    with SuiteResourceManagementAroundEach\n+    with AsyncTimeLimitedTests\n+    with ScalaFutures\n+    with Matchers\n+    with MetricsAround {\n+\n+  override def timeLimit: Span = 60.seconds\n+\n+  private val ledgerId: LedgerId = LedgerId(\"ledgerId\")\n+  private val timeProvider = TimeProvider.Constant(Instant.EPOCH.plusSeconds(10))\n+\n+  private val templateId1: Ref.Identifier = Ref.Identifier(\n+    Ref.PackageId.assertFromString(\"packageId\"),\n+    Ref.QualifiedName(\n+      Ref.ModuleName.assertFromString(\"moduleName\"),\n+      Ref.DottedName.assertFromString(\"name\")\n+    )\n+  )\n+\n+  private def textValue(t: String) =\n+    VersionedValue(ValueVersions.acceptedVersions.head, ValueText(t))\n+\n+  /** Overriding this provides an easy way to narrow down testing to a single implementation. */\n+  override protected def fixtureIdsEnabled: Set[BackendType] =\n+    Set(BackendType.InMemory, BackendType.Postgres)\n+\n+  override protected def constructResource(index: Int, fixtureId: BackendType): Resource[Ledger] =\n+    fixtureId match {\n+      case BackendType.InMemory =>\n+        LedgerResource.inMemory(ledgerId, timeProvider)\n+      case BackendType.Postgres =>\n+        LedgerResource.postgres(ledgerId, timeProvider)\n+    }\n+\n+  private def publishSingleNodeTx(\n+      ledger: Ledger,\n+      submitter: String,\n+      commandId: String,\n+      node: GenNode[NodeId, TContractId, Value[TContractId]]): Future[SubmissionResult] = {\n+    val event1: NodeId = NodeId.unsafeFromIndex(0)\n+\n+    val transaction = GenTransaction[NodeId, TContractId, Value[TContractId]](\n+      Map(event1 -> node),\n+      ImmArray(event1),\n+      Set.empty\n+    )\n+\n+    val submitterInfo = SubmitterInfo(\n+      Ref.Party.assertFromString(submitter),\n+      Ref.LedgerString.assertFromString(\"appId\"),\n+      Ref.LedgerString.assertFromString(commandId),\n+      Timestamp.assertFromInstant(MRT)\n+    )\n+\n+    val transactionMeta = TransactionMeta(\n+      Timestamp.assertFromInstant(LET),\n+      Some(Ref.LedgerString.assertFromString(\"wfid\"))\n+    )\n+\n+    ledger.publishTransaction(submitterInfo, transactionMeta, transaction)\n+  }\n+\n+  val LET = Instant.EPOCH.plusSeconds(10)\n+  val MRT = Instant.EPOCH.plusSeconds(10)\n+\n+  \"A Ledger\" should {\n+    \"implicitly add parties mentioned in a transaction\" in allFixtures { ledger =>\n+      for {\n+        createResult <- publishSingleNodeTx(\n+          ledger,\n+          \"create-signatory\",\n+          \"CmdId1\",\n+          NodeCreate(\n+            AbsoluteContractId(\"cId1\"),\n+            ContractInst(\n+              templateId1,\n+              textValue(\"some text\"),\n+              \"agreement\"\n+            ),\n+            None,\n+            Set(\"create-signatory\"),\n+            Set(\"create-stakeholder\"),\n+            Some(KeyWithMaintainers(textValue(\"some text\"), Set(\"create-signatory\")))\n+          )\n+        )\n+        exerciseResult <- publishSingleNodeTx(\n+          ledger,\n+          \"exercise-signatory\",\n+          \"CmdId2\",\n+          NodeExercises(\n+            AbsoluteContractId(\"cId1\"),\n+            templateId1,\n+            Ref.ChoiceName.assertFromString(\"choice\"),\n+            None,\n+            true,\n+            Set(\"exercise-signatory\"),\n+            textValue(\"choice value\"),\n+            Set(\"exercise-stakeholder\"),\n+            Set(\"exercise-signatory\"),\n+            Set(\"exercise-signatory\"),\n+            ImmArray.empty,\n+            None\n+          )\n+        )"
  }
]