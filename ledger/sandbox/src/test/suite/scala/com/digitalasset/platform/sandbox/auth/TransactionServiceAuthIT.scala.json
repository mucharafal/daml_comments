[
  {
    "id" : "1baa1ccc-903e-4588-9f0d-b096879c6410",
    "prId" : 3598,
    "comments" : [
      {
        "id" : "104f0138-d177-4e4b-955f-90f8268f6fba",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The read-only test cases are missing.",
        "createdAt" : "2019-11-25T11:21:38Z",
        "updatedAt" : "2019-11-25T22:18:48Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0861fc99c196c4f679d95440b2795fcd3c2e404c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,257 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.auth\n+\n+import java.util.UUID\n+\n+import com.digitalasset.ledger.api.testing.utils.SuiteResourceManagementAroundAll\n+import com.digitalasset.ledger.api.v1.transaction_service._\n+import com.digitalasset.platform.sandbox.Expect\n+import com.digitalasset.platform.sandbox.services.{\n+  SandboxFixtureWithAuth,\n+  SubmitAndWaitDummyCommand,\n+  TestCommands\n+}\n+import com.digitalasset.timer.Delayed\n+import io.grpc.Status\n+import org.scalatest.{AsyncFlatSpec, Matchers}\n+\n+import scala.concurrent.Future\n+import scala.concurrent.duration.DurationInt\n+\n+final class TransactionServiceAuthIT\n+    extends AsyncFlatSpec\n+    with SandboxFixtureWithAuth\n+    with SuiteResourceManagementAroundAll\n+    with TestCommands\n+    with Matchers\n+    with Expect\n+    with SubmitAndWaitDummyCommand {\n+\n+  override val appId = classOf[TransactionServiceAuthIT].getSimpleName\n+\n+  override val submitter = \"alice\"\n+\n+  private def ledgerEnd(token: Option[String]): Future[GetLedgerEndResponse] =\n+    stub(TransactionServiceGrpc.stub(channel), token)\n+      .getLedgerEnd(new GetLedgerEndRequest(unwrappedLedgerId))\n+\n+  behavior of \"TransactionService#LedgerEnd with authorization\""
  },
  {
    "id" : "a6eff499-3e5b-4a38-b7b5-63a20820146b",
    "prId" : 3598,
    "comments" : [
      {
        "id" : "a45d0528-ce62-49f2-852f-60f38fc4c29a",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This is missing the read-only equivalent.",
        "createdAt" : "2019-11-25T11:23:46Z",
        "updatedAt" : "2019-11-25T22:18:48Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0861fc99c196c4f679d95440b2795fcd3c2e404c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,257 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.auth\n+\n+import java.util.UUID\n+\n+import com.digitalasset.ledger.api.testing.utils.SuiteResourceManagementAroundAll\n+import com.digitalasset.ledger.api.v1.transaction_service._\n+import com.digitalasset.platform.sandbox.Expect\n+import com.digitalasset.platform.sandbox.services.{\n+  SandboxFixtureWithAuth,\n+  SubmitAndWaitDummyCommand,\n+  TestCommands\n+}\n+import com.digitalasset.timer.Delayed\n+import io.grpc.Status\n+import org.scalatest.{AsyncFlatSpec, Matchers}\n+\n+import scala.concurrent.Future\n+import scala.concurrent.duration.DurationInt\n+\n+final class TransactionServiceAuthIT\n+    extends AsyncFlatSpec\n+    with SandboxFixtureWithAuth\n+    with SuiteResourceManagementAroundAll\n+    with TestCommands\n+    with Matchers\n+    with Expect\n+    with SubmitAndWaitDummyCommand {\n+\n+  override val appId = classOf[TransactionServiceAuthIT].getSimpleName\n+\n+  override val submitter = \"alice\"\n+\n+  private def ledgerEnd(token: Option[String]): Future[GetLedgerEndResponse] =\n+    stub(TransactionServiceGrpc.stub(channel), token)\n+      .getLedgerEnd(new GetLedgerEndRequest(unwrappedLedgerId))\n+\n+  behavior of \"TransactionService#LedgerEnd with authorization\"\n+\n+  it should \"deny unauthorized calls\" in {\n+    expect(ledgerEnd(None)).toBeDenied\n+  }\n+  it should \"allow authenticated calls\" in {\n+    expect(ledgerEnd(Option(rwToken(submitter).asHeader()))).toSucceed\n+  }\n+  it should \"deny calls with expired tokens\" in {\n+    expect(ledgerEnd(Option(rwToken(submitter).expired.asHeader()))).toBeDenied\n+  }\n+  it should \"allow calls with non-expired tokens\" in {\n+    expect(ledgerEnd(Option(rwToken(submitter).expiresTomorrow.asHeader()))).toSucceed\n+  }\n+\n+  private def transactionRequest =\n+    new GetTransactionsRequest(unwrappedLedgerId, Some(ledgerBegin), None, txFilterFor(submitter))\n+\n+  private def transactions(token: Option[String]): Future[Unit] =\n+    command.flatMap(\n+      _ =>\n+        streamResult[GetTransactionsResponse](observer =>\n+          stub(TransactionServiceGrpc.stub(channel), token)\n+            .getTransactions(transactionRequest, observer)))\n+\n+  private def expiringTransactions(token: String): Future[Throwable] =\n+    expectExpiration[GetTransactionsResponse](\n+      observer =>\n+        stub(TransactionServiceGrpc.stub(channel), Some(token))\n+          .getTransactions(transactionRequest, observer))\n+\n+  behavior of \"TransactionService#GetTransactions with authorization\"\n+\n+  it should \"deny unauthorized calls\" in {\n+    expect(transactions(None)).toBeDenied\n+  }\n+  it should \"allow authenticated calls\" in {\n+    expect(transactions(Option(rwToken(submitter).asHeader()))).toSucceed\n+  }\n+  it should \"deny calls with expired tokens\" in {\n+    expect(transactions(Option(rwToken(submitter).expired.asHeader()))).toBeDenied\n+  }\n+  it should \"allow calls with read-only tokens\" in {\n+    expect(transactions(Option(roToken(submitter).asHeader()))).toSucceed\n+  }\n+  it should \"allow calls with non-expired tokens\" in {\n+    expect(transactions(Option(rwToken(submitter).expiresTomorrow.asHeader()))).toSucceed\n+  }\n+  it should \"break a stream in flight upon token expiration\" in {\n+    val _ = Delayed.Future.by(10.seconds)(issueCommand())\n+    expect(expiringTransactions(rwToken(submitter).expiresInFiveSeconds.asHeader())).toSucceed\n+  }\n+\n+  private def transactionTrees(token: Option[String]): Future[Unit] =\n+    command.flatMap(\n+      _ =>\n+        streamResult[GetTransactionTreesResponse](observer =>\n+          stub(TransactionServiceGrpc.stub(channel), token)\n+            .getTransactionTrees(transactionRequest, observer)))\n+\n+  private def expiringTransactionTrees(token: String): Future[Throwable] =\n+    expectExpiration[GetTransactionTreesResponse](\n+      observer =>\n+        stub(TransactionServiceGrpc.stub(channel), Some(token))\n+          .getTransactionTrees(transactionRequest, observer))\n+\n+  behavior of \"TransactionService#GetTransactionsTrees with authorization\"\n+\n+  it should \"deny unauthorized calls\" in {\n+    expect(transactionTrees(None)).toBeDenied\n+  }\n+  it should \"allow authenticated calls\" in {\n+    expect(transactionTrees(Option(rwToken(submitter).asHeader()))).toSucceed\n+  }\n+  it should \"deny calls with expired tokens\" in {\n+    expect(transactionTrees(Option(rwToken(submitter).expired.asHeader()))).toBeDenied\n+  }\n+  it should \"allow calls with read-only tokens\" in {\n+    expect(transactionTrees(Option(roToken(submitter).asHeader()))).toSucceed\n+  }\n+  it should \"allow calls with non-expired tokens\" in {\n+    expect(transactionTrees(Option(rwToken(submitter).expiresTomorrow.asHeader()))).toSucceed\n+  }\n+  it should \"break a stream in flight upon token expiration\" in {\n+    val _ = Delayed.Future.by(10.seconds)(issueCommand())\n+    expect(expiringTransactionTrees(rwToken(submitter).expiresInFiveSeconds.asHeader())).toSucceed\n+  }\n+\n+  private def getTransactionById(token: Option[String]): Future[GetTransactionResponse] =\n+    stub(TransactionServiceGrpc.stub(channel), token)\n+      .getTransactionById(\n+        new GetTransactionByIdRequest(unwrappedLedgerId, UUID.randomUUID.toString, List(submitter)))\n+\n+  behavior of \"TransactionService#GetTransactionById with authorization\"\n+\n+  it should \"deny unauthorized calls\" in {\n+    expect(getTransactionById(None)).toBeDenied\n+  }\n+  it should \"deny calls authorized for the wrong party\" in {"
  }
]