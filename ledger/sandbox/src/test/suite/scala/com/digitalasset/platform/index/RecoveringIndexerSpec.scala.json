[
  {
    "id" : "3f828e5a-6daf-470c-8907-525b080ef9c4",
    "prId" : 2582,
    "comments" : [
      {
        "id" : "bd2f572b-ab0d-4570-b422-97a0f4e43307",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please use `AsyncWordSpec` and no blocking in the tests.",
        "createdAt" : "2019-08-28T12:03:36Z",
        "updatedAt" : "2019-08-29T12:06:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fcd279aba39c0001526d2afa503c85bd49a701e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.index\n+\n+import java.util.concurrent.ConcurrentLinkedQueue\n+\n+import akka.actor.ActorSystem\n+import akka.pattern.after\n+import com.digitalasset.platform.common.util.{DirectExecutionContext => DEC}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.concurrent.{Await, ExecutionContext, Future, Promise}\n+import scala.concurrent.duration._\n+\n+case class SubscribeResult(\n+    name: String,\n+    subscribeDelay: FiniteDuration,\n+    subscribeSucceeds: Boolean,\n+    completeDelay: FiniteDuration,\n+    completeSucceeds: Boolean)\n+\n+sealed abstract class IndexerEvent {\n+  def name: String\n+}\n+final case class EventStreamFail(name: String) extends IndexerEvent\n+final case class EventStreamComplete(name: String) extends IndexerEvent\n+final case class EventStopCalled(name: String) extends IndexerEvent\n+final case class EventSubscribeCalled(name: String) extends IndexerEvent\n+final case class EventSubscribeSuccess(name: String) extends IndexerEvent\n+final case class EventSubscribeFail(name: String) extends IndexerEvent\n+\n+class TestIndexer(results: Iterator[SubscribeResult]) {\n+  private[this] val actorSystem = ActorSystem(\"TestIndexer\")\n+  private[this] val scheduler = actorSystem.scheduler\n+\n+  val actions = new ConcurrentLinkedQueue[IndexerEvent]()\n+\n+  class TestIndexerFeedHandle(result: SubscribeResult) extends IndexFeedHandle {\n+    private[this] val promise = Promise[akka.Done]()\n+\n+    if (result.completeSucceeds) {\n+      scheduler.scheduleOnce(result.completeDelay)({\n+        actions.add(EventStreamComplete(result.name))\n+        promise.trySuccess(akka.Done)\n+        ()\n+      })(DEC)\n+    } else {\n+      scheduler.scheduleOnce(result.completeDelay)({\n+        actions.add(EventStreamFail(result.name))\n+        promise.tryFailure(new RuntimeException(\"Random simulated failure: subscribe\"))\n+        ()\n+      })(DEC)\n+    }\n+\n+    override def stop(): Future[akka.Done] = {\n+      actions.add(EventStopCalled(result.name))\n+      promise.trySuccess(akka.Done)\n+      promise.future\n+    }\n+\n+    override def completed(): Future[akka.Done] = {\n+      promise.future\n+    }\n+  }\n+\n+  def subscribe(): Future[IndexFeedHandle] = {\n+    val result = results.next()\n+    actions.add(EventSubscribeCalled(result.name))\n+    if (result.subscribeSucceeds) {\n+      after(result.subscribeDelay, scheduler)({\n+        actions.add(EventSubscribeSuccess(result.name))\n+        Future.successful(new TestIndexerFeedHandle(result))\n+      })(DEC)\n+    } else {\n+      after(result.subscribeDelay, scheduler)({\n+        actions.add(EventSubscribeFail(result.name))\n+        Future.failed(new RuntimeException(\"Random simulated failure: subscribe\"))\n+      })(DEC)\n+    }\n+  }\n+}\n+\n+class RecoveringIndexerIT extends WordSpec with Matchers {"
  },
  {
    "id" : "e997e06d-32bf-40a3-84e7-2c0017f8a2c2",
    "prId" : 2582,
    "comments" : [
      {
        "id" : "464fbacc-c3fb-458c-8322-bd21df2a3000",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "You can use `TimeUnit.MILLISECONDS.toNanos(500)` or \r\n```\r\nimport scala.concurrent.duration._\r\n500.millis.toNanos\r\n```",
        "createdAt" : "2019-08-28T12:06:43Z",
        "updatedAt" : "2019-08-29T12:06:17Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fcd279aba39c0001526d2afa503c85bd49a701e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.index\n+\n+import java.util.concurrent.ConcurrentLinkedQueue\n+\n+import akka.actor.ActorSystem\n+import akka.pattern.after\n+import com.digitalasset.platform.common.util.{DirectExecutionContext => DEC}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.concurrent.{Await, ExecutionContext, Future, Promise}\n+import scala.concurrent.duration._\n+\n+case class SubscribeResult(\n+    name: String,\n+    subscribeDelay: FiniteDuration,\n+    subscribeSucceeds: Boolean,\n+    completeDelay: FiniteDuration,\n+    completeSucceeds: Boolean)\n+\n+sealed abstract class IndexerEvent {\n+  def name: String\n+}\n+final case class EventStreamFail(name: String) extends IndexerEvent\n+final case class EventStreamComplete(name: String) extends IndexerEvent\n+final case class EventStopCalled(name: String) extends IndexerEvent\n+final case class EventSubscribeCalled(name: String) extends IndexerEvent\n+final case class EventSubscribeSuccess(name: String) extends IndexerEvent\n+final case class EventSubscribeFail(name: String) extends IndexerEvent\n+\n+class TestIndexer(results: Iterator[SubscribeResult]) {\n+  private[this] val actorSystem = ActorSystem(\"TestIndexer\")\n+  private[this] val scheduler = actorSystem.scheduler\n+\n+  val actions = new ConcurrentLinkedQueue[IndexerEvent]()\n+\n+  class TestIndexerFeedHandle(result: SubscribeResult) extends IndexFeedHandle {\n+    private[this] val promise = Promise[akka.Done]()\n+\n+    if (result.completeSucceeds) {\n+      scheduler.scheduleOnce(result.completeDelay)({\n+        actions.add(EventStreamComplete(result.name))\n+        promise.trySuccess(akka.Done)\n+        ()\n+      })(DEC)\n+    } else {\n+      scheduler.scheduleOnce(result.completeDelay)({\n+        actions.add(EventStreamFail(result.name))\n+        promise.tryFailure(new RuntimeException(\"Random simulated failure: subscribe\"))\n+        ()\n+      })(DEC)\n+    }\n+\n+    override def stop(): Future[akka.Done] = {\n+      actions.add(EventStopCalled(result.name))\n+      promise.trySuccess(akka.Done)\n+      promise.future\n+    }\n+\n+    override def completed(): Future[akka.Done] = {\n+      promise.future\n+    }\n+  }\n+\n+  def subscribe(): Future[IndexFeedHandle] = {\n+    val result = results.next()\n+    actions.add(EventSubscribeCalled(result.name))\n+    if (result.subscribeSucceeds) {\n+      after(result.subscribeDelay, scheduler)({\n+        actions.add(EventSubscribeSuccess(result.name))\n+        Future.successful(new TestIndexerFeedHandle(result))\n+      })(DEC)\n+    } else {\n+      after(result.subscribeDelay, scheduler)({\n+        actions.add(EventSubscribeFail(result.name))\n+        Future.failed(new RuntimeException(\"Random simulated failure: subscribe\"))\n+      })(DEC)\n+    }\n+  }\n+}\n+\n+class RecoveringIndexerIT extends WordSpec with Matchers {\n+\n+  private[this] implicit val ec: ExecutionContext = DEC\n+  private[this] val actorSystem = ActorSystem(\"RecoveringIndexerIT\")\n+  private[this] val scheduler = actorSystem.scheduler\n+\n+  \"RecoveringIndexer\" should {\n+\n+    \"work when the stream completes\" in {\n+      val recoveringIndexer = new RecoveringIndexer(actorSystem.scheduler, 10.millis, 1.second)\n+      val testIndexer = new TestIndexer(\n+        List(\n+          SubscribeResult(\"A\", 10.millis, true, 10.millis, true)\n+        ).iterator)\n+\n+      val end = recoveringIndexer.start(() => testIndexer.subscribe())\n+      Await.result(end, 10.seconds)\n+\n+      List(testIndexer.actions.toArray: _*) should contain theSameElementsInOrderAs List[\n+        IndexerEvent](\n+        EventSubscribeCalled(\"A\"),\n+        EventSubscribeSuccess(\"A\"),\n+        EventStreamComplete(\"A\")\n+      )\n+    }\n+\n+    \"work when the stream is stopped\" in {\n+      val recoveringIndexer = new RecoveringIndexer(actorSystem.scheduler, 10.millis, 1.second)\n+      // Stream completes after 1sec, but stop() is called before\n+      val testIndexer = new TestIndexer(\n+        List(\n+          SubscribeResult(\"A\", 10.millis, true, 1000.millis, true) // Stream completes after a long delay\n+        ).iterator)\n+\n+      val end = recoveringIndexer.start(() => testIndexer.subscribe())\n+      scheduler.scheduleOnce(50.millis, () => recoveringIndexer.close())\n+      Await.result(end, 10.seconds)\n+\n+      List(testIndexer.actions.toArray: _*) should contain theSameElementsInOrderAs List[\n+        IndexerEvent](\n+        EventSubscribeCalled(\"A\"),\n+        EventSubscribeSuccess(\"A\"),\n+        EventStopCalled(\"A\")\n+      )\n+    }\n+\n+    \"recover failures\" in {\n+      val recoveringIndexer = new RecoveringIndexer(actorSystem.scheduler, 10.millis, 1.second)\n+      // Subscribe fails, then the stream fails, then the stream completes without errors.\n+      val testIndexer = new TestIndexer(\n+        List(\n+          SubscribeResult(\"A\", 10.millis, false, 10.millis, true), // Subscribe fails\n+          SubscribeResult(\"B\", 10.millis, true, 10.millis, false), // Stream fails\n+          SubscribeResult(\"C\", 10.millis, true, 10.millis, true) // Stream completes\n+        ).iterator)\n+\n+      val end = recoveringIndexer.start(() => testIndexer.subscribe())\n+      Await.result(end, 10.seconds)\n+\n+      List(testIndexer.actions.toArray: _*) should contain theSameElementsInOrderAs List[\n+        IndexerEvent](\n+        EventSubscribeCalled(\"A\"),\n+        EventSubscribeFail(\"A\"),\n+        EventSubscribeCalled(\"B\"),\n+        EventSubscribeSuccess(\"B\"),\n+        EventStreamFail(\"B\"),\n+        EventSubscribeCalled(\"C\"),\n+        EventSubscribeSuccess(\"C\"),\n+        EventStreamComplete(\"C\")\n+      )\n+    }\n+\n+    \"respect restart delay\" in {\n+      val recoveringIndexer = new RecoveringIndexer(actorSystem.scheduler, 500.millis, 1.second)\n+      // Subscribe fails, then the stream completes without errors. Note the restart delay of 500ms.\n+      val testIndexer = new TestIndexer(\n+        List(\n+          SubscribeResult(\"A\", 0.millis, false, 0.millis, true), // Subscribe fails\n+          SubscribeResult(\"B\", 0.millis, true, 0.millis, true) // Stream completes\n+        ).iterator)\n+\n+      val t0 = System.nanoTime()\n+      val end = recoveringIndexer.start(() => testIndexer.subscribe())\n+      Await.result(end, 10.seconds)\n+      val t1 = System.nanoTime()\n+\n+      (t1 - t0) should be >= 500L * 1000L * 1000L"
  }
]