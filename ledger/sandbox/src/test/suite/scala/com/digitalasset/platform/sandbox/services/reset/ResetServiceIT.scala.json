[
  {
    "id" : "68391539-494a-45c1-8aa5-c7ba5006e6c4",
    "prId" : 4447,
    "comments" : [
      {
        "id" : "6f1f695d-9955-4198-b5a3-0f7a3814126b",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "To the best of my understanding, this simply suggests the runtime to run garbage collection but it doesn't guarantee it will happen. Can this introduce flakiness in the test?",
        "createdAt" : "2020-02-10T10:01:35Z",
        "updatedAt" : "2020-02-10T15:56:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4a8be17c-bf18-436a-b09f-3ed60726868b",
        "parentId" : "6f1f695d-9955-4198-b5a3-0f7a3814126b",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Yes, but it seems our VM is happy with the \"suggestion\". If this fails when we upgrade Java, we can disable it and find another way to test it then.",
        "createdAt" : "2020-02-10T10:11:39Z",
        "updatedAt" : "2020-02-10T15:56:26Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "84e6c618d4689590c8f46682a40a528bbafe76f7",
    "line" : 77,
    "diffHunk" : "@@ -174,6 +173,17 @@ final class ResetServiceIT\n         }\n       }\n \n+      \"clear out all garbage\" in {\n+        val state = new WeakReference(serverResource.value.sandboxState)\n+        for {\n+          lid <- fetchLedgerId()\n+          _ <- reset(lid)\n+        } yield {\n+          System.gc()"
  },
  {
    "id" : "cdbf400b-4178-4a6a-9274-03d126e68f34",
    "prId" : 3844,
    "comments" : [
      {
        "id" : "98ea4ad7-ab52-41e9-8225-0a79187e5acb",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Why not use ScalaTest's `eventually`?",
        "createdAt" : "2019-12-13T15:50:13Z",
        "updatedAt" : "2019-12-13T15:55:07Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5fb58336-9eb6-4f98-ad4a-987e08db9aa7",
        "parentId" : "98ea4ad7-ab52-41e9-8225-0a79187e5acb",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm not sure of the reason why but everything fails if I use that. I'm not sure of the semantics there.",
        "createdAt" : "2019-12-13T16:04:07Z",
        "updatedAt" : "2019-12-13T16:04:07Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b1493b21c23cbfff4e88cad63f00f68284ec1f4a",
    "line" : 57,
    "diffHunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.services.reset\n+\n+import java.io.File\n+import java.util.UUID\n+\n+import com.digitalasset.daml.bazeltools.BazelRunfiles.rlocation\n+import com.digitalasset.ledger.api.domain.LedgerId\n+import com.digitalasset.ledger.api.testing.utils.{\n+  IsStatusException,\n+  SuiteResourceManagementAroundEach,\n+  MockMessages => M\n+}\n+import com.digitalasset.ledger.api.v1.active_contracts_service.{\n+  ActiveContractsServiceGrpc,\n+  GetActiveContractsRequest,\n+  GetActiveContractsResponse\n+}\n+import com.digitalasset.ledger.api.v1.command_completion_service.{\n+  CommandCompletionServiceGrpc,\n+  CompletionStreamRequest\n+}\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.command_submission_service.CommandSubmissionServiceGrpc\n+import com.digitalasset.ledger.api.v1.event.CreatedEvent\n+import com.digitalasset.ledger.api.v1.ledger_identity_service.{\n+  GetLedgerIdentityRequest,\n+  LedgerIdentityServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.testing.reset_service.{ResetRequest, ResetServiceGrpc}\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.common.LedgerIdMode\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.digitalasset.platform.sandbox.services.{SandboxFixture, TestCommands}\n+import com.digitalasset.platform.testing.{FiniteStreamObserver, WaitForCompletionsObserver}\n+import com.digitalasset.timer.RetryStrategy\n+import com.google.protobuf.empty.Empty\n+import io.grpc.Status\n+import org.scalatest.concurrent.{AsyncTimeLimitedTests, ScalaFutures}\n+import org.scalatest.time.Span\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Future\n+import scala.concurrent.duration.{Duration, DurationInt, DurationLong}\n+\n+final class ResetServiceIT\n+    extends AsyncWordSpec\n+    with AsyncTimeLimitedTests\n+    with Matchers\n+    with ScalaFutures\n+    with SandboxFixture\n+    with SuiteResourceManagementAroundEach\n+    with TestCommands {\n+\n+  private val eventually = RetryStrategy.exponentialBackoff(10, 10.millis)"
  },
  {
    "id" : "18235cc3-b712-4167-8fc4-56da06e75b17",
    "prId" : 3844,
    "comments" : [
      {
        "id" : "2cdcab40-3ae7-4b29-bfe5-3d027de028e4",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I think I'd prefer it if we could use `for` comprehensions with assertions.",
        "createdAt" : "2019-12-13T15:53:25Z",
        "updatedAt" : "2019-12-13T15:55:07Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b1493b21c23cbfff4e88cad63f00f68284ec1f4a",
    "line" : 134,
    "diffHunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.services.reset\n+\n+import java.io.File\n+import java.util.UUID\n+\n+import com.digitalasset.daml.bazeltools.BazelRunfiles.rlocation\n+import com.digitalasset.ledger.api.domain.LedgerId\n+import com.digitalasset.ledger.api.testing.utils.{\n+  IsStatusException,\n+  SuiteResourceManagementAroundEach,\n+  MockMessages => M\n+}\n+import com.digitalasset.ledger.api.v1.active_contracts_service.{\n+  ActiveContractsServiceGrpc,\n+  GetActiveContractsRequest,\n+  GetActiveContractsResponse\n+}\n+import com.digitalasset.ledger.api.v1.command_completion_service.{\n+  CommandCompletionServiceGrpc,\n+  CompletionStreamRequest\n+}\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.command_submission_service.CommandSubmissionServiceGrpc\n+import com.digitalasset.ledger.api.v1.event.CreatedEvent\n+import com.digitalasset.ledger.api.v1.ledger_identity_service.{\n+  GetLedgerIdentityRequest,\n+  LedgerIdentityServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.testing.reset_service.{ResetRequest, ResetServiceGrpc}\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.common.LedgerIdMode\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.digitalasset.platform.sandbox.services.{SandboxFixture, TestCommands}\n+import com.digitalasset.platform.testing.{FiniteStreamObserver, WaitForCompletionsObserver}\n+import com.digitalasset.timer.RetryStrategy\n+import com.google.protobuf.empty.Empty\n+import io.grpc.Status\n+import org.scalatest.concurrent.{AsyncTimeLimitedTests, ScalaFutures}\n+import org.scalatest.time.Span\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Future\n+import scala.concurrent.duration.{Duration, DurationInt, DurationLong}\n+\n+final class ResetServiceIT\n+    extends AsyncWordSpec\n+    with AsyncTimeLimitedTests\n+    with Matchers\n+    with ScalaFutures\n+    with SandboxFixture\n+    with SuiteResourceManagementAroundEach\n+    with TestCommands {\n+\n+  private val eventually = RetryStrategy.exponentialBackoff(10, 10.millis)\n+\n+  override def timeLimit: Span = scaled(30.seconds)\n+\n+  override protected val config: SandboxConfig =\n+    super.config.copy(ledgerIdMode = LedgerIdMode.Dynamic())\n+\n+  override protected def darFile: File = new File(rlocation(\"ledger/test-common/Test-stable.dar\"))\n+\n+  private def getLedgerId(): Future[String] =\n+    LedgerIdentityServiceGrpc\n+      .stub(channel)\n+      .getLedgerIdentity(GetLedgerIdentityRequest())\n+      .map(_.ledgerId)\n+\n+  // Resets and waits for a new ledger identity to be available\n+  private def reset(ledgerId: String): Future[String] =\n+    for {\n+      _ <- ResetServiceGrpc.stub(channel).reset(ResetRequest(ledgerId))\n+      newLedgerId <- eventually { (_, _) =>\n+        getLedgerId()\n+      }\n+    } yield newLedgerId\n+\n+  private def timedReset(ledgerId: String): Future[(String, Duration)] = {\n+    val start = System.nanoTime()\n+    reset(ledgerId).zip(Future.successful((System.nanoTime() - start).nanos))\n+  }\n+\n+  private def submitAndWait(req: SubmitAndWaitRequest): Future[Empty] =\n+    CommandServiceGrpc.stub(channel).submitAndWait(req)\n+\n+  private def activeContracts(ledgerId: String, f: TransactionFilter): Future[Set[CreatedEvent]] =\n+    FiniteStreamObserver[GetActiveContractsResponse](\n+      ActiveContractsServiceGrpc\n+        .stub(channel)\n+        .getActiveContracts(GetActiveContractsRequest(ledgerId, Some(f)), _))\n+      .map(_.flatMap(_.activeContracts)(collection.breakOut))\n+\n+  private def submitAndExpectCompletions(ledgerId: String, commands: Int): Future[Unit] =\n+    for {\n+      _ <- Future.sequence(\n+        Vector.fill(commands)(\n+          CommandSubmissionServiceGrpc\n+            .stub(channel)\n+            .submit(dummyCommands(LedgerId(ledgerId), UUID.randomUUID.toString))))\n+      unit <- WaitForCompletionsObserver(commands)(\n+        CommandCompletionServiceGrpc\n+          .stub(channel)\n+          .completionStream(\n+            CompletionStreamRequest(\n+              ledgerId = ledgerId,\n+              applicationId = M.applicationId,\n+              parties = Seq(M.party),\n+              offset = Some(M.ledgerBegin)\n+            ),\n+            _))\n+    } yield unit\n+\n+  \"ResetService\" when {\n+\n+    \"state is reset\" should {\n+\n+      \"return a new ledger ID\" in {\n+        for {\n+          lid1 <- getLedgerId()\n+          lid2 <- reset(lid1)\n+          throwable <- reset(lid1).failed\n+        } yield {\n+          lid1 should not equal lid2\n+          IsStatusException(Status.Code.NOT_FOUND)(throwable)\n+        }\n+      }\n+\n+      \"return new ledger ID - 20 resets\" in {\n+        Future\n+          .sequence(Iterator.iterate(getLedgerId())(_.flatMap(reset)).take(20).toVector)\n+          .map(ids => ids.distinct should have size 20L)"
  },
  {
    "id" : "ed056110-cb7a-4d17-8600-1a3d4cc324dd",
    "prId" : 3844,
    "comments" : [
      {
        "id" : "50def661-da4f-4ad9-b870-3b50d19ea605",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Even when the assertion is just a `succeed`, I think I'd still prefer a `for`, but I'm less fussed about this one.",
        "createdAt" : "2019-12-13T15:53:50Z",
        "updatedAt" : "2019-12-13T15:55:07Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "99df2f2b-6fae-4875-86ae-7503df004a49",
        "parentId" : "50def661-da4f-4ad9-b870-3b50d19ea605",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "There are different opinions in the team (@gerolf-da usually prefers `map` when the call is very simple). If you don't have a strong argument against this one I'd keep it as it is right now, mostly out of sheer inertia. Ideally I would have wanted to use `all(measurements) should be <= threshold` but for some reason it doesn't compile.",
        "createdAt" : "2019-12-13T16:00:02Z",
        "updatedAt" : "2019-12-13T16:00:02Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b1493b21c23cbfff4e88cad63f00f68284ec1f4a",
    "line" : 159,
    "diffHunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.services.reset\n+\n+import java.io.File\n+import java.util.UUID\n+\n+import com.digitalasset.daml.bazeltools.BazelRunfiles.rlocation\n+import com.digitalasset.ledger.api.domain.LedgerId\n+import com.digitalasset.ledger.api.testing.utils.{\n+  IsStatusException,\n+  SuiteResourceManagementAroundEach,\n+  MockMessages => M\n+}\n+import com.digitalasset.ledger.api.v1.active_contracts_service.{\n+  ActiveContractsServiceGrpc,\n+  GetActiveContractsRequest,\n+  GetActiveContractsResponse\n+}\n+import com.digitalasset.ledger.api.v1.command_completion_service.{\n+  CommandCompletionServiceGrpc,\n+  CompletionStreamRequest\n+}\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.command_submission_service.CommandSubmissionServiceGrpc\n+import com.digitalasset.ledger.api.v1.event.CreatedEvent\n+import com.digitalasset.ledger.api.v1.ledger_identity_service.{\n+  GetLedgerIdentityRequest,\n+  LedgerIdentityServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.testing.reset_service.{ResetRequest, ResetServiceGrpc}\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.common.LedgerIdMode\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.digitalasset.platform.sandbox.services.{SandboxFixture, TestCommands}\n+import com.digitalasset.platform.testing.{FiniteStreamObserver, WaitForCompletionsObserver}\n+import com.digitalasset.timer.RetryStrategy\n+import com.google.protobuf.empty.Empty\n+import io.grpc.Status\n+import org.scalatest.concurrent.{AsyncTimeLimitedTests, ScalaFutures}\n+import org.scalatest.time.Span\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Future\n+import scala.concurrent.duration.{Duration, DurationInt, DurationLong}\n+\n+final class ResetServiceIT\n+    extends AsyncWordSpec\n+    with AsyncTimeLimitedTests\n+    with Matchers\n+    with ScalaFutures\n+    with SandboxFixture\n+    with SuiteResourceManagementAroundEach\n+    with TestCommands {\n+\n+  private val eventually = RetryStrategy.exponentialBackoff(10, 10.millis)\n+\n+  override def timeLimit: Span = scaled(30.seconds)\n+\n+  override protected val config: SandboxConfig =\n+    super.config.copy(ledgerIdMode = LedgerIdMode.Dynamic())\n+\n+  override protected def darFile: File = new File(rlocation(\"ledger/test-common/Test-stable.dar\"))\n+\n+  private def getLedgerId(): Future[String] =\n+    LedgerIdentityServiceGrpc\n+      .stub(channel)\n+      .getLedgerIdentity(GetLedgerIdentityRequest())\n+      .map(_.ledgerId)\n+\n+  // Resets and waits for a new ledger identity to be available\n+  private def reset(ledgerId: String): Future[String] =\n+    for {\n+      _ <- ResetServiceGrpc.stub(channel).reset(ResetRequest(ledgerId))\n+      newLedgerId <- eventually { (_, _) =>\n+        getLedgerId()\n+      }\n+    } yield newLedgerId\n+\n+  private def timedReset(ledgerId: String): Future[(String, Duration)] = {\n+    val start = System.nanoTime()\n+    reset(ledgerId).zip(Future.successful((System.nanoTime() - start).nanos))\n+  }\n+\n+  private def submitAndWait(req: SubmitAndWaitRequest): Future[Empty] =\n+    CommandServiceGrpc.stub(channel).submitAndWait(req)\n+\n+  private def activeContracts(ledgerId: String, f: TransactionFilter): Future[Set[CreatedEvent]] =\n+    FiniteStreamObserver[GetActiveContractsResponse](\n+      ActiveContractsServiceGrpc\n+        .stub(channel)\n+        .getActiveContracts(GetActiveContractsRequest(ledgerId, Some(f)), _))\n+      .map(_.flatMap(_.activeContracts)(collection.breakOut))\n+\n+  private def submitAndExpectCompletions(ledgerId: String, commands: Int): Future[Unit] =\n+    for {\n+      _ <- Future.sequence(\n+        Vector.fill(commands)(\n+          CommandSubmissionServiceGrpc\n+            .stub(channel)\n+            .submit(dummyCommands(LedgerId(ledgerId), UUID.randomUUID.toString))))\n+      unit <- WaitForCompletionsObserver(commands)(\n+        CommandCompletionServiceGrpc\n+          .stub(channel)\n+          .completionStream(\n+            CompletionStreamRequest(\n+              ledgerId = ledgerId,\n+              applicationId = M.applicationId,\n+              parties = Seq(M.party),\n+              offset = Some(M.ledgerBegin)\n+            ),\n+            _))\n+    } yield unit\n+\n+  \"ResetService\" when {\n+\n+    \"state is reset\" should {\n+\n+      \"return a new ledger ID\" in {\n+        for {\n+          lid1 <- getLedgerId()\n+          lid2 <- reset(lid1)\n+          throwable <- reset(lid1).failed\n+        } yield {\n+          lid1 should not equal lid2\n+          IsStatusException(Status.Code.NOT_FOUND)(throwable)\n+        }\n+      }\n+\n+      \"return new ledger ID - 20 resets\" in {\n+        Future\n+          .sequence(Iterator.iterate(getLedgerId())(_.flatMap(reset)).take(20).toVector)\n+          .map(ids => ids.distinct should have size 20L)\n+      }\n+\n+      // 5 attempts with 5 transactions each seem to strike the right balance\n+      // to complete before the 30 seconds test timeout in normal conditions while\n+      // still causing the test to fail if something goes wrong\n+      //\n+      // the 10 seconds timeout built into the context's ledger reset will\n+      // be hit if something goes horribly wrong, causing an exception to report\n+      // waitForNewLedger: out of retries\n+      \"consistently complete within 5 seconds\" in {\n+        val numberOfCommands = 5\n+        val numberOfAttempts = 5\n+        Future\n+          .sequence(\n+            Iterator\n+              .iterate(getLedgerId()) { ledgerIdF =>\n+                for {\n+                  ledgerId <- ledgerIdF\n+                  _ <- submitAndExpectCompletions(ledgerId, numberOfCommands)\n+                  (newLedgerId, timing) <- timedReset(ledgerId) if timing <= 5.seconds\n+                } yield newLedgerId\n+              }\n+              .take(numberOfAttempts)\n+          )\n+          .map(_ => succeed)"
  }
]