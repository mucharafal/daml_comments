[
  {
    "id" : "0b86c981-5a32-41b3-b0e3-91b350652e40",
    "prId" : 3864,
    "comments" : [
      {
        "id" : "c8425723-c174-4350-9f2c-9fca322a93d3",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Maybe you could save this as a resource rather than embedding it in the text.\r\n\r\n(In case you haven't used resources before, basically you'd save it as _src/test/resources/com/digitalasset/platform/sandbox/stores/ledger/sql/serialisation/expected-hashes.txt_ and load it as a resource with `Source.fromInputStream(getClass.getResourceAsStream(\"expected-hashes.txt\")).mkString`.)",
        "createdAt" : "2019-12-17T10:31:53Z",
        "updatedAt" : "2020-01-06T13:28:12Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c83305bc043cb32443f64a5ac4bb86cce5c5b0da",
    "line" : 629,
    "diffHunk" : "@@ -0,0 +1,645 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.sandbox.stores.ledger.sql.serialisation\n+\n+import java.security.MessageDigest\n+\n+import com.digitalasset.daml.lf\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.data._\n+import com.digitalasset.daml.lf.transaction.Node.GlobalKey\n+import com.digitalasset.daml.lf.value.Value._\n+import com.digitalasset.daml.lf.value.{Value, ValueVersion}\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.language.implicitConversions\n+\n+class KeyHasherSpec extends WordSpec with Matchers {\n+  private[this] def templateId(module: String, name: String) = Identifier(\n+    PackageId.assertFromString(\"package\"),\n+    QualifiedName(\n+      ModuleName.assertFromString(module),\n+      DottedName.assertFromString(name)\n+    )\n+  )\n+\n+  private[this] def complexValue = {\n+    val builder = ImmArray.newBuilder[(Option[Name], Value[AbsoluteContractId])]\n+    builder += None -> ValueInt64(0)\n+    builder += None -> ValueInt64(123456)\n+    builder += None -> ValueInt64(-1)\n+    builder += None -> ValueNumeric(decimal(0))\n+    builder += None -> ValueNumeric(decimal(BigDecimal(\"0.3333333333\")))\n+    builder += None -> ValueTrue\n+    builder += None -> ValueFalse\n+    builder += None -> ValueDate(Time.Date.assertFromDaysSinceEpoch(0))\n+    builder += None -> ValueDate(Time.Date.assertFromDaysSinceEpoch(123456))\n+    builder += None -> ValueTimestamp(Time.Timestamp.assertFromLong(0))\n+    builder += None -> ValueTimestamp(Time.Timestamp.assertFromLong(123456))\n+    builder += None -> ValueText(\"\")\n+    builder += None -> ValueText(\"abcd-äöü€\")\n+    builder += None -> ValueParty(Party.assertFromString(\"Alice\"))\n+    builder += None -> ValueUnit\n+    builder += None -> ValueNone\n+    builder += None -> ValueOptional(Some(ValueText(\"Some\")))\n+    builder += None -> ValueList(FrontStack(ValueText(\"A\"), ValueText(\"B\"), ValueText(\"C\")))\n+    builder += None -> ValueVariant(None, Name.assertFromString(\"Variant\"), ValueInt64(0))\n+    builder += None -> ValueRecord(\n+      None,\n+      ImmArray(\n+        None -> ValueText(\"field1\"),\n+        None -> ValueText(\"field2\")\n+      ))\n+    builder += None -> ValueTextMap(\n+      SortedLookupList(\n+        Map(\n+          \"keyA\" -> ValueText(\"valueA\"),\n+          \"keyB\" -> ValueText(\"valueB\")\n+        )))\n+    val fields = builder.result()\n+\n+    ValueRecord(None, fields)\n+  }\n+\n+  \"KeyHasher\" should {\n+\n+    \"be stable\" in {\n+      // Hashing function must not change\n+      val value = VersionedValue(ValueVersion(\"4\"), complexValue)\n+      val hash = \"2b1019f99147ca726baa3a12509399327746f1f9c4636a6ec5f5d7af1e7c2942\"\n+\n+      KeyHasher.hashKeyString(GlobalKey(templateId(\"module\", \"name\"), value)) shouldBe hash\n+    }\n+\n+    \"be deterministic and thread safe\" in {\n+      // Compute many hashes in parallel, check that they are all equal\n+      // Note: intentionally does not reuse value instances\n+      val hashes = Vector\n+        .range(0, 1000)\n+        .map(_ =>\n+          GlobalKey(templateId(\"module\", \"name\"), VersionedValue(ValueVersion(\"4\"), complexValue)))\n+        .par\n+        .map(key => KeyHasher.hashKeyString(key))\n+\n+      hashes.toSet.size shouldBe 1\n+    }\n+\n+    \"not produce collision in template id\" in {\n+      // Same value but different template ID should produce a different hash\n+      val value = VersionedValue(ValueVersion(\"4\"), ValueText(\"A\"))\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(templateId(\"AA\", \"A\"), value))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(templateId(\"A\", \"AA\"), value))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    // Note: value version is given by the template ID, this check is not necessary\n+    /*\n+    \"not produce collision in value version\" in {\n+      // Same value but different value version should produce a different hash\n+      val value1 = VersionedValue(ValueVersion(\"3\"), ValueText(\"A\"))\n+      val value2 = VersionedValue(ValueVersion(\"4\"), ValueText(\"A\"))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+     */\n+\n+    \"not produce collision in list of text\" in {\n+      // Testing whether strings are delimited: [\"AA\", \"A\"] vs [\"A\", \"AA\"]\n+      val value1 =\n+        VersionedValue(ValueVersion(\"4\"), ValueList(FrontStack(ValueText(\"AA\"), ValueText(\"A\"))))\n+      val value2 =\n+        VersionedValue(ValueVersion(\"4\"), ValueList(FrontStack(ValueText(\"A\"), ValueText(\"AA\"))))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in list of decimals\" in {\n+      // Testing whether decimals are delimited: [10, 10] vs [101, 0]\n+      val value1 =\n+        VersionedValue(\n+          ValueVersion(\"4\"),\n+          ValueList(FrontStack(ValueNumeric(decimal(10)), ValueNumeric(decimal(10)))))\n+      val value2 =\n+        VersionedValue(\n+          ValueVersion(\"4\"),\n+          ValueList(FrontStack(ValueNumeric(decimal(101)), ValueNumeric(decimal(0)))))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in list of lists\" in {\n+      // Testing whether lists are delimited: [[()], [(), ()]] vs [[(), ()], [()]]\n+      val value1 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueList(\n+          FrontStack(\n+            ValueList(FrontStack(ValueUnit)),\n+            ValueList(FrontStack(ValueUnit, ValueUnit))\n+          )))\n+      val value2 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueList(\n+          FrontStack(\n+            ValueList(FrontStack(ValueUnit, ValueUnit)),\n+            ValueList(FrontStack(ValueUnit))\n+          )))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Variant constructor\" in {\n+      val value1 =\n+        VersionedValue(ValueVersion(\"4\"), ValueVariant(None, Name.assertFromString(\"A\"), ValueUnit))\n+      val value2 =\n+        VersionedValue(ValueVersion(\"4\"), ValueVariant(None, Name.assertFromString(\"B\"), ValueUnit))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Variant value\" in {\n+      val value1 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueVariant(None, Name.assertFromString(\"A\"), ValueInt64(0L)))\n+      val value2 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueVariant(None, Name.assertFromString(\"A\"), ValueInt64(1L)))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Map keys\" in {\n+      val value1 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueTextMap(\n+          SortedLookupList(\n+            Map(\n+              \"A\" -> ValueInt64(0),\n+              \"B\" -> ValueInt64(0)\n+            ))))\n+      val value2 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueTextMap(\n+          SortedLookupList(\n+            Map(\n+              \"A\" -> ValueInt64(0),\n+              \"C\" -> ValueInt64(0)\n+            ))))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Map values\" in {\n+      val value1 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueTextMap(\n+          SortedLookupList(\n+            Map(\n+              \"A\" -> ValueInt64(0),\n+              \"B\" -> ValueInt64(0)\n+            ))))\n+      val value2 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueTextMap(\n+          SortedLookupList(\n+            Map(\n+              \"A\" -> ValueInt64(0),\n+              \"B\" -> ValueInt64(1)\n+            ))))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Bool\" in {\n+      val value1 = VersionedValue(ValueVersion(\"4\"), ValueTrue)\n+      val value2 = VersionedValue(ValueVersion(\"4\"), ValueFalse)\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Int64\" in {\n+      val value1 = VersionedValue(ValueVersion(\"4\"), ValueInt64(0L))\n+      val value2 = VersionedValue(ValueVersion(\"4\"), ValueInt64(1L))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Decimal\" in {\n+      val value1 = VersionedValue(ValueVersion(\"4\"), ValueNumeric(decimal(0)))\n+      val value2 = VersionedValue(ValueVersion(\"4\"), ValueNumeric(decimal(1)))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Date\" in {\n+      val value1 =\n+        VersionedValue(ValueVersion(\"4\"), ValueDate(Time.Date.assertFromDaysSinceEpoch(0)))\n+      val value2 =\n+        VersionedValue(ValueVersion(\"4\"), ValueDate(Time.Date.assertFromDaysSinceEpoch(1)))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Timestamp\" in {\n+      val value1 =\n+        VersionedValue(ValueVersion(\"4\"), ValueTimestamp(Time.Timestamp.assertFromLong(0)))\n+      val value2 =\n+        VersionedValue(ValueVersion(\"4\"), ValueTimestamp(Time.Timestamp.assertFromLong(1)))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Optional\" in {\n+      val value1 = VersionedValue(ValueVersion(\"4\"), ValueNone)\n+      val value2 = VersionedValue(ValueVersion(\"4\"), ValueOptional(Some(ValueUnit)))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+\n+    \"not produce collision in Record\" in {\n+      val value1 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueRecord(\n+          None,\n+          ImmArray(\n+            None -> ValueText(\"A\"),\n+            None -> ValueText(\"B\")\n+          )))\n+      val value2 = VersionedValue(\n+        ValueVersion(\"4\"),\n+        ValueRecord(\n+          None,\n+          ImmArray(\n+            None -> ValueText(\"A\"),\n+            None -> ValueText(\"C\")\n+          )))\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashKeyString(GlobalKey(tid, value1))\n+      val hash2 = KeyHasher.hashKeyString(GlobalKey(tid, value2))\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+  }\n+\n+  \"KeyHasher.putValue\" should {\n+\n+    \"stable \" in {\n+\n+      type Value = lf.value.Value[AbsoluteContractId]\n+\n+      val pkgId = Ref.PackageId.assertFromString(\"pkgId\")\n+\n+      implicit def toTypeConName(s: String): Ref.TypeConName =\n+        Ref.TypeConName(pkgId, Ref.QualifiedName.assertFromString(s\"Mod:$s\"))\n+\n+      implicit def toName(s: String): Ref.Name =\n+        Ref.Name.assertFromString(s)\n+\n+      implicit def toSortedLookupList[V](a: ImmArray[(String, V)]): SortedLookupList[V] =\n+        SortedLookupList.fromSortedImmArray(a).right.get\n+\n+      val EnumTypeCon: Ref.TypeConName = \"Color\"\n+      val EnumTypeConBis: Ref.TypeConName = \"ColorBis\"\n+\n+      val EnumCon1: Ref.Name = \"Red\"\n+      val EnumCon2: Ref.Name = \"Green\"\n+\n+      val Record0TypeCon: Ref.TypeConName = \"Unit\"\n+      val Record2TypeCon: Ref.TypeConName = \"Tuple\"\n+      val Record0TypeConBis: Ref.TypeConName = \"UnitBis\"\n+      val Record2TypeConBis: Ref.TypeConName = \"TupleBis\"\n+      val fstField = Ref.Name.assertFromString(\"_1\")\n+      val sndField = Ref.Name.assertFromString(\"_2\")\n+\n+      val VariantTypeCon: Ref.TypeConName = \"Either\"\n+      val VariantTypeConBis: Ref.TypeConName = \"EitherBis\"\n+      val VariantCon1: Ref.Name = \"Left\"\n+      val VariantCon2: Ref.Name = \"Right\"\n+\n+      val units =\n+        List[Value](\n+          ValueUnit\n+        )\n+      val bools =\n+        List[Value](ValueTrue, ValueFalse)\n+      val ints =\n+        List[Value](ValueInt64(-1L), ValueInt64(0L), ValueInt64(1L))\n+      val decimals =\n+        List[Value](\n+          ValueNumeric(Numeric.assertFromString(\"-10000.0000000000\")),\n+          ValueNumeric(Numeric.assertFromString(\"0.0000000000\")),\n+          ValueNumeric(Numeric.assertFromString(\"10000.0000000000\")),\n+        )\n+      val numeric0s =\n+        List[Value](\n+          ValueNumeric(Numeric.assertFromString(\"-10000.\")),\n+          ValueNumeric(Numeric.assertFromString(\"0.\")),\n+          ValueNumeric(Numeric.assertFromString(\"10000.\")),\n+        )\n+\n+      val texts =\n+        List[Value](\n+          ValueText(\"\"),\n+          ValueText(\"someText\"),\n+          ValueText(\"a¶‱😂\"),\n+        )\n+      val dates =\n+        List[Value](\n+          ValueDate(Time.Date.assertFromDaysSinceEpoch(0)),\n+          ValueDate(Time.Date.assertFromString(\"1969-07-21\")),\n+          ValueDate(Time.Date.assertFromString(\"2019-12-16\")),\n+        )\n+      val timestamps =\n+        List[Value](\n+          ValueTimestamp(Time.Timestamp.assertFromLong(0)),\n+          ValueTimestamp(Time.Timestamp.assertFromString(\"1969-07-21T02:56:15.000000Z\")),\n+          ValueTimestamp(Time.Timestamp.assertFromString(\"2019-12-16T11:17:54.940779363Z\")),\n+        )\n+      val parties =\n+        List[Value](\n+          ValueParty(Ref.Party.assertFromString(\"alice\")),\n+          ValueParty(Ref.Party.assertFromString(\"bob\")),\n+        )\n+      val contractIds =\n+        List[Value](\n+          ValueContractId(\n+            AbsoluteContractId(Ref.ContractIdString.assertFromString(\n+              \"07e7b5534931dfca8e1b485c105bae4e10808bd13ddc8e897f258015f9d921c5\"))),\n+          ValueContractId(\n+            AbsoluteContractId(Ref.ContractIdString.assertFromString(\n+              \"59b59ad7a6b6066e77b91ced54b8282f0e24e7089944685cb8f22f32fcbc4e1b\")))\n+        )\n+\n+      val enums =\n+        List[Value](\n+          ValueEnum(Some(EnumTypeCon), EnumCon1),\n+          ValueEnum(Some(EnumTypeCon), EnumCon2),\n+          ValueEnum(Some(EnumTypeConBis), EnumCon2),\n+        )\n+\n+      val records0 =\n+        List[Value](\n+          ValueRecord(Some(Record0TypeCon), ImmArray.empty),\n+          ValueRecord(Some(Record0TypeConBis), ImmArray.empty),\n+        )\n+\n+      val records2 =\n+        List[Value](\n+          ValueRecord(\n+            Some(Record2TypeCon),\n+            ImmArray(Some(fstField) -> ValueFalse, Some(sndField) -> ValueFalse)),\n+          ValueRecord(\n+            Some(Record2TypeCon),\n+            ImmArray(Some(fstField) -> ValueTrue, Some(sndField) -> ValueFalse)),\n+          ValueRecord(\n+            Some(Record2TypeCon),\n+            ImmArray(Some(fstField) -> ValueFalse, Some(sndField) -> ValueTrue)),\n+          ValueRecord(\n+            Some(Record2TypeConBis),\n+            ImmArray(Some(fstField) -> ValueFalse, Some(sndField) -> ValueFalse)),\n+        )\n+\n+      val variants = List[Value](\n+        ValueVariant(Some(VariantTypeCon), VariantCon1, ValueFalse),\n+        ValueVariant(Some(VariantTypeCon), VariantCon1, ValueTrue),\n+        ValueVariant(Some(VariantTypeCon), VariantCon2, ValueFalse),\n+        ValueVariant(Some(VariantTypeConBis), VariantCon1, ValueFalse),\n+      )\n+\n+      val lists = List[Value](\n+        ValueList(FrontStack.empty),\n+        ValueList(FrontStack(ValueFalse)),\n+        ValueList(FrontStack(ValueTrue)),\n+        ValueList(FrontStack(ValueFalse, ValueFalse)),\n+        ValueList(FrontStack(ValueFalse, ValueTrue)),\n+        ValueList(FrontStack(ValueTrue, ValueFalse)),\n+      )\n+\n+      val textMaps = List[Value](\n+        ValueTextMap(SortedLookupList.empty),\n+        ValueTextMap(ImmArray(\"a\" -> ValueFalse)),\n+        ValueTextMap(ImmArray(\"a\" -> ValueFalse)),\n+        ValueTextMap(ImmArray(\"b\" -> ValueFalse)),\n+        ValueTextMap(ImmArray(\"a\" -> ValueFalse, \"b\" -> ValueFalse)),\n+        ValueTextMap(ImmArray(\"a\" -> ValueTrue, \"b\" -> ValueFalse)),\n+        ValueTextMap(ImmArray(\"a\" -> ValueFalse, \"b\" -> ValueTrue)),\n+        ValueTextMap(ImmArray(\"a\" -> ValueFalse, \"c\" -> ValueFalse)),\n+      )\n+\n+      val optionals = List[Value](\n+        ValueOptional(None),\n+        ValueOptional(Some(ValueFalse)),\n+        ValueOptional(Some(ValueTrue)),\n+        ValueOptional(Some(ValueOptional(None))),\n+        ValueOptional(Some(ValueOptional(Some(ValueFalse)))),\n+      )\n+\n+      val testCases: List[Value] =\n+        units ++ bools ++ ints ++ decimals ++ numeric0s ++ dates ++ timestamps ++ texts ++ parties ++ contractIds ++ optionals ++ lists ++ textMaps ++ enums ++ records0 ++ records2 ++ variants\n+\n+      val expectedOut =\n+        \"\"\"ValueUnit\n+          | 6e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\n+          |ValueBool(true)\n+          | 4bf5122f344554c53bde2ebb8cd2b7e3d1600ad631c385a5d7cce23c7785459a\n+          |ValueBool(false)\n+          | 6e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\n+          |ValueInt64(-1)\n+          | 12a3ae445661ce5dee78d0650d33362dec29c4f82af05e7e57fb595bbbacf0ca\n+          |ValueInt64(0)\n+          | af5570f5a1810b7af78caf4bc70a660f0df51e42baf91d4de5b2328de0e83dfc\n+          |ValueInt64(1)\n+          | cd2662154e6d76b2b2b92e70c0cac3ccf534f9b74eb5b89819ec509083d00a50\n+          |ValueNumeric(-10000.0000000000)\n+          | 92b92de61f21059f70dec535eb848a8275a402b520c6c8c65c29368e7181920a\n+          |ValueNumeric(0E-10)\n+          | 7b083527a0b46146dad7ef53700e2f975266e2d212fe683b0307c3ea00e892bc\n+          |ValueNumeric(10000.0000000000)\n+          | 44a82bcdb9f16bc015fa19d3db2a8f474c502a0c2f0d3fcf926bf1c934b8de59\n+          |ValueNumeric(-10000)\n+          | 92b92de61f21059f70dec535eb848a8275a402b520c6c8c65c29368e7181920a\n+          |ValueNumeric(0)\n+          | 7b083527a0b46146dad7ef53700e2f975266e2d212fe683b0307c3ea00e892bc\n+          |ValueNumeric(10000)\n+          | 44a82bcdb9f16bc015fa19d3db2a8f474c502a0c2f0d3fcf926bf1c934b8de59\n+          |ValueDate(1970-01-01)\n+          | df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119\n+          |ValueDate(1969-07-21)\n+          | 434fa8eb0883d896f4bcf774541c2b0a9cadc0d0e5c6e747a40ccc8c2b1007b3\n+          |ValueDate(2019-12-16)\n+          | 198ffe57505806fdb66781e9ebd1e3bddef98140ece736496dd4e8f141bd8c8b\n+          |ValueTimestamp(1970-01-01T00:00:00Z)\n+          | af5570f5a1810b7af78caf4bc70a660f0df51e42baf91d4de5b2328de0e83dfc\n+          |ValueTimestamp(1969-07-21T02:56:15Z)\n+          | 29915511efcac543356407a5aeec43025bb79ccce44c8248646830dc3dcf8434\n+          |ValueTimestamp(2019-12-16T11:17:54.940779Z)\n+          | d138f5a129f8a66d7c0eccc99116de7dc563a9425543ba33d5401109ec4be877\n+          |ValueText()\n+          | df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119\n+          |ValueText(someText)\n+          | 5d556be4585eafaf71039732a9be3821c5b960d88099a2749783762d16dcd344\n+          |ValueText(a¶‱😂)\n+          | 4f896bd4ef0468d1bef9e88eee1d7a6dc7a0e58045205df0f17345562ba78814\n+          |ValueParty(alice)\n+          | e3e40cc57896dcdac6731f60cb1748bd34b45ac0a6e42aa517d41dfea2ff8a88\n+          |ValueParty(bob)\n+          | 492f3783b824fb976eac36c0623337a7fd7440b95095581eb81687c71e802943\n+          |ValueContractId(AbsoluteContractId(07e7b5534931dfca8e1b485c105bae4e10808bd13ddc8e897f258015f9d921c5))\n+          | fa24d4f2cd646f7e6d7f4e43813e93106d52df42b4272b007d36ba7c9bf21f6b\n+          |ValueContractId(AbsoluteContractId(59b59ad7a6b6066e77b91ced54b8282f0e24e7089944685cb8f22f32fcbc4e1b))\n+          | 65b079e97a8b4804622173ef0c7c86e6bc3b4dbedef9ab7508391b8283279df7\n+          |ValueOptional(None)\n+          | df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119\n+          |ValueOptional(Some(ValueBool(false)))\n+          | 060dc63e5595dffbd161c9ec98bc06fcf67cb22e2e75ecdf0003821388aeee4d\n+          |ValueOptional(Some(ValueBool(true)))\n+          | a1f9a549ddc784959537f084c79ac5564de8080503dfc842a54616337b87d795\n+          |ValueOptional(Some(ValueOptional(None)))\n+          | cbbc48750debb8535093b3deaf88ac7f4cff87425576a58de2bac754acdb4616\n+          |ValueOptional(Some(ValueOptional(Some(ValueBool(false)))))\n+          | 2209dc1ac9031cb0089fbd019a1fa065d54ddcef9487f6469d64f9106dbb0c6a\n+          |ValueList(FrontStack())\n+          | df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119\n+          |ValueList(FrontStack(ValueBool(false)))\n+          | 060dc63e5595dffbd161c9ec98bc06fcf67cb22e2e75ecdf0003821388aeee4d\n+          |ValueList(FrontStack(ValueBool(true)))\n+          | a1f9a549ddc784959537f084c79ac5564de8080503dfc842a54616337b87d795\n+          |ValueList(FrontStack(ValueBool(false),ValueBool(false)))\n+          | e44728408fa247053c017f791d5d2fe87752119c5010006ffc4e098efbaea679\n+          |ValueList(FrontStack(ValueBool(false),ValueBool(true)))\n+          | 4f1366f56ad5b2ebd9738248a63d9d90bbb3b4b2eac3b74713c6bfd852477802\n+          |ValueList(FrontStack(ValueBool(true),ValueBool(false)))\n+          | 06cb0843c56b268bd5fc5373f450e9ee50c49705f3d8d8e33356af5d54ab0315\n+          |ValueTextMap(SortedLookupList())\n+          | df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119\n+          |ValueTextMap(SortedLookupList((a,ValueBool(false))))\n+          | a5da6937a2f4b9d4f58bf5091a2be8560b91d66792de3a69d8a6ca335304e640\n+          |ValueTextMap(SortedLookupList((a,ValueBool(false))))\n+          | a5da6937a2f4b9d4f58bf5091a2be8560b91d66792de3a69d8a6ca335304e640\n+          |ValueTextMap(SortedLookupList((b,ValueBool(false))))\n+          | aa1e21601e11f7ae67f57ed00fdf8a30b7b787ca454693b9ec17495192ebad8e\n+          |ValueTextMap(SortedLookupList((a,ValueBool(false)),(b,ValueBool(false))))\n+          | fc40403816a5de30f0d79bd5c7bf186a6528c58157bc4070abdcad9dcb7fa9d8\n+          |ValueTextMap(SortedLookupList((a,ValueBool(true)),(b,ValueBool(false))))\n+          | 336817ad8e596a47b85b0db035efa84fc72acab9f2f4bb079b93621e79a2be4c\n+          |ValueTextMap(SortedLookupList((a,ValueBool(false)),(b,ValueBool(true))))\n+          | 91e247b396cea58ab670b0767940d360cf1fd541b52444d5b1dcb4d74132d0f9\n+          |ValueTextMap(SortedLookupList((a,ValueBool(false)),(c,ValueBool(false))))\n+          | 10e757f68e9e602f8780440193064fec42a7e2f85bec983d416d171079b7240e\n+          |ValueEnum(Some(Identifier(pkgId,Mod:Color)),Red)\n+          | 3bf7245f74973e912a49c95a28e77d59594f73c78ede8683663d4bf9eca5c37c\n+          |ValueEnum(Some(Identifier(pkgId,Mod:Color)),Green)\n+          | 181bfc4e71007c1dc5406594346ae45a52c2a0bb377800b04e26ce09d8b66004\n+          |ValueEnum(Some(Identifier(pkgId,Mod:ColorBis)),Green)\n+          | 181bfc4e71007c1dc5406594346ae45a52c2a0bb377800b04e26ce09d8b66004\n+          |ValueRecord(Some(Identifier(pkgId,Mod:Unit)),ImmArray())\n+          | df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119\n+          |ValueRecord(Some(Identifier(pkgId,Mod:UnitBis)),ImmArray())\n+          | df3f619804a92fdb4057192dc43dd748ea778adc52bc498ce80524c014b81119\n+          |ValueRecord(Some(Identifier(pkgId,Mod:Tuple)),ImmArray((Some(_1),ValueBool(false)),(Some(_2),ValueBool(false))))\n+          | e44728408fa247053c017f791d5d2fe87752119c5010006ffc4e098efbaea679\n+          |ValueRecord(Some(Identifier(pkgId,Mod:Tuple)),ImmArray((Some(_1),ValueBool(true)),(Some(_2),ValueBool(false))))\n+          | 06cb0843c56b268bd5fc5373f450e9ee50c49705f3d8d8e33356af5d54ab0315\n+          |ValueRecord(Some(Identifier(pkgId,Mod:Tuple)),ImmArray((Some(_1),ValueBool(false)),(Some(_2),ValueBool(true))))\n+          | 4f1366f56ad5b2ebd9738248a63d9d90bbb3b4b2eac3b74713c6bfd852477802\n+          |ValueRecord(Some(Identifier(pkgId,Mod:TupleBis)),ImmArray((Some(_1),ValueBool(false)),(Some(_2),ValueBool(false))))\n+          | e44728408fa247053c017f791d5d2fe87752119c5010006ffc4e098efbaea679\n+          |ValueVariant(Some(Identifier(pkgId,Mod:Either)),Left,ValueBool(false))\n+          | 7ac33585fca214756dfe4b2c4de9283d7682f5a47ae8a78acf7abe266d5f41bc\n+          |ValueVariant(Some(Identifier(pkgId,Mod:Either)),Left,ValueBool(true))\n+          | bd43854d7f0bfe9fc246492fe783c5e1600a764195152cc240dc1750f7c5ce16\n+          |ValueVariant(Some(Identifier(pkgId,Mod:Either)),Right,ValueBool(false))\n+          | 635185b1cff7ebfdbde5045291955d39af1d3c392b30c53d36c06615e5479b24\n+          |ValueVariant(Some(Identifier(pkgId,Mod:EitherBis)),Left,ValueBool(false))\n+          | 7ac33585fca214756dfe4b2c4de9283d7682f5a47ae8a78acf7abe266d5f41bc\n+          |\"\"\".stripMargin"
  }
]