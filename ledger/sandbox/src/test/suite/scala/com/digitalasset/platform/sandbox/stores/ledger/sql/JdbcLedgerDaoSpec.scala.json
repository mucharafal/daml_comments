[
  {
    "id" : "e0039914-ff46-445a-a9ec-734a3dfe4dcb",
    "prId" : 3553,
    "comments" : [
      {
        "id" : "c11d1a4f-9600-48d6-b9c5-29c6d29c1126",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "A mismatching config generation results in `Duplicate`?",
        "createdAt" : "2019-11-26T21:06:54Z",
        "updatedAt" : "2019-11-27T14:09:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "857407bf-434d-4b3a-a848-eb3dadf6fbda",
        "parentId" : "c11d1a4f-9600-48d6-b9c5-29c6d29c1126",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Will rewrite to store a rejection reason instead.",
        "createdAt" : "2019-11-27T09:55:37Z",
        "updatedAt" : "2019-11-27T14:09:02Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "04d3118b43225ee033b4c9bba93102cdc650df6a",
    "line" : null,
    "diffHunk" : "@@ -270,6 +271,140 @@ class JdbcLedgerDaoSpec\n       persistAndLoadRejection(nextExternalOffset())\n     }\n \n+    val defaultConfig = Configuration(\n+      generation = 0,\n+      timeModel = TimeModel.reasonableDefault\n+    )\n+\n+    \"be able to persist and load configuration\" in {\n+      val offset = nextOffset()\n+      for {\n+        startingOffset <- ledgerDao.lookupLedgerEnd()\n+        startingConfig <- ledgerDao.lookupLedgerConfiguration()\n+\n+        response <- ledgerDao.storeConfigurationEntry(\n+          offset,\n+          offset + 1,\n+          None,\n+          Instant.EPOCH,\n+          \"submission-0\",\n+          Ref.LedgerString.assertFromString(\"participant-0\"),\n+          defaultConfig,\n+          None\n+        )\n+        storedConfig <- ledgerDao.lookupLedgerConfiguration()\n+        endingOffset <- ledgerDao.lookupLedgerEnd()\n+      } yield {\n+        response shouldEqual PersistenceResponse.Ok\n+        startingConfig shouldEqual None\n+        storedConfig shouldEqual Some(defaultConfig)\n+        endingOffset shouldEqual (startingOffset + 1)\n+      }\n+    }\n+\n+    \"be able to persist configuration rejection\" in {\n+      val offset = nextOffset()\n+      val participantId = Ref.LedgerString.assertFromString(\"participant-0\")\n+      for {\n+        startingConfig <- ledgerDao.lookupLedgerConfiguration()\n+        proposedConfig = startingConfig.getOrElse(defaultConfig)\n+        response <- ledgerDao.storeConfigurationEntry(\n+          offset,\n+          offset + 1,\n+          None,\n+          Instant.EPOCH,\n+          \"config-rejection-0\",\n+          participantId,\n+          proposedConfig,\n+          Some(\"bad config\")\n+        )\n+        storedConfig <- ledgerDao.lookupLedgerConfiguration()\n+        entries <- ledgerDao.getConfigurationEntries(offset, offset + 1).runWith(Sink.seq)\n+\n+      } yield {\n+        response shouldEqual PersistenceResponse.Ok\n+        startingConfig shouldEqual storedConfig\n+        entries shouldEqual List(\n+          offset -> ConfigurationEntry\n+            .Rejected(\"config-rejection-0\", participantId, \"bad config\", proposedConfig)\n+        )\n+      }\n+    }\n+\n+    \"refuse to persist invalid configuration entry\" in {\n+      val offset0 = nextOffset()\n+      val participantId = Ref.LedgerString.assertFromString(\"participant-0\")\n+      for {\n+        config <- ledgerDao.lookupLedgerConfiguration().map(_.getOrElse(defaultConfig))\n+\n+        // Store a new configuration with a known submission id\n+        resp0 <- ledgerDao.storeConfigurationEntry(\n+          offset0,\n+          offset0 + 1,\n+          None,\n+          Instant.EPOCH,\n+          \"refuse-config-0\",\n+          participantId,\n+          config.copy(generation = config.generation + 1),\n+          None\n+        )\n+        newConfig <- ledgerDao.lookupLedgerConfiguration().map(_.get)\n+\n+        // Submission with duplicate submissionId is rejected\n+        offset1 = nextOffset()\n+        resp1 <- ledgerDao.storeConfigurationEntry(\n+          offset1,\n+          offset1 + 1,\n+          None,\n+          Instant.EPOCH,\n+          \"refuse-config-0\",\n+          participantId,\n+          newConfig.copy(generation = config.generation + 1),\n+          None\n+        )\n+\n+        // Submission with mismatching generation is rejected\n+        offset2 = nextOffset()\n+        resp2 <- ledgerDao.storeConfigurationEntry(\n+          offset2,\n+          offset2 + 1,\n+          None,\n+          Instant.EPOCH,\n+          \"refuse-config-1\",\n+          participantId,\n+          config,\n+          None\n+        )\n+\n+        // Submission with unique submissionId and correct generation is accepted.\n+        offset3 = nextOffset()\n+        lastConfig = newConfig.copy(generation = newConfig.generation + 1)\n+        resp3 <- ledgerDao.storeConfigurationEntry(\n+          offset3,\n+          offset3 + 1,\n+          None,\n+          Instant.EPOCH,\n+          \"refuse-config-2\",\n+          participantId,\n+          lastConfig,\n+          None\n+        )\n+        lastConfigActual <- ledgerDao.lookupLedgerConfiguration().map(_.get)\n+\n+        entries <- ledgerDao.getConfigurationEntries(offset0, offset3 + 1).runWith(Sink.seq)\n+      } yield {\n+        resp0 shouldEqual PersistenceResponse.Ok\n+        resp1 shouldEqual PersistenceResponse.Duplicate\n+        resp2 shouldEqual PersistenceResponse.Duplicate"
  }
]