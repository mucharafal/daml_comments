[
  {
    "id" : "de6e02eb-0579-4889-ac5f-44b76a2eee7f",
    "prId" : 4034,
    "comments" : [
      {
        "id" : "0690d0eb-3755-49e3-ab0d-2c4c71b9ddd6",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You may want to consider using a Mockito spy here stubbing only the `stateUpdates` call to avoid having to maintain this class definition as well as we evolve participant state interfaces:\r\nhttps://github.com/mockito/mockito/wiki/Using-Spies-(and-Fakes)",
        "createdAt" : "2020-01-14T09:36:59Z",
        "updatedAt" : "2020-01-17T14:01:24Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f264fb2f-30d5-45d4-b90c-20e05b4e078b",
        "parentId" : "0690d0eb-3755-49e3-ab0d-2c4c71b9ddd6",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Good idea. Done.",
        "createdAt" : "2020-01-14T13:53:12Z",
        "updatedAt" : "2020-01-17T14:01:24Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "06e5463545d129fc32a2c0ab6be1bf86d413c698",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,280 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.server.damlonx.reference.v2\n+\n+import java.util.UUID\n+import java.util.concurrent.CompletionStage\n+\n+import akka.NotUsed\n+import akka.actor.ActorSystem\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.Source\n+import ch.qos.logback.classic.Level\n+import com.codahale.metrics.SharedMetricRegistries\n+import com.daml.ledger.api.server.damlonx.reference.v2.IndexerIT._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.LedgerString\n+import com.digitalasset.daml.lf.data.{Ref, Time}\n+import com.digitalasset.daml_lf_dev.DamlLf\n+import com.digitalasset.ledger.api.health.HealthStatus\n+import com.digitalasset.platform.common.logging.TestNamedLoggerFactory\n+import com.digitalasset.platform.indexer.{\n+  IndexerConfig,\n+  IndexerStartupMode,\n+  RecoveringIndexer,\n+  StandaloneIndexerServer\n+}\n+import com.digitalasset.platform.resources.Resource\n+import com.digitalasset.platform.sandbox.stores.ledger.sql.dao.{JdbcLedgerDao, LedgerDao}\n+import com.digitalasset.timer.RetryStrategy\n+import org.scalatest.{AsyncWordSpec, BeforeAndAfterEach, Matchers}\n+\n+import scala.compat.java8.FutureConverters._\n+import scala.concurrent.duration.{DurationInt, FiniteDuration}\n+import scala.concurrent.{Await, ExecutionContext}\n+\n+class IndexerIT extends AsyncWordSpec with Matchers with BeforeAndAfterEach {\n+  private[this] implicit var actorSystem: ActorSystem = _\n+  private[this] implicit var materializer: Materializer = _\n+\n+  override def beforeEach(): Unit = {\n+    super.beforeEach()\n+    actorSystem = ActorSystem(getClass.getSimpleName)\n+    materializer = Materializer(actorSystem)\n+  }\n+\n+  override def afterEach(): Unit = {\n+    loggerFactory.cleanup()\n+    materializer.shutdown()\n+    Await.result(actorSystem.terminate(), 10.seconds)\n+    super.afterEach()\n+  }\n+\n+  \"indexer\" should {\n+    \"index the participant state\" in {\n+      val (participantState, server, ledgerDao) =\n+        initializeEverything(new InMemoryKVParticipantState(_, _))\n+\n+      for {\n+        _ <- participantState\n+          .allocateParty(\n+            hint = Some(Ref.Party.assertFromString(\"alice\")),\n+            displayName = Some(\"Alice\"),\n+            submissionId = Ref.LedgerString.assertFromString(UUID.randomUUID().toString),\n+          )\n+          .toScala\n+        _ <- eventually { (_, _) =>\n+          ledgerDao.asFuture\n+            .flatMap(_.getParties)\n+            .map(parties => parties.map(_.displayName))\n+            .map(_ shouldBe Seq(Some(\"Alice\")))\n+        }\n+        _ <- server.release()\n+        _ <- ledgerDao.release()\n+      } yield {\n+        loggerFactory.logs(classOf[RecoveringIndexer]) shouldBe Seq(\n+          Level.INFO -> \"Starting Indexer Server\",\n+          Level.INFO -> \"Started Indexer Server\",\n+          Level.INFO -> \"Stopping Indexer Server\",\n+          Level.INFO -> \"Successfully finished processing state updates\",\n+          Level.INFO -> \"Stopped Indexer Server\",\n+        )\n+      }\n+    }\n+\n+    \"index the participant state, even on spurious failures\" in {\n+      val (participantState, server, ledgerDao) = initializeEverything(\n+        (participantId, ledgerId) =>\n+          new ParticipantStateWhichFailsOften(\n+            new InMemoryKVParticipantState(participantId, ledgerId)))\n+\n+      for {\n+        _ <- participantState\n+          .allocateParty(\n+            hint = Some(Ref.Party.assertFromString(\"alice\")),\n+            displayName = Some(\"Alice\"),\n+            submissionId = Ref.LedgerString.assertFromString(UUID.randomUUID().toString),\n+          )\n+          .toScala\n+        _ <- participantState\n+          .allocateParty(\n+            hint = Some(Ref.Party.assertFromString(\"bob\")),\n+            displayName = Some(\"Bob\"),\n+            submissionId = Ref.LedgerString.assertFromString(UUID.randomUUID().toString),\n+          )\n+          .toScala\n+        _ <- participantState\n+          .allocateParty(\n+            hint = Some(Ref.Party.assertFromString(\"carol\")),\n+            displayName = Some(\"Carol\"),\n+            submissionId = Ref.LedgerString.assertFromString(UUID.randomUUID().toString),\n+          )\n+          .toScala\n+        _ <- eventually { (_, _) =>\n+          ledgerDao.asFuture\n+            .flatMap(_.getParties)\n+            .map(parties => parties.map(_.displayName))\n+            .map(_ shouldBe Seq(Some(\"Alice\"), Some(\"Bob\"), Some(\"Carol\")))\n+        }\n+        _ <- server.release()\n+        _ <- ledgerDao.release()\n+      } yield {\n+        loggerFactory.logs(classOf[RecoveringIndexer]) shouldBe Seq(\n+          Level.INFO -> \"Starting Indexer Server\",\n+          Level.INFO -> \"Started Indexer Server\",\n+          Level.ERROR -> \"Error while running indexer, restart scheduled after 100 milliseconds\",\n+          Level.INFO -> \"Restarting Indexer Server\",\n+          Level.INFO -> \"Restarted Indexer Server\",\n+          Level.ERROR -> \"Error while running indexer, restart scheduled after 100 milliseconds\",\n+          Level.INFO -> \"Restarting Indexer Server\",\n+          Level.INFO -> \"Restarted Indexer Server\",\n+          Level.ERROR -> \"Error while running indexer, restart scheduled after 100 milliseconds\",\n+          Level.INFO -> \"Restarting Indexer Server\",\n+          Level.INFO -> \"Restarted Indexer Server\",\n+          Level.INFO -> \"Stopping Indexer Server\",\n+          Level.INFO -> \"Successfully finished processing state updates\",\n+          Level.INFO -> \"Stopped Indexer Server\",\n+        )\n+      }\n+    }\n+\n+    \"stop when the kill switch is hit after a failure\" in {\n+      val (participantState, server, ledgerDao) = initializeEverything(\n+        (participantId, ledgerId) =>\n+          new ParticipantStateWhichFailsOften(\n+            new InMemoryKVParticipantState(participantId, ledgerId)),\n+        restartDelay = 10.seconds,\n+      )\n+\n+      for {\n+        _ <- ledgerDao.release()\n+        _ <- participantState\n+          .allocateParty(\n+            hint = Some(Ref.Party.assertFromString(\"alice\")),\n+            displayName = Some(\"Alice\"),\n+            submissionId = Ref.LedgerString.assertFromString(UUID.randomUUID().toString),\n+          )\n+          .toScala\n+        _ <- server.release()\n+      } yield {\n+        // stopping the server and logging the error can happen in either order\n+        loggerFactory.logs(classOf[RecoveringIndexer]) should contain theSameElementsAs Seq(\n+          Level.INFO -> \"Starting Indexer Server\",\n+          Level.INFO -> \"Started Indexer Server\",\n+          Level.INFO -> \"Stopping Indexer Server\",\n+          Level.ERROR -> \"Error while running indexer, restart scheduled after 10 seconds\",\n+          Level.INFO -> \"The Indexer Server was stopped, so not restarting\",\n+          Level.INFO -> \"Stopped Indexer Server\",\n+        )\n+      }\n+    }\n+  }\n+\n+  private def initializeEverything(\n+      newParticipantState: (ParticipantId, LedgerString) => ParticipantState,\n+      restartDelay: FiniteDuration = 100.millis,\n+  ): (ParticipantState, Resource[Unit], Resource[LedgerDao]) = {\n+    val id = UUID.randomUUID()\n+    val participantId: ParticipantId = LedgerString.assertFromString(s\"participant-$id\")\n+    val ledgerId = LedgerString.assertFromString(s\"ledger-$id\")\n+    val participantState = newParticipantState(participantId, ledgerId)\n+    val jdbcUrl =\n+      s\"jdbc:h2:mem:${getClass.getSimpleName.toLowerCase()}-$id;db_close_delay=-1;db_close_on_exit=false\"\n+    val serverOwner = new StandaloneIndexerServer(\n+      participantState,\n+      IndexerConfig(\n+        participantId,\n+        jdbcUrl,\n+        startupMode = IndexerStartupMode.MigrateAndStart,\n+        restartDelay = restartDelay,\n+      ),\n+      loggerFactory,\n+      SharedMetricRegistries.getOrCreate(s\"${getClass.getSimpleName}-server\"),\n+    )\n+    val ledgerDaoOwner =\n+      JdbcLedgerDao.owner(\n+        jdbcUrl,\n+        loggerFactory,\n+        SharedMetricRegistries.getOrCreate(s\"${getClass.getSimpleName}-ledger-dao\"),\n+        ExecutionContext.global,\n+      )\n+    val server = serverOwner.acquire()\n+    val ledgerDao = ledgerDaoOwner.acquire()\n+    (participantState, server, ledgerDao)\n+  }\n+}\n+\n+object IndexerIT {\n+  private type ParticipantState = ReadService with WriteService with AutoCloseable\n+\n+  private val eventually = RetryStrategy.exponentialBackoff(10, 10.millis)\n+\n+  private val loggerFactory = TestNamedLoggerFactory(classOf[IndexerIT])\n+\n+  // This class inserts a failure after each state update to force the RecoveringIndexer to restart.\n+  private class ParticipantStateWhichFailsOften(delegate: ParticipantState)\n+      extends DelegatingParticipantState(delegate) {\n+    private var lastFailure: Option[Offset] = None\n+\n+    override def stateUpdates(beginAfter: Option[Offset]): Source[(Offset, Update), NotUsed] =\n+      super\n+        .stateUpdates(beginAfter)\n+        .flatMapConcat {\n+          case value @ (offset, _) =>\n+            if (lastFailure.isEmpty || lastFailure.get < offset) {\n+              lastFailure = Some(offset)\n+              Source.single(value).concat(Source.failed(new StateUpdatesFailedException))\n+            } else {\n+              Source.single(value)\n+            }\n+        }\n+  }\n+\n+  private class DelegatingParticipantState(delegate: ParticipantState)"
  }
]