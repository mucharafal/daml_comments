[
  {
    "id" : "b03501af-e58e-484c-bd29-e65a95812e4f",
    "prId" : 5100,
    "comments" : [
      {
        "id" : "71f4c97c-8b15-45bb-9fa1-411afc9ecf11",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "You can `import Ordering.Implicits._` to then use `t1.max(t2)`.\r\nThis works because `Instant` is `Comparable[Instant]`. and `LowPriorityOrderingImplicits` defines an implicit `Ordering[A]` if there is an implicit `A => Comparable[A]`, which is trivially fulfilled for `Instant`.",
        "createdAt" : "2020-03-20T17:18:43Z",
        "updatedAt" : "2020-03-25T08:01:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d421ae1a437d89063df1c3e40078f52885762eaf",
    "line" : null,
    "diffHunk" : "@@ -75,6 +74,29 @@ final class CommandsValidator(ledgerId: LedgerId) {\n         ),\n       )\n \n+  private def maxTime(t1: Instant, t2: Instant): Instant =\n+    if (t1.isAfter(t2)) t1 else t2"
  },
  {
    "id" : "7bb71e4d-b558-4774-ab1e-cde460ed7f79",
    "prId" : 5100,
    "comments" : [
      {
        "id" : "4ae86069-8268-4c47-ab71-3392d6a257fc",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Cannot",
        "createdAt" : "2020-03-25T11:13:25Z",
        "updatedAt" : "2020-03-25T11:28:29Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d421ae1a437d89063df1c3e40078f52885762eaf",
    "line" : 43,
    "diffHunk" : "@@ -43,15 +45,15 @@ final class CommandsValidator(ledgerId: LedgerId) {\n         .map(domain.ApplicationId(_))\n       commandId <- requireLedgerString(commands.commandId, \"command_id\").map(domain.CommandId(_))\n       submitter <- requireParty(commands.party, \"party\")\n-      let <- requirePresence(commands.ledgerEffectiveTime, \"ledger_effective_time\")\n-      ledgerEffectiveTime = TimestampConversion.toInstant(let)\n-      mrt <- requirePresence(commands.maximumRecordTime, \"maximum_record_time\")\n       commandz <- requireNonEmpty(commands.commands, \"commands\")\n       validatedCommands <- validateInnerCommands(commandz, submitter)\n+      ledgerEffectiveTime <- validateLedgerTime(currentLedgerTime, commands)\n       ledgerEffectiveTimestamp <- Time.Timestamp\n         .fromInstant(ledgerEffectiveTime)\n         .left\n-        .map(invalidField(_, \"ledger_effective_time\"))\n+        .map(_ =>\n+          invalidArgument(\n+            s\"Can not represent command ledger time $ledgerEffectiveTime as a DAML timestamp\"))"
  },
  {
    "id" : "470a97fa-55c4-44c8-a557-8aa95ea2e49f",
    "prId" : 5100,
    "comments" : [
      {
        "id" : "ce10c242-8820-4e85-b400-819a3d225898",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "`at the same time` may be confusing here. Maybe rewrite to `either min_ledger_time_abs or min_ledger_time_rel must be specified but not both`?",
        "createdAt" : "2020-03-25T11:13:49Z",
        "updatedAt" : "2020-03-25T11:28:29Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d421ae1a437d89063df1c3e40078f52885762eaf",
    "line" : 79,
    "diffHunk" : "@@ -75,6 +77,25 @@ final class CommandsValidator(ledgerId: LedgerId) {\n         ),\n       )\n \n+  private def validateLedgerTime(\n+      currentTime: Instant,\n+      commands: ProtoCommands,\n+  ): Either[StatusRuntimeException, Instant] = {\n+    val minLedgerTimeAbs = commands.minLedgerTimeAbs\n+    val minLedgerTimeRel = commands.minLedgerTimeRel\n+\n+    (minLedgerTimeAbs, minLedgerTimeRel) match {\n+      case (None, None) => Right(currentTime)\n+      case (Some(minAbs), None) =>\n+        Right(currentTime.max(TimestampConversion.toInstant(minAbs)))\n+      case (None, Some(minRel)) => Right(currentTime.plus(DurationConversion.fromProto(minRel)))\n+      case (Some(_), Some(_)) =>\n+        Left(\n+          invalidArgument(\n+            \"min_ledger_time_abs can not be specified at the same time as min_ledger_time_rel\"))"
  }
]