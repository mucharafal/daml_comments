[
  {
    "id" : "ce780b7f-765a-4dfc-8c54-90f4668b8aaa",
    "prId" : 1961,
    "comments" : [
      {
        "id" : "26ad49bb-e1d9-45c3-af81-fc59be640f50",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "nitpicking: this method could live on the class itself, does not have to be \"_static_\". Also, you  can drop two `{`a and '}'s",
        "createdAt" : "2019-07-01T15:03:43Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c3f87b2-54bf-4d5a-abf0-c7fd5a5430c2",
        "parentId" : "26ad49bb-e1d9-45c3-af81-fc59be640f50",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I usually favor _\"static\"_ methods unless I'm relying on a specific object's state. I can make it an instance method if you think it belongs there. Do you have a specific reason why you'd prefer it to be an instance method?",
        "createdAt" : "2019-07-01T16:55:49Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5e9000d0-96be-486f-b611-2c55bdd7163d",
        "parentId" : "26ad49bb-e1d9-45c3-af81-fc59be640f50",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Just so it's close to where it's used. I tend not put too many functions on `objects`, even if they are stateless, unless they need to have wider visibility. Putting them on the class instance has no runtime penalty and results in better code cohesion in my opinion. \r\n\r\nThis is a matter of taste I think, don't change it if you don't agree. ",
        "createdAt" : "2019-07-02T06:38:56Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e8e4b5ce2c08b6213cb9a1316617143e6daf0753",
    "line" : null,
    "diffHunk" : "@@ -21,26 +21,44 @@ import scalaz.syntax.tag._\n \n import scala.concurrent.Future\n \n+object GrpcCommandCompletionService {\n+\n+  private[this] val completionStreamDefaultOffset =\n+    LedgerOffset.of(LedgerOffset.Value.Boundary(LedgerOffset.LedgerBoundary.LEDGER_END))\n+\n+  private def fillInWithDefaults(request: CompletionStreamRequest): CompletionStreamRequest = {"
  },
  {
    "id" : "9f50864b-f321-4f0d-b152-e168e5406e58",
    "prId" : 1961,
    "comments" : [
      {
        "id" : "dfc6304a-88d5-454c-85fb-d7db1246565c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "In other services/validators we followed the approach that the domain object closely resembles the semantics of the ledger api in terms of optional/required fields. This means that the domain `CompletionStreamRequest` should get an optional `end: Option[LedgerOffset]` field, that is then filled in with the LedgerEnd logic in the implementation of the `domain.CommandCompletionService`. You can look at a similarly shaped pattern for the `GrpcTransactionService`, `TransactionServiceRequestValidator`, and `GetTransactionsRequest#end`.",
        "createdAt" : "2019-07-01T15:08:50Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a6e23eeb-0c2d-454e-8584-06fca0f3809c",
        "parentId" : "dfc6304a-88d5-454c-85fb-d7db1246565c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by ~https://github.com/digital-asset/daml/pull/1961/commits/1f8fae9ab62c717e1424427319070ee4e186564f~ https://github.com/digital-asset/daml/pull/1961/commits/a331839a8e905f80f898c193e078e7de051e5608",
        "createdAt" : "2019-07-01T17:05:40Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e8e4b5ce2c08b6213cb9a1316617143e6daf0753",
    "line" : null,
    "diffHunk" : "@@ -21,26 +21,44 @@ import scalaz.syntax.tag._\n \n import scala.concurrent.Future\n \n+object GrpcCommandCompletionService {\n+\n+  private[this] val completionStreamDefaultOffset =\n+    LedgerOffset.of(LedgerOffset.Value.Boundary(LedgerOffset.LedgerBoundary.LEDGER_END))\n+\n+  private def fillInWithDefaults(request: CompletionStreamRequest): CompletionStreamRequest = {\n+    if (request.offset.isDefined) {\n+      request\n+    } else {\n+      request.withOffset(completionStreamDefaultOffset)\n+    }\n+  }\n+\n+}\n+\n class GrpcCommandCompletionService(\n     ledgerId: LedgerId,\n     service: CommandCompletionService,\n     partyNameChecker: PartyNameChecker\n )(implicit protected val esf: ExecutionSequencerFactory, protected val mat: Materializer)\n     extends CommandCompletionServiceAkkaGrpc {\n \n+  import GrpcCommandCompletionService.fillInWithDefaults\n+\n   private val validator = new CompletionServiceRequestValidator(ledgerId, partyNameChecker)\n \n   override def completionStreamSource(\n-      request: CompletionStreamRequest): Source[CompletionStreamResponse, akka.NotUsed] =\n+      request: CompletionStreamRequest): Source[CompletionStreamResponse, akka.NotUsed] = {\n     validator\n-      .validateCompletionStreamRequest(request)\n+      .validateCompletionStreamRequest(fillInWithDefaults(request))"
  }
]