[
  {
    "id" : "16376025-ec3b-4fbb-8bb8-50fc1ffd3edf",
    "prId" : 3051,
    "comments" : [
      {
        "id" : "86179276-f10a-496e-848e-57dfdb3f5522",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n  private logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)\r\n```",
        "createdAt" : "2019-10-04T11:15:23Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7b086d71418f8dd31bcf1d51c0ae1f9e2877d27c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.server.api.authorization\n+\n+import com.daml.ledger.participant.state.v1.Claims\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.server.api.validation.ErrorFactories._\n+import io.grpc.{Context, StatusRuntimeException}\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+sealed abstract class Authorization\n+case object Authorized extends Authorization\n+final case class NotAuthorized(reason: String = \"You are not authorized to use this resource\")\n+    extends Authorization\n+\n+/** A simple helper that allows services to use authorization claims\n+  * that have been stored by [[AuthorizationInterceptor]].\n+  */\n+object ApiServiceAuthorization {\n+\n+  protected val logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)"
  },
  {
    "id" : "c9d3ae03-6cc2-4883-b287-d725d773c205",
    "prId" : 3051,
    "comments" : [
      {
        "id" : "689e5c75-b360-4a93-90ef-811e28649632",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Since you have to return an exception anyhow, would it not be possible to re-use the `StatusRuntimeException` instead of creating one just to gather the stack?",
        "createdAt" : "2019-10-04T11:17:32Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f5889f25-600d-4f1c-8fdc-e63c8155a3c4",
        "parentId" : "689e5c75-b360-4a93-90ef-811e28649632",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "I have removed the logger line and the `getStackTrace` method, that was a leftover from debugging.",
        "createdAt" : "2019-10-07T10:50:42Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7b086d71418f8dd31bcf1d51c0ae1f9e2877d27c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.server.api.authorization\n+\n+import com.daml.ledger.participant.state.v1.Claims\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.server.api.validation.ErrorFactories._\n+import io.grpc.{Context, StatusRuntimeException}\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+sealed abstract class Authorization\n+case object Authorized extends Authorization\n+final case class NotAuthorized(reason: String = \"You are not authorized to use this resource\")\n+    extends Authorization\n+\n+/** A simple helper that allows services to use authorization claims\n+  * that have been stored by [[AuthorizationInterceptor]].\n+  */\n+object ApiServiceAuthorization {\n+\n+  protected val logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)\n+\n+  private[this] def getStackTrace(t: Throwable): String = {\n+    import java.io.PrintWriter\n+    import java.io.StringWriter\n+    val sw = new StringWriter\n+    val pw = new PrintWriter(sw, true)\n+    t.printStackTrace(pw)\n+    pw.flush()\n+    sw.flush()\n+    sw.toString\n+  }\n+\n+  /** Checks whether the given claims give access to the request.\n+    *\n+    * @param check Given a set of [[Claims]], returns whether the current method is authorized.\n+    *              Typically, the caller compares the request parameters with the given claims.\n+    *\n+    * @return   A [[StatusRuntimeException]] with code `PERMISSION_DENIED` if the request is not authorized,\n+    *           or Unit if the request is authorized.\n+    */\n+  def requireClaims(check: Claims => Authorization): Either[StatusRuntimeException, Unit] = {\n+    val claims = AuthorizationInterceptor.contextKeyClaim.get()\n+    if (claims == null) {\n+      // The current context does not contain any claims.\n+      // Most likely causes:\n+      // - The API server does not use the [[AuthorizationInterceptor]] which is responsible for creating the context\n+      // - This function is called from a thread different from the one used to handle the gRPC call,\n+      //   such as during a `Future.map`. See also [[ApiServiceAuthorization.withContext]].\n+      logger.error(s\"No context key at: ${getStackTrace(new Exception)}\")\n+      Left(internal(\"Context.key.get returned no valid Claims.\"))"
  },
  {
    "id" : "7af0f35f-6ba7-4855-8ed3-c90f02f24606",
    "prId" : 3051,
    "comments" : [
      {
        "id" : "fa12f87d-59d3-4926-b1c3-5be61f63d5d7",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```\r\nscala> None.forall { _ => false }\r\nres1: Boolean = true\r\n```\r\nThis would mean that a command submission without a party would go through authorization and be caught by validation instead. It doesn't seem unreasonable so that the concerns are clearly divided, but I thought it would make sense to raise this point for discussion.",
        "createdAt" : "2019-10-04T11:28:17Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3cdba6a4-3820-4ff6-9780-b795934b3a41",
        "parentId" : "fa12f87d-59d3-4926-b1c3-5be61f63d5d7",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Good point. I think producing a validation error and not an authorization error for empty party lists is the right thing, so I have left the implementation as is and added a comment.\r\n\r\nLet me know if you feel the implementation should change.",
        "createdAt" : "2019-10-07T10:57:30Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0e9e16b6-db8c-4f22-afae-47c499179880",
        "parentId" : "fa12f87d-59d3-4926-b1c3-5be61f63d5d7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Cool, thanks for the clarification. Marking as resolved.",
        "createdAt" : "2019-10-07T13:26:32Z",
        "updatedAt" : "2019-10-07T13:26:32Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7b086d71418f8dd31bcf1d51c0ae1f9e2877d27c",
    "line" : 92,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.server.api.authorization\n+\n+import com.daml.ledger.participant.state.v1.Claims\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.server.api.validation.ErrorFactories._\n+import io.grpc.{Context, StatusRuntimeException}\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+sealed abstract class Authorization\n+case object Authorized extends Authorization\n+final case class NotAuthorized(reason: String = \"You are not authorized to use this resource\")\n+    extends Authorization\n+\n+/** A simple helper that allows services to use authorization claims\n+  * that have been stored by [[AuthorizationInterceptor]].\n+  */\n+object ApiServiceAuthorization {\n+\n+  protected val logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)\n+\n+  private[this] def getStackTrace(t: Throwable): String = {\n+    import java.io.PrintWriter\n+    import java.io.StringWriter\n+    val sw = new StringWriter\n+    val pw = new PrintWriter(sw, true)\n+    t.printStackTrace(pw)\n+    pw.flush()\n+    sw.flush()\n+    sw.toString\n+  }\n+\n+  /** Checks whether the given claims give access to the request.\n+    *\n+    * @param check Given a set of [[Claims]], returns whether the current method is authorized.\n+    *              Typically, the caller compares the request parameters with the given claims.\n+    *\n+    * @return   A [[StatusRuntimeException]] with code `PERMISSION_DENIED` if the request is not authorized,\n+    *           or Unit if the request is authorized.\n+    */\n+  def requireClaims(check: Claims => Authorization): Either[StatusRuntimeException, Unit] = {\n+    val claims = AuthorizationInterceptor.contextKeyClaim.get()\n+    if (claims == null) {\n+      // The current context does not contain any claims.\n+      // Most likely causes:\n+      // - The API server does not use the [[AuthorizationInterceptor]] which is responsible for creating the context\n+      // - This function is called from a thread different from the one used to handle the gRPC call,\n+      //   such as during a `Future.map`. See also [[ApiServiceAuthorization.withContext]].\n+      logger.error(s\"No context key at: ${getStackTrace(new Exception)}\")\n+      Left(internal(\"Context.key.get returned no valid Claims.\"))\n+    } else {\n+      check(claims) match {\n+        case Authorized =>\n+          Right(())\n+        case NotAuthorized(reason) =>\n+          // Be careful with logging errors in order to not leak secrets through log messages\n+          // logger.warn(s\"Rejecting authorization with claims $claims\")\n+          Left(permissionDenied(reason))\n+      }\n+    }\n+  }\n+\n+  /** Executes the given block with the given gRPC context as the current context.\n+    *\n+    * Usage:\n+    * ```\n+    * // Capture the gRPC context in a gRPC thread\n+    * val ctx = Context.current\n+    *\n+    * // Function bar uses ApiServiceAuthorization.requireClaims,\n+    * // but is called from a non-gRPC thread.\n+    * // Wrap it in withContext, so that the gRPC context is available in bar()\n+    * val asyncResult: Future[T] = foo()\n+    *   .flatMap(ApiServiceAuthorization.withContext(ctx)(bar))\n+    * ```\n+    */\n+  def withContext[T](context: Context)(block: => T): T = {\n+    val previous = context.attach()\n+    try block\n+    finally context.detach(previous)\n+  }\n+\n+  def requirePublicClaims(): Either[StatusRuntimeException, Unit] = {\n+    requireClaims(claims => if (claims.isPublic) Authorized else NotAuthorized())\n+  }\n+\n+  def requireAdminClaims(): Either[StatusRuntimeException, Unit] = {\n+    requireClaims(claims => if (claims.isAdmin) Authorized else NotAuthorized())\n+  }\n+\n+  def requireClaimsForAllParties(parties: Set[String]): Either[StatusRuntimeException, Unit] = {\n+    requireClaims(\n+      claims => if (parties.forall(p => claims.canActAs(p))) Authorized else NotAuthorized())\n+  }\n+\n+  def requireClaimsForParty(party: Option[String]): Either[StatusRuntimeException, Unit] = {"
  },
  {
    "id" : "cd34f724-8337-4cd5-99fb-03aa6efc7f7d",
    "prId" : 3051,
    "comments" : [
      {
        "id" : "49970cd5-d522-40a0-afc7-75f42ede4213",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```\r\nscala> Set.empty.forall { _ => false }\r\nres1: Boolean = true\r\n```\r\nThis would mean that a transactions request without a party would go through authorization and be caught by validation instead. It doesn't seem unreasonable so that the concerns are clearly divided, but I thought it would make sense to raise this point for discussion.",
        "createdAt" : "2019-10-04T11:29:29Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7b086d71418f8dd31bcf1d51c0ae1f9e2877d27c",
    "line" : 84,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.server.api.authorization\n+\n+import com.daml.ledger.participant.state.v1.Claims\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.server.api.validation.ErrorFactories._\n+import io.grpc.{Context, StatusRuntimeException}\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+sealed abstract class Authorization\n+case object Authorized extends Authorization\n+final case class NotAuthorized(reason: String = \"You are not authorized to use this resource\")\n+    extends Authorization\n+\n+/** A simple helper that allows services to use authorization claims\n+  * that have been stored by [[AuthorizationInterceptor]].\n+  */\n+object ApiServiceAuthorization {\n+\n+  protected val logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)\n+\n+  private[this] def getStackTrace(t: Throwable): String = {\n+    import java.io.PrintWriter\n+    import java.io.StringWriter\n+    val sw = new StringWriter\n+    val pw = new PrintWriter(sw, true)\n+    t.printStackTrace(pw)\n+    pw.flush()\n+    sw.flush()\n+    sw.toString\n+  }\n+\n+  /** Checks whether the given claims give access to the request.\n+    *\n+    * @param check Given a set of [[Claims]], returns whether the current method is authorized.\n+    *              Typically, the caller compares the request parameters with the given claims.\n+    *\n+    * @return   A [[StatusRuntimeException]] with code `PERMISSION_DENIED` if the request is not authorized,\n+    *           or Unit if the request is authorized.\n+    */\n+  def requireClaims(check: Claims => Authorization): Either[StatusRuntimeException, Unit] = {\n+    val claims = AuthorizationInterceptor.contextKeyClaim.get()\n+    if (claims == null) {\n+      // The current context does not contain any claims.\n+      // Most likely causes:\n+      // - The API server does not use the [[AuthorizationInterceptor]] which is responsible for creating the context\n+      // - This function is called from a thread different from the one used to handle the gRPC call,\n+      //   such as during a `Future.map`. See also [[ApiServiceAuthorization.withContext]].\n+      logger.error(s\"No context key at: ${getStackTrace(new Exception)}\")\n+      Left(internal(\"Context.key.get returned no valid Claims.\"))\n+    } else {\n+      check(claims) match {\n+        case Authorized =>\n+          Right(())\n+        case NotAuthorized(reason) =>\n+          // Be careful with logging errors in order to not leak secrets through log messages\n+          // logger.warn(s\"Rejecting authorization with claims $claims\")\n+          Left(permissionDenied(reason))\n+      }\n+    }\n+  }\n+\n+  /** Executes the given block with the given gRPC context as the current context.\n+    *\n+    * Usage:\n+    * ```\n+    * // Capture the gRPC context in a gRPC thread\n+    * val ctx = Context.current\n+    *\n+    * // Function bar uses ApiServiceAuthorization.requireClaims,\n+    * // but is called from a non-gRPC thread.\n+    * // Wrap it in withContext, so that the gRPC context is available in bar()\n+    * val asyncResult: Future[T] = foo()\n+    *   .flatMap(ApiServiceAuthorization.withContext(ctx)(bar))\n+    * ```\n+    */\n+  def withContext[T](context: Context)(block: => T): T = {\n+    val previous = context.attach()\n+    try block\n+    finally context.detach(previous)\n+  }\n+\n+  def requirePublicClaims(): Either[StatusRuntimeException, Unit] = {\n+    requireClaims(claims => if (claims.isPublic) Authorized else NotAuthorized())\n+  }\n+\n+  def requireAdminClaims(): Either[StatusRuntimeException, Unit] = {\n+    requireClaims(claims => if (claims.isAdmin) Authorized else NotAuthorized())\n+  }\n+\n+  def requireClaimsForAllParties(parties: Set[String]): Either[StatusRuntimeException, Unit] = {"
  },
  {
    "id" : "b8114437-7a07-46c1-9921-98197289c431",
    "prId" : 3051,
    "comments" : [
      {
        "id" : "9ada039b-f482-4abf-9bbc-381fe91e7df6",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I don't see usages of this method in this PR, am I missing something?",
        "createdAt" : "2019-10-04T11:41:11Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e82ddae2-112b-4e2e-b05e-efc605e50e33",
        "parentId" : "9ada039b-f482-4abf-9bbc-381fe91e7df6",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "No usages, but a useful method when dealing with gRPC contexts. We might need it later for implementing canceling requests after claims expiration, so I did not want to delete it.",
        "createdAt" : "2019-10-07T10:52:27Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7b086d71418f8dd31bcf1d51c0ae1f9e2877d27c",
    "line" : 67,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.server.api.authorization\n+\n+import com.daml.ledger.participant.state.v1.Claims\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.server.api.validation.ErrorFactories._\n+import io.grpc.{Context, StatusRuntimeException}\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+sealed abstract class Authorization\n+case object Authorized extends Authorization\n+final case class NotAuthorized(reason: String = \"You are not authorized to use this resource\")\n+    extends Authorization\n+\n+/** A simple helper that allows services to use authorization claims\n+  * that have been stored by [[AuthorizationInterceptor]].\n+  */\n+object ApiServiceAuthorization {\n+\n+  protected val logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)\n+\n+  private[this] def getStackTrace(t: Throwable): String = {\n+    import java.io.PrintWriter\n+    import java.io.StringWriter\n+    val sw = new StringWriter\n+    val pw = new PrintWriter(sw, true)\n+    t.printStackTrace(pw)\n+    pw.flush()\n+    sw.flush()\n+    sw.toString\n+  }\n+\n+  /** Checks whether the given claims give access to the request.\n+    *\n+    * @param check Given a set of [[Claims]], returns whether the current method is authorized.\n+    *              Typically, the caller compares the request parameters with the given claims.\n+    *\n+    * @return   A [[StatusRuntimeException]] with code `PERMISSION_DENIED` if the request is not authorized,\n+    *           or Unit if the request is authorized.\n+    */\n+  def requireClaims(check: Claims => Authorization): Either[StatusRuntimeException, Unit] = {\n+    val claims = AuthorizationInterceptor.contextKeyClaim.get()\n+    if (claims == null) {\n+      // The current context does not contain any claims.\n+      // Most likely causes:\n+      // - The API server does not use the [[AuthorizationInterceptor]] which is responsible for creating the context\n+      // - This function is called from a thread different from the one used to handle the gRPC call,\n+      //   such as during a `Future.map`. See also [[ApiServiceAuthorization.withContext]].\n+      logger.error(s\"No context key at: ${getStackTrace(new Exception)}\")\n+      Left(internal(\"Context.key.get returned no valid Claims.\"))\n+    } else {\n+      check(claims) match {\n+        case Authorized =>\n+          Right(())\n+        case NotAuthorized(reason) =>\n+          // Be careful with logging errors in order to not leak secrets through log messages\n+          // logger.warn(s\"Rejecting authorization with claims $claims\")\n+          Left(permissionDenied(reason))\n+      }\n+    }\n+  }\n+\n+  /** Executes the given block with the given gRPC context as the current context.\n+    *\n+    * Usage:\n+    * ```\n+    * // Capture the gRPC context in a gRPC thread\n+    * val ctx = Context.current\n+    *\n+    * // Function bar uses ApiServiceAuthorization.requireClaims,\n+    * // but is called from a non-gRPC thread.\n+    * // Wrap it in withContext, so that the gRPC context is available in bar()\n+    * val asyncResult: Future[T] = foo()\n+    *   .flatMap(ApiServiceAuthorization.withContext(ctx)(bar))\n+    * ```\n+    */\n+  def withContext[T](context: Context)(block: => T): T = {"
  },
  {
    "id" : "df9cc5dc-a539-4493-a79b-3475342bfab9",
    "prId" : 3051,
    "comments" : [
      {
        "id" : "3979bb21-749b-459e-aaae-2ca860ac8155",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Probably worth considering something that does not leak implementation details?\r\n```suggestion\r\n      Left(internal(\"Cannot retrieve claims from context\"))\r\n```",
        "createdAt" : "2019-10-04T11:44:13Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7b086d71418f8dd31bcf1d51c0ae1f9e2877d27c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.server.api.authorization\n+\n+import com.daml.ledger.participant.state.v1.Claims\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.server.api.validation.ErrorFactories._\n+import io.grpc.{Context, StatusRuntimeException}\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+sealed abstract class Authorization\n+case object Authorized extends Authorization\n+final case class NotAuthorized(reason: String = \"You are not authorized to use this resource\")\n+    extends Authorization\n+\n+/** A simple helper that allows services to use authorization claims\n+  * that have been stored by [[AuthorizationInterceptor]].\n+  */\n+object ApiServiceAuthorization {\n+\n+  protected val logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)\n+\n+  private[this] def getStackTrace(t: Throwable): String = {\n+    import java.io.PrintWriter\n+    import java.io.StringWriter\n+    val sw = new StringWriter\n+    val pw = new PrintWriter(sw, true)\n+    t.printStackTrace(pw)\n+    pw.flush()\n+    sw.flush()\n+    sw.toString\n+  }\n+\n+  /** Checks whether the given claims give access to the request.\n+    *\n+    * @param check Given a set of [[Claims]], returns whether the current method is authorized.\n+    *              Typically, the caller compares the request parameters with the given claims.\n+    *\n+    * @return   A [[StatusRuntimeException]] with code `PERMISSION_DENIED` if the request is not authorized,\n+    *           or Unit if the request is authorized.\n+    */\n+  def requireClaims(check: Claims => Authorization): Either[StatusRuntimeException, Unit] = {\n+    val claims = AuthorizationInterceptor.contextKeyClaim.get()\n+    if (claims == null) {\n+      // The current context does not contain any claims.\n+      // Most likely causes:\n+      // - The API server does not use the [[AuthorizationInterceptor]] which is responsible for creating the context\n+      // - This function is called from a thread different from the one used to handle the gRPC call,\n+      //   such as during a `Future.map`. See also [[ApiServiceAuthorization.withContext]].\n+      logger.error(s\"No context key at: ${getStackTrace(new Exception)}\")\n+      Left(internal(\"Context.key.get returned no valid Claims.\"))"
  },
  {
    "id" : "1cff31f9-0139-4a59-893b-c0735109fc62",
    "prId" : 3051,
    "comments" : [
      {
        "id" : "422c2e9e-8265-423b-a919-af86011ea5ac",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Looks like this can be made into a private helper.",
        "createdAt" : "2019-10-04T11:46:17Z",
        "updatedAt" : "2019-10-07T13:17:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7b086d71418f8dd31bcf1d51c0ae1f9e2877d27c",
    "line" : 32,
    "diffHunk" : "@@ -0,0 +1,111 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.server.api.authorization\n+\n+import com.daml.ledger.participant.state.v1.Claims\n+import com.digitalasset.ledger.api.v1.transaction_filter.TransactionFilter\n+import com.digitalasset.platform.server.api.validation.ErrorFactories._\n+import io.grpc.{Context, StatusRuntimeException}\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+sealed abstract class Authorization\n+case object Authorized extends Authorization\n+final case class NotAuthorized(reason: String = \"You are not authorized to use this resource\")\n+    extends Authorization\n+\n+/** A simple helper that allows services to use authorization claims\n+  * that have been stored by [[AuthorizationInterceptor]].\n+  */\n+object ApiServiceAuthorization {\n+\n+  protected val logger: Logger = LoggerFactory.getLogger(ApiServiceAuthorization.getClass)\n+\n+  private[this] def getStackTrace(t: Throwable): String = {\n+    import java.io.PrintWriter\n+    import java.io.StringWriter\n+    val sw = new StringWriter\n+    val pw = new PrintWriter(sw, true)\n+    t.printStackTrace(pw)\n+    pw.flush()\n+    sw.flush()\n+    sw.toString\n+  }\n+\n+  /** Checks whether the given claims give access to the request.\n+    *\n+    * @param check Given a set of [[Claims]], returns whether the current method is authorized.\n+    *              Typically, the caller compares the request parameters with the given claims.\n+    *\n+    * @return   A [[StatusRuntimeException]] with code `PERMISSION_DENIED` if the request is not authorized,\n+    *           or Unit if the request is authorized.\n+    */\n+  def requireClaims(check: Claims => Authorization): Either[StatusRuntimeException, Unit] = {"
  }
]