[
  {
    "id" : "b32e5a9d-6ee3-4b18-a64f-164bea00bde9",
    "prId" : 3655,
    "comments" : [
      {
        "id" : "146755d0-0495-4a50-94c1-806bda9ed5fc",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "It took me a moment to realize that the parameter is call-by-name.\r\nInstead of using a variable that is closed over, what do you think about an API like this:\r\n\r\n```scala\r\nclass PushHealthReporter(private var _currentHealth: HealthStatus) extends ReportsHealth {\r\n  override def currentHealth(): HealthStatus = this.synchronized { _currentHealth }\r\n  def setUnhealthy: Unit = this.synchronized { _currentHealth = Unhealthy }\r\n  def setHealthy: Unit = this.synchronized { _currentHealth = Healthy }\r\n}\r\n```\r\n\r\nThen instead of `var componentAHealth: HealthStatus = Healthy` we'd use \r\n```scala\r\nval componentAHealth = new PushHealthReporter(Healthy)\r\n// ...\r\neventually {\r\n  // ...\r\n}\r\n\r\ncomponentAHealth.setUnhealthy()\r\neventually {\r\n  // ...\r\n}\r\n```",
        "createdAt" : "2019-11-27T16:56:06Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ccdb501c-5a40-4eb2-b232-896010c41caf",
        "parentId" : "146755d0-0495-4a50-94c1-806bda9ed5fc",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Could do. I'll experiment.",
        "createdAt" : "2019-11-28T08:42:32Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "92c0b9fc-febc-48fb-bcfc-72d893e29984",
        "parentId" : "146755d0-0495-4a50-94c1-806bda9ed5fc",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "To be clear, I don't consider it critical, but was thinking a bit about it, because it wasn't immediately obvious what was going on. Maybe changing the by-name parameter to a more explicit `Unit => Health` is already enough without the extra shenanigans.",
        "createdAt" : "2019-11-28T09:36:55Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "da003f6c-ba39-402d-81e3-3fe4cfac98db",
        "parentId" : "146755d0-0495-4a50-94c1-806bda9ed5fc",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Now using `StubReporter.fixed(Healthy)` or `StubReporter.changing(() => currentHealth)`.",
        "createdAt" : "2019-11-28T10:12:52Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6faa9af0e976c271138c3d4af75a805e9497ba39",
    "line" : null,
    "diffHunk" : "@@ -31,24 +29,253 @@ final class GrpcHealthServiceSpec\n   private implicit val executionContext: ExecutionContext = materializer.executionContext\n \n   \"HealthService\" should {\n-    \"check the current health\" in {\n-      val service = new GrpcHealthService()\n+    \"report SERVING if there are no health checks\" in {\n+      val service = new GrpcHealthService(new HealthChecks)\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n+\n+    \"report SERVING if there is one healthy check\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> healthyComponent))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n \n-      val response = Await.result(service.check(request), patienceConfig.timeout)\n+    \"report NOT_SERVING if there is one unhealthy check\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> unhealthyComponent))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n+    \"report SERVING if all checks are healthy\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> healthyComponent,\n+          \"component B\" -> healthyComponent,\n+          \"component C\" -> healthyComponent,\n+        ))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n \n       response should be(servingResponse)\n     }\n \n+    \"report NOT_SERVING if a single check is unhealthy\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> healthyComponent,\n+          \"component B\" -> unhealthyComponent,\n+          \"component C\" -> healthyComponent,\n+        ))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n+    \"report SERVING when querying a single, healthy component\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> healthyComponent))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component\")), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n+\n+    \"report NOT_SERVING when querying a single, unhealthy component\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> unhealthyComponent))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component\")), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n+    \"report SERVING when querying a healthy component alongside other, unhealthy components\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> healthyComponent,\n+          \"component B\" -> healthyComponent,\n+          \"component C\" -> unhealthyComponent,\n+        ))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component B\")), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n+\n+    \"report NOT_SERVING when querying an unhealthy component alongside other, healthy components\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> unhealthyComponent,\n+          \"component B\" -> healthyComponent,\n+          \"component C\" -> healthyComponent,\n+        ))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component A\")), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n     \"observe changes in health\" in {\n       val responseObserver = new MockServerCallStreamObserver[HealthCheckResponse]\n-      val service = new GrpcHealthService()\n \n-      service.watch(request, responseObserver)\n-      responseObserver.demandResponse()\n+      var componentAHealth: HealthStatus = Healthy\n+      var componentBHealth: HealthStatus = Healthy\n+      var componentCHealth: HealthStatus = Healthy\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> new StubReporter(componentAHealth),"
  },
  {
    "id" : "1d747a2f-ca2b-4855-91a7-3c76c01b5ed5",
    "prId" : 3655,
    "comments" : [
      {
        "id" : "b39c686c-bc1b-46a2-a9ec-15ec8b948bca",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please add a comment that setting `Component C` to unhealthy doesn't produce a new response because due to status didn't change. Naively (due to previous exposure to home-brewed health checking systems) I thought that a new `notServing` would be emitted. (oh, and because up to now the rhythm of the test was do add another response).",
        "createdAt" : "2019-11-27T17:08:24Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "24c3d47d-7dc4-4063-92c3-4ff0f7b3b66c",
        "parentId" : "b39c686c-bc1b-46a2-a9ec-15ec8b948bca",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-11-28T10:13:01Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6faa9af0e976c271138c3d4af75a805e9497ba39",
    "line" : 198,
    "diffHunk" : "@@ -31,24 +29,253 @@ final class GrpcHealthServiceSpec\n   private implicit val executionContext: ExecutionContext = materializer.executionContext\n \n   \"HealthService\" should {\n-    \"check the current health\" in {\n-      val service = new GrpcHealthService()\n+    \"report SERVING if there are no health checks\" in {\n+      val service = new GrpcHealthService(new HealthChecks)\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n+\n+    \"report SERVING if there is one healthy check\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> healthyComponent))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n \n-      val response = Await.result(service.check(request), patienceConfig.timeout)\n+    \"report NOT_SERVING if there is one unhealthy check\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> unhealthyComponent))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n+    \"report SERVING if all checks are healthy\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> healthyComponent,\n+          \"component B\" -> healthyComponent,\n+          \"component C\" -> healthyComponent,\n+        ))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n \n       response should be(servingResponse)\n     }\n \n+    \"report NOT_SERVING if a single check is unhealthy\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> healthyComponent,\n+          \"component B\" -> unhealthyComponent,\n+          \"component C\" -> healthyComponent,\n+        ))\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n+    \"report SERVING when querying a single, healthy component\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> healthyComponent))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component\")), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n+\n+    \"report NOT_SERVING when querying a single, unhealthy component\" in {\n+      val service = new GrpcHealthService(new HealthChecks(\"component\" -> unhealthyComponent))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component\")), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n+    \"report SERVING when querying a healthy component alongside other, unhealthy components\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> healthyComponent,\n+          \"component B\" -> healthyComponent,\n+          \"component C\" -> unhealthyComponent,\n+        ))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component B\")), patienceConfig.timeout)\n+\n+      response should be(servingResponse)\n+    }\n+\n+    \"report NOT_SERVING when querying an unhealthy component alongside other, healthy components\" in {\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> unhealthyComponent,\n+          \"component B\" -> healthyComponent,\n+          \"component C\" -> healthyComponent,\n+        ))\n+\n+      val response =\n+        Await.result(service.check(serviceRequestFor(\"component A\")), patienceConfig.timeout)\n+\n+      response should be(notServingResponse)\n+    }\n+\n     \"observe changes in health\" in {\n       val responseObserver = new MockServerCallStreamObserver[HealthCheckResponse]\n-      val service = new GrpcHealthService()\n \n-      service.watch(request, responseObserver)\n-      responseObserver.demandResponse()\n+      var componentAHealth: HealthStatus = Healthy\n+      var componentBHealth: HealthStatus = Healthy\n+      var componentCHealth: HealthStatus = Healthy\n+      val service = new GrpcHealthService(\n+        new HealthChecks(\n+          \"component A\" -> new StubReporter(componentAHealth),\n+          \"component B\" -> new StubReporter(componentBHealth),\n+          \"component C\" -> new StubReporter(componentCHealth),\n+        ),\n+        maximumWatchFrequency = 1.millisecond,\n+      )\n+\n+      service.watch(allServicesRequest, responseObserver)\n+      responseObserver.demandResponse(count = 5)\n \n       eventually {\n         responseObserver.elements should be(Vector(servingResponse))\n       }\n+\n+      componentBHealth = Unhealthy\n+      eventually {\n+        responseObserver.elements should be(Vector(servingResponse, notServingResponse))\n+      }\n+\n+      componentBHealth = Healthy\n+      eventually {\n+        responseObserver.elements should be(\n+          Vector(servingResponse, notServingResponse, servingResponse))\n+      }\n+\n+      componentAHealth = Unhealthy\n+      eventually {\n+        responseObserver.elements should be(\n+          Vector(servingResponse, notServingResponse, servingResponse, notServingResponse))\n+      }\n+\n+      componentCHealth = Unhealthy\n+      eventually {\n+        responseObserver.elements should be(\n+          Vector(servingResponse, notServingResponse, servingResponse, notServingResponse))"
  },
  {
    "id" : "90c92d53-cda3-43e0-9550-4d1bd2dd7326",
    "prId" : 3655,
    "comments" : [
      {
        "id" : "25724410-8a89-45a1-965e-47325708d886",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "You can probably make an `AsyncWordSpec` out of this since most of the test have to deal with `Future`s. This would allow you to drop a log of `Await.result`.",
        "createdAt" : "2019-11-28T12:11:56Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c3bd223d-6843-41c1-932a-941cf3335c06",
        "parentId" : "25724410-8a89-45a1-965e-47325708d886",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "And you could also drop the `executionContext`, which would already be in scope for the test.",
        "createdAt" : "2019-11-28T12:14:14Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a23b939d-6768-429b-bb80-bf05830ec088",
        "parentId" : "25724410-8a89-45a1-965e-47325708d886",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "This fell off my to-do list. Cheers for the reminder!",
        "createdAt" : "2019-11-28T13:09:12Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6faa9af0e976c271138c3d4af75a805e9497ba39",
    "line" : null,
    "diffHunk" : "@@ -3,22 +3,20 @@\n \n package com.digitalasset.platform.server.api.services.grpc\n \n+import com.digitalasset.grpc.GrpcException\n import com.digitalasset.grpc.adapter.server.rs.MockServerCallStreamObserver\n+import com.digitalasset.ledger.api.health._\n import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.digitalasset.platform.server.api.services.grpc.GrpcHealthService._\n import com.digitalasset.platform.server.api.services.grpc.GrpcHealthServiceSpec._\n import io.grpc.health.v1.health.{HealthCheckRequest, HealthCheckResponse}\n import org.scalatest.concurrent.Eventually\n import org.scalatest.time.{Second, Span}\n import org.scalatest.{Matchers, WordSpec}\n \n+import scala.concurrent.duration.DurationInt\n import scala.concurrent.{Await, ExecutionContext}\n \n-object GrpcHealthServiceSpec {\n-  private val request = HealthCheckRequest()\n-\n-  private val servingResponse = HealthCheckResponse(HealthCheckResponse.ServingStatus.SERVING)\n-}\n-\n final class GrpcHealthServiceSpec\n     extends WordSpec"
  },
  {
    "id" : "652a6fc7-fdd4-4065-b5b2-adf5cb08a9ed",
    "prId" : 3655,
    "comments" : [
      {
        "id" : "1a8de033-619d-48c2-830f-3101f1a6977e",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n      response shouldBe servingResponse\r\n```\r\nAn alternative, if you wish.",
        "createdAt" : "2019-11-28T12:12:46Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "58090017-0f3a-4fc4-ac3f-3c4ee08e5721",
        "parentId" : "1a8de033-619d-48c2-830f-3101f1a6977e",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I prefer `should be(…)` because often I want to use `should equal(…)` or `should contain(…)`, etc. I like them to be uniform. Happy to change them if it's more consistent though.",
        "createdAt" : "2019-11-28T13:09:52Z",
        "updatedAt" : "2019-11-29T13:33:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6faa9af0e976c271138c3d4af75a805e9497ba39",
    "line" : null,
    "diffHunk" : "@@ -31,24 +29,269 @@ final class GrpcHealthServiceSpec\n   private implicit val executionContext: ExecutionContext = materializer.executionContext\n \n   \"HealthService\" should {\n-    \"check the current health\" in {\n-      val service = new GrpcHealthService()\n+    \"report SERVING if there are no health checks\" in {\n+      val service = new GrpcHealthService(new HealthChecks)\n+\n+      val response = Await.result(service.check(allServicesRequest), patienceConfig.timeout)\n+\n+      response should be(servingResponse)"
  }
]