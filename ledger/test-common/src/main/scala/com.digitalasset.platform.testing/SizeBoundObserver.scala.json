[
  {
    "id" : "67a4dbc5-7ad9-4bca-9820-3e0c0d9adb19",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "0485af89-1595-4f97-9a63-8d532d00930c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I think this should be marked as `@volatile`. I assume that gRPC won't guarantee to always run the stream observer on a single thread?",
        "createdAt" : "2019-08-30T15:03:51Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f930768a-ed7b-4204-bcf9-d026fc2fbf57",
        "parentId" : "0485af89-1595-4f97-9a63-8d532d00930c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "We're synchronizing all operations on `promise`. Shouldn't that be enough?",
        "createdAt" : "2019-09-02T09:22:36Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7a8c5557-ea02-48b9-bc20-145ff09fce62",
        "parentId" : "0485af89-1595-4f97-9a63-8d532d00930c",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "You are right of course.",
        "createdAt" : "2019-09-02T09:52:55Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : 33,
    "diffHunk" : "@@ -0,0 +1,53 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.platform.testing\n+\n+import io.grpc.Context\n+import io.grpc.stub.StreamObserver\n+\n+import scala.concurrent.{Future, Promise}\n+\n+object SizeBoundObserver {\n+\n+  def apply[A](n: Int)(attach: StreamObserver[A] => Unit): Future[Vector[A]] = {\n+    if (n < 1) {\n+      Future.failed(\n+        new IllegalArgumentException(\n+          s\"Invalid argument $n, `take` requires a strictly positive integer as an argument\"))\n+    } else {\n+      val observer = new SizeBoundObserver[A](n)\n+      attach(observer)\n+      observer.result\n+    }\n+  }\n+\n+}\n+\n+final class SizeBoundObserver[A](cap: Int) extends StreamObserver[A] {\n+\n+  private[this] val promise = Promise[Vector[A]]()\n+  private[this] val items = Vector.newBuilder[A]\n+\n+  val result: Future[Vector[A]] = promise.future\n+  var counter = 0"
  }
]