[
  {
    "id" : "78041a1d-e4fb-4134-add7-5465c05b3f78",
    "prId" : 3320,
    "comments" : [
      {
        "id" : "30536534-061c-4f9b-8baa-8bf6c6af9e53",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I don't understand what this test is trying to test. Reading the old test doesn't help either. Where does the `Unit` come into play?",
        "createdAt" : "2019-11-04T12:28:38Z",
        "updatedAt" : "2019-11-04T13:05:22Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0eca870a-3054-4b48-a235-9a6206b2e047",
        "parentId" : "30536534-061c-4f9b-8baa-8bf6c6af9e53",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Good to know I'm not the only clueless person reading this. I'll happily rephrase this, could you suggestions.",
        "createdAt" : "2019-11-04T12:36:49Z",
        "updatedAt" : "2019-11-04T13:05:22Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "871c9154-c691-4d46-b253-2f2a4713c059",
        "parentId" : "30536534-061c-4f9b-8baa-8bf6c6af9e53",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Kind of good news: this test is actually a duplicate of one found already in the `TransactionService` suite. I'll remove this one, but it's probably worth spending a couple minutes figuring out the meaning of the existing test.",
        "createdAt" : "2019-11-04T12:47:45Z",
        "updatedAt" : "2019-11-04T13:05:22Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "28c6f471-6eb6-4af1-a08a-99003fe2fc9b",
        "parentId" : "30536534-061c-4f9b-8baa-8bf6c6af9e53",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3320/commits/979de36daf75e8b2382ae37d86ac694511badd63",
        "createdAt" : "2019-11-04T12:48:46Z",
        "updatedAt" : "2019-11-04T13:05:22Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fa4e7cff-697d-4421-b539-de1db7229ea9",
        "parentId" : "30536534-061c-4f9b-8baa-8bf6c6af9e53",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "👍 ",
        "createdAt" : "2019-11-04T15:44:55Z",
        "updatedAt" : "2019-11-04T15:44:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "44a624bfe5e81445317905151f035267eb95e03b",
    "line" : null,
    "diffHunk" : "@@ -262,6 +275,282 @@ final class CommandService(session: LedgerSession) extends LedgerTestSuite(sessi\n     }\n   }\n \n+  private[this] val refuseBadChoice = LedgerTest(\n+    \"CSRefuseBadChoice\",\n+    \"The submission of an exercise of a choice that does not exist should yield INVALID_ARGUMENT\"\n+  ) { context =>\n+    val badChoice = \"THIS_IS_NOT_A_VALID_CHOICE\"\n+    for {\n+      ledger <- context.participant()\n+      party <- ledger.allocateParty()\n+      dummy <- ledger.create(party, Dummy(party))\n+      exercise = dummy.exerciseDummyChoice1(party).command\n+      wrongExercise = exercise.update(_.exercise.choice := badChoice)\n+      wrongRequest <- ledger.submitRequest(party, wrongExercise)\n+      failure <- ledger.submit(wrongRequest).failed\n+    } yield {\n+      assertGrpcError(\n+        failure,\n+        Status.Code.INVALID_ARGUMENT,\n+        s\"Couldn't find requested choice $badChoice\")\n+    }\n+  }\n+\n+  private[this] val returnStackTrace = LedgerTest(\n+    \"CSReturnStackTrace\",\n+    \"A submission resulting in an interpretation error should return the stack trace\"\n+  ) { context =>\n+    for {\n+      ledger <- context.participant()\n+      party <- ledger.allocateParty()\n+      dummy <- ledger.create(party, Dummy(party))\n+      failure <- ledger.exercise(party, dummy.exerciseFailingClone).failed\n+    } yield {\n+      assertGrpcError(\n+        failure,\n+        Status.Code.INVALID_ARGUMENT,\n+        \"Command interpretation error in LF-DAMLe: Interpretation error: Error: User abort: Assertion failed. Details: Last location: [DA.Internal.Assert:20], partial transaction: root node\"\n+      )\n+    }\n+  }\n+\n+  private[this] val exerciseByKey = LedgerTest(\n+    \"CSExerciseByKey\",\n+    \"Exercising by key should be possible only when the corresponding contract is available\"\n+  ) { context =>\n+    val keyString = UUID.randomUUID.toString\n+    for {\n+      ledger <- context.participant()\n+      party <- ledger.allocateParty()\n+      expectedKey = Value(\n+        Value.Sum.Record(\n+          Record(\n+            fields = Seq(\n+              RecordField(\"_1\", Some(Value(Value.Sum.Party(party.unwrap)))),\n+              RecordField(\"_2\", Some(Value(Value.Sum.Text(keyString))))\n+            ))))\n+      failureBeforeCreation <- ledger\n+        .exerciseByKey(\n+          party,\n+          TextKey.id,\n+          expectedKey,\n+          \"TextKeyChoice\",\n+          Value(Value.Sum.Record(Record())))\n+        .failed\n+      _ <- ledger.create(party, TextKey(party, keyString, Primitive.List.empty))\n+      _ <- ledger.exerciseByKey(\n+        party,\n+        TextKey.id,\n+        expectedKey,\n+        \"TextKeyChoice\",\n+        Value(Value.Sum.Record(Record())))\n+      failureAfterConsuming <- ledger\n+        .exerciseByKey(\n+          party,\n+          TextKey.id,\n+          expectedKey,\n+          \"TextKeyChoice\",\n+          Value(Value.Sum.Record(Record())))\n+        .failed\n+    } yield {\n+      assertGrpcError(\n+        failureBeforeCreation,\n+        Status.Code.INVALID_ARGUMENT,\n+        \"dependency error: couldn't find key\"\n+      )\n+      assertGrpcError(\n+        failureAfterConsuming,\n+        Status.Code.INVALID_ARGUMENT,\n+        \"dependency error: couldn't find key\"\n+      )\n+    }\n+  }\n+\n+  private[this] val discloseCreateToObservers =\n+    LedgerTest(\"CSDiscloseCreateToObservers\", \"Disclose create to observers\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(giver, observer1) <- alpha.allocateParties(2)\n+        observer2 <- beta.allocateParty()\n+        template = WithObservers(giver, Primitive.List(observer1, observer2))\n+        _ <- alpha.create(giver, template)\n+        observer1View <- alpha.transactionTrees(observer1)\n+        observer2View <- beta.transactionTrees(observer2)\n+      } yield {\n+        val observer1Created = assertSingleton(\n+          \"The first observer should see exactly one creation\",\n+          observer1View.flatMap(createdEvents))\n+        val observer2Created = assertSingleton(\n+          \"The second observer should see exactly one creation\",\n+          observer2View.flatMap(createdEvents))\n+        assertEquals(\n+          \"The two observers should see the same creation\",\n+          observer1Created.getCreateArguments.fields,\n+          observer2Created.getCreateArguments.fields)\n+        assertEquals(\n+          \"The observers shouls see the created contract\",\n+          observer1Created.getCreateArguments.fields,\n+          encode(template).getRecord.fields\n+        )\n+      }\n+    }\n+\n+  private[this] val discloseExerciseToObservers =\n+    LedgerTest(\"CSDiscloseExerciseToObservers\", \"Diclose exercise to observers\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(giver, observer1) <- alpha.allocateParties(2)\n+        observer2 <- beta.allocateParty()\n+        template = WithObservers(giver, Primitive.List(observer1, observer2))\n+        withObservers <- alpha.create(giver, template)\n+        _ <- alpha.exercise(giver, withObservers.exercisePing)\n+        observer1View <- alpha.transactionTrees(observer1)\n+        observer2View <- beta.transactionTrees(observer2)\n+      } yield {\n+        val observer1Exercise = assertSingleton(\n+          \"The first observer should see exactly one exercise\",\n+          observer1View.flatMap(exercisedEvents))\n+        val observer2Exercise = assertSingleton(\n+          \"The second observer should see exactly one exercise\",\n+          observer2View.flatMap(exercisedEvents))\n+        assert(\n+          observer1Exercise.contractId == observer2Exercise.contractId,\n+          \"The two observers should see the same exercise\")\n+        assert(\n+          observer1Exercise.contractId == withObservers.unwrap,\n+          \"The observers shouls see the exercised contract\")\n+      }\n+    }\n+\n+  private[this] val hugeCommandSubmission =\n+    LedgerTest(\"CSHugeCommandSubmittion\", \"The server should accept a submission with 15 commands\") {\n+      context =>\n+        {\n+          val target = 15\n+          for {\n+            ledger <- context.participant()\n+            party <- ledger.allocateParty()\n+            commands = Vector.fill(target)(Dummy(party).create.command)\n+            request <- ledger.submitAndWaitRequest(party, commands: _*)\n+            _ <- ledger.submitAndWait(request)\n+            acs <- ledger.activeContracts(party)\n+          } yield {\n+            assert(\n+              acs.size == target,\n+              s\"Expected $target contracts to be created, got ${acs.size} instead\")\n+          }\n+        }\n+    }\n+\n+  private[this] val callablePayout =\n+    LedgerTest(\"CSCallablePayout\", \"Run CallablePayout and return the right events\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(giver, newReceiver) <- alpha.allocateParties(2)\n+        receiver <- beta.allocateParty()\n+        callablePayout <- alpha.create(giver, CallablePayout(giver, receiver))\n+        tree <- beta.exercise(receiver, callablePayout.exerciseTransfer(_, newReceiver))\n+      } yield {\n+        val created = assertSingleton(\"There should only be one creation\", createdEvents(tree))\n+        assertEquals(\n+          \"The created event should be the expected one\",\n+          created.getCreateArguments.fields,\n+          encode(CallablePayout(giver, newReceiver)).getRecord.fields)\n+      }\n+    }\n+\n+  private[this] val unitAsArgumentToNothing ="
  },
  {
    "id" : "974aaf69-a65f-44ed-895f-2923f25d4f71",
    "prId" : 3320,
    "comments" : [
      {
        "id" : "035898b3-486a-4264-916a-d501149396a2",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Very strictly speaking this test doesn't test the `CommandService` but the `CommandCompletionService`. Or did you plan to put all the tests that are command related in this file?",
        "createdAt" : "2019-11-04T12:30:03Z",
        "updatedAt" : "2019-11-04T13:05:22Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "632d1f0f-edb1-4746-9270-68a801520778",
        "parentId" : "035898b3-486a-4264-916a-d501149396a2",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'd keep it here for now and move it when we actually port the `CommandCompletionServiceIT` suite. Sounds good?",
        "createdAt" : "2019-11-04T12:37:32Z",
        "updatedAt" : "2019-11-04T13:05:22Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "baf6f267-463a-41f7-9f3e-1ed9b8b9f869",
        "parentId" : "035898b3-486a-4264-916a-d501149396a2",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Sure.",
        "createdAt" : "2019-11-04T15:46:30Z",
        "updatedAt" : "2019-11-04T15:46:30Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "44a624bfe5e81445317905151f035267eb95e03b",
    "line" : 231,
    "diffHunk" : "@@ -262,6 +275,282 @@ final class CommandService(session: LedgerSession) extends LedgerTestSuite(sessi\n     }\n   }\n \n+  private[this] val refuseBadChoice = LedgerTest(\n+    \"CSRefuseBadChoice\",\n+    \"The submission of an exercise of a choice that does not exist should yield INVALID_ARGUMENT\"\n+  ) { context =>\n+    val badChoice = \"THIS_IS_NOT_A_VALID_CHOICE\"\n+    for {\n+      ledger <- context.participant()\n+      party <- ledger.allocateParty()\n+      dummy <- ledger.create(party, Dummy(party))\n+      exercise = dummy.exerciseDummyChoice1(party).command\n+      wrongExercise = exercise.update(_.exercise.choice := badChoice)\n+      wrongRequest <- ledger.submitRequest(party, wrongExercise)\n+      failure <- ledger.submit(wrongRequest).failed\n+    } yield {\n+      assertGrpcError(\n+        failure,\n+        Status.Code.INVALID_ARGUMENT,\n+        s\"Couldn't find requested choice $badChoice\")\n+    }\n+  }\n+\n+  private[this] val returnStackTrace = LedgerTest(\n+    \"CSReturnStackTrace\",\n+    \"A submission resulting in an interpretation error should return the stack trace\"\n+  ) { context =>\n+    for {\n+      ledger <- context.participant()\n+      party <- ledger.allocateParty()\n+      dummy <- ledger.create(party, Dummy(party))\n+      failure <- ledger.exercise(party, dummy.exerciseFailingClone).failed\n+    } yield {\n+      assertGrpcError(\n+        failure,\n+        Status.Code.INVALID_ARGUMENT,\n+        \"Command interpretation error in LF-DAMLe: Interpretation error: Error: User abort: Assertion failed. Details: Last location: [DA.Internal.Assert:20], partial transaction: root node\"\n+      )\n+    }\n+  }\n+\n+  private[this] val exerciseByKey = LedgerTest(\n+    \"CSExerciseByKey\",\n+    \"Exercising by key should be possible only when the corresponding contract is available\"\n+  ) { context =>\n+    val keyString = UUID.randomUUID.toString\n+    for {\n+      ledger <- context.participant()\n+      party <- ledger.allocateParty()\n+      expectedKey = Value(\n+        Value.Sum.Record(\n+          Record(\n+            fields = Seq(\n+              RecordField(\"_1\", Some(Value(Value.Sum.Party(party.unwrap)))),\n+              RecordField(\"_2\", Some(Value(Value.Sum.Text(keyString))))\n+            ))))\n+      failureBeforeCreation <- ledger\n+        .exerciseByKey(\n+          party,\n+          TextKey.id,\n+          expectedKey,\n+          \"TextKeyChoice\",\n+          Value(Value.Sum.Record(Record())))\n+        .failed\n+      _ <- ledger.create(party, TextKey(party, keyString, Primitive.List.empty))\n+      _ <- ledger.exerciseByKey(\n+        party,\n+        TextKey.id,\n+        expectedKey,\n+        \"TextKeyChoice\",\n+        Value(Value.Sum.Record(Record())))\n+      failureAfterConsuming <- ledger\n+        .exerciseByKey(\n+          party,\n+          TextKey.id,\n+          expectedKey,\n+          \"TextKeyChoice\",\n+          Value(Value.Sum.Record(Record())))\n+        .failed\n+    } yield {\n+      assertGrpcError(\n+        failureBeforeCreation,\n+        Status.Code.INVALID_ARGUMENT,\n+        \"dependency error: couldn't find key\"\n+      )\n+      assertGrpcError(\n+        failureAfterConsuming,\n+        Status.Code.INVALID_ARGUMENT,\n+        \"dependency error: couldn't find key\"\n+      )\n+    }\n+  }\n+\n+  private[this] val discloseCreateToObservers =\n+    LedgerTest(\"CSDiscloseCreateToObservers\", \"Disclose create to observers\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(giver, observer1) <- alpha.allocateParties(2)\n+        observer2 <- beta.allocateParty()\n+        template = WithObservers(giver, Primitive.List(observer1, observer2))\n+        _ <- alpha.create(giver, template)\n+        observer1View <- alpha.transactionTrees(observer1)\n+        observer2View <- beta.transactionTrees(observer2)\n+      } yield {\n+        val observer1Created = assertSingleton(\n+          \"The first observer should see exactly one creation\",\n+          observer1View.flatMap(createdEvents))\n+        val observer2Created = assertSingleton(\n+          \"The second observer should see exactly one creation\",\n+          observer2View.flatMap(createdEvents))\n+        assertEquals(\n+          \"The two observers should see the same creation\",\n+          observer1Created.getCreateArguments.fields,\n+          observer2Created.getCreateArguments.fields)\n+        assertEquals(\n+          \"The observers shouls see the created contract\",\n+          observer1Created.getCreateArguments.fields,\n+          encode(template).getRecord.fields\n+        )\n+      }\n+    }\n+\n+  private[this] val discloseExerciseToObservers =\n+    LedgerTest(\"CSDiscloseExerciseToObservers\", \"Diclose exercise to observers\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(giver, observer1) <- alpha.allocateParties(2)\n+        observer2 <- beta.allocateParty()\n+        template = WithObservers(giver, Primitive.List(observer1, observer2))\n+        withObservers <- alpha.create(giver, template)\n+        _ <- alpha.exercise(giver, withObservers.exercisePing)\n+        observer1View <- alpha.transactionTrees(observer1)\n+        observer2View <- beta.transactionTrees(observer2)\n+      } yield {\n+        val observer1Exercise = assertSingleton(\n+          \"The first observer should see exactly one exercise\",\n+          observer1View.flatMap(exercisedEvents))\n+        val observer2Exercise = assertSingleton(\n+          \"The second observer should see exactly one exercise\",\n+          observer2View.flatMap(exercisedEvents))\n+        assert(\n+          observer1Exercise.contractId == observer2Exercise.contractId,\n+          \"The two observers should see the same exercise\")\n+        assert(\n+          observer1Exercise.contractId == withObservers.unwrap,\n+          \"The observers shouls see the exercised contract\")\n+      }\n+    }\n+\n+  private[this] val hugeCommandSubmission =\n+    LedgerTest(\"CSHugeCommandSubmittion\", \"The server should accept a submission with 15 commands\") {\n+      context =>\n+        {\n+          val target = 15\n+          for {\n+            ledger <- context.participant()\n+            party <- ledger.allocateParty()\n+            commands = Vector.fill(target)(Dummy(party).create.command)\n+            request <- ledger.submitAndWaitRequest(party, commands: _*)\n+            _ <- ledger.submitAndWait(request)\n+            acs <- ledger.activeContracts(party)\n+          } yield {\n+            assert(\n+              acs.size == target,\n+              s\"Expected $target contracts to be created, got ${acs.size} instead\")\n+          }\n+        }\n+    }\n+\n+  private[this] val callablePayout =\n+    LedgerTest(\"CSCallablePayout\", \"Run CallablePayout and return the right events\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(giver, newReceiver) <- alpha.allocateParties(2)\n+        receiver <- beta.allocateParty()\n+        callablePayout <- alpha.create(giver, CallablePayout(giver, receiver))\n+        tree <- beta.exercise(receiver, callablePayout.exerciseTransfer(_, newReceiver))\n+      } yield {\n+        val created = assertSingleton(\"There should only be one creation\", createdEvents(tree))\n+        assertEquals(\n+          \"The created event should be the expected one\",\n+          created.getCreateArguments.fields,\n+          encode(CallablePayout(giver, newReceiver)).getRecord.fields)\n+      }\n+    }\n+\n+  private[this] val unitAsArgumentToNothing =\n+    LedgerTest(\"CSUnitAsArgumentToNothing\", \"Return Unit as argument to Nothing\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        template = NothingArgument(party, Primitive.Optional.empty)\n+        _ <- ledger.create(party, template)\n+        acs <- ledger.activeContracts(party)\n+      } yield {\n+        val contract = assertSingleton(\"More than one active contract\", acs)\n+        assertEquals(\n+          \"Contract mismatch\",\n+          contract.getCreateArguments.fields,\n+          encode(template).getRecord.fields)\n+      }\n+    }\n+\n+  private[this] val readyForExercise =\n+    LedgerTest(\n+      \"CSReadyForExercise\",\n+      \"It should be possible to exercise a choice on a created contract\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        factory <- ledger.create(party, DummyFactory(party))\n+        tree <- ledger.exercise(party, factory.exerciseDummyFactoryCall)\n+      } yield {\n+        val exercise = assertSingleton(\"There should only be one exercise\", exercisedEvents(tree))\n+        assert(exercise.contractId == factory.unwrap, \"Contract identifier mismatch\")\n+        assert(exercise.consuming, \"The choice should have been consuming\")\n+        val _ = assertLength(\"Two creations should have occured\", 2, createdEvents(tree))\n+      }\n+    }\n+\n+  private[this] val completions ="
  },
  {
    "id" : "37c2a43a-6735-4057-844a-65ce518e7904",
    "prId" : 2573,
    "comments" : [
      {
        "id" : "c0beada9-4cc2-4f4f-adb0-2d80de4529a7",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Is it not enough to simply send the same request twice? I don't think we need a special command id for that.",
        "createdAt" : "2019-08-16T12:38:13Z",
        "updatedAt" : "2019-08-16T13:57:49Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9bb4c31e-4d3a-4765-b608-92f12ef61749",
        "parentId" : "c0beada9-4cc2-4f4f-adb0-2d80de4529a7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Ah, sure.",
        "createdAt" : "2019-08-16T12:57:19Z",
        "updatedAt" : "2019-08-16T13:57:49Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d51aafa3-0f05-4f31-8364-19f67bb10ba6",
        "parentId" : "c0beada9-4cc2-4f4f-adb0-2d80de4529a7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2573/commits/3b3c89b38b09cd6081c1dad5f58e13b03ff24fb9",
        "createdAt" : "2019-08-16T13:26:56Z",
        "updatedAt" : "2019-08-16T13:57:49Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8bc2c4c323b336a7a9f52540c08a1697d6222824",
    "line" : null,
    "diffHunk" : "@@ -117,43 +121,34 @@ final class CommandService(session: LedgerSession) extends LedgerTestSuite(sessi\n \n   private val resendingSubmitAndWait = LedgerTest(\n     \"CSduplicateSubmitAndWait\",\n-    \"SubmitAndWait should be idempotent when reusing the same command identifier\") {\n-    implicit context =>\n-      val duplicateCommandId = \"CSduplicateSubmitAndWait\"\n-      for {\n-        alice <- allocateParty()\n-        _ <- submitAndWait(\n-          alice,\n-          Dummy(alice).create.command,\n-          _.commands.commandId := duplicateCommandId)\n-        _ <- submitAndWait(\n-          alice,\n-          Dummy(alice).create.command,\n-          _.commands.commandId := duplicateCommandId)\n-        transactions <- flatTransactions(alice)\n-      } yield {\n-        assert(\n-          transactions.size == 1,\n-          s\"Expected only 1 transaction, but received ${transactions.size}\")\n+    \"SubmitAndWait should be idempotent when reusing the same command identifier\") { ledger =>\n+    val duplicateCommandId = \"CSduplicateSubmitAndWait\"\n+    for {\n+      alice <- ledger.allocateParty()\n+      request <- ledger.submitAndWaitRequest(alice, Dummy(alice).create.command)\n+      duplicate = request.update(_.commands.commandId := duplicateCommandId)"
  },
  {
    "id" : "b6390082-1be0-4595-bdfd-3355df989faa",
    "prId" : 2508,
    "comments" : [
      {
        "id" : "0a2ce66c-a4e6-443b-a5e0-79fe55e63150",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n```\r\nNo need to keep commented code.",
        "createdAt" : "2019-08-13T12:11:13Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fd297bdf-cef6-4ec5-8d24-aa4932f86fb8",
        "parentId" : "0a2ce66c-a4e6-443b-a5e0-79fe55e63150",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I just pushed the completed tests where this should be gone.",
        "createdAt" : "2019-08-13T13:39:13Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2f7e5b7654159e3a35c0c4c116f43779c18dedc8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+package com.daml.ledger.api.testtool.tests\n+\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.test.Test.Dummy\n+//import com.digitalasset.ledger.test.Test.Dummy._"
  },
  {
    "id" : "7dcdd731-0581-4be7-b807-5c8f6a0e93ab",
    "prId" : 2508,
    "comments" : [
      {
        "id" : "d3edd3e4-81ab-435f-ad09-03d1401ee105",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "This test is checking a type. I'm not sure this test should exist.",
        "createdAt" : "2019-08-13T12:12:53Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "376b2807-cf3d-4ac1-8652-e5ae8aeef277",
        "parentId" : "d3edd3e4-81ab-435f-ad09-03d1401ee105",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "There is still value probably in checking that the `submitAndWait` has the expected side effect (i.e. creating a contract).",
        "createdAt" : "2019-08-13T13:11:22Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f964f1fe-4cc8-467c-850c-ee4380f94700",
        "parentId" : "d3edd3e4-81ab-435f-ad09-03d1401ee105",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "That's probably better indeed.",
        "createdAt" : "2019-08-13T13:39:47Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2f7e5b7654159e3a35c0c4c116f43779c18dedc8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+package com.daml.ledger.api.testtool.tests\n+\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.test.Test.Dummy\n+//import com.digitalasset.ledger.test.Test.Dummy._\n+import com.google.protobuf.empty.Empty\n+import scalaz.syntax.tag._\n+\n+final class CommandService(session: LedgerSession) extends LedgerTestSuite(session) {\n+  private val submitAndWait = LedgerTest(\"CSsubmitAndWait\", \"SubmitAndWait returns empty\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        empty <- session.bindings.submitAndWait(\n+          alice,\n+          context.applicationId,\n+          context.nextCommandId(),\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(empty == Empty())"
  },
  {
    "id" : "80b78ae7-41ff-4cbb-ba17-9824d835e7e1",
    "prId" : 2508,
    "comments" : [
      {
        "id" : "cc3a17f4-61c6-4779-8a13-c60193b3cc0e",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "If the only possible way for this to fail is to have an empty string, I'm not sure of how useful it is to display the value of `transactionId`.",
        "createdAt" : "2019-08-13T12:15:20Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ecb9dbc9-db2a-40e9-96dd-ff5f6488632c",
        "parentId" : "cc3a17f4-61c6-4779-8a13-c60193b3cc0e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Here I would see more value in trying to fetch the transaction by identifier and verify that it contains the expected transaction with the expected properties.",
        "createdAt" : "2019-08-13T13:12:14Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2f7e5b7654159e3a35c0c4c116f43779c18dedc8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+package com.daml.ledger.api.testtool.tests\n+\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.test.Test.Dummy\n+//import com.digitalasset.ledger.test.Test.Dummy._\n+import com.google.protobuf.empty.Empty\n+import scalaz.syntax.tag._\n+\n+final class CommandService(session: LedgerSession) extends LedgerTestSuite(session) {\n+  private val submitAndWait = LedgerTest(\"CSsubmitAndWait\", \"SubmitAndWait returns empty\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        empty <- session.bindings.submitAndWait(\n+          alice,\n+          context.applicationId,\n+          context.nextCommandId(),\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(empty == Empty())\n+      }\n+  }\n+\n+  private val submitAndWaitForTransactionId = LedgerTest(\n+    \"CSsubmitAndWaitForTransactionId\",\n+    \"SubmitAndWaitForTransactionId returns a transaction id\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transactionId <- session.bindings.submitAndWaitForTransactionId(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '$transactionId'.\")"
  },
  {
    "id" : "ec7b1973-c1f0-436e-851b-786902eff5d2",
    "prId" : 2508,
    "comments" : [
      {
        "id" : "6ab78d56-4124-41e8-a330-dd14b10111ad",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm not entirely sure of the usefulness of this check. It also doesn't seem to match the test description.",
        "createdAt" : "2019-08-13T13:15:37Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2f7e5b7654159e3a35c0c4c116f43779c18dedc8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+package com.daml.ledger.api.testtool.tests\n+\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.test.Test.Dummy\n+//import com.digitalasset.ledger.test.Test.Dummy._\n+import com.google.protobuf.empty.Empty\n+import scalaz.syntax.tag._\n+\n+final class CommandService(session: LedgerSession) extends LedgerTestSuite(session) {\n+  private val submitAndWait = LedgerTest(\"CSsubmitAndWait\", \"SubmitAndWait returns empty\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        empty <- session.bindings.submitAndWait(\n+          alice,\n+          context.applicationId,\n+          context.nextCommandId(),\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(empty == Empty())\n+      }\n+  }\n+\n+  private val submitAndWaitForTransactionId = LedgerTest(\n+    \"CSsubmitAndWaitForTransactionId\",\n+    \"SubmitAndWaitForTransactionId returns a transaction id\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transactionId <- session.bindings.submitAndWaitForTransactionId(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '$transactionId'.\")\n+    }\n+  }\n+\n+  private val submitAndWaitForTransaction = LedgerTest(\n+    \"CSsubmitAndWaitForTransaction\",\n+    \"SubmitAndWaitForTransaction returns a transaction\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transaction <- session.bindings.submitAndWaitForTransaction(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transaction.transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '${transaction.transactionId}'.\")\n+\n+      assert(\n+        transaction.events.size == 1,\n+        s\"The returned transaction should contain 1 event, but contained ${transaction.events.size}\")\n+\n+      val event = transaction.events.head\n+      assert(\n+        event.event.isCreated,\n+        s\"The returned transaction should contain a created-event, but was ${event.event}\"\n+      )\n+\n+      assert(\n+        event.getCreated.getTemplateId == Dummy.id.unwrap,\n+        s\"The template ID of the created-event should by ${Dummy.id}, but was ${event.getCreated.getTemplateId}\"\n+      )\n+    }\n+  }\n+\n+  private val submitAndWaitForTransactionTree = LedgerTest(\n+    \"CSsubmitAndWaitForTransactionTree\",\n+    \"SubmitAndWaitForTransactionTree returns a transaction tree\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transactionTree <- session.bindings.submitAndWaitForTransactionTree(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transactionTree.transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '${transactionTree.transactionId}'.\")\n+\n+      assert(\n+        transactionTree.eventsById.size == 1,\n+        s\"The returned transaction tree should contain 1 event, but contained ${transactionTree.eventsById.size}\")\n+\n+      val event = transactionTree.eventsById.head._2\n+      assert(\n+        event.kind.isCreated,\n+        s\"The returned transaction tree should contain a created-event, but was ${event.kind}\")\n+\n+      assert(\n+        event.getCreated.getTemplateId == Dummy.id.unwrap,\n+        s\"The template ID of the created-event should by ${Dummy.id}, but was ${event.getCreated.getTemplateId}\"\n+      )\n+    }\n+  }\n+\n+  private val resendingSubmitAndWait = LedgerTest(\n+    \"CSduplicateSubmitAndWait\",\n+    \"SubmitAndWait returns Empty for a duplicate submission\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      commandId = context.nextCommandId()\n+      empty1 <- session.bindings.submitAndWait(\n+        alice,\n+        context.applicationId,\n+        commandId,\n+        Seq(Dummy(alice).create.command.command))\n+      empty2 <- session.bindings.submitAndWait(\n+        alice,\n+        context.applicationId,\n+        commandId,\n+        Seq(Dummy(alice).create.command.command))\n+      transactions <- flatTransactions(alice)\n+    } yield {\n+      assert(empty1 == empty2, \"The responses of SubmitAndWait did not match.\")"
  },
  {
    "id" : "99544b67-edfa-41b2-8f00-cb1089949d60",
    "prId" : 2508,
    "comments" : [
      {
        "id" : "4d723418-faf8-4d9f-ba01-78eea512988b",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Could this be better phrased as idempotent with regards to the command identifier?",
        "createdAt" : "2019-08-13T13:19:28Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eba9a99b-8165-4490-bf71-715ce4f9b933",
        "parentId" : "4d723418-faf8-4d9f-ba01-78eea512988b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Note: for this to be implemented the suggested `suggestAndWait` method on the `LedgerContext` should allow to optionally pass an arbitrary command identifier (not using `nextCommandId()` can actually serves us best here as we could specify a command identifier that can make it easier to trace the source of the error in a failing test).",
        "createdAt" : "2019-08-13T13:21:42Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2f7e5b7654159e3a35c0c4c116f43779c18dedc8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+package com.daml.ledger.api.testtool.tests\n+\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.test.Test.Dummy\n+//import com.digitalasset.ledger.test.Test.Dummy._\n+import com.google.protobuf.empty.Empty\n+import scalaz.syntax.tag._\n+\n+final class CommandService(session: LedgerSession) extends LedgerTestSuite(session) {\n+  private val submitAndWait = LedgerTest(\"CSsubmitAndWait\", \"SubmitAndWait returns empty\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        empty <- session.bindings.submitAndWait(\n+          alice,\n+          context.applicationId,\n+          context.nextCommandId(),\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(empty == Empty())\n+      }\n+  }\n+\n+  private val submitAndWaitForTransactionId = LedgerTest(\n+    \"CSsubmitAndWaitForTransactionId\",\n+    \"SubmitAndWaitForTransactionId returns a transaction id\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transactionId <- session.bindings.submitAndWaitForTransactionId(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '$transactionId'.\")\n+    }\n+  }\n+\n+  private val submitAndWaitForTransaction = LedgerTest(\n+    \"CSsubmitAndWaitForTransaction\",\n+    \"SubmitAndWaitForTransaction returns a transaction\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transaction <- session.bindings.submitAndWaitForTransaction(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transaction.transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '${transaction.transactionId}'.\")\n+\n+      assert(\n+        transaction.events.size == 1,\n+        s\"The returned transaction should contain 1 event, but contained ${transaction.events.size}\")\n+\n+      val event = transaction.events.head\n+      assert(\n+        event.event.isCreated,\n+        s\"The returned transaction should contain a created-event, but was ${event.event}\"\n+      )\n+\n+      assert(\n+        event.getCreated.getTemplateId == Dummy.id.unwrap,\n+        s\"The template ID of the created-event should by ${Dummy.id}, but was ${event.getCreated.getTemplateId}\"\n+      )\n+    }\n+  }\n+\n+  private val submitAndWaitForTransactionTree = LedgerTest(\n+    \"CSsubmitAndWaitForTransactionTree\",\n+    \"SubmitAndWaitForTransactionTree returns a transaction tree\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transactionTree <- session.bindings.submitAndWaitForTransactionTree(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transactionTree.transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '${transactionTree.transactionId}'.\")\n+\n+      assert(\n+        transactionTree.eventsById.size == 1,\n+        s\"The returned transaction tree should contain 1 event, but contained ${transactionTree.eventsById.size}\")\n+\n+      val event = transactionTree.eventsById.head._2\n+      assert(\n+        event.kind.isCreated,\n+        s\"The returned transaction tree should contain a created-event, but was ${event.kind}\")\n+\n+      assert(\n+        event.getCreated.getTemplateId == Dummy.id.unwrap,\n+        s\"The template ID of the created-event should by ${Dummy.id}, but was ${event.getCreated.getTemplateId}\"\n+      )\n+    }\n+  }\n+\n+  private val resendingSubmitAndWait = LedgerTest(\n+    \"CSduplicateSubmitAndWait\",\n+    \"SubmitAndWait returns Empty for a duplicate submission\") { implicit context =>"
  },
  {
    "id" : "fb4aaf9a-d094-4b67-b482-d3f982ab327b",
    "prId" : 2508,
    "comments" : [
      {
        "id" : "12a12526-b0b2-4b81-b7e7-8eafaf89ec0b",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "We can probably enable this test by allowing to optionally pass a ledger identifier (as suggested before for command identifiers). I would suggest these methods to actually being explicitly named as to make clear that these methods are to be used to generate specific test conditions (i.e. repeating command identifier and invalid ledger identifiers).",
        "createdAt" : "2019-08-13T13:24:13Z",
        "updatedAt" : "2019-08-15T14:01:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2f7e5b7654159e3a35c0c4c116f43779c18dedc8",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+package com.daml.ledger.api.testtool.tests\n+\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.test.Test.Dummy\n+//import com.digitalasset.ledger.test.Test.Dummy._\n+import com.google.protobuf.empty.Empty\n+import scalaz.syntax.tag._\n+\n+final class CommandService(session: LedgerSession) extends LedgerTestSuite(session) {\n+  private val submitAndWait = LedgerTest(\"CSsubmitAndWait\", \"SubmitAndWait returns empty\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        empty <- session.bindings.submitAndWait(\n+          alice,\n+          context.applicationId,\n+          context.nextCommandId(),\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(empty == Empty())\n+      }\n+  }\n+\n+  private val submitAndWaitForTransactionId = LedgerTest(\n+    \"CSsubmitAndWaitForTransactionId\",\n+    \"SubmitAndWaitForTransactionId returns a transaction id\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transactionId <- session.bindings.submitAndWaitForTransactionId(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '$transactionId'.\")\n+    }\n+  }\n+\n+  private val submitAndWaitForTransaction = LedgerTest(\n+    \"CSsubmitAndWaitForTransaction\",\n+    \"SubmitAndWaitForTransaction returns a transaction\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transaction <- session.bindings.submitAndWaitForTransaction(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transaction.transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '${transaction.transactionId}'.\")\n+\n+      assert(\n+        transaction.events.size == 1,\n+        s\"The returned transaction should contain 1 event, but contained ${transaction.events.size}\")\n+\n+      val event = transaction.events.head\n+      assert(\n+        event.event.isCreated,\n+        s\"The returned transaction should contain a created-event, but was ${event.event}\"\n+      )\n+\n+      assert(\n+        event.getCreated.getTemplateId == Dummy.id.unwrap,\n+        s\"The template ID of the created-event should by ${Dummy.id}, but was ${event.getCreated.getTemplateId}\"\n+      )\n+    }\n+  }\n+\n+  private val submitAndWaitForTransactionTree = LedgerTest(\n+    \"CSsubmitAndWaitForTransactionTree\",\n+    \"SubmitAndWaitForTransactionTree returns a transaction tree\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      transactionTree <- session.bindings.submitAndWaitForTransactionTree(\n+        alice,\n+        context.applicationId,\n+        context.nextCommandId(),\n+        Seq(Dummy(alice).create.command.command))\n+    } yield {\n+      assert(\n+        transactionTree.transactionId.nonEmpty,\n+        s\"The returned transaction ID should be a non empty string, but was '${transactionTree.transactionId}'.\")\n+\n+      assert(\n+        transactionTree.eventsById.size == 1,\n+        s\"The returned transaction tree should contain 1 event, but contained ${transactionTree.eventsById.size}\")\n+\n+      val event = transactionTree.eventsById.head._2\n+      assert(\n+        event.kind.isCreated,\n+        s\"The returned transaction tree should contain a created-event, but was ${event.kind}\")\n+\n+      assert(\n+        event.getCreated.getTemplateId == Dummy.id.unwrap,\n+        s\"The template ID of the created-event should by ${Dummy.id}, but was ${event.getCreated.getTemplateId}\"\n+      )\n+    }\n+  }\n+\n+  private val resendingSubmitAndWait = LedgerTest(\n+    \"CSduplicateSubmitAndWait\",\n+    \"SubmitAndWait returns Empty for a duplicate submission\") { implicit context =>\n+    for {\n+      alice <- allocateParty()\n+      commandId = context.nextCommandId()\n+      empty1 <- session.bindings.submitAndWait(\n+        alice,\n+        context.applicationId,\n+        commandId,\n+        Seq(Dummy(alice).create.command.command))\n+      empty2 <- session.bindings.submitAndWait(\n+        alice,\n+        context.applicationId,\n+        commandId,\n+        Seq(Dummy(alice).create.command.command))\n+      transactions <- flatTransactions(alice)\n+    } yield {\n+      assert(empty1 == empty2, \"The responses of SubmitAndWait did not match.\")\n+      assert(\n+        transactions.size == 1,\n+        s\"Expected only 1 transaction, but received ${transactions.size}\")\n+\n+    }\n+  }\n+\n+  private val resendingSubmitAndWaitForTransactionId = LedgerTest(\n+    \"CSduplicateSubmitAndWaitForTransactionId\",\n+    \"SubmitAndWaitForTransactionId returns the same transaction ID for a duplicate submission\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        commandId = context.nextCommandId()\n+        transactionId1 <- session.bindings.submitAndWaitForTransactionId(\n+          alice,\n+          context.applicationId,\n+          commandId,\n+          Seq(Dummy(alice).create.command.command))\n+        transactionId2 <- session.bindings.submitAndWaitForTransactionId(\n+          alice,\n+          context.applicationId,\n+          commandId,\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(\n+          transactionId1 == transactionId2,\n+          s\"The transaction IDs did not match: transactionId1=$transactionId1, transactionId2=$transactionId2\")\n+      }\n+  }\n+\n+  private val resendingSubmitAndWaitForTransaction = LedgerTest(\n+    \"CSduplicateSubmitAndWaitForTransaction\",\n+    \"SubmitAndWaitForTransaction returns the same transaction for a duplicate submission\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        commandId = context.nextCommandId()\n+        transaction1 <- session.bindings.submitAndWaitForTransaction(\n+          alice,\n+          context.applicationId,\n+          commandId,\n+          Seq(Dummy(alice).create.command.command))\n+        transaction2 <- session.bindings.submitAndWaitForTransaction(\n+          alice,\n+          context.applicationId,\n+          commandId,\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(\n+          transaction1 == transaction2,\n+          s\"The transaction did not match: transaction1=$transaction1, transaction2=$transaction2\")\n+      }\n+  }\n+\n+  private val resendingSubmitAndWaitForTransactionTree = LedgerTest(\n+    \"CSduplicateSubmitAndWaitForTransactionTree\",\n+    \"SubmitAndWaitForTransactionTree returns the same transaction for a duplicate submission\") {\n+    implicit context =>\n+      for {\n+        alice <- allocateParty()\n+        commandId = context.nextCommandId()\n+        transactionTree1 <- session.bindings.submitAndWaitForTransactionTree(\n+          alice,\n+          context.applicationId,\n+          commandId,\n+          Seq(Dummy(alice).create.command.command))\n+        transactionTree2 <- session.bindings.submitAndWaitForTransactionTree(\n+          alice,\n+          context.applicationId,\n+          commandId,\n+          Seq(Dummy(alice).create.command.command))\n+      } yield {\n+        assert(\n+          transactionTree1 == transactionTree2,\n+          s\"The transaction trees did not match: transactionTree1=$transactionTree1, transactionTree2=$transactionTree2\")\n+      }\n+  }\n+\n+//  private val submitAndWaitWithInvalidLedgerId = LedgerTest(\n+//    \"CSsubmitAndWaitInvalidLedgerId\",\n+//    \"SubmitAndWait should fail for invalid ledger ids\") { implicit context =>"
  }
]