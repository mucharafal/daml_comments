[
  {
    "id" : "3419c9b3-ef46-4859-8ee1-b9e4c900a513",
    "prId" : 2282,
    "comments" : [
      {
        "id" : "6a81071c-bcf2-4170-9af1-16c9d921ceb9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Technically you don't need to fetch the ledger end first. You can use the [LedgerBoundary#LEDGER_END](https://github.com/digital-asset/daml/blob/master/ledger-api/grpc-definitions/com/digitalasset/ledger/api/v1/ledger_offset.proto#L31) instead and the ledger will do the \"what's the current ledger end\" check for you.",
        "createdAt" : "2019-07-29T07:09:05Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1f4ca50e-07b7-4a0b-a92c-ab2c47dd63b3",
        "parentId" : "6a81071c-bcf2-4170-9af1-16c9d921ceb9",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Fixed by https://github.com/digital-asset/daml/pull/2282/commits/577409f56cb48d68561a79521e4abac9db92cc59",
        "createdAt" : "2019-07-29T12:30:15Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c0ec2e9d435c3c835828ec8bb046a8d6fe9c4a32",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.acceptance.infrastructure\n+\n+import java.time.Clock\n+import java.util.UUID\n+import java.util.concurrent.TimeUnit\n+\n+import com.digitalasset.ledger.api.v1.admin.party_management_service.{\n+  AllocatePartyRequest,\n+  PartyManagementServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.commands.Command.Command.{Create, Exercise}\n+import com.digitalasset.ledger.api.v1.commands.{Command, Commands, CreateCommand, ExerciseCommand}\n+import com.digitalasset.ledger.api.v1.event.Event\n+import com.digitalasset.ledger.api.v1.event.Event.Event.Created\n+import com.digitalasset.ledger.api.v1.ledger_identity_service.{\n+  GetLedgerIdentityRequest,\n+  LedgerIdentityServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.api.v1.testing.time_service.TimeServiceGrpc\n+import com.digitalasset.ledger.api.v1.transaction.Transaction\n+import com.digitalasset.ledger.api.v1.transaction_filter.{\n+  Filters,\n+  InclusiveFilters,\n+  TransactionFilter\n+}\n+import com.digitalasset.ledger.api.v1.transaction_service.{\n+  GetLedgerEndRequest,\n+  GetTransactionsRequest,\n+  GetTransactionsResponse,\n+  TransactionServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.value.{Identifier, Record, RecordField, Value}\n+import com.digitalasset.platform.sandbox.SandboxServer\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.google.protobuf.timestamp.Timestamp\n+import io.grpc.ManagedChannel\n+import io.grpc.netty.NettyChannelBuilder\n+import io.netty.channel.nio.NioEventLoopGroup\n+import io.netty.util.concurrent.DefaultThreadFactory\n+import org.slf4j.LoggerFactory\n+\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Try}\n+\n+private[acceptance] sealed abstract case class LedgerSession(\n+    configuration: LedgerSessionConfiguration) {\n+\n+  protected val channel: ManagedChannel\n+\n+  def close(): Unit\n+\n+  private lazy val commandService = CommandServiceGrpc.stub(channel)\n+  private lazy val transactionService = TransactionServiceGrpc.stub(channel)\n+  private lazy val ledgerIdentityService = LedgerIdentityServiceGrpc.stub(channel)\n+  private lazy val partyManagementService = PartyManagementServiceGrpc.stub(channel)\n+  private lazy val timeService = TimeServiceGrpc.stub(channel)\n+\n+  private[infrastructure] def ledgerId()(implicit context: ExecutionContext): Future[String] =\n+    for {\n+      response <- ledgerIdentityService.getLedgerIdentity(new GetLedgerIdentityRequest)\n+    } yield response.ledgerId\n+\n+  private[infrastructure] def ledgerEnd()(\n+      implicit context: ExecutionContext): Future[LedgerOffset] =\n+    for {\n+      id <- ledgerId\n+      response <- transactionService.getLedgerEnd(new GetLedgerEndRequest(id))\n+    } yield response.offset.get\n+\n+  private[infrastructure] def transactionFilter(party: String, templateIds: Seq[Identifier]) =\n+    new TransactionFilter(Map(party -> filter(templateIds)))\n+\n+  private[infrastructure] def filter(templateIds: Seq[Identifier]): Filters =\n+    new Filters(if (templateIds.isEmpty) None else Some(new InclusiveFilters(templateIds)))\n+\n+  private[infrastructure] def allocateParty()(implicit context: ExecutionContext): Future[String] =\n+    partyManagementService.allocateParty(new AllocatePartyRequest()).map(_.partyDetails.get.party)\n+\n+  private[infrastructure] def allocateParties(n: Int)(\n+      implicit context: ExecutionContext): Future[Vector[String]] =\n+    Future.sequence(Vector.fill(n)(allocateParty()))\n+\n+  private[infrastructure] def transactionsUntilNow(\n+      begin: LedgerOffset,\n+      party: String,\n+      templateIds: Identifier*)(implicit context: ExecutionContext): Future[Vector[Transaction]] =\n+    for {\n+      id <- ledgerId()\n+      end <- ledgerEnd()"
  },
  {
    "id" : "4e811182-d795-4a92-a107-90e44334b7a3",
    "prId" : 2282,
    "comments" : [
      {
        "id" : "8fee5aba-89aa-4835-9893-18c04f404309",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Keep in mind that you can only receive completions for known applicationIds.",
        "createdAt" : "2019-07-29T07:10:23Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1fa2c487-38f5-4ab0-ba52-9d74f939d7c6",
        "parentId" : "8fee5aba-89aa-4835-9893-18c04f404309",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Each test case will have its own, automatically generated application identifier starting from https://github.com/digital-asset/daml/pull/2282/commits/d8efe8282cb58b5e7bacb4a4b2792e30b848be9e",
        "createdAt" : "2019-07-29T16:13:35Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c0ec2e9d435c3c835828ec8bb046a8d6fe9c4a32",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.acceptance.infrastructure\n+\n+import java.time.Clock\n+import java.util.UUID\n+import java.util.concurrent.TimeUnit\n+\n+import com.digitalasset.ledger.api.v1.admin.party_management_service.{\n+  AllocatePartyRequest,\n+  PartyManagementServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.commands.Command.Command.{Create, Exercise}\n+import com.digitalasset.ledger.api.v1.commands.{Command, Commands, CreateCommand, ExerciseCommand}\n+import com.digitalasset.ledger.api.v1.event.Event\n+import com.digitalasset.ledger.api.v1.event.Event.Event.Created\n+import com.digitalasset.ledger.api.v1.ledger_identity_service.{\n+  GetLedgerIdentityRequest,\n+  LedgerIdentityServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.api.v1.testing.time_service.TimeServiceGrpc\n+import com.digitalasset.ledger.api.v1.transaction.Transaction\n+import com.digitalasset.ledger.api.v1.transaction_filter.{\n+  Filters,\n+  InclusiveFilters,\n+  TransactionFilter\n+}\n+import com.digitalasset.ledger.api.v1.transaction_service.{\n+  GetLedgerEndRequest,\n+  GetTransactionsRequest,\n+  GetTransactionsResponse,\n+  TransactionServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.value.{Identifier, Record, RecordField, Value}\n+import com.digitalasset.platform.sandbox.SandboxServer\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.google.protobuf.timestamp.Timestamp\n+import io.grpc.ManagedChannel\n+import io.grpc.netty.NettyChannelBuilder\n+import io.netty.channel.nio.NioEventLoopGroup\n+import io.netty.util.concurrent.DefaultThreadFactory\n+import org.slf4j.LoggerFactory\n+\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Try}\n+\n+private[acceptance] sealed abstract case class LedgerSession(\n+    configuration: LedgerSessionConfiguration) {\n+\n+  protected val channel: ManagedChannel\n+\n+  def close(): Unit\n+\n+  private lazy val commandService = CommandServiceGrpc.stub(channel)\n+  private lazy val transactionService = TransactionServiceGrpc.stub(channel)\n+  private lazy val ledgerIdentityService = LedgerIdentityServiceGrpc.stub(channel)\n+  private lazy val partyManagementService = PartyManagementServiceGrpc.stub(channel)\n+  private lazy val timeService = TimeServiceGrpc.stub(channel)\n+\n+  private[infrastructure] def ledgerId()(implicit context: ExecutionContext): Future[String] =\n+    for {\n+      response <- ledgerIdentityService.getLedgerIdentity(new GetLedgerIdentityRequest)\n+    } yield response.ledgerId\n+\n+  private[infrastructure] def ledgerEnd()(\n+      implicit context: ExecutionContext): Future[LedgerOffset] =\n+    for {\n+      id <- ledgerId\n+      response <- transactionService.getLedgerEnd(new GetLedgerEndRequest(id))\n+    } yield response.offset.get\n+\n+  private[infrastructure] def transactionFilter(party: String, templateIds: Seq[Identifier]) =\n+    new TransactionFilter(Map(party -> filter(templateIds)))\n+\n+  private[infrastructure] def filter(templateIds: Seq[Identifier]): Filters =\n+    new Filters(if (templateIds.isEmpty) None else Some(new InclusiveFilters(templateIds)))\n+\n+  private[infrastructure] def allocateParty()(implicit context: ExecutionContext): Future[String] =\n+    partyManagementService.allocateParty(new AllocatePartyRequest()).map(_.partyDetails.get.party)\n+\n+  private[infrastructure] def allocateParties(n: Int)(\n+      implicit context: ExecutionContext): Future[Vector[String]] =\n+    Future.sequence(Vector.fill(n)(allocateParty()))\n+\n+  private[infrastructure] def transactionsUntilNow(\n+      begin: LedgerOffset,\n+      party: String,\n+      templateIds: Identifier*)(implicit context: ExecutionContext): Future[Vector[Transaction]] =\n+    for {\n+      id <- ledgerId()\n+      end <- ledgerEnd()\n+      responses <- FiniteStreamObserver[GetTransactionsResponse](\n+        transactionService\n+          .getTransactions(\n+            new GetTransactionsRequest(\n+              ledgerId = id,\n+              begin = Some(begin),\n+              end = Some(end),\n+              filter = Some(transactionFilter(party, templateIds)),\n+              verbose = true\n+            ),\n+            _\n+          ))\n+    } yield responses.flatMap(_.transactions)\n+\n+  private[infrastructure] def clock()(implicit context: ExecutionContext): Future[Clock] =\n+    for (id <- ledgerId()) yield new LedgerClock(id, timeService)\n+\n+  private[infrastructure] def create(\n+      party: String,\n+      templateId: Identifier,\n+      args: (String, Value.Sum)*)(implicit context: ExecutionContext): Future[String] =\n+    for {\n+      id <- ledgerId()\n+      clock <- clock()\n+      now = clock.instant()\n+      inFiveSeconds = now.plusSeconds(5)\n+      tx <- commandService.submitAndWaitForTransaction(\n+        new SubmitAndWaitRequest(\n+          Some(new Commands(\n+            ledgerId = id,\n+            applicationId = UUID.randomUUID().toString,"
  },
  {
    "id" : "ee5e4b0c-5e13-4db4-bcb2-eca00adee52d",
    "prId" : 2282,
    "comments" : [
      {
        "id" : "74088f59-f1e0-42a7-beb5-41cfc5702252",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "At some point we might want to use `workflowId` as well and expose it as parameter.",
        "createdAt" : "2019-07-29T07:11:19Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cd3b5375-d690-4631-bc4f-bbedff06f6d1",
        "parentId" : "74088f59-f1e0-42a7-beb5-41cfc5702252",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'll keep it simple for now, I believe that one application identifier per test case right now is all we need, but I'll definitely introduce this at a later time if we need a more granular control. Probably I'll let the `LedgerTestContext` provide `workflowId`s that can then in turn be used to filter transactions into more fine grained workflows in a test.",
        "createdAt" : "2019-07-29T16:15:03Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c0ec2e9d435c3c835828ec8bb046a8d6fe9c4a32",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.acceptance.infrastructure\n+\n+import java.time.Clock\n+import java.util.UUID\n+import java.util.concurrent.TimeUnit\n+\n+import com.digitalasset.ledger.api.v1.admin.party_management_service.{\n+  AllocatePartyRequest,\n+  PartyManagementServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.commands.Command.Command.{Create, Exercise}\n+import com.digitalasset.ledger.api.v1.commands.{Command, Commands, CreateCommand, ExerciseCommand}\n+import com.digitalasset.ledger.api.v1.event.Event\n+import com.digitalasset.ledger.api.v1.event.Event.Event.Created\n+import com.digitalasset.ledger.api.v1.ledger_identity_service.{\n+  GetLedgerIdentityRequest,\n+  LedgerIdentityServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.api.v1.testing.time_service.TimeServiceGrpc\n+import com.digitalasset.ledger.api.v1.transaction.Transaction\n+import com.digitalasset.ledger.api.v1.transaction_filter.{\n+  Filters,\n+  InclusiveFilters,\n+  TransactionFilter\n+}\n+import com.digitalasset.ledger.api.v1.transaction_service.{\n+  GetLedgerEndRequest,\n+  GetTransactionsRequest,\n+  GetTransactionsResponse,\n+  TransactionServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.value.{Identifier, Record, RecordField, Value}\n+import com.digitalasset.platform.sandbox.SandboxServer\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.google.protobuf.timestamp.Timestamp\n+import io.grpc.ManagedChannel\n+import io.grpc.netty.NettyChannelBuilder\n+import io.netty.channel.nio.NioEventLoopGroup\n+import io.netty.util.concurrent.DefaultThreadFactory\n+import org.slf4j.LoggerFactory\n+\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Try}\n+\n+private[acceptance] sealed abstract case class LedgerSession(\n+    configuration: LedgerSessionConfiguration) {\n+\n+  protected val channel: ManagedChannel\n+\n+  def close(): Unit\n+\n+  private lazy val commandService = CommandServiceGrpc.stub(channel)\n+  private lazy val transactionService = TransactionServiceGrpc.stub(channel)\n+  private lazy val ledgerIdentityService = LedgerIdentityServiceGrpc.stub(channel)\n+  private lazy val partyManagementService = PartyManagementServiceGrpc.stub(channel)\n+  private lazy val timeService = TimeServiceGrpc.stub(channel)\n+\n+  private[infrastructure] def ledgerId()(implicit context: ExecutionContext): Future[String] =\n+    for {\n+      response <- ledgerIdentityService.getLedgerIdentity(new GetLedgerIdentityRequest)\n+    } yield response.ledgerId\n+\n+  private[infrastructure] def ledgerEnd()(\n+      implicit context: ExecutionContext): Future[LedgerOffset] =\n+    for {\n+      id <- ledgerId\n+      response <- transactionService.getLedgerEnd(new GetLedgerEndRequest(id))\n+    } yield response.offset.get\n+\n+  private[infrastructure] def transactionFilter(party: String, templateIds: Seq[Identifier]) =\n+    new TransactionFilter(Map(party -> filter(templateIds)))\n+\n+  private[infrastructure] def filter(templateIds: Seq[Identifier]): Filters =\n+    new Filters(if (templateIds.isEmpty) None else Some(new InclusiveFilters(templateIds)))\n+\n+  private[infrastructure] def allocateParty()(implicit context: ExecutionContext): Future[String] =\n+    partyManagementService.allocateParty(new AllocatePartyRequest()).map(_.partyDetails.get.party)\n+\n+  private[infrastructure] def allocateParties(n: Int)(\n+      implicit context: ExecutionContext): Future[Vector[String]] =\n+    Future.sequence(Vector.fill(n)(allocateParty()))\n+\n+  private[infrastructure] def transactionsUntilNow(\n+      begin: LedgerOffset,\n+      party: String,\n+      templateIds: Identifier*)(implicit context: ExecutionContext): Future[Vector[Transaction]] =\n+    for {\n+      id <- ledgerId()\n+      end <- ledgerEnd()\n+      responses <- FiniteStreamObserver[GetTransactionsResponse](\n+        transactionService\n+          .getTransactions(\n+            new GetTransactionsRequest(\n+              ledgerId = id,\n+              begin = Some(begin),\n+              end = Some(end),\n+              filter = Some(transactionFilter(party, templateIds)),\n+              verbose = true\n+            ),\n+            _\n+          ))\n+    } yield responses.flatMap(_.transactions)\n+\n+  private[infrastructure] def clock()(implicit context: ExecutionContext): Future[Clock] =\n+    for (id <- ledgerId()) yield new LedgerClock(id, timeService)\n+\n+  private[infrastructure] def create(\n+      party: String,\n+      templateId: Identifier,\n+      args: (String, Value.Sum)*)(implicit context: ExecutionContext): Future[String] =\n+    for {\n+      id <- ledgerId()\n+      clock <- clock()\n+      now = clock.instant()\n+      inFiveSeconds = now.plusSeconds(5)\n+      tx <- commandService.submitAndWaitForTransaction(\n+        new SubmitAndWaitRequest(\n+          Some(new Commands("
  },
  {
    "id" : "94309b90-9e29-4216-9866-e1726fd78262",
    "prId" : 2282,
    "comments" : [
      {
        "id" : "61c8a31c-8e4a-45de-b745-198d22f7205a",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Considering that `commands` is the only difference between `create` and `exercise`, maybe we can deduplicate the fluff around it.",
        "createdAt" : "2019-07-29T07:12:48Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "26097660-9aa6-47e9-a9e0-074114cd58e1",
        "parentId" : "61c8a31c-8e4a-45de-b745-198d22f7205a",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2282/commits/5094794b8fe366b4f1ba082f1fb87a8190672797\r\n\r\nThis commit also adds helpers specific for test DAML code.",
        "createdAt" : "2019-07-29T14:52:44Z",
        "updatedAt" : "2019-08-09T14:28:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c0ec2e9d435c3c835828ec8bb046a8d6fe9c4a32",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.acceptance.infrastructure\n+\n+import java.time.Clock\n+import java.util.UUID\n+import java.util.concurrent.TimeUnit\n+\n+import com.digitalasset.ledger.api.v1.admin.party_management_service.{\n+  AllocatePartyRequest,\n+  PartyManagementServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.commands.Command.Command.{Create, Exercise}\n+import com.digitalasset.ledger.api.v1.commands.{Command, Commands, CreateCommand, ExerciseCommand}\n+import com.digitalasset.ledger.api.v1.event.Event\n+import com.digitalasset.ledger.api.v1.event.Event.Event.Created\n+import com.digitalasset.ledger.api.v1.ledger_identity_service.{\n+  GetLedgerIdentityRequest,\n+  LedgerIdentityServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.api.v1.testing.time_service.TimeServiceGrpc\n+import com.digitalasset.ledger.api.v1.transaction.Transaction\n+import com.digitalasset.ledger.api.v1.transaction_filter.{\n+  Filters,\n+  InclusiveFilters,\n+  TransactionFilter\n+}\n+import com.digitalasset.ledger.api.v1.transaction_service.{\n+  GetLedgerEndRequest,\n+  GetTransactionsRequest,\n+  GetTransactionsResponse,\n+  TransactionServiceGrpc\n+}\n+import com.digitalasset.ledger.api.v1.value.{Identifier, Record, RecordField, Value}\n+import com.digitalasset.platform.sandbox.SandboxServer\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.google.protobuf.timestamp.Timestamp\n+import io.grpc.ManagedChannel\n+import io.grpc.netty.NettyChannelBuilder\n+import io.netty.channel.nio.NioEventLoopGroup\n+import io.netty.util.concurrent.DefaultThreadFactory\n+import org.slf4j.LoggerFactory\n+\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Try}\n+\n+private[acceptance] sealed abstract case class LedgerSession(\n+    configuration: LedgerSessionConfiguration) {\n+\n+  protected val channel: ManagedChannel\n+\n+  def close(): Unit\n+\n+  private lazy val commandService = CommandServiceGrpc.stub(channel)\n+  private lazy val transactionService = TransactionServiceGrpc.stub(channel)\n+  private lazy val ledgerIdentityService = LedgerIdentityServiceGrpc.stub(channel)\n+  private lazy val partyManagementService = PartyManagementServiceGrpc.stub(channel)\n+  private lazy val timeService = TimeServiceGrpc.stub(channel)\n+\n+  private[infrastructure] def ledgerId()(implicit context: ExecutionContext): Future[String] =\n+    for {\n+      response <- ledgerIdentityService.getLedgerIdentity(new GetLedgerIdentityRequest)\n+    } yield response.ledgerId\n+\n+  private[infrastructure] def ledgerEnd()(\n+      implicit context: ExecutionContext): Future[LedgerOffset] =\n+    for {\n+      id <- ledgerId\n+      response <- transactionService.getLedgerEnd(new GetLedgerEndRequest(id))\n+    } yield response.offset.get\n+\n+  private[infrastructure] def transactionFilter(party: String, templateIds: Seq[Identifier]) =\n+    new TransactionFilter(Map(party -> filter(templateIds)))\n+\n+  private[infrastructure] def filter(templateIds: Seq[Identifier]): Filters =\n+    new Filters(if (templateIds.isEmpty) None else Some(new InclusiveFilters(templateIds)))\n+\n+  private[infrastructure] def allocateParty()(implicit context: ExecutionContext): Future[String] =\n+    partyManagementService.allocateParty(new AllocatePartyRequest()).map(_.partyDetails.get.party)\n+\n+  private[infrastructure] def allocateParties(n: Int)(\n+      implicit context: ExecutionContext): Future[Vector[String]] =\n+    Future.sequence(Vector.fill(n)(allocateParty()))\n+\n+  private[infrastructure] def transactionsUntilNow(\n+      begin: LedgerOffset,\n+      party: String,\n+      templateIds: Identifier*)(implicit context: ExecutionContext): Future[Vector[Transaction]] =\n+    for {\n+      id <- ledgerId()\n+      end <- ledgerEnd()\n+      responses <- FiniteStreamObserver[GetTransactionsResponse](\n+        transactionService\n+          .getTransactions(\n+            new GetTransactionsRequest(\n+              ledgerId = id,\n+              begin = Some(begin),\n+              end = Some(end),\n+              filter = Some(transactionFilter(party, templateIds)),\n+              verbose = true\n+            ),\n+            _\n+          ))\n+    } yield responses.flatMap(_.transactions)\n+\n+  private[infrastructure] def clock()(implicit context: ExecutionContext): Future[Clock] =\n+    for (id <- ledgerId()) yield new LedgerClock(id, timeService)\n+\n+  private[infrastructure] def create(\n+      party: String,\n+      templateId: Identifier,\n+      args: (String, Value.Sum)*)(implicit context: ExecutionContext): Future[String] =\n+    for {\n+      id <- ledgerId()\n+      clock <- clock()\n+      now = clock.instant()\n+      inFiveSeconds = now.plusSeconds(5)\n+      tx <- commandService.submitAndWaitForTransaction(\n+        new SubmitAndWaitRequest(\n+          Some(new Commands(\n+            ledgerId = id,\n+            applicationId = UUID.randomUUID().toString,\n+            commandId = UUID.randomUUID().toString,\n+            party = party,\n+            ledgerEffectiveTime = Some(new Timestamp(now.getEpochSecond, now.getNano)),\n+            maximumRecordTime =\n+              Some(new Timestamp(inFiveSeconds.getEpochSecond, inFiveSeconds.getNano)),\n+            commands = Seq(\n+              new Command(\n+                Create(\n+                  new CreateCommand(\n+                    Some(templateId),\n+                    Some(new Record(\n+                      fields = args.map {\n+                        case (label, value) =>\n+                          new RecordField(label, Some(new Value(value)))\n+                      }\n+                    ))\n+                  )\n+                )\n+              )\n+            )\n+          ))))\n+    } yield tx.transaction.get.events.collect { case Event(Created(e)) => e.contractId }.head\n+\n+  private[infrastructure] def exercise(\n+      party: String,\n+      templateId: Identifier,\n+      contractId: String,\n+      choice: String,\n+      args: (String, Value.Sum)*\n+  )(implicit context: ExecutionContext): Future[Unit] =\n+    for {\n+      id <- ledgerId()\n+      clock <- clock()\n+      now = clock.instant()\n+      inFiveSeconds = now.plusSeconds(5)\n+      _ <- commandService.submitAndWait(\n+        new SubmitAndWaitRequest(\n+          Some(\n+            new Commands(\n+              ledgerId = id,\n+              applicationId = UUID.randomUUID().toString,\n+              commandId = UUID.randomUUID().toString,\n+              party = party,\n+              ledgerEffectiveTime = Some(new Timestamp(now.getEpochSecond, now.getNano)),\n+              maximumRecordTime =\n+                Some(new Timestamp(inFiveSeconds.getEpochSecond, inFiveSeconds.getNano)),\n+              commands = Seq("
  }
]