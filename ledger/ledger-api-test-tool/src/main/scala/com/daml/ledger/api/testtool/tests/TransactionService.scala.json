[
  {
    "id" : "6acce73a-aea4-425e-81c5-c8bf921681ac",
    "prId" : 4909,
    "comments" : [
      {
        "id" : "569cc290-6d36-4f8e-80eb-9cdf8d944082",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Perhaps use `beta.waitForParties(Seq(alpha), Set(giver, receiver))` before this instead?",
        "createdAt" : "2020-03-11T08:37:49Z",
        "updatedAt" : "2020-03-11T19:18:10Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a6dd8a32-00a4-4bda-b22c-617b9ea5cd13",
        "parentId" : "569cc290-6d36-4f8e-80eb-9cdf8d944082",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I think we mostly went with wrapping in `eventually`.",
        "createdAt" : "2020-03-11T14:13:06Z",
        "updatedAt" : "2020-03-11T19:18:10Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9732d30a-88f6-424c-a467-d6534ab1c3a9",
        "parentId" : "569cc290-6d36-4f8e-80eb-9cdf8d944082",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "If I'm not mistaken `waitForParties` is already part of the test framework allocating the parties for the test. The error is raised when the test is ran with the flag to not wait for parties against a ledger that doesn't expose parties to remote participants.",
        "createdAt" : "2020-03-11T14:16:18Z",
        "updatedAt" : "2020-03-11T19:18:10Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3e69ecd8-2d92-4018-bf0d-9da7f1fe2279",
        "parentId" : "569cc290-6d36-4f8e-80eb-9cdf8d944082",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Ooooh, now I understand. Apologies.",
        "createdAt" : "2020-03-11T14:39:32Z",
        "updatedAt" : "2020-03-11T19:18:10Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0db1a33874140162c8d54c059033ad2c6c5df7ad",
    "line" : 9,
    "diffHunk" : "@@ -898,11 +898,9 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n     case Participants(Participant(alpha, operator, receiver), Participant(beta, giver)) =>\n       for {\n         agreementFactory <- beta.create(giver, AgreementFactory(receiver, giver))\n-        agreement <- alpha\n-          .exerciseAndGetContract[Agreement](\n-            receiver,\n-            agreementFactory.exerciseAgreementFactoryAccept,\n-          )\n+        agreement <- eventually {"
  },
  {
    "id" : "e3e8241b-5c2b-4196-a44a-f9f6e61fc65a",
    "prId" : 4885,
    "comments" : [
      {
        "id" : "bdfe8cc9-cfe4-4c5e-8c2a-520c94f3a571",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Perhaps use `match` instead?\r\n\r\n```scala\r\n            eventsToObserve.remove(eventId) match {\r\n              case None =>\r\n                throw new AssertionError(...)\r\n              case Some(event) =>\r\n                ...\r\n            }\r\n```",
        "createdAt" : "2020-03-09T09:14:03Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cd8d202c-cd0c-4561-81ef-be1b27cac4bb",
        "parentId" : "bdfe8cc9-cfe4-4c5e-8c2a-520c94f3a571",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Addressed in 7c1c9299b.",
        "createdAt" : "2020-03-09T09:55:44Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "96a369b3afd668ff924abde055ac20086b2d1fba",
    "line" : null,
    "diffHunk" : "@@ -136,6 +142,94 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       }\n   }\n \n+  test(\n+    \"TXTreeBlinding\",\n+    \"Trees should be served according to the blinding/projection rules\",\n+    allocate(TwoParties, SingleParty, SingleParty)\n+  ) {\n+    case Participants(\n+        Participant(alpha, alice, gbp_bank),\n+        Participant(beta, bob),\n+        Participant(delta, dkk_bank)) =>\n+      for {\n+        gbpIouIssue <- alpha.create(gbp_bank, Iou(gbp_bank, gbp_bank, \"GBP\", 100, Nil))\n+        gbpTransfer <- alpha.exerciseAndGetContract(\n+          gbp_bank,\n+          gbpIouIssue.exerciseIou_Transfer(_, alice))\n+        dkkIouIssue <- delta.create(dkk_bank, Iou(dkk_bank, dkk_bank, \"DKK\", 110, Nil))\n+        dkkTransfer <- delta.exerciseAndGetContract(\n+          dkk_bank,\n+          dkkIouIssue.exerciseIou_Transfer(_, bob))\n+\n+        aliceIou1 <- eventually {\n+          alpha.exerciseAndGetContract[Iou](alice, gbpTransfer.exerciseIouTransfer_Accept(_))\n+        }\n+        aliceIou <- eventually {\n+          alpha.exerciseAndGetContract[Iou](alice, aliceIou1.exerciseIou_AddObserver(_, bob))\n+        }\n+        bobIou <- eventually {\n+          beta.exerciseAndGetContract[Iou](bob, dkkTransfer.exerciseIouTransfer_Accept(_))\n+        }\n+\n+        trade <- eventually {\n+          alpha.create(\n+            alice,\n+            IouTrade(alice, bob, aliceIou, gbp_bank, \"GBP\", 100, dkk_bank, \"DKK\", 110))\n+        }\n+        tree <- eventually { beta.exercise(bob, trade.exerciseIouTrade_Accept(_, bobIou)) }\n+\n+        aliceTree <- alpha.transactionTreeById(tree.transactionId, alice)\n+        bobTree <- beta.transactionTreeById(tree.transactionId, bob)\n+        gbpTree <- alpha.transactionTreeById(tree.transactionId, gbp_bank)\n+        dkkTree <- delta.transactionTreeById(tree.transactionId, dkk_bank)\n+\n+      } yield {\n+        def treeIsWellformed(tree: TransactionTree): Unit = {\n+          val eventsToObserve = mutable.Map.empty[String, TreeEvent] ++= tree.eventsById\n+\n+          def go(eventId: String): Unit = {\n+            assert(\n+              eventsToObserve.contains(eventId),\n+              s\"Referenced eventId $eventId is not available as node in the transaction.\")\n+            val Some(event) = eventsToObserve.remove(eventId)"
  },
  {
    "id" : "d6ae9e34-3e9d-48ec-bb13-427a168ae510",
    "prId" : 4885,
    "comments" : [
      {
        "id" : "4f2e5ce4-b3c5-43b4-8d44-ee092d8892f4",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n            s\"After traversing the transaction, there are still unvisited nodes: $eventsToObserve\")\r\n```",
        "createdAt" : "2020-03-09T09:18:48Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "53bb7be8-b6c9-4e02-9f52-b56273a8b3de",
        "parentId" : "4f2e5ce4-b3c5-43b4-8d44-ee092d8892f4",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Thanks. Addressed in 7c1c9299b.",
        "createdAt" : "2020-03-09T09:56:03Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "96a369b3afd668ff924abde055ac20086b2d1fba",
    "line" : null,
    "diffHunk" : "@@ -136,6 +142,94 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       }\n   }\n \n+  test(\n+    \"TXTreeBlinding\",\n+    \"Trees should be served according to the blinding/projection rules\",\n+    allocate(TwoParties, SingleParty, SingleParty)\n+  ) {\n+    case Participants(\n+        Participant(alpha, alice, gbp_bank),\n+        Participant(beta, bob),\n+        Participant(delta, dkk_bank)) =>\n+      for {\n+        gbpIouIssue <- alpha.create(gbp_bank, Iou(gbp_bank, gbp_bank, \"GBP\", 100, Nil))\n+        gbpTransfer <- alpha.exerciseAndGetContract(\n+          gbp_bank,\n+          gbpIouIssue.exerciseIou_Transfer(_, alice))\n+        dkkIouIssue <- delta.create(dkk_bank, Iou(dkk_bank, dkk_bank, \"DKK\", 110, Nil))\n+        dkkTransfer <- delta.exerciseAndGetContract(\n+          dkk_bank,\n+          dkkIouIssue.exerciseIou_Transfer(_, bob))\n+\n+        aliceIou1 <- eventually {\n+          alpha.exerciseAndGetContract[Iou](alice, gbpTransfer.exerciseIouTransfer_Accept(_))\n+        }\n+        aliceIou <- eventually {\n+          alpha.exerciseAndGetContract[Iou](alice, aliceIou1.exerciseIou_AddObserver(_, bob))\n+        }\n+        bobIou <- eventually {\n+          beta.exerciseAndGetContract[Iou](bob, dkkTransfer.exerciseIouTransfer_Accept(_))\n+        }\n+\n+        trade <- eventually {\n+          alpha.create(\n+            alice,\n+            IouTrade(alice, bob, aliceIou, gbp_bank, \"GBP\", 100, dkk_bank, \"DKK\", 110))\n+        }\n+        tree <- eventually { beta.exercise(bob, trade.exerciseIouTrade_Accept(_, bobIou)) }\n+\n+        aliceTree <- alpha.transactionTreeById(tree.transactionId, alice)\n+        bobTree <- beta.transactionTreeById(tree.transactionId, bob)\n+        gbpTree <- alpha.transactionTreeById(tree.transactionId, gbp_bank)\n+        dkkTree <- delta.transactionTreeById(tree.transactionId, dkk_bank)\n+\n+      } yield {\n+        def treeIsWellformed(tree: TransactionTree): Unit = {\n+          val eventsToObserve = mutable.Map.empty[String, TreeEvent] ++= tree.eventsById\n+\n+          def go(eventId: String): Unit = {\n+            assert(\n+              eventsToObserve.contains(eventId),\n+              s\"Referenced eventId $eventId is not available as node in the transaction.\")\n+            val Some(event) = eventsToObserve.remove(eventId)\n+            event.kind.exercised.toList.flatMap(_.childEventIds).foreach { childEventId =>\n+              go(childEventId)\n+            }\n+          }\n+          tree.rootEventIds.foreach(go)\n+          assert(\n+            eventsToObserve.isEmpty,\n+            s\"After traversing the transaction, there are still unvisted nodes: $eventsToObserve\")"
  },
  {
    "id" : "f5b2e020-3922-4539-9e65-9beec3ebee31",
    "prId" : 4885,
    "comments" : [
      {
        "id" : "f3aef491-01e7-477d-8518-048b74294485",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "No action to be taken here, as this is a very useful test to have, but I think we're adding a test that tests the Ledger API server, rather than the backing ledger. If this test framework is so helpful, we should probably consider spinning it off and use it for both internal integration tests and the external Ledger API test tool.",
        "createdAt" : "2020-03-09T10:22:53Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "041101c1-bcc1-46da-a90e-4ed469b04397",
        "parentId" : "f3aef491-01e7-477d-8518-048b74294485",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Agreed. The reason why the test is spread across 3 participants is to check the privacy of the backing ledger. But since the ledger api server is actually doing the final blinding, we cannot tell the difference on the client side of the ledger api of whether the privacy aware split of the transaction happened already between ledger and participant, or only between participant and ledger api.",
        "createdAt" : "2020-03-09T10:35:10Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d72b0d43-0987-4bd4-a161-eee9007a8d9a",
        "parentId" : "f3aef491-01e7-477d-8518-048b74294485",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "And yes, I agree 💯 to also use this test framework for ledger api/sandbox only integration tests.",
        "createdAt" : "2020-03-09T10:39:15Z",
        "updatedAt" : "2020-03-09T10:43:00Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "96a369b3afd668ff924abde055ac20086b2d1fba",
    "line" : 32,
    "diffHunk" : "@@ -136,6 +143,96 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       }\n   }\n \n+  test("
  },
  {
    "id" : "31e0632d-f2e9-4dcd-bcb3-e1de72c375f5",
    "prId" : 3475,
    "comments" : [
      {
        "id" : "4d38c39c-2d3b-45f0-90fc-882ce9fb85eb",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Maybe move this to a companion object (and make it private)?",
        "createdAt" : "2019-11-15T08:45:06Z",
        "updatedAt" : "2019-11-15T08:45:07Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6b71583d-718d-412b-81b4-fc0db23b81f5",
        "parentId" : "4d38c39c-2d3b-45f0-90fc-882ce9fb85eb",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "👍 submitted in https://github.com/digital-asset/daml/pull/3542",
        "createdAt" : "2019-11-20T09:13:13Z",
        "updatedAt" : "2019-11-20T09:13:13Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3cc840aadc37084586f7cb87fcc9d6cec00cc66f",
    "line" : 70,
    "diffHunk" : "@@ -811,53 +811,94 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n   test(\n     \"TXSingleMultiSame\",\n     \"The same transaction should be served regardless of subscribing as one or multiple parties\",\n+    allocate(TwoParties)) {\n+    case Participants(Participant(ledger, alice, bob)) =>\n+      for {\n+        _ <- ledger.create(alice, Dummy(alice))\n+        _ <- ledger.create(bob, Dummy(bob))\n+        aliceView <- ledger.flatTransactions(alice)\n+        bobView <- ledger.flatTransactions(bob)\n+        multiSubscriptionView <- ledger.flatTransactions(alice, bob)\n+      } yield {\n+        val jointView = aliceView ++ bobView\n+        assertEquals(\n+          \"Single- and multi-party subscription yield different results\",\n+          jointView,\n+          multiSubscriptionView)\n+      }\n+  }\n+\n+  test(\n+    \"TXSingleMultiSameTrees\",\n+    \"The same transaction trees should be served regardless of subscribing as one or multiple parties\",\n+    allocate(TwoParties)\n+  ) {\n+    case Participants(Participant(ledger, alice, bob)) =>\n+      for {\n+        _ <- ledger.create(alice, Dummy(alice))\n+        _ <- ledger.create(bob, Dummy(bob))\n+        aliceView <- ledger.transactionTrees(alice)\n+        bobView <- ledger.transactionTrees(bob)\n+        multiSubscriptionView <- ledger.transactionTrees(alice, bob)\n+      } yield {\n+        val jointView = aliceView ++ bobView\n+        assertEquals(\n+          \"Single- and multi-party subscription yield different results\",\n+          jointView,\n+          multiSubscriptionView)\n+      }\n+  }\n+\n+  test(\n+    \"TXSingleMultiSameStakeholders\",\n+    \"The same transaction should be served to all stakeholders\",\n     allocate(SingleParty, SingleParty)) {\n     case Participants(Participant(alpha, alice), Participant(beta, bob)) =>\n       for {\n-        _ <- alpha.create(alice, Dummy(alice))\n-        _ <- beta.create(bob, Dummy(bob))\n-        aliceView <- alpha.flatTransactions(alice)\n-        bobView <- beta.flatTransactions(bob)\n-        _ <- synchronize(alpha, beta)\n+        _ <- alpha.create(alice, AgreementFactory(bob, alice))\n+        _ <- beta.create(bob, AgreementFactory(alice, bob))\n         alphaView <- alpha.flatTransactions(alice, bob)\n         betaView <- beta.flatTransactions(alice, bob)\n       } yield {\n-        val jointView = aliceView ++ bobView\n+        // Strip command id to yield a transaction comparable across participant\n+        def stripCommandId(transactions: Seq[Transaction]): Seq[Transaction] =\n+          transactions.map(_.copy(commandId = \"\"))"
  },
  {
    "id" : "fb4b32ed-3050-4cfd-aef0-7d5c4cf32c56",
    "prId" : 3043,
    "comments" : [
      {
        "id" : "955b2b54-67ef-4692-aed9-b0425fa5f20e",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n      s\"$context: either the number of archive events (${archivals.size}) or the number of create events (${creations.size}) doesn't match the expected number of $contracts.\"\r\n```",
        "createdAt" : "2019-09-26T10:27:45Z",
        "updatedAt" : "2019-09-26T11:34:07Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dbcdee8f-3d18-4534-b119-6cdb75e9cf63",
        "parentId" : "955b2b54-67ef-4692-aed9-b0425fa5f20e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3043/commits/114ef6cf5740db7a34d5b1739484762e618d05c7",
        "createdAt" : "2019-09-26T11:34:24Z",
        "updatedAt" : "2019-09-26T11:34:24Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "114ef6cf5740db7a34d5b1739484762e618d05c7",
    "line" : null,
    "diffHunk" : "@@ -1312,13 +1396,179 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private def checkTransactionsOrder(\n+      context: String,\n+      transactions: Vector[Transaction],\n+      contracts: Int): Unit = {\n+    val (cs, as) =\n+      transactions.flatMap(_.events).zipWithIndex.partition {\n+        case (e, _) => e.event.isCreated\n+      }\n+    val creations = cs.map { case (e, i) => e.getCreated.contractId -> i }\n+    val archivals = as.map { case (e, i) => e.getArchived.contractId -> i }\n+    assert(\n+      creations.size == contracts && archivals.size == contracts,\n+      s\"$context: either the number of archive events (${archivals.size}) or the number of create events (${creations.size}) don't match the expected number of $contracts.\""
  },
  {
    "id" : "f838a4e9-7b86-4992-80d6-61073c93ad96",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "b7b0ab5a-8c7f-414a-9348-fe46a4d32961",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I don't think the `eventually` is needed, considering we have a synchronization point before this.",
        "createdAt" : "2019-09-23T08:32:31Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "693569a4-1564-420b-bf8b-c8427d13af5e",
        "parentId" : "b7b0ab5a-8c7f-414a-9348-fe46a4d32961",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
        "createdAt" : "2019-09-23T13:12:01Z",
        "updatedAt" : "2019-09-23T13:12:01Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {"
  },
  {
    "id" : "dedec6f0-7291-475f-96a1-0cfe85568640",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "924c3e1a-1db8-48dd-bee6-09813754c442",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "`exerceForFlatTransaction` returns a ... flat transaction and not a tree?\r\n```suggestion\r\n        flat <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\r\n```",
        "createdAt" : "2019-09-23T08:33:56Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "45b0b0ec-cced-43ea-ba2d-6bab83608d05",
        "parentId" : "924c3e1a-1db8-48dd-bee6-09813754c442",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Copy-pasta, thanks.",
        "createdAt" : "2019-09-23T09:25:27Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e9c2518d-3418-43ce-8892-802571275ab2",
        "parentId" : "924c3e1a-1db8-48dd-bee6-09813754c442",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/bd5b1d34a81387a3a4e686ea73806f73fd1e1ea1",
        "createdAt" : "2019-09-23T12:54:19Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)"
  },
  {
    "id" : "e4bbef41-2d9f-4568-a515-3bd5f2ddd1d6",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "61080626-f6af-4d28-8788-551cd85e3230",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n        byId <- ledger.flatTransactionById(flat.transactionId, party)\r\n```",
        "createdAt" : "2019-09-23T08:34:04Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1f2afc60-9717-4945-b379-bddf8a4a7a71",
        "parentId" : "61080626-f6af-4d28-8788-551cd85e3230",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/bd5b1d34a81387a3a4e686ea73806f73fd1e1ea1",
        "createdAt" : "2019-09-23T13:01:27Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.flatTransactionById(tree.transactionId, party)"
  },
  {
    "id" : "ec744a50-89eb-4d5b-a1ff-3397268d40b7",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "0712f513-c19e-4a96-bfca-a9d665c7152d",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n        assertEquals(\"The transaction fetched by identifier does not match\", flat, byId)\r\n```",
        "createdAt" : "2019-09-23T08:34:22Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5565b370-b102-4648-80e1-51177fe4f6ab",
        "parentId" : "0712f513-c19e-4a96-bfca-a9d665c7152d",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/bd5b1d34a81387a3a4e686ea73806f73fd1e1ea1",
        "createdAt" : "2019-09-23T13:01:12Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.flatTransactionById(tree.transactionId, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)"
  },
  {
    "id" : "2f2b6dc5-1e96-4047-91ba-b7c999ba55e9",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "65b7379c-7e05-4a98-8d3d-1df990e63f13",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n        flats <- alpha.flatTransactions(listener, submitter)\r\n```",
        "createdAt" : "2019-09-23T08:35:09Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c4f34339-9088-4fb4-9ce1-1c89e6aa7860",
        "parentId" : "65b7379c-7e05-4a98-8d3d-1df990e63f13",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/6750f3224d1b6f137e929878d46bee4a1f835aab",
        "createdAt" : "2019-09-23T12:53:57Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.flatTransactionById(tree.transactionId, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleFlatTransactionById =\n+    LedgerTest(\n+      \"TXInvisibleFlatTransactionById\",\n+      \"Do not expose an invisible flat transaction by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.flatTransactionById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNotFound =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent flat transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.flatTransactionById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNoParty =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a flat transaction by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.flatTransactionById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactions\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        submitter <- alpha.allocateParty()\n+        listener <- beta.allocateParty()\n+        _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+        _ <- synchronize(alpha, beta)\n+        trees <- alpha.flatTransactions(listener, submitter)"
  },
  {
    "id" : "decf8867-a89e-46f1-930d-1b824a30797f",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "423f38bf-1a10-4a5b-a540-3318cd2aab1e",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Similar to the comment further above, I don't think we need the `eventually` block here, do we?",
        "createdAt" : "2019-09-23T08:35:35Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "31699cc5-3e39-4c68-b9f8-6d2fa6f63cda",
        "parentId" : "423f38bf-1a10-4a5b-a540-3318cd2aab1e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "You are right, probably a leftover from an earlier approach, thanks.",
        "createdAt" : "2019-09-23T13:04:43Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a864e576-1e8e-4e8c-8f83-e3ad33f6f5f3",
        "parentId" : "423f38bf-1a10-4a5b-a540-3318cd2aab1e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/b81eac6b9267070c0f30cb2f09e7fc8444857300",
        "createdAt" : "2019-09-23T13:11:43Z",
        "updatedAt" : "2019-09-23T13:11:44Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.flatTransactionById(tree.transactionId, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleFlatTransactionById =\n+    LedgerTest(\n+      \"TXInvisibleFlatTransactionById\",\n+      \"Do not expose an invisible flat transaction by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.flatTransactionById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNotFound =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent flat transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.flatTransactionById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNoParty =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a flat transaction by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.flatTransactionById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactions\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        submitter <- alpha.allocateParty()\n+        listener <- beta.allocateParty()\n+        _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+        _ <- synchronize(alpha, beta)\n+        trees <- alpha.flatTransactions(listener, submitter)\n+        _ <- eventually {"
  },
  {
    "id" : "6bcd75df-2e45-4934-bcd8-dbcfef91dbff",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "ba995ad0-40a1-4416-a4ad-bfe50f7c6a14",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "😄 ",
        "createdAt" : "2019-09-23T08:36:21Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d3e7c6b1-6d45-416a-9d72-77cbc97571be",
        "parentId" : "ba995ad0-40a1-4416-a4ad-bfe50f7c6a14",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Literally coming from the existing implementation. :wink: ",
        "createdAt" : "2019-09-23T09:26:07Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : 403,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.flatTransactionById(tree.transactionId, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleFlatTransactionById =\n+    LedgerTest(\n+      \"TXInvisibleFlatTransactionById\",\n+      \"Do not expose an invisible flat transaction by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.flatTransactionById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNotFound =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent flat transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.flatTransactionById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNoParty =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a flat transaction by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.flatTransactionById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactions\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        submitter <- alpha.allocateParty()\n+        listener <- beta.allocateParty()\n+        _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+        _ <- synchronize(alpha, beta)\n+        trees <- alpha.flatTransactions(listener, submitter)\n+        _ <- eventually {\n+          for {\n+            byId <- Future.sequence(\n+              trees.map(t => beta.flatTransactionById(t.transactionId, listener, submitter)))\n+          } yield {\n+            assertEquals(\n+              \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+              trees,\n+              byId)\n+          }\n+        }\n+      } yield {\n+        // Checks performed in the `eventually` block\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventId\",\n+      \"Expose a visible transaction tree by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.transactionTreeByEventId(tree.rootEventIds.head, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleTransactionTreeByEventId =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeByEventId\",\n+      \"Do not expose an invisible transaction tree by event identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeByEventId(tree.rootEventIds.head, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventIdInvalid =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdInvalid\",\n+      \"Return INVALID when looking up an invalid transaction tree by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeByEventId(\"dont' worry, be happy\", party).failed"
  },
  {
    "id" : "4b1c1772-2967-4c60-9203-1c88ba031199",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "fad733b8-5539-4242-9339-6d9e9cd5656c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n        flat <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\r\n```",
        "createdAt" : "2019-09-23T08:37:02Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f6c0abb1-1c4e-43da-af98-f860518cb0a7",
        "parentId" : "fad733b8-5539-4242-9339-6d9e9cd5656c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/6b70633a47b0894876eadf4f62359fd2b5560c31",
        "createdAt" : "2019-09-23T12:53:42Z",
        "updatedAt" : "2019-09-23T13:12:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.flatTransactionById(tree.transactionId, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleFlatTransactionById =\n+    LedgerTest(\n+      \"TXInvisibleFlatTransactionById\",\n+      \"Do not expose an invisible flat transaction by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.flatTransactionById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNotFound =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent flat transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.flatTransactionById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNoParty =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a flat transaction by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.flatTransactionById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactions\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        submitter <- alpha.allocateParty()\n+        listener <- beta.allocateParty()\n+        _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+        _ <- synchronize(alpha, beta)\n+        trees <- alpha.flatTransactions(listener, submitter)\n+        _ <- eventually {\n+          for {\n+            byId <- Future.sequence(\n+              trees.map(t => beta.flatTransactionById(t.transactionId, listener, submitter)))\n+          } yield {\n+            assertEquals(\n+              \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+              trees,\n+              byId)\n+          }\n+        }\n+      } yield {\n+        // Checks performed in the `eventually` block\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventId\",\n+      \"Expose a visible transaction tree by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.transactionTreeByEventId(tree.rootEventIds.head, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleTransactionTreeByEventId =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeByEventId\",\n+      \"Do not expose an invisible transaction tree by event identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeByEventId(tree.rootEventIds.head, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventIdInvalid =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdInvalid\",\n+      \"Return INVALID when looking up an invalid transaction tree by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeByEventId(\"dont' worry, be happy\", party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"Invalid field event_id\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by event identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          failure <- ledger.transactionTreeByEventId(s\"#${\"a\" * 60}:000\", party).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by event identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeByEventId(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventId\",\n+      \"Expose a visible flat transaction by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)"
  },
  {
    "id" : "b03a0537-e6c1-4552-bad4-e51960aa6db3",
    "prId" : 2961,
    "comments" : [
      {
        "id" : "f43fa5f8-9d43-4400-a8f6-9a6b9abead74",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Hm, shouldn't we know precisely which event we expect? Although I guess in this case it doesn't matter so much, as we simply want to look up the transaction by any eventId.",
        "createdAt" : "2019-09-23T08:38:49Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e37b3247-64bb-4eef-9c5c-c273fd9d30e7",
        "parentId" : "f43fa5f8-9d43-4400-a8f6-9a6b9abead74",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I believe the intent here was to not encode the order in which a transaction arrived in the test. I'm not sure this makes sense though and I would be in favor of pinning the expected transaction to be either a create or an archival. Makes sense?",
        "createdAt" : "2019-09-23T10:20:47Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e82b0fad-3e08-4f96-b530-3fd68706467d",
        "parentId" : "f43fa5f8-9d43-4400-a8f6-9a6b9abead74",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Right. The Ledger API doesn't specify the order or the events, but there should only be a single archived event in this case anyway.",
        "createdAt" : "2019-09-23T10:28:35Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e3538771-e2b0-4997-8b57-e1a40b5c6ff3",
        "parentId" : "f43fa5f8-9d43-4400-a8f6-9a6b9abead74",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Of course, thanks.",
        "createdAt" : "2019-09-23T12:22:34Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3f0f9011-5a63-4b47-96ed-0f82050087a7",
        "parentId" : "f43fa5f8-9d43-4400-a8f6-9a6b9abead74",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2961/commits/962544588c5b708f7b2bd392347a46652d088d34",
        "createdAt" : "2019-09-23T12:53:27Z",
        "updatedAt" : "2019-09-23T13:11:21Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b32f1221504aed4a2bc42e4068e5ee9f8fed8c49",
    "line" : null,
    "diffHunk" : "@@ -806,6 +807,523 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n         }\n     }\n \n+  private[this] val singleMultiSame =\n+    LedgerTest(\n+      \"TXSingleMultiSame\",\n+      \"The same transaction should be served regardless of subscribing as one or multiple parties\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          alice <- alpha.allocateParty()\n+          bob <- beta.allocateParty()\n+          _ <- alpha.create(alice, Dummy(alice))\n+          _ <- beta.create(bob, Dummy(bob))\n+          aliceView <- alpha.flatTransactions(alice)\n+          bobView <- beta.flatTransactions(bob)\n+          _ <- synchronize(alpha, beta)\n+          alphaView <- alpha.flatTransactions(alice, bob)\n+          betaView <- beta.flatTransactions(alice, bob)\n+        } yield {\n+          val jointView = aliceView ++ bobView\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            alphaView)\n+          assertEquals(\n+            \"Single- and multi-party subscription yield different results\",\n+            jointView,\n+            betaView)\n+        }\n+    }\n+\n+  private[this] val fetchContractCreatedInTransaction =\n+    LedgerTest(\n+      \"TXFetchContractCreatedInTransaction\",\n+      \"It should be possible to fetch a contract created within a transaction\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        alice <- ledger.allocateParty()\n+        createAndFetch <- ledger.create(alice, CreateAndFetch(alice))\n+        transaction <- ledger.exerciseForFlatTransaction(\n+          alice,\n+          createAndFetch.exerciseCreateAndFetch_Run)\n+      } yield {\n+        val _ = assertSingleton(\"There should be only one create\", createdEvents(transaction))\n+        val exercise =\n+          assertSingleton(\"There should be only one archive\", archivedEvents(transaction))\n+        assertEquals(\n+          \"The contract identifier of the exercise does not match\",\n+          Tag.unwrap(createAndFetch),\n+          exercise.contractId)\n+      }\n+    }\n+\n+  private[this] val flatTransactionsWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionsWrongLedgerId\",\n+      \"The getTransactions endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreesWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreesWrongLedgerId\",\n+      \"The getTransactionTrees endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionsRequest(Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTrees(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The getTransactionTreeById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdWrongLedgerId\",\n+      \"The getFlatTransactionById endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionById(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdWrongLedgerId\",\n+      \"The getTransactionTreeByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.transactionTreeByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventIdWrongLedgerId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventIdWrongLedgerId\",\n+      \"The getFlatTransactionByEventId endpoint should reject calls with the wrong ledger identifier\") {\n+      context =>\n+        val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          invalidRequest = ledger\n+            .getTransactionByEventIdRequest(\"not-relevant\", Seq(party))\n+            .update(_.ledgerId := invalidLedgerId)\n+          failure <- ledger.flatTransactionByEventId(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.NOT_FOUND,\n+            s\"Ledger ID '$invalidLedgerId' not found.\")\n+        }\n+    }\n+\n+  private[this] val ledgerEndWrongLedgerId =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdWrongLedgerId\",\n+      \"The ledgerEnd endpoint should reject calls with the wrong ledger identifier\") { context =>\n+      val invalidLedgerId = \"DEFINITELY_NOT_A_VALID_LEDGER_IDENTIFIER\"\n+      for {\n+        ledger <- context.participant()\n+        failure <- ledger.currentEnd(invalidLedgerId).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, s\"Ledger ID '$invalidLedgerId' not found.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeById =\n+    LedgerTest(\"TXTransactionTreeById\", \"Expose a visible transaction tree by identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+          byId <- ledger.transactionTreeById(tree.transactionId, party)\n+        } yield {\n+          assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+        }\n+    }\n+\n+  private[this] val invisibleTransactionTreeById =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeById\",\n+      \"Do not expose an invisible transaction tree by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXTransactionTreeByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactionTrees\") {\n+      context =>\n+        for {\n+          Vector(alpha, beta) <- context.participants(2)\n+          submitter <- alpha.allocateParty()\n+          listener <- beta.allocateParty()\n+          _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+          _ <- synchronize(alpha, beta)\n+          trees <- alpha.transactionTrees(listener, submitter)\n+          _ <- eventually {\n+            for {\n+              byId <- Future.sequence(\n+                trees.map(t => beta.transactionTreeById(t.transactionId, listener, submitter)))\n+            } yield {\n+              assertEquals(\n+                \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+                trees,\n+                byId)\n+            }\n+          }\n+        } yield {\n+          // Checks performed in the `eventually` block\n+        }\n+    }\n+\n+  private[this] val flatTransactionById =\n+    LedgerTest(\"TXFlatTransactionById\", \"Expose a visible transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.flatTransactionById(tree.transactionId, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleFlatTransactionById =\n+    LedgerTest(\n+      \"TXInvisibleFlatTransactionById\",\n+      \"Do not expose an invisible flat transaction by identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.flatTransactionById(tree.transactionId, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNotFound =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent flat transaction by identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.flatTransactionById(\"a\" * 60, party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val flatTransactionByIdNoParty =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a flat transaction by identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.flatTransactionById(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByIdSameAsTransactionStream =\n+    LedgerTest(\n+      \"TXFlatTransactionByIdSameAsTransactionStream\",\n+      \"Expose the same events for each transaction as the output of getTransactions\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        submitter <- alpha.allocateParty()\n+        listener <- beta.allocateParty()\n+        _ <- alpha.create(submitter, AgreementFactory(listener, submitter))\n+        _ <- synchronize(alpha, beta)\n+        trees <- alpha.flatTransactions(listener, submitter)\n+        _ <- eventually {\n+          for {\n+            byId <- Future.sequence(\n+              trees.map(t => beta.flatTransactionById(t.transactionId, listener, submitter)))\n+          } yield {\n+            assertEquals(\n+              \"The events fetched by identifier did not match with the ones on the transaction stream\",\n+              trees,\n+              byId)\n+          }\n+        }\n+      } yield {\n+        // Checks performed in the `eventually` block\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventId =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventId\",\n+      \"Expose a visible transaction tree by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exercise(party, dummy.exerciseDummyChoice1)\n+        byId <- ledger.transactionTreeByEventId(tree.rootEventIds.head, party)\n+      } yield {\n+        assertEquals(\"The transaction fetched by identifier does not match\", tree, byId)\n+      }\n+    }\n+\n+  private[this] val invisibleTransactionTreeByEventId =\n+    LedgerTest(\n+      \"TXInvisibleTransactionTreeByEventId\",\n+      \"Do not expose an invisible transaction tree by event identifier\") { context =>\n+      for {\n+        Vector(alpha, beta) <- context.participants(2)\n+        party <- alpha.allocateParty()\n+        intruder <- beta.allocateParty()\n+        dummy <- alpha.create(party, Dummy(party))\n+        tree <- alpha.exercise(party, dummy.exerciseDummyChoice1)\n+        _ <- synchronize(alpha, beta)\n+        failure <- beta.transactionTreeByEventId(tree.rootEventIds.head, intruder).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventIdInvalid =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdInvalid\",\n+      \"Return INVALID when looking up an invalid transaction tree by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        failure <- ledger.transactionTreeByEventId(\"dont' worry, be happy\", party).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"Invalid field event_id\")\n+      }\n+    }\n+\n+  private[this] val transactionTreeByEventIdNotFound =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdNotFound\",\n+      \"Return NOT_FOUND when looking up an inexistent transaction tree by event identifier\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          party <- ledger.allocateParty()\n+          failure <- ledger.transactionTreeByEventId(s\"#${\"a\" * 60}:000\", party).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.NOT_FOUND, \"Transaction not found, or not visible.\")\n+        }\n+    }\n+\n+  private[this] val transactionTreeByEventIdNoParty =\n+    LedgerTest(\n+      \"TXTransactionTreeByEventIdNotFound\",\n+      \"Return INVALID_ARGUMENT when looking up a transaction tree by event identifier without specifying a party\") {\n+      context =>\n+        for {\n+          ledger <- context.participant()\n+          failure <- ledger.transactionTreeByEventId(\"not-relevant\").failed\n+        } yield {\n+          assertGrpcError(\n+            failure,\n+            Status.Code.INVALID_ARGUMENT,\n+            \"Missing field: requesting_parties\")\n+        }\n+    }\n+\n+  private[this] val flatTransactionByEventId =\n+    LedgerTest(\n+      \"TXFlatTransactionByEventId\",\n+      \"Expose a visible flat transaction by event identifier\") { context =>\n+      for {\n+        ledger <- context.participant()\n+        party <- ledger.allocateParty()\n+        dummy <- ledger.create(party, Dummy(party))\n+        tree <- ledger.exerciseForFlatTransaction(party, dummy.exerciseDummyChoice1)\n+        event = tree.events.head.event\n+        eventId = event.created.map(_.eventId).getOrElse(event.archived.map(_.eventId).get)"
  },
  {
    "id" : "bf9d601e-a076-4c99-be51-b56006554840",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "e1e52fb4-e3fa-470a-9e4a-6df7ee9b52b4",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Since `triProposal` is created on `alpha`, there is potential for flakiness when exercising `AcceptTriProposal` on `beta` if the `triProposal` contract hasn't made it to `beta` yet. Wrap in `assertEventually`?",
        "createdAt" : "2019-09-16T07:52:39Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0716b070-bca8-4fb8-a0cd-e129aff26625",
        "parentId" : "e1e52fb4-e3fa-470a-9e4a-6df7ee9b52b4",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Definitely, I was looking only at explicit transaction reads for source of potential flakiness but I definitely overlooked this (and others, as you pointed out).",
        "createdAt" : "2019-09-16T08:38:00Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1039f598-06fd-4ba7-9b52-87ae8ee38d99",
        "parentId" : "e1e52fb4-e3fa-470a-9e4a-6df7ee9b52b4",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/b218310180d117e637a94c4e6506785a46316153",
        "createdAt" : "2019-09-16T09:23:00Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : null,
    "diffHunk" : "@@ -603,15 +663,16 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n     LedgerTest(\"TXMultiActorChoiceOk\", \"Accept exercising a well-authorized multi-actor choice\") {\n       context =>\n         for {\n-          ledger <- context.participant()\n-          Vector(operator, receiver, giver) <- ledger.allocateParties(3)\n-          agreementFactory <- ledger.create(giver, AgreementFactory(receiver, giver))\n-          agreement <- ledger.exerciseAndGetContract[Agreement](\n+          Vector(alpha, beta) <- context.participants(2)\n+          Vector(operator, receiver) <- alpha.allocateParties(2)\n+          giver <- beta.allocateParty()\n+          agreementFactory <- beta.create(giver, AgreementFactory(receiver, giver))\n+          agreement <- alpha.exerciseAndGetContract[Agreement](\n             receiver,\n             agreementFactory.exerciseAgreementFactoryAccept)\n           triProposalTemplate = TriProposal(operator, receiver, giver)\n-          triProposal <- ledger.create(operator, triProposalTemplate)\n-          tree <- ledger.exercise(giver, agreement.exerciseAcceptTriProposal(_, triProposal))\n+          triProposal <- alpha.create(operator, triProposalTemplate)\n+          tree <- beta.exercise(giver, agreement.exerciseAcceptTriProposal(_, triProposal))"
  },
  {
    "id" : "d2a1b4f6-bf93-4105-9d7a-c2a8b29ada14",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "96ab399d-ad9a-4c77-a3fa-d5578d3832b8",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Same argument as above regarding flakiness between `alpha` and `beta`.",
        "createdAt" : "2019-09-16T07:53:05Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "be6993bb-94cf-43e3-981e-eb11aae0dd42",
        "parentId" : "96ab399d-ad9a-4c77-a3fa-d5578d3832b8",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/0fa14d151df5a99067c88f4ce5ce11896b379e5a",
        "createdAt" : "2019-09-16T09:23:15Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : null,
    "diffHunk" : "@@ -627,15 +688,16 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       \"Accept exercising a well-authorized multi-actor choice with coinciding controllers\") {\n       context =>\n         for {\n-          ledger <- context.participant()\n-          Vector(operator, giver) <- ledger.allocateParties(2)\n-          agreementFactory <- ledger.create(giver, AgreementFactory(giver, giver))\n-          agreement <- ledger.exerciseAndGetContract[Agreement](\n+          Vector(alpha, beta) <- context.participants(2)\n+          operator <- alpha.allocateParty()\n+          giver <- beta.allocateParty()\n+          agreementFactory <- beta.create(giver, AgreementFactory(giver, giver))\n+          agreement <- beta.exerciseAndGetContract[Agreement](\n             giver,\n             agreementFactory.exerciseAgreementFactoryAccept)\n           triProposalTemplate = TriProposal(operator, giver, giver)\n-          triProposal <- ledger.create(operator, triProposalTemplate)\n-          tree <- ledger.exercise(giver, agreement.exerciseAcceptTriProposal(_, triProposal))\n+          triProposal <- alpha.create(operator, triProposalTemplate)\n+          tree <- beta.exercise(giver, agreement.exerciseAcceptTriProposal(_, triProposal))"
  },
  {
    "id" : "d96558e3-777b-4adf-bd65-cb59ea7315b9",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "8efc610b-b8b6-4ef1-83c6-23003769d58e",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Potential flakiness between `alpha` and `beta`.",
        "createdAt" : "2019-09-16T07:53:25Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7c5ae627-71a3-45cf-8672-988aaaf29683",
        "parentId" : "8efc610b-b8b6-4ef1-83c6-23003769d58e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/0c9203e60b21cdf3ea34816ba143f4790daf6b15",
        "createdAt" : "2019-09-16T09:23:30Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : null,
    "diffHunk" : "@@ -650,10 +712,11 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       \"TXRejectMultiActorMissingAuth\",\n       \"Reject exercising a multi-actor choice with missing authorizers\") { context =>\n       for {\n-        ledger <- context.participant()\n-        Vector(operator, receiver, giver) <- ledger.allocateParties(3)\n-        triProposal <- ledger.create(operator, TriProposal(operator, receiver, giver))\n-        failure <- ledger.exercise(giver, triProposal.exerciseTriProposalAccept).failed\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(operator, receiver) <- alpha.allocateParties(2)\n+        giver <- beta.allocateParty()\n+        triProposal <- alpha.create(operator, TriProposal(operator, receiver, giver))\n+        failure <- beta.exercise(giver, triProposal.exerciseTriProposalAccept).failed"
  },
  {
    "id" : "dfc083fe-1a0d-48c1-bb21-2337ec767277",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "d9026918-6671-4106-9c1d-2fa72dcb21b1",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Potential flakiness between `alpha` and `beta`.",
        "createdAt" : "2019-09-16T07:53:42Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8e222d10-1fd3-485b-b197-18c7d7e9f4da",
        "parentId" : "d9026918-6671-4106-9c1d-2fa72dcb21b1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/1f22a2a4fc6c6a84fe27096298c9addbafcaa327",
        "createdAt" : "2019-09-16T09:23:48Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : null,
    "diffHunk" : "@@ -668,16 +731,17 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       \"TXRejectMultiActorExcessiveAuth\",\n       \"Reject exercising a multi-actor choice with too many authorizers\") { context =>\n       for {\n-        ledger <- context.participant()\n-        Vector(operator, receiver, giver) <- ledger.allocateParties(3)\n-        agreementFactory <- ledger.create(giver, AgreementFactory(receiver, giver))\n-        agreement <- ledger\n+        Vector(alpha, beta) <- context.participants(2)\n+        Vector(operator, receiver) <- alpha.allocateParties(2)\n+        giver <- beta.allocateParty()\n+        agreementFactory <- beta.create(giver, AgreementFactory(receiver, giver))\n+        agreement <- alpha\n           .exerciseAndGetContract[Agreement](\n             receiver,\n             agreementFactory.exerciseAgreementFactoryAccept)\n         triProposalTemplate = TriProposal(operator, giver, giver)\n-        triProposal <- ledger.create(operator, triProposalTemplate)\n-        failure <- ledger\n+        triProposal <- alpha.create(operator, triProposalTemplate)\n+        failure <- beta"
  },
  {
    "id" : "fbb13cff-ef95-4180-863b-8f5ddcea8ef0",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "fb438103-4c29-4b93-ac0f-a6584c82f4f6",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This test could succeed even with a faulty disclosure mechanism, simply by way of `beta.flatTransactions` always being called before `beta` would receive the transaction.\r\nTo make sure that we can make a negative statement (transaction X created on alpha is not seen by party Alice), we need to ensure that party Alice does see a later transactions. Only then can we be sure that party Alice has seen all actions that happened on alpha.",
        "createdAt" : "2019-09-16T07:58:11Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4bce8716-9ae9-48f3-bc77-ba08de0363d6",
        "parentId" : "fb438103-4c29-4b93-ac0f-a6584c82f4f6",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/886f7e81b2be070d2ca25f98e29079995fd0a3b2",
        "createdAt" : "2019-09-16T11:47:34Z",
        "updatedAt" : "2019-09-16T11:47:35Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : 203,
    "diffHunk" : "@@ -475,12 +526,13 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       \"TXNotDiscloseCreateToNonChosenBranchingController\",\n       \"Not disclose create to non-chosen branching controller\") { context =>\n       for {\n-        ledger <- context.participant()\n-        Vector(alice, bob, eve) <- ledger.allocateParties(3)\n+        Vector(alpha, beta) <- context.participants(2)\n+        alice <- alpha.allocateParty()\n+        Vector(bob, eve) <- beta.allocateParties(2)\n         template = BranchingControllers(alice, false, bob, eve)\n-        create <- ledger.submitAndWaitRequest(alice, template.create.command)\n-        transaction <- ledger.submitAndWaitForTransaction(create)\n-        transactions <- ledger.flatTransactions(bob)\n+        create <- alpha.submitAndWaitRequest(alice, template.create.command)\n+        transaction <- alpha.submitAndWaitForTransaction(create)\n+        transactions <- beta.flatTransactions(bob)"
  },
  {
    "id" : "c0b8d9e8-21d3-4f50-a29f-e06ca9be3f35",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "150f2447-8a5d-445c-aa1d-4b324045b5be",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Potential flakiness between `alpha` and `beta`.",
        "createdAt" : "2019-09-16T07:58:41Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b2b5a921-6733-49b5-b80a-14d6b8bdba34",
        "parentId" : "150f2447-8a5d-445c-aa1d-4b324045b5be",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Since this tests tries to \"prove non-existence\" of something, it looks like it's less of a case of potential flakiness and more of a source of false positives, like in the case of https://github.com/digital-asset/daml/pull/2900#discussion_r324545682. Makes sense?",
        "createdAt" : "2019-09-16T09:26:30Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3e225809-ff31-41ab-a77b-95963885abe9",
        "parentId" : "150f2447-8a5d-445c-aa1d-4b324045b5be",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Yes, you're right.",
        "createdAt" : "2019-09-16T09:46:47Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "05b08ecc-00a5-431e-b5f0-3488efe38e8f",
        "parentId" : "150f2447-8a5d-445c-aa1d-4b324045b5be",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/5bac758267a860375dc82870dd62815fb7a4f2be",
        "createdAt" : "2019-09-16T11:46:54Z",
        "updatedAt" : "2019-09-16T11:46:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : 133,
    "diffHunk" : "@@ -441,12 +473,13 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       \"TXNotDiscloseCreateToNonSignatory\",\n       \"Not disclose create to non-chosen branching signatory\") { context =>\n       for {\n-        ledger <- context.participant()\n-        Vector(alice, bob) <- ledger.allocateParties(2)\n+        Vector(alpha, beta) <- context.participants(2)\n+        alice <- alpha.allocateParty()\n+        bob <- beta.allocateParty()\n         template = BranchingSignatories(false, alice, bob)\n-        create <- ledger.submitAndWaitRequest(bob, template.create.command)\n-        transaction <- ledger.submitAndWaitForTransaction(create)\n-        transactions <- ledger.flatTransactions(alice)\n+        create <- beta.submitAndWaitRequest(bob, template.create.command)\n+        transaction <- beta.submitAndWaitForTransaction(create)\n+        transactions <- alpha.flatTransactions(alice)"
  },
  {
    "id" : "d26553e6-04b6-4763-8e0c-69817c4b2674",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "be58da1e-9fc6-40da-b187-315c975bfef1",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Potential flakiness between `alpha` and `beta`.",
        "createdAt" : "2019-09-16T07:59:01Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "41c2a1e2-e40f-4e15-a7a6-f76280a0336a",
        "parentId" : "be58da1e-9fc6-40da-b187-315c975bfef1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Since this tests tries to \"prove non-existence\" of something, it looks like it's less of a case of potential flakiness and more of a source of false positives, like in the case of https://github.com/digital-asset/daml/pull/2900#discussion_r324545682. Makes sense?",
        "createdAt" : "2019-09-16T09:26:35Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8e3fd794-f989-4417-8b29-7d8c745e730f",
        "parentId" : "be58da1e-9fc6-40da-b187-315c975bfef1",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "👍 ",
        "createdAt" : "2019-09-16T09:49:56Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "de0bcdb8-61c4-4f76-9776-b5e641535758",
        "parentId" : "be58da1e-9fc6-40da-b187-315c975bfef1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/4edfac1712a8deb54e5686d93d7840cf3e18979b",
        "createdAt" : "2019-09-16T11:47:48Z",
        "updatedAt" : "2019-09-16T11:47:49Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : 94,
    "diffHunk" : "@@ -409,11 +439,12 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       \"Expressing a non-consuming choice on a contract should not result in its archival\") {\n       context =>\n         for {\n-          ledger <- context.participant()\n-          Vector(receiver, giver) <- ledger.allocateParties(2)\n-          agreementFactory <- ledger.create(giver, AgreementFactory(receiver, giver))\n-          _ <- ledger.exercise(receiver, agreementFactory.exerciseCreateAgreement)\n-          transactions <- ledger.flatTransactions(receiver, giver)\n+          Vector(alpha, beta) <- context.participants(2)\n+          receiver <- alpha.allocateParty()\n+          giver <- beta.allocateParty()\n+          agreementFactory <- beta.create(giver, AgreementFactory(receiver, giver))\n+          _ <- alpha.exercise(receiver, agreementFactory.exerciseCreateAgreement)"
  },
  {
    "id" : "a02f1838-3e1d-4378-83d3-14027094fe3c",
    "prId" : 2900,
    "comments" : [
      {
        "id" : "3c73ccbc-7bec-4649-85bc-8888eb118612",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Potential flakiness between `alpha` and `beta`.",
        "createdAt" : "2019-09-16T07:59:25Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8054a611-3dbb-4f25-978e-8d4b1d284c65",
        "parentId" : "3c73ccbc-7bec-4649-85bc-8888eb118612",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Since this tests tries to \"prove non-existence\" of something, it looks like it's less of a case of potential flakiness and more of a source of false positives, like in the case of https://github.com/digital-asset/daml/pull/2900#discussion_r324545682. Makes sense?",
        "createdAt" : "2019-09-16T09:26:40Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1ced86f4-73f5-46dd-9887-a2dffcf09af0",
        "parentId" : "3c73ccbc-7bec-4649-85bc-8888eb118612",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "In this case it's flakiness, because we're not trying to prove that the transaction is not visible, but rather that the `commandId` is not set.",
        "createdAt" : "2019-09-16T09:49:28Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e7889aa6-3437-4ef0-92e5-50c29811b343",
        "parentId" : "3c73ccbc-7bec-4649-85bc-8888eb118612",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Of course, thanks, I'll wrap the call to `transactionTreeById` with `eventually`.",
        "createdAt" : "2019-09-16T11:41:52Z",
        "updatedAt" : "2019-09-16T11:46:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a7aa79b-6ffb-4bf1-9ce7-45e8369fd512",
        "parentId" : "3c73ccbc-7bec-4649-85bc-8888eb118612",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2900/commits/cb3e0358d915d8511f21e83057e70a1616c6a3a9",
        "createdAt" : "2019-09-16T11:48:01Z",
        "updatedAt" : "2019-09-16T11:48:02Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "131bf99b912303d82407c7a903bba0ad64ce2cb6",
    "line" : null,
    "diffHunk" : "@@ -237,12 +238,11 @@ class TransactionService(session: LedgerSession) extends LedgerTestSuite(session\n       \"A transaction should be visible to a non-submitting stakeholder but its command identifier should be empty\"\n     ) { context =>\n       for {\n-        ledger <- context.participant()\n-        Vector(submitter, listener) <- ledger.allocateParties(2)\n-        (id, _) <- ledger.createAndGetTransactionId(\n-          submitter,\n-          AgreementFactory(listener, submitter))\n-        tree <- ledger.transactionTreeById(id, listener)\n+        Vector(alpha, beta) <- context.participants(2)\n+        submitter <- alpha.allocateParty()\n+        listener <- beta.allocateParty()\n+        (id, _) <- alpha.createAndGetTransactionId(submitter, AgreementFactory(listener, submitter))\n+        tree <- beta.transactionTreeById(id, listener)"
  },
  {
    "id" : "caf8e075-8a7c-4e96-9612-e65766b3bf45",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "16c9e522-4183-45c6-bdeb-d8b5814df0aa",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "you don't need a for-comprehension with one \"producer\" that directly yields the result.\r\nThis is equivalent:\r\n```scala\r\nFuture.sequence(Vector.fill(transactionsToSubmit)(ledger.create(party, Dummy(party))))\r\n```",
        "createdAt" : "2019-08-30T15:23:23Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bb8b49da-13be-4ab2-a37b-c8b4f7b434ff",
        "parentId" : "16c9e522-4183-45c6-bdeb-d8b5814df0aa",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2713/commits/a46d2a3fba1d5f92154c4116751abbd30056ba59",
        "createdAt" : "2019-09-02T09:39:23Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {"
  },
  {
    "id" : "cef39098-eef4-49d2-96a0-e6d5b6f6866f",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "e5c16721-440a-4a22-831d-fea4367425e4",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Same remark as above regarding the for-comprehension.",
        "createdAt" : "2019-08-30T15:24:43Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04813c30-08da-4dc4-90d4-06f400b51d15",
        "parentId" : "e5c16721-440a-4a22-831d-fea4367425e4",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2713/commits/f62f594d2f3bc634db569bed7b35d483eb772153\r\n\r\nThanks for catching this, my best guess is I left those over from a previous iteration.",
        "createdAt" : "2019-09-02T09:43:31Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {"
  },
  {
    "id" : "c20afe4f-0f68-49e7-99ce-1a934f543d4a",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "96ec3350-477b-48e4-8572-63a00867a1d3",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "\r\n\r\nSame remark as above regarding the for-comprehension.\r\n",
        "createdAt" : "2019-08-30T15:26:40Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "961d1163-6700-4f75-be02-2fe59177fa1d",
        "parentId" : "96ec3350-477b-48e4-8572-63a00867a1d3",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2713/commits/7be8d6b9b8083f91e756c6e9ae959153b5bb70ce",
        "createdAt" : "2019-09-02T09:39:02Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {"
  },
  {
    "id" : "9e15e996-41fd-4c5e-afa7-c4782f332f95",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "d777813e-361c-4570-81f2-b3b292e52ad8",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Same remark as above regarding the for-comprehension.\r\n",
        "createdAt" : "2019-08-30T15:27:06Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9f38c156-43b8-4921-95c1-6047f25f6a57",
        "parentId" : "d777813e-361c-4570-81f2-b3b292e52ad8",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2713/commits/c46eecc2eb97ad87d0f9212e3d76970c9376403f",
        "createdAt" : "2019-09-02T09:38:48Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {"
  },
  {
    "id" : "7b120bd4-041b-45f8-93fa-dc1b8d7c2fe9",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "5dcef2c5-73eb-4617-9991-bc699df5fc9f",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Same remark as above regarding the for-comprehension.\r\n",
        "createdAt" : "2019-08-30T15:27:29Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bc9d295d-564a-4207-9bc5-87cf0c38cd6a",
        "parentId" : "5dcef2c5-73eb-4617-9991-bc699df5fc9f",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2713/commits/9009d848dbaf23e32fbc92bc1e9f712e26316644",
        "createdAt" : "2019-09-02T09:38:34Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>\n+    val transactionsToSubmit = 5\n+    val parallelRequests = 10\n+    for {\n+      party <- ledger.allocateParty()\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {"
  },
  {
    "id" : "0b603f3e-973f-4109-ae11-459c2b0f44b0",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "407ffab6-0778-45e1-9682-7f83fb552cea",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Same remark as above regarding the for-comprehension.",
        "createdAt" : "2019-08-30T15:27:36Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d377a4a9-f7b7-4659-bb45-3322935e336b",
        "parentId" : "407ffab6-0778-45e1-9682-7f83fb552cea",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2713/commits/d795e4186ce1618edf2695cb40f6148c0e3f896d",
        "createdAt" : "2019-09-02T09:38:22Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>\n+    val transactionsToSubmit = 5\n+    val parallelRequests = 10\n+    for {\n+      party <- ledger.allocateParty()\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      results <- Future.sequence(Vector.fill(parallelRequests)(for {"
  },
  {
    "id" : "8143b9e1-3939-41bd-a0fe-1b05554250ba",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "b4661b1d-1cf5-4eef-aeb6-7838b38321dd",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The test runs 10 parallel requests, no?\r\n```suggestion\r\n    \"The same data should be served for more than 1 identical, parallel requests\") { ledger =>\r\n```",
        "createdAt" : "2019-08-30T15:28:36Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4b603465-bc4b-4219-ba89-54fc67a360d6",
        "parentId" : "b4661b1d-1cf5-4eef-aeb6-7838b38321dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm :it:, I love Copy :spaghetti: .",
        "createdAt" : "2019-09-02T09:34:27Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>"
  },
  {
    "id" : "8c9c67e9-9fe4-4f57-9ab2-c83bf6ba8e5e",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "c9101df1-75cc-458f-8f7d-f0e817a9d176",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Super nit-picky, but maybe move this test after the test that uses ledger begin twice?",
        "createdAt" : "2019-08-30T15:29:38Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ba45b6a7-2dc3-43d6-a783-eeca6d01dc98",
        "parentId" : "c9101df1-75cc-458f-8f7d-f0e817a9d176",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Makes a lot of sense actually. Addressed by https://github.com/digital-asset/daml/pull/2713/commits/cf1d1d348c6cbaa9bd443c51609dd8f736884657",
        "createdAt" : "2019-09-02T09:44:15Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>\n+    val transactionsToSubmit = 5\n+    val parallelRequests = 10\n+    for {\n+      party <- ledger.allocateParty()\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      results <- Future.sequence(Vector.fill(parallelRequests)(for {\n+        transactions <- ledger.flatTransactions(party)\n+      } yield transactions))\n+    } yield {\n+      assert(\n+        results.toSet.size == 1,\n+        s\"All requests are supposed to return the same results but there \" +\n+          s\"where differences: ${results.map(_.map(_.commandId)).mkString(\", \")}\"\n+      )\n+    }\n+  }\n+\n+  private[this] val notDivulgeToUnrelatedParties =\n+    LedgerTest(\"TXNotDivulge\", \"Data should not be exposed to parties unrelated to a transaction\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          _ <- ledger.create(alice, Dummy(alice))\n+          bobsView <- ledger.flatTransactions(bob)\n+        } yield {\n+          assert(\n+            bobsView.isEmpty,\n+            s\"After Alice create a contract, Bob sees one or more transaction he shouldn't, namely those created by commands ${bobsView.map(_.commandId).mkString(\", \")}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val endToEndShouldBeEmpty ="
  },
  {
    "id" : "bb2469a3-2b94-41ec-8f22-4ea34ad968f6",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "209e8f8d-e170-4d4a-8ef2-8c0daa45f923",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    LedgerTest(\"TXRejectOnFailingAssertion\", \"Reject a transaction on a failing assertion\") {\r\n```",
        "createdAt" : "2019-08-30T15:31:08Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>\n+    val transactionsToSubmit = 5\n+    val parallelRequests = 10\n+    for {\n+      party <- ledger.allocateParty()\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      results <- Future.sequence(Vector.fill(parallelRequests)(for {\n+        transactions <- ledger.flatTransactions(party)\n+      } yield transactions))\n+    } yield {\n+      assert(\n+        results.toSet.size == 1,\n+        s\"All requests are supposed to return the same results but there \" +\n+          s\"where differences: ${results.map(_.map(_.commandId)).mkString(\", \")}\"\n+      )\n+    }\n+  }\n+\n+  private[this] val notDivulgeToUnrelatedParties =\n+    LedgerTest(\"TXNotDivulge\", \"Data should not be exposed to parties unrelated to a transaction\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          _ <- ledger.create(alice, Dummy(alice))\n+          bobsView <- ledger.flatTransactions(bob)\n+        } yield {\n+          assert(\n+            bobsView.isEmpty,\n+            s\"After Alice create a contract, Bob sees one or more transaction he shouldn't, namely those created by commands ${bobsView.map(_.commandId).mkString(\", \")}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val endToEndShouldBeEmpty =\n+    LedgerTest(\n+      \"TXEndToEnd\",\n+      \"An empty stream should be served when getting transactions from and to the end of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          _ <- ledger.create(party, Dummy(party))\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          endToEnd = request.update(_.begin := ledger.end, _.end := ledger.end)\n+          transactions <- ledger.flatTransactions(endToEnd)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"No transactions were expected but ${transactions.size} were read\")\n+        }\n+    }\n+\n+  private[this] val rejectBeginAfterEnd =\n+    LedgerTest(\n+      \"TXRejectBeginAfterEnd\",\n+      \"A request with the end before the begin should be rejected with INVALID_ARGUMENT\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          earlier <- ledger.currentEnd()\n+          _ <- ledger.create(party, Dummy(party))\n+          later <- ledger.currentEnd()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          invalidRequest = request.update(_.begin := later, _.end := earlier)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"is before Begin offset\")\n+        }\n+    }\n+\n+  private[this] val hideCommandIdToNonSubmittingStakeholders =\n+    LedgerTest(\n+      \"TXHideCommandIdToNonSubmittingStakeholders\",\n+      \"A transaction should be visible to a non-submitting stakeholder but its command identifier should be empty\"\n+    ) { ledger =>\n+      for {\n+        Vector(submitter, listener) <- ledger.allocateParties(2)\n+        (id, _) <- ledger.createAndGetTransactionId(\n+          submitter,\n+          AgreementFactory(listener, submitter))\n+        tree <- ledger.transactionTreeById(id, listener)\n+      } yield {\n+        assert(\n+          tree.commandId.isEmpty,\n+          s\"The command identifier was supposed to be empty but it's `${tree.commandId}` instead.\")\n+      }\n+    }\n+\n+  private[this] val filterByTemplate =\n+    LedgerTest(\n+      \"TXFilterByTemplate\",\n+      \"The transaction service should correctly filter by template identifier\") { ledger =>\n+      val filterBy = Dummy.id\n+      for {\n+        party <- ledger.allocateParty()\n+        create <- ledger.submitAndWaitRequest(\n+          party,\n+          Dummy(party).create.command,\n+          DummyFactory(party).create.command)\n+        _ <- ledger.submitAndWait(create)\n+        transactions <- ledger.flatTransactionsByTemplateId(filterBy, party)\n+      } yield {\n+        val contract = assertSingleton(\"FilterByTemplate\", transactions.flatMap(createdEvents))\n+        assertEquals(\"FilterByTemplate\", contract.getTemplateId, Tag.unwrap(filterBy))\n+      }\n+    }\n+\n+  private[this] val useCreateToExercise =\n+    LedgerTest(\n+      \"TXUseCreateToExercise\",\n+      \"Should be able to directly use a contract identifier to exercise a choice\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        dummyFactory <- ledger.create(party, DummyFactory(party))\n+        transactions <- ledger.exercise(party, dummyFactory.exerciseDummyFactoryCall)\n+      } yield {\n+        val events = transactions.rootEventIds.collect(transactions.eventsById)\n+        val exercised = events.filter(_.kind.isExercised)\n+        assert(exercised.size == 1, s\"Only one exercise expected, got ${exercised.size}\")\n+        assert(\n+          exercised.head.getExercised.contractId == Tag.unwrap(dummyFactory),\n+          s\"The identifier of the exercised contract should have been ${Tag\n+            .unwrap(dummyFactory)} but instead it was ${exercised.head.getExercised.contractId}\"\n+        )\n+      }\n+    }\n+\n+  private[this] val rejectOnFailingAssertion =\n+    LedgerTest(\"TXRejectOnFailingAssertion\", \"Reject a transaction on a failing transaction\") {"
  },
  {
    "id" : "7564a2ba-0173-4543-9791-1a555a11bdb7",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "6613337a-e4ef-44dd-a7a1-801e2fdb4122",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This test is only partially useful. Could you put a comment that this should actually test that a party that is a signatory but not the submitter also receives the create event?",
        "createdAt" : "2019-08-30T15:35:18Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7939739c-a3e5-49fe-b2dc-0d9304b60ed7",
        "parentId" : "6613337a-e4ef-44dd-a7a1-801e2fdb4122",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Even better, I completed the test following your indications. Thanks for the help offline. :slightly_smiling_face: \r\n\r\nAddressed by https://github.com/digital-asset/daml/pull/2713/commits/3be1b233f0c85d4c46dfb48c245699fbe1ca4111",
        "createdAt" : "2019-09-02T10:05:10Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : 422,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>\n+    val transactionsToSubmit = 5\n+    val parallelRequests = 10\n+    for {\n+      party <- ledger.allocateParty()\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      results <- Future.sequence(Vector.fill(parallelRequests)(for {\n+        transactions <- ledger.flatTransactions(party)\n+      } yield transactions))\n+    } yield {\n+      assert(\n+        results.toSet.size == 1,\n+        s\"All requests are supposed to return the same results but there \" +\n+          s\"where differences: ${results.map(_.map(_.commandId)).mkString(\", \")}\"\n+      )\n+    }\n+  }\n+\n+  private[this] val notDivulgeToUnrelatedParties =\n+    LedgerTest(\"TXNotDivulge\", \"Data should not be exposed to parties unrelated to a transaction\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          _ <- ledger.create(alice, Dummy(alice))\n+          bobsView <- ledger.flatTransactions(bob)\n+        } yield {\n+          assert(\n+            bobsView.isEmpty,\n+            s\"After Alice create a contract, Bob sees one or more transaction he shouldn't, namely those created by commands ${bobsView.map(_.commandId).mkString(\", \")}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val endToEndShouldBeEmpty =\n+    LedgerTest(\n+      \"TXEndToEnd\",\n+      \"An empty stream should be served when getting transactions from and to the end of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          _ <- ledger.create(party, Dummy(party))\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          endToEnd = request.update(_.begin := ledger.end, _.end := ledger.end)\n+          transactions <- ledger.flatTransactions(endToEnd)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"No transactions were expected but ${transactions.size} were read\")\n+        }\n+    }\n+\n+  private[this] val rejectBeginAfterEnd =\n+    LedgerTest(\n+      \"TXRejectBeginAfterEnd\",\n+      \"A request with the end before the begin should be rejected with INVALID_ARGUMENT\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          earlier <- ledger.currentEnd()\n+          _ <- ledger.create(party, Dummy(party))\n+          later <- ledger.currentEnd()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          invalidRequest = request.update(_.begin := later, _.end := earlier)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"is before Begin offset\")\n+        }\n+    }\n+\n+  private[this] val hideCommandIdToNonSubmittingStakeholders =\n+    LedgerTest(\n+      \"TXHideCommandIdToNonSubmittingStakeholders\",\n+      \"A transaction should be visible to a non-submitting stakeholder but its command identifier should be empty\"\n+    ) { ledger =>\n+      for {\n+        Vector(submitter, listener) <- ledger.allocateParties(2)\n+        (id, _) <- ledger.createAndGetTransactionId(\n+          submitter,\n+          AgreementFactory(listener, submitter))\n+        tree <- ledger.transactionTreeById(id, listener)\n+      } yield {\n+        assert(\n+          tree.commandId.isEmpty,\n+          s\"The command identifier was supposed to be empty but it's `${tree.commandId}` instead.\")\n+      }\n+    }\n+\n+  private[this] val filterByTemplate =\n+    LedgerTest(\n+      \"TXFilterByTemplate\",\n+      \"The transaction service should correctly filter by template identifier\") { ledger =>\n+      val filterBy = Dummy.id\n+      for {\n+        party <- ledger.allocateParty()\n+        create <- ledger.submitAndWaitRequest(\n+          party,\n+          Dummy(party).create.command,\n+          DummyFactory(party).create.command)\n+        _ <- ledger.submitAndWait(create)\n+        transactions <- ledger.flatTransactionsByTemplateId(filterBy, party)\n+      } yield {\n+        val contract = assertSingleton(\"FilterByTemplate\", transactions.flatMap(createdEvents))\n+        assertEquals(\"FilterByTemplate\", contract.getTemplateId, Tag.unwrap(filterBy))\n+      }\n+    }\n+\n+  private[this] val useCreateToExercise =\n+    LedgerTest(\n+      \"TXUseCreateToExercise\",\n+      \"Should be able to directly use a contract identifier to exercise a choice\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        dummyFactory <- ledger.create(party, DummyFactory(party))\n+        transactions <- ledger.exercise(party, dummyFactory.exerciseDummyFactoryCall)\n+      } yield {\n+        val events = transactions.rootEventIds.collect(transactions.eventsById)\n+        val exercised = events.filter(_.kind.isExercised)\n+        assert(exercised.size == 1, s\"Only one exercise expected, got ${exercised.size}\")\n+        assert(\n+          exercised.head.getExercised.contractId == Tag.unwrap(dummyFactory),\n+          s\"The identifier of the exercised contract should have been ${Tag\n+            .unwrap(dummyFactory)} but instead it was ${exercised.head.getExercised.contractId}\"\n+        )\n+      }\n+    }\n+\n+  private[this] val rejectOnFailingAssertion =\n+    LedgerTest(\"TXRejectOnFailingAssertion\", \"Reject a transaction on a failing transaction\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          failure <- ledger\n+            .exercise(\n+              party,\n+              dummy.exerciseConsumeIfTimeIsBetween(\n+                _,\n+                Primitive.Timestamp.MAX,\n+                Primitive.Timestamp.MAX))\n+            .failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"Assertion failed\")\n+        }\n+    }\n+\n+  private[this] val createWithAnyType =\n+    LedgerTest(\n+      \"TXCreateWithAnyType\",\n+      \"Creates should not have issues dealing with any type of argument\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        template = ParameterShowcase(\n+          party,\n+          42L,\n+          BigDecimal(\"47.0000000000\"),\n+          \"some text\",\n+          true,\n+          Primitive.Timestamp.MIN,\n+          NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+          Primitive.List(0L, 1L, 2L, 3L),\n+          Primitive.Optional(\"some optional text\")\n+        )\n+        create <- ledger.submitAndWaitRequest(party, template.create.command)\n+        transaction <- ledger.submitAndWaitForTransaction(create)\n+      } yield {\n+        val contract = assertSingleton(\"CreateWithAnyType\", createdEvents(transaction))\n+        assertEquals(\"CreateWithAnyType\", contract.getCreateArguments, template.arguments)\n+      }\n+    }\n+\n+  private[this] val exerciseWithAnyType =\n+    LedgerTest(\n+      \"TXExerciseWithAnyType\",\n+      \"Exercise should not have issues dealing with any type of argument\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        template = ParameterShowcase(\n+          party,\n+          42L,\n+          BigDecimal(\"47.0000000000\"),\n+          \"some text\",\n+          true,\n+          Primitive.Timestamp.MIN,\n+          NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+          Primitive.List(0L, 1L, 2L, 3L),\n+          Primitive.Optional(\"some optional text\")\n+        )\n+        choice1 = Choice1(\n+          template.integer,\n+          BigDecimal(\"37.0000000000\"),\n+          template.text,\n+          template.bool,\n+          template.time,\n+          template.nestedOptionalInteger,\n+          template.integerList,\n+          template.optionalText\n+        )\n+        parameterShowcase <- ledger.create(\n+          party,\n+          template\n+        )\n+        tree <- ledger.exercise(party, parameterShowcase.exerciseChoice1(_, choice1))\n+      } yield {\n+        val contract = assertSingleton(\"ExerciseWithAnyType\", exercisedEvents(tree))\n+        assertEquals(\"ExerciseWithAnyType\", contract.getChoiceArgument, encode(choice1))\n+      }\n+    }\n+\n+  private[this] val submitAVeryLongList =\n+    LedgerTest(\"TXVeryLongList\", \"Accept a submission with a very long list (10,000 items)\") {\n+      ledger =>\n+        val n = 10000\n+        val veryLongList = Primitive.List(List.iterate(0L, n)(_ + 1): _*)\n+        for {\n+          party <- ledger.allocateParty()\n+          template = ParameterShowcase(\n+            party,\n+            42L,\n+            BigDecimal(\"47.0000000000\"),\n+            \"some text\",\n+            true,\n+            Primitive.Timestamp.MIN,\n+            NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+            veryLongList,\n+            Primitive.Optional(\"some optional text\")\n+          )\n+          create <- ledger.submitAndWaitRequest(party, template.create.command)\n+          transaction <- ledger.submitAndWaitForTransaction(create)\n+        } yield {\n+          val contract = assertSingleton(\"VeryLongList\", createdEvents(transaction))\n+          assertEquals(\"VeryLongList\", contract.getCreateArguments, template.arguments)\n+        }\n+    }\n+\n+  private[this] val notArchiveNonConsuming =\n+    LedgerTest(\n+      \"TXNotArchiveNonConsuming\",\n+      \"Expressing a non-consuming choice on a contract should not result in its archival\") {\n+      ledger =>\n+        for {\n+          Vector(receiver, giver) <- ledger.allocateParties(2)\n+          agreementFactory <- ledger.create(giver, AgreementFactory(receiver, giver))\n+          _ <- ledger.exercise(receiver, agreementFactory.exerciseCreateAgreement)\n+          transactions <- ledger.flatTransactions(receiver, giver)\n+        } yield {\n+          assert(\n+            !transactions.exists(_.events.exists(_.event.isArchived)),\n+            s\"The transaction include an archival: ${transactions.flatMap(_.events).filter(_.event.isArchived)}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val requireAuthorization =\n+    LedgerTest(\"TXRequireAuthorization\", \"Require only authorization of chosen branching signatory\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          template = BranchingSignatories(true, alice, bob)\n+          _ <- ledger.create(alice, template)\n+          transactions <- ledger.flatTransactions(alice)\n+        } yield {\n+          assert(template.arguments == transactions.head.events.head.getCreated.getCreateArguments)\n+        }\n+    }\n+\n+  private[this] val notDiscloseCreateToNonSignatory =\n+    LedgerTest(\n+      \"TXNotDiscloseCreateToNonSignatory\",\n+      \"Not disclose create to non-chosen branching signatory\") { ledger =>\n+      for {\n+        Vector(alice, bob) <- ledger.allocateParties(2)\n+        template = BranchingSignatories(false, alice, bob)\n+        create <- ledger.submitAndWaitRequest(bob, template.create.command)\n+        transaction <- ledger.submitAndWaitForTransaction(create)\n+        transactions <- ledger.flatTransactions(alice)\n+      } yield {\n+        assert(transactions.find(_.transactionId != transaction.transactionId).isEmpty)\n+      }\n+    }\n+\n+  private[this] val discloseCreateToSignatory ="
  },
  {
    "id" : "da06e285-186d-4ab7-ba42-6cfd72527c14",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "36fc881c-29ca-4022-8e75-fb702018c34f",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    LedgerTest(\"TXDiscloseCreateToSignatory\", \"Disclose create to the submitting signatory\") {\r\n```",
        "createdAt" : "2019-08-30T15:35:52Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>\n+    val transactionsToSubmit = 5\n+    val parallelRequests = 10\n+    for {\n+      party <- ledger.allocateParty()\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      results <- Future.sequence(Vector.fill(parallelRequests)(for {\n+        transactions <- ledger.flatTransactions(party)\n+      } yield transactions))\n+    } yield {\n+      assert(\n+        results.toSet.size == 1,\n+        s\"All requests are supposed to return the same results but there \" +\n+          s\"where differences: ${results.map(_.map(_.commandId)).mkString(\", \")}\"\n+      )\n+    }\n+  }\n+\n+  private[this] val notDivulgeToUnrelatedParties =\n+    LedgerTest(\"TXNotDivulge\", \"Data should not be exposed to parties unrelated to a transaction\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          _ <- ledger.create(alice, Dummy(alice))\n+          bobsView <- ledger.flatTransactions(bob)\n+        } yield {\n+          assert(\n+            bobsView.isEmpty,\n+            s\"After Alice create a contract, Bob sees one or more transaction he shouldn't, namely those created by commands ${bobsView.map(_.commandId).mkString(\", \")}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val endToEndShouldBeEmpty =\n+    LedgerTest(\n+      \"TXEndToEnd\",\n+      \"An empty stream should be served when getting transactions from and to the end of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          _ <- ledger.create(party, Dummy(party))\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          endToEnd = request.update(_.begin := ledger.end, _.end := ledger.end)\n+          transactions <- ledger.flatTransactions(endToEnd)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"No transactions were expected but ${transactions.size} were read\")\n+        }\n+    }\n+\n+  private[this] val rejectBeginAfterEnd =\n+    LedgerTest(\n+      \"TXRejectBeginAfterEnd\",\n+      \"A request with the end before the begin should be rejected with INVALID_ARGUMENT\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          earlier <- ledger.currentEnd()\n+          _ <- ledger.create(party, Dummy(party))\n+          later <- ledger.currentEnd()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          invalidRequest = request.update(_.begin := later, _.end := earlier)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"is before Begin offset\")\n+        }\n+    }\n+\n+  private[this] val hideCommandIdToNonSubmittingStakeholders =\n+    LedgerTest(\n+      \"TXHideCommandIdToNonSubmittingStakeholders\",\n+      \"A transaction should be visible to a non-submitting stakeholder but its command identifier should be empty\"\n+    ) { ledger =>\n+      for {\n+        Vector(submitter, listener) <- ledger.allocateParties(2)\n+        (id, _) <- ledger.createAndGetTransactionId(\n+          submitter,\n+          AgreementFactory(listener, submitter))\n+        tree <- ledger.transactionTreeById(id, listener)\n+      } yield {\n+        assert(\n+          tree.commandId.isEmpty,\n+          s\"The command identifier was supposed to be empty but it's `${tree.commandId}` instead.\")\n+      }\n+    }\n+\n+  private[this] val filterByTemplate =\n+    LedgerTest(\n+      \"TXFilterByTemplate\",\n+      \"The transaction service should correctly filter by template identifier\") { ledger =>\n+      val filterBy = Dummy.id\n+      for {\n+        party <- ledger.allocateParty()\n+        create <- ledger.submitAndWaitRequest(\n+          party,\n+          Dummy(party).create.command,\n+          DummyFactory(party).create.command)\n+        _ <- ledger.submitAndWait(create)\n+        transactions <- ledger.flatTransactionsByTemplateId(filterBy, party)\n+      } yield {\n+        val contract = assertSingleton(\"FilterByTemplate\", transactions.flatMap(createdEvents))\n+        assertEquals(\"FilterByTemplate\", contract.getTemplateId, Tag.unwrap(filterBy))\n+      }\n+    }\n+\n+  private[this] val useCreateToExercise =\n+    LedgerTest(\n+      \"TXUseCreateToExercise\",\n+      \"Should be able to directly use a contract identifier to exercise a choice\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        dummyFactory <- ledger.create(party, DummyFactory(party))\n+        transactions <- ledger.exercise(party, dummyFactory.exerciseDummyFactoryCall)\n+      } yield {\n+        val events = transactions.rootEventIds.collect(transactions.eventsById)\n+        val exercised = events.filter(_.kind.isExercised)\n+        assert(exercised.size == 1, s\"Only one exercise expected, got ${exercised.size}\")\n+        assert(\n+          exercised.head.getExercised.contractId == Tag.unwrap(dummyFactory),\n+          s\"The identifier of the exercised contract should have been ${Tag\n+            .unwrap(dummyFactory)} but instead it was ${exercised.head.getExercised.contractId}\"\n+        )\n+      }\n+    }\n+\n+  private[this] val rejectOnFailingAssertion =\n+    LedgerTest(\"TXRejectOnFailingAssertion\", \"Reject a transaction on a failing transaction\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          failure <- ledger\n+            .exercise(\n+              party,\n+              dummy.exerciseConsumeIfTimeIsBetween(\n+                _,\n+                Primitive.Timestamp.MAX,\n+                Primitive.Timestamp.MAX))\n+            .failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"Assertion failed\")\n+        }\n+    }\n+\n+  private[this] val createWithAnyType =\n+    LedgerTest(\n+      \"TXCreateWithAnyType\",\n+      \"Creates should not have issues dealing with any type of argument\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        template = ParameterShowcase(\n+          party,\n+          42L,\n+          BigDecimal(\"47.0000000000\"),\n+          \"some text\",\n+          true,\n+          Primitive.Timestamp.MIN,\n+          NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+          Primitive.List(0L, 1L, 2L, 3L),\n+          Primitive.Optional(\"some optional text\")\n+        )\n+        create <- ledger.submitAndWaitRequest(party, template.create.command)\n+        transaction <- ledger.submitAndWaitForTransaction(create)\n+      } yield {\n+        val contract = assertSingleton(\"CreateWithAnyType\", createdEvents(transaction))\n+        assertEquals(\"CreateWithAnyType\", contract.getCreateArguments, template.arguments)\n+      }\n+    }\n+\n+  private[this] val exerciseWithAnyType =\n+    LedgerTest(\n+      \"TXExerciseWithAnyType\",\n+      \"Exercise should not have issues dealing with any type of argument\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        template = ParameterShowcase(\n+          party,\n+          42L,\n+          BigDecimal(\"47.0000000000\"),\n+          \"some text\",\n+          true,\n+          Primitive.Timestamp.MIN,\n+          NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+          Primitive.List(0L, 1L, 2L, 3L),\n+          Primitive.Optional(\"some optional text\")\n+        )\n+        choice1 = Choice1(\n+          template.integer,\n+          BigDecimal(\"37.0000000000\"),\n+          template.text,\n+          template.bool,\n+          template.time,\n+          template.nestedOptionalInteger,\n+          template.integerList,\n+          template.optionalText\n+        )\n+        parameterShowcase <- ledger.create(\n+          party,\n+          template\n+        )\n+        tree <- ledger.exercise(party, parameterShowcase.exerciseChoice1(_, choice1))\n+      } yield {\n+        val contract = assertSingleton(\"ExerciseWithAnyType\", exercisedEvents(tree))\n+        assertEquals(\"ExerciseWithAnyType\", contract.getChoiceArgument, encode(choice1))\n+      }\n+    }\n+\n+  private[this] val submitAVeryLongList =\n+    LedgerTest(\"TXVeryLongList\", \"Accept a submission with a very long list (10,000 items)\") {\n+      ledger =>\n+        val n = 10000\n+        val veryLongList = Primitive.List(List.iterate(0L, n)(_ + 1): _*)\n+        for {\n+          party <- ledger.allocateParty()\n+          template = ParameterShowcase(\n+            party,\n+            42L,\n+            BigDecimal(\"47.0000000000\"),\n+            \"some text\",\n+            true,\n+            Primitive.Timestamp.MIN,\n+            NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+            veryLongList,\n+            Primitive.Optional(\"some optional text\")\n+          )\n+          create <- ledger.submitAndWaitRequest(party, template.create.command)\n+          transaction <- ledger.submitAndWaitForTransaction(create)\n+        } yield {\n+          val contract = assertSingleton(\"VeryLongList\", createdEvents(transaction))\n+          assertEquals(\"VeryLongList\", contract.getCreateArguments, template.arguments)\n+        }\n+    }\n+\n+  private[this] val notArchiveNonConsuming =\n+    LedgerTest(\n+      \"TXNotArchiveNonConsuming\",\n+      \"Expressing a non-consuming choice on a contract should not result in its archival\") {\n+      ledger =>\n+        for {\n+          Vector(receiver, giver) <- ledger.allocateParties(2)\n+          agreementFactory <- ledger.create(giver, AgreementFactory(receiver, giver))\n+          _ <- ledger.exercise(receiver, agreementFactory.exerciseCreateAgreement)\n+          transactions <- ledger.flatTransactions(receiver, giver)\n+        } yield {\n+          assert(\n+            !transactions.exists(_.events.exists(_.event.isArchived)),\n+            s\"The transaction include an archival: ${transactions.flatMap(_.events).filter(_.event.isArchived)}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val requireAuthorization =\n+    LedgerTest(\"TXRequireAuthorization\", \"Require only authorization of chosen branching signatory\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          template = BranchingSignatories(true, alice, bob)\n+          _ <- ledger.create(alice, template)\n+          transactions <- ledger.flatTransactions(alice)\n+        } yield {\n+          assert(template.arguments == transactions.head.events.head.getCreated.getCreateArguments)\n+        }\n+    }\n+\n+  private[this] val notDiscloseCreateToNonSignatory =\n+    LedgerTest(\n+      \"TXNotDiscloseCreateToNonSignatory\",\n+      \"Not disclose create to non-chosen branching signatory\") { ledger =>\n+      for {\n+        Vector(alice, bob) <- ledger.allocateParties(2)\n+        template = BranchingSignatories(false, alice, bob)\n+        create <- ledger.submitAndWaitRequest(bob, template.create.command)\n+        transaction <- ledger.submitAndWaitForTransaction(create)\n+        transactions <- ledger.flatTransactions(alice)\n+      } yield {\n+        assert(transactions.find(_.transactionId != transaction.transactionId).isEmpty)\n+      }\n+    }\n+\n+  private[this] val discloseCreateToSignatory =\n+    LedgerTest(\"TXDiscloseCreateToSignatory\", \"Disclose create to chosen branching controller\") {"
  },
  {
    "id" : "d7477431-889f-40f8-8833-ef5c81edcaed",
    "prId" : 2713,
    "comments" : [
      {
        "id" : "054fba6a-dbc8-4964-8278-00b15d1b07b9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I've added an agreement text to the `Dummy` template, so it is easier to create create a contract and observe the agreement text. I needed this for an additional test for the `ActiveContractsService`.",
        "createdAt" : "2019-08-30T15:47:26Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7ef91c01-9d6a-4b51-8d59-8260a7a9186b",
        "parentId" : "054fba6a-dbc8-4964-8278-00b15d1b07b9",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2713/commits/edbec5015d7c47dfd557c34af94900a47f03e2d0",
        "createdAt" : "2019-09-02T09:56:29Z",
        "updatedAt" : "2019-09-02T10:59:08Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3153aa5aee7120933b68f4773dedc170bfa2b123",
    "line" : 482,
    "diffHunk" : "@@ -0,0 +1,707 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.api.testtool.tests\n+\n+import ai.x.diff.conversions._\n+import com.daml.ledger.api.testtool.infrastructure.{LedgerSession, LedgerTest, LedgerTestSuite}\n+import com.digitalasset.ledger.api.v1.value.{RecordField, Value}\n+import com.digitalasset.ledger.client.binding.Value.encode\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.test_stable.Test.Agreement._\n+import com.digitalasset.ledger.test_stable.Test.AgreementFactory._\n+import com.digitalasset.ledger.test_stable.Test.Choice1._\n+import com.digitalasset.ledger.test_stable.Test.Dummy._\n+import com.digitalasset.ledger.test_stable.Test.DummyFactory._\n+import com.digitalasset.ledger.test_stable.Test.ParameterShowcase._\n+import com.digitalasset.ledger.test_stable.Test.TriProposal._\n+import com.digitalasset.ledger.test_stable.Test._\n+import io.grpc.Status\n+import scalaz.Tag\n+\n+import scala.concurrent.Future\n+\n+class TransactionService(session: LedgerSession) extends LedgerTestSuite(session) {\n+\n+  private[this] val beginToBeginShouldBeEmpty =\n+    LedgerTest(\n+      \"TXBeginToBegin\",\n+      \"An empty stream should be served when getting transactions from and to the beginning of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          fromAndToBegin = request.update(_.begin := ledger.begin, _.end := ledger.begin)\n+          transactions <- ledger.flatTransactions(fromAndToBegin)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"Received a non-empty stream with ${transactions.size} transactions in it.\")\n+        }\n+    }\n+\n+  private[this] val serveElementsUntilCancellation =\n+    LedgerTest(\"TXServeUntilCancellation\", \"Items should be served until the client cancels\") {\n+      ledger =>\n+        val transactionsToSubmit = 14\n+        val transactionsToRead = 10\n+        for {\n+          party <- ledger.allocateParty()\n+          dummies <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+            contract <- ledger.create(party, Dummy(party))\n+          } yield contract))\n+          transactions <- ledger.flatTransactions(transactionsToRead, party)\n+        } yield {\n+          assert(\n+            dummies.size == transactionsToSubmit,\n+            s\"$transactionsToSubmit should have been submitted but ${dummies.size} were instead\")\n+          assert(\n+            transactions.size == transactionsToRead,\n+            s\"$transactionsToRead should have been received but ${transactions.size} were instead\")\n+        }\n+    }\n+\n+  private[this] val deduplicateCommands =\n+    LedgerTest(\n+      \"TXDeduplicateCommands\",\n+      \"Commands with identical command identifier and application identifier should be accepted and deduplicated\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request <- ledger.submitAndWaitRequest(party, Dummy(party).create.command)\n+          _ <- ledger.submitAndWait(request)\n+          _ <- ledger.submitAndWait(request)\n+          transactions <- ledger.flatTransactions(party)\n+        } yield {\n+          assert(\n+            transactions.length == 1,\n+            s\"Only one transaction was expected to be seen but ${transactions.length} appeared\")\n+        }\n+    }\n+\n+  private[this] val rejectEmptyFilter =\n+    LedgerTest(\n+      \"TXRejectEmptyFilter\",\n+      \"A query with an empty transaction filter should be rejected with an INVALID_ARGUMENT status\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          requestWithEmptyFilter = request.update(_.filter.filtersByParty := Map.empty)\n+          failure <- ledger.flatTransactions(requestWithEmptyFilter).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"filtersByParty cannot be empty\")\n+        }\n+    }\n+\n+  private[this] val completeOnLedgerEnd = LedgerTest(\n+    \"TXCompleteOnLedgerEnd\",\n+    \"A stream should complete as soon as the ledger end is hit\") { ledger =>\n+    val transactionsToSubmit = 14\n+    for {\n+      party <- ledger.allocateParty()\n+      transactionsFuture = ledger.flatTransactions(party)\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      _ <- transactionsFuture\n+    } yield {\n+      // doing nothing: we are just checking that `transactionsFuture` completes successfully\n+    }\n+  }\n+\n+  private[this] val processInTwoChunks = LedgerTest(\n+    \"TXProcessInTwoChunks\",\n+    \"Serve the complete sequence of transactions even if processing is stopped and resumed\") {\n+    ledger =>\n+      val transactionsToSubmit = 5\n+      for {\n+        party <- ledger.allocateParty()\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterFirstSection <- ledger.currentEnd()\n+        firstSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.end := endAfterFirstSection)\n+        firstSection <- ledger.flatTransactions(firstSectionRequest)\n+        _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+          contract <- ledger.create(party, Dummy(party))\n+        } yield contract))\n+        endAfterSecondSection <- ledger.currentEnd()\n+        secondSectionRequest = ledger\n+          .getTransactionsRequest(Seq(party))\n+          .update(_.begin := endAfterFirstSection, _.end := endAfterSecondSection)\n+        secondSection <- ledger.flatTransactions(secondSectionRequest)\n+        fullSequence <- ledger.flatTransactions(party)\n+      } yield {\n+        val concatenation = Vector.concat(firstSection, secondSection)\n+        assert(\n+          fullSequence == concatenation,\n+          s\"The result of processing items in two chunk should yield the same result as getting the overall stream of transactions in the end but there are differences. \" +\n+            s\"Full sequence: ${fullSequence.map(_.commandId).mkString(\", \")}, \" +\n+            s\"first section: ${firstSection.map(_.commandId).mkString(\", \")}, \" +\n+            s\"second section: ${secondSection.map(_.commandId).mkString(\", \")}\"\n+        )\n+      }\n+  }\n+\n+  private[this] val identicalAndParallel = LedgerTest(\n+    \"TXParallel\",\n+    \"The same data should be served for two identical, parallel requests\") { ledger =>\n+    val transactionsToSubmit = 5\n+    val parallelRequests = 10\n+    for {\n+      party <- ledger.allocateParty()\n+      _ <- Future.sequence(Vector.fill(transactionsToSubmit)(for {\n+        contract <- ledger.create(party, Dummy(party))\n+      } yield contract))\n+      results <- Future.sequence(Vector.fill(parallelRequests)(for {\n+        transactions <- ledger.flatTransactions(party)\n+      } yield transactions))\n+    } yield {\n+      assert(\n+        results.toSet.size == 1,\n+        s\"All requests are supposed to return the same results but there \" +\n+          s\"where differences: ${results.map(_.map(_.commandId)).mkString(\", \")}\"\n+      )\n+    }\n+  }\n+\n+  private[this] val notDivulgeToUnrelatedParties =\n+    LedgerTest(\"TXNotDivulge\", \"Data should not be exposed to parties unrelated to a transaction\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          _ <- ledger.create(alice, Dummy(alice))\n+          bobsView <- ledger.flatTransactions(bob)\n+        } yield {\n+          assert(\n+            bobsView.isEmpty,\n+            s\"After Alice create a contract, Bob sees one or more transaction he shouldn't, namely those created by commands ${bobsView.map(_.commandId).mkString(\", \")}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val endToEndShouldBeEmpty =\n+    LedgerTest(\n+      \"TXEndToEnd\",\n+      \"An empty stream should be served when getting transactions from and to the end of the ledger\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          _ <- ledger.create(party, Dummy(party))\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          endToEnd = request.update(_.begin := ledger.end, _.end := ledger.end)\n+          transactions <- ledger.flatTransactions(endToEnd)\n+        } yield {\n+          assert(\n+            transactions.isEmpty,\n+            s\"No transactions were expected but ${transactions.size} were read\")\n+        }\n+    }\n+\n+  private[this] val rejectBeginAfterEnd =\n+    LedgerTest(\n+      \"TXRejectBeginAfterEnd\",\n+      \"A request with the end before the begin should be rejected with INVALID_ARGUMENT\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          earlier <- ledger.currentEnd()\n+          _ <- ledger.create(party, Dummy(party))\n+          later <- ledger.currentEnd()\n+          request = ledger.getTransactionsRequest(Seq(party))\n+          invalidRequest = request.update(_.begin := later, _.end := earlier)\n+          failure <- ledger.flatTransactions(invalidRequest).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"is before Begin offset\")\n+        }\n+    }\n+\n+  private[this] val hideCommandIdToNonSubmittingStakeholders =\n+    LedgerTest(\n+      \"TXHideCommandIdToNonSubmittingStakeholders\",\n+      \"A transaction should be visible to a non-submitting stakeholder but its command identifier should be empty\"\n+    ) { ledger =>\n+      for {\n+        Vector(submitter, listener) <- ledger.allocateParties(2)\n+        (id, _) <- ledger.createAndGetTransactionId(\n+          submitter,\n+          AgreementFactory(listener, submitter))\n+        tree <- ledger.transactionTreeById(id, listener)\n+      } yield {\n+        assert(\n+          tree.commandId.isEmpty,\n+          s\"The command identifier was supposed to be empty but it's `${tree.commandId}` instead.\")\n+      }\n+    }\n+\n+  private[this] val filterByTemplate =\n+    LedgerTest(\n+      \"TXFilterByTemplate\",\n+      \"The transaction service should correctly filter by template identifier\") { ledger =>\n+      val filterBy = Dummy.id\n+      for {\n+        party <- ledger.allocateParty()\n+        create <- ledger.submitAndWaitRequest(\n+          party,\n+          Dummy(party).create.command,\n+          DummyFactory(party).create.command)\n+        _ <- ledger.submitAndWait(create)\n+        transactions <- ledger.flatTransactionsByTemplateId(filterBy, party)\n+      } yield {\n+        val contract = assertSingleton(\"FilterByTemplate\", transactions.flatMap(createdEvents))\n+        assertEquals(\"FilterByTemplate\", contract.getTemplateId, Tag.unwrap(filterBy))\n+      }\n+    }\n+\n+  private[this] val useCreateToExercise =\n+    LedgerTest(\n+      \"TXUseCreateToExercise\",\n+      \"Should be able to directly use a contract identifier to exercise a choice\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        dummyFactory <- ledger.create(party, DummyFactory(party))\n+        transactions <- ledger.exercise(party, dummyFactory.exerciseDummyFactoryCall)\n+      } yield {\n+        val events = transactions.rootEventIds.collect(transactions.eventsById)\n+        val exercised = events.filter(_.kind.isExercised)\n+        assert(exercised.size == 1, s\"Only one exercise expected, got ${exercised.size}\")\n+        assert(\n+          exercised.head.getExercised.contractId == Tag.unwrap(dummyFactory),\n+          s\"The identifier of the exercised contract should have been ${Tag\n+            .unwrap(dummyFactory)} but instead it was ${exercised.head.getExercised.contractId}\"\n+        )\n+      }\n+    }\n+\n+  private[this] val rejectOnFailingAssertion =\n+    LedgerTest(\"TXRejectOnFailingAssertion\", \"Reject a transaction on a failing transaction\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          dummy <- ledger.create(party, Dummy(party))\n+          failure <- ledger\n+            .exercise(\n+              party,\n+              dummy.exerciseConsumeIfTimeIsBetween(\n+                _,\n+                Primitive.Timestamp.MAX,\n+                Primitive.Timestamp.MAX))\n+            .failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"Assertion failed\")\n+        }\n+    }\n+\n+  private[this] val createWithAnyType =\n+    LedgerTest(\n+      \"TXCreateWithAnyType\",\n+      \"Creates should not have issues dealing with any type of argument\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        template = ParameterShowcase(\n+          party,\n+          42L,\n+          BigDecimal(\"47.0000000000\"),\n+          \"some text\",\n+          true,\n+          Primitive.Timestamp.MIN,\n+          NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+          Primitive.List(0L, 1L, 2L, 3L),\n+          Primitive.Optional(\"some optional text\")\n+        )\n+        create <- ledger.submitAndWaitRequest(party, template.create.command)\n+        transaction <- ledger.submitAndWaitForTransaction(create)\n+      } yield {\n+        val contract = assertSingleton(\"CreateWithAnyType\", createdEvents(transaction))\n+        assertEquals(\"CreateWithAnyType\", contract.getCreateArguments, template.arguments)\n+      }\n+    }\n+\n+  private[this] val exerciseWithAnyType =\n+    LedgerTest(\n+      \"TXExerciseWithAnyType\",\n+      \"Exercise should not have issues dealing with any type of argument\") { ledger =>\n+      for {\n+        party <- ledger.allocateParty()\n+        template = ParameterShowcase(\n+          party,\n+          42L,\n+          BigDecimal(\"47.0000000000\"),\n+          \"some text\",\n+          true,\n+          Primitive.Timestamp.MIN,\n+          NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+          Primitive.List(0L, 1L, 2L, 3L),\n+          Primitive.Optional(\"some optional text\")\n+        )\n+        choice1 = Choice1(\n+          template.integer,\n+          BigDecimal(\"37.0000000000\"),\n+          template.text,\n+          template.bool,\n+          template.time,\n+          template.nestedOptionalInteger,\n+          template.integerList,\n+          template.optionalText\n+        )\n+        parameterShowcase <- ledger.create(\n+          party,\n+          template\n+        )\n+        tree <- ledger.exercise(party, parameterShowcase.exerciseChoice1(_, choice1))\n+      } yield {\n+        val contract = assertSingleton(\"ExerciseWithAnyType\", exercisedEvents(tree))\n+        assertEquals(\"ExerciseWithAnyType\", contract.getChoiceArgument, encode(choice1))\n+      }\n+    }\n+\n+  private[this] val submitAVeryLongList =\n+    LedgerTest(\"TXVeryLongList\", \"Accept a submission with a very long list (10,000 items)\") {\n+      ledger =>\n+        val n = 10000\n+        val veryLongList = Primitive.List(List.iterate(0L, n)(_ + 1): _*)\n+        for {\n+          party <- ledger.allocateParty()\n+          template = ParameterShowcase(\n+            party,\n+            42L,\n+            BigDecimal(\"47.0000000000\"),\n+            \"some text\",\n+            true,\n+            Primitive.Timestamp.MIN,\n+            NestedOptionalInteger(OptionalInteger.SomeInteger(-1L)),\n+            veryLongList,\n+            Primitive.Optional(\"some optional text\")\n+          )\n+          create <- ledger.submitAndWaitRequest(party, template.create.command)\n+          transaction <- ledger.submitAndWaitForTransaction(create)\n+        } yield {\n+          val contract = assertSingleton(\"VeryLongList\", createdEvents(transaction))\n+          assertEquals(\"VeryLongList\", contract.getCreateArguments, template.arguments)\n+        }\n+    }\n+\n+  private[this] val notArchiveNonConsuming =\n+    LedgerTest(\n+      \"TXNotArchiveNonConsuming\",\n+      \"Expressing a non-consuming choice on a contract should not result in its archival\") {\n+      ledger =>\n+        for {\n+          Vector(receiver, giver) <- ledger.allocateParties(2)\n+          agreementFactory <- ledger.create(giver, AgreementFactory(receiver, giver))\n+          _ <- ledger.exercise(receiver, agreementFactory.exerciseCreateAgreement)\n+          transactions <- ledger.flatTransactions(receiver, giver)\n+        } yield {\n+          assert(\n+            !transactions.exists(_.events.exists(_.event.isArchived)),\n+            s\"The transaction include an archival: ${transactions.flatMap(_.events).filter(_.event.isArchived)}\"\n+          )\n+        }\n+    }\n+\n+  private[this] val requireAuthorization =\n+    LedgerTest(\"TXRequireAuthorization\", \"Require only authorization of chosen branching signatory\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob) <- ledger.allocateParties(2)\n+          template = BranchingSignatories(true, alice, bob)\n+          _ <- ledger.create(alice, template)\n+          transactions <- ledger.flatTransactions(alice)\n+        } yield {\n+          assert(template.arguments == transactions.head.events.head.getCreated.getCreateArguments)\n+        }\n+    }\n+\n+  private[this] val notDiscloseCreateToNonSignatory =\n+    LedgerTest(\n+      \"TXNotDiscloseCreateToNonSignatory\",\n+      \"Not disclose create to non-chosen branching signatory\") { ledger =>\n+      for {\n+        Vector(alice, bob) <- ledger.allocateParties(2)\n+        template = BranchingSignatories(false, alice, bob)\n+        create <- ledger.submitAndWaitRequest(bob, template.create.command)\n+        transaction <- ledger.submitAndWaitForTransaction(create)\n+        transactions <- ledger.flatTransactions(alice)\n+      } yield {\n+        assert(transactions.find(_.transactionId != transaction.transactionId).isEmpty)\n+      }\n+    }\n+\n+  private[this] val discloseCreateToSignatory =\n+    LedgerTest(\"TXDiscloseCreateToSignatory\", \"Disclose create to chosen branching controller\") {\n+      ledger =>\n+        for {\n+          Vector(alice, bob, eve) <- ledger.allocateParties(3)\n+          template = BranchingControllers(alice, true, bob, eve)\n+          _ <- ledger.create(alice, template)\n+          transactions <- ledger.flatTransactions(alice)\n+        } yield {\n+          assert(template.arguments == transactions.head.events.head.getCreated.getCreateArguments)\n+        }\n+    }\n+\n+  private[this] val notDiscloseCreateToNonChosenBranchingController =\n+    LedgerTest(\n+      \"TXNotDiscloseCreateToNonChosenBranchingController\",\n+      \"Not disclose create to non-chosen branching controller\") { ledger =>\n+      for {\n+        Vector(alice, bob, eve) <- ledger.allocateParties(3)\n+        template = BranchingControllers(alice, false, bob, eve)\n+        create <- ledger.submitAndWaitRequest(alice, template.create.command)\n+        transaction <- ledger.submitAndWaitForTransaction(create)\n+        transactions <- ledger.flatTransactions(bob)\n+      } yield {\n+        assert(transactions.find(_.transactionId != transaction.transactionId).isEmpty)\n+      }\n+    }\n+\n+  private[this] val discloseCreateToObservers =\n+    LedgerTest(\"TXDiscloseCreateToObservers\", \"Disclose create to observers\") { ledger =>\n+      for {\n+        Vector(alice, bob, eve) <- ledger.allocateParties(3)\n+        observers = Seq(bob, eve)\n+        template = WithObservers(alice, Primitive.List(observers: _*))\n+        create <- ledger.submitAndWaitRequest(alice, template.create.command)\n+        transactionId <- ledger.submitAndWaitForTransactionId(create)\n+        transactions <- ledger.flatTransactions(observers: _*)\n+      } yield {\n+        assert(transactions.exists(_.transactionId == transactionId))\n+      }\n+    }\n+\n+  private[this] val unitAsArgumentToNothing =\n+    LedgerTest(\"TXUnitAsArgumentToNothing\", \"DAML engine returns Unit as argument to Nothing\") {\n+      ledger =>\n+        for {\n+          party <- ledger.allocateParty()\n+          template = NothingArgument(party, Primitive.Optional.empty)\n+          create <- ledger.submitAndWaitRequest(party, template.create.command)\n+          transaction <- ledger.submitAndWaitForTransaction(create)\n+        } yield {\n+          val contract = assertSingleton(\"UnitAsArgumentToNothing\", createdEvents(transaction))\n+          assertEquals(\"UnitAsArgumentToNothing\", contract.getCreateArguments, template.arguments)\n+        }\n+    }\n+\n+  private[this] val agreementText ="
  }
]