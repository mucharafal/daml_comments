[
  {
    "id" : "d62e4e82-7700-4bb5-83b4-043368d7046b",
    "prId" : 6382,
    "comments" : [
      {
        "id" : "c760bd32-5e81-4265-bc43-3f17e9742003",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Rather than having this bespoke method here, use `getParties`, passing `alphaLocalParty` and `betaLocalParty` in. This prevents the tests from possibly interfering with others that may use `Alice` and `Bob` as party hints.",
        "createdAt" : "2020-06-17T14:10:51Z",
        "updatedAt" : "2020-06-19T09:18:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47a8ecee-0f13-4f63-92c0-c4f783efd64a",
        "parentId" : "c760bd32-5e81-4265-bc43-3f17e9742003",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Done thanks for the pointer to `getParties` (should have noticed it myself while looking through the helpers).",
        "createdAt" : "2020-06-18T09:49:23Z",
        "updatedAt" : "2020-06-19T09:18:12Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "efb941f667b1ddcd27e8da8d7740f2ea79ba5a67",
    "line" : null,
    "diffHunk" : "@@ -183,4 +183,62 @@ final class PartyManagement(session: LedgerSession) extends LedgerTestSuite(sess\n           s\"The allocated party IDs $allocatedPartyIds are not a subset of $knownPartyIds.\")\n       }\n   }\n+\n+  test(\n+    \"PMListKnowPartiesIsLocal\",\n+    \"Listing parties on multi-node ledgers should reflect whether parties are local\",\n+    allocate(NoParties, NoParties),\n+  ) {\n+    case Participants(Participant(alpha), Participant(beta)) =>\n+      for {\n+        alphaLocalParty <- alpha.allocateParty(\n+          partyIdHint = Some(\"PMListKnowPartiesIsLocal_\" + Random.alphanumeric.take(10).mkString),\n+          displayName = Some(\"Alice\"),\n+        )\n+        betaLocalParty <- beta.allocateParty(\n+          partyIdHint = Some(\"PMListKnowPartiesIsLocal_\" + Random.alphanumeric.take(10).mkString),\n+          displayName = Some(\"Bob\"),\n+        )\n+        // only wait for parties on ledgers configured to know about each other's parties\n+        _ <- alpha.waitForParties(Set(alpha, beta), Set(alphaLocalParty, betaLocalParty))\n+        _ <- beta.waitForParties(Set(alpha, beta), Set(alphaLocalParty, betaLocalParty))\n+        partyDetailsKnowToAlpha <- alpha.listKnownPartyDetails()\n+        partyDetailsKnowToBeta <- beta.listKnownPartyDetails()\n+      } yield {\n+        def lookUp(\n+            party: binding.Primitive.Party,\n+            details: Seq[PartyDetails]): Option[(String, Boolean)] =\n+          details.collectFirst {\n+            case PartyDetails(p, displayName, isLocal)\n+                if p == binding.Primitive.Party.unwrap(party) =>\n+              (displayName, isLocal)\n+          }"
  },
  {
    "id" : "64135512-cf2a-4e86-ac91-bd597d402ecb",
    "prId" : 6382,
    "comments" : [
      {
        "id" : "ee22d6d9-db63-4ac4-a259-aeaa344b8353",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "There seems to be a bit of extra slack here. Why are these both acceptable behaviors?",
        "createdAt" : "2020-06-17T14:15:17Z",
        "updatedAt" : "2020-06-19T09:18:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "95f01971-c937-40cf-9324-1f5dcc43da94",
        "parentId" : "ee22d6d9-db63-4ac4-a259-aeaa344b8353",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "I added clarification in the comments in the code. Underlying this slack/freedom here is that distributed ledgers could choose to publish local parties to other participants or not.\r\n\r\nCurrently, Canton publishes parties to participants connected to the same domain by default, but even that could change based on configuration.",
        "createdAt" : "2020-06-18T09:52:43Z",
        "updatedAt" : "2020-06-19T09:18:12Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "efb941f667b1ddcd27e8da8d7740f2ea79ba5a67",
    "line" : null,
    "diffHunk" : "@@ -183,4 +183,62 @@ final class PartyManagement(session: LedgerSession) extends LedgerTestSuite(sess\n           s\"The allocated party IDs $allocatedPartyIds are not a subset of $knownPartyIds.\")\n       }\n   }\n+\n+  test(\n+    \"PMListKnowPartiesIsLocal\",\n+    \"Listing parties on multi-node ledgers should reflect whether parties are local\",\n+    allocate(NoParties, NoParties),\n+  ) {\n+    case Participants(Participant(alpha), Participant(beta)) =>\n+      for {\n+        alphaLocalParty <- alpha.allocateParty(\n+          partyIdHint = Some(\"PMListKnowPartiesIsLocal_\" + Random.alphanumeric.take(10).mkString),\n+          displayName = Some(\"Alice\"),\n+        )\n+        betaLocalParty <- beta.allocateParty(\n+          partyIdHint = Some(\"PMListKnowPartiesIsLocal_\" + Random.alphanumeric.take(10).mkString),\n+          displayName = Some(\"Bob\"),\n+        )\n+        // only wait for parties on ledgers configured to know about each other's parties\n+        _ <- alpha.waitForParties(Set(alpha, beta), Set(alphaLocalParty, betaLocalParty))\n+        _ <- beta.waitForParties(Set(alpha, beta), Set(alphaLocalParty, betaLocalParty))\n+        partyDetailsKnowToAlpha <- alpha.listKnownPartyDetails()\n+        partyDetailsKnowToBeta <- beta.listKnownPartyDetails()\n+      } yield {\n+        def lookUp(\n+            party: binding.Primitive.Party,\n+            details: Seq[PartyDetails]): Option[(String, Boolean)] =\n+          details.collectFirst {\n+            case PartyDetails(p, displayName, isLocal)\n+                if p == binding.Primitive.Party.unwrap(party) =>\n+              (displayName, isLocal)\n+          }\n+\n+        val Some((alice, aliceIsLocal)) = lookUp(alphaLocalParty, partyDetailsKnowToAlpha)\n+        assert(alice == \"Alice\" && aliceIsLocal)\n+\n+        val Some((bob, bobIsLocal)) = lookUp(betaLocalParty, partyDetailsKnowToBeta)\n+        assert(bob == \"Bob\" && bobIsLocal)\n+\n+        // On multi-participant ledgers remote parties should either not be known to each\n+        // other or should be marked as non-local.\n+        if (alpha.endpointId != beta.endpointId) {\n+          lookUp(betaLocalParty, partyDetailsKnowToAlpha) match {\n+            case None =>\n+            case Some((\"Bob\", false)) =>"
  },
  {
    "id" : "0b6d2b59-eca2-4232-97ab-9af7fe133aea",
    "prId" : 6382,
    "comments" : [
      {
        "id" : "67087e40-90b0-4041-aff1-c5c3ffb67abf",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "This seems a bit verbose for what it aims to do, can you check if something along the lines of https://github.com/digital-asset/daml/pull/6413 could do it? Feel free to either merge it into this PR or adopt the bits that you find relevant.",
        "createdAt" : "2020-06-18T13:27:09Z",
        "updatedAt" : "2020-06-19T09:18:12Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eccdf67a-5ead-4830-8602-acb8f17233b3",
        "parentId" : "67087e40-90b0-4041-aff1-c5c3ffb67abf",
        "author" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "body" : "Thanks for the help simplifying the test - much better now.",
        "createdAt" : "2020-06-18T15:25:50Z",
        "updatedAt" : "2020-06-19T09:18:12Z",
        "lastEditedBy" : {
          "login" : "oliverse-da",
          "name" : "Oliver Seeliger",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/46452754?u=dd1d8e09760abe67b40a4e527a15aafe9d104d82&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "efb941f667b1ddcd27e8da8d7740f2ea79ba5a67",
    "line" : null,
    "diffHunk" : "@@ -183,4 +183,68 @@ final class PartyManagement(session: LedgerSession) extends LedgerTestSuite(sess\n           s\"The allocated party IDs $allocatedPartyIds are not a subset of $knownPartyIds.\")\n       }\n   }\n+\n+  test(\n+    \"PMGetPartiesIsLocal\",\n+    \"Getting parties on multi-node ledgers should reflect whether parties are local\",\n+    allocate(NoParties, NoParties),\n+  ) {\n+    case Participants(Participant(alpha), Participant(beta)) =>\n+      val alphaPartyHintAndDisplayName =\n+        \"PMGetPartiesIsLocal_\" + Random.alphanumeric.take(10).mkString\n+      val betaPartyHintAndDisplayName =\n+        \"PMGetPartiesIsLocal_\" + Random.alphanumeric.take(10).mkString\n+      for {\n+        alphaLocalParty <- alpha.allocateParty(\n+          partyIdHint = Some(alphaPartyHintAndDisplayName),\n+          displayName = Some(alphaPartyHintAndDisplayName),\n+        )\n+        betaLocalParty <- beta.allocateParty(\n+          partyIdHint = Some(betaPartyHintAndDisplayName),\n+          displayName = Some(betaPartyHintAndDisplayName),\n+        )\n+        // only wait for parties on ledgers configured to know about each other's parties\n+        _ <- alpha.waitForParties(Set(alpha, beta), Set(alphaLocalParty, betaLocalParty))\n+        _ <- beta.waitForParties(Set(alpha, beta), Set(alphaLocalParty, betaLocalParty))\n+        alphaPartyOnAlphaParticipant <- alpha.getParties(Seq(alphaLocalParty))\n+        alphaPartyOnBetaParticipant <- beta.getParties(Seq(alphaLocalParty))\n+        betaPartyOnAlphaParticipant <- alpha.getParties(Seq(betaLocalParty))\n+        betaPartyOnBetaParticipant <- beta.getParties(Seq(betaLocalParty))\n+      } yield {\n+        alphaPartyOnAlphaParticipant.headOption match {\n+          case None =>\n+            Assertions.fail(\"Expected to find alpha party on alpha participant\")\n+          case Some(alphaLocal) =>\n+            assert(alphaLocal.displayName == alphaPartyHintAndDisplayName && alphaLocal.isLocal)\n+        }\n+\n+        betaPartyOnBetaParticipant.headOption match {\n+          case None =>\n+            Assertions.fail(\"Expected to find beta party on beta participant\")\n+          case Some(betaLocal) =>\n+            assert(betaLocal.displayName == betaPartyHintAndDisplayName && betaLocal.isLocal)\n+        }\n+\n+        // On multi-participant ledgers remote parties should either not be known to each\n+        // other or should be marked as non-local.\n+        if (alpha.endpointId != beta.endpointId) {\n+          alphaPartyOnBetaParticipant.headOption match {\n+            // distributed ledgers may choose not to publish parties across participants (e.g. privacy-enabled P-KVUtils)\n+            case None =>\n+            // but if they do, remote parties have to be marked non-local\n+            case Some(alphaRemote) =>\n+              assert(\n+                alphaRemote.displayName == alphaPartyHintAndDisplayName && !alphaRemote.isLocal)\n+          }\n+\n+          betaPartyOnAlphaParticipant.headOption match {\n+            // distributed ledgers may choose not to publish parties across participants (e.g. privacy-enabled P-KVUtils)\n+            case None =>\n+            // but if they do, remote parties have to be marked non-local\n+            case Some(betaRemote) =>\n+              assert(betaRemote.displayName == betaPartyHintAndDisplayName && !betaRemote.isLocal)\n+          }\n+        }\n+      }\n+  }"
  },
  {
    "id" : "dc4d6344-5d15-41e9-b7ba-d7be1fa64290",
    "prId" : 2749,
    "comments" : [
      {
        "id" : "13ba3f95-29e1-4f5e-b9e4-34005ffd5997",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please keep the original name and append the randomized string to it.",
        "createdAt" : "2019-09-04T17:09:00Z",
        "updatedAt" : "2019-09-04T18:53:04Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "58d078a4-2d1f-463e-b5af-c26ea90403b1",
        "parentId" : "13ba3f95-29e1-4f5e-b9e4-34005ffd5997",
        "author" : {
          "login" : "dasormeter",
          "name" : "Brian Healey",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25179017?u=80e3160e2447461bd5847fe928a3e6fa9f6793fc&v=4"
        },
        "body" : "put this back in and added randomized suffix separated by underscore",
        "createdAt" : "2019-09-04T17:36:33Z",
        "updatedAt" : "2019-09-04T18:53:04Z",
        "lastEditedBy" : {
          "login" : "dasormeter",
          "name" : "Brian Healey",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25179017?u=80e3160e2447461bd5847fe928a3e6fa9f6793fc&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9856671c4594bdb9204a3de6c83b0312f65e17a1",
    "line" : null,
    "diffHunk" : "@@ -28,7 +30,7 @@ final class PartyManagement(session: LedgerSession) extends LedgerTestSuite(sess\n       for {\n         ledger <- context.participant()\n         party <- ledger.allocateParty(\n-          partyHintId = Some(\"PMAllocateWithHint\"),\n+          partyHintId = Some(Random.alphanumeric.take(10).mkString),"
  }
]