[
  {
    "id" : "2580be30-9c55-4039-958a-66339be469f2",
    "prId" : 7395,
    "comments" : [
      {
        "id" : "07774918-be1a-4ee1-9bd3-4a088a952749",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n              results <- Future.traverse(1 to archives)(i =>\r\n```",
        "createdAt" : "2020-09-14T17:33:34Z",
        "updatedAt" : "2020-09-15T05:57:28Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8cfcd1d6-5985-4860-a971-c2e998ead7b4",
        "parentId" : "07774918-be1a-4ee1-9bd3-4a088a952749",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Done",
        "createdAt" : "2020-09-15T05:59:03Z",
        "updatedAt" : "2020-09-15T05:59:03Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "35efada5666731ec09775bd06f65d2ab589ebf89",
    "line" : null,
    "diffHunk" : "@@ -67,30 +67,36 @@ final class SemanticTests extends LedgerTestSuite {\n     case Participants(Participant(alpha, payer, owner1), Participant(beta, owner2)) =>\n       // This test create a contract and then concurrently archives it several times\n       // through two different participants\n-      val contracts = 10 // Number of contracts to create\n+      val creates = 2 // Number of contracts to create\n       val archives = 10 // Number of concurrent archives per contract\n-      Future\n-        .traverse((1 to contracts).toList)(c =>\n-          for {\n-            shared <- alpha.create(payer, SharedContract(payer, owner1, owner2))\n-            _ <- synchronize(alpha, beta)\n-            results <- Future.traverse((1 to archives).toList)(i =>\n-              i % 2 match {\n-                case 0 =>\n-                  alpha\n-                    .exercise(owner1, shared.exerciseSharedContract_Consume1)\n-                    .transform(Success(_))\n-                case 1 =>\n-                  beta\n-                    .exercise(owner2, shared.exerciseSharedContract_Consume2)\n-                    .transform(Success(_))\n-            })\n-          } yield {\n-            assertLength(s\"Contract $c successful archives\", 1, results.filter(_.isSuccess))\n-            assertLength(s\"Contract $c failed archives\", archives - 1, results.filter(_.isFailure))\n-            ()\n-        })\n-        .map(_ => ())\n+      // Each created contract is archived in parallel, next contract\n+      // is created only when previous is archived\n+      (1 to creates).toList.foldLeft(Future(())) { (f, c) =>\n+        f.flatMap(\n+          _ =>\n+            for {\n+              shared <- alpha.create(payer, SharedContract(payer, owner1, owner2))\n+              _ <- synchronize(alpha, beta)\n+              results <- Future.traverse((1 to archives).toList)(i =>"
  },
  {
    "id" : "c6e7a366-07ab-493e-9824-a1f61c803fcd",
    "prId" : 7395,
    "comments" : [
      {
        "id" : "35d05c92-d095-4c6a-9cf7-d143814a0705",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "To simplify this, you could just define a function with pattern matches directly, e.g.:\r\n```scala\r\n  results <- Future.traverse((1 to archives).toList) {\r\n    case i if i % 2 == 0 => ...\r\n    ...\r\n  }\r\n```",
        "createdAt" : "2020-09-14T17:39:25Z",
        "updatedAt" : "2020-09-15T05:57:28Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "67eff16b-8903-4377-acfe-be713578184d",
        "parentId" : "35d05c92-d095-4c6a-9cf7-d143814a0705",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Done",
        "createdAt" : "2020-09-15T05:59:13Z",
        "updatedAt" : "2020-09-15T05:59:13Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "35efada5666731ec09775bd06f65d2ab589ebf89",
    "line" : null,
    "diffHunk" : "@@ -67,30 +67,36 @@ final class SemanticTests extends LedgerTestSuite {\n     case Participants(Participant(alpha, payer, owner1), Participant(beta, owner2)) =>\n       // This test create a contract and then concurrently archives it several times\n       // through two different participants\n-      val contracts = 10 // Number of contracts to create\n+      val creates = 2 // Number of contracts to create\n       val archives = 10 // Number of concurrent archives per contract\n-      Future\n-        .traverse((1 to contracts).toList)(c =>\n-          for {\n-            shared <- alpha.create(payer, SharedContract(payer, owner1, owner2))\n-            _ <- synchronize(alpha, beta)\n-            results <- Future.traverse((1 to archives).toList)(i =>\n-              i % 2 match {\n-                case 0 =>\n-                  alpha\n-                    .exercise(owner1, shared.exerciseSharedContract_Consume1)\n-                    .transform(Success(_))\n-                case 1 =>\n-                  beta\n-                    .exercise(owner2, shared.exerciseSharedContract_Consume2)\n-                    .transform(Success(_))\n-            })\n-          } yield {\n-            assertLength(s\"Contract $c successful archives\", 1, results.filter(_.isSuccess))\n-            assertLength(s\"Contract $c failed archives\", archives - 1, results.filter(_.isFailure))\n-            ()\n-        })\n-        .map(_ => ())\n+      // Each created contract is archived in parallel, next contract\n+      // is created only when previous is archived\n+      (1 to creates).toList.foldLeft(Future(())) { (f, c) =>\n+        f.flatMap(\n+          _ =>\n+            for {\n+              shared <- alpha.create(payer, SharedContract(payer, owner1, owner2))\n+              _ <- synchronize(alpha, beta)\n+              results <- Future.traverse((1 to archives).toList)(i =>"
  },
  {
    "id" : "a1279a0a-95da-4bd5-baa7-4163919c6a89",
    "prId" : 7260,
    "comments" : [
      {
        "id" : "c1d7e150-08e7-405a-bf10-72eef2d71fd5",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I think the builtin methods will help you here.\r\n\r\n```suggestion\r\n            assertLength(s\"Contract $c successful archives\", 1, results.filter(_.isSuccess))\r\n            assertLength(s\"Contract $c failed archives\", archives - 1, results.filter(_.isFailure)))\r\n```",
        "createdAt" : "2020-08-28T12:18:59Z",
        "updatedAt" : "2020-08-31T07:39:01Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c4ab8a51a135ef171e5588a83451aeb14c64124c",
    "line" : null,
    "diffHunk" : "@@ -58,6 +59,44 @@ final class SemanticTests extends LedgerTestSuite {\n       }\n   })\n \n+  test(\n+    \"SemanticConcurrentDoubleSpend\",\n+    \"Cannot concurrently double spend across transactions\",\n+    allocate(TwoParties, SingleParty),\n+  )(implicit ec => {\n+    case Participants(Participant(alpha, payer, owner1), Participant(beta, owner2)) =>\n+      // This test create a contract and then concurrently archives it several times\n+      // through two different participants\n+      val contracts = 10 // Number of contracts to create\n+      val archives = 10 // Number of concurrent archives per contract\n+      Future\n+        .traverse((1 to contracts).toList)(c =>\n+          for {\n+            shared <- alpha.create(payer, SharedContract(payer, owner1, owner2))\n+            _ <- synchronize(alpha, beta)\n+            results <- Future.traverse((1 to archives).toList)(i =>\n+              i % 2 match {\n+                case 0 =>\n+                  alpha\n+                    .exercise(owner1, shared.exerciseSharedContract_Consume1)\n+                    .transform(Success(_))\n+                case 1 =>\n+                  beta\n+                    .exercise(owner2, shared.exerciseSharedContract_Consume2)\n+                    .transform(Success(_))\n+            })\n+          } yield {\n+            assertLength(s\"Contract $c successful archives\", 1, results.collect({\n+              case Success(_) => true\n+            }))\n+            assertLength(s\"Contract $c failed archives\", archives - 1, results.collect({\n+              case Failure(_) => true\n+            }))"
  },
  {
    "id" : "6741c338-de0a-45cb-a398-b32f727aa7ea",
    "prId" : 7260,
    "comments" : [
      {
        "id" : "23e4ef2f-3d57-4d48-9efe-14591a436e00",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "You could potentially make use of `Seq.fill` here to make this a bit more declarative, though I'm not sure whether it's bettor not. Something like:\r\n\r\n```suggestion\r\n            exercises = Seq.fill(archives / 2)(Seq(\r\n              (alpha, owner1, shared.exerciseSharedContract_Consume1),\r\n              (beta, owner2, shared.exerciseSharedContract_Consume2),\r\n            )).flatten\r\n            results <- Future.traverse(exercises) {\r\n              case (participant, owner, consume) =>\r\n                participant.exercise(owner, consume).transform(Success(_))\r\n            }\r\n```\r\n\r\n_I_ prefer it, but you don't have to agree.",
        "createdAt" : "2020-08-28T12:22:02Z",
        "updatedAt" : "2020-08-31T07:39:01Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c4ab8a51a135ef171e5588a83451aeb14c64124c",
    "line" : 37,
    "diffHunk" : "@@ -58,6 +59,44 @@ final class SemanticTests extends LedgerTestSuite {\n       }\n   })\n \n+  test(\n+    \"SemanticConcurrentDoubleSpend\",\n+    \"Cannot concurrently double spend across transactions\",\n+    allocate(TwoParties, SingleParty),\n+  )(implicit ec => {\n+    case Participants(Participant(alpha, payer, owner1), Participant(beta, owner2)) =>\n+      // This test create a contract and then concurrently archives it several times\n+      // through two different participants\n+      val contracts = 10 // Number of contracts to create\n+      val archives = 10 // Number of concurrent archives per contract\n+      Future\n+        .traverse((1 to contracts).toList)(c =>\n+          for {\n+            shared <- alpha.create(payer, SharedContract(payer, owner1, owner2))\n+            _ <- synchronize(alpha, beta)\n+            results <- Future.traverse((1 to archives).toList)(i =>\n+              i % 2 match {\n+                case 0 =>\n+                  alpha\n+                    .exercise(owner1, shared.exerciseSharedContract_Consume1)\n+                    .transform(Success(_))\n+                case 1 =>\n+                  beta\n+                    .exercise(owner2, shared.exerciseSharedContract_Consume2)\n+                    .transform(Success(_))\n+            })"
  },
  {
    "id" : "0a274f57-c955-47d6-9361-938194f95c18",
    "prId" : 6506,
    "comments" : [
      {
        "id" : "ebf1cbe2-3350-4748-a359-8b89b4636e68",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Why rename this?",
        "createdAt" : "2020-06-26T09:53:58Z",
        "updatedAt" : "2020-06-26T11:19:16Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8d4342e4db17283312fc898b18a846df59d9b908",
    "line" : null,
    "diffHunk" : "@@ -12,21 +12,21 @@ import com.daml.ledger.api.testtool.infrastructure.TransactionHelpers._\n import com.daml.ledger.api.testtool.infrastructure.participant.ParticipantTestContext\n import com.daml.ledger.api.v1.value.{Record, RecordField, Value}\n import com.daml.ledger.client.binding.Primitive\n-import com.daml.ledger.test.SemanticTests.Delegation._\n-import com.daml.ledger.test.SemanticTests.FetchIou._\n-import com.daml.ledger.test.SemanticTests.FetchPaintAgree._\n-import com.daml.ledger.test.SemanticTests.FetchPaintOffer._\n-import com.daml.ledger.test.SemanticTests.Iou._\n-import com.daml.ledger.test.SemanticTests.PaintCounterOffer._\n-import com.daml.ledger.test.SemanticTests.PaintOffer._\n-import com.daml.ledger.test.SemanticTests.SharedContract._\n-import com.daml.ledger.test.SemanticTests._\n+import com.daml.ledger.test.semantic.SemanticTests.Delegation._\n+import com.daml.ledger.test.semantic.SemanticTests.FetchIou._\n+import com.daml.ledger.test.semantic.SemanticTests.FetchPaintAgree._\n+import com.daml.ledger.test.semantic.SemanticTests.FetchPaintOffer._\n+import com.daml.ledger.test.semantic.SemanticTests.Iou._\n+import com.daml.ledger.test.semantic.SemanticTests.PaintCounterOffer._\n+import com.daml.ledger.test.semantic.SemanticTests.PaintOffer._\n+import com.daml.ledger.test.semantic.SemanticTests.SharedContract._\n+import com.daml.ledger.test.semantic.SemanticTests._\n import io.grpc.Status\n import scalaz.Tag\n \n import scala.concurrent.{ExecutionContext, Future}\n \n-final class SemanticTests extends LedgerTestSuite {\n+final class SemanticsTests extends LedgerTestSuite {"
  },
  {
    "id" : "3d5cd237-f123-407f-a52f-011467d152db",
    "prId" : 2718,
    "comments" : [
      {
        "id" : "f4b5cef4-2ecd-47b2-b916-5b411e349827",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "The error code looks wrong here. We'd want an authorization failure and not a privacy failure. The problem is that this `Iou` is not visible to the painter.\r\n\r\nAn easy way out is to add the option to `Reject` the offer for the houseOwner and try to trigger that rejection as the painter. In that case no Iou needs to be created.",
        "createdAt" : "2019-09-02T08:41:17Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1b4877f8-0328-4558-814f-57e48c84bea1",
        "parentId" : "f4b5cef4-2ecd-47b2-b916-5b411e349827",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2718/commits/c0e8912d2ea892eaa3ff0f3e22c2abdc39150d6f\r\n\r\nThe cause was that the painter is unable to see the `iou`. I worked around the problem by giving the `iou` to the painter.\r\n\r\nThis is a very good catch.\r\n\r\n![giphy](https://user-images.githubusercontent.com/43749967/64102478-5eadf200-cd70-11e9-8271-22be88de048a.gif)\r\n\r\nThis actually highlights a possible problem in how we do the validation, as @gerolf-da just told me offline.\r\n\r\nI'd say we can (for now) limit ourselves to make sure the test passes but we can easily add another test that checks that the validation is performed in the correct order.",
        "createdAt" : "2019-09-02T09:00:28Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a6031c62c41ff8b2700bab555dd502a53d5add97",
    "line" : null,
    "diffHunk" : "@@ -3,52 +3,340 @@\n \n package com.daml.ledger.api.testtool.tests\n \n+import ai.x.diff.conversions._\n import com.daml.ledger.api.testtool.infrastructure.{\n   LedgerSession,\n   LedgerTest,\n-  LedgerTestSuite,\n-  SemanticTesterLedger\n+  LedgerTestContext,\n+  LedgerTestSuite\n }\n-import com.digitalasset.daml.lf.archive.SupportedFileType.DarFile\n-import com.digitalasset.daml.lf.archive.{Decode, UniversalArchiveReader}\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester.SemanticTesterError\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.api.v1.value.{Optional, Record, RecordField, Value}\n+import com.digitalasset.ledger.test.DA.Types.{Tuple2 => DamlTuple2}\n+import com.digitalasset.ledger.test.SemanticTests.AccountInvitation._\n+import com.digitalasset.ledger.test.SemanticTests.AccountFetchByKey._\n+import com.digitalasset.ledger.test.SemanticTests.AccountLookupByKey._\n+import com.digitalasset.ledger.test.SemanticTests.Delegation._\n+import com.digitalasset.ledger.test.SemanticTests.FetchIou._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintAgree._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.Iou._\n+import com.digitalasset.ledger.test.SemanticTests.PaintCounterOffer._\n+import com.digitalasset.ledger.test.SemanticTests.PaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.SharedContract._\n+import com.digitalasset.ledger.test.SemanticTests._\n+import io.grpc.Status\n+import scalaz.Tag\n \n import scala.concurrent.Future\n-import scala.util.{Failure, Success, Try}\n \n final class SemanticTests(session: LedgerSession) extends LedgerTestSuite(session) {\n \n-  private[this] val loadedPackages = Try {\n-    val dar = UniversalArchiveReader()\n-      .readStream(\n-        \"SemanticTests.dar\",\n-        getClass.getResourceAsStream(\"/ledger/test-common/SemanticTests.dar\"),\n-        DarFile)\n-      .get\n-    dar.main._1 -> Map(dar.all.map {\n-      case (pkgId, archive) => Decode.readArchivePayloadAndVersion(pkgId, archive)._1\n-    }: _*)\n-  }\n-\n-  override val tests: Vector[LedgerTest] =\n-    loadedPackages match {\n-      case Failure(exception) =>\n-        Vector(LedgerTest(\"SemanticTests\", \"SemanticTests\") { _ =>\n-          Future.failed(\n-            new RuntimeException(\"Unable to load the semantic tests package\", exception))\n-        })\n-      case Success((main, packages)) =>\n-        for (name <- SemanticTester.scenarios(packages)(main).toVector) yield {\n-          LedgerTest(name.toString, name.toString) { ledger =>\n-            val tester =\n-              new SemanticTester(new SemanticTesterLedger(ledger, _, packages), main, packages)\n-            tester.testScenario(name).recover {\n-              case error @ SemanticTesterError(_, message) =>\n-                throw new AssertionError(message, error)\n-            }\n-          }\n+  private[this] val onePound = Amount(BigDecimal(1), \"GBP\")\n+  private[this] val twoPounds = Amount(BigDecimal(2), \"GBP\")\n+\n+  /*\n+   * Consistency\n+   *\n+   * A transaction is internally consistent for a contract\n+   * `c` if the following hold for all its subactions `act`\n+   * on the contract `c`:\n+   *\n+   * 1. `act` does not happen before any Create c action (correct by construction in DAML)\n+   * 2. `act` does not happen after the contract has been consumend (i.e. no double spending)\n+   */\n+\n+  private[this] val doubleSpendAcrossTwoTransactions =\n+    LedgerTest(\"SemanticDoubleSpend\", \"Cannot double spend across transactions\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner, leftWithNothing) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        _ <- ledger.exercise(owner, iou.exerciseTransfer(_, newOwner))\n+        failure <- ledger.exercise(owner, iou.exerciseTransfer(_, leftWithNothing)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendInTransaction =\n+    LedgerTest(\"SemanticDoubleSpendSameTx\", \"Cannot double spend within a transaction\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner1, newOwner2) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        doubleSpend <- ledger.submitAndWaitRequest(\n+          owner,\n+          iou.exerciseTransfer(owner, newOwner1).command,\n+          iou.exerciseTransfer(owner, newOwner2).command)\n+        failure <- ledger.submitAndWait(doubleSpend).failed\n+      } yield {\n+        assertGrpcError(\n+          failure,\n+          Status.Code.INVALID_ARGUMENT,\n+          \"Update failed due to fetch of an inactive contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendSharedContract =\n+    LedgerTest(\"SemanticDoubleSpendShared\", \"Different parties cannot spend the same contract\") {\n+      ledger =>\n+        for {\n+          Vector(payer, owner1, owner2) <- ledger.allocateParties(3)\n+          shared <- ledger.create(payer, SharedContract(payer, owner1, owner2))\n+          _ <- ledger.exercise(owner1, shared.exerciseSharedContract_Consume1)\n+          failure <- ledger.exercise(owner2, shared.exerciseSharedContract_Consume2).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+        }\n+    }\n+\n+  /*\n+   * Authorization\n+   *\n+   * A commit is well-authorized if every subaction `act` of the commit is\n+   * authorized by at least all of the required authorizers to `act`, where:\n+   *\n+   * 1. the required authorizers of a Create action on a contract `c` are the signatories of `c`\n+   * 2. the required authorizers of an Exercise or a Fetch action are its actors\n+   */\n+\n+  private[this] val successfulPaintOffer =\n+    LedgerTest(\"SemanticPaintOffer\", \"Conduct the paint offer worflow successfully\") { ledger =>\n+      for {\n+        Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+        iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+        offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+        tree <- ledger.exercise(houseOwner, offer.exercisePaintOffer_Accept(_, iou))\n+      } yield {\n+        val agreement = assertSingleton(\n+          \"SemanticPaintOffer\",\n+          createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+        assertEquals(\n+          \"Paint agreement parameters\",\n+          agreement.getCreateArguments,\n+          Record(\n+            recordId = Some(Tag.unwrap(PaintAgree.id)),\n+            fields = Seq(\n+              RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+              RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+            )\n+          )\n+        )\n+      }\n+    }\n+\n+  private[this] val successfulPaintCounterOffer =\n+    LedgerTest(\"SemanticPaintCounterOffer\", \"Conduct the paint counter-offer worflow successfully\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, twoPounds))\n+          counter <- ledger.exerciseAndGetContract[PaintCounterOffer](\n+            houseOwner,\n+            offer.exercisePaintOffer_Counter(_, iou))\n+          tree <- ledger.exercise(painter, counter.exercisePaintCounterOffer_Accept)\n+        } yield {\n+          val agreement = assertSingleton(\n+            \"SemanticPaintCounterOffer\",\n+            createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+          assertEquals(\n+            \"Paint agreement parameters\",\n+            agreement.getCreateArguments,\n+            Record(\n+              recordId = Some(Tag.unwrap(PaintAgree.id)),\n+              fields = Seq(\n+                RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+                RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+              )\n+            )\n+          )\n+        }\n+    }\n+\n+  private[this] val partialSignatories =\n+    LedgerTest(\n+      \"SemanticPartialSignatories\",\n+      \"A signatory should not be able to create a contract on behalf of two parties\") { ledger =>\n+      for {\n+        Vector(houseOwner, painter) <- ledger.allocateParties(2)\n+        failure <- ledger.create(houseOwner, PaintAgree(painter, houseOwner)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"requires authorizers\")\n+      }\n+    }\n+\n+  private[this] val acceptOnBehalf =\n+    LedgerTest(\n+      \"SemanticAcceptOnBehalf\",\n+      \"It should not be possible to exercise a choice without the consent of the controller\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+          failure <- ledger.exercise(painter, offer.exercisePaintOffer_Accept(_, iou)).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")"
  },
  {
    "id" : "e014a79f-98e4-47b3-88fb-b7d2e276750f",
    "prId" : 2718,
    "comments" : [
      {
        "id" : "cea666f7-f6e1-4fab-83c8-f8842ef1c9bf",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "@stefanobaghino-da : it does not seem to me that we are exploiting this note, are we? ",
        "createdAt" : "2019-09-02T08:49:09Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0ad902d3-1caf-4328-8274-fc925b01d9ad",
        "parentId" : "cea666f7-f6e1-4fab-83c8-f8842ef1c9bf",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2718/commits/a97a9e24a4c8fb23a5ba007bb7204e5987356b1c",
        "createdAt" : "2019-09-02T09:15:11Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a6031c62c41ff8b2700bab555dd502a53d5add97",
    "line" : null,
    "diffHunk" : "@@ -3,52 +3,340 @@\n \n package com.daml.ledger.api.testtool.tests\n \n+import ai.x.diff.conversions._\n import com.daml.ledger.api.testtool.infrastructure.{\n   LedgerSession,\n   LedgerTest,\n-  LedgerTestSuite,\n-  SemanticTesterLedger\n+  LedgerTestContext,\n+  LedgerTestSuite\n }\n-import com.digitalasset.daml.lf.archive.SupportedFileType.DarFile\n-import com.digitalasset.daml.lf.archive.{Decode, UniversalArchiveReader}\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester.SemanticTesterError\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.api.v1.value.{Optional, Record, RecordField, Value}\n+import com.digitalasset.ledger.test.DA.Types.{Tuple2 => DamlTuple2}\n+import com.digitalasset.ledger.test.SemanticTests.AccountInvitation._\n+import com.digitalasset.ledger.test.SemanticTests.AccountFetchByKey._\n+import com.digitalasset.ledger.test.SemanticTests.AccountLookupByKey._\n+import com.digitalasset.ledger.test.SemanticTests.Delegation._\n+import com.digitalasset.ledger.test.SemanticTests.FetchIou._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintAgree._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.Iou._\n+import com.digitalasset.ledger.test.SemanticTests.PaintCounterOffer._\n+import com.digitalasset.ledger.test.SemanticTests.PaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.SharedContract._\n+import com.digitalasset.ledger.test.SemanticTests._\n+import io.grpc.Status\n+import scalaz.Tag\n \n import scala.concurrent.Future\n-import scala.util.{Failure, Success, Try}\n \n final class SemanticTests(session: LedgerSession) extends LedgerTestSuite(session) {\n \n-  private[this] val loadedPackages = Try {\n-    val dar = UniversalArchiveReader()\n-      .readStream(\n-        \"SemanticTests.dar\",\n-        getClass.getResourceAsStream(\"/ledger/test-common/SemanticTests.dar\"),\n-        DarFile)\n-      .get\n-    dar.main._1 -> Map(dar.all.map {\n-      case (pkgId, archive) => Decode.readArchivePayloadAndVersion(pkgId, archive)._1\n-    }: _*)\n-  }\n-\n-  override val tests: Vector[LedgerTest] =\n-    loadedPackages match {\n-      case Failure(exception) =>\n-        Vector(LedgerTest(\"SemanticTests\", \"SemanticTests\") { _ =>\n-          Future.failed(\n-            new RuntimeException(\"Unable to load the semantic tests package\", exception))\n-        })\n-      case Success((main, packages)) =>\n-        for (name <- SemanticTester.scenarios(packages)(main).toVector) yield {\n-          LedgerTest(name.toString, name.toString) { ledger =>\n-            val tester =\n-              new SemanticTester(new SemanticTesterLedger(ledger, _, packages), main, packages)\n-            tester.testScenario(name).recover {\n-              case error @ SemanticTesterError(_, message) =>\n-                throw new AssertionError(message, error)\n-            }\n-          }\n+  private[this] val onePound = Amount(BigDecimal(1), \"GBP\")\n+  private[this] val twoPounds = Amount(BigDecimal(2), \"GBP\")\n+\n+  /*\n+   * Consistency\n+   *\n+   * A transaction is internally consistent for a contract\n+   * `c` if the following hold for all its subactions `act`\n+   * on the contract `c`:\n+   *\n+   * 1. `act` does not happen before any Create c action (correct by construction in DAML)\n+   * 2. `act` does not happen after the contract has been consumend (i.e. no double spending)\n+   */\n+\n+  private[this] val doubleSpendAcrossTwoTransactions =\n+    LedgerTest(\"SemanticDoubleSpend\", \"Cannot double spend across transactions\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner, leftWithNothing) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        _ <- ledger.exercise(owner, iou.exerciseTransfer(_, newOwner))\n+        failure <- ledger.exercise(owner, iou.exerciseTransfer(_, leftWithNothing)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendInTransaction =\n+    LedgerTest(\"SemanticDoubleSpendSameTx\", \"Cannot double spend within a transaction\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner1, newOwner2) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        doubleSpend <- ledger.submitAndWaitRequest(\n+          owner,\n+          iou.exerciseTransfer(owner, newOwner1).command,\n+          iou.exerciseTransfer(owner, newOwner2).command)\n+        failure <- ledger.submitAndWait(doubleSpend).failed\n+      } yield {\n+        assertGrpcError(\n+          failure,\n+          Status.Code.INVALID_ARGUMENT,\n+          \"Update failed due to fetch of an inactive contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendSharedContract =\n+    LedgerTest(\"SemanticDoubleSpendShared\", \"Different parties cannot spend the same contract\") {\n+      ledger =>\n+        for {\n+          Vector(payer, owner1, owner2) <- ledger.allocateParties(3)\n+          shared <- ledger.create(payer, SharedContract(payer, owner1, owner2))\n+          _ <- ledger.exercise(owner1, shared.exerciseSharedContract_Consume1)\n+          failure <- ledger.exercise(owner2, shared.exerciseSharedContract_Consume2).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+        }\n+    }\n+\n+  /*\n+   * Authorization\n+   *\n+   * A commit is well-authorized if every subaction `act` of the commit is\n+   * authorized by at least all of the required authorizers to `act`, where:\n+   *\n+   * 1. the required authorizers of a Create action on a contract `c` are the signatories of `c`\n+   * 2. the required authorizers of an Exercise or a Fetch action are its actors\n+   */\n+\n+  private[this] val successfulPaintOffer =\n+    LedgerTest(\"SemanticPaintOffer\", \"Conduct the paint offer worflow successfully\") { ledger =>\n+      for {\n+        Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+        iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+        offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+        tree <- ledger.exercise(houseOwner, offer.exercisePaintOffer_Accept(_, iou))\n+      } yield {\n+        val agreement = assertSingleton(\n+          \"SemanticPaintOffer\",\n+          createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+        assertEquals(\n+          \"Paint agreement parameters\",\n+          agreement.getCreateArguments,\n+          Record(\n+            recordId = Some(Tag.unwrap(PaintAgree.id)),\n+            fields = Seq(\n+              RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+              RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+            )\n+          )\n+        )\n+      }\n+    }\n+\n+  private[this] val successfulPaintCounterOffer =\n+    LedgerTest(\"SemanticPaintCounterOffer\", \"Conduct the paint counter-offer worflow successfully\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, twoPounds))\n+          counter <- ledger.exerciseAndGetContract[PaintCounterOffer](\n+            houseOwner,\n+            offer.exercisePaintOffer_Counter(_, iou))\n+          tree <- ledger.exercise(painter, counter.exercisePaintCounterOffer_Accept)\n+        } yield {\n+          val agreement = assertSingleton(\n+            \"SemanticPaintCounterOffer\",\n+            createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+          assertEquals(\n+            \"Paint agreement parameters\",\n+            agreement.getCreateArguments,\n+            Record(\n+              recordId = Some(Tag.unwrap(PaintAgree.id)),\n+              fields = Seq(\n+                RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+                RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+              )\n+            )\n+          )\n+        }\n+    }\n+\n+  private[this] val partialSignatories =\n+    LedgerTest(\n+      \"SemanticPartialSignatories\",\n+      \"A signatory should not be able to create a contract on behalf of two parties\") { ledger =>\n+      for {\n+        Vector(houseOwner, painter) <- ledger.allocateParties(2)\n+        failure <- ledger.create(houseOwner, PaintAgree(painter, houseOwner)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"requires authorizers\")\n+      }\n+    }\n+\n+  private[this] val acceptOnBehalf =\n+    LedgerTest(\n+      \"SemanticAcceptOnBehalf\",\n+      \"It should not be possible to exercise a choice without the consent of the controller\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+          failure <- ledger.exercise(painter, offer.exercisePaintOffer_Accept(_, iou)).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+        }\n+    }\n+\n+  /*\n+   * Privacy\n+   *\n+   * Visibility of contracts we fetch. Since the Ledger API has\n+   * no fetch operation built-in, we use a template with a choice\n+   * that causes the fetch.\n+   */\n+\n+  private[this] val privacyProjections =\n+    LedgerTest(\n+      \"SemanticPrivacyProjections\",\n+      \"Test visibility via contract fetches for the paint-offer flow\") { ledger =>\n+      for {\n+        Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+        iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+\n+        // The IOU should be visible only to the payer and the owner\n+        _ <- fetchIou(ledger, bank, iou)\n+        _ <- fetchIou(ledger, houseOwner, iou)\n+        _ <- fetchIou(ledger, painter, iou).failed\n+\n+        offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+\n+        // The house owner and the painter can see the offer but the bank can't\n+        _ <- fetchPaintOffer(ledger, houseOwner, offer)\n+        _ <- fetchPaintOffer(ledger, painter, offer)\n+        _ <- fetchPaintOffer(ledger, bank, offer).failed\n+\n+        // Note that the new IOU was divulged to the house owner"
  },
  {
    "id" : "e3f67c9a-7cb5-4fee-8706-bc5cbc943059",
    "prId" : 2718,
    "comments" : [
      {
        "id" : "0e04ea25-b82b-4759-a1f9-57f795347a3c",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "typo `s/doesn't/doesn't work`",
        "createdAt" : "2019-09-02T08:50:42Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "623faa29-9492-4f5d-a373-3c037cec55a5",
        "parentId" : "0e04ea25-b82b-4759-a1f9-57f795347a3c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Also `s/delegate/divulge`. Fixing, thanks.\r\n\r\n(FYI, point 6 [here](https://help.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request) can come in handy for this kind of comments :wink:)",
        "createdAt" : "2019-09-02T09:03:53Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "de8137f2-c68c-4a68-a079-693548230564",
        "parentId" : "0e04ea25-b82b-4759-a1f9-57f795347a3c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2718/commits/d3e4ae9db78fec56118cae9c519a3aea8f728c7c",
        "createdAt" : "2019-09-02T09:10:39Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a6031c62c41ff8b2700bab555dd502a53d5add97",
    "line" : null,
    "diffHunk" : "@@ -3,52 +3,340 @@\n \n package com.daml.ledger.api.testtool.tests\n \n+import ai.x.diff.conversions._\n import com.daml.ledger.api.testtool.infrastructure.{\n   LedgerSession,\n   LedgerTest,\n-  LedgerTestSuite,\n-  SemanticTesterLedger\n+  LedgerTestContext,\n+  LedgerTestSuite\n }\n-import com.digitalasset.daml.lf.archive.SupportedFileType.DarFile\n-import com.digitalasset.daml.lf.archive.{Decode, UniversalArchiveReader}\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester.SemanticTesterError\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.api.v1.value.{Optional, Record, RecordField, Value}\n+import com.digitalasset.ledger.test.DA.Types.{Tuple2 => DamlTuple2}\n+import com.digitalasset.ledger.test.SemanticTests.AccountInvitation._\n+import com.digitalasset.ledger.test.SemanticTests.AccountFetchByKey._\n+import com.digitalasset.ledger.test.SemanticTests.AccountLookupByKey._\n+import com.digitalasset.ledger.test.SemanticTests.Delegation._\n+import com.digitalasset.ledger.test.SemanticTests.FetchIou._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintAgree._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.Iou._\n+import com.digitalasset.ledger.test.SemanticTests.PaintCounterOffer._\n+import com.digitalasset.ledger.test.SemanticTests.PaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.SharedContract._\n+import com.digitalasset.ledger.test.SemanticTests._\n+import io.grpc.Status\n+import scalaz.Tag\n \n import scala.concurrent.Future\n-import scala.util.{Failure, Success, Try}\n \n final class SemanticTests(session: LedgerSession) extends LedgerTestSuite(session) {\n \n-  private[this] val loadedPackages = Try {\n-    val dar = UniversalArchiveReader()\n-      .readStream(\n-        \"SemanticTests.dar\",\n-        getClass.getResourceAsStream(\"/ledger/test-common/SemanticTests.dar\"),\n-        DarFile)\n-      .get\n-    dar.main._1 -> Map(dar.all.map {\n-      case (pkgId, archive) => Decode.readArchivePayloadAndVersion(pkgId, archive)._1\n-    }: _*)\n-  }\n-\n-  override val tests: Vector[LedgerTest] =\n-    loadedPackages match {\n-      case Failure(exception) =>\n-        Vector(LedgerTest(\"SemanticTests\", \"SemanticTests\") { _ =>\n-          Future.failed(\n-            new RuntimeException(\"Unable to load the semantic tests package\", exception))\n-        })\n-      case Success((main, packages)) =>\n-        for (name <- SemanticTester.scenarios(packages)(main).toVector) yield {\n-          LedgerTest(name.toString, name.toString) { ledger =>\n-            val tester =\n-              new SemanticTester(new SemanticTesterLedger(ledger, _, packages), main, packages)\n-            tester.testScenario(name).recover {\n-              case error @ SemanticTesterError(_, message) =>\n-                throw new AssertionError(message, error)\n-            }\n-          }\n+  private[this] val onePound = Amount(BigDecimal(1), \"GBP\")\n+  private[this] val twoPounds = Amount(BigDecimal(2), \"GBP\")\n+\n+  /*\n+   * Consistency\n+   *\n+   * A transaction is internally consistent for a contract\n+   * `c` if the following hold for all its subactions `act`\n+   * on the contract `c`:\n+   *\n+   * 1. `act` does not happen before any Create c action (correct by construction in DAML)\n+   * 2. `act` does not happen after the contract has been consumend (i.e. no double spending)\n+   */\n+\n+  private[this] val doubleSpendAcrossTwoTransactions =\n+    LedgerTest(\"SemanticDoubleSpend\", \"Cannot double spend across transactions\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner, leftWithNothing) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        _ <- ledger.exercise(owner, iou.exerciseTransfer(_, newOwner))\n+        failure <- ledger.exercise(owner, iou.exerciseTransfer(_, leftWithNothing)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendInTransaction =\n+    LedgerTest(\"SemanticDoubleSpendSameTx\", \"Cannot double spend within a transaction\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner1, newOwner2) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        doubleSpend <- ledger.submitAndWaitRequest(\n+          owner,\n+          iou.exerciseTransfer(owner, newOwner1).command,\n+          iou.exerciseTransfer(owner, newOwner2).command)\n+        failure <- ledger.submitAndWait(doubleSpend).failed\n+      } yield {\n+        assertGrpcError(\n+          failure,\n+          Status.Code.INVALID_ARGUMENT,\n+          \"Update failed due to fetch of an inactive contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendSharedContract =\n+    LedgerTest(\"SemanticDoubleSpendShared\", \"Different parties cannot spend the same contract\") {\n+      ledger =>\n+        for {\n+          Vector(payer, owner1, owner2) <- ledger.allocateParties(3)\n+          shared <- ledger.create(payer, SharedContract(payer, owner1, owner2))\n+          _ <- ledger.exercise(owner1, shared.exerciseSharedContract_Consume1)\n+          failure <- ledger.exercise(owner2, shared.exerciseSharedContract_Consume2).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+        }\n+    }\n+\n+  /*\n+   * Authorization\n+   *\n+   * A commit is well-authorized if every subaction `act` of the commit is\n+   * authorized by at least all of the required authorizers to `act`, where:\n+   *\n+   * 1. the required authorizers of a Create action on a contract `c` are the signatories of `c`\n+   * 2. the required authorizers of an Exercise or a Fetch action are its actors\n+   */\n+\n+  private[this] val successfulPaintOffer =\n+    LedgerTest(\"SemanticPaintOffer\", \"Conduct the paint offer worflow successfully\") { ledger =>\n+      for {\n+        Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+        iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+        offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+        tree <- ledger.exercise(houseOwner, offer.exercisePaintOffer_Accept(_, iou))\n+      } yield {\n+        val agreement = assertSingleton(\n+          \"SemanticPaintOffer\",\n+          createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+        assertEquals(\n+          \"Paint agreement parameters\",\n+          agreement.getCreateArguments,\n+          Record(\n+            recordId = Some(Tag.unwrap(PaintAgree.id)),\n+            fields = Seq(\n+              RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+              RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+            )\n+          )\n+        )\n+      }\n+    }\n+\n+  private[this] val successfulPaintCounterOffer =\n+    LedgerTest(\"SemanticPaintCounterOffer\", \"Conduct the paint counter-offer worflow successfully\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, twoPounds))\n+          counter <- ledger.exerciseAndGetContract[PaintCounterOffer](\n+            houseOwner,\n+            offer.exercisePaintOffer_Counter(_, iou))\n+          tree <- ledger.exercise(painter, counter.exercisePaintCounterOffer_Accept)\n+        } yield {\n+          val agreement = assertSingleton(\n+            \"SemanticPaintCounterOffer\",\n+            createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+          assertEquals(\n+            \"Paint agreement parameters\",\n+            agreement.getCreateArguments,\n+            Record(\n+              recordId = Some(Tag.unwrap(PaintAgree.id)),\n+              fields = Seq(\n+                RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+                RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+              )\n+            )\n+          )\n+        }\n+    }\n+\n+  private[this] val partialSignatories =\n+    LedgerTest(\n+      \"SemanticPartialSignatories\",\n+      \"A signatory should not be able to create a contract on behalf of two parties\") { ledger =>\n+      for {\n+        Vector(houseOwner, painter) <- ledger.allocateParties(2)\n+        failure <- ledger.create(houseOwner, PaintAgree(painter, houseOwner)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"requires authorizers\")\n+      }\n+    }\n+\n+  private[this] val acceptOnBehalf =\n+    LedgerTest(\n+      \"SemanticAcceptOnBehalf\",\n+      \"It should not be possible to exercise a choice without the consent of the controller\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+          failure <- ledger.exercise(painter, offer.exercisePaintOffer_Accept(_, iou)).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+        }\n+    }\n+\n+  /*\n+   * Privacy\n+   *\n+   * Visibility of contracts we fetch. Since the Ledger API has\n+   * no fetch operation built-in, we use a template with a choice\n+   * that causes the fetch.\n+   */\n+\n+  private[this] val privacyProjections =\n+    LedgerTest(\n+      \"SemanticPrivacyProjections\",\n+      \"Test visibility via contract fetches for the paint-offer flow\") { ledger =>\n+      for {\n+        Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+        iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+\n+        // The IOU should be visible only to the payer and the owner\n+        _ <- fetchIou(ledger, bank, iou)\n+        _ <- fetchIou(ledger, houseOwner, iou)\n+        _ <- fetchIou(ledger, painter, iou).failed\n+\n+        offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+\n+        // The house owner and the painter can see the offer but the bank can't\n+        _ <- fetchPaintOffer(ledger, houseOwner, offer)\n+        _ <- fetchPaintOffer(ledger, painter, offer)\n+        _ <- fetchPaintOffer(ledger, bank, offer).failed\n+\n+        // Note that the new IOU was divulged to the house owner\n+        tree <- ledger.exercise(houseOwner, offer.exercisePaintOffer_Accept(_, iou))\n+        (newIouEvent +: _, agreementEvent +: _) = createdEvents(tree).partition(\n+          _.getTemplateId == Tag.unwrap(Iou.id))\n+        newIou = Primitive.ContractId[Iou](newIouEvent.contractId)\n+        agreement = Primitive.ContractId[PaintAgree](agreementEvent.contractId)\n+\n+        // The Bank can see the new IOU, but it cannot see the PaintAgree contract\n+        _ <- fetchIou(ledger, bank, newIou)\n+        _ <- fetchPaintAgree(ledger, bank, agreement).failed\n+\n+        // The house owner and the painter can see the contract\n+        _ <- fetchPaintAgree(ledger, painter, agreement)\n+        _ <- fetchPaintAgree(ledger, houseOwner, agreement)\n+\n+        // The painter sees its new IOU but the house owner cannot see it\n+        _ <- fetchIou(ledger, painter, newIou)\n+        _ <- fetchIou(ledger, houseOwner, newIou).failed\n+\n+      } yield {\n+        // Nothing to do, all checks have been done in the for-comprehension\n+      }\n+    }\n+\n+  private def fetchIou(\n+      ledger: LedgerTestContext,\n+      party: Primitive.Party,\n+      iou: Primitive.ContractId[Iou]): Future[Unit] =\n+    for {\n+      fetch <- ledger.create(party, FetchIou(party, iou))\n+      _ <- ledger.exercise(party, fetch.exerciseFetchIou_Fetch)\n+    } yield ()\n+\n+  private def fetchPaintOffer(\n+      ledger: LedgerTestContext,\n+      party: Primitive.Party,\n+      paintOffer: Primitive.ContractId[PaintOffer]\n+  ): Future[Unit] =\n+    for {\n+      fetch <- ledger.create(party, FetchPaintOffer(party, paintOffer))\n+      _ <- ledger.exercise(party, fetch.exerciseFetchPaintOffer_Fetch)\n+    } yield ()\n+\n+  private def fetchPaintAgree(\n+      ledger: LedgerTestContext,\n+      party: Primitive.Party,\n+      agreement: Primitive.ContractId[PaintAgree]\n+  ): Future[Unit] =\n+    for {\n+      fetch <- ledger.create(party, FetchPaintAgree(party, agreement))\n+      _ <- ledger.exercise(party, fetch.exerciseFetchPaintAgree_Fetch)\n+    } yield ()\n+\n+  /*\n+   * Divulgence\n+   */\n+\n+  private[this] val divulgence =\n+    LedgerTest(\"SemanticDivulgence\", \"Respect divulgence rules\") { ledger =>\n+      for {\n+        Vector(issuer, owner, delegate) <- ledger.allocateParties(3)\n+        token <- ledger.create(issuer, Token(issuer, owner, 1))\n+        delegation <- ledger.create(owner, Delegation(owner, delegate))\n+\n+        // The owner tries to delegate with a non-consuming choice, which actually doesn't"
  },
  {
    "id" : "f433eccc-00e1-4dde-aaa5-ab8b2eea89d7",
    "prId" : 2718,
    "comments" : [
      {
        "id" : "ceb1b19e-59ca-49cc-ad15-4514f4698da3",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "@stefanobaghino-da : what does the comment here mean?",
        "createdAt" : "2019-09-02T08:51:12Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dad5feb5-3756-495c-82ce-d631b19377eb",
        "parentId" : "ceb1b19e-59ca-49cc-ad15-4514f4698da3",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "It's the way in which the key is computed on DAML. I left it there for reference. Unfortunately I don't think there is a way to do it organically without replicating the logic to get the key. Not that readable though, thanks for the comment, I'll make it explicit.",
        "createdAt" : "2019-09-02T09:06:26Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "baabbb93-f4ec-4049-9570-a06bc5bf1f51",
        "parentId" : "ceb1b19e-59ca-49cc-ad15-4514f4698da3",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2718/commits/7a623c3d5de46231da70f08dc86df5621b56bdbc",
        "createdAt" : "2019-09-02T09:09:23Z",
        "updatedAt" : "2019-09-02T11:48:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a6031c62c41ff8b2700bab555dd502a53d5add97",
    "line" : null,
    "diffHunk" : "@@ -3,52 +3,340 @@\n \n package com.daml.ledger.api.testtool.tests\n \n+import ai.x.diff.conversions._\n import com.daml.ledger.api.testtool.infrastructure.{\n   LedgerSession,\n   LedgerTest,\n-  LedgerTestSuite,\n-  SemanticTesterLedger\n+  LedgerTestContext,\n+  LedgerTestSuite\n }\n-import com.digitalasset.daml.lf.archive.SupportedFileType.DarFile\n-import com.digitalasset.daml.lf.archive.{Decode, UniversalArchiveReader}\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester\n-import com.digitalasset.daml.lf.engine.testing.SemanticTester.SemanticTesterError\n+import com.digitalasset.ledger.client.binding.Primitive\n+import com.digitalasset.ledger.api.v1.value.{Optional, Record, RecordField, Value}\n+import com.digitalasset.ledger.test.DA.Types.{Tuple2 => DamlTuple2}\n+import com.digitalasset.ledger.test.SemanticTests.AccountInvitation._\n+import com.digitalasset.ledger.test.SemanticTests.AccountFetchByKey._\n+import com.digitalasset.ledger.test.SemanticTests.AccountLookupByKey._\n+import com.digitalasset.ledger.test.SemanticTests.Delegation._\n+import com.digitalasset.ledger.test.SemanticTests.FetchIou._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintAgree._\n+import com.digitalasset.ledger.test.SemanticTests.FetchPaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.Iou._\n+import com.digitalasset.ledger.test.SemanticTests.PaintCounterOffer._\n+import com.digitalasset.ledger.test.SemanticTests.PaintOffer._\n+import com.digitalasset.ledger.test.SemanticTests.SharedContract._\n+import com.digitalasset.ledger.test.SemanticTests._\n+import io.grpc.Status\n+import scalaz.Tag\n \n import scala.concurrent.Future\n-import scala.util.{Failure, Success, Try}\n \n final class SemanticTests(session: LedgerSession) extends LedgerTestSuite(session) {\n \n-  private[this] val loadedPackages = Try {\n-    val dar = UniversalArchiveReader()\n-      .readStream(\n-        \"SemanticTests.dar\",\n-        getClass.getResourceAsStream(\"/ledger/test-common/SemanticTests.dar\"),\n-        DarFile)\n-      .get\n-    dar.main._1 -> Map(dar.all.map {\n-      case (pkgId, archive) => Decode.readArchivePayloadAndVersion(pkgId, archive)._1\n-    }: _*)\n-  }\n-\n-  override val tests: Vector[LedgerTest] =\n-    loadedPackages match {\n-      case Failure(exception) =>\n-        Vector(LedgerTest(\"SemanticTests\", \"SemanticTests\") { _ =>\n-          Future.failed(\n-            new RuntimeException(\"Unable to load the semantic tests package\", exception))\n-        })\n-      case Success((main, packages)) =>\n-        for (name <- SemanticTester.scenarios(packages)(main).toVector) yield {\n-          LedgerTest(name.toString, name.toString) { ledger =>\n-            val tester =\n-              new SemanticTester(new SemanticTesterLedger(ledger, _, packages), main, packages)\n-            tester.testScenario(name).recover {\n-              case error @ SemanticTesterError(_, message) =>\n-                throw new AssertionError(message, error)\n-            }\n-          }\n+  private[this] val onePound = Amount(BigDecimal(1), \"GBP\")\n+  private[this] val twoPounds = Amount(BigDecimal(2), \"GBP\")\n+\n+  /*\n+   * Consistency\n+   *\n+   * A transaction is internally consistent for a contract\n+   * `c` if the following hold for all its subactions `act`\n+   * on the contract `c`:\n+   *\n+   * 1. `act` does not happen before any Create c action (correct by construction in DAML)\n+   * 2. `act` does not happen after the contract has been consumend (i.e. no double spending)\n+   */\n+\n+  private[this] val doubleSpendAcrossTwoTransactions =\n+    LedgerTest(\"SemanticDoubleSpend\", \"Cannot double spend across transactions\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner, leftWithNothing) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        _ <- ledger.exercise(owner, iou.exerciseTransfer(_, newOwner))\n+        failure <- ledger.exercise(owner, iou.exerciseTransfer(_, leftWithNothing)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendInTransaction =\n+    LedgerTest(\"SemanticDoubleSpendSameTx\", \"Cannot double spend within a transaction\") { ledger =>\n+      for {\n+        Vector(payer, owner, newOwner1, newOwner2) <- ledger.allocateParties(4)\n+        iou <- ledger.create(payer, Iou(payer, owner, onePound))\n+        doubleSpend <- ledger.submitAndWaitRequest(\n+          owner,\n+          iou.exerciseTransfer(owner, newOwner1).command,\n+          iou.exerciseTransfer(owner, newOwner2).command)\n+        failure <- ledger.submitAndWait(doubleSpend).failed\n+      } yield {\n+        assertGrpcError(\n+          failure,\n+          Status.Code.INVALID_ARGUMENT,\n+          \"Update failed due to fetch of an inactive contract\")\n+      }\n+    }\n+\n+  private[this] val doubleSpendSharedContract =\n+    LedgerTest(\"SemanticDoubleSpendShared\", \"Different parties cannot spend the same contract\") {\n+      ledger =>\n+        for {\n+          Vector(payer, owner1, owner2) <- ledger.allocateParties(3)\n+          shared <- ledger.create(payer, SharedContract(payer, owner1, owner2))\n+          _ <- ledger.exercise(owner1, shared.exerciseSharedContract_Consume1)\n+          failure <- ledger.exercise(owner2, shared.exerciseSharedContract_Consume2).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+        }\n+    }\n+\n+  /*\n+   * Authorization\n+   *\n+   * A commit is well-authorized if every subaction `act` of the commit is\n+   * authorized by at least all of the required authorizers to `act`, where:\n+   *\n+   * 1. the required authorizers of a Create action on a contract `c` are the signatories of `c`\n+   * 2. the required authorizers of an Exercise or a Fetch action are its actors\n+   */\n+\n+  private[this] val successfulPaintOffer =\n+    LedgerTest(\"SemanticPaintOffer\", \"Conduct the paint offer worflow successfully\") { ledger =>\n+      for {\n+        Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+        iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+        offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+        tree <- ledger.exercise(houseOwner, offer.exercisePaintOffer_Accept(_, iou))\n+      } yield {\n+        val agreement = assertSingleton(\n+          \"SemanticPaintOffer\",\n+          createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+        assertEquals(\n+          \"Paint agreement parameters\",\n+          agreement.getCreateArguments,\n+          Record(\n+            recordId = Some(Tag.unwrap(PaintAgree.id)),\n+            fields = Seq(\n+              RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+              RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+            )\n+          )\n+        )\n+      }\n+    }\n+\n+  private[this] val successfulPaintCounterOffer =\n+    LedgerTest(\"SemanticPaintCounterOffer\", \"Conduct the paint counter-offer worflow successfully\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, twoPounds))\n+          counter <- ledger.exerciseAndGetContract[PaintCounterOffer](\n+            houseOwner,\n+            offer.exercisePaintOffer_Counter(_, iou))\n+          tree <- ledger.exercise(painter, counter.exercisePaintCounterOffer_Accept)\n+        } yield {\n+          val agreement = assertSingleton(\n+            \"SemanticPaintCounterOffer\",\n+            createdEvents(tree).filter(_.getTemplateId == Tag.unwrap(PaintAgree.id)))\n+          assertEquals(\n+            \"Paint agreement parameters\",\n+            agreement.getCreateArguments,\n+            Record(\n+              recordId = Some(Tag.unwrap(PaintAgree.id)),\n+              fields = Seq(\n+                RecordField(\"painter\", Some(Value(Value.Sum.Party(Tag.unwrap(painter))))),\n+                RecordField(\"houseOwner\", Some(Value(Value.Sum.Party(Tag.unwrap(houseOwner)))))\n+              )\n+            )\n+          )\n+        }\n+    }\n+\n+  private[this] val partialSignatories =\n+    LedgerTest(\n+      \"SemanticPartialSignatories\",\n+      \"A signatory should not be able to create a contract on behalf of two parties\") { ledger =>\n+      for {\n+        Vector(houseOwner, painter) <- ledger.allocateParties(2)\n+        failure <- ledger.create(houseOwner, PaintAgree(painter, houseOwner)).failed\n+      } yield {\n+        assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"requires authorizers\")\n+      }\n+    }\n+\n+  private[this] val acceptOnBehalf =\n+    LedgerTest(\n+      \"SemanticAcceptOnBehalf\",\n+      \"It should not be possible to exercise a choice without the consent of the controller\") {\n+      ledger =>\n+        for {\n+          Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+          iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+          offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+          failure <- ledger.exercise(painter, offer.exercisePaintOffer_Accept(_, iou)).failed\n+        } yield {\n+          assertGrpcError(failure, Status.Code.INVALID_ARGUMENT, \"couldn't find contract\")\n+        }\n+    }\n+\n+  /*\n+   * Privacy\n+   *\n+   * Visibility of contracts we fetch. Since the Ledger API has\n+   * no fetch operation built-in, we use a template with a choice\n+   * that causes the fetch.\n+   */\n+\n+  private[this] val privacyProjections =\n+    LedgerTest(\n+      \"SemanticPrivacyProjections\",\n+      \"Test visibility via contract fetches for the paint-offer flow\") { ledger =>\n+      for {\n+        Vector(bank, houseOwner, painter) <- ledger.allocateParties(3)\n+        iou <- ledger.create(bank, Iou(bank, houseOwner, onePound))\n+\n+        // The IOU should be visible only to the payer and the owner\n+        _ <- fetchIou(ledger, bank, iou)\n+        _ <- fetchIou(ledger, houseOwner, iou)\n+        _ <- fetchIou(ledger, painter, iou).failed\n+\n+        offer <- ledger.create(painter, PaintOffer(painter, houseOwner, bank, onePound))\n+\n+        // The house owner and the painter can see the offer but the bank can't\n+        _ <- fetchPaintOffer(ledger, houseOwner, offer)\n+        _ <- fetchPaintOffer(ledger, painter, offer)\n+        _ <- fetchPaintOffer(ledger, bank, offer).failed\n+\n+        // Note that the new IOU was divulged to the house owner\n+        tree <- ledger.exercise(houseOwner, offer.exercisePaintOffer_Accept(_, iou))\n+        (newIouEvent +: _, agreementEvent +: _) = createdEvents(tree).partition(\n+          _.getTemplateId == Tag.unwrap(Iou.id))\n+        newIou = Primitive.ContractId[Iou](newIouEvent.contractId)\n+        agreement = Primitive.ContractId[PaintAgree](agreementEvent.contractId)\n+\n+        // The Bank can see the new IOU, but it cannot see the PaintAgree contract\n+        _ <- fetchIou(ledger, bank, newIou)\n+        _ <- fetchPaintAgree(ledger, bank, agreement).failed\n+\n+        // The house owner and the painter can see the contract\n+        _ <- fetchPaintAgree(ledger, painter, agreement)\n+        _ <- fetchPaintAgree(ledger, houseOwner, agreement)\n+\n+        // The painter sees its new IOU but the house owner cannot see it\n+        _ <- fetchIou(ledger, painter, newIou)\n+        _ <- fetchIou(ledger, houseOwner, newIou).failed\n+\n+      } yield {\n+        // Nothing to do, all checks have been done in the for-comprehension\n+      }\n+    }\n+\n+  private def fetchIou(\n+      ledger: LedgerTestContext,\n+      party: Primitive.Party,\n+      iou: Primitive.ContractId[Iou]): Future[Unit] =\n+    for {\n+      fetch <- ledger.create(party, FetchIou(party, iou))\n+      _ <- ledger.exercise(party, fetch.exerciseFetchIou_Fetch)\n+    } yield ()\n+\n+  private def fetchPaintOffer(\n+      ledger: LedgerTestContext,\n+      party: Primitive.Party,\n+      paintOffer: Primitive.ContractId[PaintOffer]\n+  ): Future[Unit] =\n+    for {\n+      fetch <- ledger.create(party, FetchPaintOffer(party, paintOffer))\n+      _ <- ledger.exercise(party, fetch.exerciseFetchPaintOffer_Fetch)\n+    } yield ()\n+\n+  private def fetchPaintAgree(\n+      ledger: LedgerTestContext,\n+      party: Primitive.Party,\n+      agreement: Primitive.ContractId[PaintAgree]\n+  ): Future[Unit] =\n+    for {\n+      fetch <- ledger.create(party, FetchPaintAgree(party, agreement))\n+      _ <- ledger.exercise(party, fetch.exerciseFetchPaintAgree_Fetch)\n+    } yield ()\n+\n+  /*\n+   * Divulgence\n+   */\n+\n+  private[this] val divulgence =\n+    LedgerTest(\"SemanticDivulgence\", \"Respect divulgence rules\") { ledger =>\n+      for {\n+        Vector(issuer, owner, delegate) <- ledger.allocateParties(3)\n+        token <- ledger.create(issuer, Token(issuer, owner, 1))\n+        delegation <- ledger.create(owner, Delegation(owner, delegate))\n+\n+        // The owner tries to delegate with a non-consuming choice, which actually doesn't\n+        noDivulgeToken <- ledger.create(owner, Delegation(owner, delegate))\n+        _ <- ledger.exercise(owner, noDivulgeToken.exerciseDelegation_Wrong_Divulge_Token(_, token))\n+        _ <- ledger.exercise(delegate, delegation.exerciseDelegation_Token_Consume(_, token)).failed\n+\n+        // Successful divulgence and delegation\n+        divulgeToken <- ledger.create(owner, Delegation(owner, delegate))\n+        _ <- ledger.exercise(owner, divulgeToken.exerciseDelegation_Divulge_Token(_, token))\n+        _ <- ledger.exercise(delegate, delegation.exerciseDelegation_Token_Consume(_, token))\n+      } yield {}\n+    }\n+\n+  /*\n+   * Contract keys\n+   */\n+\n+  private[this] val contractKeys =\n+    LedgerTest(\"SemanticContractKeys\", \"Perform correctly operations based on contract keys\") {\n+      ledger =>\n+        for {\n+          Vector(bank, accountHolder) <- ledger.allocateParties(2)\n+          accountTemplate = Account(bank, accountHolder, DamlTuple2(\"CH\", 123))\n+          accountKey = DamlTuple2(bank, \"CH123\") // key (bank, accountNumber._1 <> show (this.accountNumber._2)) : (Party, Text)"
  }
]