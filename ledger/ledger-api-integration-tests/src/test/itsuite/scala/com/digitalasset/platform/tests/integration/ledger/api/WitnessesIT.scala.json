[
  {
    "id" : "01298847-b628-4241-b784-2ac4b29f3d26",
    "prId" : 959,
    "comments" : [
      {
        "id" : "70f17b10-3931-4be5-9aad-96dfa1fc212a",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "in tests we should rather use `fail(...)` instead",
        "createdAt" : "2019-05-07T06:47:34Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a6720308-17ba-4065-a4b0-c60569270b00",
        "parentId" : "70f17b10-3931-4be5-9aad-96dfa1fc212a",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "These are just scalafmt changes. I will change `sys.error` to `fail` in a separate commit.",
        "createdAt" : "2019-05-07T07:46:45Z",
        "updatedAt" : "2019-05-15T16:27:45Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e4dc5b75fb95575adb8e21bb2ae04bcccdc97acf",
    "line" : null,
    "diffHunk" : "@@ -44,81 +43,80 @@ class WitnessIT\n       \"charlie\" -> Filters.defaultInstance,\n     ))\n \n-  // TODO test for all fixtures once <https://github.com/digital-asset/daml/issues/784> is fixed\n-  \"disclosure rules are respected\" in forAllMatchingFixtures {\n-    case TestFixture(SandboxInMemory, ctx) =>\n-      val createArg = Record(\n-        fields = List(\n-          RecordField(\"p_signatory\", \"alice\".asParty),\n-          RecordField(\"p_observer\", \"bob\".asParty),\n-          RecordField(\"p_actor\", \"charlie\".asParty),\n-        ))\n-      val exerciseArg = Value(Value.Sum.Record(Record()))\n-      def exercise(cid: String, choice: String): Future[ExercisedEvent] =\n-        ctx.testingHelpers\n-          .submitAndListenForSingleTreeResultOfCommand(\n-            ctx.testingHelpers\n-              .submitRequestWithId(s\"$choice-exercise\")\n-              .update(\n-                _.commands.commands :=\n-                  List(ExerciseCommand(Some(templateIds.witnesses), cid, choice, Some(exerciseArg)).wrap),\n-                _.commands.party := \"charlie\"\n-              ),\n-            filter,\n-            false\n-          )\n-          .map { tx =>\n-            tx.eventsById(tx.rootEventIds(0)).kind match {\n-              case TreeEvent.Kind.Exercised(e) => e\n-              case _ => sys.error(\"unexpected event\")\n-            }\n-          }\n-      for {\n-        // Create Witnesses contract\n-        createTx <- ctx.testingHelpers.submitAndListenForSingleResultOfCommand(\n+  \"disclosure rules are respected\" in allFixtures { ctx =>\n+    val createArg = Record(\n+      fields = List(\n+        RecordField(\"p_signatory\", \"alice\".asParty),\n+        RecordField(\"p_observer\", \"bob\".asParty),\n+        RecordField(\"p_actor\", \"charlie\".asParty),\n+      ))\n+    val exerciseArg = Value(Value.Sum.Record(Record()))\n+    def exercise(cid: String, choice: String): Future[ExercisedEvent] =\n+      ctx.testingHelpers\n+        .submitAndListenForSingleTreeResultOfCommand(\n           ctx.testingHelpers\n-            .submitRequestWithId(\"create\")\n+            .submitRequestWithId(s\"$choice-exercise\")\n             .update(\n               _.commands.commands :=\n-                List(CreateCommand(Some(templateIds.witnesses), Some(createArg)).wrap),\n-              _.commands.party := \"alice\"\n+                List(\n+                  ExerciseCommand(Some(templateIds.witnesses), cid, choice, Some(exerciseArg)).wrap),\n+              _.commands.party := \"charlie\"\n             ),\n-          filter\n-        )\n-        createdEv = ctx.testingHelpers.getHead(ctx.testingHelpers.createdEventsIn(createTx))\n-        // Divulge Witnesses contract to charlie, who's just an actor and thus cannot\n-        // see it by default.\n-        divulgeCreatedEv <- ctx.testingHelpers.simpleCreate(\n-          \"create-divulge\",\n-          \"charlie\",\n-          templateIds.divulgeWitnesses,\n-          Record(\n-            fields =\n-              List(RecordField(value = \"alice\".asParty), RecordField(value = \"charlie\".asParty)))\n+          filter,\n+          false\n         )\n-        _ <- ctx.testingHelpers.simpleExercise(\n-          \"exercise-divulge\",\n-          \"alice\",\n-          templateIds.divulgeWitnesses,\n-          divulgeCreatedEv.contractId,\n-          \"Divulge\",\n-          Value(\n-            Value.Sum.Record(\n-              Record(fields = List(RecordField(value = createdEv.contractId.asContractId)))))\n-        )\n-        // Now, first try the non-consuming choice\n-        nonConsumingExerciseEv <- exercise(createdEv.contractId, \"WitnessesNonConsumingChoice\")\n-        // And then the consuming one\n-        consumingExerciseEv <- exercise(createdEv.contractId, \"WitnessesChoice\")\n-      } yield {\n-        createdEv.witnessParties should contain theSameElementsAs List(\"alice\", \"bob\") // stakeholders = signatories \\cup observers\n-        nonConsumingExerciseEv.witnessParties should contain theSameElementsAs List(\n-          \"alice\",\n-          \"charlie\") // signatories \\cup actors\n-        consumingExerciseEv.witnessParties should contain theSameElementsAs List(\n-          \"alice\",\n-          \"bob\",\n-          \"charlie\") // stakeholders \\cup actors\n-      }\n+        .map { tx =>\n+          tx.eventsById(tx.rootEventIds(0)).kind match {\n+            case TreeEvent.Kind.Exercised(e) => e\n+            case _ => sys.error(\"unexpected event\")"
  }
]