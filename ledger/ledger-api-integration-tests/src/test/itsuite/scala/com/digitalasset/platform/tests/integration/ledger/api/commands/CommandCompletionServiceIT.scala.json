[
  {
    "id" : "0957f178-bbca-48b9-8f38-6a1ab0f9331e",
    "prId" : 2122,
    "comments" : [
      {
        "id" : "d96e9ed5-34c9-4daf-acbe-9f19a8ace3ea",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "why not use `collect`?",
        "createdAt" : "2019-07-12T11:43:27Z",
        "updatedAt" : "2019-07-12T11:43:28Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5de11b21-ae49-4fa4-bee1-d76ef3b93b90",
        "parentId" : "d96e9ed5-34c9-4daf-acbe-9f19a8ace3ea",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "nevermind, I thought it's a reactive stream. I'd consider using the client bindings providing Akka streams here. Doing this with it would be fairly trivial.",
        "createdAt" : "2019-07-12T11:44:18Z",
        "updatedAt" : "2019-07-12T11:48:47Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "93fe5e76-4cc8-4faa-8723-60d3d3c84ff5",
        "parentId" : "d96e9ed5-34c9-4daf-acbe-9f19a8ace3ea",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "You mean as a name?",
        "createdAt" : "2019-07-12T11:56:18Z",
        "updatedAt" : "2019-07-12T11:56:19Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "13efef982312e1d7f9069e336c8aa922ed0ed968",
    "line" : 5,
    "diffHunk" : "@@ -191,7 +191,10 @@ class CommandCompletionServiceIT\n         def tailCompletions(\n             context: LedgerContext\n         ): Future[Completion] = {\n-          val (streamObserver, future) = FirstElementObserver[CompletionStreamResponse]\n+          val (streamObserver, future) = FirstElementObserver.filter[CompletionStreamResponse] {"
  },
  {
    "id" : "8d3450db-e065-46de-8298-1f5573e03e5c",
    "prId" : 1961,
    "comments" : [
      {
        "id" : "39cc7a24-420a-45f2-bd9b-84604c9ca6c5",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "mind that this is coming to avoid boiler-plating: https://github.com/digital-asset/daml/pull/1863/files#diff-1f9584cad6e35fdc752fe77e66266729R32",
        "createdAt" : "2019-07-01T15:05:07Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "975384f6-4b08-43e7-9c05-5e75f1dceeb4",
        "parentId" : "39cc7a24-420a-45f2-bd9b-84604c9ca6c5",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'll set up a reminder to fix this as soon as #1863 is merged, thanks.",
        "createdAt" : "2019-07-01T16:20:35Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e8e4b5ce2c08b6213cb9a1316617143e6daf0753",
    "line" : 58,
    "diffHunk" : "@@ -79,7 +87,7 @@ class CommandCompletionServiceIT\n             ctx.ledgerId,\n             applicationId,\n             Seq(party),\n-            LedgerOffset(Boundary(LEDGER_BEGIN)))\n+            Some(LedgerOffset(Boundary(LEDGER_BEGIN))))"
  },
  {
    "id" : "a77da6b7-fc77-4ff0-9354-1a4e221e517e",
    "prId" : 1961,
    "comments" : [
      {
        "id" : "8f896547-3086-4b0e-a1db-f77aa4aabcc2",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "I mostly use `_` in such cases, didn't know that `()` also works. What's the difference?",
        "createdAt" : "2019-07-01T15:06:51Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4351bc49-585b-4d9a-82c6-1d9ee23bbb47",
        "parentId" : "8f896547-3086-4b0e-a1db-f77aa4aabcc2",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Using `()` means that you're actually pattern matching on the returned `Unit` value.\r\n@S11001001: Will this be desugared to `withFilter` due to the pattern matching? ",
        "createdAt" : "2019-07-01T15:22:41Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "98b7b538-6f06-440a-89db-8bea20e90413",
        "parentId" : "8f896547-3086-4b0e-a1db-f77aa4aabcc2",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "It's mostly to make sure there is a compilation error is some type change. I'm not sure it's worth spending time caring about this detail, I believe the impact of this in the integration tests running time would barely be perceivable.",
        "createdAt" : "2019-07-01T15:30:56Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e241b580-7b15-4516-b651-119f934fa446",
        "parentId" : "8f896547-3086-4b0e-a1db-f77aa4aabcc2",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I slightly changed the helper functions return types and changed this for convenience.",
        "createdAt" : "2019-07-01T16:18:50Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dfe2ad89-7159-41d2-9010-7c97af68b3f8",
        "parentId" : "8f896547-3086-4b0e-a1db-f77aa4aabcc2",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "@gerolf-da Yes.\r\n\r\n@stefanobaghino-da That means you don't quite get the type-safety you expect:\r\n\r\n```scala\r\nscala> for (() <- List(1:Any, 2)) yield 42\r\nres1: List[Int] = List()\r\n```\r\n\r\nInstead:\r\n\r\n```suggestion\r\n          _ <- createDummies(arbitraryCommandIds): Future[Unit]\r\n```",
        "createdAt" : "2019-07-01T16:21:02Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "81a0f0d4-f07f-48ed-9e4c-b583e5e0cf39",
        "parentId" : "8f896547-3086-4b0e-a1db-f77aa4aabcc2",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by ~https://github.com/digital-asset/daml/pull/1961/commits/1f8fae9ab62c717e1424427319070ee4e186564f~ https://github.com/digital-asset/daml/pull/1961/commits/a331839a8e905f80f898c193e078e7de051e5608",
        "createdAt" : "2019-07-01T17:05:10Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e8e4b5ce2c08b6213cb9a1316617143e6daf0753",
    "line" : null,
    "diffHunk" : "@@ -154,6 +162,64 @@ class CommandCompletionServiceIT\n             commandIds3 should not contain (commandIds1(1))\n           }\n       }\n+\n+      \"implicitly tail the stream if no offset is passed\" in allFixtures { ctx =>\n+        // A command to create a Test.Dummy contract (see //ledger/sandbox/src/main/resources/damls/Test.daml)\n+        val createDummyCommand = ProtoCommand(\n+          ProtoCommand.Command.Create(\n+            ProtoCreateCommand(\n+              templateId = Some(templateIds.dummy),\n+              createArguments = Some(\n+                Record(\n+                  fields = Seq(\n+                    RecordField(\"operator\", Some(Value(Value.Sum.Party(party))))\n+                  )\n+                ))\n+            )))\n+\n+        // Issue the `createDummyCommand` to the ledger using the managed command client\n+        def createDummy(id: String) =\n+          for {\n+            commandClient <- ctx.commandClient(ctx.ledgerId)\n+            request = ctx.command(id, Seq(createDummyCommand))\n+            _ <- commandClient.submitSingleCommand(request)\n+          } yield ()\n+\n+        // Issues several `createDummyCommand`s\n+        def createDummies(ids: List[String]) =\n+          Future.sequence(ids.map(createDummy)).map(_ => ())\n+\n+        // Starts \"tailing\" the completions service and then issues one more command\n+        def tailCompletionsAndConcurrentlyCreateDummyWithCommandId(id: String) = {\n+          val completions = completionSource(\n+            ctx.commandCompletionService,\n+            ctx.ledgerId,\n+            applicationId,\n+            Seq(party),\n+            offset = None).runWith(Sink.queue())\n+          createDummy(id)\n+          completions\n+        }\n+\n+        // Issue 10 create commands, then listen from the ledger end (implicitly by passing no offset) and\n+        // verify that the first received completion is for the last created contract\n+\n+        val arbitraryCommandIds = List.tabulate(10)(_.toString)\n+        val targetCommandId = \"the-one\"\n+\n+        for {\n+          () <- createDummies(arbitraryCommandIds)"
  },
  {
    "id" : "78ea95a8-0f3c-4981-ba26-ba42119b1537",
    "prId" : 1961,
    "comments" : [
      {
        "id" : "49b487fd-2f5d-4fb2-bd90-82d766eba802",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "you don't have to create a client for every command you send, it's probably not too efficient",
        "createdAt" : "2019-07-01T15:13:06Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6e83a120-fe65-46a2-ad23-8358b986880b",
        "parentId" : "49b487fd-2f5d-4fb2-bd90-82d766eba802",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Good catch, thanks.",
        "createdAt" : "2019-07-01T16:22:03Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "46219ef8-47e6-44b5-b515-165ed619754c",
        "parentId" : "49b487fd-2f5d-4fb2-bd90-82d766eba802",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by ~https://github.com/digital-asset/daml/pull/1961/commits/1f8fae9ab62c717e1424427319070ee4e186564f~ https://github.com/digital-asset/daml/pull/1961/commits/a331839a8e905f80f898c193e078e7de051e5608",
        "createdAt" : "2019-07-01T17:05:25Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e8e4b5ce2c08b6213cb9a1316617143e6daf0753",
    "line" : null,
    "diffHunk" : "@@ -154,6 +162,64 @@ class CommandCompletionServiceIT\n             commandIds3 should not contain (commandIds1(1))\n           }\n       }\n+\n+      \"implicitly tail the stream if no offset is passed\" in allFixtures { ctx =>\n+        // A command to create a Test.Dummy contract (see //ledger/sandbox/src/main/resources/damls/Test.daml)\n+        val createDummyCommand = ProtoCommand(\n+          ProtoCommand.Command.Create(\n+            ProtoCreateCommand(\n+              templateId = Some(templateIds.dummy),\n+              createArguments = Some(\n+                Record(\n+                  fields = Seq(\n+                    RecordField(\"operator\", Some(Value(Value.Sum.Party(party))))\n+                  )\n+                ))\n+            )))\n+\n+        // Issue the `createDummyCommand` to the ledger using the managed command client\n+        def createDummy(id: String) =\n+          for {\n+            commandClient <- ctx.commandClient(ctx.ledgerId)"
  },
  {
    "id" : "52f1d90c-8211-4ad1-bbcb-67f2b03d3b00",
    "prId" : 1961,
    "comments" : [
      {
        "id" : "b739afae-9bef-4aba-9d13-8b70559b5455",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "to get only first element you should rather use `Sink.head` instead of a queue",
        "createdAt" : "2019-07-01T15:17:37Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "71799083-efa2-4fc8-815b-0c10a8da4919",
        "parentId" : "b739afae-9bef-4aba-9d13-8b70559b5455",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Yeah, I went through various iterations and in the end I forgot to restore `Sink.head`. Good catch, thanks! :slightly_smiling_face: ",
        "createdAt" : "2019-07-01T16:22:34Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "261d8b8f-f11e-4531-94e9-c439b95cb9ff",
        "parentId" : "b739afae-9bef-4aba-9d13-8b70559b5455",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm not entirely sure why but the tests seem to fail using `Sink.head`. I'll leave this as is it for now. Is it worth investigating this?",
        "createdAt" : "2019-07-01T16:50:44Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "540c5ddf-19eb-4768-912c-4e81ee44916d",
        "parentId" : "b739afae-9bef-4aba-9d13-8b70559b5455",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "I think it is. Using a queue here is misleading and an overkill. Can it be because of pure `Checkpoint`s? This actually reminds me that you need to filter the results stream not to get pure `Checkpoint` responses. There is a timing flaw here which can lead to flaky tests.",
        "createdAt" : "2019-07-02T06:26:27Z",
        "updatedAt" : "2019-07-02T09:31:06Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e8e4b5ce2c08b6213cb9a1316617143e6daf0753",
    "line" : null,
    "diffHunk" : "@@ -154,6 +162,64 @@ class CommandCompletionServiceIT\n             commandIds3 should not contain (commandIds1(1))\n           }\n       }\n+\n+      \"implicitly tail the stream if no offset is passed\" in allFixtures { ctx =>\n+        // A command to create a Test.Dummy contract (see //ledger/sandbox/src/main/resources/damls/Test.daml)\n+        val createDummyCommand = ProtoCommand(\n+          ProtoCommand.Command.Create(\n+            ProtoCreateCommand(\n+              templateId = Some(templateIds.dummy),\n+              createArguments = Some(\n+                Record(\n+                  fields = Seq(\n+                    RecordField(\"operator\", Some(Value(Value.Sum.Party(party))))\n+                  )\n+                ))\n+            )))\n+\n+        // Issue the `createDummyCommand` to the ledger using the managed command client\n+        def createDummy(id: String) =\n+          for {\n+            commandClient <- ctx.commandClient(ctx.ledgerId)\n+            request = ctx.command(id, Seq(createDummyCommand))\n+            _ <- commandClient.submitSingleCommand(request)\n+          } yield ()\n+\n+        // Issues several `createDummyCommand`s\n+        def createDummies(ids: List[String]) =\n+          Future.sequence(ids.map(createDummy)).map(_ => ())\n+\n+        // Starts \"tailing\" the completions service and then issues one more command\n+        def tailCompletionsAndConcurrentlyCreateDummyWithCommandId(id: String) = {\n+          val completions = completionSource(\n+            ctx.commandCompletionService,\n+            ctx.ledgerId,\n+            applicationId,\n+            Seq(party),\n+            offset = None).runWith(Sink.queue())"
  }
]