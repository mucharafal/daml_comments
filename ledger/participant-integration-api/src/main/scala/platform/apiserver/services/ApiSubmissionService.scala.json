[
  {
    "id" : "58d373bd-7be6-46f0-ac6c-cfd565f3aa1d",
    "prId" : 6924,
    "comments" : [
      {
        "id" : "5641619b-ffb9-4363-92f2-70b775c16b8e",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This is much nicer. Thanks!",
        "createdAt" : "2020-07-31T09:33:07Z",
        "updatedAt" : "2020-07-31T11:58:54Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f25933bf-9fd0-49ea-9898-7cbf302d376d",
        "parentId" : "5641619b-ffb9-4363-92f2-70b775c16b8e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'll use this approach to make the other calls to `withEnrichedLoggingContext` a bit more compact.",
        "createdAt" : "2020-07-31T12:09:08Z",
        "updatedAt" : "2020-07-31T12:09:09Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "865574590cb0a7ba8a61b4b5c4f66bdee74d6153",
    "line" : 48,
    "diffHunk" : "@@ -105,114 +104,125 @@ private[apiserver] final class ApiSubmissionService private (\n     commandExecutor: CommandExecutor,\n     configuration: ApiSubmissionService.Configuration,\n     metrics: Metrics,\n-)(implicit ec: ExecutionContext, mat: Materializer, logCtx: LoggingContext)\n+)(implicit ec: ExecutionContext, mat: Materializer, loggingContext: LoggingContext)\n     extends CommandSubmissionService\n     with ErrorFactories\n     with AutoCloseable {\n \n   private val logger = ContextualizedLogger.get(this.getClass)\n \n+  private val DuplicateCommand = Status.ALREADY_EXISTS.augmentDescription(\"Duplicate command\")\n+\n+  override def submit(request: SubmitRequest): Future[Unit] =\n+    withEnrichedLoggingContext(logging.commands(request.commands)) { implicit loggingContext =>"
  },
  {
    "id" : "3d80b053-e1e1-4984-85f2-8dbe08cca94e",
    "prId" : 6924,
    "comments" : [
      {
        "id" : "937211b7-5b95-4d88-a3a6-934702fe6725",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Lovely. :joy: ",
        "createdAt" : "2020-07-31T09:53:34Z",
        "updatedAt" : "2020-07-31T11:58:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "865574590cb0a7ba8a61b4b5c4f66bdee74d6153",
    "line" : 49,
    "diffHunk" : "@@ -105,114 +104,125 @@ private[apiserver] final class ApiSubmissionService private (\n     commandExecutor: CommandExecutor,\n     configuration: ApiSubmissionService.Configuration,\n     metrics: Metrics,\n-)(implicit ec: ExecutionContext, mat: Materializer, logCtx: LoggingContext)\n+)(implicit ec: ExecutionContext, mat: Materializer, loggingContext: LoggingContext)\n     extends CommandSubmissionService\n     with ErrorFactories\n     with AutoCloseable {\n \n   private val logger = ContextualizedLogger.get(this.getClass)\n \n+  private val DuplicateCommand = Status.ALREADY_EXISTS.augmentDescription(\"Duplicate command\")\n+\n+  override def submit(request: SubmitRequest): Future[Unit] =\n+    withEnrichedLoggingContext(logging.commands(request.commands)) { implicit loggingContext =>\n+      logger.trace(s\"Commands: ${request.commands.commands.commands}\")"
  },
  {
    "id" : "aacb60c3-4422-49d1-95ae-8eb0834c39bb",
    "prId" : 6924,
    "comments" : [
      {
        "id" : "67735f59-f786-4dbf-835f-b70192ecd096",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Unnecessary interpolation.",
        "createdAt" : "2020-07-31T09:56:06Z",
        "updatedAt" : "2020-07-31T11:58:54Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "865574590cb0a7ba8a61b4b5c4f66bdee74d6153",
    "line" : null,
    "diffHunk" : "@@ -105,114 +104,125 @@ private[apiserver] final class ApiSubmissionService private (\n     commandExecutor: CommandExecutor,\n     configuration: ApiSubmissionService.Configuration,\n     metrics: Metrics,\n-)(implicit ec: ExecutionContext, mat: Materializer, logCtx: LoggingContext)\n+)(implicit ec: ExecutionContext, mat: Materializer, loggingContext: LoggingContext)\n     extends CommandSubmissionService\n     with ErrorFactories\n     with AutoCloseable {\n \n   private val logger = ContextualizedLogger.get(this.getClass)\n \n+  private val DuplicateCommand = Status.ALREADY_EXISTS.augmentDescription(\"Duplicate command\")\n+\n+  override def submit(request: SubmitRequest): Future[Unit] =\n+    withEnrichedLoggingContext(logging.commands(request.commands)) { implicit loggingContext =>\n+      logger.trace(s\"Commands: ${request.commands.commands.commands}\")\n+      ledgerConfigProvider.latestConfiguration\n+        .map(deduplicateAndRecordOnLedger(seedService.nextSeed(), request.commands, _))\n+        .getOrElse(Future.failed(ErrorFactories.missingLedgerConfig()))\n+        .andThen(logger.logErrorsOnCall[Unit])\n+    }\n+\n   private def deduplicateAndRecordOnLedger(\n       seed: crypto.Hash,\n       commands: ApiCommands,\n-      ledgerConfig: Configuration)(implicit logCtx: LoggingContext): Future[Unit] = {\n-    val submittedAt = commands.submittedAt\n-    val deduplicateUntil = commands.deduplicateUntil\n-\n+      ledgerConfig: Configuration,\n+  )(implicit loggingContext: LoggingContext): Future[Unit] =\n     submissionService\n-      .deduplicateCommand(commands.commandId, commands.submitter, submittedAt, deduplicateUntil)\n+      .deduplicateCommand(\n+        commands.commandId,\n+        commands.submitter,\n+        commands.submittedAt,\n+        commands.deduplicateUntil,\n+      )\n       .flatMap {\n         case CommandDeduplicationNew =>\n-          recordOnLedger(seed, commands, ledgerConfig)\n-            .transform(mapSubmissionResult)\n+          evaluateAndSubmit(seed, commands, ledgerConfig)\n+            .transform(handleSubmissionResult)\n             .recoverWith {\n-              case error =>\n+              case NonFatal(originalCause) =>\n                 submissionService\n                   .stopDeduplicatingCommand(commands.commandId, commands.submitter)\n-                  .transform(_ => Failure(error))\n+                  .transform(_ => Failure(originalCause))\n             }\n-        case CommandDeduplicationDuplicate(until) =>\n+        case _: CommandDeduplicationDuplicate =>\n           metrics.daml.commands.deduplicatedCommands.mark()\n-          val reason =\n-            s\"A command with the same command ID ${commands.commandId} and submitter ${commands.submitter} was submitted before. Deduplication window until $until\"\n-          logger.debug(reason)\n-          Future.failed(Status.ALREADY_EXISTS.augmentDescription(reason).asRuntimeException)\n+          logger.debug(DuplicateCommand.getDescription)\n+          Future.failed(DuplicateCommand.asRuntimeException)\n       }\n-  }\n-\n-  override def submit(request: SubmitRequest): Future[Unit] =\n-    withEnrichedLoggingContext(\n-      logging.commandId(request.commands.commandId),\n-      logging.party(request.commands.submitter)) { implicit logCtx =>\n-      val commands = request.commands\n \n-      logger.trace(s\"Received composite commands: $commands\")\n-      logger.debug(s\"Received composite command let ${commands.commands.ledgerEffectiveTime}.\")\n-      ledgerConfigProvider.latestConfiguration.fold[Future[Unit]](\n-        Future.failed(ErrorFactories.missingLedgerConfig())\n-      )(\n-        ledgerConfig =>\n-          deduplicateAndRecordOnLedger(seedService.nextSeed(), commands, ledgerConfig)\n-            .andThen(logger.logErrorsOnCall[Unit])(DirectExecutionContext))\n-    }\n-\n-  private def mapSubmissionResult(result: Try[SubmissionResult])(\n-      implicit logCtx: LoggingContext): Try[Unit] = result match {\n+  private def handleSubmissionResult(result: Try[SubmissionResult])(\n+      implicit loggingContext: LoggingContext,\n+  ): Try[Unit] = result match {\n     case Success(Acknowledged) =>\n-      logger.debug(\"Submission of command succeeded\")\n+      logger.debug(\"Success\")\n       Success(())\n \n     case Success(Overloaded) =>\n-      logger.info(\"Submission has failed due to backpressure\")\n+      logger.info(\"Back-pressure\")\n       Failure(Status.RESOURCE_EXHAUSTED.asRuntimeException)\n \n     case Success(NotSupported) =>\n-      logger.warn(\"Submission of command was not supported\")\n+      logger.warn(\"Not supported\")\n       Failure(Status.INVALID_ARGUMENT.asRuntimeException)\n \n     case Success(InternalError(reason)) =>\n-      logger.error(s\"Submission of command failed due to an internal error, reason=$reason\")\n+      logger.error(s\"Internal error: $reason\")\n       Failure(Status.INTERNAL.augmentDescription(reason).asRuntimeException)\n \n     case Failure(error) =>\n-      logger.info(s\"Submission of command rejected: ${error.getMessage}\")\n+      logger.info(s\"Rejected: ${error.getMessage}\")\n       Failure(error)\n   }\n \n-  private def recordOnLedger(\n+  private def handleCommandExecutionResult(\n+      result: Either[ErrorCause, CommandExecutionResult],\n+  ): Future[CommandExecutionResult] =\n+    result.fold(error => {\n+      metrics.daml.commands.failedCommandInterpretations.mark()\n+      Future.failed(grpcError(toStatus(error)))\n+    }, Future.successful)\n+\n+  private def evaluateAndSubmit(\n       submissionSeed: crypto.Hash,\n       commands: ApiCommands,\n       ledgerConfig: Configuration,\n-  )(implicit logCtx: LoggingContext): Future[SubmissionResult] =\n+  )(implicit loggingContext: LoggingContext): Future[SubmissionResult] =\n     for {\n-      res <- commandExecutor.execute(commands, submissionSeed)\n-      transactionInfo <- res.fold(error => {\n-        metrics.daml.commands.failedCommandInterpretations.mark()\n-        Future.failed(grpcError(toStatus(error)))\n-      }, Future.successful)\n+      result <- commandExecutor.execute(commands, submissionSeed)\n+      transactionInfo <- handleCommandExecutionResult(result)\n       partyAllocationResults <- allocateMissingInformees(transactionInfo.transaction)\n       submissionResult <- submitTransaction(transactionInfo, partyAllocationResults, ledgerConfig)\n     } yield submissionResult\n \n+  // Takes the whole transaction to ensure to traverse it only if necessary\n   private def allocateMissingInformees(\n       transaction: SubmittedTransaction,\n-  ): Future[Seq[SubmissionResult]] =\n+  )(implicit loggingContext: LoggingContext): Future[Seq[SubmissionResult]] =\n     if (configuration.implicitPartyAllocation) {\n-      val parties: Set[Party] = transaction.nodes.values.flatMap(_.informeesOfNode).toSet\n-      partyManagementService.getParties(parties.toSeq).flatMap { partyDetails =>\n-        val missingParties = parties -- partyDetails.map(_.party)\n+      val partiesInTransaction = transaction.nodes.valuesIterator.flatMap(_.informeesOfNode).toSeq\n+      partyManagementService.getParties(partiesInTransaction).flatMap { partyDetails =>\n+        val knownParties = partyDetails.iterator.map(_.party).toSet\n+        val missingParties = partiesInTransaction.filterNot(knownParties)\n         if (missingParties.nonEmpty) {\n-          logger.info(s\"Implicitly allocating the parties: ${missingParties.mkString(\", \")}\")\n           Future.sequence(\n-            missingParties.toSeq\n-              .map(name =>\n-                writeService.allocateParty(\n-                  hint = Some(name),\n-                  displayName = Some(name),\n-                  // TODO: Just like the ApiPartyManagementService, this should do proper validation.\n-                  submissionId = v1.SubmissionId.assertFromString(UUID.randomUUID().toString),\n-              ))\n-              .map(_.toScala))\n+            missingParties\n+              .map(name => {\n+                val submissionId = v1.SubmissionId.assertFromString(UUID.randomUUID().toString)\n+                withEnrichedLoggingContext(\n+                  logging.party(name),\n+                  logging.submissionId(submissionId),\n+                ) { implicit loggingContext =>\n+                  logger.info(s\"Implicit party allocation\")"
  }
]