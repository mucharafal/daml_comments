[
  {
    "id" : "7b0c0dd2-840b-4961-8c46-edde84faab63",
    "prId" : 7593,
    "comments" : [
      {
        "id" : "9f1e2a75-8bed-4bd4-9b8a-18d2104c3ffe",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n      mat,\r\n    )\r\n```",
        "createdAt" : "2020-10-07T15:20:21Z",
        "updatedAt" : "2020-10-07T15:42:08Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "32fe45def3644018b639489ac3e03ea28f298aeb",
    "line" : null,
    "diffHunk" : "@@ -112,12 +113,14 @@ private[apiserver] object ApiPartyManagementService {\n       partyManagementServiceBackend: IndexPartyManagementService,\n       transactionsService: IndexTransactionsService,\n       writeBackend: WritePartyService,\n+      managementServiceTimeout: Duration,\n   )(implicit mat: Materializer, loggingContext: LoggingContext)\n     : PartyManagementServiceGrpc.PartyManagementService with GrpcApiService =\n     new ApiPartyManagementService(\n       partyManagementServiceBackend,\n       transactionsService,\n       writeBackend,\n+      managementServiceTimeout,\n       mat)"
  },
  {
    "id" : "767a841d-42fc-409b-87c7-71544a13c086",
    "prId" : 7171,
    "comments" : [
      {
        "id" : "115db9f1-f851-45a2-9f65-a9aaf0d0b91a",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "If you want to spend 10 minutes breaking this up in named methods the readability would probably gain much more than from removing the explicit `flatMap`.",
        "createdAt" : "2020-08-18T17:44:51Z",
        "updatedAt" : "2020-08-19T07:06:52Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "303601ab-f73a-477a-8f83-6191e3080f9c",
        "parentId" : "115db9f1-f851-45a2-9f65-a9aaf0d0b91a",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I think that's a solid idea. I did try that but abandoned it half-way because it wasn't looking amazing, but that was before some other changes that I think will make it easier.",
        "createdAt" : "2020-08-18T18:14:03Z",
        "updatedAt" : "2020-08-19T07:06:52Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "839fbb87-9d50-4ffd-a8cd-a8200bf52f97",
        "parentId" : "115db9f1-f851-45a2-9f65-a9aaf0d0b91a",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Soâ€¦ I moved a lot more behavior into `SynchronousResponse`. I hope I didn't go overboard.",
        "createdAt" : "2020-08-19T05:34:35Z",
        "updatedAt" : "2020-08-19T07:06:52Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d7cea368c8d7395d980eaa682c00046a92e2a22e",
    "line" : null,
    "diffHunk" : "@@ -98,37 +78,48 @@ private[apiserver] final class ApiPartyManagementService private (\n       else Some(Ref.Party.assertFromString(request.partyIdHint))\n     val displayName = if (request.displayName.isEmpty) None else Some(request.displayName)\n \n-    transactionService\n-      .currentLedgerEnd()\n-      .flatMap { ledgerEndBeforeRequest =>\n-        FutureConverters\n-          .toScala(writeService\n-            .allocateParty(party, displayName, submissionId))\n-          .flatMap {\n-            case SubmissionResult.Acknowledged =>\n-              pollUntilPersisted(submissionId, ledgerEndBeforeRequest).flatMap {\n-                case domain.PartyEntry.AllocationAccepted(_, partyDetails) =>\n-                  Future.successful(\n-                    AllocatePartyResponse(\n-                      Some(\n-                        PartyDetails(\n-                          partyDetails.party,\n-                          partyDetails.displayName.getOrElse(\"\"),\n-                          partyDetails.isLocal,\n-                        ))))\n-                case domain.PartyEntry.AllocationRejected(_, reason) =>\n-                  Future.failed(ErrorFactories.invalidArgument(reason))\n-              }(DE)\n-            case r @ SubmissionResult.Overloaded =>\n-              Future.failed(ErrorFactories.resourceExhausted(r.description))\n-            case r @ SubmissionResult.InternalError(_) =>\n-              Future.failed(ErrorFactories.internal(r.reason))\n-            case r @ SubmissionResult.NotSupported =>\n-              Future.failed(ErrorFactories.unimplemented(r.description))\n-          }(DE)\n-      }(DE)\n-      .andThen(logger.logErrorsOnCall[AllocatePartyResponse])(DE)\n+    // Execute subsequent transforms in the thread of the previous operation.\n+    implicit val executionContext: ExecutionContext = DE\n+\n+    val response = for {\n+      ledgerEndBeforeRequest <- transactionService.currentLedgerEnd()\n+      submissionResult <- writeService.allocateParty(party, displayName, submissionId).toScala\n+      entry <- submissionResult match {\n+        case SubmissionResult.Acknowledged =>\n+          SynchronousResponse.pollUntilPersisted(\n+            partyManagementService\n+              .partyEntries(ledgerEndBeforeRequest)\n+              .collect {\n+                case entry @ AllocationAccepted(Some(`submissionId`), _) => entry\n+                case entry @ AllocationRejected(`submissionId`, _) => entry\n+              },\n+            30.seconds,\n+          )(materializer)\n+        case r @ SubmissionResult.Overloaded =>\n+          Future.failed(ErrorFactories.resourceExhausted(r.description))\n+        case r @ SubmissionResult.InternalError(_) =>\n+          Future.failed(ErrorFactories.internal(r.reason))\n+        case r @ SubmissionResult.NotSupported =>\n+          Future.failed(ErrorFactories.unimplemented(r.description))\n+      }\n+      response <- entry match {\n+        case domain.PartyEntry.AllocationAccepted(_, partyDetails) =>\n+          Future.successful(\n+            AllocatePartyResponse(\n+              Some(\n+                PartyDetails(\n+                  partyDetails.party,\n+                  partyDetails.displayName.getOrElse(\"\"),\n+                  partyDetails.isLocal,\n+                ))))\n+        case domain.PartyEntry.AllocationRejected(_, reason) =>\n+          Future.failed(ErrorFactories.invalidArgument(reason))\n+      }"
  }
]