[
  {
    "id" : "26228136-7b9e-44ba-b876-cd9f96bf107e",
    "prId" : 7601,
    "comments" : [
      {
        "id" : "bc6780e9-049b-4ab4-b2da-5d3ab5abee3f",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n          delayTimer,\r\n        )\r\n```",
        "createdAt" : "2020-10-08T07:43:18Z",
        "updatedAt" : "2020-10-08T12:31:53Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a61fbec8a9d4dc44475daf366f77312a3c6c1c0d",
    "line" : null,
    "diffHunk" : "@@ -23,10 +24,16 @@ final class InstrumentedSourceSpec extends AsyncFlatSpec with Matchers with Akka\n \n     val capacityCounter = new Counter()\n     val maxBuffered = new InstrumentedSourceSpec.MaxValueCounter()\n+    val delayTimer = new Timer()\n \n     val (source, sink) =\n       InstrumentedSource\n-        .queue[Int](bufferSize, OverflowStrategy.backpressure, capacityCounter, maxBuffered)\n+        .queue[Int](\n+          bufferSize,\n+          OverflowStrategy.backpressure,\n+          capacityCounter,\n+          maxBuffered,\n+          delayTimer)"
  },
  {
    "id" : "ff44a2b4-d7f5-47ab-904c-3fe117f0bd62",
    "prId" : 7601,
    "comments" : [
      {
        "id" : "7731d091-9e50-4570-b082-bc5e76f0660a",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Perhaps use the scheduler here rather than blocking a Future thread?\r\n\r\n```suggestion\r\n        .mapAsync(1) { x =>\r\n          scheduler.scheduleOnce(5.seconds)(Future(x))\r\n        }\r\n```",
        "createdAt" : "2020-10-08T07:47:10Z",
        "updatedAt" : "2020-10-08T12:31:53Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5f713440-87c0-4bc0-85b2-e5058d14803e",
        "parentId" : "7731d091-9e50-4570-b082-bc5e76f0660a",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Thanks, good suggestion. I'll give it a try. (It's 5 millis though).",
        "createdAt" : "2020-10-08T12:19:55Z",
        "updatedAt" : "2020-10-08T12:31:53Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb987c30-f3d4-4fcf-9ecf-3e156ef6d679",
        "parentId" : "7731d091-9e50-4570-b082-bc5e76f0660a",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "scheduler didn't have the right methods, but found this instead: https://doc.akka.io/docs/akka/current/futures.html.",
        "createdAt" : "2020-10-08T12:30:18Z",
        "updatedAt" : "2020-10-08T12:31:53Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6c59f810-4711-4f0b-b2b8-56a08d3328dc",
        "parentId" : "7731d091-9e50-4570-b082-bc5e76f0660a",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Oh, my bad. Totally fine with the `Thread.sleep` then.",
        "createdAt" : "2020-10-08T12:54:12Z",
        "updatedAt" : "2020-10-08T12:54:12Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a61fbec8a9d4dc44475daf366f77312a3c6c1c0d",
    "line" : null,
    "diffHunk" : "@@ -47,6 +54,37 @@ final class InstrumentedSourceSpec extends AsyncFlatSpec with Matchers with Akka\n     }\n   }\n \n+  it should \"correctly measure queue delay\" in {\n+    val capacityCounter = new Counter()\n+    val maxBuffered = new InstrumentedSourceSpec.MaxValueCounter()\n+    val delayTimer = new Timer()\n+    val bufferSize = 2\n+\n+    val (source, sink) =\n+      InstrumentedSource\n+        .queue[Int](16, OverflowStrategy.backpressure, capacityCounter, maxBuffered, delayTimer)\n+        .map { x =>\n+          // Sleep to delay the processing of the next element.\n+          Thread.sleep(5)\n+          x\n+        }"
  },
  {
    "id" : "21059ad1-875b-4e86-8fdf-320bd8f01bc9",
    "prId" : 7576,
    "comments" : [
      {
        "id" : "5d130e52-1db7-4541-8b37-bd93b28879c5",
        "parentId" : null,
        "author" : {
          "login" : "hanshoglund-da",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/67470727?u=892c91ffdb18efc4ad9153a77891a6949c6c555c&v=4"
        },
        "body" : "```suggestion\r\n    // Due to differences in scheduling, we expect the highest\r\n```",
        "createdAt" : "2020-10-07T10:56:17Z",
        "updatedAt" : "2020-10-07T11:04:05Z",
        "lastEditedBy" : {
          "login" : "hanshoglund-da",
          "name" : null,
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/67470727?u=892c91ffdb18efc4ad9153a77891a6949c6c555c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "76f067753b482633f0992ac86992896c2f75fcda",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,124 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.metrics\n+\n+import java.util.concurrent.atomic.AtomicLong\n+\n+import akka.stream.scaladsl.{Keep, Sink}\n+import akka.stream.{OverflowStrategy, QueueOfferResult}\n+import com.codahale.metrics.Counter\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.scalatest.{AsyncFlatSpec, Matchers}\n+\n+import scala.concurrent.{Future, Promise}\n+\n+final class InstrumentedSourceSpec extends AsyncFlatSpec with Matchers with AkkaBeforeAndAfterAll {\n+\n+  behavior of \"InstrumentedSource.queue\"\n+\n+  it should \"correctly enqueue and track the buffer saturation\" in {\n+\n+    val bufferSize = 500\n+\n+    val capacityCounter = new Counter()\n+    val maxBuffered = new InstrumentedSourceSpec.MaxValueCounter()\n+\n+    val (source, sink) =\n+      InstrumentedSource\n+        .queue[Int](bufferSize, OverflowStrategy.backpressure, capacityCounter, maxBuffered)\n+        .toMat(Sink.seq)(Keep.both)\n+        .run()\n+\n+    // The values in the queue are not relevant, hence the random generation\n+    val input = Seq.fill(bufferSize)(util.Random.nextInt)\n+\n+    for {\n+      results <- Future.sequence(input.map(source.offer))\n+      _ = capacityCounter.getCount shouldEqual bufferSize\n+      _ = source.complete()\n+      output <- sink\n+    } yield {\n+      all(results) shouldBe QueueOfferResult.Enqueued\n+      output shouldEqual input\n+      maxBuffered.getCount shouldEqual bufferSize\n+      capacityCounter.getCount shouldEqual 0\n+      maxBuffered.decrements.get shouldEqual bufferSize\n+    }\n+  }\n+\n+  it should \"track the buffer saturation correctly when dropping items\" in {\n+\n+    val bufferSize = 500\n+\n+    // Due to differences in scheduling, we accept that the highest"
  }
]