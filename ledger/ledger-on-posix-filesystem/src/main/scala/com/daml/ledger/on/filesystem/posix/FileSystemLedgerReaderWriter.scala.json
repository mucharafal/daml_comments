[
  {
    "id" : "b2ac818e-cb35-4424-ac8e-a3fada5a3274",
    "prId" : 4177,
    "comments" : [
      {
        "id" : "8d2c9c17-f522-46e3-bbb2-c34dcba988f9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Why is this duplicated in the for-comprehension and the yield block?",
        "createdAt" : "2020-01-23T12:47:38Z",
        "updatedAt" : "2020-01-23T13:59:44Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6e96e908-3b35-4ae0-9669-36d33edda169",
        "parentId" : "8d2c9c17-f522-46e3-bbb2-c34dcba988f9",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Refactoring fail. Will fix.",
        "createdAt" : "2020-01-23T13:57:08Z",
        "updatedAt" : "2020-01-23T13:59:44Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e8a324dd393a841e950e02d5e3e659caa3a9a9d4",
    "line" : 94,
    "diffHunk" : "@@ -193,14 +183,27 @@ class FileSystemLedgerReaderWriter private (\n object FileSystemLedgerReaderWriter {\n   type Index = Int\n \n-  private val StartOffset: Index = 0\n+  private val StartIndex: Index = 0\n \n-  def apply(\n+  def owner(\n       ledgerId: LedgerId,\n       participantId: ParticipantId,\n       root: Path,\n-  )(implicit executionContext: ExecutionContext): Future[FileSystemLedgerReaderWriter] = {\n-    val ledger = new FileSystemLedgerReaderWriter(ledgerId, participantId, root)\n-    ledger.createDirectories().map(_ => ledger)\n-  }\n+  )(implicit executionContext: ExecutionContext): ResourceOwner[FileSystemLedgerReaderWriter] =\n+    for {\n+      dispatcher <- ResourceOwner.forCloseable(\n+        () =>\n+          Dispatcher(\n+            \"posix-filesystem-participant-state\",\n+            zeroIndex = StartIndex,\n+            headAtInitialization = StartIndex,\n+        ))\n+      participant <- ResourceOwner.successful(\n+        new FileSystemLedgerReaderWriter(ledgerId, participantId, root, dispatcher))\n+      _ = participant.createDirectories()\n+    } yield {\n+      val participant = new FileSystemLedgerReaderWriter(ledgerId, participantId, root, dispatcher)"
  },
  {
    "id" : "4480988b-d6b5-4ecc-8aec-d0f33f785de0",
    "prId" : 3933,
    "comments" : [
      {
        "id" : "137bcbe7-b258-4e49-9878-0b5831798469",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "This could be simplified as\r\n```suggestion\r\n        case Failure(_: NoSuchFileException) =>\r\n```",
        "createdAt" : "2020-01-08T10:44:10Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bba0ecd5-4e69-4026-87a7-f1b346205d2e",
        "parentId" : "137bcbe7-b258-4e49-9878-0b5831798469",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Done. Thanks for the tip!",
        "createdAt" : "2020-01-14T16:16:50Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a2e881199f655c2e74b34179de146b04e16081e2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.filesystem.posix\n+\n+import java.nio.file.{Files, NoSuchFileException, Path}\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.filesystem.posix.FileSystemLedgerReaderWriter._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1.{LedgerId, Offset, ParticipantId, SubmissionResult}\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.immutable\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Random, Success}\n+\n+class FileSystemLedgerReaderWriter private (\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    override val participantId: ParticipantId,\n+    root: Path,\n+)(implicit executionContext: ExecutionContext)\n+    extends LedgerReader\n+    with LedgerWriter\n+    with AutoCloseable {\n+\n+  private val lockPath = root.resolve(\"lock\")\n+  private val logDirectory = root.resolve(\"log\")\n+  private val logEntriesDirectory = logDirectory.resolve(\"entries\")\n+  private val logHeadPath = logDirectory.resolve(\"head\")\n+  private val logIndexDirectory = logDirectory.resolve(\"index\")\n+  private val stateDirectory = root.resolve(\"state\")\n+\n+  private val lock = new FileSystemLock(lockPath)\n+\n+  private val engine = Engine()\n+\n+  private val dispatcher: Dispatcher[Index] =\n+    Dispatcher(\n+      \"posix-filesystem-participant-state\",\n+      zeroIndex = StartOffset,\n+      headAtInitialization = StartOffset,\n+    )\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = {\n+    dispatcher.close()\n+  }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Index, immutable.Seq[LedgerRecord]](\n+          (index: Index, _) => index + 1,\n+          (index: Index) => retrieveLogEntry(index).map(immutable.Seq(_))\n+        )\n+      )\n+      .mapConcat {\n+        case (_, updates) => updates\n+      }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] = {\n+    val submission = Envelope\n+      .openSubmission(envelope)\n+      .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+    lock.run {\n+      for {\n+        stateInputStream <- Future.sequence(\n+          submission.getInputDamlStateList.asScala.toVector\n+            .map(key => readState(key).map(key -> _)))\n+        stateInputs: Map[DamlStateKey, Option[DamlStateValue]] = stateInputStream.toMap\n+        entryId = allocateEntryId()\n+        (logEntry, stateUpdates) = KeyValueCommitting.processSubmission(\n+          engine,\n+          entryId,\n+          currentRecordTime(),\n+          LedgerReader.DefaultTimeModel,\n+          submission,\n+          participantId,\n+          stateInputs\n+        )\n+        _ = verifyStateUpdatesAgainstPreDeclaredOutputs(stateUpdates, entryId, submission)\n+        newHead <- appendLog(entryId, Envelope.enclose(logEntry))\n+        _ <- updateState(stateUpdates)\n+      } yield {\n+        dispatcher.signalNewHead(newHead)\n+        SubmissionResult.Acknowledged\n+      }\n+    }\n+  }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  ): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  private def currentRecordTime(): Timestamp =\n+    Timestamp.assertFromInstant(Clock.systemUTC().instant())\n+\n+  private def allocateEntryId(): DamlLogEntryId = {\n+    val nonce: Array[Byte] = Array.ofDim(8)\n+    randomNumberGenerator.nextBytes(nonce)\n+    DamlLogEntryId.newBuilder\n+      .setEntryId(ByteString.copyFrom(nonce))\n+      .build\n+  }\n+\n+  private def retrieveLogEntry(index: Index): Future[LedgerRecord] =\n+    for {\n+      entryId <- Future(Files.readAllBytes(logIndexDirectory.resolve(index.toString))).transform {\n+        case Success(value) => Success(value)\n+        case Failure(exception) if exception.isInstanceOf[NoSuchFileException] =>"
  },
  {
    "id" : "604bfb50-ff29-4d04-bd9f-fe309aff4cc1",
    "prId" : 3933,
    "comments" : [
      {
        "id" : "135b4466-67fa-4b20-943a-598e0af7f1b5",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "It would be great to have a quick recap of the design here as a comment. I.e., what do we store on the different paths and how are they connected.",
        "createdAt" : "2020-01-08T10:49:10Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "39e13263-813b-4e7e-adc3-13345971a6c1",
        "parentId" : "135b4466-67fa-4b20-943a-598e0af7f1b5",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I have added comments for all the different paths.",
        "createdAt" : "2020-01-14T16:17:33Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a2e881199f655c2e74b34179de146b04e16081e2",
    "line" : 34,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.filesystem.posix\n+\n+import java.nio.file.{Files, NoSuchFileException, Path}\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.filesystem.posix.FileSystemLedgerReaderWriter._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1.{LedgerId, Offset, ParticipantId, SubmissionResult}\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.immutable\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Random, Success}\n+\n+class FileSystemLedgerReaderWriter private ("
  },
  {
    "id" : "ac792865-9e38-426a-a080-2e418f2a3410",
    "prId" : 3933,
    "comments" : [
      {
        "id" : "9f4b6486-7489-44c2-b133-7379dee324ad",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You may want to simply use a sequential log entry ID instead of a random one.",
        "createdAt" : "2020-01-08T10:50:39Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0ed3db10-bbd7-4f80-a990-1cf981f2a554",
        "parentId" : "9f4b6486-7489-44c2-b133-7379dee324ad",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Done; thanks for the changes that made this easy.",
        "createdAt" : "2020-01-14T16:17:02Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a2e881199f655c2e74b34179de146b04e16081e2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.filesystem.posix\n+\n+import java.nio.file.{Files, NoSuchFileException, Path}\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.filesystem.posix.FileSystemLedgerReaderWriter._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1.{LedgerId, Offset, ParticipantId, SubmissionResult}\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.immutable\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Random, Success}\n+\n+class FileSystemLedgerReaderWriter private (\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    override val participantId: ParticipantId,\n+    root: Path,\n+)(implicit executionContext: ExecutionContext)\n+    extends LedgerReader\n+    with LedgerWriter\n+    with AutoCloseable {\n+\n+  private val lockPath = root.resolve(\"lock\")\n+  private val logDirectory = root.resolve(\"log\")\n+  private val logEntriesDirectory = logDirectory.resolve(\"entries\")\n+  private val logHeadPath = logDirectory.resolve(\"head\")\n+  private val logIndexDirectory = logDirectory.resolve(\"index\")\n+  private val stateDirectory = root.resolve(\"state\")\n+\n+  private val lock = new FileSystemLock(lockPath)\n+\n+  private val engine = Engine()\n+\n+  private val dispatcher: Dispatcher[Index] =\n+    Dispatcher(\n+      \"posix-filesystem-participant-state\",\n+      zeroIndex = StartOffset,\n+      headAtInitialization = StartOffset,\n+    )\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = {\n+    dispatcher.close()\n+  }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Index, immutable.Seq[LedgerRecord]](\n+          (index: Index, _) => index + 1,\n+          (index: Index) => retrieveLogEntry(index).map(immutable.Seq(_))\n+        )\n+      )\n+      .mapConcat {\n+        case (_, updates) => updates\n+      }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] = {\n+    val submission = Envelope\n+      .openSubmission(envelope)\n+      .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+    lock.run {\n+      for {\n+        stateInputStream <- Future.sequence(\n+          submission.getInputDamlStateList.asScala.toVector\n+            .map(key => readState(key).map(key -> _)))\n+        stateInputs: Map[DamlStateKey, Option[DamlStateValue]] = stateInputStream.toMap\n+        entryId = allocateEntryId()\n+        (logEntry, stateUpdates) = KeyValueCommitting.processSubmission(\n+          engine,\n+          entryId,\n+          currentRecordTime(),\n+          LedgerReader.DefaultTimeModel,\n+          submission,\n+          participantId,\n+          stateInputs\n+        )\n+        _ = verifyStateUpdatesAgainstPreDeclaredOutputs(stateUpdates, entryId, submission)\n+        newHead <- appendLog(entryId, Envelope.enclose(logEntry))\n+        _ <- updateState(stateUpdates)\n+      } yield {\n+        dispatcher.signalNewHead(newHead)\n+        SubmissionResult.Acknowledged\n+      }\n+    }\n+  }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  ): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  private def currentRecordTime(): Timestamp =\n+    Timestamp.assertFromInstant(Clock.systemUTC().instant())\n+\n+  private def allocateEntryId(): DamlLogEntryId = {\n+    val nonce: Array[Byte] = Array.ofDim(8)"
  },
  {
    "id" : "0ddc10e8-3bbe-4827-89a7-d498630500ec",
    "prId" : 3933,
    "comments" : [
      {
        "id" : "abbcdb89-638b-4470-ad06-3be1656b8353",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "This could be simplified as\r\n```suggestion\r\n        case Failure(_: NoSuchFileException) =>\r\n```",
        "createdAt" : "2020-01-08T10:53:15Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b9e37eb-278b-425f-925c-e38f398cbafd",
        "parentId" : "abbcdb89-638b-4470-ad06-3be1656b8353",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Done. Thanks for the tip!",
        "createdAt" : "2020-01-14T16:16:53Z",
        "updatedAt" : "2020-01-15T13:38:34Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a2e881199f655c2e74b34179de146b04e16081e2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.filesystem.posix\n+\n+import java.nio.file.{Files, NoSuchFileException, Path}\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.filesystem.posix.FileSystemLedgerReaderWriter._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1.{LedgerId, Offset, ParticipantId, SubmissionResult}\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.immutable\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Random, Success}\n+\n+class FileSystemLedgerReaderWriter private (\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    override val participantId: ParticipantId,\n+    root: Path,\n+)(implicit executionContext: ExecutionContext)\n+    extends LedgerReader\n+    with LedgerWriter\n+    with AutoCloseable {\n+\n+  private val lockPath = root.resolve(\"lock\")\n+  private val logDirectory = root.resolve(\"log\")\n+  private val logEntriesDirectory = logDirectory.resolve(\"entries\")\n+  private val logHeadPath = logDirectory.resolve(\"head\")\n+  private val logIndexDirectory = logDirectory.resolve(\"index\")\n+  private val stateDirectory = root.resolve(\"state\")\n+\n+  private val lock = new FileSystemLock(lockPath)\n+\n+  private val engine = Engine()\n+\n+  private val dispatcher: Dispatcher[Index] =\n+    Dispatcher(\n+      \"posix-filesystem-participant-state\",\n+      zeroIndex = StartOffset,\n+      headAtInitialization = StartOffset,\n+    )\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = {\n+    dispatcher.close()\n+  }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Index, immutable.Seq[LedgerRecord]](\n+          (index: Index, _) => index + 1,\n+          (index: Index) => retrieveLogEntry(index).map(immutable.Seq(_))\n+        )\n+      )\n+      .mapConcat {\n+        case (_, updates) => updates\n+      }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] = {\n+    val submission = Envelope\n+      .openSubmission(envelope)\n+      .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+    lock.run {\n+      for {\n+        stateInputStream <- Future.sequence(\n+          submission.getInputDamlStateList.asScala.toVector\n+            .map(key => readState(key).map(key -> _)))\n+        stateInputs: Map[DamlStateKey, Option[DamlStateValue]] = stateInputStream.toMap\n+        entryId = allocateEntryId()\n+        (logEntry, stateUpdates) = KeyValueCommitting.processSubmission(\n+          engine,\n+          entryId,\n+          currentRecordTime(),\n+          LedgerReader.DefaultTimeModel,\n+          submission,\n+          participantId,\n+          stateInputs\n+        )\n+        _ = verifyStateUpdatesAgainstPreDeclaredOutputs(stateUpdates, entryId, submission)\n+        newHead <- appendLog(entryId, Envelope.enclose(logEntry))\n+        _ <- updateState(stateUpdates)\n+      } yield {\n+        dispatcher.signalNewHead(newHead)\n+        SubmissionResult.Acknowledged\n+      }\n+    }\n+  }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  ): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  private def currentRecordTime(): Timestamp =\n+    Timestamp.assertFromInstant(Clock.systemUTC().instant())\n+\n+  private def allocateEntryId(): DamlLogEntryId = {\n+    val nonce: Array[Byte] = Array.ofDim(8)\n+    randomNumberGenerator.nextBytes(nonce)\n+    DamlLogEntryId.newBuilder\n+      .setEntryId(ByteString.copyFrom(nonce))\n+      .build\n+  }\n+\n+  private def retrieveLogEntry(index: Index): Future[LedgerRecord] =\n+    for {\n+      entryId <- Future(Files.readAllBytes(logIndexDirectory.resolve(index.toString))).transform {\n+        case Success(value) => Success(value)\n+        case Failure(exception) if exception.isInstanceOf[NoSuchFileException] =>\n+          Failure(new NoSuchElementException(s\"No log entry at $index.\"))\n+        case Failure(exception) => Failure(exception)\n+      }\n+      envelope <- Future(Files.readAllBytes(logEntriesDirectory.resolve(Bytes.toString(entryId))))\n+    } yield\n+      LedgerRecord(\n+        Offset(Array(index.toLong)),\n+        DamlLogEntryId.newBuilder().setEntryId(ByteString.copyFrom(entryId)).build(),\n+        envelope)\n+\n+  private def appendLog(entry: DamlLogEntryId, envelope: ByteString): Future[Index] =\n+    for {\n+      currentHead <- Future(Files.readAllLines(logHeadPath).get(0)).transform {\n+        case Success(contents) =>\n+          Success(contents.toInt)\n+        case Failure(exception) if exception.isInstanceOf[NoSuchFileException] =>"
  }
]