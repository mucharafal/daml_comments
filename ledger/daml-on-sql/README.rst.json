[
  {
    "id" : "729ef08c-26e8-4d52-91ae-c5b8e6c3b130",
    "prId" : 6961,
    "comments" : [
      {
        "id" : "e6409805-0976-430c-b243-1d00dcb40395",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "No matter what, a dam will always be rock solid.",
        "createdAt" : "2020-08-17T07:34:33Z",
        "updatedAt" : "2020-08-17T07:34:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ebc476b8788e4e2ffe43090ce4f8e9ed5b2805ad",
    "line" : 34,
    "diffHunk" : "@@ -12,26 +12,30 @@ Setup PostgreSQL and run\n Before starting, you need to perform the following steps:\n \n - create an initially empty PostgresSQL database that *DAML on SQL* can access\n-- have a database user for *DAML on SQL* that has authority to execute DDL operations\n+- create a database user for *DAML on SQL* that has authority to execute DDL\n+  operations\n \n-This is because *DAML on SQL* manages its own database schema,\n-applying migrations if necessary when upgrading versions.\n+This is because *DAML on SQL* manages its own database schema, applying\n+migrations if necessary when upgrading versions.\n \n To specify the PostgreSQL instance you wish to connect, use the\n-``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n-is a valid JDBC URL containing the username, password and database\n-name to connect to.\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>`` is a\n+valid JDBC URL containing the username, password and database name to connect\n+to (for example, ``jdbc:postgresql://localhost/test?user=fred&password=secret``).\n \n-Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+You will also need to provide a ledger ID with the `--ledgerid` flag, which must\n+be the same upon restart. This value is expected in many API endpoints, to\n+ensure ledger clients are connecting to the correct ledger.\n \n-Due to possible conflicts between the ``&`` character and various terminal\n-shells, we recommend quoting the JDBC URL like so:\n+Due to possible conflicts between the ``&`` character and various shells, we\n+recommend quoting the JDBC URL in the terminal, as follows:\n \n .. code-block:: none\n \n-  $ java -jar dam-on-sql-<version>.jar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+  $ java -jar daml-on-sql-<version>.jar --ledgerid=test --sql-backend-jdbcurl='jdbc:postgresql://localhost/test?user=fred&password=secret'"
  },
  {
    "id" : "6a3dea23-c537-450b-9c0b-03346923e41a",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "13c37c8f-0a94-4f14-b12e-bb13fd165761",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I recommend using single quotes when no string interpolation or escaping is required.\r\n\r\n```suggestion\r\n  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\r\n```\r\n",
        "createdAt" : "2020-07-24T09:35:11Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\""
  },
  {
    "id" : "ff57d296-bf84-42f8-8613-fbc7952e695f",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "de94bde6-92a9-4c0b-8a00-313454b2753c",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I think we can probably refer to this as the \"ledger server\", as it's more than just the ledger API: it's the ledger itself, the ledger API, and the index.",
        "createdAt" : "2020-07-24T09:36:24Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8b33d029-0371-4521-bf7f-7ee12d324249",
        "parentId" : "de94bde6-92a9-4c0b-8a00-313454b2753c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "That is an implementation detail, I don't think we should commit to it in the docs.",
        "createdAt" : "2020-07-24T09:56:14Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ee49a41-5917-447d-9134-05faba6d35ce",
        "parentId" : "de94bde6-92a9-4c0b-8a00-313454b2753c",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I think we should refer to the process as _DAML on SQL_ instead of _Ledger API Server_, _Participant Server_, or _Ledger Server_. All of the latter ones are implementation details.\r\n\r\nInstead of `JVM-hosted` I think the docs could explicitly state which JVM version DAML on SQL is tested with and that this particular version is the minimum requirement and that other versions could work as well.\r\n\r\n",
        "createdAt" : "2020-07-24T15:12:34Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dd38c4b2-c312-4647-936d-4b10883115d4",
        "parentId" : "de94bde6-92a9-4c0b-8a00-313454b2753c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T07:46:53Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d929e398-2d7f-437e-be5e-348c9922db08",
        "parentId" : "de94bde6-92a9-4c0b-8a00-313454b2753c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T08:52:16Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and"
  },
  {
    "id" : "6a90e7fa-e1db-4a62-951b-3cfbf12c36c8",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "a603cb65-7fec-4ae1-99e0-f1c7887dbbf8",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Can you use an RST link for this?",
        "createdAt" : "2020-07-24T09:38:28Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8be410c8-bea0-445d-aff0-7cdff24c761c",
        "parentId" : "a603cb65-7fec-4ae1-99e0-f1c7887dbbf8",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Rst will turn this into a link automatically. You only need a link if you want a different text.",
        "createdAt" : "2020-07-24T09:48:32Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "011b1a5e-6026-4e16-b710-205a58e61b2a",
        "parentId" : "a603cb65-7fec-4ae1-99e0-f1c7887dbbf8",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/b9f12152db407dc5dcb94304c8eaea893f5e749a",
        "createdAt" : "2020-07-24T10:08:27Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html"
  },
  {
    "id" : "c762c3fc-940c-4c5a-bd49-e16fe0470115",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "201efa20-ec32-47cb-bc5b-cab74f59fdcf",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "What does the `\\` at the start of the line do?",
        "createdAt" : "2020-07-24T09:40:07Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ae7877f1-39de-49ee-bd04-f9cda0f748d9",
        "parentId" : "201efa20-ec32-47cb-bc5b-cab74f59fdcf",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "It's a literary device that I often use to confuse people when copying and pasting text. :smile: ",
        "createdAt" : "2020-07-24T09:47:51Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eafe4056-1658-447c-85f3-ee2e1466bb11",
        "parentId" : "201efa20-ec32-47cb-bc5b-cab74f59fdcf",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/9b2bfdd6d54ce32d0e2bb17c994cd1afb64ba3bb",
        "createdAt" : "2020-07-24T10:07:58Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authentication\n+=========================\n+\n+By default, DAML-on-SQL does not use any authentication and accepts all valid Ledger API requests.\n+\n+To start DAML-on-SQL with authentication based on `JWT <https://jwt.io/>`__ tokens,\n+use one of the following command line options:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  \\DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given X.509 certificate file."
  },
  {
    "id" : "f6e97e8d-5655-4185-a25c-fdad7e2a010c",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "94cbcacc-f73c-4915-a13f-563ff62f617c",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Can you wrap these lines as you have above?",
        "createdAt" : "2020-07-24T09:40:17Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8c793bed-e4dc-4fb6-80a9-c05187dafa81",
        "parentId" : "94cbcacc-f73c-4915-a13f-563ff62f617c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f6b1b2bbca8954d80ae4202d39692c4fe64a1a26",
        "createdAt" : "2020-07-24T10:08:10Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authentication\n+=========================\n+\n+By default, DAML-on-SQL does not use any authentication and accepts all valid Ledger API requests.\n+\n+To start DAML-on-SQL with authentication based on `JWT <https://jwt.io/>`__ tokens,\n+use one of the following command line options:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  \\DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given X.509 certificate file."
  },
  {
    "id" : "4185a124-9763-4de3-8fc4-808b9bfff674",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "6ea75cca-527e-47a4-b4a3-873e51421988",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "There's one option. No need to get plural.",
        "createdAt" : "2020-07-24T09:40:42Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d94451a0-fe60-4801-8c55-740c9f3e25f4",
        "parentId" : "6ea75cca-527e-47a4-b4a3-873e51421988",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/55f9b613c1f18b0d6d8b752f682ba23741599f89",
        "createdAt" : "2020-07-24T10:07:43Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authentication\n+=========================\n+\n+By default, DAML-on-SQL does not use any authentication and accepts all valid Ledger API requests.\n+\n+To start DAML-on-SQL with authentication based on `JWT <https://jwt.io/>`__ tokens,\n+use one of the following command line options:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  \\DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-es256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES256 (ECDSA using P-256 and SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certicates (binary files) are supported.\n+\n+- ``--auth-jwt-es512-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES512 (ECDSA using P-521 and SHA-512)     with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-rs256-jwks=<url>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given `JWKS <https://tools.ietf.org/html/rfc7517>`__ URL.\n+\n+.. warning::\n+\n+  For testing purposes only, the following options may also be used."
  },
  {
    "id" : "f5babd0b-c070-4943-a89d-399aa8762dc4",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "eb619cc8-cd09-4c83-a69b-21e444655637",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This section and a few below it seem to be relevant to any ledger API, not just DAML-on-SQL. Can we not just point to the relevant pages in the documentation (and improve them with the text below)?",
        "createdAt" : "2020-07-24T09:42:23Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d1b70f7-a8d3-42d1-9d83-149f8f47cc67",
        "parentId" : "eb619cc8-cd09-4c83-a69b-21e444655637",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "The JWT part is DAML-on-SQL specific, the rest is copy-pasted from the SDK docs. I'll link the definition of claims and preserve the reset.",
        "createdAt" : "2020-07-24T09:59:40Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "524038a4-e319-48b8-a83d-179204b451ed",
        "parentId" : "eb619cc8-cd09-4c83-a69b-21e444655637",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/2572ef91318bfa499ef48ab21865fe48fb48638d",
        "createdAt" : "2020-07-24T10:08:40Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : 111,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS"
  },
  {
    "id" : "b97f0803-8dd1-46ab-854a-d5f250fb8ba8",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "dcfe7389-1c7b-4c4f-9673-a17e6f2bc207",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n- ``--metrics-reporter``: passing a legal value will enable reporting; the accepted values\r\n  are as follows:\r\n```",
        "createdAt" : "2020-07-24T09:43:28Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authentication\n+=========================\n+\n+By default, DAML-on-SQL does not use any authentication and accepts all valid Ledger API requests.\n+\n+To start DAML-on-SQL with authentication based on `JWT <https://jwt.io/>`__ tokens,\n+use one of the following command line options:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  \\DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-es256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES256 (ECDSA using P-256 and SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certicates (binary files) are supported.\n+\n+- ``--auth-jwt-es512-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES512 (ECDSA using P-521 and SHA-512)     with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-rs256-jwks=<url>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given `JWKS <https://tools.ietf.org/html/rfc7517>`__ URL.\n+\n+.. warning::\n+\n+  For testing purposes only, the following options may also be used.\n+  None of them is considered safe for production:\n+\n+  - ``--auth-jwt-hs256-unsafe=<secret>``.\n+    DAML-on-SQL will expect all tokens to be signed with HMAC256 with the given plaintext secret.\n+\n+Token payload\n+^^^^^^^^^^^^^\n+\n+Access tokens contain information about the capabilities held by the bearer of the token. This information is represented by a *claim* to a given capability.\n+\n+The claims can express the following capabilities:\n+\n+- ``public``: ability to retrieve publicly available information, such as the ledger identity\n+- ``admin``: ability to interact with admin-level services, such as package uploading and user allocation\n+- ``canReadAs(p)``: ability to read information off the ledger (like the active contracts) visible to the party ``p``\n+- ``canActsAs(p)``: same as ``canReadAs(p)``, with the added ability of issuing commands on behalf of the party ``p``\n+\n+The following table summarizes what kind of claim is required to access each Ledger API endpoint:\n+\n++-------------------------------------+----------------------------+------------------------------------------+\n+| Ledger API service                  | Endpoint                   | Required claim                           |\n++=====================================+============================+==========================================+\n+| LedgerIdentityService               | GetLedgerIdentity          | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| ActiveContractsService              | GetActiveContracts         | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| CommandSubmissionService            | Submit                     | for submitting party p: canActAs(p)      |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | CompletionEnd              | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | CompletionStream           | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| CommandService                      | All                        | for submitting party p: canActAs(p)      |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| LedgerConfigurationService          | GetLedgerConfiguration     | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PackageService                      | All                        | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PackageManagementService            | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PartyManagementService              | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| ResetService                        | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| TimeService                         | GetTime                    | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | SetTime                    | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| TransactionService                  | LedgerEnd                  | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | All (except LedgerEnd)     | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+\n+DAML-on-SQL uses JWTs to express these claims.\n+\n+The following is an example of a valid JWT payload:\n+\n+.. code-block:: json\n+\n+   {\n+      \"https://daml.com/ledger-api\": {\n+        \"ledgerId\": \"aaaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\",\n+        \"participantId\": null,\n+        \"applicationId\": null,\n+        \"admin\": true,\n+        \"actAs\": [\"Alice\"],\n+        \"readAs\": [\"Bob\"]\n+      },\n+      \"exp\": 1300819380\n+   }\n+\n+where\n+\n+- ``ledgerId``, ``participantId``, ``applicationId`` restrict the validity of the token to the given ledger, participant, or application\n+- ``exp`` is the standard JWT expiration date (in seconds since Epoch)\n+- ``admin``, ``actAs`` and ``readAs`` bear the same meaning as in the :ref:`authentication <authentication-claims>` documentation\n+\n+The ``public`` claim is implicitly held by anyone bearing a valid JWT (even without being an admin or being able to act or read on behalf of any party).\n+\n+Generating JSON Web Tokens (JWT)\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To generate tokens for testing purposes, use the `jwt.io <https://jwt.io/>`__ web site.\n+\n+Generating RSA keys\n+^^^^^^^^^^^^^^^^^^^\n+\n+To generate RSA keys for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -nodes -new -x509 -keyout ledger.key -out ledger.crt\n+\n+which generates the following files:\n+\n+- ``ledger.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ledger.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Generating EC keys\n+^^^^^^^^^^^^^^^^^^\n+\n+To generate keys to be used with ES256 for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name prime256v1) -keyout ecdsa256.key -out ecdsa256.crt\n+\n+which generates the following files:\n+\n+- ``ecdsa256.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ecdsa256.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Similarly, you can use the following command for ES512 keys:\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name secp521r1) -keyout ecdsa512.key -out ecdsa512.crt\n+\n+Command-line reference\n+**********************\n+\n+To start DAML-on-SQL, run: ``java -jar daml-on-sql-<version>.jar [options] <archive>...``.\n+\n+To see all the available options, run ``java -jar daml-on-sql-<version>.jar --help``.\n+\n+Monitoring\n+**********\n+\n+Enable and configure reporting\n+==============================\n+\n+To enable metrics and configure reporting, you can use the two following CLI options:\n+\n+- ``--metrics-reporter``: passing a legal value will enable reporting; the accepted values\n+  are ``console``, ``csv:</path/to/metrics.csv>`` and ``graphite:<local_server_port>``."
  },
  {
    "id" : "6d7aa4ce-53b2-4208-b0f9-f51882754768",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "dbc2c7df-f762-45f4-a566-dc03f77385ad",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n  - ``console``: prints captured metrics to standard output\r\n```",
        "createdAt" : "2020-07-24T09:43:36Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "918431c9-febe-4771-8bde-30ef87317a88",
        "parentId" : "dbc2c7df-f762-45f4-a566-dc03f77385ad",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Worth checking whether they go to STDOUT or STDERR.",
        "createdAt" : "2020-07-24T09:44:25Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authentication\n+=========================\n+\n+By default, DAML-on-SQL does not use any authentication and accepts all valid Ledger API requests.\n+\n+To start DAML-on-SQL with authentication based on `JWT <https://jwt.io/>`__ tokens,\n+use one of the following command line options:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  \\DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-es256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES256 (ECDSA using P-256 and SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certicates (binary files) are supported.\n+\n+- ``--auth-jwt-es512-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES512 (ECDSA using P-521 and SHA-512)     with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-rs256-jwks=<url>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given `JWKS <https://tools.ietf.org/html/rfc7517>`__ URL.\n+\n+.. warning::\n+\n+  For testing purposes only, the following options may also be used.\n+  None of them is considered safe for production:\n+\n+  - ``--auth-jwt-hs256-unsafe=<secret>``.\n+    DAML-on-SQL will expect all tokens to be signed with HMAC256 with the given plaintext secret.\n+\n+Token payload\n+^^^^^^^^^^^^^\n+\n+Access tokens contain information about the capabilities held by the bearer of the token. This information is represented by a *claim* to a given capability.\n+\n+The claims can express the following capabilities:\n+\n+- ``public``: ability to retrieve publicly available information, such as the ledger identity\n+- ``admin``: ability to interact with admin-level services, such as package uploading and user allocation\n+- ``canReadAs(p)``: ability to read information off the ledger (like the active contracts) visible to the party ``p``\n+- ``canActsAs(p)``: same as ``canReadAs(p)``, with the added ability of issuing commands on behalf of the party ``p``\n+\n+The following table summarizes what kind of claim is required to access each Ledger API endpoint:\n+\n++-------------------------------------+----------------------------+------------------------------------------+\n+| Ledger API service                  | Endpoint                   | Required claim                           |\n++=====================================+============================+==========================================+\n+| LedgerIdentityService               | GetLedgerIdentity          | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| ActiveContractsService              | GetActiveContracts         | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| CommandSubmissionService            | Submit                     | for submitting party p: canActAs(p)      |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | CompletionEnd              | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | CompletionStream           | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| CommandService                      | All                        | for submitting party p: canActAs(p)      |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| LedgerConfigurationService          | GetLedgerConfiguration     | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PackageService                      | All                        | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PackageManagementService            | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PartyManagementService              | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| ResetService                        | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| TimeService                         | GetTime                    | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | SetTime                    | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| TransactionService                  | LedgerEnd                  | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | All (except LedgerEnd)     | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+\n+DAML-on-SQL uses JWTs to express these claims.\n+\n+The following is an example of a valid JWT payload:\n+\n+.. code-block:: json\n+\n+   {\n+      \"https://daml.com/ledger-api\": {\n+        \"ledgerId\": \"aaaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\",\n+        \"participantId\": null,\n+        \"applicationId\": null,\n+        \"admin\": true,\n+        \"actAs\": [\"Alice\"],\n+        \"readAs\": [\"Bob\"]\n+      },\n+      \"exp\": 1300819380\n+   }\n+\n+where\n+\n+- ``ledgerId``, ``participantId``, ``applicationId`` restrict the validity of the token to the given ledger, participant, or application\n+- ``exp`` is the standard JWT expiration date (in seconds since Epoch)\n+- ``admin``, ``actAs`` and ``readAs`` bear the same meaning as in the :ref:`authentication <authentication-claims>` documentation\n+\n+The ``public`` claim is implicitly held by anyone bearing a valid JWT (even without being an admin or being able to act or read on behalf of any party).\n+\n+Generating JSON Web Tokens (JWT)\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To generate tokens for testing purposes, use the `jwt.io <https://jwt.io/>`__ web site.\n+\n+Generating RSA keys\n+^^^^^^^^^^^^^^^^^^^\n+\n+To generate RSA keys for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -nodes -new -x509 -keyout ledger.key -out ledger.crt\n+\n+which generates the following files:\n+\n+- ``ledger.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ledger.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Generating EC keys\n+^^^^^^^^^^^^^^^^^^\n+\n+To generate keys to be used with ES256 for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name prime256v1) -keyout ecdsa256.key -out ecdsa256.crt\n+\n+which generates the following files:\n+\n+- ``ecdsa256.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ecdsa256.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Similarly, you can use the following command for ES512 keys:\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name secp521r1) -keyout ecdsa512.key -out ecdsa512.crt\n+\n+Command-line reference\n+**********************\n+\n+To start DAML-on-SQL, run: ``java -jar daml-on-sql-<version>.jar [options] <archive>...``.\n+\n+To see all the available options, run ``java -jar daml-on-sql-<version>.jar --help``.\n+\n+Monitoring\n+**********\n+\n+Enable and configure reporting\n+==============================\n+\n+To enable metrics and configure reporting, you can use the two following CLI options:\n+\n+- ``--metrics-reporter``: passing a legal value will enable reporting; the accepted values\n+  are ``console``, ``csv:</path/to/metrics.csv>`` and ``graphite:<local_server_port>``.\n+\n+  - ``console``: prints captured metrics on the standard output"
  },
  {
    "id" : "d57352c6-f2a3-4f5e-9a94-a72ea814b586",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "2f1b1b82-06e6-4570-84b3-26fd38bbd890",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\nReplicating performance envelope tests\r\n======================================\r\n```",
        "createdAt" : "2020-07-24T09:45:06Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f0b05b23-950b-47f5-ae40-55d5e9aad358",
        "parentId" : "2f1b1b82-06e6-4570-84b3-26fd38bbd890",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Nope, sorry, where possible I try to keep an instructional tone, it was a recommendation that [we got from a former employee](https://www.youtube.com/watch?v=8TD-20Mb_7M).",
        "createdAt" : "2020-07-24T09:51:56Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9aabbc7b-1ec4-4758-9ebb-44885a93be26",
        "parentId" : "2f1b1b82-06e6-4570-84b3-26fd38bbd890",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "You've used \"Generating\" above a lot though. 😛 ",
        "createdAt" : "2020-07-24T10:26:31Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "de26a863-146d-4ecc-b082-78b81a3d6a31",
        "parentId" : "2f1b1b82-06e6-4570-84b3-26fd38bbd890",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Maybe `Reproduce`?",
        "createdAt" : "2020-07-24T15:35:58Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : 692,
    "diffHunk" : "@@ -0,0 +1,742 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl \"jdbc:postgresql://localhost/test?user=fred&password=secret\"\n+\n+If you're not familiar with JDBC URLs, see the PostgreSQL JDBC docs for more information: https://jdbc.postgresql.org/documentation/head/connect.html\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authentication\n+=========================\n+\n+By default, DAML-on-SQL does not use any authentication and accepts all valid Ledger API requests.\n+\n+To start DAML-on-SQL with authentication based on `JWT <https://jwt.io/>`__ tokens,\n+use one of the following command line options:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  \\DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-es256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES256 (ECDSA using P-256 and SHA-256) with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certicates (binary files) are supported.\n+\n+- ``--auth-jwt-es512-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES512 (ECDSA using P-521 and SHA-512)     with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-rs256-jwks=<url>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256) with the public key loaded from the given `JWKS <https://tools.ietf.org/html/rfc7517>`__ URL.\n+\n+.. warning::\n+\n+  For testing purposes only, the following options may also be used.\n+  None of them is considered safe for production:\n+\n+  - ``--auth-jwt-hs256-unsafe=<secret>``.\n+    DAML-on-SQL will expect all tokens to be signed with HMAC256 with the given plaintext secret.\n+\n+Token payload\n+^^^^^^^^^^^^^\n+\n+Access tokens contain information about the capabilities held by the bearer of the token. This information is represented by a *claim* to a given capability.\n+\n+The claims can express the following capabilities:\n+\n+- ``public``: ability to retrieve publicly available information, such as the ledger identity\n+- ``admin``: ability to interact with admin-level services, such as package uploading and user allocation\n+- ``canReadAs(p)``: ability to read information off the ledger (like the active contracts) visible to the party ``p``\n+- ``canActsAs(p)``: same as ``canReadAs(p)``, with the added ability of issuing commands on behalf of the party ``p``\n+\n+The following table summarizes what kind of claim is required to access each Ledger API endpoint:\n+\n++-------------------------------------+----------------------------+------------------------------------------+\n+| Ledger API service                  | Endpoint                   | Required claim                           |\n++=====================================+============================+==========================================+\n+| LedgerIdentityService               | GetLedgerIdentity          | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| ActiveContractsService              | GetActiveContracts         | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| CommandSubmissionService            | Submit                     | for submitting party p: canActAs(p)      |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | CompletionEnd              | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | CompletionStream           | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| CommandService                      | All                        | for submitting party p: canActAs(p)      |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| LedgerConfigurationService          | GetLedgerConfiguration     | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PackageService                      | All                        | public                                   |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PackageManagementService            | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| PartyManagementService              | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| ResetService                        | All                        | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| TimeService                         | GetTime                    | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | SetTime                    | admin                                    |\n++-------------------------------------+----------------------------+------------------------------------------+\n+| TransactionService                  | LedgerEnd                  | public                                   |\n+|                                     +----------------------------+------------------------------------------+\n+|                                     | All (except LedgerEnd)     | for each requested party p: canReadAs(p) |\n++-------------------------------------+----------------------------+------------------------------------------+\n+\n+DAML-on-SQL uses JWTs to express these claims.\n+\n+The following is an example of a valid JWT payload:\n+\n+.. code-block:: json\n+\n+   {\n+      \"https://daml.com/ledger-api\": {\n+        \"ledgerId\": \"aaaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\",\n+        \"participantId\": null,\n+        \"applicationId\": null,\n+        \"admin\": true,\n+        \"actAs\": [\"Alice\"],\n+        \"readAs\": [\"Bob\"]\n+      },\n+      \"exp\": 1300819380\n+   }\n+\n+where\n+\n+- ``ledgerId``, ``participantId``, ``applicationId`` restrict the validity of the token to the given ledger, participant, or application\n+- ``exp`` is the standard JWT expiration date (in seconds since Epoch)\n+- ``admin``, ``actAs`` and ``readAs`` bear the same meaning as in the :ref:`authentication <authentication-claims>` documentation\n+\n+The ``public`` claim is implicitly held by anyone bearing a valid JWT (even without being an admin or being able to act or read on behalf of any party).\n+\n+Generating JSON Web Tokens (JWT)\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To generate tokens for testing purposes, use the `jwt.io <https://jwt.io/>`__ web site.\n+\n+Generating RSA keys\n+^^^^^^^^^^^^^^^^^^^\n+\n+To generate RSA keys for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -nodes -new -x509 -keyout ledger.key -out ledger.crt\n+\n+which generates the following files:\n+\n+- ``ledger.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ledger.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Generating EC keys\n+^^^^^^^^^^^^^^^^^^\n+\n+To generate keys to be used with ES256 for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name prime256v1) -keyout ecdsa256.key -out ecdsa256.crt\n+\n+which generates the following files:\n+\n+- ``ecdsa256.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ecdsa256.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Similarly, you can use the following command for ES512 keys:\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name secp521r1) -keyout ecdsa512.key -out ecdsa512.crt\n+\n+Command-line reference\n+**********************\n+\n+To start DAML-on-SQL, run: ``java -jar daml-on-sql-<version>.jar [options] <archive>...``.\n+\n+To see all the available options, run ``java -jar daml-on-sql-<version>.jar --help``.\n+\n+Monitoring\n+**********\n+\n+Enable and configure reporting\n+==============================\n+\n+To enable metrics and configure reporting, you can use the two following CLI options:\n+\n+- ``--metrics-reporter``: passing a legal value will enable reporting; the accepted values\n+  are ``console``, ``csv:</path/to/metrics.csv>`` and ``graphite:<local_server_port>``.\n+\n+  - ``console``: prints captured metrics on the standard output\n+\n+  - ``csv://</path/to/metrics.csv>``: saves the captured metrics in CSV format at the specified location\n+\n+  - ``graphite://<server_host>[:<server_port>]``: sends captured metrics to a Graphite server. If the port\n+    is omitted, the default value ``2003`` will be used.\n+\n+- ``--metrics-reporting-interval``: metrics are pre-aggregated on DAML-on-SQL and sent to\n+  the reporter, this option allows the user to set the interval. The formats accepted are based\n+  on the ISO-8601 duration format ``PnDTnHnMn.nS`` with days considered to be exactly 24 hours.\n+  The default interval is 10 seconds.\n+\n+Types of metrics\n+================\n+\n+This is a list of type of metrics with all data points recorded for each.\n+Use this as a reference when reading the list of metrics.\n+\n+Gauge\n+-----\n+\n+An individual instantaneous measurement.\n+\n+Counter\n+-------\n+\n+Number of occurrences of some event.\n+\n+Meter\n+-----\n+\n+A meter tracks the number of times a given event occurred. The following data\n+points are kept and reported by any meter.\n+\n+- ``<metric.qualified.name>.count``: number of registered data points overall\n+- ``<metric.qualified.name>.m1_rate``: number of registered data points per minute\n+- ``<metric.qualified.name>.m5_rate``: number of registered data points every 5 minutes\n+- ``<metric.qualified.name>.m15_rate``: number of registered data points every 15 minutes\n+- ``<metric.qualified.name>.mean_rate``: mean number of registered data points\n+\n+Histogram\n+---------\n+\n+An histogram records aggregated statistics about collections of events.\n+The exact meaning of the number depends on the metric (e.g. timers\n+are histograms about the time necessary to complete an operation).\n+\n+- ``<metric.qualified.name>.mean``: arithmetic mean\n+- ``<metric.qualified.name>.stddev``: standard deviation\n+- ``<metric.qualified.name>.p50``: median\n+- ``<metric.qualified.name>.p75``: 75th percentile\n+- ``<metric.qualified.name>.p95``: 95th percentile\n+- ``<metric.qualified.name>.p98``: 98th percentile\n+- ``<metric.qualified.name>.p99``: 99th percentile\n+- ``<metric.qualified.name>.p999``: 99.9th percentile\n+- ``<metric.qualified.name>.min``: lowest registered value overall\n+- ``<metric.qualified.name>.max``: highest registered value overall\n+\n+Histograms only keep a small *reservoir* of statistically relevant data points\n+to ensure that metrics collection can be reasonably accurate without being\n+too taxing resource-wise.\n+\n+Unless mentioned otherwise all histograms (including timers, mentioned below)\n+use exponentially decaying reservoirs (i.e. the data is roughly relevant for\n+the last five minutes of recording) to ensure that recent and possibly\n+operationally relevant changes are visible through the metrics reporter.\n+\n+Note that ``min`` and ``max`` values are not affected by the reservoir sampling policy.\n+\n+You can read more about reservoir sampling and possible associated policies\n+in the `Dropwizard Metrics library documentation <https://metrics.dropwizard.io/4.1.2/manual/core.html#man-core-histograms/>`__.\n+\n+Timers\n+------\n+\n+A timer records all metrics registered by a meter and by an histogram, where\n+the histogram records the time necessary to execute a given operation (unless\n+otherwise specified, the precision is nanoseconds and the unit of measurement\n+is milliseconds).\n+\n+Database Metrics\n+----------------\n+\n+A \"database metric\" is a collection of simpler metrics that keep track of\n+relevant numbers when interacting with a persistent relational store.\n+\n+These metrics are:\n+\n+- ``<metric.qualified.name>.wait`` (timer): time to acquire a connection to the database\n+- ``<metric.qualified.name>.exec`` (timer): time to run the query and read the result\n+- ``<metric.qualified.name>.query`` (timer): time to run the query\n+- ``<metric.qualified.name>.commit`` (timer): time to perform the commit\n+- ``<metric.qualified.name>.translation`` (timer): if relevant, time necessary to turn serialized DAML-LF values into in-memory objects\n+\n+List of metrics\n+===============\n+\n+The following is a non-exhaustive list of selected metrics\n+that can be particularly important to track.\n+\n+``daml.commands.deduplicated_commands``\n+---------------------------------------\n+\n+A meter. Number of deduplicated commands.\n+\n+``daml.commands.delayed_submissions``\n+-------------------------------------\n+\n+A meter. Number of delayed submissions (submission who have been\n+evaluated to transaction with a ledger time farther in\n+the future than the expected latency).\n+\n+``daml.commands.failed_command_interpretation``\n+-----------------------------------------------\n+\n+A meter. Number of commands that have been deemed unacceptable\n+by the interpreter and thus rejected (e.g. double spends)\n+\n+``daml.commands.submissions``\n+-----------------------------\n+\n+A timer. Time to fully process a submission (validation,\n+deduplication and interpretation) before it's handed over\n+to the ledger to be finalized (either committed or rejected).\n+\n+``daml.commands.valid_submissions``\n+-----------------------------------\n+\n+A meter. Number of submission that pass validation and are\n+further sent to deduplication and interpretation.\n+\n+``daml.commands.validation``\n+----------------------------\n+\n+A timer. Time to validate submitted commands before they are\n+fed to the DAML interpreter.\n+\n+\n+``daml.execution.get_lf_package``\n+---------------------------------\n+\n+A timer. Time spent by the engine fetching the packages of compiled\n+DAML code necessary for interpretation.\n+\n+``daml.execution.lookup_active_contract_count_per_execution``\n+-------------------------------------------------------------\n+\n+A histogram. Number of active contracts fetched for each processed transaction.\n+\n+``daml.execution.lookup_active_contract_per_execution``\n+-------------------------------------------------------\n+\n+A timer. Time to fetch all active contracts necessary to process each transaction.\n+\n+``daml.execution.lookup_active_contract``\n+-----------------------------------------\n+\n+A timer. Time to fetch each individual active contract during interpretation.\n+\n+``daml.execution.lookup_contract_key_count_per_execution``\n+----------------------------------------------------------\n+\n+A histogram. Number of contract keys looked up for each processed transaction.\n+\n+``daml.execution.lookup_contract_key_per_execution``\n+----------------------------------------------------\n+\n+A timer. Time to lookup all contract keys necessary to process each transaction.\n+\n+``daml.execution.lookup_contract_key``\n+--------------------------------------\n+\n+A timer. Time to lookup each individual contract key during interpretation.\n+\n+``daml.execution.retry``\n+------------------------\n+\n+A meter. Overall number of interpretation retries attempted due to\n+mismatching ledger effective time.\n+\n+``daml.execution.total``\n+------------------------\n+\n+A timer. Time spent interpreting a valid command into a transaction\n+ready to be submitted to the ledger for finalization.\n+\n+``daml.index.db.connection.sandbox.pool``\n+-----------------------------------------\n+\n+This namespace holds a number of interesting metrics about the\n+connection pool used to communicate with the persistent store\n+that underlies the index.\n+\n+These metrics include:\n+\n+- ``daml.index.db.connection.sandbox.pool.Wait`` (timer): time spent waiting to acquire a connection\n+- ``daml.index.db.connection.sandbox.pool.Usage`` (histogram): time spent using each acquired connection\n+- ``daml.index.db.connection.sandbox.pool.TotalConnections`` (gauge): number or total connections\n+- ``daml.index.db.connection.sandbox.pool.IdleConnections`` (gauge): number of idle connections\n+- ``daml.index.db.connection.sandbox.pool.ActiveConnections`` (gauge): number of active connections\n+- ``daml.index.db.connection.sandbox.pool.PendingConnections`` (gauge): number of threads waiting for a connection\n+\n+``daml.index.db.deduplicate_command``\n+-------------------------------------\n+\n+A timer. Time spent persisting deduplication information to ensure the\n+continued working of the deduplication mechanism across restarts.\n+\n+``daml.index.db.get_active_contracts``\n+--------------------------------------\n+\n+A database metric. Time spent retrieving a page of active contracts to be\n+served from the active contract service. The page size is\n+configurable, please look at the CLI reference.\n+\n+``daml.index.db.get_completions``\n+---------------------------------\n+\n+A database metric. Time spent retrieving a page of command completions to be\n+served from the command completion service. The page size is\n+configurable, please look at the CLI reference.\n+\n+``daml.index.db.get_flat_transactions``\n+---------------------------------------\n+\n+A database metric. Time spent retrieving a page of flat transactions to be\n+streamed from the transaction service. The page size is\n+configurable, please look at the CLI reference.\n+\n+``daml.index.db.get_ledger_end``\n+--------------------------------\n+\n+A database metric. Time spent retrieving the current ledger end. The count for this metric is expected to\n+be very high and always increasing as the indexed is queried for the latest updates.\n+\n+``daml.index.db.get_ledger_id``\n+-------------------------------\n+\n+A database metric. Time spent retrieving the ledger identifier.\n+\n+``daml.index.db.get_transaction_trees``\n+---------------------------------------\n+\n+A database metric. Time spent retrieving a page of flat transactions to be\n+streamed from the transaction service. The page size is\n+configurable, please look at the CLI reference.\n+\n+``daml.index.db.load_all_parties``\n+----------------------------------\n+\n+A database metric. Load the currently allocated parties so that\n+they are served via the party management service.\n+\n+``daml.index.db.load_archive``\n+------------------------------\n+\n+A database metric. Time spent loading a package of compiled DAML code\n+so that it's given to the DAML interpreter when\n+needed.\n+\n+``daml.index.db.load_configuration_entries``\n+--------------------------------------------\n+\n+A database metric. Time to load the current entries in the log of\n+configuration entries. Used to verify whether a configuration\n+has been ultimately set.\n+\n+``daml.index.db.load_package_entries``\n+--------------------------------------\n+\n+A database metric. Time to load the current entries in the log of\n+package uploads. Used to verify whether a package\n+has been ultimately uploaded.\n+\n+``daml.index.db.load_packages``\n+-------------------------------\n+\n+A database metric. Load the currently uploaded packages so that\n+they are served via the package management service.\n+\n+``daml.index.db.load_parties``\n+------------------------------\n+\n+A database metric. Load the currently allocated parties so that\n+they are served via the party service.\n+\n+``daml.index.db.load_party_entries``\n+------------------------------------\n+\n+A database metric. Time to load the current entries in the log of\n+party allocations. Used to verify whether a party\n+has been ultimately allocated.\n+\n+``daml.index.db.lookup_active_contract``\n+----------------------------------------\n+\n+A database metric. Time to fetch one contract on the index to be used by\n+the DAML interpreter to evaluate a command into a\n+transaction.\n+\n+``daml.index.db.lookup_configuration``\n+--------------------------------------\n+\n+A database metric. Time to fetch the configuration so that it's\n+served via the configuration management service.\n+\n+``daml.index.db.lookup_contract_by_key``\n+----------------------------------------\n+\n+A database metric. Time to lookup one contract key on the index to be used by\n+the DAML interpreter to evaluate a command into a\n+transaction.\n+\n+``daml.index.db.lookup_flat_transaction_by_id``\n+-----------------------------------------------\n+\n+A database metric. Time to lookup a single flat transaction by identifier\n+to be served by the transaction service.\n+\n+``daml.index.db.lookup_maximum_ledger_time``\n+--------------------------------------------\n+\n+A database metric. Time spent looking up the ledger effective time of a\n+transaction as the maximum ledger time of all active\n+contracts involved to ensure causal monotonicity.\n+\n+``daml.index.db.lookup_transaction_tree_by_id``\n+-----------------------------------------------\n+\n+A database metric. Time to lookup a single transaction tree by identifier\n+to be served by the transaction service.\n+\n+``daml.index.db.remove_expired_deduplication_data``\n+---------------------------------------------------\n+\n+A database metric. Time spent removing deduplication information after the expiration\n+of the deduplication window. Deduplication information is persisted to\n+ensure the continued working of the deduplication mechanism across restarts.\n+\n+``daml.index.db.stop_deduplicating_command``\n+--------------------------------------------\n+\n+A database metric. Time spent removing deduplication information after the failure of a\n+command. Deduplication information is persisted to ensure the continued\n+working of the deduplication mechanism across restarts.\n+\n+``daml.index.db.store_configuration_entry``\n+-------------------------------------------\n+\n+A database metric. Time spent persisting a change in the ledger configuration\n+provided through the configuration management service.\n+\n+``daml.index.db.store_ledger_entry``\n+------------------------------------\n+\n+A database metric. Time spent persisting a transaction that has been\n+successfully interpreted and is final.\n+\n+``daml.index.db.store_package_entry``\n+-------------------------------------\n+\n+A database metric. Time spent storing a DAML package uploaded through\n+the package management service.\n+\n+``daml.index.db.store_party_entry``\n+-----------------------------------\n+\n+A database metric. Time spent storing party information as part of the\n+party allocation endpoint provided by the party\n+management service.\n+\n+``daml.index.db.store_rejection``\n+---------------------------------\n+\n+A database metric. Time spent persisting the information that a given\n+command has been rejected.\n+\n+``daml.lapi``\n+-------------\n+\n+Every metrics under this namespace is a timer, one for each\n+service exposed by the Ledger API, in the format:\n+\n+``daml.lapi.service_name.service_endpoint``\n+\n+As in the following example:\n+\n+``daml.lapi.command_service.submit_and_wait``\n+\n+Single call services return the time to serve the request,\n+streaming services measure the time to return the first response.\n+\n+``jvm``\n+-------\n+\n+Under the ``jvm`` namespace there is a collection of metrics that\n+tracks important measurements about the JVM that DAML-on-SQL is\n+running on, including CPU usage, memory consumption and the\n+current state of threads.\n+\n+DAML Ledger Model Compliance\n+****************************\n+\n+Model conformance\n+=================\n+\n+On top of bespoke unit and integration tests, the DAML-on-SQL is\n+thoroughly tested with the Ledger API Test Tool to ensure that the\n+implementation conforms with the DAML Ledger Model.\n+\n+Performance envelope\n+====================\n+\n+Furthermore, this implementation is regularly tested to comply\n+with the DAML Ledger Implementation Performance Envelope tests\n+with beta-level fidelity which ensure that DAML-on-SQL can:\n+\n+- process transactions as large as 1 MB\n+- have a tail latency no greater than 1 second when issuing 20 pings\n+- have a throughput of 20 pings per second\n+\n+.. note::\n+\n+  A \"ping\" is a collective name for two templates used to evaluate\n+  the performance envelope. Each of the two templates, \"Ping\" and\n+  \"Pong\", have a single choice allowing the controller to create\n+  an instance of the complementary template, directed to the\n+  original sender.\n+\n+Replicate performance envelope tests\n+===================================="
  },
  {
    "id" : "2f42f591-44ce-4fef-859a-b872a9008dd0",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "c9c01829-f38c-4fce-b403-02b2da5a3aba",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Let's decouple managing the the daml on sql process from the \"deployment\" of DAR packages.\r\n```suggestion\r\n  $ java -jar daml-on-sql-<version>.jar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\r\n```",
        "createdAt" : "2020-07-24T15:07:21Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'"
  },
  {
    "id" : "26f839a4-b7f4-4815-9d1e-d52ff7136c7a",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "a0c2013f-cca1-41ea-bbb5-fa3a53d489e8",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I think the product names are always without dashes.\r\n```suggestion\r\nDAML on SQL\r\n```\r\nNot sure if we should or should not always italicize _DAML on SQL_ to emphasize it as a reference to the product.",
        "createdAt" : "2020-07-24T15:14:04Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f2fe95fb-6ccb-4df8-b69d-e556e4856675",
        "parentId" : "a0c2013f-cca1-41ea-bbb5-fa3a53d489e8",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T07:47:05Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "adb131e2-c5ac-45cc-a31b-a5c8529d0d0c",
        "parentId" : "a0c2013f-cca1-41ea-bbb5-fa3a53d489e8",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T08:52:02Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL"
  },
  {
    "id" : "12bd7359-f090-47af-a2f3-4ac3f1d0c1db",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "3890a2b5-afe8-4f1d-976b-e03042f6756a",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nto run without interfering with each other. Depending on the kind of\r\n```",
        "createdAt" : "2020-07-24T15:15:49Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of"
  },
  {
    "id" : "11e2d382-f72d-43d6-b19c-7cd411f3d91d",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "fcf4c9aa-53c9-49e9-8ad5-8b8e405bc748",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nor simply using physically different machines. Still, DAML on SQL communicates\r\n```",
        "createdAt" : "2020-07-24T15:16:10Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "83258007-51e6-4371-9316-df1a1f97def9",
        "parentId" : "fcf4c9aa-53c9-49e9-8ad5-8b8e405bc748",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T07:47:18Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7b768f95-518f-43d1-8b63-16f94a0cdb11",
        "parentId" : "fcf4c9aa-53c9-49e9-8ad5-8b8e405bc748",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T08:51:53Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : 63,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates"
  },
  {
    "id" : "5c37701b-eda6-4f1a-a661-2bdac467b4bd",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "98b0ad26-527c-47ff-8814-ea300699f971",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'm not sure the details about why a multi-participant deployment for DAML on SQL doesn't work are necessary to convey that only a single DAML on SQL process should be connected at the same time to a particular postgres schema.",
        "createdAt" : "2020-07-24T15:25:37Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "63df49a9-c7af-49cb-bddc-4d56a9968481",
        "parentId" : "98b0ad26-527c-47ff-8814-ea300699f971",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I'm not telling any detail. I'm just providing a relatively vague motivation (state-dependent behavior) regarding why it's important to have a single DAML on SQL instances running atop a single PostgreSQL database. I can remove the reasoning, but I'm not sure that would effectively tell users that there are inherent dangers in ending up with two active DAML on SQL instances interacting with a single PostgreSQL installation.",
        "createdAt" : "2020-07-27T07:39:05Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a8ca9607-99a3-4622-9d6e-0e85b93223b8",
        "parentId" : "98b0ad26-527c-47ff-8814-ea300699f971",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T07:47:29Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset"
  },
  {
    "id" : "e68ab199-bcba-4f6e-bc7f-ef9de6f31c74",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "9e66a09c-68c3-4b6d-a209-f0c5b65387de",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Putting a link here would be very helpful.",
        "createdAt" : "2020-07-24T15:26:26Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fc7bbdfe-9852-49a5-ae98-f4c86403c0d4",
        "parentId" : "9e66a09c-68c3-4b6d-a209-f0c5b65387de",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/6850/commits/f57199d0811464e1f0c13d7b9bd3a98f5873cd7a",
        "createdAt" : "2020-07-27T07:47:48Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC."
  },
  {
    "id" : "358a6056-3ba0-4da2-a149-cd342c0ff3e7",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "206bf2d2-8fad-4589-aa6a-f4f0abecc72e",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I think the terms are _data at rest_ and _data in transit_.\r\n```suggestion\r\nTo protect data in transit and allow using the Ledger API over untrusted networks,\r\n```",
        "createdAt" : "2020-07-24T15:28:00Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,"
  },
  {
    "id" : "4fffc219-392d-46c9-b4bc-096eebf2c368",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "ae4abd43-35ca-4e98-b623-bda35fdf68ce",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nThe following command line options are available to enable authorization:\r\n```",
        "createdAt" : "2020-07-24T15:28:59Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authorization\n+========================\n+\n+By default, DAML-on-SQL accepts all valid Ledger API requests.\n+\n+DAML-on-SQL allows to enable authorization, representing claims as defined by the\n+`Ledger API authorization documentation <https://docs.daml.com/app-dev/authentication.html#authentication-claims>`__\n+using the `JWT <https://jwt.io/>`__ format.\n+\n+The following command line options are available to enable authentication:"
  },
  {
    "id" : "9813dba5-66b0-4853-8bff-dabc2dbf4fe2",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "3e00aedd-c391-4db0-bc79-2aec3b58f754",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nTo start DAML-on-SQL, run: ``java -jar daml-on-sql-<version>.jar [options] ``.\r\n```\r\nI hadn't thought about ",
        "createdAt" : "2020-07-24T15:31:58Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authorization\n+========================\n+\n+By default, DAML-on-SQL accepts all valid Ledger API requests.\n+\n+DAML-on-SQL allows to enable authorization, representing claims as defined by the\n+`Ledger API authorization documentation <https://docs.daml.com/app-dev/authentication.html#authentication-claims>`__\n+using the `JWT <https://jwt.io/>`__ format.\n+\n+The following command line options are available to enable authentication:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-es256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES256 (ECDSA using P-256 and SHA-256)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certicates (binary files) are supported.\n+\n+- ``--auth-jwt-es512-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES512 (ECDSA using P-521 and SHA-512)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-rs256-jwks=<url>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256)\n+  with the public key loaded from the given `JWKS <https://tools.ietf.org/html/rfc7517>`__ URL.\n+\n+.. warning::\n+\n+  For testing purposes only, the following option may also be used.\n+  None of them is considered safe for production:\n+\n+  - ``--auth-jwt-hs256-unsafe=<secret>``.\n+    DAML-on-SQL will expect all tokens to be signed with HMAC256 with the given plaintext secret.\n+\n+Token payload\n+^^^^^^^^^^^^^\n+\n+The following is an example of a valid JWT payload:\n+\n+.. code-block:: json\n+\n+   {\n+      \"https://daml.com/ledger-api\": {\n+        \"ledgerId\": \"aaaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\",\n+        \"participantId\": null,\n+        \"applicationId\": null,\n+        \"admin\": true,\n+        \"actAs\": [\"Alice\"],\n+        \"readAs\": [\"Bob\"]\n+      },\n+      \"exp\": 1300819380\n+   }\n+\n+where\n+\n+- ``ledgerId``, ``participantId``, ``applicationId`` restrict the validity of the token to the given ledger, participant, or application\n+- ``exp`` is the standard JWT expiration date (in seconds since Epoch)\n+- ``admin``, ``actAs`` and ``readAs`` bear the same meaning as in the Ledger API authorization documentation\n+\n+The ``public`` claim is implicitly held by anyone bearing a valid JWT (even without being an admin or being able to act or read on behalf of any party).\n+\n+Generating JSON Web Tokens (JWT)\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To generate tokens for testing purposes, use the `jwt.io <https://jwt.io/>`__ web site.\n+\n+Generating RSA keys\n+^^^^^^^^^^^^^^^^^^^\n+\n+To generate RSA keys for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -nodes -new -x509 -keyout ledger.key -out ledger.crt\n+\n+which generates the following files:\n+\n+- ``ledger.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ledger.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Generating EC keys\n+^^^^^^^^^^^^^^^^^^\n+\n+To generate keys to be used with ES256 for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name prime256v1) -keyout ecdsa256.key -out ecdsa256.crt\n+\n+which generates the following files:\n+\n+- ``ecdsa256.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ecdsa256.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Similarly, you can use the following command for ES512 keys:\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name secp521r1) -keyout ecdsa512.key -out ecdsa512.crt\n+\n+Command-line reference\n+**********************\n+\n+To start DAML-on-SQL, run: ``java -jar daml-on-sql-<version>.jar [options] <archive>...``."
  },
  {
    "id" : "9d35e684-0af4-4175-821b-abe061e0e4f8",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "222439ad-c208-446c-9a7d-65ab1f233ab7",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n  - ``graphite://<server_host>[:<server_port>][/<metric_prefix>]``: sends captured metrics to a Graphite server. If the port\r\n```",
        "createdAt" : "2020-07-24T15:33:22Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authorization\n+========================\n+\n+By default, DAML-on-SQL accepts all valid Ledger API requests.\n+\n+DAML-on-SQL allows to enable authorization, representing claims as defined by the\n+`Ledger API authorization documentation <https://docs.daml.com/app-dev/authentication.html#authentication-claims>`__\n+using the `JWT <https://jwt.io/>`__ format.\n+\n+The following command line options are available to enable authentication:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-es256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES256 (ECDSA using P-256 and SHA-256)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certicates (binary files) are supported.\n+\n+- ``--auth-jwt-es512-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES512 (ECDSA using P-521 and SHA-512)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-rs256-jwks=<url>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256)\n+  with the public key loaded from the given `JWKS <https://tools.ietf.org/html/rfc7517>`__ URL.\n+\n+.. warning::\n+\n+  For testing purposes only, the following option may also be used.\n+  None of them is considered safe for production:\n+\n+  - ``--auth-jwt-hs256-unsafe=<secret>``.\n+    DAML-on-SQL will expect all tokens to be signed with HMAC256 with the given plaintext secret.\n+\n+Token payload\n+^^^^^^^^^^^^^\n+\n+The following is an example of a valid JWT payload:\n+\n+.. code-block:: json\n+\n+   {\n+      \"https://daml.com/ledger-api\": {\n+        \"ledgerId\": \"aaaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\",\n+        \"participantId\": null,\n+        \"applicationId\": null,\n+        \"admin\": true,\n+        \"actAs\": [\"Alice\"],\n+        \"readAs\": [\"Bob\"]\n+      },\n+      \"exp\": 1300819380\n+   }\n+\n+where\n+\n+- ``ledgerId``, ``participantId``, ``applicationId`` restrict the validity of the token to the given ledger, participant, or application\n+- ``exp`` is the standard JWT expiration date (in seconds since Epoch)\n+- ``admin``, ``actAs`` and ``readAs`` bear the same meaning as in the Ledger API authorization documentation\n+\n+The ``public`` claim is implicitly held by anyone bearing a valid JWT (even without being an admin or being able to act or read on behalf of any party).\n+\n+Generating JSON Web Tokens (JWT)\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To generate tokens for testing purposes, use the `jwt.io <https://jwt.io/>`__ web site.\n+\n+Generating RSA keys\n+^^^^^^^^^^^^^^^^^^^\n+\n+To generate RSA keys for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -nodes -new -x509 -keyout ledger.key -out ledger.crt\n+\n+which generates the following files:\n+\n+- ``ledger.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ledger.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Generating EC keys\n+^^^^^^^^^^^^^^^^^^\n+\n+To generate keys to be used with ES256 for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name prime256v1) -keyout ecdsa256.key -out ecdsa256.crt\n+\n+which generates the following files:\n+\n+- ``ecdsa256.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ecdsa256.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Similarly, you can use the following command for ES512 keys:\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name secp521r1) -keyout ecdsa512.key -out ecdsa512.crt\n+\n+Command-line reference\n+**********************\n+\n+To start DAML-on-SQL, run: ``java -jar daml-on-sql-<version>.jar [options] <archive>...``.\n+\n+To see all the available options, run ``java -jar daml-on-sql-<version>.jar --help``.\n+\n+Monitoring\n+**********\n+\n+Enable and configure reporting\n+==============================\n+\n+To enable metrics and configure reporting, you can use the two following CLI options:\n+\n+- ``--metrics-reporter``: passing a legal value will enable reporting; the accepted values\n+  are as follows:\n+\n+  - ``console``: prints captured metrics to standard output\n+\n+  - ``csv://</path/to/metrics.csv>``: saves the captured metrics in CSV format at the specified location\n+\n+  - ``graphite://<server_host>[:<server_port>]``: sends captured metrics to a Graphite server. If the port"
  },
  {
    "id" : "bef14463-bd74-4f70-b52c-d848b707ae5f",
    "prId" : 6850,
    "comments" : [
      {
        "id" : "7702c7f6-bcf3-4953-a869-eff958eedac9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    is omitted, the default value ``2003`` will be used. A ``metric_prefix`` can be specified, causing all metrics to be reported with the specified prefix.\r\n```",
        "createdAt" : "2020-07-24T15:34:02Z",
        "updatedAt" : "2020-07-27T08:57:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8ca91634272a0c912fdc9bf9c9372b418107fb30",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,703 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-on-SQL\n+###########\n+\n+DAML-on-SQL is a PostgreSQL-based DAML ledger implementation.\n+\n+Setup PostgreSQL and run\n+************************\n+\n+Before starting, you need to perform the following steps:\n+\n+- create an initially empty PostgresSQL database that DAML-on-SQL can access\n+- have a database user for DAML-on-SQL that has authority to execute DDL operations\n+\n+This is because DAML-on-SQL manages its own database schema,\n+applying migrations if necessary when upgrading versions.\n+\n+To specify the PostgreSQL instance you wish to connect, use the\n+``--sql-backend-jdbcurl <value>`` command line option, where ``<value>``\n+is a valid JDBC URL containing the username, password and database\n+name to connect to.\n+\n+Here is an example for such a URL: ``jdbc:postgresql://localhost/test?user=fred&password=secret``\n+\n+Due to possible conflicts between the ``&`` character and various terminal\n+shells, we recommend quoting the JDBC URL like so:\n+\n+.. code-block:: none\n+\n+  $ java -jar daml-on-sql-<version>.jar Main.dar --sql-backend-jdbcurl 'jdbc:postgresql://localhost/test?user=fred&password=secret'\n+\n+If you're not familiar with JDBC URLs, see the `PostgreSQL JDBC docs for more information <https://jdbc.postgresql.org/documentation/head/connect.html>`__.\n+\n+Architecture and availability\n+*****************************\n+\n+Processes and components\n+========================\n+\n+The core processes necessary to run a DAML-on-SQL deployment are:\n+\n+- the JVM-hosted standalone Ledger API server and\n+- the PostgreSQL server used to persist the ledger data.\n+\n+The Ledger API server communicates with the external world via the gRPC\n+Ledger API and communicates with PostgreSQL via JDBC to persist transactions,\n+keep track of active contracts, store compiled DAML packages, and so on.\n+\n+Core architecture considerations\n+================================\n+\n+A very important point to make is that the backing PostgreSQL server performs a\n+lot of work which is both CPU- and IO-intensive: all (valid) Ledger API requests\n+will eventually hit the database. At the same time, the Ledger API server has to\n+have available resources to validate requests, evaluate commands and prepare responses.\n+While the PostgreSQL schema is designed to be as efficient as possible, practical\n+experience has shown that having **dedicated computation and memory resources for the\n+two core components** (the Ledger API server and the PostgreSQL server) allows the two\n+to run interfering as little as possible with each other. Depending on the kind of\n+deployment you wish to make, this can be achieved with containerization, virtualization\n+or simply using physically different machines. Still, the Ledger API communicates\n+abundantly with the PostgreSQL server and many Ledger API requests need to go all\n+the way to persist information on the database. To reduce the latency necessary to\n+serve outstanding requests, **the Ledger API server and PostgreSQL server should be\n+physically co-located**.\n+\n+Core availability considerations\n+================================\n+\n+In order to address availability concerns, it's important to understand what each of the\n+core components do and how they interact with each other, in particular regarding state\n+and consistency.\n+\n+In DAML-on-SQL, the Ledger API server holds important state that affects the offset\n+assigned to each transaction. This effectively means that having two Ledger API servers\n+running on top of a single PostgreSQL server can lead to duplicated and inconsistent\n+offsets, effectively leading to undefined (and likely broken) behavior. For this reason,\n+it's important to maintain a strict 1:1 relationship between a running Ledger API server\n+and a running PostgreSQL server. Note that using PostgreSQL in a high-availability\n+configuration does not allow you to run additional Ledger API servers.\n+\n+Downtime for the Ledger API server can be minimized using a watchdog or orchestration\n+system taking care of evaluating its health of the core components and ensuring its\n+availability. The Ledger API implementation of DAML-on-SQL exposes the standard gRPC\n+health checkpoint that can be used to evaluate the health status of the Ledger API\n+component. More information on the endpoint can be found at the documentation for gRPC.\n+\n+Security and privacy\n+********************\n+\n+Trust assumptions\n+=================\n+\n+In DAML-on-SQL, all data is kept centrally by the operator of the deployment.\n+Thus, it's their responsibility to ensure that the data is treated with the\n+appropriate care so to respect confidentiality and the applicable regulations.\n+\n+The ledger operator is advised to use the tools available to them to not divulge\n+private user data, including those documented by PostgreSQL, to protect data at\n+rest and using a secure communication channel between the Ledger API server and\n+the PostgreSQL server.\n+\n+Ledger API over TLS\n+===================\n+\n+To protect data on-the-wire and allow using the Ledger API over untrusted networks,\n+the DAML-on-SQL Ledger API server implementation leverages gRPC's built-in TLS support\n+to allow clients to verify the server's identity and encrypt the communication channel\n+over which the Ledger API requests and responses are sent.\n+\n+To enable TLS, you need to specify the private key for your server and the certificate\n+chain via ``java -jar daml-on-sql-<version>.jar --pem server.pem --crt server.crt``.\n+By default, DAML-on-SQL requires client authentication as well. You can set a custom root\n+CA certificate used to validate client certificates via ``--cacrt ca.crt``. You can\n+change the client authentication mode via ``--client-auth none`` which will disable it\n+completely, ``--client-auth optional`` which makes it optional or specify the default\n+explicitly via ``--client-auth require``.\n+\n+Ledger API Authorization\n+========================\n+\n+By default, DAML-on-SQL accepts all valid Ledger API requests.\n+\n+DAML-on-SQL allows to enable authorization, representing claims as defined by the\n+`Ledger API authorization documentation <https://docs.daml.com/app-dev/authentication.html#authentication-claims>`__\n+using the `JWT <https://jwt.io/>`__ format.\n+\n+The following command line options are available to enable authentication:\n+\n+- ``--auth-jwt-rs256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-es256-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES256 (ECDSA using P-256 and SHA-256)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certicates (binary files) are supported.\n+\n+- ``--auth-jwt-es512-crt=<filename>``.\n+  DAML-on-SQL will expect all tokens to be signed with ES512 (ECDSA using P-521 and SHA-512)\n+  with the public key loaded from the given X.509 certificate file.\n+  Both PEM-encoded certificates (text files starting with ``-----BEGIN CERTIFICATE-----``)\n+  and DER-encoded certificates (binary files) are supported.\n+\n+- ``--auth-jwt-rs256-jwks=<url>``.\n+  DAML-on-SQL will expect all tokens to be signed with RS256 (RSA Signature with SHA-256)\n+  with the public key loaded from the given `JWKS <https://tools.ietf.org/html/rfc7517>`__ URL.\n+\n+.. warning::\n+\n+  For testing purposes only, the following option may also be used.\n+  None of them is considered safe for production:\n+\n+  - ``--auth-jwt-hs256-unsafe=<secret>``.\n+    DAML-on-SQL will expect all tokens to be signed with HMAC256 with the given plaintext secret.\n+\n+Token payload\n+^^^^^^^^^^^^^\n+\n+The following is an example of a valid JWT payload:\n+\n+.. code-block:: json\n+\n+   {\n+      \"https://daml.com/ledger-api\": {\n+        \"ledgerId\": \"aaaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\",\n+        \"participantId\": null,\n+        \"applicationId\": null,\n+        \"admin\": true,\n+        \"actAs\": [\"Alice\"],\n+        \"readAs\": [\"Bob\"]\n+      },\n+      \"exp\": 1300819380\n+   }\n+\n+where\n+\n+- ``ledgerId``, ``participantId``, ``applicationId`` restrict the validity of the token to the given ledger, participant, or application\n+- ``exp`` is the standard JWT expiration date (in seconds since Epoch)\n+- ``admin``, ``actAs`` and ``readAs`` bear the same meaning as in the Ledger API authorization documentation\n+\n+The ``public`` claim is implicitly held by anyone bearing a valid JWT (even without being an admin or being able to act or read on behalf of any party).\n+\n+Generating JSON Web Tokens (JWT)\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+To generate tokens for testing purposes, use the `jwt.io <https://jwt.io/>`__ web site.\n+\n+Generating RSA keys\n+^^^^^^^^^^^^^^^^^^^\n+\n+To generate RSA keys for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -nodes -new -x509 -keyout ledger.key -out ledger.crt\n+\n+which generates the following files:\n+\n+- ``ledger.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ledger.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Generating EC keys\n+^^^^^^^^^^^^^^^^^^\n+\n+To generate keys to be used with ES256 for testing purposes, use the following command\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name prime256v1) -keyout ecdsa256.key -out ecdsa256.crt\n+\n+which generates the following files:\n+\n+- ``ecdsa256.key``: the private key in PEM/DER/PKCS#1 format\n+- ``ecdsa256.crt``: a self-signed certificate containing the public key, in PEM/DER/X.509 Certificate format\n+\n+Similarly, you can use the following command for ES512 keys:\n+\n+.. code-block:: none\n+\n+  openssl req -x509 -nodes -days 3650 -newkey ec:<(openssl ecparam -name secp521r1) -keyout ecdsa512.key -out ecdsa512.crt\n+\n+Command-line reference\n+**********************\n+\n+To start DAML-on-SQL, run: ``java -jar daml-on-sql-<version>.jar [options] <archive>...``.\n+\n+To see all the available options, run ``java -jar daml-on-sql-<version>.jar --help``.\n+\n+Monitoring\n+**********\n+\n+Enable and configure reporting\n+==============================\n+\n+To enable metrics and configure reporting, you can use the two following CLI options:\n+\n+- ``--metrics-reporter``: passing a legal value will enable reporting; the accepted values\n+  are as follows:\n+\n+  - ``console``: prints captured metrics to standard output\n+\n+  - ``csv://</path/to/metrics.csv>``: saves the captured metrics in CSV format at the specified location\n+\n+  - ``graphite://<server_host>[:<server_port>]``: sends captured metrics to a Graphite server. If the port\n+    is omitted, the default value ``2003`` will be used."
  }
]