[
  {
    "id" : "82392462-5e59-406a-881a-8bf7986d8046",
    "prId" : 6638,
    "comments" : [
      {
        "id" : "577667e7-58e4-448c-bd09-2bb76789eac4",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I seem to remember that some ledgers might not use `0` as the beginning. I'm not sure if this is an issue; it might be OK because it's the lowest possible offset, even if there isn't a `0`.\r\n\r\n@simonmaxen-da, can you comment?",
        "createdAt" : "2020-07-07T12:37:14Z",
        "updatedAt" : "2020-07-07T14:00:57Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "412afaec-acaf-4532-ae4a-0a1a89e0a175",
        "parentId" : "577667e7-58e4-448c-bd09-2bb76789eac4",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "This is basically what we used to return before this:\r\n\r\nhttps://github.com/digital-asset/daml/commit/12c05c408af5abefad56d1135aa9d36ee1c2ea3c\r\n\r\nSo I hope it's not problematic from a functional behavior perspactive, at least the commit message in that commit doesn't suggest that it was",
        "createdAt" : "2020-07-07T12:50:41Z",
        "updatedAt" : "2020-07-07T14:00:57Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "22aceb75-6a43-49f1-b0c3-b3afd4a75d56",
        "parentId" : "577667e7-58e4-448c-bd09-2bb76789eac4",
        "author" : {
          "login" : "simonmaxen-da",
          "name" : "Simon Maxen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/56595114?u=cfde0812fcba2729e1d8f0b715136950eee6f84f&v=4"
        },
        "body" : "@SamirTalwar-DA - the first used offset should be at the discretion of the ledger implementor.  With the current DAML-on-Corda offset calculation the first offset will not be Offset.begin.   In future it could be.",
        "createdAt" : "2020-07-07T12:55:26Z",
        "updatedAt" : "2020-07-07T14:00:57Z",
        "lastEditedBy" : {
          "login" : "simonmaxen-da",
          "name" : "Simon Maxen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/56595114?u=cfde0812fcba2729e1d8f0b715136950eee6f84f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "16b5bcac-24b4-475e-ad6e-61a23013ec1b",
        "parentId" : "577667e7-58e4-448c-bd09-2bb76789eac4",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "The ledger API server doesn't expose the underlying ledger's offsets; see the `parameters` table of the indexer and the `ledger_end` and `external_ledger_end` column. So IIUC, whatever the underlying ledger uses as the first offset, `0` should be consistent with what the Ledger API server uses.",
        "createdAt" : "2020-07-07T13:05:01Z",
        "updatedAt" : "2020-07-07T14:00:57Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04571cac-fefe-41c7-b753-7061ab8147df",
        "parentId" : "577667e7-58e4-448c-bd09-2bb76789eac4",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "That makes sense. This line probably belongs in `ApiOffset`, not here, then.",
        "createdAt" : "2020-07-07T13:06:53Z",
        "updatedAt" : "2020-07-07T14:00:57Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e3195675-9529-401b-b35d-30b1f3967560",
        "parentId" : "577667e7-58e4-448c-bd09-2bb76789eac4",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Moved to `ApiOffset` then",
        "createdAt" : "2020-07-07T14:03:45Z",
        "updatedAt" : "2020-07-07T14:03:45Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e499dfbe66379ccb8b24c52d1eea8a9610c851ea",
    "line" : null,
    "diffHunk" : "@@ -36,6 +36,8 @@ object Offset {\n \n   val beforeBegin: Offset = Offset.fromByteArray(Array.empty[Byte])\n \n+  val begin: Offset = Offset.fromByteArray(Array(0: Byte))"
  },
  {
    "id" : "9966857f-ce80-4cdd-b307-80fc00af968a",
    "prId" : 5140,
    "comments" : [
      {
        "id" : "cd1ad28a-2168-484f-9934-b9e6fa9010dd",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "We are not using tagged types in participant state yet, and I'm not sure we should start now tbh.",
        "createdAt" : "2020-03-23T16:14:33Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b79ba3d4-fe12-481d-80ed-d49ed24468d7",
        "parentId" : "cd1ad28a-2168-484f-9934-b9e6fa9010dd",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I change it to case class",
        "createdAt" : "2020-03-23T16:56:24Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f294ff3bf6e8f914a9259daabba5a33e2634244d",
    "line" : null,
    "diffHunk" : "@@ -21,22 +20,18 @@ import com.google.protobuf.ByteString\n   * less than newer offsets.\n   *\n   */\n-final class Offset(private val value: ByteString) extends AnyVal with Ordered[Offset] {\n+sealed trait OffsetTag\n \n-  override def compare(that: Offset): Int =\n-    Offset.comparator.compare(value, that.value)\n+object Offset {\n \n-  def toByteArray: Array[Byte] = value.toByteArray\n+  val tag = Tag.of[OffsetTag]"
  },
  {
    "id" : "d256e988-ce94-456a-8e4a-f7b5e86d5bd6",
    "prId" : 5140,
    "comments" : [
      {
        "id" : "a2a9e546-43e1-47fe-82a1-e3290694dd0e",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Can this be moved into the object?",
        "createdAt" : "2020-03-23T16:16:37Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "34841fb9-01f7-44d0-943f-6f97c1d276a0",
        "parentId" : "a2a9e546-43e1-47fe-82a1-e3290694dd0e",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "@gerolf-da prefers we do not use tag. ",
        "createdAt" : "2020-03-23T16:59:36Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "840b8fd4-0a1a-4f48-8870-1f46fa5aa13b",
        "parentId" : "a2a9e546-43e1-47fe-82a1-e3290694dd0e",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I am all for that.",
        "createdAt" : "2020-03-23T17:32:17Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f294ff3bf6e8f914a9259daabba5a33e2634244d",
    "line" : null,
    "diffHunk" : "@@ -21,22 +20,18 @@ import com.google.protobuf.ByteString\n   * less than newer offsets.\n   *\n   */\n-final class Offset(private val value: ByteString) extends AnyVal with Ordered[Offset] {\n+sealed trait OffsetTag"
  },
  {
    "id" : "4de90299-77f7-46ae-ba13-65efb8ed8f57",
    "prId" : 5140,
    "comments" : [
      {
        "id" : "5859bbec-57e8-4116-b8d3-606f442ddad8",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I'd like to keep the `to*` methods delegating to `unwrap` for readability. A `toByteBuffer` and a `toHexString` might make sense too. Calling `unwrap` directly seems like a bad sign to me.",
        "createdAt" : "2020-03-23T16:17:45Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "83946c75-849c-4cfb-a46b-ee63b74a5f93",
        "parentId" : "5859bbec-57e8-4116-b8d3-606f442ddad8",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I put back to `to*` and the `from*`. \r\nI added only `toHexString` as `toByteBuffer` is not used.",
        "createdAt" : "2020-03-23T17:00:31Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f294ff3bf6e8f914a9259daabba5a33e2634244d",
    "line" : null,
    "diffHunk" : "@@ -21,22 +20,18 @@ import com.google.protobuf.ByteString\n   * less than newer offsets.\n   *\n   */\n-final class Offset(private val value: ByteString) extends AnyVal with Ordered[Offset] {\n+sealed trait OffsetTag\n \n-  override def compare(that: Offset): Int =\n-    Offset.comparator.compare(value, that.value)\n+object Offset {\n \n-  def toByteArray: Array[Byte] = value.toByteArray\n+  val tag = Tag.of[OffsetTag]\n \n-  def toInputStream: InputStream = value.newInput()\n-}\n+  def apply(s: Bytes): Offset = tag(s)\n \n-object Offset {\n-  private val comparator = ByteString.unsignedLexicographicalComparator()\n+  def unwrap(x: Offset): Bytes = tag.unwrap(x)"
  },
  {
    "id" : "6ef05053-f38b-408f-93f8-856c754a6747",
    "prId" : 5140,
    "comments" : [
      {
        "id" : "f1790da3-b126-49b6-a9da-5641f3d3829d",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This can still be `final`.",
        "createdAt" : "2020-03-23T17:30:00Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7f128bbe-fcb8-46e9-b5ce-009bc801f6be",
        "parentId" : "f1790da3-b126-49b6-a9da-5641f3d3829d",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : ":+1: ",
        "createdAt" : "2020-03-23T17:36:23Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f294ff3bf6e8f914a9259daabba5a33e2634244d",
    "line" : null,
    "diffHunk" : "@@ -21,22 +21,24 @@ import com.google.protobuf.ByteString\n   * less than newer offsets.\n   *\n   */\n-final class Offset(private val value: ByteString) extends AnyVal with Ordered[Offset] {\n-\n+case class Offset(bytes: Bytes) extends Ordered[Offset] {"
  },
  {
    "id" : "4e1270e9-c1e3-4653-a007-b2755ed6e1b1",
    "prId" : 5140,
    "comments" : [
      {
        "id" : "999375d8-d281-410f-b730-fa46ef3c3a3f",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Hmmmâ€¦ can this be `AnyVal`?",
        "createdAt" : "2020-03-23T17:32:37Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "55f51768-37cd-41ec-834e-fb3e512e820e",
        "parentId" : "999375d8-d281-410f-b730-fa46ef3c3a3f",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "It cannot because Bytes is already a user-defined `AnyVal`",
        "createdAt" : "2020-03-23T17:36:26Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5562456b-c157-4a44-85d6-8f404955a16a",
        "parentId" : "999375d8-d281-410f-b730-fa46ef3c3a3f",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "It cannot, because `Bytes` is already `AnyVal`.",
        "createdAt" : "2020-03-23T17:37:02Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f5dc1c2c-eef7-4f65-a2e9-bb7a1e281f84",
        "parentId" : "999375d8-d281-410f-b730-fa46ef3c3a3f",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I did not know that was a thing.\r\n\r\n_Samir has learnt something today._",
        "createdAt" : "2020-03-23T17:48:51Z",
        "updatedAt" : "2020-03-23T22:49:17Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f294ff3bf6e8f914a9259daabba5a33e2634244d",
    "line" : null,
    "diffHunk" : "@@ -21,22 +21,24 @@ import com.google.protobuf.ByteString\n   * less than newer offsets.\n   *\n   */\n-final class Offset(private val value: ByteString) extends AnyVal with Ordered[Offset] {\n-\n+case class Offset(bytes: Bytes) extends Ordered[Offset] {"
  },
  {
    "id" : "b1d6ddc0-1344-40c6-95f1-a5e53302ffa0",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "f0d80fb7-9889-4457-adf6-4097478695c9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This is used in quite a few places. I'm tempted to removed it so that each ledger implementation has to make a conscious decision about the offsets. For KV Ledgers, kvutils could provide a small utility library to add further restrictions (e.g. kvutils needs to manipulate returned offsets to [account for multiple state updates per log entry](https://github.com/digital-asset/daml/blob/d333d9e8820770875876d2639127b531a2e4520c/ledger/participant-state/kvutils/src/main/scala/com/daml/ledger/participant/state/kvutils/api/KeyValueParticipantStateReader.scala#L32-L35)).",
        "createdAt" : "2020-03-11T18:11:02Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : null,
    "diffHunk" : "@@ -4,46 +4,40 @@\n package com.daml.ledger.participant.state.v1\n \n import com.digitalasset.daml.lf.data.Ref.LedgerString\n-import com.digitalasset.daml.lf.data.Ref\n+\n+import scala.util.Try\n \n /** Offsets into streams with hierarchical addressing.\n   *\n   * We use these [[Offset]]'s to address changes to the participant state.\n-  * We allow for array of [[Long]] to allow for hierarchical addresses.\n-  * These [[Long]] values are expected to be positive. Offsets are ordered by\n-  * lexicographic ordering of the array elements.\n+  * Offsets are arbitrary string values. Offset strings must be strict\n+  * monotonically increasing according to lexicographical ordering.\n   *\n-  * A typical use case for [[Offset]]s would be addressing a transaction in a\n-  * blockchain by `[<blockheight>, <transactionId>]`. Depending on the\n-  * structure of the underlying ledger these offsets are more or less\n-  * nested, which is why we use an array of [[Long]]s. The expectation is\n-  * though that there usually are few elements in the array.\n+  * Ledger implementations are advised to future proof their design\n+  * of offsets by reserving the first (few) characters to a version\n+  * indicator, followed by the specific offset scheme for that version.\n+  * This way it is possible in the future to switch to a different versioning\n+  * scheme, while making sure that previously created offsets are always\n+  * less than newer offsets.\n   *\n   */\n-final case class Offset(private val xs: Array[Long]) extends Ordered[Offset] {\n-  def toLedgerString: Ref.LedgerString =\n-    // It is safe to concatenate number and \"-\" to obtain a valid transactionId\n-    Ref.LedgerString.assertFromString(components.mkString(\"-\"))\n-\n-  override def toString: String = toLedgerString\n+final case class Offset private (value: String) extends Ordered[Offset] {\n \n-  def components: Iterable[Long] = xs\n+  def toLedgerString: LedgerString = LedgerString.assertFromString(toString)\n \n-  override def equals(that: Any): Boolean = that match {\n-    case o: Offset => this.compare(o) == 0\n-    case _ => false\n-  }\n+  override def toString: String = value.toString()\n \n-  def compare(that: Offset): Int =\n-    scala.math.Ordering.Iterable[Long].compare(this.xs.toIterable, that.xs.toIterable)\n+  override def compare(that: Offset): Int = value.compareTo(that.value)\n }\n \n object Offset {\n \n-  /** Create an offset from a string of form 1-2-3. Throws\n-    * NumberFormatException on misformatted strings.\n-    */\n-  def assertFromString(s: LedgerString): Offset =\n-    Offset(s.split('-').map(_.toLong))\n+  def empty: Offset = Offset(\"\")\n+\n+  def assertFromString(s: String): Offset =\n+    Offset(s)\n+\n+  def fromString(s: String): Try[Offset] = Try(assertFromString(s))\n \n+  def fromLong(l: Long, padding: Int = 8): Offset = assertFromString(s\"%0${padding}d\".format(l))"
  },
  {
    "id" : "33c7ffb3-4d72-4a5a-97b1-368eaab1c41b",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "0e5781a4-f0e1-41d7-a4f3-d9cfc67616bc",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Did you mean to do this? This'll play havoc with a REPL, debugger, etc. If you don't want to have a `toString`, just don't override it.",
        "createdAt" : "2020-03-16T15:10:50Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5fc4c867-0196-4661-9184-3607c3297565",
        "parentId" : "0e5781a4-f0e1-41d7-a4f3-d9cfc67616bc",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Thinking about it, converting the byte array to hex might be the most user-friendly option that stops people from trying to parse the value with their eyeballs.",
        "createdAt" : "2020-03-16T15:42:46Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9833b77e-95a3-4f8d-8aa1-c52edc36ec13",
        "parentId" : "0e5781a4-f0e1-41d7-a4f3-d9cfc67616bc",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Thanks. I wanted to make sure I catch all the implicit calls to `toString` in log entries.",
        "createdAt" : "2020-03-16T16:44:57Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2436f53a-5483-4734-9d85-293e5f651133",
        "parentId" : "0e5781a4-f0e1-41d7-a4f3-d9cfc67616bc",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Clearly it should be removed :)",
        "createdAt" : "2020-03-16T16:45:17Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : null,
    "diffHunk" : "@@ -3,47 +3,34 @@\n \n package com.daml.ledger.participant.state.v1\n \n-import com.digitalasset.daml.lf.data.Ref.LedgerString\n-import com.digitalasset.daml.lf.data.Ref\n+import com.google.protobuf.ByteString\n \n /** Offsets into streams with hierarchical addressing.\n   *\n   * We use these [[Offset]]'s to address changes to the participant state.\n-  * We allow for array of [[Long]] to allow for hierarchical addresses.\n-  * These [[Long]] values are expected to be positive. Offsets are ordered by\n-  * lexicographic ordering of the array elements.\n+  * Offsets are opaque values that must be must be strictly\n+  * increasing according to lexicographical ordering.\n   *\n-  * A typical use case for [[Offset]]s would be addressing a transaction in a\n-  * blockchain by `[<blockheight>, <transactionId>]`. Depending on the\n-  * structure of the underlying ledger these offsets are more or less\n-  * nested, which is why we use an array of [[Long]]s. The expectation is\n-  * though that there usually are few elements in the array.\n+  * Ledger implementations are advised to future proof their design\n+  * of offsets by reserving the first (few) bytes for a version\n+  * indicator, followed by the specific offset scheme for that version.\n+  * This way it is possible in the future to switch to a different versioning\n+  * scheme, while making sure that previously created offsets are always\n+  * less than newer offsets.\n   *\n   */\n-final case class Offset(private val xs: Array[Long]) extends Ordered[Offset] {\n-  def toLedgerString: Ref.LedgerString =\n-    // It is safe to concatenate number and \"-\" to obtain a valid transactionId\n-    Ref.LedgerString.assertFromString(components.mkString(\"-\"))\n+final class Offset(val value: ByteString) extends AnyVal with Ordered[Offset] {\n \n-  override def toString: String = toLedgerString\n+  override def toString: String = ???"
  },
  {
    "id" : "eb609ece-3a73-4d2e-b046-8b2d3c52402d",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "932eed5b-6fe3-42e3-9a0b-b7ea485a7ea1",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n  val begin: Offset = new Offset(ByteString.copyFrom(Array(0: Byte)))\r\n```",
        "createdAt" : "2020-03-17T13:38:27Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : null,
    "diffHunk" : "@@ -3,47 +3,32 @@\n \n package com.daml.ledger.participant.state.v1\n \n-import com.digitalasset.daml.lf.data.Ref.LedgerString\n-import com.digitalasset.daml.lf.data.Ref\n+import com.google.protobuf.ByteString\n \n /** Offsets into streams with hierarchical addressing.\n   *\n   * We use these [[Offset]]'s to address changes to the participant state.\n-  * We allow for array of [[Long]] to allow for hierarchical addresses.\n-  * These [[Long]] values are expected to be positive. Offsets are ordered by\n-  * lexicographic ordering of the array elements.\n+  * Offsets are opaque values that must be must be strictly\n+  * increasing according to lexicographical ordering.\n   *\n-  * A typical use case for [[Offset]]s would be addressing a transaction in a\n-  * blockchain by `[<blockheight>, <transactionId>]`. Depending on the\n-  * structure of the underlying ledger these offsets are more or less\n-  * nested, which is why we use an array of [[Long]]s. The expectation is\n-  * though that there usually are few elements in the array.\n+  * Ledger implementations are advised to future proof their design\n+  * of offsets by reserving the first (few) bytes for a version\n+  * indicator, followed by the specific offset scheme for that version.\n+  * This way it is possible in the future to switch to a different versioning\n+  * scheme, while making sure that previously created offsets are always\n+  * less than newer offsets.\n   *\n   */\n-final case class Offset(private val xs: Array[Long]) extends Ordered[Offset] {\n-  def toLedgerString: Ref.LedgerString =\n-    // It is safe to concatenate number and \"-\" to obtain a valid transactionId\n-    Ref.LedgerString.assertFromString(components.mkString(\"-\"))\n+final class Offset(val value: ByteString) extends AnyVal with Ordered[Offset] {\n \n-  override def toString: String = toLedgerString\n+  override def compare(that: Offset): Int =\n+    ByteString.unsignedLexicographicalComparator().compare(value, that.value)\n \n-  def components: Iterable[Long] = xs\n-\n-  override def equals(that: Any): Boolean = that match {\n-    case o: Offset => this.compare(o) == 0\n-    case _ => false\n-  }\n-\n-  def compare(that: Offset): Int =\n-    scala.math.Ordering.Iterable[Long].compare(this.xs.toIterable, that.xs.toIterable)\n+  def toByteArray: Array[Byte] = value.toByteArray\n }\n \n object Offset {\n+  def empty: Offset = new Offset(ByteString.copyFrom(Array(0: Byte)))"
  },
  {
    "id" : "8b570c61-5de0-4a8f-bc1e-c8ab48bc8df9",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "412488c0-6f45-48a7-aa4b-68d995a15c6c",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "As mentioned off-band, you can make `value` private and still retain the value type.",
        "createdAt" : "2020-03-17T14:22:45Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : null,
    "diffHunk" : "@@ -3,47 +3,32 @@\n \n package com.daml.ledger.participant.state.v1\n \n-import com.digitalasset.daml.lf.data.Ref.LedgerString\n-import com.digitalasset.daml.lf.data.Ref\n+import com.google.protobuf.ByteString\n \n /** Offsets into streams with hierarchical addressing.\n   *\n   * We use these [[Offset]]'s to address changes to the participant state.\n-  * We allow for array of [[Long]] to allow for hierarchical addresses.\n-  * These [[Long]] values are expected to be positive. Offsets are ordered by\n-  * lexicographic ordering of the array elements.\n+  * Offsets are opaque values that must be must be strictly\n+  * increasing according to lexicographical ordering.\n   *\n-  * A typical use case for [[Offset]]s would be addressing a transaction in a\n-  * blockchain by `[<blockheight>, <transactionId>]`. Depending on the\n-  * structure of the underlying ledger these offsets are more or less\n-  * nested, which is why we use an array of [[Long]]s. The expectation is\n-  * though that there usually are few elements in the array.\n+  * Ledger implementations are advised to future proof their design\n+  * of offsets by reserving the first (few) bytes for a version\n+  * indicator, followed by the specific offset scheme for that version.\n+  * This way it is possible in the future to switch to a different versioning\n+  * scheme, while making sure that previously created offsets are always\n+  * less than newer offsets.\n   *\n   */\n-final case class Offset(private val xs: Array[Long]) extends Ordered[Offset] {\n-  def toLedgerString: Ref.LedgerString =\n-    // It is safe to concatenate number and \"-\" to obtain a valid transactionId\n-    Ref.LedgerString.assertFromString(components.mkString(\"-\"))\n+final class Offset(val value: ByteString) extends AnyVal with Ordered[Offset] {"
  },
  {
    "id" : "c37ff0d9-351d-4d32-8bbd-0c184a08fe26",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "565ac370-25b6-485b-94a5-e83107fb7ca6",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Very minor and likely to be inlined by the runtime, but probably worth calling `ByteString.unsignedLexicographicalComparator()` just once in a companion object.",
        "createdAt" : "2020-03-17T14:24:05Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : null,
    "diffHunk" : "@@ -3,47 +3,32 @@\n \n package com.daml.ledger.participant.state.v1\n \n-import com.digitalasset.daml.lf.data.Ref.LedgerString\n-import com.digitalasset.daml.lf.data.Ref\n+import com.google.protobuf.ByteString\n \n /** Offsets into streams with hierarchical addressing.\n   *\n   * We use these [[Offset]]'s to address changes to the participant state.\n-  * We allow for array of [[Long]] to allow for hierarchical addresses.\n-  * These [[Long]] values are expected to be positive. Offsets are ordered by\n-  * lexicographic ordering of the array elements.\n+  * Offsets are opaque values that must be must be strictly\n+  * increasing according to lexicographical ordering.\n   *\n-  * A typical use case for [[Offset]]s would be addressing a transaction in a\n-  * blockchain by `[<blockheight>, <transactionId>]`. Depending on the\n-  * structure of the underlying ledger these offsets are more or less\n-  * nested, which is why we use an array of [[Long]]s. The expectation is\n-  * though that there usually are few elements in the array.\n+  * Ledger implementations are advised to future proof their design\n+  * of offsets by reserving the first (few) bytes for a version\n+  * indicator, followed by the specific offset scheme for that version.\n+  * This way it is possible in the future to switch to a different versioning\n+  * scheme, while making sure that previously created offsets are always\n+  * less than newer offsets.\n   *\n   */\n-final case class Offset(private val xs: Array[Long]) extends Ordered[Offset] {\n-  def toLedgerString: Ref.LedgerString =\n-    // It is safe to concatenate number and \"-\" to obtain a valid transactionId\n-    Ref.LedgerString.assertFromString(components.mkString(\"-\"))\n+final class Offset(val value: ByteString) extends AnyVal with Ordered[Offset] {\n \n-  override def toString: String = toLedgerString\n+  override def compare(that: Offset): Int =\n+    ByteString.unsignedLexicographicalComparator().compare(value, that.value)"
  },
  {
    "id" : "e9964261-eb9d-466c-8727-3adcb7eeb020",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "6138f16a-05a9-45f1-9420-a2dc9a5302a6",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "This reasonably does some defensive copying but the usages I see can either use an `InputStream` (when writing to the database) (`ByteArray` has a `newInput` method for that) and perhaps the `decodingStream` method on `BaseEncoding` to format the string for the API.",
        "createdAt" : "2020-03-17T14:41:30Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "60bb31f5-5ea4-40b1-8ad3-45e6b2b9a498",
        "parentId" : "6138f16a-05a9-45f1-9420-a2dc9a5302a6",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'll transform the reading and writing from the database to use `InputStream`. The string *for* the API would need to be encoded, and would end up being something like this:\r\n\r\n```\r\n  def toApiString(offset: Offset): Ref.LedgerString = {\r\n    val writer = new StringWriter()\r\n    val os = BaseEncoding.base16.encodingStream(writer)\r\n    ByteStreams.copy(offset.toInputStream, os)\r\n    Ref.LedgerString.assertFromString(writer.toString)\r\n  }\r\n```\r\nNot sure this is really worth it for >40 bytes.",
        "createdAt" : "2020-03-17T16:48:42Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f99cf577-2984-4900-ae6b-3ad7d3243c30",
        "parentId" : "6138f16a-05a9-45f1-9420-a2dc9a5302a6",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "See https://github.com/digital-asset/daml/pull/4953/commits/c2b39cd378e657de10e791b99fadfd84330c416f#diff-3c79ae69c286b56286dda4655d1eceb7R22-R27",
        "createdAt" : "2020-03-17T17:25:41Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : 48,
    "diffHunk" : "@@ -3,47 +3,32 @@\n \n package com.daml.ledger.participant.state.v1\n \n-import com.digitalasset.daml.lf.data.Ref.LedgerString\n-import com.digitalasset.daml.lf.data.Ref\n+import com.google.protobuf.ByteString\n \n /** Offsets into streams with hierarchical addressing.\n   *\n   * We use these [[Offset]]'s to address changes to the participant state.\n-  * We allow for array of [[Long]] to allow for hierarchical addresses.\n-  * These [[Long]] values are expected to be positive. Offsets are ordered by\n-  * lexicographic ordering of the array elements.\n+  * Offsets are opaque values that must be must be strictly\n+  * increasing according to lexicographical ordering.\n   *\n-  * A typical use case for [[Offset]]s would be addressing a transaction in a\n-  * blockchain by `[<blockheight>, <transactionId>]`. Depending on the\n-  * structure of the underlying ledger these offsets are more or less\n-  * nested, which is why we use an array of [[Long]]s. The expectation is\n-  * though that there usually are few elements in the array.\n+  * Ledger implementations are advised to future proof their design\n+  * of offsets by reserving the first (few) bytes for a version\n+  * indicator, followed by the specific offset scheme for that version.\n+  * This way it is possible in the future to switch to a different versioning\n+  * scheme, while making sure that previously created offsets are always\n+  * less than newer offsets.\n   *\n   */\n-final case class Offset(private val xs: Array[Long]) extends Ordered[Offset] {\n-  def toLedgerString: Ref.LedgerString =\n-    // It is safe to concatenate number and \"-\" to obtain a valid transactionId\n-    Ref.LedgerString.assertFromString(components.mkString(\"-\"))\n+final class Offset(val value: ByteString) extends AnyVal with Ordered[Offset] {\n \n-  override def toString: String = toLedgerString\n+  override def compare(that: Offset): Int =\n+    ByteString.unsignedLexicographicalComparator().compare(value, that.value)\n \n-  def components: Iterable[Long] = xs\n-\n-  override def equals(that: Any): Boolean = that match {\n-    case o: Offset => this.compare(o) == 0\n-    case _ => false\n-  }\n-\n-  def compare(that: Offset): Int =\n-    scala.math.Ordering.Iterable[Long].compare(this.xs.toIterable, that.xs.toIterable)\n+  def toByteArray: Array[Byte] = value.toByteArray"
  },
  {
    "id" : "5e62c1ff-f153-4951-a81a-dade71390907",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "e5e279c6-1bd6-44e8-9f9a-ecec7b70cc4f",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Just had a thought: shouldn't `Offset` have `equals` and `hashCode`? Sure, they're opaque, but you should at least be able to put them in a `Set` or check that a value sent over the wire is the same as one in memory.\r\n\r\nIt didn't need it before because it was a `case class` before.",
        "createdAt" : "2020-03-17T17:38:31Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "19488df8-ab58-4e2c-886f-b1190ea35df6",
        "parentId" : "e5e279c6-1bd6-44e8-9f9a-ecec7b70cc4f",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Value classes don't exist at runtime, so `ByteString`'s `hashCode` and `equals` are used already.",
        "createdAt" : "2020-03-17T17:42:46Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4495b1a5-26f8-465a-ac43-591470e2b36f",
        "parentId" : "e5e279c6-1bd6-44e8-9f9a-ecec7b70cc4f",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Makes sense. I'd feel a lot more comfortable if `Offset` had some test cases though. (Not sure why I didn't notice that before.)",
        "createdAt" : "2020-03-17T17:44:43Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7fe58af4-6023-4a57-8094-f8d462c458be",
        "parentId" : "e5e279c6-1bd6-44e8-9f9a-ecec7b70cc4f",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "There's not a whole lot to `Offset` itself. There are test cases for `KVOffset`, but that is around checking the bit shifting magic (which as you pointed out only worked incidentally).",
        "createdAt" : "2020-03-17T19:45:55Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : 38,
    "diffHunk" : "@@ -3,47 +3,40 @@\n \n package com.daml.ledger.participant.state.v1\n \n-import com.digitalasset.daml.lf.data.Ref.LedgerString\n-import com.digitalasset.daml.lf.data.Ref\n+import java.io.InputStream\n+\n+import com.google.protobuf.ByteString\n \n /** Offsets into streams with hierarchical addressing.\n   *\n   * We use these [[Offset]]'s to address changes to the participant state.\n-  * We allow for array of [[Long]] to allow for hierarchical addresses.\n-  * These [[Long]] values are expected to be positive. Offsets are ordered by\n-  * lexicographic ordering of the array elements.\n+  * Offsets are opaque values that must be must be strictly\n+  * increasing according to lexicographical ordering.\n   *\n-  * A typical use case for [[Offset]]s would be addressing a transaction in a\n-  * blockchain by `[<blockheight>, <transactionId>]`. Depending on the\n-  * structure of the underlying ledger these offsets are more or less\n-  * nested, which is why we use an array of [[Long]]s. The expectation is\n-  * though that there usually are few elements in the array.\n+  * Ledger implementations are advised to future proof their design\n+  * of offsets by reserving the first (few) bytes for a version\n+  * indicator, followed by the specific offset scheme for that version.\n+  * This way it is possible in the future to switch to a different versioning\n+  * scheme, while making sure that previously created offsets are always\n+  * less than newer offsets.\n   *\n   */\n-final case class Offset(private val xs: Array[Long]) extends Ordered[Offset] {\n-  def toLedgerString: Ref.LedgerString =\n-    // It is safe to concatenate number and \"-\" to obtain a valid transactionId\n-    Ref.LedgerString.assertFromString(components.mkString(\"-\"))\n-\n-  override def toString: String = toLedgerString\n+final class Offset(private val value: ByteString) extends AnyVal with Ordered[Offset] {"
  }
]