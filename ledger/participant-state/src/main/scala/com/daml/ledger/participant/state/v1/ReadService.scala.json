[
  {
    "id" : "45f71c62-0f0c-42f3-a816-5fffbdaef3f5",
    "prId" : 5043,
    "comments" : [
      {
        "id" : "0e6472ab-dda2-4e82-8815-cdeceb4a7a74",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Note: the submission service deduplicates submissions as described here, but only for submissions coming through the same participant. The ledger may _additionally_ perform cross-participant deduplication, but is not required to do so (to keep `ReadService` implementations simple). That's why this sentence uses \"may\", and is not very helpful in general.",
        "createdAt" : "2020-03-17T14:30:31Z",
        "updatedAt" : "2020-03-17T18:08:49Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "257bda699f866c31589adba93c05b0d47ca02142",
    "line" : 32,
    "diffHunk" : "@@ -57,17 +57,27 @@ trait ReadService extends ReportsHealth {\n     *   the [[Update.TransactionAccepted]].\n     *\n     * - *causal monotonicity*: given a [[Update.TransactionAccepted]] with an associated\n-    *   record time `rt_tx`, it holds that `rt_tx >= rt_c` for all `c`, where `c` is a\n-    *   contract used by the transaction and `rt_c` the record time of the\n+    *   ledger time `lt_tx`, it holds that `lt_tx >= lt_c` for all `c`, where `c` is a\n+    *   contract used by the transaction and `lt_c` the ledger time of the\n     *   [[Update.TransactionAccepted]] that created the contract.\n-    *   Note that the record time of unrelated updates is not necessarily monotonically\n+    *   The ledger time of a transaction is specified in the corresponding [[TransactionMeta]]\n+    *   meta-data.\n+    *   Note that the ledger time of unrelated updates is not necessarily monotonically\n     *   increasing.\n     *\n-    * - *no duplicate transaction acceptance*: there are no two separate\n-    *   [[Update.TransactionAccepted]] updates with associated [[SubmitterInfo]]\n-    *   records that agree on the `submitter`, `applicationId` and\n-    *   `commandId` fields.  This implies that transaction submissions must be\n-    *   deduplicated w.r.t. the `(submitter, applicationId, commandId)` tuples.\n+    * - *time skew*: given a [[Update.TransactionAccepted]] with an associated\n+    *   ledger time `lt_tx` and a record time `rt_tx`, it holds that\n+    *   `rt_TX - minSkew <= lt_TX <= rt_TX + maxSkew`, where `minSkew` and `maxSkew`\n+    *   are parameters specified in the ledger [[TimeModel]].\n+    *\n+    * - *command deduplication*: if there is a [[Update.TransactionAccepted]] with\n+    *   an associated [[SubmitterInfo]] `info1`, then for every later\n+    *   transaction with [[SubmitterInfo]] `info2` that agrees with\n+    *   `info1` on the `submitter` and `commandId` fields and\n+    *   was submitted before `info1.deduplicateUntil`,\n+    *   a transaction may be rejected without a corresponding update being issued.\n+    *   I.e., transactions may be deduplicated on the `(submitter, commandId)` tuple,\n+    *   but only until the time specified in [[SubmitterInfo.deduplicateUntil]]."
  },
  {
    "id" : "3483a4f9-8622-4433-8147-35e9229b1a24",
    "prId" : 5043,
    "comments" : [
      {
        "id" : "597d2086-7c5f-46fc-b9aa-7e8e9e2ef734",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "This section is not very precise. Neither `deduplicateUntil` nor `maximumRecordTime` can be used to uniquely identify submissions.",
        "createdAt" : "2020-03-17T14:32:51Z",
        "updatedAt" : "2020-03-17T18:08:49Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "257bda699f866c31589adba93c05b0d47ca02142",
    "line" : 42,
    "diffHunk" : "@@ -79,17 +89,9 @@ trait ReadService extends ReportsHealth {\n     * - *rejection finality*: if there is a [[Update.CommandRejected]] update\n     *   with [[SubmitterInfo]] `info`, then there is no later\n     *   [[Update.TransactionAccepted]] with the same associated [[SubmitterInfo]]\n-    *   `info`. Note that in contrast to *no duplicate transaction acceptance*\n+    *   `info`. Note that in contrast to *command deduplication*\n     *   this only holds wrt the full [[SubmitterInfo]], as a resubmission of a"
  },
  {
    "id" : "9b396a69-4833-4be7-943a-fa2a9c51249d",
    "prId" : 5026,
    "comments" : [
      {
        "id" : "d9ac01b6-178c-45fe-a368-930fc6592fc1",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n    *   contract used by the transaction and `rt_c` the record time of the\r\n```\r\nI prefer the term `used` over `referenced` because used is defined in the ledger model. Referencing could be misunderstood to mean that the sole mentioning of a contract ID in a contract argument in the transaction enforces the monotonicity requirement, but we don't want to guarantee that.",
        "createdAt" : "2020-03-17T07:09:58Z",
        "updatedAt" : "2020-03-17T07:32:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "be783ecb-c2e3-4c34-9b57-e78d36b9eab2",
        "parentId" : "d9ac01b6-178c-45fe-a368-930fc6592fc1",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-03-17T08:14:45Z",
        "updatedAt" : "2020-03-17T08:14:46Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "57010c16d3ed4deaa24f495a9a0b61151b9da188",
    "line" : null,
    "diffHunk" : "@@ -56,11 +56,12 @@ trait ReadService extends ReportsHealth {\n     *   and [[Update.PublicPackageUpload]] updates for all packages referenced by\n     *   the [[Update.TransactionAccepted]].\n     *\n-    * - *monotonic record time*: for any update `u1` with an associated record\n-    *   time `rt1` before an update `u2` with an associated record time `rt2`\n-    *   in the stream, it holds that `rt1 <= rt2`. The updates with an\n-    *   associated record time are [[Update.Heartbeat]] and [[Update.TransactionAccepted]],\n-    *   which both store the record time in the `recordTime` field.\n+    * - *causal monotonicity*: given a [[Update.TransactionAccepted]] with an associated\n+    *   record time `rt_tx`, it holds that `rt_tx >= rt_c` for all `c`, where `c` is a\n+    *   contract referenced by the transaction and `rt_c` the record time of the"
  },
  {
    "id" : "7d14b382-83d9-4576-9c51-b23bbf43ecb8",
    "prId" : 432,
    "comments" : [
      {
        "id" : "4d4998c5-8a3a-4508-b4ca-7bd74c873ae9",
        "parentId" : null,
        "author" : {
          "login" : "gleber-da",
          "name" : "gleber",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/34243031?u=682c8d513afbef14cd3f71d93040a37500b5b2d0&v=4"
        },
        "body" : "Typo `*`\r\n```suggestion\r\n    * - a party `B` hosted at participant `p2`, and\r\n```",
        "createdAt" : "2019-04-12T13:15:40Z",
        "updatedAt" : "2019-04-12T15:11:57Z",
        "lastEditedBy" : {
          "login" : "gleber-da",
          "name" : "gleber",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/34243031?u=682c8d513afbef14cd3f71d93040a37500b5b2d0&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4f8143ac-f93a-46b4-b6c0-56d7132b3958",
        "parentId" : "4d4998c5-8a3a-4508-b4ca-7bd74c873ae9",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "fixed by @dajmaki ",
        "createdAt" : "2019-04-12T15:10:16Z",
        "updatedAt" : "2019-04-12T15:12:30Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "015b4a7f0c0e810915767c5f413631c8cde70d08",
    "line" : null,
    "diffHunk" : "@@ -6,33 +6,155 @@ package com.daml.ledger.participant.state.v1\n import akka.NotUsed\n import akka.stream.scaladsl.Source\n \n+/** An interface for reading the state of a ledger participant.\n+  *\n+  * The state of a ledger participant is communicated as a stream of state\n+  * [[Update]]s. That stream is accessible via [[ReadService!.stateUpdates]].\n+  * Commonly that stream is processed by a single consumer that keeps track of\n+  * the current state and creates indexes to satisfy read requests against\n+  * that state.\n+  *\n+  * See [[com.daml.ledger.participant.state.v1]] for further architectural\n+  * information. See [[Update]] for a description of the state updates\n+  * communicated by [[ReadService!.stateUpdates]].\n+  *\n+  */\n trait ReadService {\n \n-  /** Get the stream of state updates starting from the beginning of the\n-    * given [[Offset]]\n+  // TOOD (SM): add a method to get the initial record time together with the\n+  // ledger-id.\n+\n+  /** Get the stream of state [[Update]]s starting from the beginning or right\n+    * after the given [[Offset]]\n     *\n-    * Correct implementations of this method need to satisfy the properties\n-    * listed below. These properties fall into two categories:\n+    * This is where the meat of the implementation effort lies. Please take your time\n+    * to read carefully through the properties required from correct implementations.\n+    * These properties fall into two categories:\n     *\n     * 1. properties about the sequence of [[(UpdateId, Update)]] tuples\n     *    in a stream read from the beginning, and\n     * 2. properties relating the streams obtained from two separate alls\n     *   to [[ReadService.stateUpdates]].\n     *\n-    * We explain them in turn.\n+    * The first class of properties are invariants of a single stream:\n     *\n     * - *strictly increasing [[Offset]]s*:\n-    *   for any two consecutive tuples `(i1, u1)` and `(i2,u2)` in the\n-    *   stream `i1` is strictly smaller than `i2` when lexicographically\n-    *   comparing the [[Offset]]s.\n+    *   for any two consecutive tuples `(o1, u1)` and `(o2,u2)`, `o1` is\n+    *   strictly smaller than `o2`.\n     *\n     * - *initialize before transaction acceptance*: before any\n     *   [[Update.TransactionAccepted]], there are a [[Update.ConfigurationChanged]] update\n     *   and [[Update.PublicPackageUploaded]] updates for all packages referenced by\n     *   the [[Update.TransactionAccepted]].\n     *\n-    * TODO (SM): finish documentation\n-    * https://github.com/digital-asset/daml/issues/138\n+    * - *monotonic record time*: for any update `u1` with an associated record\n+    *   time `rt1` before an update `u2` with an associated record time `rt2`\n+    *   in the stream, it holds that `rt1 <= rt2`. The updates with an\n+    *   associated record time are [[Update.Heartbeat]] and [[Update.TransactionAccepted]],\n+    *   which both store the record time in the `recordTime` field.\n+    *\n+    * - *no duplicate transaction acceptance*: there are no two separate\n+    *   [[Update.TransactionAccepted]] updates with associated [[SubmitterInfo]]\n+    *   records that agree on the `submitter`, `applicationId` and\n+    *   `commandId` fields.  This implies that transaction submissions must be\n+    *   deduplicated wrt the `(submitter, applicationId, commandId)` tuples.\n+    *\n+    *   TODO (SM): we would like to weaken this requirement to allow multiple\n+    *   [[Update.TransactionAccepted]] updates provided\n+    *   the transactions are sub-transactions of each other. Thereby enabling\n+    *   the after-the-fact communication of extra details about a transaction\n+    *   in case a party is newly hosted at a participant.\n+    *   See https://github.com/digital-asset/daml/issues/430\n+    *\n+    * - *rejection finality*: if there is a [[Update.CommandRejected]] update\n+    *   with [[SubmitterInfo]] `info`, then there is no later\n+    *   [[Update.TransactionAccepted]] with the same associated [[SubmitterInfo]]\n+    *   `info`. Note that in contrast to *no duplicate transaction acceptance*\n+    *   this only holds wrt the full [[SubmitterInfo]], as a resubmission of a\n+    *   transaction with a higher `maximumRecordTime` must be allowed.\n+    *\n+    * - *acceptance finality*: if there is a [[Update.TransactionAccepted]] with\n+    *   associated [[SubmitterInfo]] `info1`, then for every later\n+    *   [[Update.CommandRejected]] with [[SubmitterInfo]] `info2` that agrees with\n+    *   `info1` on the `submitter`, `applicationId`, and `commandId` fields,\n+    *   it holds that the rejection reason is\n+    *   [[RejectionReason.DuplicateCommand]]. Simply put: the only reason for\n+    *   a signalling a rejection of an accepted transaction is a duplicate\n+    *   submission of that transaction.\n+    *\n+    * - *maximum record time enforced*: for all [[Update.TransactionAccepted]]\n+    *   updates `u` with associated [[SubmitterInfo]] `info`, it holds that\n+    *   `u.recordTime <= info.maximumRecordTime`. Together with *monotonic\n+    *   record time* this implies that transactions with a maximum record time\n+    *   `mrt` will not be accepted after an update with an associated record\n+    *   time larger than `mrt` has been observed.\n+    *\n+    * The second class of properties relates multiple calls to\n+    * [[stateUpdates]]s, and thereby provides constraints on which [[Update]]s\n+    * need to be persisted. Before explaining them in detail we provide\n+    * intuition.\n+    *\n+    * All [[Update]]s other than [[Update.Heartbeat]] and [[Update.CommandRejected]] must\n+    * always be persisted by the backends implementing the [[ReadService]].\n+    * For heartbeats and command rejections, the situation is more\n+    * nuanced, as we want to provide the backends with additional\n+    * implementation leeway.\n+    *\n+    * [[Update.CommandRejected]] messages are advisory messages to submitters of\n+    * transactions to inform them in a timely fashion that their transaction\n+    * has been rejected. The failure of transactions submissions for which no\n+    * explicit [[Update.CommandRejected]] message is provided can be detected via\n+    * [[Update.Heartbeat]]s, as explained in the 'maximum record time enforced'\n+    * property above. In that context, it is also such that only the latest [[Update.Heartbeat]]\n+    * with the highest record time matters.\n+    *\n+    * Given this intuition for the desired mechanism, we advise participant\n+    * state implementations to aim to always provide timely\n+    * [[Update.CommandRejected]] messages and regular heartbeats at a\n+    * granularity that supports timely detection of maximum record time\n+    * violation. Concrete values need to be recommended by implementors.\n+    *\n+    * Implementations are free to not persist\n+    * [[Update.CommandRejected]] and [[Update.Heartbeat]] updates provided their\n+    * [[Offset]]s are not reused. This is relevant for the case where a\n+    * consumer rebuilds his view of the state by starting from a fresh\n+    * call to [[ReadService.stateUpdates]]; e.g., because it or the\n+    * stream provider crashed.\n+    *\n+    * Formally, we capture the expected relation between two calls\n+    * `s1 = stateUpdates(o1)` and `s2 = stateUpdates(o2)` for `o1 <= o2` as\n+    * follows.\n+    *\n+    * - *unique offets*: for any update `u1` with offset `uo` in `s1` and any\n+    *   update `u2` with the same offset `uo` in `se2` it holds that `u1 ==\n+    *   u2`. This means that offsets can never be reused. Together with\n+    *   *strictly increasing [[Offset]]* this also implies that the order of\n+    *   elements present in both `s1` and `s2` cannot change.\n+    *\n+    * - *persistent updates*: any update other than [[Update.Heartbeat]] and\n+    *   [[Update.CommandRejected]] in `s2` must also be present in `s1`.\n+    *\n+    *\n+    * Last but not least, there is an expectation about the relation between streams visible\n+    * on *separate* participant state implementations connected to the same ledger.\n+    * The expectation is that two parties hosted on separate participant nodes are in sync\n+    * on transaction nodes and contracts that they can both see. The more formal definition\n+    * is based on the notion of projections of transactions\n+    * (see https://docs.daml.com/concepts/ledger-model/ledger-privacy.html), as follows.\n+    *\n+    * Assume that there is\n+    * - a party `A` hosted at participant `p1`,\n+    * - a party * `B` hosted at participant `p2`, and"
  },
  {
    "id" : "7c255547-7e33-40df-bb64-1542ca3498c4",
    "prId" : 432,
    "comments" : [
      {
        "id" : "7f9cd92a-e884-4da6-9481-3a844de16dab",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "s/UpdateId/Offset/",
        "createdAt" : "2019-04-12T14:04:20Z",
        "updatedAt" : "2019-04-12T15:11:57Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "015b4a7f0c0e810915767c5f413631c8cde70d08",
    "line" : null,
    "diffHunk" : "@@ -6,33 +6,155 @@ package com.daml.ledger.participant.state.v1\n import akka.NotUsed\n import akka.stream.scaladsl.Source\n \n+/** An interface for reading the state of a ledger participant.\n+  *\n+  * The state of a ledger participant is communicated as a stream of state\n+  * [[Update]]s. That stream is accessible via [[ReadService!.stateUpdates]].\n+  * Commonly that stream is processed by a single consumer that keeps track of\n+  * the current state and creates indexes to satisfy read requests against\n+  * that state.\n+  *\n+  * See [[com.daml.ledger.participant.state.v1]] for further architectural\n+  * information. See [[Update]] for a description of the state updates\n+  * communicated by [[ReadService!.stateUpdates]].\n+  *\n+  */\n trait ReadService {\n \n-  /** Get the stream of state updates starting from the beginning of the\n-    * given [[Offset]]\n+  // TOOD (SM): add a method to get the initial record time together with the\n+  // ledger-id.\n+\n+  /** Get the stream of state [[Update]]s starting from the beginning or right\n+    * after the given [[Offset]]\n     *\n-    * Correct implementations of this method need to satisfy the properties\n-    * listed below. These properties fall into two categories:\n+    * This is where the meat of the implementation effort lies. Please take your time\n+    * to read carefully through the properties required from correct implementations.\n+    * These properties fall into two categories:\n     *\n     * 1. properties about the sequence of [[(UpdateId, Update)]] tuples"
  }
]