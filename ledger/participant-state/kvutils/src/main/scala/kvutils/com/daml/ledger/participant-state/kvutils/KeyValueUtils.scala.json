[
  {
    "id" : "6389e02b-a445-4129-8b5d-5597bac476aa",
    "prId" : 637,
    "comments" : [
      {
        "id" : "e1f80cf2-74fc-4176-ba7e-93379b89c7cd",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Why? It is cached by the `Indexer`; and we can't really do that in an actual transaction-processor implementation can we?",
        "createdAt" : "2019-04-24T08:26:28Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb13d545-a6e8-4481-b6d2-44da4d2684c6",
        "parentId" : "e1f80cf2-74fc-4176-ba7e-93379b89c7cd",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "this is used by validation, so index service isn't available.",
        "createdAt" : "2019-04-24T09:53:13Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,447 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.{PackageId, Party, SimpleString}\n+import com.digitalasset.daml.lf.data.Time\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.{Engine, Error => EngineError}\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.{\n+  NodeCreate,\n+  NodeExercises,\n+  NodeFetch,\n+  NodeLookupByKey\n+}\n+import com.digitalasset.daml.lf.transaction._\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  RelativeContractId,\n+  VersionedValue\n+}\n+import com.digitalasset.daml.lf.value.ValueCoder.DecodeError\n+import com.digitalasset.daml.lf.value.ValueOuterClass\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.google.common.io.BaseEncoding\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+/**\n+  * Utilities for implementing participant state on top of a key-value based ledger.\n+  * Implements helpers and serialization/deserialization into protocol buffer messages\n+  * defined in daml_kvutils.proto.\n+  */\n+object KeyValueUtils {\n+\n+  /** Entry identifiers are opaque strings chosen by the implementation that provide a unique\n+    * reference to the entry. This may be the database key used to store the entry, or a combination\n+    * of a key and offset within a batch. Conceptually entry identifier should have 1-1 mapping into\n+    * participant-state [[Offset]] as the implementation using these utilities is expected to produce the\n+    * offset for each entry.\n+    *\n+    * When used as transactionId they're rendered in hexadecimal.\n+    */\n+  type KVEntryId = ByteString\n+\n+  /** A relative contract identifier is a reference to the index of the create node. */\n+  type KVRelativeContractId = Int\n+\n+  /** Absolute Contract Identifiers are references to a transaction node. */\n+  type KVAbsoluteContractId = (KVEntryId, KVRelativeContractId)\n+\n+  /** A contract instance along with its ledger effective time from which it is active. */\n+  type StampedContractInstance = (Timestamp, ContractInst[Transaction.Value[AbsoluteContractId]])\n+\n+  /** KVEntry is the serialized 'DamlKVEntry', containing either the submitted transaction and related metadata\n+    * or the DAML-LF archive. */\n+  type KVEntryBlob = ByteString\n+\n+  /** The inputs to the transaction. */\n+  final case class Inputs(\n+      /* The contracts referenced in the transaction.\n+       * When committing the activeness of the referenced contracts at the ledger effective time\n+       * of the transaction must be validated.\n+       */\n+      contracts: List[KVAbsoluteContractId],\n+      /* FIXME(JM): Contract key inputs */\n+\n+      /* The DAML-LF packages referenced in the transaction. */\n+      // FIXME(JM): We need this information from DAML Engine!\n+      packages: List[PackageId]\n+  )\n+\n+  /** The effects of the transaction, that is what contracts\n+    * were consumed and created, and what contract keys were updated.\n+    */\n+  case class Effects(\n+      /** The contracts consumed by this transaction.\n+        * When committing the transaction these contracts must be marked consumed.\n+        * A contract should be marked consumed when the transaction is committed,\n+        * regardless of the ledger effective time of the transaction (e.g. a transaction\n+        * with an earlier ledger effective time that gets committed later would find the\n+        * contract inactive).\n+        */\n+      consumedContracts: List[KVAbsoluteContractId],\n+      /** The contracts created by this transaction.\n+        * When the transaction is committed, keys marking the activeness of these\n+        * contracts should be created. The key should be a combination of the transaction\n+        * id and the relative contract id (that is, the node index).\n+        */\n+      createdContracts: List[KVRelativeContractId]\n+\n+      // FIXME(JM): updated contract keys\n+  )\n+\n+  /** Transaction information required for validation, consistency checks\n+    * and for updating contract activeness. */\n+  case class TxInfo(\n+      /** The party that submitted the transaction. */\n+      submitter: Party,\n+      /** The ledger effective time of the transaction. The activeness of the declared inputs should\n+        * be checked in relation to this (except if archived, see comment near [[Effects.consumedContracts]]).\n+        */\n+      ledgerEffectiveTime: Timestamp,\n+      /** The inputs to the transaction. */\n+      inputs: Inputs,\n+      /** The effects of the transaction: the contracts consumed and created. */\n+      effects: Effects,\n+      /** The decoded transaction. */\n+      tx: SubmittedTransaction,\n+  )\n+\n+  /** Given a KVTransaction and a contract id, deserialize the transaction and\n+    * and produce the absolute contract instance.\n+    *\n+    * FIXME(JM): We should cache some of the work to deserialize the transactions."
  },
  {
    "id" : "2f926948-4958-4ef6-8d4c-49309e3d1f5f",
    "prId" : 637,
    "comments" : [
      {
        "id" : "95b1b7b2-da43-4ae6-950f-a7e7a7dafab2",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Negative numbers seem to be a problem. What about too large numbers?",
        "createdAt" : "2019-04-24T08:37:32Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,447 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.{PackageId, Party, SimpleString}\n+import com.digitalasset.daml.lf.data.Time\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.{Engine, Error => EngineError}\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.{\n+  NodeCreate,\n+  NodeExercises,\n+  NodeFetch,\n+  NodeLookupByKey\n+}\n+import com.digitalasset.daml.lf.transaction._\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  RelativeContractId,\n+  VersionedValue\n+}\n+import com.digitalasset.daml.lf.value.ValueCoder.DecodeError\n+import com.digitalasset.daml.lf.value.ValueOuterClass\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.google.common.io.BaseEncoding\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+/**\n+  * Utilities for implementing participant state on top of a key-value based ledger.\n+  * Implements helpers and serialization/deserialization into protocol buffer messages\n+  * defined in daml_kvutils.proto.\n+  */\n+object KeyValueUtils {\n+\n+  /** Entry identifiers are opaque strings chosen by the implementation that provide a unique\n+    * reference to the entry. This may be the database key used to store the entry, or a combination\n+    * of a key and offset within a batch. Conceptually entry identifier should have 1-1 mapping into\n+    * participant-state [[Offset]] as the implementation using these utilities is expected to produce the\n+    * offset for each entry.\n+    *\n+    * When used as transactionId they're rendered in hexadecimal.\n+    */\n+  type KVEntryId = ByteString\n+\n+  /** A relative contract identifier is a reference to the index of the create node. */\n+  type KVRelativeContractId = Int\n+\n+  /** Absolute Contract Identifiers are references to a transaction node. */\n+  type KVAbsoluteContractId = (KVEntryId, KVRelativeContractId)\n+\n+  /** A contract instance along with its ledger effective time from which it is active. */\n+  type StampedContractInstance = (Timestamp, ContractInst[Transaction.Value[AbsoluteContractId]])\n+\n+  /** KVEntry is the serialized 'DamlKVEntry', containing either the submitted transaction and related metadata\n+    * or the DAML-LF archive. */\n+  type KVEntryBlob = ByteString\n+\n+  /** The inputs to the transaction. */\n+  final case class Inputs(\n+      /* The contracts referenced in the transaction.\n+       * When committing the activeness of the referenced contracts at the ledger effective time\n+       * of the transaction must be validated.\n+       */\n+      contracts: List[KVAbsoluteContractId],\n+      /* FIXME(JM): Contract key inputs */\n+\n+      /* The DAML-LF packages referenced in the transaction. */\n+      // FIXME(JM): We need this information from DAML Engine!\n+      packages: List[PackageId]\n+  )\n+\n+  /** The effects of the transaction, that is what contracts\n+    * were consumed and created, and what contract keys were updated.\n+    */\n+  case class Effects(\n+      /** The contracts consumed by this transaction.\n+        * When committing the transaction these contracts must be marked consumed.\n+        * A contract should be marked consumed when the transaction is committed,\n+        * regardless of the ledger effective time of the transaction (e.g. a transaction\n+        * with an earlier ledger effective time that gets committed later would find the\n+        * contract inactive).\n+        */\n+      consumedContracts: List[KVAbsoluteContractId],\n+      /** The contracts created by this transaction.\n+        * When the transaction is committed, keys marking the activeness of these\n+        * contracts should be created. The key should be a combination of the transaction\n+        * id and the relative contract id (that is, the node index).\n+        */\n+      createdContracts: List[KVRelativeContractId]\n+\n+      // FIXME(JM): updated contract keys\n+  )\n+\n+  /** Transaction information required for validation, consistency checks\n+    * and for updating contract activeness. */\n+  case class TxInfo(\n+      /** The party that submitted the transaction. */\n+      submitter: Party,\n+      /** The ledger effective time of the transaction. The activeness of the declared inputs should\n+        * be checked in relation to this (except if archived, see comment near [[Effects.consumedContracts]]).\n+        */\n+      ledgerEffectiveTime: Timestamp,\n+      /** The inputs to the transaction. */\n+      inputs: Inputs,\n+      /** The effects of the transaction: the contracts consumed and created. */\n+      effects: Effects,\n+      /** The decoded transaction. */\n+      tx: SubmittedTransaction,\n+  )\n+\n+  /** Given a KVTransaction and a contract id, deserialize the transaction and\n+    * and produce the absolute contract instance.\n+    *\n+    * FIXME(JM): We should cache some of the work to deserialize the transactions.\n+    */\n+  def lookupStampedContractInstance(\n+      entryId: KVEntryId,\n+      entry: KVEntryBlob,\n+      coid: KVAbsoluteContractId): Option[StampedContractInstance] = {\n+    val decodedKvTx = decodeKVTransaction(entry)\n+    val relTx = TransactionCoding.decodeTransaction(decodedKvTx.getTransaction)\n+    relTx.nodes\n+      .get(NodeId.unsafeFromIndex(coid._2))\n+      .flatMap { (node: Transaction.Node) =>\n+        node match {\n+          case create: NodeCreate[ContractId, VersionedValue[ContractId]] =>\n+            Some(\n+              parseTimestamp(decodedKvTx.getLedgerEffectiveTime) ->\n+                create.coinst.mapValue(\n+                  _.mapContractId(toAbsCoid(entryId, _))\n+                )\n+            )\n+          case _ =>\n+            // TODO(JM): Logging?\n+            None\n+        }\n+      }\n+  }\n+\n+  /** Transform the submitted transaction into entry blob. */\n+  def transactionToEntry(\n+      submitterInfo: SubmitterInfo,\n+      meta: TransactionMeta,\n+      tx: SubmittedTransaction): KVEntryBlob = {\n+    DamlKVEntry.newBuilder\n+      .setTransaction(\n+        DamlKVTransaction.newBuilder\n+          .setTransaction(TransactionCoding.encodeTransaction(tx))\n+          .setCommandId(submitterInfo.commandId)\n+          .setSubmitter(submitterInfo.submitter.underlyingString)\n+          .setApplicationId(submitterInfo.applicationId)\n+          .setLedgerEffectiveTime(buildTimestamp(meta.ledgerEffectiveTime))\n+          .setMaximumRecordTime(buildTimestamp(submitterInfo.maxRecordTime))\n+          .setWorkflowId(meta.workflowId)\n+          .build\n+      )\n+      .build\n+      .toByteString\n+  }\n+\n+  def archiveToEntry(archive: Archive): KVEntryBlob = {\n+    DamlKVEntry.newBuilder\n+      .setArchive(\n+        DamlKVArchive.newBuilder\n+          .setPackageId(archive.getHash)\n+          .setArchiveBytes(archive.toByteString)\n+      )\n+      .build\n+      .toByteString\n+  }\n+\n+  /** Convert the entry blob into a participant state [[Update]].\n+    * The caller is expected to provide the record time of the batch into which the entry\n+    * was committed and to produce the accompanying [[Offset]] from the entryId.\n+    *\n+    * @param entryId: The transaction identifier assigned to the transaction.\n+    * @param entry: The entry blob.\n+    * @param recordTime: The record time of the batch into which the entry was committed.\n+    */\n+  def entryToUpdate(entryId: KVEntryId, entry: KVEntryBlob, recordTime: Timestamp): Update = {\n+    val parsedEntry = DamlKVEntry.parseFrom(entry)\n+    parsedEntry.getPayloadCase match {\n+      case DamlKVEntry.PayloadCase.ARCHIVE =>\n+        makePublicPackageUploaded(parsedEntry.getArchive)\n+\n+      case DamlKVEntry.PayloadCase.TRANSACTION =>\n+        makeTransactionAccepted(entryId, parsedEntry.getTransaction, recordTime)\n+\n+      case x =>\n+        throw new RuntimeException(\"entryToUpdate: Unknown payload case: $x\")\n+    }\n+  }\n+\n+  private def makePublicPackageUploaded(archive: DamlKVArchive): Update.PublicPackageUploaded =\n+    Update.PublicPackageUploaded(\n+      Archive.parseFrom(archive.getArchiveBytes)\n+    )\n+\n+  /** Transform the DamlKVTransaction into the [[Update.TransactionAccepted]] event. */\n+  private def makeTransactionAccepted(\n+      entryId: KVEntryId,\n+      kvTx: DamlKVTransaction,\n+      recordTime: Timestamp): Update.TransactionAccepted = {\n+    val relTx = TransactionCoding.decodeTransaction(kvTx.getTransaction)\n+    val hexTxId = BaseEncoding.base16.encode(entryId.toByteArray)\n+\n+    Update.TransactionAccepted(\n+      optSubmitterInfo = Some(\n+        SubmitterInfo(\n+          submitter = SimpleString.assertFromString(kvTx.getSubmitter),\n+          applicationId = kvTx.getApplicationId,\n+          commandId = kvTx.getCommandId,\n+          maxRecordTime = parseTimestamp(kvTx.getMaximumRecordTime),\n+        )),\n+      transactionMeta = TransactionMeta(\n+        ledgerEffectiveTime = parseTimestamp(kvTx.getLedgerEffectiveTime),\n+        workflowId = kvTx.getWorkflowId,\n+      ),\n+      transaction = makeCommittedTransaction(entryId, relTx),\n+      transactionId = hexTxId,\n+      recordTime = recordTime,\n+      referencedContracts = List.empty // TODO(JM): rename this to additionalContracts. Always empty here.\n+    )\n+  }\n+\n+  /** Compute the transaction information from the KVTransaction. */\n+  def computeTxInfo(entry: KVEntryBlob): TxInfo = {\n+    val decodedKvTx = decodeKVTransaction(entry)\n+    val relTx = TransactionCoding.decodeTransaction(decodedKvTx.getTransaction)\n+    val (inputs, effects) = computeInputsAndEffects(relTx)\n+\n+    TxInfo(\n+      submitter = SimpleString.assertFromString(decodedKvTx.getSubmitter),\n+      ledgerEffectiveTime = parseTimestamp(decodedKvTx.getLedgerEffectiveTime),\n+      inputs = inputs,\n+      effects = effects,\n+      tx = relTx,\n+    )\n+  }\n+\n+  // ------------------------------------------------------\n+\n+  private def decodeKVTransaction(blob: KVEntryBlob): DamlKVTransaction =\n+    // FIXME(JM): throws a protobuf exception if this wasn't a transaction. we might want something more specific?\n+    DamlKVEntry.parser.parseFrom(blob.newCodedInput).getTransaction\n+\n+  private def computeInputsAndEffects(tx: SubmittedTransaction): (Inputs, Effects) = {\n+    // FIXME(JM): Get referenced packages from the transaction (once they're added to it)\n+    def addInput(inputs: Inputs, coid: ContractId): Inputs =\n+      coid match {\n+        case acoid: AbsoluteContractId =>\n+          inputs.copy(\n+            contracts = decodeAbsoluteContractId(acoid) :: inputs.contracts\n+          )\n+        case _ =>\n+          inputs\n+      }\n+\n+    tx.fold(\n+      GenTransaction.TopDown,\n+      (Inputs(List.empty, List.empty), Effects(List.empty, List.empty))) {\n+      case ((inputs, effects), (nodeId, node)) =>\n+        node match {\n+          case fetch: NodeFetch[ContractId] =>\n+            (addInput(inputs, fetch.coid), effects)\n+          case create: NodeCreate[_, _] =>\n+            (\n+              inputs,\n+              effects.copy(\n+                createdContracts = create.coid\n+                  .asInstanceOf[RelativeContractId]\n+                  .txnid\n+                  .index :: effects.createdContracts\n+              ))\n+          case exe: NodeExercises[_, ContractId, _] =>\n+            (\n+              addInput(inputs, exe.targetCoid),\n+              if (exe.consuming) {\n+                exe.targetCoid match {\n+                  case acoid: AbsoluteContractId =>\n+                    effects.copy(\n+                      consumedContracts = decodeAbsoluteContractId(acoid) :: effects.consumedContracts\n+                    )\n+                  case _ =>\n+                    effects\n+                }\n+              } else {\n+                effects\n+              }\n+            )\n+          case l: NodeLookupByKey[_, _] =>\n+            // FIXME(JM): track fetched keys\n+            (inputs, effects)\n+        }\n+    }\n+  }\n+\n+  private def toAbsCoid(txId: KVEntryId, coid: ContractId): AbsoluteContractId = {\n+    val hexTxId =\n+      BaseEncoding.base16.encode(txId.toByteArray)\n+    coid match {\n+      case a @ AbsoluteContractId(_) => a\n+      case RelativeContractId(txnid) =>\n+        // NOTE(JM): Must match with decodeAbsoluteContractId\n+        AbsoluteContractId(s\"$hexTxId:${txnid.index}\")\n+    }\n+  }\n+\n+  private def makeCommittedTransaction(\n+      txId: KVEntryId,\n+      tx: SubmittedTransaction): CommittedTransaction = {\n+    tx\n+    /* Assign absolute contract ids */\n+      .mapContractIdAndValue(\n+        toAbsCoid(txId, _),\n+        _.mapContractId(toAbsCoid(txId, _))\n+      )\n+  }\n+\n+  private def decodeAbsoluteContractId(acoid: AbsoluteContractId): KVAbsoluteContractId =\n+    acoid.coid.split(':').toList match {\n+      case hexTxId :: nodeId :: Nil =>\n+        (ByteString.copyFrom(BaseEncoding.base16().decode(hexTxId)), nodeId.toInt)\n+      case _ => sys.error(s\"decodeAbsoluteContractId: Cannot decode '$acoid'\")\n+    }\n+\n+  private def buildTimestamp(ts: Time.Timestamp): com.google.protobuf.Timestamp = {\n+    val instant = ts.toInstant\n+    com.google.protobuf.Timestamp.newBuilder\n+      .setSeconds(instant.getEpochSecond)\n+      .setNanos(instant.getNano)\n+      .build\n+  }\n+\n+  private def parseTimestamp(ts: com.google.protobuf.Timestamp): Time.Timestamp =\n+    Time.Timestamp.assertFromInstant(Instant.ofEpochSecond(ts.getSeconds, ts.getNanos.toLong))\n+\n+  // ------------------------------------------\n+  // Entry validation.\n+  // TODO:\n+  // - given an entry blob, deserializes it and runs the DAML engine validation on the transaction.\n+  // - DAML engine must be able to load packages as needed, hence that functionality must be provided by the\n+  //   caller.\n+\n+  def validateTransaction(\n+      engine: Engine,\n+      // The packages used as inputs to the entry.\n+      // FIXME(JM): The engine caches these so we could retrieve these lazily as needed.\n+      inputPackages: Map[PackageId, ByteString],\n+      inputTransactions: Map[KVEntryId, KVEntryBlob],\n+      txInfo: TxInfo): Either[EngineError, Unit] = {\n+\n+    def lookupContract(coid: AbsoluteContractId) = {\n+      val kvCoid = decodeAbsoluteContractId(coid)\n+      inputTransactions.get(kvCoid._1).flatMap { entry =>\n+        lookupStampedContractInstance(kvCoid._1, entry, kvCoid).flatMap {\n+          case (activeAt, coinst) =>\n+            if (activeAt > txInfo.ledgerEffectiveTime)\n+              None\n+            else\n+              Some(coinst)\n+        }\n+      }\n+    }\n+\n+    def lookupPackage(pkgId: PackageId) =\n+      inputPackages.get(pkgId).map { archiveBytes =>\n+        Decode.decodeArchive(Archive.parseFrom(archiveBytes))._2\n+      }\n+\n+    engine\n+      .validate(txInfo.tx, txInfo.ledgerEffectiveTime)\n+      .consume(lookupContract, lookupPackage, _ => sys.error(\"unimplemented\"))\n+  }\n+\n+  // ------------------------------------------\n+\n+  object TransactionCoding {\n+\n+    import com.digitalasset.daml.lf.transaction.TransactionCoder\n+    import com.digitalasset.daml.lf.value.ValueCoder\n+\n+    def encodeTransaction(tx: SubmittedTransaction): TransactionOuterClass.Transaction = {\n+      TransactionCoder\n+        .encodeTransactionWithCustomVersion(\n+          nidEncoder,\n+          cidEncoder,\n+          VersionedTransaction(TransactionVersions.assignVersion(tx), tx))\n+        .fold(err => sys.error(s\"encodeTransaction error: $err\"), identity)\n+    }\n+\n+    def decodeTransaction(tx: TransactionOuterClass.Transaction): SubmittedTransaction = {\n+      TransactionCoder\n+        .decodeVersionedTransaction(\n+          nidDecoder,\n+          cidDecoder,\n+          tx\n+        )\n+        .fold(err => sys.error(s\"decodeTransaction error: $err\"), _.transaction)\n+    }\n+\n+    // FIXME(JM): Should we have a well-defined schema for this?\n+    private val cidEncoder: ValueCoder.EncodeCid[ContractId] = {\n+      val asStruct: ContractId => (String, Boolean) = {\n+        case RelativeContractId(nid) => (s\"~${nid.index}\", true)\n+        case AbsoluteContractId(coid) => (s\"$coid\", false)\n+      }\n+      ValueCoder.EncodeCid(asStruct(_)._1, asStruct)\n+    }\n+    private val cidDecoder: ValueCoder.DecodeCid[ContractId] = {\n+      def fromString(x: String): Either[DecodeError, ContractId] = {\n+        if (x.startsWith(\"~\"))\n+          Try(x.tail.toInt).toOption match {\n+            case None =>\n+              Left(DecodeError(s\"Invalid relative contract id: $x\"))\n+            case Some(i) =>\n+              Right(RelativeContractId(NodeId.unsafeFromIndex(i)))"
  }
]