[
  {
    "id" : "61c997ef-1a26-4bd5-b230-9341191688c5",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "862fb888-0cc7-4c75-9d69-03755aae1a19",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "`conflictsWithCurrentState`",
        "createdAt" : "2020-07-24T15:52:02Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "81a10e75-74d7-4008-a512-e913244f0b2d",
        "parentId" : "862fb888-0cc7-4c75-9d69-03755aae1a19",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-03T16:45:31Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.preexecution\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.{Bytes, Err, Fingerprint}\n+import com.daml.ledger.participant.state.v1.SubmissionResult\n+import com.daml.ledger.validator.LedgerStateOperations\n+import com.daml.ledger.validator.LedgerStateOperations.Value\n+import com.daml.ledger.validator.SubmissionValidator.RawKeyValuePairs\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+/**\n+  * An in-transaction post-execution finalizer to be invoked as the last stage of a pre-execution pipeline that\n+  * performs deferred time bound checks, detects pre-execution conflicts and persists both state changes and\n+  * a suitable log entry.\n+  *\n+  * It access the ledger state through [[LedgerStateOperations]] that doesn't provide fingerprints along values\n+  * and so it is parametric in the logic that produces a fingerprint given a value.\n+  *\n+  * @param valueToFingerprint The logic producing a [[Fingerprint]] given a value.\n+  * @tparam LogResult Type of the offset used for a log entry.\n+  */\n+class PostExecutionFinalizerWithFingerprintsFromValues[LogResult](\n+    valueToFingerprint: Option[Value] => Fingerprint) {\n+\n+  import PostExecutionFinalizerWithFingerprintsFromValues._\n+\n+  /**\n+    * @param now The logic that produces the current instant for record time bounds check and record time finality.\n+    * @param preExecutionOutput The output from the pre-execution stage.\n+    * @param ledgerStateOperations The operations that can access actual ledger storage as part of a transaction.\n+    * @param executionContext The execution context for ledger state operations.\n+    * @return The submission result (asynchronous).\n+    */\n+  def conflictDetectAndFinalize(\n+      now: () => Instant,\n+      preExecutionOutput: PreExecutionOutput[RawKeyValuePairs],\n+      ledgerStateOperations: LedgerStateOperations[LogResult],\n+  )(implicit executionContext: ExecutionContext): Future[SubmissionResult] = {\n+    val keys = preExecutionOutput.readSet.map(_._1)\n+    val preExecutionFingerprints = preExecutionOutput.readSet.map(_._2)\n+\n+    val conflictFuture = for {"
  },
  {
    "id" : "971cb1c8-c7ee-49ca-b4d8-fc6f680a709d",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "8182a838-fda6-4bff-be86-91d70249541d",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "I'd suggest breaking this function into smaller chunks to improve readability.",
        "createdAt" : "2020-07-24T15:54:14Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ae2a7f09-91d7-4aff-8079-4532eba877b5",
        "parentId" : "8182a838-fda6-4bff-be86-91d70249541d",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-03T16:45:26Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.preexecution\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.{Bytes, Err, Fingerprint}\n+import com.daml.ledger.participant.state.v1.SubmissionResult\n+import com.daml.ledger.validator.LedgerStateOperations\n+import com.daml.ledger.validator.LedgerStateOperations.Value\n+import com.daml.ledger.validator.SubmissionValidator.RawKeyValuePairs\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+/**\n+  * An in-transaction post-execution finalizer to be invoked as the last stage of a pre-execution pipeline that\n+  * performs deferred time bound checks, detects pre-execution conflicts and persists both state changes and\n+  * a suitable log entry.\n+  *\n+  * It access the ledger state through [[LedgerStateOperations]] that doesn't provide fingerprints along values\n+  * and so it is parametric in the logic that produces a fingerprint given a value.\n+  *\n+  * @param valueToFingerprint The logic producing a [[Fingerprint]] given a value.\n+  * @tparam LogResult Type of the offset used for a log entry.\n+  */\n+class PostExecutionFinalizerWithFingerprintsFromValues[LogResult](\n+    valueToFingerprint: Option[Value] => Fingerprint) {\n+\n+  import PostExecutionFinalizerWithFingerprintsFromValues._\n+\n+  /**\n+    * @param now The logic that produces the current instant for record time bounds check and record time finality.\n+    * @param preExecutionOutput The output from the pre-execution stage.\n+    * @param ledgerStateOperations The operations that can access actual ledger storage as part of a transaction.\n+    * @param executionContext The execution context for ledger state operations.\n+    * @return The submission result (asynchronous).\n+    */\n+  def conflictDetectAndFinalize(\n+      now: () => Instant,\n+      preExecutionOutput: PreExecutionOutput[RawKeyValuePairs],\n+      ledgerStateOperations: LedgerStateOperations[LogResult],\n+  )(implicit executionContext: ExecutionContext): Future[SubmissionResult] = {\n+    val keys = preExecutionOutput.readSet.map(_._1)\n+    val preExecutionFingerprints = preExecutionOutput.readSet.map(_._2)\n+\n+    val conflictFuture = for {\n+      values <- ledgerStateOperations.readState(keys)\n+      postExecutionFingerprints = values.map(valueToFingerprint)\n+    } yield preExecutionFingerprints != postExecutionFingerprints\n+\n+    conflictFuture.flatMap { hasConflict =>\n+      if (hasConflict) {\n+        throw Conflict\n+      } else {\n+        val recordTime = now()"
  },
  {
    "id" : "86bb54bd-1d21-4bd1-9ff7-fb55a02b11d8",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "d80b67dc-352b-4953-bc0c-f6eddfb19379",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You could merge these to improve readability, e.g.:\r\n```scala\r\n  for {\r\n    values <- ...\r\n    currentFingerprints = values.map(valueToFingerprint)\r\n    hasConflict = preExecutionFingerprints != currentFingerprints\r\n  } yield {\r\n    if (hasConflict) {\r\n      ...\r\n    } else {\r\n      ...\r\n    }\r\n  }\r\n```",
        "createdAt" : "2020-08-04T08:58:28Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "15cc5270-1439-4ae1-bc12-bf46a9110e64",
        "parentId" : "d80b67dc-352b-4953-bc0c-f6eddfb19379",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-04T12:30:57Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.preexecution\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.{Bytes, Err, Fingerprint}\n+import com.daml.ledger.participant.state.v1.SubmissionResult\n+import com.daml.ledger.validator.LedgerStateOperations\n+import com.daml.ledger.validator.LedgerStateOperations.Value\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+/**\n+  * An in-transaction post-execution finalizer to be invoked as the last stage of a pre-execution pipeline that\n+  * performs deferred time bound checks, detects pre-execution conflicts and persists both state changes and\n+  * a suitable log entry.\n+  *\n+  * It access the ledger state through [[LedgerStateOperations]] that doesn't provide fingerprints along values\n+  * and so it is parametric in the logic that produces a fingerprint given a value.\n+  *\n+  * @param valueToFingerprint The logic producing a [[Fingerprint]] given a value.\n+  * @tparam LogResult Type of the offset used for a log entry.\n+  */\n+class PostExecutionFinalizerWithFingerprintsFromValues[LogResult](\n+    valueToFingerprint: Option[Value] => Fingerprint) {\n+\n+  import PostExecutionFinalizerWithFingerprintsFromValues._\n+\n+  /**\n+    * @param now The logic that produces the current instant for record time bounds check and record time finality.\n+    * @param preExecutionOutput The output from the pre-execution stage.\n+    * @param ledgerStateOperations The operations that can access actual ledger storage as part of a transaction.\n+    * @param executionContext The execution context for ledger state operations.\n+    * @return The submission result (asynchronous).\n+    */\n+  def conflictDetectAndFinalize(\n+      now: () => Instant,\n+      preExecutionOutput: PreExecutionOutput[AnnotatedRawKeyValuePairs],\n+      ledgerStateOperations: LedgerStateOperations[LogResult],\n+  )(implicit executionContext: ExecutionContext): Future[SubmissionResult] = {\n+    val keys = preExecutionOutput.readSet.map(_._1)\n+    val preExecutionFingerprints = preExecutionOutput.readSet.map(_._2)\n+\n+    val conflictsWithCurrentState = for {\n+      values <- ledgerStateOperations.readState(keys)\n+      postExecutionFingerprints = values.map(valueToFingerprint)\n+    } yield preExecutionFingerprints != postExecutionFingerprints"
  },
  {
    "id" : "56fc0c2e-aa24-40ea-8181-877e2dbef371",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "6a02a7fa-1260-4b3e-9983-bb52b839e55d",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Can you rename this to something shorter, like `PostExecutionFinalizer`, please? I.e., we most probably won't have two versions of post-execution logic.",
        "createdAt" : "2020-08-04T09:22:16Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c3e0821e-da01-411b-8e11-cec0c01a830f",
        "parentId" : "6a02a7fa-1260-4b3e-9983-bb52b839e55d",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-04T12:30:05Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.preexecution\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.{Bytes, Err, Fingerprint}\n+import com.daml.ledger.participant.state.v1.SubmissionResult\n+import com.daml.ledger.validator.LedgerStateOperations\n+import com.daml.ledger.validator.LedgerStateOperations.Value\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+/**\n+  * An in-transaction post-execution finalizer to be invoked as the last stage of a pre-execution pipeline that\n+  * performs deferred time bound checks, detects pre-execution conflicts and persists both state changes and\n+  * a suitable log entry.\n+  *\n+  * It access the ledger state through [[LedgerStateOperations]] that doesn't provide fingerprints along values\n+  * and so it is parametric in the logic that produces a fingerprint given a value.\n+  *\n+  * @param valueToFingerprint The logic producing a [[Fingerprint]] given a value.\n+  * @tparam LogResult Type of the offset used for a log entry.\n+  */\n+class PostExecutionFinalizerWithFingerprintsFromValues[LogResult]("
  },
  {
    "id" : "b90804f7-9f98-4377-85c0-d5b7e51b87d1",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "ae7611a9-3a04-4a94-877c-ba8d3bc75a1b",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n  val ConflictDetectedException = new RuntimeException\r\n```",
        "createdAt" : "2020-08-04T09:23:45Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "63d0f1c1-7808-4178-b3c7-4fb7a364d7d3",
        "parentId" : "ae7611a9-3a04-4a94-877c-ba8d3bc75a1b",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-04T12:29:58Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.preexecution\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.{Bytes, Err, Fingerprint}\n+import com.daml.ledger.participant.state.v1.SubmissionResult\n+import com.daml.ledger.validator.LedgerStateOperations\n+import com.daml.ledger.validator.LedgerStateOperations.Value\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+/**\n+  * An in-transaction post-execution finalizer to be invoked as the last stage of a pre-execution pipeline that\n+  * performs deferred time bound checks, detects pre-execution conflicts and persists both state changes and\n+  * a suitable log entry.\n+  *\n+  * It access the ledger state through [[LedgerStateOperations]] that doesn't provide fingerprints along values\n+  * and so it is parametric in the logic that produces a fingerprint given a value.\n+  *\n+  * @param valueToFingerprint The logic producing a [[Fingerprint]] given a value.\n+  * @tparam LogResult Type of the offset used for a log entry.\n+  */\n+class PostExecutionFinalizerWithFingerprintsFromValues[LogResult](\n+    valueToFingerprint: Option[Value] => Fingerprint) {\n+\n+  import PostExecutionFinalizerWithFingerprintsFromValues._\n+\n+  /**\n+    * @param now The logic that produces the current instant for record time bounds check and record time finality.\n+    * @param preExecutionOutput The output from the pre-execution stage.\n+    * @param ledgerStateOperations The operations that can access actual ledger storage as part of a transaction.\n+    * @param executionContext The execution context for ledger state operations.\n+    * @return The submission result (asynchronous).\n+    */\n+  def conflictDetectAndFinalize(\n+      now: () => Instant,\n+      preExecutionOutput: PreExecutionOutput[AnnotatedRawKeyValuePairs],\n+      ledgerStateOperations: LedgerStateOperations[LogResult],\n+  )(implicit executionContext: ExecutionContext): Future[SubmissionResult] = {\n+    val keys = preExecutionOutput.readSet.map(_._1)\n+    val preExecutionFingerprints = preExecutionOutput.readSet.map(_._2)\n+\n+    val conflictsWithCurrentState = for {\n+      values <- ledgerStateOperations.readState(keys)\n+      postExecutionFingerprints = values.map(valueToFingerprint)\n+    } yield preExecutionFingerprints != postExecutionFingerprints\n+\n+    conflictsWithCurrentState.flatMap { hasConflict =>\n+      if (hasConflict)\n+        throw Conflict\n+      else\n+        finalizeSubmission(now, preExecutionOutput, ledgerStateOperations)\n+    }\n+  }\n+}\n+\n+object PostExecutionFinalizerWithFingerprintsFromValues {\n+  val Conflict = new RuntimeException"
  },
  {
    "id" : "d4accd52-509e-417d-8235-0dfe56425a59",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "a12b8f55-8554-4e5d-a91a-40712c0e499e",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Can you add a message to this exception, please?",
        "createdAt" : "2020-08-04T09:24:29Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5ef84c6e-2205-41fd-ac01-c77316ce01b6",
        "parentId" : "a12b8f55-8554-4e5d-a91a-40712c0e499e",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-04T12:29:54Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.preexecution\n+\n+import java.time.Instant\n+\n+import com.daml.ledger.participant.state.kvutils.{Bytes, Err, Fingerprint}\n+import com.daml.ledger.participant.state.v1.SubmissionResult\n+import com.daml.ledger.validator.LedgerStateOperations\n+import com.daml.ledger.validator.LedgerStateOperations.Value\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+/**\n+  * An in-transaction post-execution finalizer to be invoked as the last stage of a pre-execution pipeline that\n+  * performs deferred time bound checks, detects pre-execution conflicts and persists both state changes and\n+  * a suitable log entry.\n+  *\n+  * It access the ledger state through [[LedgerStateOperations]] that doesn't provide fingerprints along values\n+  * and so it is parametric in the logic that produces a fingerprint given a value.\n+  *\n+  * @param valueToFingerprint The logic producing a [[Fingerprint]] given a value.\n+  * @tparam LogResult Type of the offset used for a log entry.\n+  */\n+class PostExecutionFinalizerWithFingerprintsFromValues[LogResult](\n+    valueToFingerprint: Option[Value] => Fingerprint) {\n+\n+  import PostExecutionFinalizerWithFingerprintsFromValues._\n+\n+  /**\n+    * @param now The logic that produces the current instant for record time bounds check and record time finality.\n+    * @param preExecutionOutput The output from the pre-execution stage.\n+    * @param ledgerStateOperations The operations that can access actual ledger storage as part of a transaction.\n+    * @param executionContext The execution context for ledger state operations.\n+    * @return The submission result (asynchronous).\n+    */\n+  def conflictDetectAndFinalize(\n+      now: () => Instant,\n+      preExecutionOutput: PreExecutionOutput[AnnotatedRawKeyValuePairs],\n+      ledgerStateOperations: LedgerStateOperations[LogResult],\n+  )(implicit executionContext: ExecutionContext): Future[SubmissionResult] = {\n+    val keys = preExecutionOutput.readSet.map(_._1)\n+    val preExecutionFingerprints = preExecutionOutput.readSet.map(_._2)\n+\n+    val conflictsWithCurrentState = for {\n+      values <- ledgerStateOperations.readState(keys)\n+      postExecutionFingerprints = values.map(valueToFingerprint)\n+    } yield preExecutionFingerprints != postExecutionFingerprints\n+\n+    conflictsWithCurrentState.flatMap { hasConflict =>\n+      if (hasConflict)\n+        throw Conflict\n+      else\n+        finalizeSubmission(now, preExecutionOutput, ledgerStateOperations)\n+    }\n+  }\n+}\n+\n+object PostExecutionFinalizerWithFingerprintsFromValues {\n+  val Conflict = new RuntimeException"
  }
]