[
  {
    "id" : "46b8d8a1-6557-4546-96d9-8bd15ed3596b",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "87f6b319-e683-4fd0-81f9-367768558cbb",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Explain purpose of Context",
        "createdAt" : "2019-10-08T15:17:55Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6213e7fa-d52b-4885-bd66-d37cd08a405b",
        "parentId" : "87f6b319-e683-4fd0-81f9-367768558cbb",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "In particular explain what data it maintains and how it does so.\r\n\r\nAFAIU, it maintains the inputs and a mutable state map on top of it; and the idea is to start with just the inputs and the other ledger metadata captured, and then mutate the outputs \"into shape\". Is that correct?",
        "createdAt" : "2019-10-09T15:49:54Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6e29c317-55ac-44bd-aa28-ef9bc4015f81",
        "parentId" : "87f6b319-e683-4fd0-81f9-367768558cbb",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Added explanation. Correct.",
        "createdAt" : "2019-10-10T08:14:25Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,42 @@\n+package com.daml.ledger.participant.state.kvutils.committer\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlStateKey,\n+  DamlStateValue\n+}\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+\n+import scala.collection.mutable\n+\n+trait Context {"
  },
  {
    "id" : "2acf36d7-f7cf-4342-837e-ff1e50c9b4c4",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "65fd0db9-109f-4320-8435-ea4164376b29",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Don't you need to check whether the key has already been set or not? Otherwise, you'll list a key multiple times.",
        "createdAt" : "2019-10-09T15:47:44Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3e4a81b9-c5b0-4886-924a-620c3b24970b",
        "parentId" : "65fd0db9-109f-4320-8435-ea4164376b29",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Oops. Fixed.",
        "createdAt" : "2019-10-10T07:52:28Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,42 @@\n+package com.daml.ledger.participant.state.kvutils.committer\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlStateKey,\n+  DamlStateValue\n+}\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+\n+import scala.collection.mutable\n+\n+trait Context {\n+  def inputs: DamlStateMap\n+  // NOTE(JM): The outputs must be iterable in deterministic order, hence we\n+  // keep track of insertion order.\n+  private val outputOrder: mutable.ArrayBuffer[DamlStateKey] =\n+    mutable.ArrayBuffer()\n+\n+  private val outputs: mutable.Map[DamlStateKey, DamlStateValue] =\n+    mutable.HashMap.empty[DamlStateKey, DamlStateValue]\n+\n+  def getRecordTime: Timestamp\n+  def getParticipantId: ParticipantId\n+\n+  def getOutputs: Iterable[(DamlStateKey, DamlStateValue)] =\n+    outputOrder.map(k => k -> outputs(k))\n+\n+  /** Finish the commit, skipping the remaining steps. */\n+  def done[Void](logEntry: DamlLogEntry): Void\n+\n+  /** Retrieve value from state. */\n+  def get(key: DamlStateKey): Option[DamlStateValue] =\n+    outputs.get(key).orElse(inputs.get(key))\n+\n+  /** Set a value in state. */\n+  def set(key: DamlStateKey, value: DamlStateValue): Unit = {\n+    outputOrder += key"
  }
]