[
  {
    "id" : "f3759c16-930c-4214-a208-50abe40033c9",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "8208af3d-0f54-4fa0-a685-5d47eb22d309",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Not a big fan of using `getXyz` for non-getters. Perhaps `fetchLogEntry` or `retrieveLogEntry`.",
        "createdAt" : "2019-12-23T11:05:33Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a34b4536-d8cf-4806-bbbf-cae881e5c2fc",
        "parentId" : "8208af3d-0f54-4fa0-a685-5d47eb22d309",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Agreed -- changed to `retrieveLogEntry`.",
        "createdAt" : "2020-01-06T10:09:10Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState(\n+    log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+class InMemoryLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId)(implicit executionContext: ExecutionContext)\n+    extends LedgerWriter\n+    with LedgerReader {\n+\n+  private val engine = Engine()\n+\n+  private val currentState = InMemoryState()\n+\n+  private val StartOffset: Int = 0\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    Future {\n+      val submission = Envelope\n+        .openSubmission(envelope)\n+        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+      currentState.synchronized {\n+        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n+          submission.getInputDamlStateList.asScala\n+            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n+        val entryId = allocateEntryId\n+        val (logEntry, damlStateUpdates) =\n+          KeyValueCommitting.processSubmission(\n+            engine,\n+            entryId,\n+            currentRecordTime(),\n+            LedgerReader.DefaultTimeModel,\n+            submission,\n+            participantId,\n+            stateInputs\n+          )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(damlStateUpdates, entryId, submission)\n+        val stateUpdates = damlStateUpdates.toSeq.map {\n+          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+        }\n+        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n+        currentState.state ++= stateUpdates\n+        dispatcher.signalNewHead(currentState.log.size)\n+      }\n+      SubmissionResult.Acknowledged\n+    }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Int, List[LedgerRecord]](\n+          (index: Int, _) => index + 1,\n+          (index: Int) => Future.successful(List(getLogEntry(index)))\n+        )\n+      )\n+      .collect {\n+        case (_, updates) => updates\n+      }\n+      .mapConcat(identity)\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  private val dispatcher: Dispatcher[Int] =\n+    Dispatcher(\"in-memory-key-value-participant-state\", zeroIndex = 0, headAtInitialization = 0)\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  private val NamespaceLogEntries = ByteString.copyFromUtf8(\"L\")\n+\n+  private def allocateEntryId: DamlLogEntryId = {\n+    val nonce: Array[Byte] = Array.ofDim(8)\n+    randomNumberGenerator.nextBytes(nonce)\n+    DamlLogEntryId.newBuilder\n+      .setEntryId(NamespaceLogEntries.concat(ByteString.copyFrom(nonce)))\n+      .build\n+  }\n+\n+  private def currentRecordTime(): Timestamp =\n+    Timestamp.assertFromInstant(Clock.systemUTC().instant())\n+\n+  private def getLogEntry(index: Int): LedgerRecord = {"
  },
  {
    "id" : "2b11fa8d-1c6e-46b7-b3e1-c43dab6474a9",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "c48c67b5-0c5a-4f6a-9ba1-06579bd4b0d5",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "This has behavior; use parentheses please.",
        "createdAt" : "2019-12-23T11:10:07Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cfd523e4-4b84-493f-8a47-734bc3fa250b",
        "parentId" : "c48c67b5-0c5a-4f6a-9ba1-06579bd4b0d5",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Added.",
        "createdAt" : "2020-01-06T10:08:04Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState(\n+    log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+class InMemoryLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId)(implicit executionContext: ExecutionContext)\n+    extends LedgerWriter\n+    with LedgerReader {\n+\n+  private val engine = Engine()\n+\n+  private val currentState = InMemoryState()\n+\n+  private val StartOffset: Int = 0\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    Future {\n+      val submission = Envelope\n+        .openSubmission(envelope)\n+        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+      currentState.synchronized {\n+        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n+          submission.getInputDamlStateList.asScala\n+            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n+        val entryId = allocateEntryId\n+        val (logEntry, damlStateUpdates) =\n+          KeyValueCommitting.processSubmission(\n+            engine,\n+            entryId,\n+            currentRecordTime(),\n+            LedgerReader.DefaultTimeModel,\n+            submission,\n+            participantId,\n+            stateInputs\n+          )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(damlStateUpdates, entryId, submission)\n+        val stateUpdates = damlStateUpdates.toSeq.map {\n+          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+        }\n+        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n+        currentState.state ++= stateUpdates\n+        dispatcher.signalNewHead(currentState.log.size)\n+      }\n+      SubmissionResult.Acknowledged\n+    }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Int, List[LedgerRecord]](\n+          (index: Int, _) => index + 1,\n+          (index: Int) => Future.successful(List(getLogEntry(index)))\n+        )\n+      )\n+      .collect {\n+        case (_, updates) => updates\n+      }\n+      .mapConcat(identity)\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  private val dispatcher: Dispatcher[Int] =\n+    Dispatcher(\"in-memory-key-value-participant-state\", zeroIndex = 0, headAtInitialization = 0)\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  private val NamespaceLogEntries = ByteString.copyFromUtf8(\"L\")\n+\n+  private def allocateEntryId: DamlLogEntryId = {"
  },
  {
    "id" : "af9d1682-0aba-46c6-8108-0fab950bae55",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "2af2feed-49ee-4126-bdbe-0d466c82edd4",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Perhaps a custom Exception type here?",
        "createdAt" : "2019-12-23T11:22:55Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "83aa0e96-70e1-49df-8a55-dfd1e2bf154a",
        "parentId" : "2af2feed-49ee-4126-bdbe-0d466c82edd4",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Or perhaps use `assert` as that's what this is.\r\nEDIT: We should move the assertion into processSubmission?",
        "createdAt" : "2020-01-06T09:26:43Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8ea8fe41-8ac4-49ed-a13e-2cbedd77a2ce",
        "parentId" : "2af2feed-49ee-4126-bdbe-0d466c82edd4",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Yes, moving this into `KeyValueComitting.processSubmission` would be a great idea.",
        "createdAt" : "2020-01-06T10:05:33Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : 96,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState(\n+    log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+class InMemoryLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId)(implicit executionContext: ExecutionContext)\n+    extends LedgerWriter\n+    with LedgerReader {\n+\n+  private val engine = Engine()\n+\n+  private val currentState = InMemoryState()\n+\n+  private val StartOffset: Int = 0\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    Future {\n+      val submission = Envelope\n+        .openSubmission(envelope)\n+        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+      currentState.synchronized {\n+        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n+          submission.getInputDamlStateList.asScala\n+            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n+        val entryId = allocateEntryId\n+        val (logEntry, damlStateUpdates) =\n+          KeyValueCommitting.processSubmission(\n+            engine,\n+            entryId,\n+            currentRecordTime(),\n+            LedgerReader.DefaultTimeModel,\n+            submission,\n+            participantId,\n+            stateInputs\n+          )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(damlStateUpdates, entryId, submission)\n+        val stateUpdates = damlStateUpdates.toSeq.map {\n+          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+        }\n+        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n+        currentState.state ++= stateUpdates\n+        dispatcher.signalNewHead(currentState.log.size)\n+      }\n+      SubmissionResult.Acknowledged\n+    }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error("
  },
  {
    "id" : "440f2597-a2dc-4891-8691-f3932f880374",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "77702f40-4505-4c6e-bc0e-c771160d7b1d",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "This could just be `.mapConcat { case (_, updates) => updates }`.",
        "createdAt" : "2019-12-23T13:11:23Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "371bbfcc-e799-45ca-a159-95492a32ff50",
        "parentId" : "77702f40-4505-4c6e-bc0e-c771160d7b1d",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Changed.",
        "createdAt" : "2020-01-06T10:38:13Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "84829b26-e8d9-4822-b602-c5170e4743bb",
        "parentId" : "77702f40-4505-4c6e-bc0e-c771160d7b1d",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "@SamirTalwar's suggestion wasn't working?",
        "createdAt" : "2020-01-06T16:49:36Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "25ad64be-e593-4ba9-9498-7470641429f1",
        "parentId" : "77702f40-4505-4c6e-bc0e-c771160d7b1d",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "It worked, of course :)",
        "createdAt" : "2020-01-06T17:53:25Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState(\n+    log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+class InMemoryLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId)(implicit executionContext: ExecutionContext)\n+    extends LedgerWriter\n+    with LedgerReader {\n+\n+  private val engine = Engine()\n+\n+  private val currentState = InMemoryState()\n+\n+  private val StartOffset: Int = 0\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    Future {\n+      val submission = Envelope\n+        .openSubmission(envelope)\n+        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+      currentState.synchronized {\n+        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n+          submission.getInputDamlStateList.asScala\n+            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n+        val entryId = allocateEntryId\n+        val (logEntry, damlStateUpdates) =\n+          KeyValueCommitting.processSubmission(\n+            engine,\n+            entryId,\n+            currentRecordTime(),\n+            LedgerReader.DefaultTimeModel,\n+            submission,\n+            participantId,\n+            stateInputs\n+          )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(damlStateUpdates, entryId, submission)\n+        val stateUpdates = damlStateUpdates.toSeq.map {\n+          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+        }\n+        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n+        currentState.state ++= stateUpdates\n+        dispatcher.signalNewHead(currentState.log.size)\n+      }\n+      SubmissionResult.Acknowledged\n+    }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Int, List[LedgerRecord]](\n+          (index: Int, _) => index + 1,\n+          (index: Int) => Future.successful(List(getLogEntry(index)))\n+        )\n+      )\n+      .collect {\n+        case (_, updates) => updates\n+      }\n+      .mapConcat(identity)"
  },
  {
    "id" : "43bf540a-0fe0-4dbf-9e3c-190271c92083",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "55c28138-ca77-471d-9fa4-fb41b941e84c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "case classes with mutable fields are problematic. Probably `InMemoryState` doesn't need to be a case class.",
        "createdAt" : "2020-01-06T13:19:16Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ea1cd65-1398-4399-9193-f77456b8c9b6",
        "parentId" : "55c28138-ca77-471d-9fa4-fb41b941e84c",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Removed this anti-pattern.",
        "createdAt" : "2020-01-06T16:20:15Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState("
  },
  {
    "id" : "415dc658-d131-4a69-9339-15099eed1284",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "d07c4045-134f-4146-b6f7-6636d8233f48",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Since no \"filtering\" is happening in this `collect`, you can call `mapConcat` directly.",
        "createdAt" : "2020-01-06T13:23:44Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6c62ab44-2812-4e53-9e3d-7d2a5e9cf458",
        "parentId" : "d07c4045-134f-4146-b6f7-6636d8233f48",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Changed.",
        "createdAt" : "2020-01-06T16:18:46Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState(\n+    log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+class InMemoryLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId)(implicit executionContext: ExecutionContext)\n+    extends LedgerWriter\n+    with LedgerReader {\n+\n+  private val engine = Engine()\n+\n+  private val currentState = InMemoryState()\n+\n+  private val StartOffset: Int = 0\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    Future {\n+      val submission = Envelope\n+        .openSubmission(envelope)\n+        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+      currentState.synchronized {\n+        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n+          submission.getInputDamlStateList.asScala\n+            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n+        val entryId = allocateEntryId\n+        val (logEntry, damlStateUpdates) =\n+          KeyValueCommitting.processSubmission(\n+            engine,\n+            entryId,\n+            currentRecordTime(),\n+            LedgerReader.DefaultTimeModel,\n+            submission,\n+            participantId,\n+            stateInputs\n+          )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(damlStateUpdates, entryId, submission)\n+        val stateUpdates = damlStateUpdates.toSeq.map {\n+          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+        }\n+        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n+        currentState.state ++= stateUpdates\n+        dispatcher.signalNewHead(currentState.log.size)\n+      }\n+      SubmissionResult.Acknowledged\n+    }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Int, List[LedgerRecord]](\n+          (index: Int, _) => index + 1,\n+          (index: Int) => Future.successful(List(getLogEntry(index)))\n+        )\n+      )\n+      .collect {"
  },
  {
    "id" : "8ce37ecd-11f9-47ee-9a18-dc2acf31ca03",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "b29e3dd8-6bbc-4ffe-a3b8-f075b3779817",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Please note that the above warning points out that having arrays in case classes could lead to unpleasant head-scratching situations, as in the following snippet:\r\n```\r\nscala> final case class Foo(array: Array[Int])\r\ndefined class Foo\r\n\r\nscala> Foo(Array(1)) == Foo(Array(1))\r\nres8: Boolean = false\r\n```\r\n\r\nYou can solve this issue (and remove the warning) by using an `IndexedSeq` as an interface:\r\n\r\n```\r\nscala> final case class Foo(array: IndexedSeq[Int])\r\ndefined class Foo\r\n\r\nscala> Foo(Array(1)) == Foo(Array(1))\r\nres9: Boolean = true\r\n```\r\n\r\nIf you really want an array here and you don't care about having referential equality, consider not using `case class`es in the first place (which would allow you again to remove the warning).",
        "createdAt" : "2020-01-06T16:38:16Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "50de219a-e896-4b10-935d-914920aaa4ca",
        "parentId" : "b29e3dd8-6bbc-4ffe-a3b8-f075b3779817",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Thanks for that suggestion. `LogEntry` is no longer a case class.",
        "createdAt" : "2020-01-07T13:54:23Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])"
  },
  {
    "id" : "8b372982-84ea-41ce-b728-7f0727011b75",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "c82e2d97-7536-48cf-a716-dc3c466573d9",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Do we really need to have this as a `case class`? Judging from the mutable state a regular class could suffice.",
        "createdAt" : "2020-01-06T16:39:31Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6a11249c-df90-45f1-b3c7-88b9f344f8e0",
        "parentId" : "c82e2d97-7536-48cf-a716-dc3c466573d9",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "This is no longer a case class.",
        "createdAt" : "2020-01-07T13:53:38Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState("
  },
  {
    "id" : "454538f0-befd-47a0-9c57-94376ac70d24",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "a69fc8ad-ee92-4bd4-85b4-7e0edb571914",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "In general I always suggest to default to `final` classes unless you're designing a class to be extended. It clarifies the fact that the class is not designed to be extended and it allows the compiler to perform some inlining.",
        "createdAt" : "2020-01-06T16:41:16Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "70a974e4-7cba-4aa0-869e-294af03bbbb4",
        "parentId" : "a69fc8ad-ee92-4bd4-85b4-7e0edb571914",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Made it final.",
        "createdAt" : "2020-01-07T13:53:23Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState(\n+    log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+class InMemoryLedgerReaderWriter("
  },
  {
    "id" : "be9c75e1-5471-48df-8a13-697539fee32c",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "ceb5cde0-9bae-4545-8958-4138d8de2497",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "You can avoid doing a double pass on the collection by using `view` here and then calling `toSeq` after the `map`.",
        "createdAt" : "2020-01-06T16:43:24Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e60d0f83-b5f2-4030-b55f-97a805235a3e",
        "parentId" : "ceb5cde0-9bae-4545-8958-4138d8de2497",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I would also recommend using a more concrete implementation of `Seq` as a target collection based on how you expect this data to be accessed (by default on Scala 2.12.10 the target collection seems to be a `Stream` in this case).",
        "createdAt" : "2020-01-06T16:46:54Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a4e2c438-9156-4f58-9184-9ea1827a016b",
        "parentId" : "ceb5cde0-9bae-4545-8958-4138d8de2497",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Those are good points. That `.toSeq` was completely unnecessary -- removed.",
        "createdAt" : "2020-01-06T17:52:28Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,139 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.ArrayEquals\"))\n+private[impl] case class LogEntry(entryId: DamlLogEntryId, payload: Array[Byte])\n+\n+private[impl] case class InMemoryState(\n+    log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+class InMemoryLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId)(implicit executionContext: ExecutionContext)\n+    extends LedgerWriter\n+    with LedgerReader {\n+\n+  private val engine = Engine()\n+\n+  private val currentState = InMemoryState()\n+\n+  private val StartOffset: Int = 0\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    Future {\n+      val submission = Envelope\n+        .openSubmission(envelope)\n+        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+      currentState.synchronized {\n+        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n+          submission.getInputDamlStateList.asScala\n+            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n+        val entryId = allocateEntryId\n+        val (logEntry, damlStateUpdates) =\n+          KeyValueCommitting.processSubmission(\n+            engine,\n+            entryId,\n+            currentRecordTime(),\n+            LedgerReader.DefaultTimeModel,\n+            submission,\n+            participantId,\n+            stateInputs\n+          )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(damlStateUpdates, entryId, submission)\n+        val stateUpdates = damlStateUpdates.toSeq.map {"
  },
  {
    "id" : "d67886d6-4b29-476e-b6c7-b5e09fbe9320",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "4332431b-4da0-40d7-b99d-c427dd7f40c0",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "We should probably undo this mistake of mine and use a better entry id allocation schema for the in-memory ledgers. e.g. use monotonically increasing integer. Medium term we'll do away with the entry id though (removal of relative ids), so this isn't a big deal right now.",
        "createdAt" : "2020-01-08T17:07:11Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "29955ccb-df1d-474c-bec8-6d27b47cb43a",
        "parentId" : "4332431b-4da0-40d7-b99d-c427dd7f40c0",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Good point -- will address that in a separate PR.",
        "createdAt" : "2020-01-08T17:29:14Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : 128,
    "diffHunk" : "@@ -0,0 +1,142 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api.impl\n+\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.OneAfterAnother\n+\n+import scala.collection.JavaConverters._\n+import scala.collection.{breakOut, mutable}\n+import scala.collection.mutable.ArrayBuffer\n+import scala.concurrent.{ExecutionContext, Future}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Random\n+\n+private[impl] class LogEntry(val entryId: DamlLogEntryId, val payload: Array[Byte])\n+\n+private[impl] object LogEntry {\n+  def apply(entryId: DamlLogEntryId, payload: Array[Byte]): LogEntry =\n+    new LogEntry(entryId, payload)\n+}\n+\n+private[impl] class InMemoryState(\n+    val log: mutable.Buffer[LogEntry] = ArrayBuffer[LogEntry](),\n+    val state: mutable.Map[ByteString, DamlStateValue] = mutable.Map.empty)\n+\n+final class InMemoryLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId)(implicit executionContext: ExecutionContext)\n+    extends LedgerWriter\n+    with LedgerReader {\n+\n+  private val engine = Engine()\n+\n+  private val currentState = new InMemoryState()\n+\n+  private val StartOffset: Int = 0\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    Future {\n+      val submission = Envelope\n+        .openSubmission(envelope)\n+        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+      currentState.synchronized {\n+        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n+          submission.getInputDamlStateList.asScala\n+            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n+        val entryId = allocateEntryId()\n+        val (logEntry, damlStateUpdates) =\n+          KeyValueCommitting.processSubmission(\n+            engine,\n+            entryId,\n+            currentRecordTime(),\n+            LedgerReader.DefaultTimeModel,\n+            submission,\n+            participantId,\n+            stateInputs\n+          )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(damlStateUpdates, entryId, submission)\n+        val stateUpdates = damlStateUpdates.map {\n+          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+        }\n+        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n+        currentState.state ++= stateUpdates\n+        dispatcher.signalNewHead(currentState.log.size)\n+      }\n+      SubmissionResult.Acknowledged\n+    }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartOffset),\n+        OneAfterAnother[Int, List[LedgerRecord]](\n+          (index: Int, _) => index + 1,\n+          (index: Int) => Future.successful(List(retrieveLogEntry(index)))\n+        )\n+      )\n+      .mapConcat { case (_, updates) => updates }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def currentHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = ()\n+\n+  private val dispatcher: Dispatcher[Int] =\n+    Dispatcher(\"in-memory-key-value-participant-state\", zeroIndex = 0, headAtInitialization = 0)\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  private val NamespaceLogEntries = ByteString.copyFromUtf8(\"L\")\n+\n+  private def allocateEntryId(): DamlLogEntryId = {\n+    val nonce: Array[Byte] = Array.ofDim(8)"
  }
]