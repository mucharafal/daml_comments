[
  {
    "id" : "df345e4a-b690-439b-8826-73b2478a9d07",
    "prId" : 3806,
    "comments" : [
      {
        "id" : "e710a90a-330e-4258-8967-8226fdb3ab6f",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Minor, but the commenting here looks a bit wonky.",
        "createdAt" : "2019-12-12T16:15:03Z",
        "updatedAt" : "2019-12-12T17:11:45Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "251fd5fc053893266c997d1d7451a1f25479df7b",
    "line" : 97,
    "diffHunk" : "@@ -454,21 +396,29 @@ class InMemoryKVParticipantState(\n   private def generateRandomParty(): Ref.Party =\n     Ref.Party.assertFromString(s\"party-${UUID.randomUUID().toString.take(8)}\")\n \n+  /*"
  },
  {
    "id" : "2992e7a8-fb80-4e15-b508-a8cec49037a4",
    "prId" : 3744,
    "comments" : [
      {
        "id" : "56677747-7e3f-48d2-b32e-b61c6a26a393",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Perhaps wrap earlier.",
        "createdAt" : "2019-12-05T10:53:17Z",
        "updatedAt" : "2019-12-05T15:56:33Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "05a96558-2914-4eaa-bbb9-a822e061b8f4",
        "parentId" : "56677747-7e3f-48d2-b32e-b61c6a26a393",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'll leave that for @dajmaki to judge.",
        "createdAt" : "2019-12-05T11:05:15Z",
        "updatedAt" : "2019-12-05T15:56:33Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d8204b7c377ce994002fb11ce1227c245747b3d0",
    "line" : 66,
    "diffHunk" : "@@ -345,8 +328,8 @@ class InMemoryKVParticipantState(\n       zeroIndex = beginning,\n       headAtInitialization = beginning)\n \n-  /** Helper for [[dispatcher]] to fetch [[DamlLogEntry]] from the\n-    * state and convert it into [[Update]].\n+  /** Helper for [[dispatcher]] to fetch [[com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlLogEntry]] from the\n+    * state and convert it into [[com.daml.ledger.participant.state.v1.Update]]."
  },
  {
    "id" : "76e86c69-9f42-4a3a-8828-be76bc75c4b8",
    "prId" : 3417,
    "comments" : [
      {
        "id" : "02a9cad6-3399-4d3b-b266-9c4437c7fe98",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "`()` many times serves as a useful reminder that the method performs side effects. If you don't have a strong opinion about it I would prefer to keep it.",
        "createdAt" : "2019-11-11T15:40:15Z",
        "updatedAt" : "2019-11-11T20:55:34Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f5207178-8f5d-41ef-9350-1a4e0215d663",
        "parentId" : "02a9cad6-3399-4d3b-b266-9c4437c7fe98",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Seconded; if nothing else, it tells you can't easily inline the result. It's not exactly `IO[Timestamp]` but it's something.",
        "createdAt" : "2019-11-11T15:54:23Z",
        "updatedAt" : "2019-11-11T17:19:08Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "516f0373-485f-4c74-a49b-accdb64b5a1e",
        "parentId" : "02a9cad6-3399-4d3b-b266-9c4437c7fe98",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Perhaps rename it to simply `newRecordTime` to stop IntelliJ complaining?",
        "createdAt" : "2019-11-11T15:54:46Z",
        "updatedAt" : "2019-11-11T17:19:08Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f76f496a9acb7aa099941cafa8af15182d2da731",
    "line" : null,
    "diffHunk" : "@@ -553,7 +553,7 @@ class InMemoryKVParticipantState(\n   /** Get a new record time for the ledger from the system clock.\n     * Public for use from integration tests.\n     */\n-  def getNewRecordTime(): Timestamp =\n+  def getNewRecordTime: Timestamp ="
  },
  {
    "id" : "48b60684-cb6d-4904-bdaa-4da85e6708a8",
    "prId" : 1553,
    "comments" : [
      {
        "id" : "226bd2d1-7913-432b-a158-269bc4b2d3dd",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "I'd be interested in seeing how the Sawtooth implementation of this logic ends up looking like and whether we can abstract it out and use it for other implementations as well.",
        "createdAt" : "2019-06-28T12:53:09Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b89ec3eec97b94cea04cfd27c4bf94180ecef4ca",
    "line" : 51,
    "diffHunk" : "@@ -125,6 +139,62 @@ class InMemoryKVParticipantState(implicit system: ActorSystem, mat: Materializer\n       )\n     )\n \n+  /** Akka actor that matches the requests for party allocation\n+    * with asynchronous responses delivered within the log entries.\n+    */\n+  class ResponseMatcher extends Actor {"
  },
  {
    "id" : "8f13579a-ac94-43ad-8fca-0da8dacb6ffc",
    "prId" : 637,
    "comments" : [
      {
        "id" : "7259214a-d118-4bea-a780-9ce9d87f20a1",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : " This comment is quite difficult to understand.\r\n\r\nExplain somewhere the difference betwenn submission and commit.",
        "createdAt" : "2019-04-26T12:54:08Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state."
  },
  {
    "id" : "7b5ca29e-e2a3-49ee-a875-42545d800a7c",
    "prId" : 637,
    "comments" : [
      {
        "id" : "0d121a0f-2d9a-4bf9-8549-f02c9eeb433c",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "participant-state ReadService and WriteService interfaces",
        "createdAt" : "2019-04-26T12:54:46Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */"
  },
  {
    "id" : "dcf3aac1-d5cd-4ba7-b130-68b4702de38e",
    "prId" : 637,
    "comments" : [
      {
        "id" : "617c77b7-db25-471a-b240-19171f0ff4aa",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Add comment on why we have log-entry ids associated to the `DamlSubmission`",
        "createdAt" : "2019-04-26T12:55:41Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],"
  },
  {
    "id" : "d22e432a-2ce9-4024-b82c-939431c62ec1",
    "prId" : 637,
    "comments" : [
      {
        "id" : "ba5b1f23-d672-44be-81b0-90773a3b467c",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Add comment explaining that both DamlLogentryId entries and DamlStateKey entries are stored in this map.",
        "createdAt" : "2019-04-26T12:56:18Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 46,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],"
  },
  {
    "id" : "c4403390-b65f-4dbe-b745-079df97c4759",
    "prId" : 637,
    "comments" : [
      {
        "id" : "a08808ca-0e85-47e0-8cd0-887bd68d51e7",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Who/what is the `CommitActor`?",
        "createdAt" : "2019-04-26T12:56:43Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "450eb9b0-ec91-4cef-aa4e-65888168ac41",
        "parentId" : "a08808ca-0e85-47e0-8cd0-887bd68d51e7",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "What immutable state are we talking about?",
        "createdAt" : "2019-04-26T12:56:55Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor."
  },
  {
    "id" : "67b65a7e-263d-49e9-bce3-d153e02bb459",
    "prId" : 637,
    "comments" : [
      {
        "id" : "87c793c0-9dc0-48f9-b645-aa250057482e",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "add warning log message here",
        "createdAt" : "2019-04-26T12:58:43Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 139,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission."
  },
  {
    "id" : "dfa7dacc-3665-4af9-aca6-45b7241a6055",
    "prId" : 637,
    "comments" : [
      {
        "id" : "5a4adad0-82ca-484a-9706-ff8cc323a2a3",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "add appropriate debug log messages that allow tracing how validation etc. progresses",
        "createdAt" : "2019-04-26T13:00:11Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 144,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission.\n+        } else {\n+          // Process the submission to produce the log entry and the state updates."
  },
  {
    "id" : "982d70f2-578e-4dbb-a6a3-f6aeaf7f86a8",
    "prId" : 637,
    "comments" : [
      {
        "id" : "14ac7fa9-dc3a-4f62-97d2-a16645cd005f",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "The way this is written it seems to me that we MUST re-validate the read input values on the update here! Otherwise, we are racy!",
        "createdAt" : "2019-04-26T13:01:33Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fcbcb5de-cb1b-4ee6-9e22-4ae8b790fbad",
        "parentId" : "14ac7fa9-dc3a-4f62-97d2-a16645cd005f",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Or explain why we are not in case the actor guards us. I don't understand the 'atomically' in that case though? Is it wrt readers only seeing properly updated state?",
        "createdAt" : "2019-04-26T13:02:26Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d2480e9d-51a7-4507-8c0b-20660c173e08",
        "parentId" : "14ac7fa9-dc3a-4f62-97d2-a16645cd005f",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "The actor processes the messages completely sequentially and this line is the only place where the state is swapped.\r\natomically refers to the fact that we swap the reference to a new copy of the state. I'll definitely add some more comments about what's the idea here. Definitely not entirely happy about the construction. Could wrap stateRef into AtomicReference and do a compare and swap to switch it, but it seems rather pointless with one writer.",
        "createdAt" : "2019-04-26T14:25:55Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 169,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission.\n+        } else {\n+          // Process the submission to produce the log entry and the state updates.\n+          val (logEntry, damlStateUpdates) = KeyValueCommitting.processSubmission(\n+            engine,\n+            state.config,\n+            entryId,\n+            state.recordTime,\n+            submission,\n+            submission.getInputLogEntriesList.asScala\n+              .map(eid => eid -> getLogEntry(state, eid))(breakOut),\n+            submission.getInputDamlStateList.asScala\n+              .map(key => key -> getDamlState(state, key))(breakOut)\n+          )\n+\n+          // Combine the abstract log entry and the state updates into concrete updates to the store.\n+          val allUpdates =\n+            damlStateUpdates.map {\n+              case (k, v) =>\n+                NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(k)) ->\n+                  KeyValueCommitting.packDamlStateValue(v)\n+            } + (entryId.getEntryId -> KeyValueCommitting.packDamlLogEntry(logEntry))\n+\n+          // Atomically update the state reference, recording the commit\n+          // and the updated state.\n+          stateRef = state.copy("
  },
  {
    "id" : "16e39340-74d6-4c2e-b57c-6345f6607d95",
    "prId" : 637,
    "comments" : [
      {
        "id" : "9fd5196d-ed88-4fa7-baf0-bd56e193b31b",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "It seems that somewhere we need a bit of explanation (or pointers to Akka docs) that explain how and why this ledger works under concurrent submissions.",
        "createdAt" : "2019-04-26T13:03:20Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "940a4136-f597-487d-b86b-f25d17859c64",
        "parentId" : "9fd5196d-ed88-4fa7-baf0-bd56e193b31b",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Agreed. I'll add links and comment what's going on.",
        "createdAt" : "2019-04-26T14:27:16Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission.\n+        } else {\n+          // Process the submission to produce the log entry and the state updates.\n+          val (logEntry, damlStateUpdates) = KeyValueCommitting.processSubmission(\n+            engine,\n+            state.config,\n+            entryId,\n+            state.recordTime,\n+            submission,\n+            submission.getInputLogEntriesList.asScala\n+              .map(eid => eid -> getLogEntry(state, eid))(breakOut),\n+            submission.getInputDamlStateList.asScala\n+              .map(key => key -> getDamlState(state, key))(breakOut)\n+          )\n+\n+          // Combine the abstract log entry and the state updates into concrete updates to the store.\n+          val allUpdates =\n+            damlStateUpdates.map {\n+              case (k, v) =>\n+                NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(k)) ->\n+                  KeyValueCommitting.packDamlStateValue(v)\n+            } + (entryId.getEntryId -> KeyValueCommitting.packDamlLogEntry(logEntry))\n+\n+          // Atomically update the state reference, recording the commit\n+          // and the updated state.\n+          stateRef = state.copy(\n+            log = state.log :+ (entryId -> submission),\n+            store = state.store ++ allUpdates\n+          )\n+\n+          // Wake up consumers.\n+          dispatcher.signalNewHead(stateRef.log.size)\n+        }\n+    }\n+  }\n+  private val commitActorRef =\n+    system.actorOf(Props(new CommitActor), s\"commit-actor-${ledgerId.underlyingString}\")\n+\n+  // Dispatcher to subscribe to 'Update' events derived from the state."
  },
  {
    "id" : "b2f3e765-e5e4-42d4-8b10-0477afa862f3",
    "prId" : 637,
    "comments" : [
      {
        "id" : "43b8acd0-0715-4778-a97f-7e168afd2c97",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "where does this `startingAt` come from? Do we buffer all states?",
        "createdAt" : "2019-04-26T13:04:41Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "836c4008-5547-4ff1-b8fd-76fe33cb0d55",
        "parentId" : "43b8acd0-0715-4778-a97f-7e168afd2c97",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "It's all part of dispatcher. We don't buffer anything. Dispatcher is what is used in sandbox (both in-memory and sql backend, platform used to use it as well) so this is quite well tested code and I ended up being convinced that it's better to re-use it than to implement it from scratch. Debatable whether it's good to use it in an example.\r\n\r\nhttps://github.com/digital-asset/daml/blob/master/ledger/ledger-api-common/src/main/scala/com/digitalasset/platform/akkastreams/Dispatcher.scala",
        "createdAt" : "2019-04-26T14:30:18Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission.\n+        } else {\n+          // Process the submission to produce the log entry and the state updates.\n+          val (logEntry, damlStateUpdates) = KeyValueCommitting.processSubmission(\n+            engine,\n+            state.config,\n+            entryId,\n+            state.recordTime,\n+            submission,\n+            submission.getInputLogEntriesList.asScala\n+              .map(eid => eid -> getLogEntry(state, eid))(breakOut),\n+            submission.getInputDamlStateList.asScala\n+              .map(key => key -> getDamlState(state, key))(breakOut)\n+          )\n+\n+          // Combine the abstract log entry and the state updates into concrete updates to the store.\n+          val allUpdates =\n+            damlStateUpdates.map {\n+              case (k, v) =>\n+                NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(k)) ->\n+                  KeyValueCommitting.packDamlStateValue(v)\n+            } + (entryId.getEntryId -> KeyValueCommitting.packDamlLogEntry(logEntry))\n+\n+          // Atomically update the state reference, recording the commit\n+          // and the updated state.\n+          stateRef = state.copy(\n+            log = state.log :+ (entryId -> submission),\n+            store = state.store ++ allUpdates\n+          )\n+\n+          // Wake up consumers.\n+          dispatcher.signalNewHead(stateRef.log.size)\n+        }\n+    }\n+  }\n+  private val commitActorRef =\n+    system.actorOf(Props(new CommitActor), s\"commit-actor-${ledgerId.underlyingString}\")\n+\n+  // Dispatcher to subscribe to 'Update' events derived from the state.\n+  private val beginning: Int = 0\n+  private val dispatcher: Dispatcher[Int, Update] = Dispatcher(\n+    steppingMode = OneAfterAnother(\n+      (idx: Int, _) => idx + 1,\n+      (idx: Int) => Future.successful(getUpdate(idx, stateRef))\n+    ),\n+    zeroIndex = beginning,\n+    headAtInitialization = beginning\n+  )\n+\n+  private def getUpdate(idx: Int, state: State): Update = {\n+    if (idx < 0 || idx >= state.log.size)\n+      sys.error(s\"getUpdate: $idx out of bounds (${state.log.size})\")\n+\n+    // Resolve the \"height\" to log entry.\n+    val entryId = state.log(idx)._1\n+\n+    state.store\n+      .get(entryId.getEntryId)\n+      .map { blob =>\n+        KeyValueConsumption.logEntryToUpdate(entryId, KeyValueConsumption.unpackDamlLogEntry(blob))\n+      }\n+      .getOrElse(\n+        sys.error(s\"getUpdate: $entryId not found from store!\")\n+      )\n+  }\n+\n+  override def stateUpdates(beginAfter: Option[Offset]): Source[(Offset, Update), NotUsed] = {\n+    dispatcher\n+      .startingAt(beginAfter.map(_.components.head.toInt + 1).getOrElse(beginning))"
  },
  {
    "id" : "269c8bf6-7e51-46cf-aded-91f1e2e7eaf7",
    "prId" : 637,
    "comments" : [
      {
        "id" : "fe38b692-eaa1-4fa7-9b1a-4f5606805f40",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "extend comments on what's happening -- I'm assuming this should be the example that explains how to implement the participant-state interfaces using the kvutils.",
        "createdAt" : "2019-04-26T13:05:50Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 291,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission.\n+        } else {\n+          // Process the submission to produce the log entry and the state updates.\n+          val (logEntry, damlStateUpdates) = KeyValueCommitting.processSubmission(\n+            engine,\n+            state.config,\n+            entryId,\n+            state.recordTime,\n+            submission,\n+            submission.getInputLogEntriesList.asScala\n+              .map(eid => eid -> getLogEntry(state, eid))(breakOut),\n+            submission.getInputDamlStateList.asScala\n+              .map(key => key -> getDamlState(state, key))(breakOut)\n+          )\n+\n+          // Combine the abstract log entry and the state updates into concrete updates to the store.\n+          val allUpdates =\n+            damlStateUpdates.map {\n+              case (k, v) =>\n+                NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(k)) ->\n+                  KeyValueCommitting.packDamlStateValue(v)\n+            } + (entryId.getEntryId -> KeyValueCommitting.packDamlLogEntry(logEntry))\n+\n+          // Atomically update the state reference, recording the commit\n+          // and the updated state.\n+          stateRef = state.copy(\n+            log = state.log :+ (entryId -> submission),\n+            store = state.store ++ allUpdates\n+          )\n+\n+          // Wake up consumers.\n+          dispatcher.signalNewHead(stateRef.log.size)\n+        }\n+    }\n+  }\n+  private val commitActorRef =\n+    system.actorOf(Props(new CommitActor), s\"commit-actor-${ledgerId.underlyingString}\")\n+\n+  // Dispatcher to subscribe to 'Update' events derived from the state.\n+  private val beginning: Int = 0\n+  private val dispatcher: Dispatcher[Int, Update] = Dispatcher(\n+    steppingMode = OneAfterAnother(\n+      (idx: Int, _) => idx + 1,\n+      (idx: Int) => Future.successful(getUpdate(idx, stateRef))\n+    ),\n+    zeroIndex = beginning,\n+    headAtInitialization = beginning\n+  )\n+\n+  private def getUpdate(idx: Int, state: State): Update = {\n+    if (idx < 0 || idx >= state.log.size)\n+      sys.error(s\"getUpdate: $idx out of bounds (${state.log.size})\")\n+\n+    // Resolve the \"height\" to log entry.\n+    val entryId = state.log(idx)._1\n+\n+    state.store\n+      .get(entryId.getEntryId)\n+      .map { blob =>\n+        KeyValueConsumption.logEntryToUpdate(entryId, KeyValueConsumption.unpackDamlLogEntry(blob))\n+      }\n+      .getOrElse(\n+        sys.error(s\"getUpdate: $entryId not found from store!\")\n+      )\n+  }\n+\n+  override def stateUpdates(beginAfter: Option[Offset]): Source[(Offset, Update), NotUsed] = {\n+    dispatcher\n+      .startingAt(beginAfter.map(_.components.head.toInt + 1).getOrElse(beginning))\n+      .map {\n+        case (idx, update) =>\n+          Offset(Array(idx.toLong)) -> update\n+      }\n+  }\n+\n+  private def getLogEntry(state: State, entryId: DamlLogEntryId): DamlLogEntry =\n+    DamlLogEntry.parseFrom(state.store(entryId.getEntryId))\n+\n+  private def getDamlState(state: State, key: DamlStateKey): Option[DamlStateValue] =\n+    state.store\n+      .get(NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(key)))\n+      .map(DamlStateValue.parseFrom)\n+\n+  override def submitTransaction(\n+      submitterInfo: SubmitterInfo,\n+      transactionMeta: TransactionMeta,\n+      transaction: SubmittedTransaction): Unit = {\n+"
  },
  {
    "id" : "15a614ec-171a-4839-8cff-f43e3c8799b6",
    "prId" : 637,
    "comments" : [
      {
        "id" : "7548f821-c6e7-4fca-8c87-a4111bea7f9c",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Explain why we need the backchannel",
        "createdAt" : "2019-04-26T13:06:11Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9302f6f2-a603-41a2-b4c7-a2dd235f58a2",
        "parentId" : "7548f821-c6e7-4fca-8c87-a4111bea7f9c",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Also link to #347 ",
        "createdAt" : "2019-04-26T13:07:09Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission.\n+        } else {\n+          // Process the submission to produce the log entry and the state updates.\n+          val (logEntry, damlStateUpdates) = KeyValueCommitting.processSubmission(\n+            engine,\n+            state.config,\n+            entryId,\n+            state.recordTime,\n+            submission,\n+            submission.getInputLogEntriesList.asScala\n+              .map(eid => eid -> getLogEntry(state, eid))(breakOut),\n+            submission.getInputDamlStateList.asScala\n+              .map(key => key -> getDamlState(state, key))(breakOut)\n+          )\n+\n+          // Combine the abstract log entry and the state updates into concrete updates to the store.\n+          val allUpdates =\n+            damlStateUpdates.map {\n+              case (k, v) =>\n+                NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(k)) ->\n+                  KeyValueCommitting.packDamlStateValue(v)\n+            } + (entryId.getEntryId -> KeyValueCommitting.packDamlLogEntry(logEntry))\n+\n+          // Atomically update the state reference, recording the commit\n+          // and the updated state.\n+          stateRef = state.copy(\n+            log = state.log :+ (entryId -> submission),\n+            store = state.store ++ allUpdates\n+          )\n+\n+          // Wake up consumers.\n+          dispatcher.signalNewHead(stateRef.log.size)\n+        }\n+    }\n+  }\n+  private val commitActorRef =\n+    system.actorOf(Props(new CommitActor), s\"commit-actor-${ledgerId.underlyingString}\")\n+\n+  // Dispatcher to subscribe to 'Update' events derived from the state.\n+  private val beginning: Int = 0\n+  private val dispatcher: Dispatcher[Int, Update] = Dispatcher(\n+    steppingMode = OneAfterAnother(\n+      (idx: Int, _) => idx + 1,\n+      (idx: Int) => Future.successful(getUpdate(idx, stateRef))\n+    ),\n+    zeroIndex = beginning,\n+    headAtInitialization = beginning\n+  )\n+\n+  private def getUpdate(idx: Int, state: State): Update = {\n+    if (idx < 0 || idx >= state.log.size)\n+      sys.error(s\"getUpdate: $idx out of bounds (${state.log.size})\")\n+\n+    // Resolve the \"height\" to log entry.\n+    val entryId = state.log(idx)._1\n+\n+    state.store\n+      .get(entryId.getEntryId)\n+      .map { blob =>\n+        KeyValueConsumption.logEntryToUpdate(entryId, KeyValueConsumption.unpackDamlLogEntry(blob))\n+      }\n+      .getOrElse(\n+        sys.error(s\"getUpdate: $entryId not found from store!\")\n+      )\n+  }\n+\n+  override def stateUpdates(beginAfter: Option[Offset]): Source[(Offset, Update), NotUsed] = {\n+    dispatcher\n+      .startingAt(beginAfter.map(_.components.head.toInt + 1).getOrElse(beginning))\n+      .map {\n+        case (idx, update) =>\n+          Offset(Array(idx.toLong)) -> update\n+      }\n+  }\n+\n+  private def getLogEntry(state: State, entryId: DamlLogEntryId): DamlLogEntry =\n+    DamlLogEntry.parseFrom(state.store(entryId.getEntryId))\n+\n+  private def getDamlState(state: State, key: DamlStateKey): Option[DamlStateValue] =\n+    state.store\n+      .get(NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(key)))\n+      .map(DamlStateValue.parseFrom)\n+\n+  override def submitTransaction(\n+      submitterInfo: SubmitterInfo,\n+      transactionMeta: TransactionMeta,\n+      transaction: SubmittedTransaction): Unit = {\n+\n+    val submission =\n+      KeyValueSubmission.transactionToSubmission(submitterInfo, transactionMeta, transaction)\n+\n+    // Submit the transaction to the committer.\n+    commitActorRef ! CommitMessage(\n+      allocateEntryId,\n+      submission\n+    )\n+  }\n+\n+  // Back-channel for uploading DAML-LF archives."
  },
  {
    "id" : "8a898ea5-c179-46a5-81fd-1f4e7c311f7c",
    "prId" : 637,
    "comments" : [
      {
        "id" : "bc3818c2-2178-45af-8d0d-20c1b93d0ee5",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "why 'epoch' and not just initial ledger record time?",
        "createdAt" : "2019-04-26T13:07:30Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,216 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.actor.{Actor, ActorSystem, Kill, Props}\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref.SimpleString\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import com.digitalasset.platform.akkastreams.Dispatcher\n+import com.digitalasset.platform.akkastreams.SteppingMode.OneAfterAnother\n+import com.digitalasset.platform.services.time.TimeModel\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+import scala.collection.breakOut\n+\n+object InMemoryKVParticipantState {\n+\n+  /** The complete state of the participant at a given point in time.\n+    * This emulates a key-value blockchain with a log of commits and a key-value store.\n+    * The commit log provides the ordering for the log entries, and its height is used\n+    * as the [[Offset]].\n+    * */\n+  case class State(\n+      log: Vector[(DamlLogEntryId, DamlSubmission)],\n+      recordTime: Timestamp,\n+      // Store is the key-value store that the commits mutate.\n+      store: Map[ByteString, ByteString],\n+      config: Configuration\n+  )\n+\n+  // Message sent to the commit actor to commit a submission to the state.\n+  case class CommitMessage(\n+      // Submitter chosen entry identifier\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission\n+  )\n+}\n+\n+/* Implementation of the participant-state using the key-value utilities and an in-memory map. */\n+class InMemoryKVParticipantState(implicit system: ActorSystem)\n+    extends ReadService\n+    with WriteService\n+    with AutoCloseable {\n+  import InMemoryKVParticipantState._\n+\n+  val ledgerId = SimpleString.assertFromString(UUID.randomUUID.toString)\n+\n+  // DAML Engine for transaction validation.\n+  private val engine = Engine()\n+\n+  // Random number generator for generating unique entry identifiers.\n+  private val rng = new java.util.Random\n+\n+  // Namespace prefix for log entries.\n+  private val NS_LOG_ENTRIES = ByteString.copyFromUtf8(\"L\")\n+\n+  // Namespace prefix for DAML state.\n+  private val NS_DAML_STATE = ByteString.copyFromUtf8(\"DS\")\n+\n+  // Reference to the latest immutable state. Reference is only updated by the CommitActor.\n+  // Reading from the state must happen by first taking the reference (val state = stateRef).\n+  @volatile private var stateRef: State =\n+    State(\n+      log = Vector.empty[(DamlLogEntryId, DamlSubmission)],\n+      recordTime = Timestamp.Epoch,\n+      store = Map.empty[ByteString, ByteString],\n+      config = Configuration(\n+        timeModel = TimeModel.reasonableDefault\n+      )\n+    )\n+\n+  // Akka actor that receives submissions and commits them to the key-value store.\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  class CommitActor extends Actor {\n+    override def receive: Receive = {\n+      case CommitMessage(entryId, submission) =>\n+        val state = stateRef\n+        if (state.store.contains(entryId.getEntryId)) {\n+          // The entry identifier already in use, drop the message and let the\n+          // client retry submission.\n+        } else {\n+          // Process the submission to produce the log entry and the state updates.\n+          val (logEntry, damlStateUpdates) = KeyValueCommitting.processSubmission(\n+            engine,\n+            state.config,\n+            entryId,\n+            state.recordTime,\n+            submission,\n+            submission.getInputLogEntriesList.asScala\n+              .map(eid => eid -> getLogEntry(state, eid))(breakOut),\n+            submission.getInputDamlStateList.asScala\n+              .map(key => key -> getDamlState(state, key))(breakOut)\n+          )\n+\n+          // Combine the abstract log entry and the state updates into concrete updates to the store.\n+          val allUpdates =\n+            damlStateUpdates.map {\n+              case (k, v) =>\n+                NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(k)) ->\n+                  KeyValueCommitting.packDamlStateValue(v)\n+            } + (entryId.getEntryId -> KeyValueCommitting.packDamlLogEntry(logEntry))\n+\n+          // Atomically update the state reference, recording the commit\n+          // and the updated state.\n+          stateRef = state.copy(\n+            log = state.log :+ (entryId -> submission),\n+            store = state.store ++ allUpdates\n+          )\n+\n+          // Wake up consumers.\n+          dispatcher.signalNewHead(stateRef.log.size)\n+        }\n+    }\n+  }\n+  private val commitActorRef =\n+    system.actorOf(Props(new CommitActor), s\"commit-actor-${ledgerId.underlyingString}\")\n+\n+  // Dispatcher to subscribe to 'Update' events derived from the state.\n+  private val beginning: Int = 0\n+  private val dispatcher: Dispatcher[Int, Update] = Dispatcher(\n+    steppingMode = OneAfterAnother(\n+      (idx: Int, _) => idx + 1,\n+      (idx: Int) => Future.successful(getUpdate(idx, stateRef))\n+    ),\n+    zeroIndex = beginning,\n+    headAtInitialization = beginning\n+  )\n+\n+  private def getUpdate(idx: Int, state: State): Update = {\n+    if (idx < 0 || idx >= state.log.size)\n+      sys.error(s\"getUpdate: $idx out of bounds (${state.log.size})\")\n+\n+    // Resolve the \"height\" to log entry.\n+    val entryId = state.log(idx)._1\n+\n+    state.store\n+      .get(entryId.getEntryId)\n+      .map { blob =>\n+        KeyValueConsumption.logEntryToUpdate(entryId, KeyValueConsumption.unpackDamlLogEntry(blob))\n+      }\n+      .getOrElse(\n+        sys.error(s\"getUpdate: $entryId not found from store!\")\n+      )\n+  }\n+\n+  override def stateUpdates(beginAfter: Option[Offset]): Source[(Offset, Update), NotUsed] = {\n+    dispatcher\n+      .startingAt(beginAfter.map(_.components.head.toInt + 1).getOrElse(beginning))\n+      .map {\n+        case (idx, update) =>\n+          Offset(Array(idx.toLong)) -> update\n+      }\n+  }\n+\n+  private def getLogEntry(state: State, entryId: DamlLogEntryId): DamlLogEntry =\n+    DamlLogEntry.parseFrom(state.store(entryId.getEntryId))\n+\n+  private def getDamlState(state: State, key: DamlStateKey): Option[DamlStateValue] =\n+    state.store\n+      .get(NS_DAML_STATE.concat(KeyValueCommitting.packDamlStateKey(key)))\n+      .map(DamlStateValue.parseFrom)\n+\n+  override def submitTransaction(\n+      submitterInfo: SubmitterInfo,\n+      transactionMeta: TransactionMeta,\n+      transaction: SubmittedTransaction): Unit = {\n+\n+    val submission =\n+      KeyValueSubmission.transactionToSubmission(submitterInfo, transactionMeta, transaction)\n+\n+    // Submit the transaction to the committer.\n+    commitActorRef ! CommitMessage(\n+      allocateEntryId,\n+      submission\n+    )\n+  }\n+\n+  // Back-channel for uploading DAML-LF archives.\n+  def uploadArchive(archive: Archive): Unit = {\n+    commitActorRef ! CommitMessage(\n+      allocateEntryId,\n+      KeyValueSubmission.archiveToSubmission(archive)\n+    )\n+  }\n+\n+  /** Retrieve the static initial conditions of the ledger, containing\n+    * the ledger identifier and the epoch of the ledger record time."
  }
]