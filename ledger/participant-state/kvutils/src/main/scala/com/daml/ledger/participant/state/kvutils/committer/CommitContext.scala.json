[
  {
    "id" : "a9c7e8d7-4834-4593-aa03-75b54497dc9c",
    "prId" : 6630,
    "comments" : [
      {
        "id" : "49c07ed9-ca56-4b79-873b-a77b76891f29",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "We might want to turn all these `var` into properties for easier testability,",
        "createdAt" : "2020-07-08T14:46:53Z",
        "updatedAt" : "2020-07-09T10:04:48Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8b65556c-6367-40e7-a1e9-9f80d0603c13",
        "parentId" : "49c07ed9-ca56-4b79-873b-a77b76891f29",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "That's exactly the same comment I had on this before for you ;) mockito is happy to stub these as well so didn't make that change.",
        "createdAt" : "2020-07-17T09:25:46Z",
        "updatedAt" : "2020-07-17T09:25:47Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "30f59a7ea813c8683703e913a307efff5574108f",
    "line" : 19,
    "diffHunk" : "@@ -41,9 +45,15 @@ private[kvutils] trait CommitContext {\n   var minimumRecordTime: Option[Instant] = None\n   var maximumRecordTime: Option[Instant] = None\n \n+  // Rejection log entry used for generating an out-of-time-bounds log entry in case of\n+  // pre-execution.\n+  var outOfTimeBoundsLogEntry: Option[DamlLogEntry] = None"
  },
  {
    "id" : "cf6153cc-36d5-453c-8ed6-b4738910e75b",
    "prId" : 6567,
    "comments" : [
      {
        "id" : "e420b09b-4c72-44e7-b52f-8ddbe1a36789",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "I wouldn't make this `final`. If we keep the same `CommitContext` interface for both pre-execution vs. normal use-cases then these two methods must be implemented in `Committer` in order to avoid rebuilding the input map every time for normal execution.\r\nA simple solution is to lazily transform the inputs to the other type (i.e., inputs with vs. without fingerprints).",
        "createdAt" : "2020-07-03T08:33:56Z",
        "updatedAt" : "2020-07-03T08:42:54Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "112848b33c7d7e20093c922504fa5e654512b27a",
    "line" : 20,
    "diffHunk" : "@@ -21,15 +26,19 @@ import scala.collection.mutable\n private[kvutils] trait CommitContext {\n   private[this] val logger = LoggerFactory.getLogger(this.getClass)\n \n-  def inputs: DamlStateMap\n+  def inputsWithFingerprints: DamlStateMapWithFingerprints\n+  final def inputs: DamlStateMap = inputsWithFingerprints.map {"
  },
  {
    "id" : "b06f188e-b9e4-4265-bada-3280f64e7b32",
    "prId" : 6567,
    "comments" : [
      {
        "id" : "2f4b662c-1cd0-4f61-b1e7-885832332905",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We may leave associating fingerprints to accessed input keys to the caller, i.e., that would keep this interface less tailored to pre-execution (as we are using the same fingerprints that have been input this is trivial to do at the caller side) as well as remove the need to have an `inputsWithFingerprints` method.",
        "createdAt" : "2020-07-03T08:38:51Z",
        "updatedAt" : "2020-07-03T08:48:45Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "112848b33c7d7e20093c922504fa5e654512b27a",
    "line" : 56,
    "diffHunk" : "@@ -69,8 +78,8 @@ private[kvutils] trait CommitContext {\n       }\n \n   /** Get the accessed input key set. */\n-  def getAccessedInputKeys: collection.Set[DamlStateKey] =\n-    accessedInputKeys\n+  def getAccessedInputKeysWithFingerprints: collection.Set[(DamlStateKey, Fingerprint)] ="
  },
  {
    "id" : "3de0af36-3e20-4ffe-9a3b-025c6c9c2304",
    "prId" : 6561,
    "comments" : [
      {
        "id" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We don't need to keep track of the read order just the set of read keys. I.e., we could make the resulting `Iterable` deterministic by simply using a `SortedSet`. ",
        "createdAt" : "2020-07-01T13:39:41Z",
        "updatedAt" : "2020-07-01T15:52:08Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b169ac2e-31ac-42f9-806d-30bd90afc0c5",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Insertion order should be deterministic too (because access order is deterministic due to regular execution and post-execution being deterministic on a given submission) and is slightly more efficient and it can also be simplified with a `LinkedHashSet`. @andreaslochbihler-da could you validate my reasoning?",
        "createdAt" : "2020-07-01T14:10:05Z",
        "updatedAt" : "2020-07-01T15:52:08Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "30f383af-cea7-49ed-a61e-73f35f96fd00",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Also, not sure if we really need deterministic or stable iteration over the accessed input keys at all; do we already know that?",
        "createdAt" : "2020-07-01T14:32:40Z",
        "updatedAt" : "2020-07-01T15:52:08Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4e1ec846-8091-468c-a150-d8a8d6c53eed",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We don't even need deterministic order for the read set, we only care about membership and nothing else in the end. You could capture that by simply returning a `Set` and not an `Iterable` from the `getAccessedInputKeys` method.",
        "createdAt" : "2020-07-01T14:36:33Z",
        "updatedAt" : "2020-07-01T15:52:08Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e5c7d3df-8173-437a-8ba9-f60af04f72bc",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "So no reliance by any ledger on any of these properties? If so yes and I could also just use an `HashSet` and save some more memory.",
        "createdAt" : "2020-07-01T14:45:26Z",
        "updatedAt" : "2020-07-01T15:52:08Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2f65ec69-759b-417f-bc9d-cd84f43e0bc4",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Not that I know of. It's easy to fix this in the actual execution engine implementation if needed.",
        "createdAt" : "2020-07-01T15:06:09Z",
        "updatedAt" : "2020-07-01T15:52:08Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "428de5ee-c529-4a96-9541-53952a6bb787",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done, can you have a further look?",
        "createdAt" : "2020-07-01T15:52:30Z",
        "updatedAt" : "2020-07-01T15:52:30Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f29665fb-ac6b-458e-9bbd-fae89808d097",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Looks good to me.",
        "createdAt" : "2020-07-01T16:03:30Z",
        "updatedAt" : "2020-07-01T16:03:30Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a47dc00b-963b-46fc-8a5b-b49fcfadf044",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Thanks!",
        "createdAt" : "2020-07-01T16:10:28Z",
        "updatedAt" : "2020-07-01T16:10:28Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "59f34091-1684-4942-a3db-bd742adc9394",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "For pre-execution, we must compute the same serialization for the read set on all replicas. This is because the read set contributes to the hash the replicas need to each consensus on. So we will ultimately need a deterministic order on the keys in the read set. For now, using any `Set` is fine as long as we recover determinism before/during serialization, e.g., by ordering all keys in it.",
        "createdAt" : "2020-07-02T06:13:09Z",
        "updatedAt" : "2020-07-02T06:13:09Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5364c286-a70f-4352-a27f-603190390cf9",
        "parentId" : "856af59f-ab14-43a6-b156-3f094242afb9",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "OK, then we might want to revisit this because always iterating in access order is cheap here and spares us reordering later. Added a note to the LLD and will also cross-link this discussion.",
        "createdAt" : "2020-07-02T07:08:13Z",
        "updatedAt" : "2020-07-02T07:08:13Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1daf68a136e83014d4801aff22c806a970e54c44",
    "line" : null,
    "diffHunk" : "@@ -37,7 +41,10 @@ private[kvutils] trait CommitContext {\n   /** Retrieve value from output state, or if not found, from input state. */\n   def get(key: DamlStateKey): Option[DamlStateValue] =\n     outputs.get(key).orElse {\n-      inputs.getOrElse(key, throw Err.MissingInputState(key))\n+      val value = inputs.getOrElse(key, throw Err.MissingInputState(key))\n+      if (accessedInputKeys.add(key))"
  },
  {
    "id" : "4e42c0cb-2821-4377-a30e-b77132567a5f",
    "prId" : 6166,
    "comments" : [
      {
        "id" : "d561bc83-8b11-4449-b5b4-79f0da668a12",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Why an error?",
        "createdAt" : "2020-05-29T15:49:19Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6b235ae8-4768-453a-939a-2a78fa881ed9",
        "parentId" : "d561bc83-8b11-4449-b5b4-79f0da668a12",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Will change that before merging -- wanted to see if we actually hit this.",
        "createdAt" : "2020-05-29T15:53:41Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a7853362-96f5-4771-8cee-9a503e197f45",
        "parentId" : "d561bc83-8b11-4449-b5b4-79f0da668a12",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Changed it back to `TRACE`.",
        "createdAt" : "2020-05-29T16:28:30Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fa409c01178f2afb0bc265221613b023a96b20b",
    "line" : null,
    "diffHunk" : "@@ -39,12 +42,24 @@ private[kvutils] trait CommitContext {\n \n   /** Set a value in the output state. */\n   def set(key: DamlStateKey, value: DamlStateValue): Unit = {\n-    if (!outputs.contains(key)) {\n-      outputOrder += key\n+    if (inputAlreadyContains(key, value)) {\n+      logger.error(s\"Identical output found for key $key\")"
  },
  {
    "id" : "aab879db-7314-4ee6-ae46-8654a8ff8ed6",
    "prId" : 6166,
    "comments" : [
      {
        "id" : "9c3ed5e7-e717-4081-9965-4bc286c79736",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Shorter:\r\n```suggestion\r\n    inputs.get(key).exists(_.contains(value))\r\n```",
        "createdAt" : "2020-06-02T06:19:46Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fa409c01178f2afb0bc265221613b023a96b20b",
    "line" : null,
    "diffHunk" : "@@ -59,4 +62,11 @@ private[kvutils] trait CommitContext {\n   def getOutputs: Iterable[(DamlStateKey, DamlStateValue)] =\n     outputOrder.map(k => k -> outputs(k))\n \n+  private def inputAlreadyContains(key: DamlStateKey, value: DamlStateValue): Boolean =\n+    inputs\n+      .get(key)\n+      .exists {\n+        case Some(inputValue) => inputValue == value\n+        case None => false\n+      }"
  },
  {
    "id" : "717f33e9-af67-49f6-8d92-448966fc6243",
    "prId" : 6166,
    "comments" : [
      {
        "id" : "6dcbb2f4-8ab8-440a-937d-0b5b2a028e96",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Every `Committer` uses its own `CommitContext`, so the output order is determinized for each DamlSubmission in isolation. The output order across several DamlSubmissions does not seem to be deterministic given that `BatchedSubmissionValidator` calls `commit`s inside a `mapAsync`. I'm not sure though why we even need deterministic output order here. Can you check why we need the deterministic output order in the first place?",
        "createdAt" : "2020-06-02T06:57:19Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "60ad4e46-875a-4f49-8b95-53059e01ed8a",
        "parentId" : "6dcbb2f4-8ab8-440a-937d-0b5b2a028e96",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We ensure determinisim in `BatchedSubmissionValidator` by doing the conflict detection first (according to a fixed order) and only `commit`ing submissions that won't conflict and will generate the same write set regardless of order of execution.\r\nWe need deterministic output for historical reasons here -- we may want to relax this requirement.",
        "createdAt" : "2020-06-02T08:38:04Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e15626e1-cbfd-4c4e-8e57-6fa22178214c",
        "parentId" : "6dcbb2f4-8ab8-440a-937d-0b5b2a028e96",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Makes sense. Thanks for explaining the historical reasons.",
        "createdAt" : "2020-06-02T09:16:21Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4fa409c01178f2afb0bc265221613b023a96b20b",
    "line" : 20,
    "diffHunk" : "@@ -8,16 +8,19 @@ import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n   DamlStateKey,\n   DamlStateValue\n }\n-import com.daml.ledger.participant.state.kvutils.{Err, DamlStateMap}\n+import com.daml.ledger.participant.state.kvutils.{DamlStateMap, Err}\n import com.daml.ledger.participant.state.v1.ParticipantId\n import com.daml.lf.data.Time.Timestamp\n+import org.slf4j.LoggerFactory\n \n import scala.collection.mutable\n \n /** Commit context provides access to state inputs, commit parameters (e.g. record time) and\n   * allows committer to set state outputs.\n   */\n private[kvutils] trait CommitContext {\n+  private[this] val logger = LoggerFactory.getLogger(this.getClass)\n+\n   def inputs: DamlStateMap\n   // NOTE(JM): The outputs must be iterable in deterministic order, hence we\n   // keep track of insertion order."
  },
  {
    "id" : "f2383b28-036e-446a-a0a1-0078f1cdf006",
    "prId" : 6166,
    "comments" : [
      {
        "id" : "4fd93af9-c656-4768-866d-821963bad4dd",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I'd additionally remove the `key` from `outputs` and possibly `outputOrder`. Otherwise `set` has a weird semantics. For example,\r\n```\r\ninputs = Map(k1 -> Some(v1))\r\n\r\nset(k1, v2)\r\nset(k1, v1)\r\n```\r\nwhere `v1 != v2`. When we call `getOutputs`, we will get `Seq(k1 -> v2)` even though the second `set` should have overwritten the first. I would personally find it simpler if `set` remains unchanged and we only filter the outputs in `getOutputs`. ",
        "createdAt" : "2020-06-02T07:04:08Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c86beb72-d8f9-4300-8d32-7de0ad13436d",
        "parentId" : "4fd93af9-c656-4768-866d-821963bad4dd",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Applied your suggestion (i.e., doing the filtration only in `.getOutputs`) and added a test case for verifying this corner case.",
        "createdAt" : "2020-06-02T09:10:40Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fa409c01178f2afb0bc265221613b023a96b20b",
    "line" : null,
    "diffHunk" : "@@ -39,16 +42,16 @@ private[kvutils] trait CommitContext {\n \n   /** Set a value in the output state. */\n   def set(key: DamlStateKey, value: DamlStateValue): Unit = {\n-    if (!outputs.contains(key)) {\n-      outputOrder += key\n+    if (inputAlreadyContains(key, value)) {\n+      logger.trace(s\"Identical output found for key $key\")"
  },
  {
    "id" : "7f1cebfc-9f5f-4a41-a535-2b7a2577ae05",
    "prId" : 6166,
    "comments" : [
      {
        "id" : "f8e58df1-69a0-4fe5-8200-247e071d6562",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "If you use an Slf4j logger, you may want to use Slf4j templates instead of Scala string interpolation.",
        "createdAt" : "2020-06-02T07:43:57Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4958323b-61e1-4a91-aa88-1a8801a0010f",
        "parentId" : "f8e58df1-69a0-4fe5-8200-247e071d6562",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Thanks, that's a good point especially in case of expensive `.toString` methods.",
        "createdAt" : "2020-06-02T09:09:02Z",
        "updatedAt" : "2020-06-02T10:17:50Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fa409c01178f2afb0bc265221613b023a96b20b",
    "line" : null,
    "diffHunk" : "@@ -39,16 +42,16 @@ private[kvutils] trait CommitContext {\n \n   /** Set a value in the output state. */\n   def set(key: DamlStateKey, value: DamlStateValue): Unit = {\n-    if (!outputs.contains(key)) {\n-      outputOrder += key\n+    if (inputAlreadyContains(key, value)) {\n+      logger.trace(s\"Identical output found for key $key\")"
  }
]