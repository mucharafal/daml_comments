[
  {
    "id" : "1bfec0b0-7ffd-4436-8d89-e64fd9dfae54",
    "prId" : 7215,
    "comments" : [
      {
        "id" : "54744d7b-b784-4cae-821a-08e9a2ca063b",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2020-08-25T10:59:07Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0020dd8e089d897ae22c94ce2643c7d7f6073b04",
    "line" : 5,
    "diffHunk" : "@@ -32,6 +32,8 @@ package object kvutils {\n   type Bytes = ByteString\n   type DamlStateMap = Map[DamlStateKey, Option[DamlStateValue]]\n \n+  type CorrelationId = String\n+"
  },
  {
    "id" : "da97e71c-4692-4f7f-8dfa-a08aa86a3b38",
    "prId" : 6567,
    "comments" : [
      {
        "id" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "My understanding is that a fingerprint will always be present but we'll only use it in pre-execution; hence, I am defining and using this value in the current (non-preexec) code path.",
        "createdAt" : "2020-07-02T09:27:38Z",
        "updatedAt" : "2020-07-02T12:20:39Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "de950706-cf33-4a22-bf0f-5608b3984882",
        "parentId" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We only need fingerprints for pre-execution, hence, let's have two separate `CommitContext` implementations -- one should have DAML state input with fingerprints whereas the other without fingerprints. We won't even need to be able to access read input keys for normal execution. As we have the same committer implementations for pre-execution vs. normal execution it may lead to a bit of confusion, though.",
        "createdAt" : "2020-07-02T14:43:45Z",
        "updatedAt" : "2020-07-02T14:45:02Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b71d94ce-da5a-4b07-a722-5d4ec02bd5bc",
        "parentId" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "It's a good idea, let's see if I can come up with something decent.",
        "createdAt" : "2020-07-02T15:51:26Z",
        "updatedAt" : "2020-07-02T15:51:27Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7146c041-4d1c-4988-a0b0-117ddbf8dc70",
        "parentId" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "I think the best moment to do that as cleanly as possible is after we bifurcate the code path into execution and pre-execution. Then, any shared logic left (if any) that still needs to discriminate between the two cases would take `Either[ExecutionCommitContext, PreexecutionCommitContext]` (both would inherit from a common `CommitContext` trait containing only the common parts). What do you think?",
        "createdAt" : "2020-07-02T16:20:59Z",
        "updatedAt" : "2020-07-02T16:22:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f21f4b36-c65d-4eab-b4cd-5342d636001b",
        "parentId" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Agreed regarding bifurcating the code paths for the two execution methods later. However, right now the simplest approach would be to have access to the same set of properties in the context and the driver (`KeyValueCommitting` or parent `Committer` class) can do whatever they want with those and also may do some pre-execution specific logic. I would not suggest introducing an `Either` for this as it's going to complicate code unnecessarily. Instead, we may want to define different set of steps for pre-execution vs. normal execution for the different committers and share the steps that are common.",
        "createdAt" : "2020-07-02T16:29:46Z",
        "updatedAt" : "2020-07-02T16:30:25Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1f8e7803-3881-4332-a235-553076feafc2",
        "parentId" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Yes, using separate steps can do it more cleanly. What's your suggestion for now though, leaving as it is if I understand correctly?",
        "createdAt" : "2020-07-02T16:35:56Z",
        "updatedAt" : "2020-07-02T16:35:56Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d4c08ea-6cfa-424f-8d6a-fd4f709f1eed",
        "parentId" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Yes, let's leave it as-is for now and do a refactoring at a later step.",
        "createdAt" : "2020-07-02T17:03:10Z",
        "updatedAt" : "2020-07-02T17:03:11Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0672446e-3d0a-4593-a43d-0897dcb6ded1",
        "parentId" : "ec5c03a3-8499-411a-93ff-c08c69ff0612",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "@miklos-da If everything else looks at this stage, could you approve it?",
        "createdAt" : "2020-07-03T07:04:23Z",
        "updatedAt" : "2020-07-03T07:04:23Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "112848b33c7d7e20093c922504fa5e654512b27a",
    "line" : 9,
    "diffHunk" : "@@ -30,9 +30,12 @@ import com.google.protobuf.ByteString\n package object kvutils {\n \n   type Bytes = ByteString\n-\n   type DamlStateMap = Map[DamlStateKey, Option[DamlStateValue]]\n \n+  type Fingerprint = Bytes\n+  type DamlStateMapWithFingerprints = Map[DamlStateKey, (Option[DamlStateValue], Fingerprint)]\n+  val FingerprintPlaceholder: Fingerprint = ByteString.EMPTY"
  },
  {
    "id" : "1a3c02a8-df2c-40ed-937d-7f70364e3fc2",
    "prId" : 637,
    "comments" : [
      {
        "id" : "a98def47-d5b6-4a82-8246-99a28238b408",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "What auxilliary data?",
        "createdAt" : "2019-04-25T13:11:50Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue]).\n+  *\n+  * The first element describes the ordering of log entries. The second element contains the immutable\n+  * committed DAML log entries, and the third element describes auxilliary mutable state related to the log entry\n+  * (e.g. a log entry might describe a DAML transaction containing contracts and the auxilliary mutable data may\n+  * describe their activeness).\n+  *\n+  * While these can be represented in a key-value store directly, some implementations may\n+  * provide the ordering of log entries from outside the state (e.g. via the transaction chain).\n+  * The distinction between DAML log entries and DAML state values is that log entries are immutable,\n+  * and that their keys are not necessarily known beforehand, which is why the implementation talks\n+  * about them separately.\n+  *\n+  * At a high-level the approach for submitting, committing and reading transactions is\n+  * as follows:\n+  *\n+  * 1. The submitted transaction is serialized into a `DamlSubmission` blob, which is\n+  *    sent to the ledger to be committed. This protocol buffer data structure contains\n+  *    the transaction and its required inputs for execution.\n+  *\n+  * 2. The transaction processor of the underlying ledger receives the `DamlSubmission`,\n+  *    assigns the submission a unique log entry identifier (this may also be pre-assigned)\n+  *    and calls `processSubmission` to validate the submission and produce the log entry\n+  *    that is to be committed, and a list of updates to the key-value state.\n+  *\n+  * 3. A read pipeline on participant-state gets a notification of a committed transaction (receives\n+  *    a new `DamlLogEntryId`), reads the `DamlLogEntry`, and auxilliary data from the state and"
  },
  {
    "id" : "15fb58d6-d3b6-44bb-b4df-3092f9a699fa",
    "prId" : 637,
    "comments" : [
      {
        "id" : "a1f3726e-514b-41f8-9e82-789c09edf850",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "How can I get the necessary inputs of a submission such that I can prefetch them?",
        "createdAt" : "2019-04-25T13:15:03Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue]).\n+  *\n+  * The first element describes the ordering of log entries. The second element contains the immutable\n+  * committed DAML log entries, and the third element describes auxilliary mutable state related to the log entry\n+  * (e.g. a log entry might describe a DAML transaction containing contracts and the auxilliary mutable data may\n+  * describe their activeness).\n+  *\n+  * While these can be represented in a key-value store directly, some implementations may\n+  * provide the ordering of log entries from outside the state (e.g. via the transaction chain).\n+  * The distinction between DAML log entries and DAML state values is that log entries are immutable,\n+  * and that their keys are not necessarily known beforehand, which is why the implementation talks\n+  * about them separately.\n+  *\n+  * At a high-level the approach for submitting, committing and reading transactions is\n+  * as follows:\n+  *\n+  * 1. The submitted transaction is serialized into a `DamlSubmission` blob, which is\n+  *    sent to the ledger to be committed. This protocol buffer data structure contains\n+  *    the transaction and its required inputs for execution.\n+  *\n+  * 2. The transaction processor of the underlying ledger receives the `DamlSubmission`,\n+  *    assigns the submission a unique log entry identifier (this may also be pre-assigned)\n+  *    and calls `processSubmission` to validate the submission and produce the log entry\n+  *    that is to be committed, and a list of updates to the key-value state.\n+  *\n+  * 3. A read pipeline on participant-state gets a notification of a committed transaction (receives\n+  *    a new `DamlLogEntryId`), reads the `DamlLogEntry`, and auxilliary data from the state and\n+  *    produces an `Update` event.\n+  */\n+package object kvutils {\n+\n+  /**\n+    * Methods to produce a `DamlSubmission`.\n+    */\n+  trait KeyValueSubmission {\n+\n+    def transactionToSubmission(\n+        submitterInfo: SubmitterInfo,\n+        meta: TransactionMeta,\n+        tx: SubmittedTransaction): DamlSubmission\n+\n+    def archiveToSubmission(archive: Archive): DamlSubmission\n+\n+    def configurationToSubmission(config: Configuration): DamlSubmission\n+  }\n+\n+  /**\n+    * Methods to process a `DamlSubmission`.\n+    */\n+  trait KeyValueCommitting {\n+\n+    /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+      * Produces the log entry to be committed, and DAML state updates.\n+      *\n+      * The caller should fetch the inputs declared in `DamlSubmission`.\n+      *\n+      * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+      * @param config: The ledger configuration.\n+      * @param entryId: The log entry id to which this submission is committed.\n+      * @param recordTime: The record time for the log entry.\n+      * @param submission: The submission to commit to the ledger.\n+      * @param inputLogEntries: The resolved inputs to the submission.\n+      * @param inputState: The input DAML state entries.\n+      * @return The log entry to be committed and the DAML state updates.\n+      */\n+    def processSubmission("
  },
  {
    "id" : "670e8d31-a5f8-42bb-8724-ec642bd2a5ae",
    "prId" : 637,
    "comments" : [
      {
        "id" : "1677a499-b1ce-404f-9aca-fc0fda6aa9ce",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Explain how these updates should be applied.",
        "createdAt" : "2019-04-25T13:15:49Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue]).\n+  *\n+  * The first element describes the ordering of log entries. The second element contains the immutable\n+  * committed DAML log entries, and the third element describes auxilliary mutable state related to the log entry\n+  * (e.g. a log entry might describe a DAML transaction containing contracts and the auxilliary mutable data may\n+  * describe their activeness).\n+  *\n+  * While these can be represented in a key-value store directly, some implementations may\n+  * provide the ordering of log entries from outside the state (e.g. via the transaction chain).\n+  * The distinction between DAML log entries and DAML state values is that log entries are immutable,\n+  * and that their keys are not necessarily known beforehand, which is why the implementation talks\n+  * about them separately.\n+  *\n+  * At a high-level the approach for submitting, committing and reading transactions is\n+  * as follows:\n+  *\n+  * 1. The submitted transaction is serialized into a `DamlSubmission` blob, which is\n+  *    sent to the ledger to be committed. This protocol buffer data structure contains\n+  *    the transaction and its required inputs for execution.\n+  *\n+  * 2. The transaction processor of the underlying ledger receives the `DamlSubmission`,\n+  *    assigns the submission a unique log entry identifier (this may also be pre-assigned)\n+  *    and calls `processSubmission` to validate the submission and produce the log entry\n+  *    that is to be committed, and a list of updates to the key-value state.\n+  *\n+  * 3. A read pipeline on participant-state gets a notification of a committed transaction (receives\n+  *    a new `DamlLogEntryId`), reads the `DamlLogEntry`, and auxilliary data from the state and\n+  *    produces an `Update` event.\n+  */\n+package object kvutils {\n+\n+  /**\n+    * Methods to produce a `DamlSubmission`.\n+    */\n+  trait KeyValueSubmission {\n+\n+    def transactionToSubmission(\n+        submitterInfo: SubmitterInfo,\n+        meta: TransactionMeta,\n+        tx: SubmittedTransaction): DamlSubmission\n+\n+    def archiveToSubmission(archive: Archive): DamlSubmission\n+\n+    def configurationToSubmission(config: Configuration): DamlSubmission\n+  }\n+\n+  /**\n+    * Methods to process a `DamlSubmission`.\n+    */\n+  trait KeyValueCommitting {\n+\n+    /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+      * Produces the log entry to be committed, and DAML state updates."
  },
  {
    "id" : "43a5f63d-7ddf-492f-a0a7-437892939fe6",
    "prId" : 637,
    "comments" : [
      {
        "id" : "e5b7086d-7cb9-4e83-ac79-f86de932fd7d",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Make it clear that it is key that only the Java classes for DamlSubmission are used to create and consume it. They should not embed the protobufs directly in another class.",
        "createdAt" : "2019-04-25T13:26:23Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue]).\n+  *\n+  * The first element describes the ordering of log entries. The second element contains the immutable\n+  * committed DAML log entries, and the third element describes auxilliary mutable state related to the log entry\n+  * (e.g. a log entry might describe a DAML transaction containing contracts and the auxilliary mutable data may\n+  * describe their activeness).\n+  *\n+  * While these can be represented in a key-value store directly, some implementations may\n+  * provide the ordering of log entries from outside the state (e.g. via the transaction chain).\n+  * The distinction between DAML log entries and DAML state values is that log entries are immutable,\n+  * and that their keys are not necessarily known beforehand, which is why the implementation talks\n+  * about them separately.\n+  *\n+  * At a high-level the approach for submitting, committing and reading transactions is\n+  * as follows:\n+  *\n+  * 1. The submitted transaction is serialized into a `DamlSubmission` blob, which is\n+  *    sent to the ledger to be committed. This protocol buffer data structure contains\n+  *    the transaction and its required inputs for execution.\n+  *\n+  * 2. The transaction processor of the underlying ledger receives the `DamlSubmission`,\n+  *    assigns the submission a unique log entry identifier (this may also be pre-assigned)\n+  *    and calls `processSubmission` to validate the submission and produce the log entry\n+  *    that is to be committed, and a list of updates to the key-value state.\n+  *\n+  * 3. A read pipeline on participant-state gets a notification of a committed transaction (receives\n+  *    a new `DamlLogEntryId`), reads the `DamlLogEntry`, and auxilliary data from the state and\n+  *    produces an `Update` event.\n+  */\n+package object kvutils {\n+\n+  /**\n+    * Methods to produce a `DamlSubmission`."
  },
  {
    "id" : "662bfd5d-7a31-4b0f-90c6-94316fe3da0a",
    "prId" : 637,
    "comments" : [
      {
        "id" : "aa89fe04-69f3-4b78-8141-594985c7825d",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "the participant-state Read/WriteService interfaces",
        "createdAt" : "2019-04-25T13:52:33Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6d729940-db76-4eb4-804c-1cf6ec29060f",
        "parentId" : "aa89fe04-69f3-4b78-8141-594985c7825d",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "provide motivation for why we somebody should use this tooling. Also explain why we provide this tooling (to enable evolution of DAML).",
        "createdAt" : "2019-04-25T13:57:20Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage."
  },
  {
    "id" : "98818809-6d65-49f6-825d-bb6fc10c8b45",
    "prId" : 637,
    "comments" : [
      {
        "id" : "9bff1a19-659e-4106-8b48-82b41bd96507",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "The",
        "createdAt" : "2019-04-25T13:52:41Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around"
  },
  {
    "id" : "7e706434-0abc-4374-ba8d-1e8e350634b0",
    "prId" : 637,
    "comments" : [
      {
        "id" : "05792518-ea9a-40ae-a522-6010032b6904",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "an abstract state of the form `(logEntryIds, logEntryMap, kvState)` of type `(List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue])`.",
        "createdAt" : "2019-04-25T13:55:21Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue])."
  },
  {
    "id" : "5691af7c-fdd5-4e3d-8566-d72e8c611c90",
    "prId" : 637,
    "comments" : [
      {
        "id" : "25c9c4d0-6b98-41e7-ad01-799ee8347809",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "The `logEntries` list describes the ordering of log entries. The `logEntryMap` contains the data for `logEntries`. Entries in that map are expected to be immutable. We separate the ordering of log-entries from storing their data, as ...",
        "createdAt" : "2019-04-25T13:56:35Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "efdd9521-8f41-449e-8094-07954b1520b0",
        "parentId" : "25c9c4d0-6b98-41e7-ad01-799ee8347809",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Avoid explanations that use the word `might`. Ideally, explain exactly what's happening or give an explanation that is potentially too wide. Explanations that are \"open\" are often not helpful, as they just heighten uncertainty.\r\n\r\n",
        "createdAt" : "2019-04-25T13:58:42Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 20,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue]).\n+  *\n+  * The first element describes the ordering of log entries. The second element contains the immutable\n+  * committed DAML log entries, and the third element describes auxilliary mutable state related to the log entry\n+  * (e.g. a log entry might describe a DAML transaction containing contracts and the auxilliary mutable data may\n+  * describe their activeness)."
  },
  {
    "id" : "7a1445c6-21e7-453d-ac63-94b76d52e262",
    "prId" : 637,
    "comments" : [
      {
        "id" : "68ed4e82-857f-42ab-ac9c-c05ad6512c07",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Work this explanation into the explanation of the components above.",
        "createdAt" : "2019-04-25T13:59:09Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue]).\n+  *\n+  * The first element describes the ordering of log entries. The second element contains the immutable\n+  * committed DAML log entries, and the third element describes auxilliary mutable state related to the log entry\n+  * (e.g. a log entry might describe a DAML transaction containing contracts and the auxilliary mutable data may\n+  * describe their activeness).\n+  *\n+  * While these can be represented in a key-value store directly, some implementations may\n+  * provide the ordering of log entries from outside the state (e.g. via the transaction chain).\n+  * The distinction between DAML log entries and DAML state values is that log entries are immutable,\n+  * and that their keys are not necessarily known beforehand, which is why the implementation talks\n+  * about them separately."
  },
  {
    "id" : "9acfaf42-b6cd-419b-97a6-b4db0d0bbf32",
    "prId" : 637,
    "comments" : [
      {
        "id" : "7d560380-5ccb-4a5a-9a15-55280bff9d01",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Explain this approach with explicit references to variables for the submission and the changes to the state that entail from it. Make it as easy to follow as possible. Ideally, the explanation is not high-level, but exact and concise. It can be that by exploiting that the structure of the state is very simple.",
        "createdAt" : "2019-04-25T14:00:50Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "713a7102-fab8-434a-9cd6-4924442f1613",
        "parentId" : "7d560380-5ccb-4a5a-9a15-55280bff9d01",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "did a pass on it.. could you have another look?",
        "createdAt" : "2019-04-25T14:50:44Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue]).\n+  *\n+  * The first element describes the ordering of log entries. The second element contains the immutable\n+  * committed DAML log entries, and the third element describes auxilliary mutable state related to the log entry\n+  * (e.g. a log entry might describe a DAML transaction containing contracts and the auxilliary mutable data may\n+  * describe their activeness).\n+  *\n+  * While these can be represented in a key-value store directly, some implementations may\n+  * provide the ordering of log entries from outside the state (e.g. via the transaction chain).\n+  * The distinction between DAML log entries and DAML state values is that log entries are immutable,\n+  * and that their keys are not necessarily known beforehand, which is why the implementation talks\n+  * about them separately.\n+  *\n+  * At a high-level the approach for submitting, committing and reading transactions is\n+  * as follows:"
  },
  {
    "id" : "23637088-4bfb-43d5-98e8-3d3454ace3d7",
    "prId" : 637,
    "comments" : [
      {
        "id" : "3c4f03ee-d172-43aa-8333-b833e480c6dd",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Also explain that if one allocates `DamlLogEntryId`s consecutively, then the list can be stored implicitly via the list of ordered entry-ids.",
        "createdAt" : "2019-04-25T16:05:26Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+package com.daml.ledger.participant.state\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{\n+  Configuration,\n+  SubmittedTransaction,\n+  SubmitterInfo,\n+  TransactionMeta,\n+  Update\n+}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+\n+/** The participant-state key-value utilities provide methods to succintly implement\n+  * participant-state on top of ledger's that provide a key-value state storage.\n+  *\n+  * Key-value utilities are based around the concept of modelling the ledger around\n+  * an abstract state that can be described (abstractly) as the tuple\n+  * (List[DamlLogEntryId], Map[DamlLogEntryId, DamlLogEntry], Map[DamlStateKey, DamlStateValue])."
  }
]