[
  {
    "id" : "b96f3f4b-c3fc-42a9-ac93-15617535d865",
    "prId" : 7584,
    "comments" : [
      {
        "id" : "e020e06f-d5cb-409d-8caa-7fa4302981ef",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "The purpose of this change is to be able to invoke `submissionOutputs` without having a `KeyValueCommitting` instance.",
        "createdAt" : "2020-10-06T14:11:04Z",
        "updatedAt" : "2020-10-13T08:04:09Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "786f945fdc62b10bee6b10a2fcf88af69442f323",
    "line" : 13,
    "diffHunk" : "@@ -141,6 +143,30 @@ class KeyValueCommitting private[daml] (\n         throw Err.InvalidSubmission(\"DamlSubmission payload not set\")\n     }\n \n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs("
  },
  {
    "id" : "616bfad1-fbe3-420f-b048-bbd9b6f367eb",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "c17cfa5b-2b0e-478c-a11b-2c75adb597b4",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "I'd suggest removing the comment and leaving this into `Postcommit` mode and we'll resolve this later.",
        "createdAt" : "2020-09-23T12:35:45Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "34c92fcf-3eda-4321-a53d-b47ee5ab2dd6",
        "parentId" : "c17cfa5b-2b0e-478c-a11b-2c75adb597b4",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2020-09-24T08:09:37Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -34,10 +34,14 @@ import scala.collection.JavaConverters._\n class KeyValueCommitting private[daml] (\n     engine: Engine,\n     metrics: Metrics,\n-    inStaticTimeMode: Boolean) {\n+    inStaticTimeMode: Boolean,\n+    packageValidation: CommitPackageValidationMode,\n+) {\n   private val logger = LoggerFactory.getLogger(this.getClass)\n \n-  def this(engine: Engine, metrics: Metrics) = this(engine, metrics, false)\n+  // RH: what is the good default value for packageValidation"
  },
  {
    "id" : "9738d9d4-3199-4772-8e25-492cb3eb0a5d",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "7365c061-bc33-4b5c-83a4-d515fb432fba",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "We should avoid having multiple places with default values. I think this constructor should also have the `packageValidation` parameter. Any concerns with such an API change, @miklos-da?",
        "createdAt" : "2020-09-30T15:28:29Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c35d185f-d925-4df2-a402-f143e92b525e",
        "parentId" : "7365c061-bc33-4b5c-83a4-d515fb432fba",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I dropped the default values.",
        "createdAt" : "2020-10-02T11:50:39Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -34,10 +34,13 @@ import scala.collection.JavaConverters._\n class KeyValueCommitting private[daml] (\n     engine: Engine,\n     metrics: Metrics,\n-    inStaticTimeMode: Boolean) {\n+    inStaticTimeMode: Boolean,\n+    packageValidation: CommitPackageValidationMode,\n+) {\n   private val logger = LoggerFactory.getLogger(this.getClass)\n \n-  def this(engine: Engine, metrics: Metrics) = this(engine, metrics, false)\n+  def this(engine: Engine, metrics: Metrics) =\n+    this(engine, metrics, false, CommitPackageValidationMode.PostCommit)"
  },
  {
    "id" : "d9b0f3b4-e14c-4bfa-9f6c-a921b55b2dbc",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "9d97f64a-a5df-407f-90dd-cac327b10994",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Can you not add this TODO here, please? We already have it in many places and this should be rather captured in our backlog.",
        "createdAt" : "2020-05-08T14:13:41Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b42639ac-032b-4b9b-a8a6-d8017ff6a8f1",
        "parentId" : "9d97f64a-a5df-407f-90dd-cac327b10994",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Done",
        "createdAt" : "2020-05-08T18:43:44Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : null,
    "diffHunk" : "@@ -176,12 +176,14 @@ class KeyValueCommitting private[daml] (\n         )\n \n       case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n-        new ProcessTransactionSubmission(defaultConfig, engine, metrics, inStaticTimeMode)\n+        new TransactionCommitter(defaultConfig, engine, metrics, inStaticTimeMode)\n           .run(\n             entryId,\n+            //TODO replace this call with an explicit maxRecordTime from the request once available"
  },
  {
    "id" : "5f0e2169-cb46-4033-b6d6-2be416174a0a",
    "prId" : 3811,
    "comments" : [
      {
        "id" : "3ca7e8be-c333-4074-80d4-536acab7bcb0",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Will we be able to correlate this exception with the faulty submission based on the logs? If not we might want to add a correlation ID here (e.g., log entry ID).",
        "createdAt" : "2019-12-11T09:56:56Z",
        "updatedAt" : "2019-12-11T10:10:38Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5a054c5c-9c2e-4ce6-a1b1-afc56b291efc",
        "parentId" : "3ca7e8be-c333-4074-80d4-536acab7bcb0",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "I do not want to put such transient information into errors, that can be persisted. I would like to separate the logging need for correlation ids from the business logic",
        "createdAt" : "2019-12-11T10:59:23Z",
        "updatedAt" : "2019-12-11T10:59:24Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "965b91ae-9bfb-4e7b-90dd-782e87a698e7",
        "parentId" : "3ca7e8be-c333-4074-80d4-536acab7bcb0",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Sure, then we just need to make sure that we can correlate the above error with the submission itself at one point.",
        "createdAt" : "2019-12-11T11:27:56Z",
        "updatedAt" : "2019-12-11T11:28:15Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "561993529dbc4e148f7a091eb4cfd2d40ef559d8",
    "line" : 5,
    "diffHunk" : "@@ -134,7 +134,7 @@ object KeyValueCommitting {\n           ).run\n \n         case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n-          throw Err.InvalidSubmission(\"DamlSubmission.payload not set.\")\n+          throw Err.InvalidSubmission(\"DamlSubmission payload not set\")"
  },
  {
    "id" : "bc8b35c6-040a-4328-8f2b-fc1f1d9abffe",
    "prId" : 3780,
    "comments" : [
      {
        "id" : "a20f1642-b3e5-4079-9f18-76f40c476edf",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "please add comments on why this is temporarily here.",
        "createdAt" : "2019-12-09T10:29:47Z",
        "updatedAt" : "2019-12-10T08:35:01Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "485c0c8b47042f401b12c0c13992bc13ed2ea4dd",
    "line" : 15,
    "diffHunk" : "@@ -37,6 +38,9 @@ object KeyValueCommitting {\n   def packDamlLogEntryId(entry: DamlLogEntryId): ByteString = entry.toByteString\n   def unpackDamlLogEntryId(bytes: ByteString): DamlLogEntryId = DamlLogEntryId.parseFrom(bytes)\n \n+  private def estimateMaximumRecordTime(recordTime: Timestamp): Timestamp ="
  },
  {
    "id" : "c6f38865-ea7e-423d-a037-feb2e19c5de9",
    "prId" : 3701,
    "comments" : [
      {
        "id" : "a17723f5-bf8d-4cfd-baae-5a832c6614c3",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "dropping the optional wrapping was a bad idea. we should keep it throughout to make sure that the submitter cannot cheat by \"forgetting\" to mention some inputs.",
        "createdAt" : "2019-12-04T10:55:07Z",
        "updatedAt" : "2019-12-04T12:47:49Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8eb17918b3460de8d54a0e9129d083b7f46e95bd",
    "line" : null,
    "diffHunk" : "@@ -89,13 +92,14 @@ object KeyValueCommitting {\n           logEntry -> outputs.toMap\n \n         case DamlSubmission.PayloadCase.PARTY_ALLOCATION_ENTRY =>\n-          ProcessPartyAllocation(\n+          val (logEntry, outputs) = PartyAllocationCommitter.run(\n             entryId,\n             recordTime,\n-            participantId,\n             submission.getPartyAllocationEntry,\n-            inputState\n-          ).run\n+            participantId,\n+            inputState.collect { case (k, Some(v)) => k -> v }"
  },
  {
    "id" : "f46fa20e-b92f-4aae-b8c9-a6734f8580b7",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "3cffff0e-3bf3-401b-abf6-9f11e2975ba9",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "further step would be to initialize all these \"committers\" once. Needed to nicely set up some metrics' gauges anyway, but that'll change the interface so would do this in multiple steps (and would try to keep the original interface around until implementations have upgraded). ",
        "createdAt" : "2019-10-07T08:38:19Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : 22,
    "diffHunk" : "@@ -73,13 +73,22 @@ object KeyValueCommitting {\n     try {\n       submission.getPayloadCase match {\n         case DamlSubmission.PayloadCase.PACKAGE_UPLOAD_ENTRY =>\n-          ProcessPackageUpload(\n+          val (logEntry, outputs) = PackageCommitter(engine).run("
  },
  {
    "id" : "752f263c-3ff4-4293-ace9-a4dd23f135de",
    "prId" : 3065,
    "comments" : [
      {
        "id" : "4669cea4-fcf0-4619-bc50-917519066792",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The `var`s in here should probably be marked as `@volatile`.",
        "createdAt" : "2019-10-01T14:50:16Z",
        "updatedAt" : "2019-10-02T12:13:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "00fd96ed-18fe-47c9-b4ca-103d3aeb122a",
        "parentId" : "4669cea4-fcf0-4619-bc50-917519066792",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "In fact, it's probably best to create a custom `Gauge` implementation that always reports the last value that the application sets, and register that gauge directly with `MetricRegistry#register`. This way the application doesn't have to deal with synchronization (volatile vars or AtomicReference).",
        "createdAt" : "2019-10-01T14:55:03Z",
        "updatedAt" : "2019-10-02T12:13:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9cd8f4a6-3305-4545-b0c4-660fb04d4d56",
        "parentId" : "4669cea4-fcf0-4619-bc50-917519066792",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Thanks, Added `VarGauge`",
        "createdAt" : "2019-10-02T12:13:50Z",
        "updatedAt" : "2019-10-02T12:13:50Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2f01ac85d811524ea061ca8561b9e2eebfaca389",
    "line" : 152,
    "diffHunk" : "@@ -207,4 +216,37 @@ object KeyValueCommitting {\n \n     }\n   }\n+\n+  private object Metrics {"
  },
  {
    "id" : "1859efe0-1fb3-4a2d-bf54-3771cf66c622",
    "prId" : 2304,
    "comments" : [
      {
        "id" : "5da6d8e8-dbab-46c7-a3f8-c933ea750d48",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "`inputState` seems to be already a map, is there a specific reason to turn it into a list and then back into a map?",
        "createdAt" : "2019-07-29T07:20:21Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c98f89bf6eb59cfe18c2a97d41daf898fb97679",
    "line" : 121,
    "diffHunk" : "@@ -336,97 +337,81 @@ object KeyValueCommitting {\n         parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n     )\n \n-    // Helper to lookup contract instances. We verify the activeness of\n-    // contract instances here. Since we look up every contract that was\n-    // an input to a transaction, we do not need to verify the inputs separately.\n-    def lookupContract(coid: AbsoluteContractId) = {\n-      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n-      val stateKey = absoluteContractIdToStateKey(coid)\n-      for {\n-        // Fetch the state of the contract so that activeness and visibility can be checked.\n-        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState)).orElse {\n-          tracelog(s\"lookupContract($coid): Contract state not found!\")\n-          throw Err.MissingInputState(stateKey)\n-        }\n-        locallyDisclosedTo = contractState.getLocallyDisclosedToList.asScala.toSet\n-        divulgedTo = contractState.getDivulgedToList.asScala.toSet\n-        submitter = submitterInfo.getSubmitter\n-\n-        // 1. Verify that the submitter can view the contract.\n-        _ <- if (locallyDisclosedTo.contains(submitter) || divulgedTo.contains(submitter))\n-          Some(())\n-        else {\n-          tracelog(s\"lookupContract($coid): Contract not visible to submitter $submitter\")\n-          None\n-        }\n-\n-        // 2. Verify that the contract is active\n-        _ <- if (contractState.hasActiveAt && txLet >= parseTimestamp(contractState.getActiveAt))\n-          Some(())\n-        else {\n-          val activeAtStr =\n-            if (contractState.hasActiveAt)\n-              parseTimestamp(contractState.getActiveAt).toString\n-            else \"<activeAt missing>\"\n-          tracelog(\n-            s\"lookupContract($coid): Contract not active (let=$txLet, activeAt=$activeAtStr).\")\n-          None\n-        }\n-\n-        // Finally lookup the log entry containing the create node and the contract instance.\n-        entry = inputLogEntries\n-          .getOrElse(eid, throw Err.MissingInputLogEntry(eid))\n-        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n-      } yield (coinst)\n+    def contractVisibleToSubmitter(contractState: DamlContractState): Boolean = {\n+      val locallyDisclosedTo = contractState.getLocallyDisclosedToList.asScala.toSet\n+      val divulgedTo = contractState.getDivulgedToList.asScala.toSet\n+      locallyDisclosedTo.contains(submitter) || divulgedTo.contains(submitter)\n     }\n \n-    // Helper to lookup package from the state. The package contents\n-    // are stored in the [[DamlLogEntry]], which we find by looking up\n-    // the DAML state entry at `DamlStateKey(packageId = pkgId)`.\n-    def lookupPackage(pkgId: PackageId) = {\n-      val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId).build\n-      for {\n-        value <- inputState\n-          .get(stateKey)\n-          .flatten\n-          .orElse {\n-            throw Err.MissingInputState(stateKey)\n-          }\n-        pkg <- value.getValueCase match {\n-          case DamlStateValue.ValueCase.ARCHIVE =>\n-            // NOTE(JM): Engine only looks up packages once, compiles and caches,\n-            // provided that the engine instance is persisted.\n-            Some(Decode.decodeArchive(value.getArchive)._2)\n-          case _ =>\n-            tracelog(s\"lookupPackage($pkgId): value not a DAML-LF archive!\")\n-            None\n-        }\n-      } yield pkg\n-    }\n+    // Pull all keys from referenced contracts. We require this for 'fetchByKey' calls\n+    // which are not evidenced in the transaction itself and hence the contract key state is\n+    // not included in the inputs.\n+    lazy val knownKeys: Map[GlobalKey, AbsoluteContractId] =\n+      inputState.toList.collect {"
  },
  {
    "id" : "083c24a5-cd74-4a29-8524-bbcb726b304c",
    "prId" : 2304,
    "comments" : [
      {
        "id" : "db6d5276-8dd3-4f2d-8017-06d99a4d2b5d",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I'm not familiar with this code, but I suspect that if a transaction archives a contract with a key and then creates another contract with the same key, then the creation may overwrite the key entry for the actual input contract in this map.",
        "createdAt" : "2019-07-29T07:43:26Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "48d94921-03c0-465c-8db8-4dfd702cb0f0",
        "parentId" : "db6d5276-8dd3-4f2d-8017-06d99a4d2b5d",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Shouldn't be a problem. This code wouldn't get invoked if the contract is archived and new one created with the same key since the interpreter already catches this.",
        "createdAt" : "2019-07-29T08:34:08Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "24e1e7a6-c895-4dd2-a1f5-f0521471c852",
        "parentId" : "db6d5276-8dd3-4f2d-8017-06d99a4d2b5d",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "But that's a perfectly legitimate use case. First archive the contract with the key and then create a new one with the same key, all in the same transaction. DAMLe is supposed to produce such a transaction. I'm worried that this code visits the create node and later fetch nodes and this overwrites the data from the lookupByKey/exercise that archives the input contract.",
        "createdAt" : "2019-07-29T09:42:25Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c98f89bf6eb59cfe18c2a97d41daf898fb97679",
    "line" : 126,
    "diffHunk" : "@@ -336,97 +337,81 @@ object KeyValueCommitting {\n         parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n     )\n \n-    // Helper to lookup contract instances. We verify the activeness of\n-    // contract instances here. Since we look up every contract that was\n-    // an input to a transaction, we do not need to verify the inputs separately.\n-    def lookupContract(coid: AbsoluteContractId) = {\n-      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n-      val stateKey = absoluteContractIdToStateKey(coid)\n-      for {\n-        // Fetch the state of the contract so that activeness and visibility can be checked.\n-        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState)).orElse {\n-          tracelog(s\"lookupContract($coid): Contract state not found!\")\n-          throw Err.MissingInputState(stateKey)\n-        }\n-        locallyDisclosedTo = contractState.getLocallyDisclosedToList.asScala.toSet\n-        divulgedTo = contractState.getDivulgedToList.asScala.toSet\n-        submitter = submitterInfo.getSubmitter\n-\n-        // 1. Verify that the submitter can view the contract.\n-        _ <- if (locallyDisclosedTo.contains(submitter) || divulgedTo.contains(submitter))\n-          Some(())\n-        else {\n-          tracelog(s\"lookupContract($coid): Contract not visible to submitter $submitter\")\n-          None\n-        }\n-\n-        // 2. Verify that the contract is active\n-        _ <- if (contractState.hasActiveAt && txLet >= parseTimestamp(contractState.getActiveAt))\n-          Some(())\n-        else {\n-          val activeAtStr =\n-            if (contractState.hasActiveAt)\n-              parseTimestamp(contractState.getActiveAt).toString\n-            else \"<activeAt missing>\"\n-          tracelog(\n-            s\"lookupContract($coid): Contract not active (let=$txLet, activeAt=$activeAtStr).\")\n-          None\n-        }\n-\n-        // Finally lookup the log entry containing the create node and the contract instance.\n-        entry = inputLogEntries\n-          .getOrElse(eid, throw Err.MissingInputLogEntry(eid))\n-        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n-      } yield (coinst)\n+    def contractVisibleToSubmitter(contractState: DamlContractState): Boolean = {\n+      val locallyDisclosedTo = contractState.getLocallyDisclosedToList.asScala.toSet\n+      val divulgedTo = contractState.getDivulgedToList.asScala.toSet\n+      locallyDisclosedTo.contains(submitter) || divulgedTo.contains(submitter)\n     }\n \n-    // Helper to lookup package from the state. The package contents\n-    // are stored in the [[DamlLogEntry]], which we find by looking up\n-    // the DAML state entry at `DamlStateKey(packageId = pkgId)`.\n-    def lookupPackage(pkgId: PackageId) = {\n-      val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId).build\n-      for {\n-        value <- inputState\n-          .get(stateKey)\n-          .flatten\n-          .orElse {\n-            throw Err.MissingInputState(stateKey)\n-          }\n-        pkg <- value.getValueCase match {\n-          case DamlStateValue.ValueCase.ARCHIVE =>\n-            // NOTE(JM): Engine only looks up packages once, compiles and caches,\n-            // provided that the engine instance is persisted.\n-            Some(Decode.decodeArchive(value.getArchive)._2)\n-          case _ =>\n-            tracelog(s\"lookupPackage($pkgId): value not a DAML-LF archive!\")\n-            None\n-        }\n-      } yield pkg\n-    }\n+    // Pull all keys from referenced contracts. We require this for 'fetchByKey' calls\n+    // which are not evidenced in the transaction itself and hence the contract key state is\n+    // not included in the inputs.\n+    lazy val knownKeys: Map[GlobalKey, AbsoluteContractId] =\n+      inputState.toList.collect {\n+        case (key, Some(value))\n+            if value.hasContractState\n+              && value.getContractState.hasContractKey\n+              && contractVisibleToSubmitter(value.getContractState) =>\n+          Conversions.decodeContractKey(value.getContractState.getContractKey) ->"
  },
  {
    "id" : "b9ca4af6-b3db-4ad1-bbad-10d3e78f4273",
    "prId" : 2304,
    "comments" : [
      {
        "id" : "b026b5de-8955-4397-828d-3a50b10348ec",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Do you think the following refactoring would make sense? Running the tests revealed no issue.\r\n\r\n```scala\r\n  private def lookupKey(\r\n      inputState: Map[DamlStateKey, Option[DamlStateValue]],\r\n      knownKeys: Map[GlobalKey, AbsoluteContractId],\r\n      submitter: String,\r\n      key: GlobalKey): Option[AbsoluteContractId] = {\r\n    def isVisibleToSubmitter(cs: DamlContractState, coid: AbsoluteContractId): Boolean = {\r\n      cs.getLocallyDisclosedToList.asScala.contains(submitter) || cs.getDivulgedToList.asScala\r\n        .contains(submitter) || {\r\n        logger.trace(s\"lookupKey($key): Contract $coid not visible to submitter $submitter.\")\r\n        false\r\n      }\r\n    }\r\n    inputState\r\n      .get(Conversions.contractKeyToStateKey(key))\r\n      .flatMap {\r\n        _.flatMap { value =>\r\n          for {\r\n            contractId <- Option(value.getContractKeyState.getContractId).map(decodeContractId)\r\n            contractStateKey = absoluteContractIdToStateKey(contractId)\r\n            contractState <- inputState.get(contractStateKey).flatMap(_.map(_.getContractState))\r\n            if isVisibleToSubmitter(contractState, contractId)\r\n          } yield contractId\r\n        }\r\n      }\r\n      // If the key was not in state inputs, then we look whether any of the accessed contracts\r\n      // has the key we're looking for. This happens with \"fetchByKey\" where the key lookup\r\n      // is not evidenced in the transaction.\r\n      .orElse(knownKeys.get(key))\r\n  }\r\n```",
        "createdAt" : "2019-07-29T08:40:54Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "22392fa3-86e5-4a40-a3a7-efee391f82a8",
        "parentId" : "b026b5de-8955-4397-828d-3a50b10348ec",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "thanks, looks much nicer!",
        "createdAt" : "2019-07-29T10:57:33Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c98f89bf6eb59cfe18c2a97d41daf898fb97679",
    "line" : 315,
    "diffHunk" : "@@ -485,6 +489,118 @@ object KeyValueCommitting {\n \n   // ------------------------------------------------------\n \n+  // Helper to lookup contract instances. We verify the activeness of\n+  // contract instances here. Since we look up every contract that was\n+  // an input to a transaction, we do not need to verify the inputs separately.\n+  private def lookupContract(\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]],\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      submitter: String,\n+      txLet: Timestamp,\n+      coid: AbsoluteContractId) = {\n+    val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n+    val stateKey = absoluteContractIdToStateKey(coid)\n+    for {\n+      // Fetch the state of the contract so that activeness and visibility can be checked.\n+      contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState)).orElse {\n+        logger.trace(s\"lookupContract($coid): Contract state not found!\")\n+        throw Err.MissingInputState(stateKey)\n+      }\n+      locallyDisclosedTo = contractState.getLocallyDisclosedToList.asScala.toSet\n+      divulgedTo = contractState.getDivulgedToList.asScala.toSet\n+\n+      // 1. Verify that the submitter can view the contract.\n+      _ <- if (locallyDisclosedTo.contains(submitter) || divulgedTo.contains(submitter))\n+        Some(())\n+      else {\n+        logger.trace(s\"lookupContract($coid): Contract not visible to submitter $submitter\")\n+        None\n+      }\n+\n+      // 2. Verify that the contract is active\n+      _ <- if (contractState.hasActiveAt && txLet >= parseTimestamp(contractState.getActiveAt))\n+        Some(())\n+      else {\n+        val activeAtStr =\n+          if (contractState.hasActiveAt)\n+            parseTimestamp(contractState.getActiveAt).toString\n+          else \"<activeAt missing>\"\n+        logger.trace(\n+          s\"lookupContract($coid): Contract not active (let=$txLet, activeAt=$activeAtStr).\")\n+        None\n+      }\n+\n+      // Finally lookup the log entry containing the create node and the contract instance.\n+      entry = inputLogEntries\n+        .getOrElse(eid, throw Err.MissingInputLogEntry(eid))\n+      coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n+    } yield (coinst)\n+  }\n+\n+  // Helper to lookup package from the state. The package contents\n+  // are stored in the [[DamlLogEntry]], which we find by looking up\n+  // the DAML state entry at `DamlStateKey(packageId = pkgId)`.\n+  def lookupPackage(inputState: Map[DamlStateKey, Option[DamlStateValue]], pkgId: PackageId) = {\n+    val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId).build\n+    for {\n+      value <- inputState\n+        .get(stateKey)\n+        .flatten\n+        .orElse {\n+          throw Err.MissingInputState(stateKey)\n+        }\n+      pkg <- value.getValueCase match {\n+        case DamlStateValue.ValueCase.ARCHIVE =>\n+          // NOTE(JM): Engine only looks up packages once, compiles and caches,\n+          // provided that the engine instance is persisted.\n+          Some(Decode.decodeArchive(value.getArchive)._2)\n+        case _ =>\n+          logger.trace(s\"lookupPackage($pkgId): value not a DAML-LF archive!\")\n+          None\n+      }\n+    } yield pkg\n+  }\n+\n+  private def lookupKey("
  },
  {
    "id" : "4df1b615-5b77-46fd-83b8-baa5d049319c",
    "prId" : 2304,
    "comments" : [
      {
        "id" : "c0b109ce-bc41-4fd5-a7e0-1aa7675a2451",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "`asScala` is cheap because it simply creates a view on top of the underlying Java collection. On the other hand, `toSet` traverses and copies the list. I'm not sure it's worth doing this for a single lookup. This comment applies to both lists in this method.",
        "createdAt" : "2019-07-29T08:50:50Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a12b31c8-b313-46ed-9884-c8f011c09bb8",
        "parentId" : "c0b109ce-bc41-4fd5-a7e0-1aa7675a2451",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "toSet makes sense if we'd actually share the computation, which we don't currently. And even if we did it probably wouldn't get called enough times anyway.. I'll drop the `toSet`.",
        "createdAt" : "2019-07-29T11:50:16Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c98f89bf6eb59cfe18c2a97d41daf898fb97679",
    "line" : null,
    "diffHunk" : "@@ -336,97 +337,81 @@ object KeyValueCommitting {\n         parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n     )\n \n-    // Helper to lookup contract instances. We verify the activeness of\n-    // contract instances here. Since we look up every contract that was\n-    // an input to a transaction, we do not need to verify the inputs separately.\n-    def lookupContract(coid: AbsoluteContractId) = {\n-      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n-      val stateKey = absoluteContractIdToStateKey(coid)\n-      for {\n-        // Fetch the state of the contract so that activeness and visibility can be checked.\n-        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState)).orElse {\n-          tracelog(s\"lookupContract($coid): Contract state not found!\")\n-          throw Err.MissingInputState(stateKey)\n-        }\n-        locallyDisclosedTo = contractState.getLocallyDisclosedToList.asScala.toSet\n-        divulgedTo = contractState.getDivulgedToList.asScala.toSet\n-        submitter = submitterInfo.getSubmitter\n-\n-        // 1. Verify that the submitter can view the contract.\n-        _ <- if (locallyDisclosedTo.contains(submitter) || divulgedTo.contains(submitter))\n-          Some(())\n-        else {\n-          tracelog(s\"lookupContract($coid): Contract not visible to submitter $submitter\")\n-          None\n-        }\n-\n-        // 2. Verify that the contract is active\n-        _ <- if (contractState.hasActiveAt && txLet >= parseTimestamp(contractState.getActiveAt))\n-          Some(())\n-        else {\n-          val activeAtStr =\n-            if (contractState.hasActiveAt)\n-              parseTimestamp(contractState.getActiveAt).toString\n-            else \"<activeAt missing>\"\n-          tracelog(\n-            s\"lookupContract($coid): Contract not active (let=$txLet, activeAt=$activeAtStr).\")\n-          None\n-        }\n-\n-        // Finally lookup the log entry containing the create node and the contract instance.\n-        entry = inputLogEntries\n-          .getOrElse(eid, throw Err.MissingInputLogEntry(eid))\n-        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n-      } yield (coinst)\n+    def contractVisibleToSubmitter(contractState: DamlContractState): Boolean = {\n+      val locallyDisclosedTo = contractState.getLocallyDisclosedToList.asScala.toSet"
  },
  {
    "id" : "160e3e6d-caf8-4ad1-af35-889b47afd95e",
    "prId" : 2304,
    "comments" : [
      {
        "id" : "377c9e12-edd2-4c90-8608-50a297123433",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Do you think the following refactoring makes sense? Running the tests found no issue.\r\n\r\n```scala\r\n  private def lookupContract(\r\n      inputState: Map[DamlStateKey, Option[DamlStateValue]],\r\n      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\r\n      submitter: String,\r\n      txLet: Timestamp,\r\n      coid: AbsoluteContractId) = {\r\n    def isVisibleToSubmitter(cs: DamlContractState): Boolean =\r\n      cs.getLocallyDisclosedToList.asScala.contains(submitter) || cs.getDivulgedToList.asScala\r\n        .contains(submitter) || {\r\n        logger.trace(s\"lookupContract($coid): Contract state not found!\")\r\n        false\r\n      }\r\n    def isActive(cs: DamlContractState): Boolean = {\r\n      val activeAt = Option(cs.getActiveAt).map(parseTimestamp)\r\n      activeAt.exists(txLet >= _) || {\r\n        val activeAtStr = activeAt.fold(\"<activeAt missing>\")(_.toString)\r\n        logger.trace(s\"lookupContract($coid): Contract not active (let=$txLet, activeAt=$activeAtStr).\")\r\n        false        \r\n      }\r\n    }      \r\n    val (eid, nid) = absoluteContractIdToLogEntryId(coid)\r\n    val stateKey = absoluteContractIdToStateKey(coid)\r\n    for {\r\n      // Fetch the state of the contract so that activeness and visibility can be checked.\r\n      contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState)).orElse {\r\n        logger.trace(s\"lookupContract($coid): Contract state not found!\")\r\n        throw Err.MissingInputState(stateKey)\r\n      }\r\n      if isVisibleToSubmitter(contractState) && isActive(contractState)\r\n      // Finally lookup the log entry containing the create node and the contract instance.\r\n      entry = inputLogEntries.getOrElse(eid, throw Err.MissingInputLogEntry(eid))\r\n      contract <- lookupContractInstanceFromLogEntry(eid, entry, nid)\r\n    } yield contract\r\n  }\r\n```",
        "createdAt" : "2019-07-29T09:06:29Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "12577d4f-9842-46b6-afad-7937ddd635d0",
        "parentId" : "377c9e12-edd2-4c90-8608-50a297123433",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "thanks, looks better.",
        "createdAt" : "2019-07-29T11:00:03Z",
        "updatedAt" : "2019-07-29T12:35:05Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c98f89bf6eb59cfe18c2a97d41daf898fb97679",
    "line" : 255,
    "diffHunk" : "@@ -485,6 +489,118 @@ object KeyValueCommitting {\n \n   // ------------------------------------------------------\n \n+  // Helper to lookup contract instances. We verify the activeness of\n+  // contract instances here. Since we look up every contract that was\n+  // an input to a transaction, we do not need to verify the inputs separately.\n+  private def lookupContract("
  },
  {
    "id" : "2cac9c09-ce2e-4340-83b6-83fdfd830ca4",
    "prId" : 1553,
    "comments" : [
      {
        "id" : "a0f9b9f6-e1f1-41b4-ba38-178ee29434a2",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "could as well just do `foldLeft(\"\")` and `packagesValidityError.isEmpty` etc.",
        "createdAt" : "2019-06-28T12:47:26Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b89ec3eec97b94cea04cfd27c4bf94180ecef4ca",
    "line" : null,
    "diffHunk" : "@@ -146,6 +142,157 @@ object KeyValueCommitting {\n     }\n   }\n \n+  private def processPackageUpload(\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      packageUploadEntry: DamlPackageUploadEntry,\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+    val submissionId = packageUploadEntry.getSubmissionId\n+    def tracelog(msg: String): Unit =\n+      logger.trace(\n+        s\"processPackageUpload[entryId=${prettyEntryId(entryId)}, submId=$submissionId]: $msg\")\n+\n+    val archives = packageUploadEntry.getArchivesList.asScala\n+    val packagesValidityResult =\n+      archives.foldLeft[(Boolean, String)]((true, \"\"))("
  },
  {
    "id" : "6ae5134d-1be2-4dca-879c-d95cc5e3dbb2",
    "prId" : 1553,
    "comments" : [
      {
        "id" : "9b2726dd-0a03-4619-82eb-01f7d5e8d8f2",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "swap this so we can read it more naturally: check for errors, handle the error, otherwise continue.",
        "createdAt" : "2019-06-28T12:47:51Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b89ec3eec97b94cea04cfd27c4bf94180ecef4ca",
    "line" : null,
    "diffHunk" : "@@ -146,6 +142,157 @@ object KeyValueCommitting {\n     }\n   }\n \n+  private def processPackageUpload(\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      packageUploadEntry: DamlPackageUploadEntry,\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+    val submissionId = packageUploadEntry.getSubmissionId\n+    def tracelog(msg: String): Unit =\n+      logger.trace(\n+        s\"processPackageUpload[entryId=${prettyEntryId(entryId)}, submId=$submissionId]: $msg\")\n+\n+    val archives = packageUploadEntry.getArchivesList.asScala\n+    val packagesValidityResult =\n+      archives.foldLeft[(Boolean, String)]((true, \"\"))(\n+        (acc, archive) =>\n+          if (archive.getPayload.isEmpty) (false, acc._2 ++ s\"empty package '${archive.getHash}';\")\n+          else acc)\n+\n+    if (packagesValidityResult._1) {"
  },
  {
    "id" : "e3924cae-194f-4966-b134-959d6a65156f",
    "prId" : 1553,
    "comments" : [
      {
        "id" : "124d4057-4871-4091-a097-632b96177fb0",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "tip: inner .build not needed as `setFoo` takes a `FooOrBuilder`",
        "createdAt" : "2019-06-28T12:48:16Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b89ec3eec97b94cea04cfd27c4bf94180ecef4ca",
    "line" : null,
    "diffHunk" : "@@ -146,6 +142,157 @@ object KeyValueCommitting {\n     }\n   }\n \n+  private def processPackageUpload(\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      packageUploadEntry: DamlPackageUploadEntry,\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+    val submissionId = packageUploadEntry.getSubmissionId\n+    def tracelog(msg: String): Unit =\n+      logger.trace(\n+        s\"processPackageUpload[entryId=${prettyEntryId(entryId)}, submId=$submissionId]: $msg\")\n+\n+    val archives = packageUploadEntry.getArchivesList.asScala\n+    val packagesValidityResult =\n+      archives.foldLeft[(Boolean, String)]((true, \"\"))(\n+        (acc, archive) =>\n+          if (archive.getPayload.isEmpty) (false, acc._2 ++ s\"empty package '${archive.getHash}';\")\n+          else acc)\n+\n+    if (packagesValidityResult._1) {\n+      val filteredArchives = archives\n+        .filter(\n+          archive =>\n+            inputState(\n+              DamlStateKey.newBuilder\n+                .setPackageId(archive.getHash)\n+                .build).isEmpty\n+        )\n+      tracelog(s\"\"\"Packages: ${archives\n+        .map(_.getHash)\n+        .mkString(\",\")} committed.\"\"\")\n+\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setPackageUploadEntry(\n+            DamlPackageUploadEntry.newBuilder\n+              .setSubmissionId(submissionId)\n+              .addAllArchives(filteredArchives.asJava)\n+              .setSourceDescription(packageUploadEntry.getSourceDescription)\n+              .setParticipantId(packageUploadEntry.getParticipantId)\n+              .build"
  },
  {
    "id" : "349e5dfd-da95-44aa-866c-7e2f2f880877",
    "prId" : 1553,
    "comments" : [
      {
        "id" : "eacff576-a15b-4613-8e70-fd984fcac956",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "log what invalid package it was and why it was invalid.",
        "createdAt" : "2019-06-28T12:48:48Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "753cca7e-1450-4868-9393-79ebc1e23071",
        "parentId" : "eacff576-a15b-4613-8e70-fd984fcac956",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Done",
        "createdAt" : "2019-07-01T08:48:20Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b89ec3eec97b94cea04cfd27c4bf94180ecef4ca",
    "line" : null,
    "diffHunk" : "@@ -146,6 +142,157 @@ object KeyValueCommitting {\n     }\n   }\n \n+  private def processPackageUpload(\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      packageUploadEntry: DamlPackageUploadEntry,\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+    val submissionId = packageUploadEntry.getSubmissionId\n+    def tracelog(msg: String): Unit =\n+      logger.trace(\n+        s\"processPackageUpload[entryId=${prettyEntryId(entryId)}, submId=$submissionId]: $msg\")\n+\n+    val archives = packageUploadEntry.getArchivesList.asScala\n+    val packagesValidityResult =\n+      archives.foldLeft[(Boolean, String)]((true, \"\"))(\n+        (acc, archive) =>\n+          if (archive.getPayload.isEmpty) (false, acc._2 ++ s\"empty package '${archive.getHash}';\")\n+          else acc)\n+\n+    if (packagesValidityResult._1) {\n+      val filteredArchives = archives\n+        .filter(\n+          archive =>\n+            inputState(\n+              DamlStateKey.newBuilder\n+                .setPackageId(archive.getHash)\n+                .build).isEmpty\n+        )\n+      tracelog(s\"\"\"Packages: ${archives\n+        .map(_.getHash)\n+        .mkString(\",\")} committed.\"\"\")\n+\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setPackageUploadEntry(\n+            DamlPackageUploadEntry.newBuilder\n+              .setSubmissionId(submissionId)\n+              .addAllArchives(filteredArchives.asJava)\n+              .setSourceDescription(packageUploadEntry.getSourceDescription)\n+              .setParticipantId(packageUploadEntry.getParticipantId)\n+              .build\n+          )\n+          .build,\n+        filteredArchives\n+          .map(\n+            archive =>\n+              (\n+                DamlStateKey.newBuilder.setPackageId(archive.getHash).build,\n+                DamlStateValue.newBuilder.setArchive(archive).build\n+            )\n+          )(breakOut)\n+      )\n+    } else {\n+      tracelog(s\"Packages upload failed, invalid package submitted\")"
  },
  {
    "id" : "d08a4afc-e471-46d3-925e-ca9ce8c68981",
    "prId" : 1553,
    "comments" : [
      {
        "id" : "e356c137-4df2-4542-a0e1-5aef3b2f81db",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "are the curlybraces needed?",
        "createdAt" : "2019-06-28T12:49:05Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e288ac83-b321-41e8-a6b6-3daf1a430916",
        "parentId" : "e356c137-4df2-4542-a0e1-5aef3b2f81db",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Done",
        "createdAt" : "2019-07-01T08:49:36Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b89ec3eec97b94cea04cfd27c4bf94180ecef4ca",
    "line" : null,
    "diffHunk" : "@@ -146,6 +142,157 @@ object KeyValueCommitting {\n     }\n   }\n \n+  private def processPackageUpload(\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      packageUploadEntry: DamlPackageUploadEntry,\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+    val submissionId = packageUploadEntry.getSubmissionId\n+    def tracelog(msg: String): Unit =\n+      logger.trace(\n+        s\"processPackageUpload[entryId=${prettyEntryId(entryId)}, submId=$submissionId]: $msg\")\n+\n+    val archives = packageUploadEntry.getArchivesList.asScala\n+    val packagesValidityResult =\n+      archives.foldLeft[(Boolean, String)]((true, \"\"))(\n+        (acc, archive) =>\n+          if (archive.getPayload.isEmpty) (false, acc._2 ++ s\"empty package '${archive.getHash}';\")\n+          else acc)\n+\n+    if (packagesValidityResult._1) {\n+      val filteredArchives = archives\n+        .filter(\n+          archive =>\n+            inputState(\n+              DamlStateKey.newBuilder\n+                .setPackageId(archive.getHash)\n+                .build).isEmpty\n+        )\n+      tracelog(s\"\"\"Packages: ${archives\n+        .map(_.getHash)\n+        .mkString(\",\")} committed.\"\"\")\n+\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setPackageUploadEntry(\n+            DamlPackageUploadEntry.newBuilder\n+              .setSubmissionId(submissionId)\n+              .addAllArchives(filteredArchives.asJava)\n+              .setSourceDescription(packageUploadEntry.getSourceDescription)\n+              .setParticipantId(packageUploadEntry.getParticipantId)\n+              .build\n+          )\n+          .build,\n+        filteredArchives\n+          .map(\n+            archive =>\n+              (\n+                DamlStateKey.newBuilder.setPackageId(archive.getHash).build,\n+                DamlStateValue.newBuilder.setArchive(archive).build\n+            )\n+          )(breakOut)\n+      )\n+    } else {\n+      tracelog(s\"Packages upload failed, invalid package submitted\")\n+      buildPackageRejectionLogEntry(recordTime, packageUploadEntry, {\n+        _.setInvalidPackage(packagesValidityResult._2)\n+      })"
  },
  {
    "id" : "f54ce74b-b585-4bdf-9311-f449388f72d4",
    "prId" : 1553,
    "comments" : [
      {
        "id" : "ebbcdd08-6fc2-42d3-a430-cb6abcddcda1",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Is that enough to check the validity of the payload? Shouldn't you try to parse the archive?",
        "createdAt" : "2019-06-28T14:09:19Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e17cd565-4fcd-4605-a2d9-21380d3c0abf",
        "parentId" : "ebbcdd08-6fc2-42d3-a430-cb6abcddcda1",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Well, the proper validation would go through a transitive closure of all the packages. It will have to be added at a later stage. We have agreed with Jussi to do the minimum at the moment. I can add a clear TODO in the code",
        "createdAt" : "2019-06-28T16:01:57Z",
        "updatedAt" : "2019-07-01T09:03:27Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b89ec3eec97b94cea04cfd27c4bf94180ecef4ca",
    "line" : null,
    "diffHunk" : "@@ -146,6 +142,157 @@ object KeyValueCommitting {\n     }\n   }\n \n+  private def processPackageUpload(\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      packageUploadEntry: DamlPackageUploadEntry,\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+    val submissionId = packageUploadEntry.getSubmissionId\n+    def tracelog(msg: String): Unit =\n+      logger.trace(\n+        s\"processPackageUpload[entryId=${prettyEntryId(entryId)}, submId=$submissionId]: $msg\")\n+\n+    val archives = packageUploadEntry.getArchivesList.asScala\n+    val packagesValidityResult =\n+      archives.foldLeft[(Boolean, String)]((true, \"\"))(\n+        (acc, archive) =>\n+          if (archive.getPayload.isEmpty) (false, acc._2 ++ s\"empty package '${archive.getHash}';\")"
  },
  {
    "id" : "72282484-bbed-4b5b-b1a4-e7672def0b3e",
    "prId" : 1498,
    "comments" : [
      {
        "id" : "15f55b17-7236-4d4b-99f2-4b9bead698d2",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "this could be done by depending on the state entries for each of the packages and then filtering out the ones that exist. it'll read all the data for them from the database though, so we might want to consider extending the interface a bit.",
        "createdAt" : "2019-06-05T21:55:07Z",
        "updatedAt" : "2019-06-07T06:35:42Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d9e588cf1df2d92d070ee8832d72044b4329a1a1",
    "line" : 23,
    "diffHunk" : "@@ -98,22 +99,26 @@ object KeyValueCommitting {\n \n     // Look at what kind of submission this is...\n     submission.getPayloadCase match {\n-      case DamlSubmission.PayloadCase.ARCHIVE =>\n-        val archive = submission.getArchive\n-        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+      case DamlSubmission.PayloadCase.PACKAGE_UPLOAD_ENTRY =>\n+        val archives = submission.getPackageUploadEntry.getArchivesList.asScala\n         // TODO(JM): We're duplicating the archive data. This way we don't have an indirection\n         // to fetch by packageId or when building [[Update]], and we don't have to declare\n         // the log entry containing the archive as an input (which would be messy).\n-        logger.trace(\n-          s\"processSubmission[entryId=${prettyEntryId(entryId)}]: Package ${archive.getHash} committed.\")\n+\n+        // TODO(MZ): Produce a DamlPackageUploadEntry that filters out pre-existing packages"
  },
  {
    "id" : "70fa0ae0-f5b9-428e-83a1-cdac48461158",
    "prId" : 1059,
    "comments" : [
      {
        "id" : "62ff7c3e-6b0a-4dce-a259-f6587b94efeb",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/mork/mark",
        "createdAt" : "2019-05-10T07:06:23Z",
        "updatedAt" : "2019-05-16T20:55:42Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f5f375b1320c49f59cc8305ef2225ebe5afaa54a",
    "line" : null,
    "diffHunk" : "@@ -63,7 +78,10 @@ object KeyValueCommitting {\n     * @param recordTime: Record time at which this log entry is committed.\n     * @param submission: Submission to commit to the ledger.\n     * @param inputLogEntries: Resolved input log entries specified in submission.\n-    * @param inputState: Resolved input state specified in submission. Potentially not all keys present, hence optional.\n+    * @param inputState:\n+    *   Resolved input state specified in submission. Optional to mork that input state was resolved"
  },
  {
    "id" : "1cb6f961-6383-4796-9ad0-26e263bd0eef",
    "prId" : 1059,
    "comments" : [
      {
        "id" : "929a4871-7d53-4d7e-a8df-bbf81e6726f9",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "This will lead to duplicate entries.",
        "createdAt" : "2019-05-10T07:16:38Z",
        "updatedAt" : "2019-05-16T20:55:42Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fb1b9e8f-8882-4c38-bae7-e86a0b5999a4",
        "parentId" : "929a4871-7d53-4d7e-a8df-bbf81e6726f9",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Uh oh, good catch. Thanks!",
        "createdAt" : "2019-05-13T13:54:53Z",
        "updatedAt" : "2019-05-16T20:55:42Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f5f375b1320c49f59cc8305ef2225ebe5afaa54a",
    "line" : null,
    "diffHunk" : "@@ -254,9 +283,22 @@ object KeyValueCommitting {\n         effects.createdContracts.foreach { key =>\n           val cs = DamlContractState.newBuilder\n           cs.setActiveAt(buildTimestamp(txLet))\n+          val localDisclosure =\n+            blindingInfo.localDisclosure(NodeId.unsafeFromIndex(key.getContractId.getNodeId.toInt))\n+          cs.addAllLocallyDisclosedTo((localDisclosure: Iterable[String]).asJava)\n           stateUpdates += key -> DamlStateValue.newBuilder.setContractState(cs).build\n         }\n \n+        // Update contract state of divulged contracts\n+        blindingInfo.globalImplicitDisclosure.foreach {\n+          case (absCoid, parties) =>\n+            val key = absoluteContractIdToStateKey(absCoid)\n+            val cs =\n+              inputState(key).getOrElse(throw Err.MissingInputState(key)).getContractState.toBuilder\n+            cs.addAllDivulgedTo((parties: Iterable[String]).asJava)"
  },
  {
    "id" : "6a779009-6c63-4262-9f95-fb72682644a5",
    "prId" : 637,
    "comments" : [
      {
        "id" : "abafe888-7049-4526-adda-8119f993cb82",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/DAML state entry/DAML state key",
        "createdAt" : "2019-04-26T13:25:33Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 48,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying"
  },
  {
    "id" : "c3569f55-9282-4ea1-8d54-dac43e5ffca8",
    "prId" : 637,
    "comments" : [
      {
        "id" : "95e1806b-76ea-4eed-9164-63fb33e4bad8",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Nice comment! Great help for the reader!",
        "createdAt" : "2019-04-26T13:25:45Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]"
  },
  {
    "id" : "46ae602c-b1ab-4a74-ba10-9d629d490956",
    "prId" : 637,
    "comments" : [
      {
        "id" : "da53b1ce-3b6e-41a0-8d23-148034d6e90b",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/state entry/state key\r\n\r\nAlso search and replace for that mistake.",
        "createdAt" : "2019-04-26T13:26:29Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing."
  },
  {
    "id" : "646fd070-3cca-4d2f-b6a7-767dbb7598ff",
    "prId" : 637,
    "comments" : [
      {
        "id" : "0e48361f-7278-46fb-b7bf-0d6c6f934526",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "comment",
        "createdAt" : "2019-04-26T13:27:28Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b0ce2a63-668b-4812-a753-19df95bb27e6",
        "parentId" : "0e48361f-7278-46fb-b7bf-0d6c6f934526",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "this is a completely internal method and would just duplicate the documentation from the above public method.",
        "createdAt" : "2019-04-26T13:49:56Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 115,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission("
  },
  {
    "id" : "4a0aa938-cb0d-493e-9636-64f2bd84c39b",
    "prId" : 637,
    "comments" : [
      {
        "id" : "30013c82-446a-4181-8a33-5704d9367d17",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "I believe it is enough. A written out justification will help becoming sure; and support readers in their reasoning.",
        "createdAt" : "2019-04-26T13:29:26Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      txEntry: DamlTransactionEntry,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    val txLet = parseTimestamp(txEntry.getLedgerEffectiveTime)\n+\n+    // 1. Verify that this is not a duplicate command submission.\n+    val dedupKey = commandDedupKey(txEntry.getSubmitterInfo)\n+    val dedupEntry = inputState(dedupKey)\n+    val dedupCheckResult = dedupEntry.isEmpty\n+\n+    // 2. Verify that the ledger effective time falls within time bounds\n+    val letCheckResult = config.timeModel.checkLet(\n+      currentTime = recordTime.toInstant,\n+      givenLedgerEffectiveTime = txLet.toInstant,\n+      givenMaximumRecordTime =\n+        parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n+    )\n+\n+    // 3. Verify that the input contracts are active.\n+    // FIXME(JM): Does this need to be done separately, or is it enough to\n+    // have lookupContract to check these?\n+    val activenessCheckResult = true"
  },
  {
    "id" : "8114b582-3386-4811-a3b7-cbf59555aff5",
    "prId" : 637,
    "comments" : [
      {
        "id" : "e65b58a9-d9b3-45a6-ab31-8e72983d46e9",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "comment on what's happening in here",
        "createdAt" : "2019-04-26T13:29:46Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 148,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      txEntry: DamlTransactionEntry,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    val txLet = parseTimestamp(txEntry.getLedgerEffectiveTime)\n+\n+    // 1. Verify that this is not a duplicate command submission.\n+    val dedupKey = commandDedupKey(txEntry.getSubmitterInfo)\n+    val dedupEntry = inputState(dedupKey)\n+    val dedupCheckResult = dedupEntry.isEmpty\n+\n+    // 2. Verify that the ledger effective time falls within time bounds\n+    val letCheckResult = config.timeModel.checkLet(\n+      currentTime = recordTime.toInstant,\n+      givenLedgerEffectiveTime = txLet.toInstant,\n+      givenMaximumRecordTime =\n+        parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n+    )\n+\n+    // 3. Verify that the input contracts are active.\n+    // FIXME(JM): Does this need to be done separately, or is it enough to\n+    // have lookupContract to check these?\n+    val activenessCheckResult = true\n+\n+    // 4. Verify that the submission conforms to the DAML model\n+    def lookupContract(coid: AbsoluteContractId) = {\n+      val (eid, nid) = absoluteContractIdToLogEntryId(coid)"
  },
  {
    "id" : "747d0375-bf60-47cc-8985-8c0151c8421e",
    "prId" : 637,
    "comments" : [
      {
        "id" : "31883869-69f2-4f46-ba93-374b0761f9c2",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "!! `reason` seems to be ignored!",
        "createdAt" : "2019-04-26T13:30:40Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7887da1e-7908-43af-a02e-46bc2fe8ba9e",
        "parentId" : "31883869-69f2-4f46-ba93-374b0761f9c2",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "how did this happen!? :D",
        "createdAt" : "2019-04-26T13:51:29Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      txEntry: DamlTransactionEntry,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    val txLet = parseTimestamp(txEntry.getLedgerEffectiveTime)\n+\n+    // 1. Verify that this is not a duplicate command submission.\n+    val dedupKey = commandDedupKey(txEntry.getSubmitterInfo)\n+    val dedupEntry = inputState(dedupKey)\n+    val dedupCheckResult = dedupEntry.isEmpty\n+\n+    // 2. Verify that the ledger effective time falls within time bounds\n+    val letCheckResult = config.timeModel.checkLet(\n+      currentTime = recordTime.toInstant,\n+      givenLedgerEffectiveTime = txLet.toInstant,\n+      givenMaximumRecordTime =\n+        parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n+    )\n+\n+    // 3. Verify that the input contracts are active.\n+    // FIXME(JM): Does this need to be done separately, or is it enough to\n+    // have lookupContract to check these?\n+    val activenessCheckResult = true\n+\n+    // 4. Verify that the submission conforms to the DAML model\n+    def lookupContract(coid: AbsoluteContractId) = {\n+      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n+      val stateKey = absoluteContractIdToStateKey(coid)\n+      for {\n+        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState))\n+        if txLet > parseTimestamp(contractState.getActiveAt) && !contractState.hasActiveAt\n+        entry <- inputLogEntries.get(eid)\n+        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n+      } yield (coinst)\n+    }\n+\n+    def lookupPackage(pkgId: PackageId) = {\n+      val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId.underlyingString).build\n+      inputState\n+        .get(stateKey)\n+        .flatMap(identity)\n+        .flatMap { value =>\n+          inputLogEntries.get(value.getArchiveEntry)\n+        }\n+        .flatMap { entry =>\n+          entry.getPayloadCase match {\n+            case DamlLogEntry.PayloadCase.ARCHIVE =>\n+              // NOTE(JM): Engine only looks up packages once, compiles and caches,\n+              // provided that the engine instance is persisted.\n+              Try(Decode.decodeArchive(entry.getArchive)._2).toOption\n+            case _ =>\n+              None\n+          }\n+        }\n+    }\n+\n+    val relTx = Conversions.decodeTransaction(txEntry.getTransaction)\n+    val modelCheckResult = engine\n+      .validate(relTx, txLet)\n+      .consume(lookupContract, lookupPackage, _ => sys.error(\"contract keys unimplemented\"))\n+\n+    def reject(reason: RejectionReason): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setRejectionEntry(\n+            buildRejectionEntry(txEntry, RejectionReason.DuplicateCommand)"
  },
  {
    "id" : "9739f4be-ee6a-4dc9-8949-955d547ea65e",
    "prId" : 637,
    "comments" : [
      {
        "id" : "da60ff83-9c92-4065-aba2-cdf7b6366b78",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "add comments explaining each of the steps. Also helps double-check that all state that is checked up front is modified here.",
        "createdAt" : "2019-04-26T13:31:46Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 229,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      txEntry: DamlTransactionEntry,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    val txLet = parseTimestamp(txEntry.getLedgerEffectiveTime)\n+\n+    // 1. Verify that this is not a duplicate command submission.\n+    val dedupKey = commandDedupKey(txEntry.getSubmitterInfo)\n+    val dedupEntry = inputState(dedupKey)\n+    val dedupCheckResult = dedupEntry.isEmpty\n+\n+    // 2. Verify that the ledger effective time falls within time bounds\n+    val letCheckResult = config.timeModel.checkLet(\n+      currentTime = recordTime.toInstant,\n+      givenLedgerEffectiveTime = txLet.toInstant,\n+      givenMaximumRecordTime =\n+        parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n+    )\n+\n+    // 3. Verify that the input contracts are active.\n+    // FIXME(JM): Does this need to be done separately, or is it enough to\n+    // have lookupContract to check these?\n+    val activenessCheckResult = true\n+\n+    // 4. Verify that the submission conforms to the DAML model\n+    def lookupContract(coid: AbsoluteContractId) = {\n+      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n+      val stateKey = absoluteContractIdToStateKey(coid)\n+      for {\n+        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState))\n+        if txLet > parseTimestamp(contractState.getActiveAt) && !contractState.hasActiveAt\n+        entry <- inputLogEntries.get(eid)\n+        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n+      } yield (coinst)\n+    }\n+\n+    def lookupPackage(pkgId: PackageId) = {\n+      val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId.underlyingString).build\n+      inputState\n+        .get(stateKey)\n+        .flatMap(identity)\n+        .flatMap { value =>\n+          inputLogEntries.get(value.getArchiveEntry)\n+        }\n+        .flatMap { entry =>\n+          entry.getPayloadCase match {\n+            case DamlLogEntry.PayloadCase.ARCHIVE =>\n+              // NOTE(JM): Engine only looks up packages once, compiles and caches,\n+              // provided that the engine instance is persisted.\n+              Try(Decode.decodeArchive(entry.getArchive)._2).toOption\n+            case _ =>\n+              None\n+          }\n+        }\n+    }\n+\n+    val relTx = Conversions.decodeTransaction(txEntry.getTransaction)\n+    val modelCheckResult = engine\n+      .validate(relTx, txLet)\n+      .consume(lookupContract, lookupPackage, _ => sys.error(\"contract keys unimplemented\"))\n+\n+    def reject(reason: RejectionReason): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setRejectionEntry(\n+            buildRejectionEntry(txEntry, RejectionReason.DuplicateCommand)\n+          )\n+          .build,\n+        Map.empty\n+      )\n+\n+    // FIXME(JM): Refactor this?\n+    (dedupCheckResult, letCheckResult, activenessCheckResult, modelCheckResult) match {\n+      case (false, _, _, _) =>\n+        reject(RejectionReason.DuplicateCommand)\n+\n+      case (_, false, _, _) =>\n+        reject(RejectionReason.MaximumRecordTimeExceeded)\n+\n+      case (_, _, false, _) =>\n+        reject(RejectionReason.Inconsistent)\n+\n+      case (true, true, true, Left(err)) =>\n+        reject(RejectionReason.Disputed(err.msg)) // FIXME(JM): or detailMsg?\n+\n+      case (true, true, true, Right(())) =>\n+        // All checks passed. Return transaction log entry, and update the DAML state\n+        // with the committed command and the created and consumed contracts.\n+\n+        var stateUpdates = scala.collection.mutable.Map.empty[DamlStateKey, DamlStateValue]"
  },
  {
    "id" : "ca05214e-ee77-4c38-90f2-2e63b17b82eb",
    "prId" : 637,
    "comments" : [
      {
        "id" : "19cad2c3-1be6-4348-ac0d-329e4dd0046d",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "We seem to not be creating this rejection-reason. Should we? Should we add a link to an issue? Or a least a TODO?",
        "createdAt" : "2019-04-26T13:34:58Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      txEntry: DamlTransactionEntry,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    val txLet = parseTimestamp(txEntry.getLedgerEffectiveTime)\n+\n+    // 1. Verify that this is not a duplicate command submission.\n+    val dedupKey = commandDedupKey(txEntry.getSubmitterInfo)\n+    val dedupEntry = inputState(dedupKey)\n+    val dedupCheckResult = dedupEntry.isEmpty\n+\n+    // 2. Verify that the ledger effective time falls within time bounds\n+    val letCheckResult = config.timeModel.checkLet(\n+      currentTime = recordTime.toInstant,\n+      givenLedgerEffectiveTime = txLet.toInstant,\n+      givenMaximumRecordTime =\n+        parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n+    )\n+\n+    // 3. Verify that the input contracts are active.\n+    // FIXME(JM): Does this need to be done separately, or is it enough to\n+    // have lookupContract to check these?\n+    val activenessCheckResult = true\n+\n+    // 4. Verify that the submission conforms to the DAML model\n+    def lookupContract(coid: AbsoluteContractId) = {\n+      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n+      val stateKey = absoluteContractIdToStateKey(coid)\n+      for {\n+        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState))\n+        if txLet > parseTimestamp(contractState.getActiveAt) && !contractState.hasActiveAt\n+        entry <- inputLogEntries.get(eid)\n+        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n+      } yield (coinst)\n+    }\n+\n+    def lookupPackage(pkgId: PackageId) = {\n+      val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId.underlyingString).build\n+      inputState\n+        .get(stateKey)\n+        .flatMap(identity)\n+        .flatMap { value =>\n+          inputLogEntries.get(value.getArchiveEntry)\n+        }\n+        .flatMap { entry =>\n+          entry.getPayloadCase match {\n+            case DamlLogEntry.PayloadCase.ARCHIVE =>\n+              // NOTE(JM): Engine only looks up packages once, compiles and caches,\n+              // provided that the engine instance is persisted.\n+              Try(Decode.decodeArchive(entry.getArchive)._2).toOption\n+            case _ =>\n+              None\n+          }\n+        }\n+    }\n+\n+    val relTx = Conversions.decodeTransaction(txEntry.getTransaction)\n+    val modelCheckResult = engine\n+      .validate(relTx, txLet)\n+      .consume(lookupContract, lookupPackage, _ => sys.error(\"contract keys unimplemented\"))\n+\n+    def reject(reason: RejectionReason): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setRejectionEntry(\n+            buildRejectionEntry(txEntry, RejectionReason.DuplicateCommand)\n+          )\n+          .build,\n+        Map.empty\n+      )\n+\n+    // FIXME(JM): Refactor this?\n+    (dedupCheckResult, letCheckResult, activenessCheckResult, modelCheckResult) match {\n+      case (false, _, _, _) =>\n+        reject(RejectionReason.DuplicateCommand)\n+\n+      case (_, false, _, _) =>\n+        reject(RejectionReason.MaximumRecordTimeExceeded)\n+\n+      case (_, _, false, _) =>\n+        reject(RejectionReason.Inconsistent)\n+\n+      case (true, true, true, Left(err)) =>\n+        reject(RejectionReason.Disputed(err.msg)) // FIXME(JM): or detailMsg?\n+\n+      case (true, true, true, Right(())) =>\n+        // All checks passed. Return transaction log entry, and update the DAML state\n+        // with the committed command and the created and consumed contracts.\n+\n+        var stateUpdates = scala.collection.mutable.Map.empty[DamlStateKey, DamlStateValue]\n+        stateUpdates += commandDedupKey(txEntry.getSubmitterInfo) -> emptyDamlStateValue\n+        val effects = InputsAndEffects.computeEffects(entryId, relTx)\n+        effects.consumedContracts.foreach { key =>\n+          val cs = inputState(key).fold(DamlContractState.newBuilder)(_.getContractState.toBuilder) // FIXME(JM): Previous contract state should always be there\n+          cs.setArchivedAt(buildTimestamp(recordTime))\n+          cs.setArchivedByEntry(entryId)\n+          stateUpdates += key -> DamlStateValue.newBuilder.setContractState(cs.build).build\n+        }\n+        effects.createdContracts.foreach { key =>\n+          val cs = DamlContractState.newBuilder\n+          cs.setActiveAt(buildTimestamp(recordTime))\n+          stateUpdates += key -> DamlStateValue.newBuilder.setContractState(cs).build\n+        }\n+\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setTransactionEntry(txEntry)\n+            .build,\n+          stateUpdates.toMap\n+        )\n+    }\n+  }\n+\n+  // ------------------------------------------------------\n+\n+  private def buildRejectionEntry(\n+      txEntry: DamlTransactionEntry,\n+      reason: RejectionReason): DamlRejectionEntry = {\n+    val builder = DamlRejectionEntry.newBuilder\n+    builder\n+      .setSubmitterInfo(txEntry.getSubmitterInfo)\n+\n+    reason match {\n+      case RejectionReason.Inconsistent =>\n+        builder.setInconsistent(\"\")\n+      case RejectionReason.Disputed(disputeReason) =>\n+        builder.setDisputed(disputeReason)\n+      case RejectionReason.ResourcesExhausted =>\n+        builder.setResourcesExhausted(\"\")\n+      case RejectionReason.MaximumRecordTimeExceeded =>\n+        builder.setMaximumRecordTimeExceeded(\"\")\n+      case RejectionReason.DuplicateCommand =>\n+        builder.setDuplicateCommand(\"\")\n+      case RejectionReason.PartyNotKnownOnLedger =>\n+        builder.setPartyNotKnownOnLedger(\"\")"
  },
  {
    "id" : "20995a87-9185-4b8d-aea8-26cb5c24b569",
    "prId" : 637,
    "comments" : [
      {
        "id" : "a82e8498-5464-4721-b0a1-97faa5913a26",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "It seems that we are missing a check or the ability for a check that produces this violation!",
        "createdAt" : "2019-04-26T13:35:36Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bd054d39-3392-47f4-8b7a-8d9986258a7e",
        "parentId" : "a82e8498-5464-4721-b0a1-97faa5913a26",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Probably create a ticket to delay that work.",
        "createdAt" : "2019-04-26T13:35:46Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      txEntry: DamlTransactionEntry,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    val txLet = parseTimestamp(txEntry.getLedgerEffectiveTime)\n+\n+    // 1. Verify that this is not a duplicate command submission.\n+    val dedupKey = commandDedupKey(txEntry.getSubmitterInfo)\n+    val dedupEntry = inputState(dedupKey)\n+    val dedupCheckResult = dedupEntry.isEmpty\n+\n+    // 2. Verify that the ledger effective time falls within time bounds\n+    val letCheckResult = config.timeModel.checkLet(\n+      currentTime = recordTime.toInstant,\n+      givenLedgerEffectiveTime = txLet.toInstant,\n+      givenMaximumRecordTime =\n+        parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n+    )\n+\n+    // 3. Verify that the input contracts are active.\n+    // FIXME(JM): Does this need to be done separately, or is it enough to\n+    // have lookupContract to check these?\n+    val activenessCheckResult = true\n+\n+    // 4. Verify that the submission conforms to the DAML model\n+    def lookupContract(coid: AbsoluteContractId) = {\n+      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n+      val stateKey = absoluteContractIdToStateKey(coid)\n+      for {\n+        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState))\n+        if txLet > parseTimestamp(contractState.getActiveAt) && !contractState.hasActiveAt\n+        entry <- inputLogEntries.get(eid)\n+        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n+      } yield (coinst)\n+    }\n+\n+    def lookupPackage(pkgId: PackageId) = {\n+      val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId.underlyingString).build\n+      inputState\n+        .get(stateKey)\n+        .flatMap(identity)\n+        .flatMap { value =>\n+          inputLogEntries.get(value.getArchiveEntry)\n+        }\n+        .flatMap { entry =>\n+          entry.getPayloadCase match {\n+            case DamlLogEntry.PayloadCase.ARCHIVE =>\n+              // NOTE(JM): Engine only looks up packages once, compiles and caches,\n+              // provided that the engine instance is persisted.\n+              Try(Decode.decodeArchive(entry.getArchive)._2).toOption\n+            case _ =>\n+              None\n+          }\n+        }\n+    }\n+\n+    val relTx = Conversions.decodeTransaction(txEntry.getTransaction)\n+    val modelCheckResult = engine\n+      .validate(relTx, txLet)\n+      .consume(lookupContract, lookupPackage, _ => sys.error(\"contract keys unimplemented\"))\n+\n+    def reject(reason: RejectionReason): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setRejectionEntry(\n+            buildRejectionEntry(txEntry, RejectionReason.DuplicateCommand)\n+          )\n+          .build,\n+        Map.empty\n+      )\n+\n+    // FIXME(JM): Refactor this?\n+    (dedupCheckResult, letCheckResult, activenessCheckResult, modelCheckResult) match {\n+      case (false, _, _, _) =>\n+        reject(RejectionReason.DuplicateCommand)\n+\n+      case (_, false, _, _) =>\n+        reject(RejectionReason.MaximumRecordTimeExceeded)\n+\n+      case (_, _, false, _) =>\n+        reject(RejectionReason.Inconsistent)\n+\n+      case (true, true, true, Left(err)) =>\n+        reject(RejectionReason.Disputed(err.msg)) // FIXME(JM): or detailMsg?\n+\n+      case (true, true, true, Right(())) =>\n+        // All checks passed. Return transaction log entry, and update the DAML state\n+        // with the committed command and the created and consumed contracts.\n+\n+        var stateUpdates = scala.collection.mutable.Map.empty[DamlStateKey, DamlStateValue]\n+        stateUpdates += commandDedupKey(txEntry.getSubmitterInfo) -> emptyDamlStateValue\n+        val effects = InputsAndEffects.computeEffects(entryId, relTx)\n+        effects.consumedContracts.foreach { key =>\n+          val cs = inputState(key).fold(DamlContractState.newBuilder)(_.getContractState.toBuilder) // FIXME(JM): Previous contract state should always be there\n+          cs.setArchivedAt(buildTimestamp(recordTime))\n+          cs.setArchivedByEntry(entryId)\n+          stateUpdates += key -> DamlStateValue.newBuilder.setContractState(cs.build).build\n+        }\n+        effects.createdContracts.foreach { key =>\n+          val cs = DamlContractState.newBuilder\n+          cs.setActiveAt(buildTimestamp(recordTime))\n+          stateUpdates += key -> DamlStateValue.newBuilder.setContractState(cs).build\n+        }\n+\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setTransactionEntry(txEntry)\n+            .build,\n+          stateUpdates.toMap\n+        )\n+    }\n+  }\n+\n+  // ------------------------------------------------------\n+\n+  private def buildRejectionEntry(\n+      txEntry: DamlTransactionEntry,\n+      reason: RejectionReason): DamlRejectionEntry = {\n+    val builder = DamlRejectionEntry.newBuilder\n+    builder\n+      .setSubmitterInfo(txEntry.getSubmitterInfo)\n+\n+    reason match {\n+      case RejectionReason.Inconsistent =>\n+        builder.setInconsistent(\"\")\n+      case RejectionReason.Disputed(disputeReason) =>\n+        builder.setDisputed(disputeReason)\n+      case RejectionReason.ResourcesExhausted =>\n+        builder.setResourcesExhausted(\"\")\n+      case RejectionReason.MaximumRecordTimeExceeded =>\n+        builder.setMaximumRecordTimeExceeded(\"\")\n+      case RejectionReason.DuplicateCommand =>\n+        builder.setDuplicateCommand(\"\")\n+      case RejectionReason.PartyNotKnownOnLedger =>\n+        builder.setPartyNotKnownOnLedger(\"\")\n+      case RejectionReason.SubmitterCannotActViaParticipant(details) =>\n+        builder.setSubmitterCannotActViaParticipant(details)"
  },
  {
    "id" : "70295d96-7d9b-4429-8e28-be539ab09014",
    "prId" : 637,
    "comments" : [
      {
        "id" : "6148d021-1263-41ae-af7a-82632f7227d1",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Add note and link to backlog (https://github.com/digital-asset/daml/milestone/5) for flat transaction representation that avoids deserializing contracts that are not accessed.",
        "createdAt" : "2019-04-26T13:37:15Z",
        "updatedAt" : "2019-04-29T09:35:03Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5b2167d99861a69fd3366ab5fb08acc35514642",
    "line" : 311,
    "diffHunk" : "@@ -0,0 +1,279 @@\n+package com.daml.ledger.participant.state.kvutils\n+\n+import com.daml.ledger.participant.state.kvutils.Conversions._\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.v1.{Configuration, PackageId, RejectionReason}\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.lfpackage.Decode\n+import com.digitalasset.daml.lf.transaction.Node.NodeCreate\n+import com.digitalasset.daml.lf.transaction.Transaction\n+import com.digitalasset.daml.lf.value.Value.{\n+  AbsoluteContractId,\n+  ContractId,\n+  ContractInst,\n+  NodeId,\n+  VersionedValue\n+}\n+import com.google.protobuf.ByteString\n+\n+import scala.util.Try\n+\n+object KeyValueCommitting {\n+\n+  def packDamlStateKey(key: DamlStateKey): ByteString = key.toByteString\n+  def unpackDamlStateKey(bytes: ByteString): DamlStateKey = DamlStateKey.parseFrom(bytes)\n+\n+  def packDamlStateValue(value: DamlStateValue): ByteString = value.toByteString\n+  def unpackDamlStateValue(bytes: ByteString): DamlStateValue = DamlStateValue.parseFrom(bytes)\n+\n+  def packDamlLogEntry(entry: DamlLogEntry): ByteString = entry.toByteString\n+  def unpackDamLLogEntry(bytes: ByteString): DamlLogEntry = DamlLogEntry.parseFrom(bytes)\n+\n+  /** Processes a DAML submission, given the allocated log entry id, the submission and its resolved inputs.\n+    * Produces the log entry to be committed, and DAML state updates.\n+    *\n+    * The caller is expected to resolve the inputs declared in [[DamlSubmission]] prior\n+    * to calling this method, e.g. by reading [[DamlSubmission.getInputEntriesList]] and\n+    * [[DamlSubmission.getInputStateList]]\n+    *\n+    * The caller is expected to store the produced [[DamlLogEntry]] in key-value store at a location\n+    * that can be accessed through `entryId`. The DAML state updates may create new entries or update\n+    * existing entries in the key-value store. The concrete key for DAML state entry is obtained by applying\n+    * [[packDamlStateKey]] to [[DamlStateKey]].\n+    *\n+    * @param engine: The DAML Engine. This instance should be persistent as it caches package compilation.\n+    * @param config: The ledger configuration.\n+    * @param entryId: The log entry id to which this submission is committed.\n+    * @param recordTime: The record time for the log entry.\n+    * @param submission: The submission to commit to the ledger.\n+    * @param inputLogEntries: The resolved inputs to the submission.\n+    * @param inputState: The input DAML state entries. Some state entries declared as input can be missing.\n+    * @return The log entry to be committed and the DAML state updates.\n+    */\n+  def processSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      submission: DamlSubmission,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    submission.getPayloadCase match {\n+      case DamlSubmission.PayloadCase.ARCHIVE =>\n+        val archive = submission.getArchive\n+        val key = DamlStateKey.newBuilder.setPackageId(archive.getHash).build\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setArchive(archive)\n+            .build,\n+          Map(\n+            key -> DamlStateValue.newBuilder.setArchiveEntry(entryId).build\n+          )\n+        )\n+      case DamlSubmission.PayloadCase.CONFIGURATION_ENTRY =>\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setConfigurationEntry(submission.getConfigurationEntry)\n+            .build,\n+          Map.empty\n+        )\n+      case DamlSubmission.PayloadCase.TRANSACTION_ENTRY =>\n+        processTransactionSubmission(\n+          engine,\n+          config,\n+          entryId,\n+          recordTime,\n+          submission.getTransactionEntry,\n+          inputLogEntries,\n+          inputState\n+        )\n+\n+      case DamlSubmission.PayloadCase.PAYLOAD_NOT_SET =>\n+        throw new RuntimeException(\"DamlSubmission payload not set!\")\n+    }\n+  }\n+\n+  private def processTransactionSubmission(\n+      engine: Engine,\n+      config: Configuration,\n+      entryId: DamlLogEntryId,\n+      recordTime: Timestamp,\n+      txEntry: DamlTransactionEntry,\n+      inputLogEntries: Map[DamlLogEntryId, DamlLogEntry],\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]]\n+  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) = {\n+\n+    val txLet = parseTimestamp(txEntry.getLedgerEffectiveTime)\n+\n+    // 1. Verify that this is not a duplicate command submission.\n+    val dedupKey = commandDedupKey(txEntry.getSubmitterInfo)\n+    val dedupEntry = inputState(dedupKey)\n+    val dedupCheckResult = dedupEntry.isEmpty\n+\n+    // 2. Verify that the ledger effective time falls within time bounds\n+    val letCheckResult = config.timeModel.checkLet(\n+      currentTime = recordTime.toInstant,\n+      givenLedgerEffectiveTime = txLet.toInstant,\n+      givenMaximumRecordTime =\n+        parseTimestamp(txEntry.getSubmitterInfo.getMaximumRecordTime).toInstant\n+    )\n+\n+    // 3. Verify that the input contracts are active.\n+    // FIXME(JM): Does this need to be done separately, or is it enough to\n+    // have lookupContract to check these?\n+    val activenessCheckResult = true\n+\n+    // 4. Verify that the submission conforms to the DAML model\n+    def lookupContract(coid: AbsoluteContractId) = {\n+      val (eid, nid) = absoluteContractIdToLogEntryId(coid)\n+      val stateKey = absoluteContractIdToStateKey(coid)\n+      for {\n+        contractState <- inputState.get(stateKey).flatMap(_.map(_.getContractState))\n+        if txLet > parseTimestamp(contractState.getActiveAt) && !contractState.hasActiveAt\n+        entry <- inputLogEntries.get(eid)\n+        coinst <- lookupContractInstanceFromLogEntry(eid, entry, nid)\n+      } yield (coinst)\n+    }\n+\n+    def lookupPackage(pkgId: PackageId) = {\n+      val stateKey = DamlStateKey.newBuilder.setPackageId(pkgId.underlyingString).build\n+      inputState\n+        .get(stateKey)\n+        .flatMap(identity)\n+        .flatMap { value =>\n+          inputLogEntries.get(value.getArchiveEntry)\n+        }\n+        .flatMap { entry =>\n+          entry.getPayloadCase match {\n+            case DamlLogEntry.PayloadCase.ARCHIVE =>\n+              // NOTE(JM): Engine only looks up packages once, compiles and caches,\n+              // provided that the engine instance is persisted.\n+              Try(Decode.decodeArchive(entry.getArchive)._2).toOption\n+            case _ =>\n+              None\n+          }\n+        }\n+    }\n+\n+    val relTx = Conversions.decodeTransaction(txEntry.getTransaction)\n+    val modelCheckResult = engine\n+      .validate(relTx, txLet)\n+      .consume(lookupContract, lookupPackage, _ => sys.error(\"contract keys unimplemented\"))\n+\n+    def reject(reason: RejectionReason): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n+      (\n+        DamlLogEntry.newBuilder\n+          .setRecordTime(buildTimestamp(recordTime))\n+          .setRejectionEntry(\n+            buildRejectionEntry(txEntry, RejectionReason.DuplicateCommand)\n+          )\n+          .build,\n+        Map.empty\n+      )\n+\n+    // FIXME(JM): Refactor this?\n+    (dedupCheckResult, letCheckResult, activenessCheckResult, modelCheckResult) match {\n+      case (false, _, _, _) =>\n+        reject(RejectionReason.DuplicateCommand)\n+\n+      case (_, false, _, _) =>\n+        reject(RejectionReason.MaximumRecordTimeExceeded)\n+\n+      case (_, _, false, _) =>\n+        reject(RejectionReason.Inconsistent)\n+\n+      case (true, true, true, Left(err)) =>\n+        reject(RejectionReason.Disputed(err.msg)) // FIXME(JM): or detailMsg?\n+\n+      case (true, true, true, Right(())) =>\n+        // All checks passed. Return transaction log entry, and update the DAML state\n+        // with the committed command and the created and consumed contracts.\n+\n+        var stateUpdates = scala.collection.mutable.Map.empty[DamlStateKey, DamlStateValue]\n+        stateUpdates += commandDedupKey(txEntry.getSubmitterInfo) -> emptyDamlStateValue\n+        val effects = InputsAndEffects.computeEffects(entryId, relTx)\n+        effects.consumedContracts.foreach { key =>\n+          val cs = inputState(key).fold(DamlContractState.newBuilder)(_.getContractState.toBuilder) // FIXME(JM): Previous contract state should always be there\n+          cs.setArchivedAt(buildTimestamp(recordTime))\n+          cs.setArchivedByEntry(entryId)\n+          stateUpdates += key -> DamlStateValue.newBuilder.setContractState(cs.build).build\n+        }\n+        effects.createdContracts.foreach { key =>\n+          val cs = DamlContractState.newBuilder\n+          cs.setActiveAt(buildTimestamp(recordTime))\n+          stateUpdates += key -> DamlStateValue.newBuilder.setContractState(cs).build\n+        }\n+\n+        (\n+          DamlLogEntry.newBuilder\n+            .setRecordTime(buildTimestamp(recordTime))\n+            .setTransactionEntry(txEntry)\n+            .build,\n+          stateUpdates.toMap\n+        )\n+    }\n+  }\n+\n+  // ------------------------------------------------------\n+\n+  private def buildRejectionEntry(\n+      txEntry: DamlTransactionEntry,\n+      reason: RejectionReason): DamlRejectionEntry = {\n+    val builder = DamlRejectionEntry.newBuilder\n+    builder\n+      .setSubmitterInfo(txEntry.getSubmitterInfo)\n+\n+    reason match {\n+      case RejectionReason.Inconsistent =>\n+        builder.setInconsistent(\"\")\n+      case RejectionReason.Disputed(disputeReason) =>\n+        builder.setDisputed(disputeReason)\n+      case RejectionReason.ResourcesExhausted =>\n+        builder.setResourcesExhausted(\"\")\n+      case RejectionReason.MaximumRecordTimeExceeded =>\n+        builder.setMaximumRecordTimeExceeded(\"\")\n+      case RejectionReason.DuplicateCommand =>\n+        builder.setDuplicateCommand(\"\")\n+      case RejectionReason.PartyNotKnownOnLedger =>\n+        builder.setPartyNotKnownOnLedger(\"\")\n+      case RejectionReason.SubmitterCannotActViaParticipant(details) =>\n+        builder.setSubmitterCannotActViaParticipant(details)\n+    }\n+    builder.build\n+  }\n+\n+  private val emptyDamlStateValue: DamlStateValue =\n+    DamlStateValue.newBuilder\n+      .setEmpty(com.google.protobuf.Empty.newBuilder.build)\n+      .build\n+\n+  /** Look up the contract instance from the log entry containing the transaction."
  }
]