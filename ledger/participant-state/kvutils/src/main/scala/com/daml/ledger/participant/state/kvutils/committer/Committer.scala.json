[
  {
    "id" : "c03f4ca6-5426-4d96-aac9-c94de11e1b22",
    "prId" : 6737,
    "comments" : [
      {
        "id" : "10c7f74d-6120-43db-9f94-c0ce57e46aff",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n      logEntry -> commitContext.getOutputs.toMap\r\n```",
        "createdAt" : "2020-07-15T11:57:36Z",
        "updatedAt" : "2020-07-15T12:13:40Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8fff4446-84b0-4238-8b1c-a47084c04654",
        "parentId" : "10c7f74d-6120-43db-9f94-c0ce57e46aff",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Will fix this after the snapshot release.",
        "createdAt" : "2020-07-15T12:59:32Z",
        "updatedAt" : "2020-07-15T12:59:32Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9bce5cb9fbcf790218a9e6ffd3f16db460d55a0a",
    "line" : 11,
    "diffHunk" : "@@ -89,10 +89,7 @@ private[committer] trait Committer[PartialResult] extends SubmissionExecutor {\n \n         override def getParticipantId: ParticipantId = participantId\n \n-        override def inputsWithFingerprints: DamlStateMapWithFingerprints =\n-          inputState.map {\n-            case (key, value) => (key, (value, FingerprintPlaceholder))\n-          }\n+        override val inputs: DamlStateMap = inputState\n       }\n       val logEntry = runSteps(ctx, submission)\n       logEntry -> ctx.getOutputs.toMap"
  },
  {
    "id" : "cfd00c52-bded-4a3c-ab9e-ff163a676844",
    "prId" : 6592,
    "comments" : [
      {
        "id" : "367ae375-33e1-4a42-a818-95d7fff3fa30",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Simpler:\r\n```suggestion\r\n    recordTime.fold(logEntryBuilder)(timestamp => logEntryBuilder.setRecordTime(buildTimestamp(timestamp)))\r\n```",
        "createdAt" : "2020-07-03T07:31:22Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55fbe3cc0a4ea1575e54fc6873803e8129a24e49",
    "line" : null,
    "diffHunk" : "@@ -129,6 +172,8 @@ object Committer {\n \n   private def setRecordTimeIfAvailable(\n       recordTime: Option[Timestamp],\n-      logEntryBuilder: DamlLogEntry.Builder): Unit =\n-    recordTime.foreach(timestamp => logEntryBuilder.setRecordTime(buildTimestamp(timestamp)))\n+      logEntryBuilder: DamlLogEntry.Builder): DamlLogEntry.Builder =\n+    recordTime\n+      .map(timestamp => logEntryBuilder.setRecordTime(buildTimestamp(timestamp)))\n+      .getOrElse(logEntryBuilder)"
  },
  {
    "id" : "73951255-3cc8-43ae-b1fb-8fb76cce5b86",
    "prId" : 6592,
    "comments" : [
      {
        "id" : "75052194-285d-49d2-a17d-ec828ce2c6f8",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Why is that? Time updates should be received only by involved participants in case of success and only by the submitting participant in case of out-of-time and conflict.",
        "createdAt" : "2020-07-07T14:42:18Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9e983036-1a93-453d-9f67-0cfa01b814e6",
        "parentId" : "75052194-285d-49d2-a17d-ec828ce2c6f8",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Yes, that's correct for a ledger with sub-transaction privacy. However, we don't have such ledger implementations as part of the DAML SDK.",
        "createdAt" : "2020-07-07T16:32:44Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a8ec7672-31e2-42b3-a993-badba534860f",
        "parentId" : "75052194-285d-49d2-a17d-ec828ce2c6f8",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Right, I'd only make it a bit more explicit in the comment, e.g. \"This default value only covers use cases that don't need sub-transaction privacy\".",
        "createdAt" : "2020-07-08T06:39:12Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55fbe3cc0a4ea1575e54fc6873803e8129a24e49",
    "line" : null,
    "diffHunk" : "@@ -62,39 +57,88 @@ private[committer] trait Committer[Submission, PartialResult] {\n     }.toMap\n \n   /** A committer can `run` a submission and produce a log entry and output states. */\n-  @SuppressWarnings(Array(\"org.wartremover.warts.Return\"))\n   def run(\n       recordTime: Option[Time.Timestamp],\n-      submission: Submission,\n+      submission: DamlSubmission,\n       participantId: ParticipantId,\n       inputState: DamlStateMap,\n   ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n     runTimer.time { () =>\n       val ctx = new CommitContext {\n         override def getRecordTime: Option[Time.Timestamp] = recordTime\n+\n         override def getParticipantId: ParticipantId = participantId\n+\n         override def inputsWithFingerprints: DamlStateMapWithFingerprints =\n           inputState.map {\n             case (key, value) => (key, (value, FingerprintPlaceholder))\n           }\n       }\n-      var cstate = init(ctx, submission)\n-      for ((info, step) <- steps) {\n-        val result: StepResult[PartialResult] =\n-          stepTimers(info).time(() => step(ctx, cstate))\n-        result match {\n-          case StepContinue(newCState) => cstate = newCState\n-          case StepStop(logEntry) =>\n-            return logEntry -> ctx.getOutputs.toMap\n-        }\n+      val logEntry = runSteps(ctx, submission)\n+      logEntry -> ctx.getOutputs.toMap\n+    }\n+\n+  def dryRun(\n+      submission: DamlSubmission,\n+      participantId: ParticipantId,\n+      inputState: DamlStateMapWithFingerprints,\n+  ): PreexecutionResult = {\n+    runTimer.time { () =>\n+      // TODO(miklos): Create context for pre-execution here.\n+      val commitContext = new CommitContext {\n+        override def getRecordTime: Option[Time.Timestamp] = None\n+\n+        override def getParticipantId: ParticipantId = participantId\n+\n+        override def inputsWithFingerprints: DamlStateMapWithFingerprints = inputState\n       }\n-      sys.error(s\"Internal error: Committer $committerName did not produce a result!\")\n+      preexecute(submission, participantId, inputState, commitContext)\n+    }\n+  }\n+\n+  private[committer] def preexecute(\n+      submission: DamlSubmission,\n+      participantId: ParticipantId,\n+      inputState: DamlStateMapWithFingerprints,\n+      commitContext: CommitContext,\n+  ): PreexecutionResult = {\n+    val logEntry = runSteps(commitContext, submission)\n+    PreexecutionResult(\n+      readSet = commitContext.getAccessedInputKeysWithFingerprints.toMap,\n+      successfulLogEntry = logEntry,\n+      stateUpdates = commitContext.getOutputs.toMap,\n+      // TODO(miklos): Take out-of-time-bounds log entry and min/max record time from context.\n+      outOfTimeBoundsLogEntry = constructOutOfTimeBoundsLogEntry(commitContext),\n+      minimumRecordTime = Timestamp.MinValue,\n+      maximumRecordTime = Timestamp.MaxValue,\n+      // We assume the time updates must be visible to every participant."
  },
  {
    "id" : "14d46a5f-721a-4434-b992-cd344b1bef41",
    "prId" : 6592,
    "comments" : [
      {
        "id" : "2680d546-9b2b-45cc-be8e-35e7228f122d",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "I think a TODO is missing here",
        "createdAt" : "2020-07-07T14:42:42Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47fcb4f3-d425-4e9f-8e9d-6aaf2e00f9ff",
        "parentId" : "2680d546-9b2b-45cc-be8e-35e7228f122d",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Yes, it will be implemented once #6630 is merged -- this PR is still just a draft.",
        "createdAt" : "2020-07-07T16:34:12Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55fbe3cc0a4ea1575e54fc6873803e8129a24e49",
    "line" : null,
    "diffHunk" : "@@ -62,39 +57,88 @@ private[committer] trait Committer[Submission, PartialResult] {\n     }.toMap\n \n   /** A committer can `run` a submission and produce a log entry and output states. */\n-  @SuppressWarnings(Array(\"org.wartremover.warts.Return\"))\n   def run(\n       recordTime: Option[Time.Timestamp],\n-      submission: Submission,\n+      submission: DamlSubmission,\n       participantId: ParticipantId,\n       inputState: DamlStateMap,\n   ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n     runTimer.time { () =>\n       val ctx = new CommitContext {\n         override def getRecordTime: Option[Time.Timestamp] = recordTime\n+\n         override def getParticipantId: ParticipantId = participantId\n+\n         override def inputsWithFingerprints: DamlStateMapWithFingerprints =\n           inputState.map {\n             case (key, value) => (key, (value, FingerprintPlaceholder))\n           }\n       }\n-      var cstate = init(ctx, submission)\n-      for ((info, step) <- steps) {\n-        val result: StepResult[PartialResult] =\n-          stepTimers(info).time(() => step(ctx, cstate))\n-        result match {\n-          case StepContinue(newCState) => cstate = newCState\n-          case StepStop(logEntry) =>\n-            return logEntry -> ctx.getOutputs.toMap\n-        }\n+      val logEntry = runSteps(ctx, submission)\n+      logEntry -> ctx.getOutputs.toMap\n+    }\n+\n+  def dryRun(\n+      submission: DamlSubmission,\n+      participantId: ParticipantId,\n+      inputState: DamlStateMapWithFingerprints,\n+  ): PreexecutionResult = {\n+    runTimer.time { () =>\n+      // TODO(miklos): Create context for pre-execution here.\n+      val commitContext = new CommitContext {\n+        override def getRecordTime: Option[Time.Timestamp] = None\n+\n+        override def getParticipantId: ParticipantId = participantId\n+\n+        override def inputsWithFingerprints: DamlStateMapWithFingerprints = inputState\n       }\n-      sys.error(s\"Internal error: Committer $committerName did not produce a result!\")\n+      preexecute(submission, participantId, inputState, commitContext)\n+    }\n+  }\n+\n+  private[committer] def preexecute(\n+      submission: DamlSubmission,\n+      participantId: ParticipantId,\n+      inputState: DamlStateMapWithFingerprints,\n+      commitContext: CommitContext,\n+  ): PreexecutionResult = {\n+    val logEntry = runSteps(commitContext, submission)\n+    PreexecutionResult(\n+      readSet = commitContext.getAccessedInputKeysWithFingerprints.toMap,\n+      successfulLogEntry = logEntry,\n+      stateUpdates = commitContext.getOutputs.toMap,\n+      // TODO(miklos): Take out-of-time-bounds log entry and min/max record time from context.\n+      outOfTimeBoundsLogEntry = constructOutOfTimeBoundsLogEntry(commitContext),\n+      minimumRecordTime = Timestamp.MinValue,\n+      maximumRecordTime = Timestamp.MaxValue,\n+      // We assume the time updates must be visible to every participant.\n+      involvedParticipants = AllParticipants\n+    )\n+  }\n+\n+  private def constructOutOfTimeBoundsLogEntry(commitContext: CommitContext): DamlLogEntry =\n+    DamlLogEntry.getDefaultInstance"
  },
  {
    "id" : "ff07e0fc-ea4a-442d-8485-553c2b4e88ab",
    "prId" : 6592,
    "comments" : [
      {
        "id" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "This default seems to me safe only for some submission types though, so I suggest specializing.",
        "createdAt" : "2020-07-10T11:15:47Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c31d8987-7f17-48d9-b597-7c005cffa1dd",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We could make `minimumRecordTime` optional, however, the check that needs to be done during post-execution should be a simple comparison (i.e., whether the record time at that time is within limits). Not making this field optional simplifies the post-execution code as any record time other than `Timestamp.MinValue` should be larger than the default minimum record time set here.",
        "createdAt" : "2020-07-10T11:41:37Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d2cd3250-39aa-45c8-913d-605800ee8c32",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Pre-executing a transaction submission and not getting back minimum/maximum record time is not a valid state AFAIU, so I think we shouldn't set the widest possible window nor avoid setting it but we should rather throw. This is committer-specific though, so I think the committer should tell what to do in such cases.",
        "createdAt" : "2020-07-10T11:48:38Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5d319357-4717-418f-95de-1a705a17a9e3",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "E.g. an option could be specializing the context, another one could be to have the committer validate the context before it is used to return the pre-execution result.",
        "createdAt" : "2020-07-10T11:53:39Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0906264f-b476-4893-b390-02ddcdccec59",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "I'm not sure if it's worth introducing more complexity around these checks (i.e., make the left side of the interval optional while the right side is mandatory). As we are controlling the full flow I'm leaning towards simplicity and just have a very relaxed left side of the interval that needs to be checked as a default (i.e., any record time will adhere to it). What disadvantage can you see with keeping the implementation as-is? We have unit tests covering what is expected from the `Committer` implementations plus the default values.",
        "createdAt" : "2020-07-10T13:11:09Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ff64701-0381-4ad5-b478-5a8fc4e464d8",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "I think we shouldn't fill here missing committer-specific data with general defaults that are not generally safe, it is confusing and we might miss something it in the future. You could also just throw instead and expect the specialized committers to always set a value (possibly a default one).",
        "createdAt" : "2020-07-10T13:32:33Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "312b4612-81cb-4297-ba3d-c3fb0ec758c1",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Why are you suggesting that `Timestamp.MinValue` as the default for a non-existant left interval point is not safe? I'm happy to make both of these record times optional, i.e., we will send these as part of a proto3 message in which every field is optional anyway.",
        "createdAt" : "2020-07-10T13:53:24Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "683e39cc-4b05-479b-a0fe-0c420fe7feb9",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "It's not just about minimum but both extremes and the reason is that minimum and maximum record time _must_ be filled in by the transaction and configuration committers during pre-execution. The matter here is the following: as a reader, I don't understand what assumption is made about the concrete committers, i.e. I read \"during pre-execution, committers will fill min and max record time and if they don't then it means we should take the biggest possible window (independently of which committers they are)\", which is not always true. I'd prefer reading \"during pre-execution, committers will fill min and max record time (possibly with defaults), else it's a bug\".",
        "createdAt" : "2020-07-10T14:19:41Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "042b6ccd-95eb-4c4d-95b5-e489756bf7ad",
        "parentId" : "7f564ed7-9371-492e-8563-3a6a011a07f3",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Makes sense -- we can have an optional here then for min/max record time.",
        "createdAt" : "2020-07-10T14:37:33Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55fbe3cc0a4ea1575e54fc6873803e8129a24e49",
    "line" : null,
    "diffHunk" : "@@ -78,46 +87,63 @@ private[committer] trait Committer[PartialResult] extends SubmissionExecutor {\n       logEntry -> ctx.getOutputs.toMap\n     }\n \n-  def dryRun(\n+  def runWithPreExecution(\n       submission: DamlSubmission,\n       participantId: ParticipantId,\n       inputState: DamlStateMapWithFingerprints,\n-  ): PreexecutionResult = {\n-    runTimer.time { () =>\n-      // TODO(miklos): Create context for pre-execution here.\n+  ): PreExecutionResult = {\n+    preExecutionRunTimer.time { () =>\n       val commitContext = new CommitContext {\n         override def getRecordTime: Option[Time.Timestamp] = None\n \n         override def getParticipantId: ParticipantId = participantId\n \n         override def inputsWithFingerprints: DamlStateMapWithFingerprints = inputState\n       }\n-      preexecute(submission, participantId, inputState, commitContext)\n+      preExecute(submission, participantId, inputState, commitContext)\n     }\n   }\n \n-  private[committer] def preexecute(\n+  private[committer] def preExecute(\n       submission: DamlSubmission,\n       participantId: ParticipantId,\n       inputState: DamlStateMapWithFingerprints,\n       commitContext: CommitContext,\n-  ): PreexecutionResult = {\n+  ): PreExecutionResult = {\n     val logEntry = runSteps(commitContext, submission)\n-    PreexecutionResult(\n+    PreExecutionResult(\n       readSet = commitContext.getAccessedInputKeysWithFingerprints.toMap,\n       successfulLogEntry = logEntry,\n       stateUpdates = commitContext.getOutputs.toMap,\n-      // TODO(miklos): Take out-of-time-bounds log entry and min/max record time from context.\n       outOfTimeBoundsLogEntry = constructOutOfTimeBoundsLogEntry(commitContext),\n-      minimumRecordTime = Timestamp.MinValue,\n-      maximumRecordTime = Timestamp.MaxValue,\n+      minimumRecordTime = commitContext.minimumRecordTime\n+        .map(Timestamp.assertFromInstant)\n+        .getOrElse(Timestamp.MinValue),"
  },
  {
    "id" : "16abf2fd-3899-4ff4-b227-b0fe0b730703",
    "prId" : 6592,
    "comments" : [
      {
        "id" : "fcb87df8-74e2-4246-aeb8-a47d245f6f26",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Where is `deduplicate_until` set in the `OutOfTimeBoundsEntry`?",
        "createdAt" : "2020-07-10T11:20:35Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c32febc3-ff31-4aa2-8432-b2bea8acfa9e",
        "parentId" : "fcb87df8-74e2-4246-aeb8-a47d245f6f26",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "See #6672 which builds on this one.",
        "createdAt" : "2020-07-10T11:26:24Z",
        "updatedAt" : "2020-07-10T16:13:44Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "55fbe3cc0a4ea1575e54fc6873803e8129a24e49",
    "line" : 165,
    "diffHunk" : "@@ -78,46 +87,63 @@ private[committer] trait Committer[PartialResult] extends SubmissionExecutor {\n       logEntry -> ctx.getOutputs.toMap\n     }\n \n-  def dryRun(\n+  def runWithPreExecution(\n       submission: DamlSubmission,\n       participantId: ParticipantId,\n       inputState: DamlStateMapWithFingerprints,\n-  ): PreexecutionResult = {\n-    runTimer.time { () =>\n-      // TODO(miklos): Create context for pre-execution here.\n+  ): PreExecutionResult = {\n+    preExecutionRunTimer.time { () =>\n       val commitContext = new CommitContext {\n         override def getRecordTime: Option[Time.Timestamp] = None\n \n         override def getParticipantId: ParticipantId = participantId\n \n         override def inputsWithFingerprints: DamlStateMapWithFingerprints = inputState\n       }\n-      preexecute(submission, participantId, inputState, commitContext)\n+      preExecute(submission, participantId, inputState, commitContext)\n     }\n   }\n \n-  private[committer] def preexecute(\n+  private[committer] def preExecute(\n       submission: DamlSubmission,\n       participantId: ParticipantId,\n       inputState: DamlStateMapWithFingerprints,\n       commitContext: CommitContext,\n-  ): PreexecutionResult = {\n+  ): PreExecutionResult = {\n     val logEntry = runSteps(commitContext, submission)\n-    PreexecutionResult(\n+    PreExecutionResult(\n       readSet = commitContext.getAccessedInputKeysWithFingerprints.toMap,\n       successfulLogEntry = logEntry,\n       stateUpdates = commitContext.getOutputs.toMap,\n-      // TODO(miklos): Take out-of-time-bounds log entry and min/max record time from context.\n       outOfTimeBoundsLogEntry = constructOutOfTimeBoundsLogEntry(commitContext),\n-      minimumRecordTime = Timestamp.MinValue,\n-      maximumRecordTime = Timestamp.MaxValue,\n+      minimumRecordTime = commitContext.minimumRecordTime\n+        .map(Timestamp.assertFromInstant)\n+        .getOrElse(Timestamp.MinValue),\n+      maximumRecordTime = commitContext.maximumRecordTime\n+        .map(Timestamp.assertFromInstant)\n+        .getOrElse(Timestamp.MaxValue),\n       // We assume the time updates must be visible to every participant.\n       involvedParticipants = AllParticipants\n     )\n   }\n \n   private def constructOutOfTimeBoundsLogEntry(commitContext: CommitContext): DamlLogEntry =\n-    DamlLogEntry.getDefaultInstance\n+    commitContext.outOfTimeBoundsLogEntry\n+      .map { rejectionLogEntry =>\n+        val builder = DamlOutOfTimeBoundsEntry.newBuilder\n+          .setEntry(rejectionLogEntry)\n+        commitContext.minimumRecordTime.foreach { instant =>\n+          builder.setTooEarlyUntil(buildTimestamp(instant))\n+        }\n+        commitContext.maximumRecordTime.foreach { instant =>\n+          builder.setTooLateFrom(buildTimestamp(instant))\n+        }\n+        DamlLogEntry.newBuilder\n+          .setOutOfTimeBoundsEntry(builder)\n+          .build"
  },
  {
    "id" : "f9a28fbe-542b-4b35-bc80-7f74ab880e52",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "fa26ba1e-80a4-4dca-9fff-3d7a0d4cce6b",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Going to move those to `TransactionCommitter`",
        "createdAt" : "2020-07-02T15:27:36Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : null,
    "diffHunk" : "@@ -131,4 +127,21 @@ object Committer {\n       recordTime: Option[Timestamp],\n       logEntryBuilder: DamlLogEntry.Builder): Unit =\n     recordTime.foreach(timestamp => logEntryBuilder.setRecordTime(buildTimestamp(timestamp)))\n+\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private[committer] def transactionMinimumRecordTime(\n+      maybeDeduplicateUntil: Option[Instant],\n+      ledgerTime: Instant,\n+      maxSkew: Duration,\n+      submissionTime: Instant): Instant =\n+    List(\n+      maybeDeduplicateUntil,\n+      Some(ledgerTime.minus(maxSkew)),\n+      Some(submissionTime.minus(maxSkew))).flatten.max\n+\n+  private[committer] def transactionMaximumRecordTime(\n+      ledgerTime: Instant,\n+      minSkew: Duration): Instant =\n+    ledgerTime.plus(minSkew)\n+"
  },
  {
    "id" : "ba7488ce-4f30-4ac5-9fb8-f0d2a21d8417",
    "prId" : 6538,
    "comments" : [
      {
        "id" : "7d709c9f-bcca-438e-bdae-6a8379bb9be2",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Minor: As this method takes a builder, it should again return the builder to enable the callers to chain method calls on the builder.",
        "createdAt" : "2020-07-02T06:17:19Z",
        "updatedAt" : "2020-07-02T06:17:19Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bcc144e6-d82e-4536-9dbd-d60db3adf71d",
        "parentId" : "7d709c9f-bcca-438e-bdae-6a8379bb9be2",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Good point -- will change it in a follow-up PR.",
        "createdAt" : "2020-07-02T13:48:55Z",
        "updatedAt" : "2020-07-02T13:48:55Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7fcd13b1e8abafa8318221497401dd1746cfe5e2",
    "line" : 52,
    "diffHunk" : "@@ -117,4 +117,18 @@ object Committer {\n           }, conf => Some(Some(entry) -> conf))\n       }\n       .getOrElse(None -> defaultConfig)\n+\n+  def buildLogEntryWithOptionalRecordTime(\n+      recordTime: Option[Timestamp],\n+      addSubmissionSpecificEntry: DamlLogEntry.Builder => DamlLogEntry.Builder): DamlLogEntry = {\n+    val logEntryBuilder = DamlLogEntry.newBuilder\n+    addSubmissionSpecificEntry(logEntryBuilder)\n+    setRecordTimeIfAvailable(recordTime, logEntryBuilder)\n+    logEntryBuilder.build\n+  }\n+\n+  private def setRecordTimeIfAvailable(\n+      recordTime: Option[Timestamp],\n+      logEntryBuilder: DamlLogEntry.Builder): Unit ="
  },
  {
    "id" : "f5122e26-ba98-4d9e-9215-f4f22879a14c",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "7eafb9ad-c1a5-4bd4-abf1-f697860b2a08",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "`Conversions.configurationStateKey` should probably be moved into this object as a (package private) constant -- it does not seem to be related to the rest of the methods in `Conversions`.",
        "createdAt" : "2020-05-08T14:12:32Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "391ed633-43d8-4379-98f3-a90dd2d9e891",
        "parentId" : "7eafb9ad-c1a5-4bd4-abf1-f697860b2a08",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "It seems as though it is related to other methods in `Conversions` such as `partyStateKey` and `packageStateKey` each of which returns `DamlStateKey` wrapping. This one just happens to be parameterless.\r\nIt is also used in many places throughout the codebase. Moving it and making it private would result in code replication. ",
        "createdAt" : "2020-05-08T18:18:43Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : 29,
    "diffHunk" : "@@ -93,4 +94,27 @@ private[committer] trait Committer[Submission, PartialResult] {\n \n object Committer {\n   type StepInfo = String\n+\n+  def getCurrentConfiguration(\n+      defaultConfig: Configuration,\n+      inputState: Map[DamlStateKey, Option[DamlStateValue]],\n+      logger: Logger): (Option[DamlConfigurationEntry], Configuration) =\n+    inputState\n+      .getOrElse(\n+        Conversions.configurationStateKey,"
  },
  {
    "id" : "694eda95-4bed-414a-92f3-d3bf6eb7e710",
    "prId" : 4984,
    "comments" : [
      {
        "id" : "2f760aad-3bcb-431b-9d38-a17affbe0116",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This is nice, but I think we should do it in a separate change because I can't quite follow the ramifications.",
        "createdAt" : "2020-03-16T08:31:31Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "63577525-c504-430f-93bc-e9b3f8da8fe0",
        "parentId" : "2f760aad-3bcb-431b-9d38-a17affbe0116",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Pulled it out and created #5013.",
        "createdAt" : "2020-03-16T10:54:26Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8049c9ebb4015c70e4b3db0344c1e0bdf85699ec",
    "line" : null,
    "diffHunk" : "@@ -83,7 +87,7 @@ private[kvutils] trait Committer[Submission, PartialResult] {\n         result match {\n           case StepContinue(newCState) => cstate = newCState\n           case StepStop(logEntry) =>\n-            return logEntry -> ctx.getOutputs.toMap\n+            return logEntry -> SortedMap(ctx.getOutputs.toSeq: _*)"
  },
  {
    "id" : "6aa7b031-791d-483d-b0b2-8e8efe058da4",
    "prId" : 4242,
    "comments" : [
      {
        "id" : "863ec18e-c51a-4e19-b4a4-a877f43e63c8",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "We have to be really careful here to retain ordering for the produced outputs (e.g. retain determinism). `Map` by defaults to `HashMap` which does not give a stable ordering. Use `TreeMap` instead, or retain the `Iterable` and produce a set of keys when verifying.",
        "createdAt" : "2020-01-28T13:49:23Z",
        "updatedAt" : "2020-01-28T16:52:14Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "154f8489-9d43-4204-9241-936331120ec3",
        "parentId" : "863ec18e-c51a-4e19-b4a4-a877f43e63c8",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "As discussed offline, the consumer of this call will convert the result to a `Map` anyway. Let's review the data flows separately and ensure we have deterministic ordering where needed. ",
        "createdAt" : "2020-01-28T15:34:13Z",
        "updatedAt" : "2020-01-28T16:52:14Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5f97bcbe6a6713514ec6a15681a44edcf15ecfc9",
    "line" : null,
    "diffHunk" : "@@ -66,7 +66,7 @@ private[kvutils] trait Committer[Submission, PartialResult] {\n       recordTime: Time.Timestamp,\n       submission: Submission,\n       participantId: ParticipantId,\n-      inputState: DamlStateMap): (DamlLogEntry, Iterable[(DamlStateKey, DamlStateValue)]) =\n+      inputState: DamlStateMap): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) ="
  },
  {
    "id" : "85313a69-5dc7-4a5d-82a4-38f0513fb775",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "ff8c20f0-88a1-4a1e-bf84-6a80a9854867",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "`Void`, `Nothing`'s slightly weaker sibling ;)",
        "createdAt" : "2019-10-08T08:25:05Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "689193dd-17ea-4e74-897c-1671df537e44",
        "parentId" : "ff8c20f0-88a1-4a1e-bf84-6a80a9854867",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "btw, any idea why this construct makes the scala compiler warn of dead code following the `done()` call? I cannot figure out why, but I like it.\r\n\r\nAlso better less hacky approach to this would be welcome :).",
        "createdAt" : "2019-10-08T09:42:21Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "929b491d-4959-40d1-af31-a947c74e71db",
        "parentId" : "ff8c20f0-88a1-4a1e-bf84-6a80a9854867",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Wait, I completely missed that this `Void` isn't actually `java.lang.Void`. So basically it's the `Nothing` check. In fact, if you look at what type is inferred for `PackageCommitter#finish`, you will find that it is indeed `Nothing`.",
        "createdAt" : "2019-10-08T12:26:45Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "938965e9-f206-48d1-89ef-f49c1601b35c",
        "parentId" : "ff8c20f0-88a1-4a1e-bf84-6a80a9854867",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "In fact, this should result in a null pointer exception, since the use site in `PackageCommitter` doesn't specify a type parameter.\r\n\r\n```\r\nscala> def n: Nothing = null.asInstanceOf[Nothing]\r\nn: Nothing\r\n\r\nscala> def mayFail[F] = null.asInstanceOf[F]\r\nmayFail: [F]=> F\r\n\r\nscala> n\r\njava.lang.NullPointerException\r\n  at .$print$lzycompute(<console>:9)\r\n\r\nscala> mayFail[Int]\r\nres4: Int = 0\r\n\r\nscala> mayFail\r\njava.lang.NullPointerException\r\n  at .$print$lzycompute(<console>:9)\r\n\r\nscala> mayFail[String]\r\nres6: String = null\r\n```",
        "createdAt" : "2019-10-08T12:30:52Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9373ebde-a36a-488d-9bc4-59e20c554aae",
        "parentId" : "ff8c20f0-88a1-4a1e-bf84-6a80a9854867",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Dropped all this sillyness and used an ADT (Continue/Stop).",
        "createdAt" : "2019-10-10T07:51:30Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,66 @@\n+package com.daml.ledger.participant.state.kvutils.committer\n+\n+import com.codahale.metrics\n+import com.codahale.metrics.Timer\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue\n+}\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.digitalasset.daml.lf.data.Time\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+trait Committer[Submission, PartialResult] {\n+\n+  /** A kvutils committer is composed of individual commit steps which:\n+    *  - carry a partial result from one step to another\n+    *  - can access daml state via [[Context.get]]\n+    *  - can update daml state via [[Context.set]]\n+    *  - can end the commit via [[Context.done]], which skips the rest of the remaining steps\n+    */\n+  type Step = (Context, PartialResult) => PartialResult\n+  def steps: Iterable[Step]\n+\n+  /** The initial partial result passed to first step. */\n+  def init(subm: Submission): PartialResult\n+\n+  val logger: Logger = LoggerFactory.getLogger(this.getClass)\n+  val metricsRegistry: metrics.MetricRegistry =\n+    metrics.SharedMetricRegistries.getOrCreate(\"kvutils\")\n+  def metricsName(metric: String): String = metrics.MetricRegistry.name(this.getClass, metric)\n+  private val runTimer: Timer = metricsRegistry.timer(metricsName(\"run-timer\"))\n+\n+  /** A committer can `run` a submission and produce a log entry and output states. */\n+  def run(\n+      entryId: DamlLogEntryId,\n+      recordTime: Time.Timestamp,\n+      submission: Submission,\n+      participantId: ParticipantId,\n+      inputState: DamlStateMap): (DamlLogEntry, Iterable[(DamlStateKey, DamlStateValue)]) =\n+    runTimer.time { () =>\n+      var result: Option[DamlLogEntry] = None\n+      val ctx = new Context {\n+        override def getRecordTime: Time.Timestamp = recordTime\n+        override def getParticipantId: ParticipantId = participantId\n+        override def inputs: DamlStateMap = inputState\n+        override def done[Void](logEntry: DamlLogEntry): Void = {\n+          result = Some(logEntry)\n+          // Return \"null\", giving us the assertion and a compiler warning if the committer"
  },
  {
    "id" : "4a6aa9a9-7cc0-4f40-94df-168c26419f80",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "c2ec3b53-60d1-4c5f-9af9-0ee6d138547d",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Explain high-level concept behind the 'Committer'. It is not obvious to me.",
        "createdAt" : "2019-10-09T15:50:45Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "faccc03a-113c-4761-b21e-deaa0a87702a",
        "parentId" : "c2ec3b53-60d1-4c5f-9af9-0ee6d138547d",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "added explanations.",
        "createdAt" : "2019-10-10T08:11:49Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,66 @@\n+package com.daml.ledger.participant.state.kvutils.committer\n+\n+import com.codahale.metrics\n+import com.codahale.metrics.Timer\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue\n+}\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.digitalasset.daml.lf.data.Time\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+trait Committer[Submission, PartialResult] {"
  },
  {
    "id" : "d567ce77-4c21-48a9-a1eb-49d6acd182a0",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "d5b681b8-9503-4eb5-a14e-9d82575edad6",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "I wouldn't have understood from the definition of the `Context` class that this is the intended use. Are there other intended uses?",
        "createdAt" : "2019-10-09T15:52:56Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "48882d81-b112-4400-a7b1-e0b25ddaf0b8",
        "parentId" : "d5b681b8-9503-4eb5-a14e-9d82575edad6",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "renamed and documented.",
        "createdAt" : "2019-10-10T08:11:41Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,66 @@\n+package com.daml.ledger.participant.state.kvutils.committer\n+\n+import com.codahale.metrics\n+import com.codahale.metrics.Timer\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue\n+}\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.digitalasset.daml.lf.data.Time\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+trait Committer[Submission, PartialResult] {\n+\n+  /** A kvutils committer is composed of individual commit steps which:\n+    *  - carry a partial result from one step to another\n+    *  - can access daml state via [[Context.get]]\n+    *  - can update daml state via [[Context.set]]\n+    *  - can end the commit via [[Context.done]], which skips the rest of the remaining steps\n+    */\n+  type Step = (Context, PartialResult) => PartialResult\n+  def steps: Iterable[Step]\n+\n+  /** The initial partial result passed to first step. */\n+  def init(subm: Submission): PartialResult\n+\n+  val logger: Logger = LoggerFactory.getLogger(this.getClass)\n+  val metricsRegistry: metrics.MetricRegistry =\n+    metrics.SharedMetricRegistries.getOrCreate(\"kvutils\")\n+  def metricsName(metric: String): String = metrics.MetricRegistry.name(this.getClass, metric)\n+  private val runTimer: Timer = metricsRegistry.timer(metricsName(\"run-timer\"))\n+\n+  /** A committer can `run` a submission and produce a log entry and output states. */\n+  def run(\n+      entryId: DamlLogEntryId,\n+      recordTime: Time.Timestamp,\n+      submission: Submission,\n+      participantId: ParticipantId,\n+      inputState: DamlStateMap): (DamlLogEntry, Iterable[(DamlStateKey, DamlStateValue)]) =\n+    runTimer.time { () =>\n+      var result: Option[DamlLogEntry] = None\n+      val ctx = new Context {"
  },
  {
    "id" : "7e5e9cd1-75de-4b8a-a869-c1dd9a415dd1",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "3027c1b5-c880-407a-9b0f-c06beb2437fb",
        "parentId" : null,
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "s/rational/rationale",
        "createdAt" : "2019-11-04T10:19:25Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c65c94f-fb6b-4ea0-a4b0-c599492babe9",
        "parentId" : "3027c1b5-c880-407a-9b0f-c06beb2437fb",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "fixed.",
        "createdAt" : "2019-11-07T09:36:10Z",
        "updatedAt" : "2019-11-07T09:36:10Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,85 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.committer\n+\n+import com.codahale.metrics\n+import com.codahale.metrics.Timer\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue\n+}\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.digitalasset.daml.lf.data.Time\n+import org.slf4j.{Logger, LoggerFactory}\n+\n+/** A committer processes a submission, with its inputs into an ordered set of output state and a log entry.\n+  * It is parametrized by the submission type `Submission` (e.g. PackageUploadEntry) and a committer's partial result\n+  * `PartialResult`.\n+  *\n+  * A committer implementation defines an initial partial result with `init` and `steps` to process the submission\n+  * into a set of DAML state outputs and a log entry. The main rational behind this abstraction is to provide uniform"
  }
]