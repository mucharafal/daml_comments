[
  {
    "id" : "bac24109-b017-4e10-a3ad-4f183eb8187b",
    "prId" : 7215,
    "comments" : [
      {
        "id" : "eed7953d-51ef-49cf-b0ed-740e08589929",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2020-08-25T10:56:58Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0020dd8e089d897ae22c94ce2643c7d7f6073b04",
    "line" : 91,
    "diffHunk" : "@@ -7,96 +7,40 @@ import java.io.DataOutputStream\n import java.time.Instant\n import java.util.concurrent.locks.StampedLock\n \n+import com.daml.ledger.participant.state.kvutils.CorrelationId\n import com.daml.ledger.participant.state.v1.ParticipantId\n import com.daml.ledger.validator.LedgerStateOperations.{Key, Value}\n-import com.google.protobuf.ByteString\n-\n-import scala.collection.mutable\n-import scala.collection.mutable.ListBuffer\n \n /**\n   * Enables exporting ledger data to an output stream.\n   * This class is thread-safe.\n   */\n class FileBasedLedgerDataExporter(output: DataOutputStream) extends LedgerDataExporter {\n-  import FileBasedLedgerDataExporter._\n \n   private val outputLock = new StampedLock\n \n-  private[export] val correlationIdMapping = mutable.Map.empty[String, String]\n-  private[export] val inProgressSubmissions = mutable.Map.empty[String, SubmissionInfo]\n-  private[export] val bufferedKeyValueDataPerCorrelationId =\n-    mutable.Map.empty[String, mutable.ListBuffer[(Key, Value)]]\n-\n-  def addSubmission(\n-      submissionEnvelope: ByteString,\n-      correlationId: String,\n+  override def addSubmission(\n+      participantId: ParticipantId,\n+      correlationId: CorrelationId,\n+      submissionEnvelope: Key,\n       recordTimeInstant: Instant,\n-      participantId: ParticipantId): Unit =\n-    this.synchronized {\n-      inProgressSubmissions.put(\n-        correlationId,\n-        SubmissionInfo(submissionEnvelope, correlationId, recordTimeInstant, participantId))\n-      ()\n-    }\n-\n-  def addParentChild(parentCorrelationId: String, childCorrelationId: String): Unit =\n-    this.synchronized {\n-      correlationIdMapping.put(childCorrelationId, parentCorrelationId)\n-      ()\n-    }\n-\n-  def addToWriteSet(correlationId: String, data: Iterable[(Key, Value)]): Unit =\n+  ): SubmissionAggregator =\n     this.synchronized {\n-      correlationIdMapping\n-        .get(correlationId)\n-        .foreach { parentCorrelationId =>\n-          val keyValuePairs = bufferedKeyValueDataPerCorrelationId\n-            .getOrElseUpdate(parentCorrelationId, ListBuffer.empty)\n-          keyValuePairs.appendAll(data)\n-          bufferedKeyValueDataPerCorrelationId.put(parentCorrelationId, keyValuePairs)\n-        }\n+      val submissionInfo =\n+        SubmissionInfo(participantId, correlationId, submissionEnvelope, recordTimeInstant)\n+      new InMemorySubmissionAggregator(submissionInfo, FileBasedLedgerDataWriter)\n     }\n \n-  def finishedProcessing(correlationId: String): Unit = {\n-    val (submissionInfo, bufferedData) = this.synchronized {\n-      (\n-        inProgressSubmissions.get(correlationId),\n-        bufferedKeyValueDataPerCorrelationId.get(correlationId))\n-    }\n-    submissionInfo.foreach { submission =>\n-      bufferedData.foreach(writeSubmissionData(submission, _))\n-      this.synchronized {\n-        inProgressSubmissions.remove(correlationId)\n-        bufferedKeyValueDataPerCorrelationId.remove(correlationId)\n-        correlationIdMapping\n-          .collect {\n-            case (key, value) if value == correlationId => key\n-          }\n-          .foreach(correlationIdMapping.remove)\n+  object FileBasedLedgerDataWriter extends LedgerDataWriter {\n+    override def write(submissionInfo: SubmissionInfo, writeSet: Seq[(Key, Value)]): Unit = {\n+      val stamp = outputLock.writeLock()\n+      try {\n+        Serialization.serializeEntry(submissionInfo, writeSet, output)\n+        output.flush()\n+      } finally {\n+        outputLock.unlock(stamp)\n       }\n     }\n   }\n "
  }
]