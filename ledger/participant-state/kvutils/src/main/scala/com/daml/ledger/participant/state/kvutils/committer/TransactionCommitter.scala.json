[
  {
    "id" : "b122c067-d32f-4f2d-b091-ce7fa3625236",
    "prId" : 7617,
    "comments" : [
      {
        "id" : "182c7331-86ae-4abd-9873-e731a0d29e5d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This looks horrible. Can't we do something like this?\r\n```suggestion\r\n            (_, exe: Node.NodeExercises))\r\n```\r\nWe have the same in many other places too. We should clean this up a bit in a separate PR. I'm happy to do it myself.",
        "createdAt" : "2020-10-09T14:03:23Z",
        "updatedAt" : "2020-10-13T08:21:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f017c58e-424a-4842-b09d-e7a4c1dcead0",
        "parentId" : "182c7331-86ae-4abd-9873-e731a0d29e5d",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "In this case you have to write something like: \r\n\r\n```(_, exe: Node.NodeExercises[_, ContractId, VersionnedValue[ContractId]))```\r\nor using type alias \r\n```(_, exe: Node.NodeExercises.WithTxValue[_, ContractId]))```\r\n\r\nI really dislike matching with parametric types.  \r\nBut if you whish I will do the \"cleanup\".",
        "createdAt" : "2020-10-12T08:49:21Z",
        "updatedAt" : "2020-10-13T08:21:59Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2c99b66c-e295-4569-83d8-9cfd3ccd2566",
        "parentId" : "182c7331-86ae-4abd-9873-e731a0d29e5d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we do the following?\r\n```scala\r\n(_, exe: Node.Exercises[_, _, _])\r\n```\r\nI mean, we don't really care about the actual type arguments, do we?",
        "createdAt" : "2020-10-12T09:00:51Z",
        "updatedAt" : "2020-10-13T08:21:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "40863a4b-ea39-415c-8ba3-29d4bfad188f",
        "parentId" : "182c7331-86ae-4abd-9873-e731a0d29e5d",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I suspect in some place this broks the type inference. \r\nIn this case, it seems to compile. However, this definitively broke the type inference of Intellij :-(\r\n",
        "createdAt" : "2020-10-12T09:20:23Z",
        "updatedAt" : "2020-10-13T08:21:59Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a398dd1f-f448-4597-b087-06b7d9283894",
        "parentId" : "182c7331-86ae-4abd-9873-e731a0d29e5d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That's weird that it breaks (IntelliJ's) type inference. The pattern `Node.NodeExercises(_, _, _, _, _, _, _, _, _, _, _, _, _, _)` doesn't make any statements about types whatsoever. Anyway, let's not touch this then for now.",
        "createdAt" : "2020-10-12T09:39:11Z",
        "updatedAt" : "2020-10-13T08:21:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "028bbced28b92a3143f68f3f65bf48954cba4025",
    "line" : 5,
    "diffHunk" : "@@ -281,7 +281,7 @@ private[kvutils] class TransactionCommitter(\n       .fold((true, keys)) {\n         case (\n             (allUnique, existingKeys),\n-            (_, exe @ Node.NodeExercises(_, _, _, _, _, _, _, _, _, _, _, _, _)))\n+            (_, exe @ Node.NodeExercises(_, _, _, _, _, _, _, _, _, _, _, _, _, _)))"
  },
  {
    "id" : "133e1720-cb1e-4666-928b-880f3c63c142",
    "prId" : 7437,
    "comments" : [
      {
        "id" : "f908d699-811c-4ba6-a667-7d3f3073db7f",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Why not rename that now? ",
        "createdAt" : "2020-09-18T13:27:00Z",
        "updatedAt" : "2020-09-21T12:27:22Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb3e9d1d-4735-4bdc-8352-fa950fba4d61",
        "parentId" : "f908d699-811c-4ba6-a667-7d3f3073db7f",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "sure\r\nthe only reason for stopping was I didn't know how far the cascade of changes would go.",
        "createdAt" : "2020-09-18T13:35:12Z",
        "updatedAt" : "2020-09-18T16:01:59Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb0ac700-bc44-4f11-9306-402f390f34b5",
        "parentId" : "f908d699-811c-4ba6-a667-7d3f3073db7f",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "You just need to change this line together with the line 70.\r\n\r\n```scala \r\n\"authorize_and_blind\" -> authorizeAndBlind\r\n```\r\nto \r\n```scala \r\n\"blind\" -> blind\r\n```",
        "createdAt" : "2020-09-18T13:42:08Z",
        "updatedAt" : "2020-09-18T16:01:59Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2578cc48-5f4e-4c19-a812-0649517295b3",
        "parentId" : "f908d699-811c-4ba6-a667-7d3f3073db7f",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "@miklos-da, @gerolf-da,  or @SamirTalwar-DA  could you confirm ? ",
        "createdAt" : "2020-09-18T13:42:26Z",
        "updatedAt" : "2020-09-18T16:01:59Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "330c33dd-2d93-480b-a479-611de38470b4",
        "parentId" : "f908d699-811c-4ba6-a667-7d3f3073db7f",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Yeah, this rename should be pretty benign.",
        "createdAt" : "2020-09-18T13:44:50Z",
        "updatedAt" : "2020-09-18T16:01:59Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9123b37d-6ac4-41d0-b0e2-ae10647a199e",
        "parentId" : "f908d699-811c-4ba6-a667-7d3f3073db7f",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "will do it",
        "createdAt" : "2020-09-18T15:27:19Z",
        "updatedAt" : "2020-09-18T16:01:59Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2d0de2d68e8b984633eefb02b8cadbe21e6d4dc",
    "line" : null,
    "diffHunk" : "@@ -249,20 +249,11 @@ private[kvutils] class TransactionCommitter(\n       })\n \n   /** Validate the submission's conformance to the DAML model */\n-  private def authorizeAndBlind: Step =\n-    (commitContext, transactionEntry) =>\n-      Blinding\n-        .checkAuthorizationAndBlind(\n-          transactionEntry.transaction,\n-          initialAuthorizers = Set(transactionEntry.submitter),\n-        )\n-        .fold(\n-          error =>\n-            reject(\n-              commitContext.getRecordTime,\n-              buildRejectionLogEntry(transactionEntry, RejectionReason.Disputed(error.msg))),\n-          blindingInfo => buildFinalResult(commitContext, transactionEntry, blindingInfo)\n-      )\n+  private def authorizeAndBlind: Step = //TODO: rename. no authorization here any more!"
  },
  {
    "id" : "6afdc2e4-8b9f-470d-91c2-5efbc757aa67",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "33d888f4-b2ab-4f88-a32a-164d6be0db38",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "You don't want to take the deduplication time from the submitted transaction, but from what is stored on the ledger in the deduplication key for the command ID of the submission.",
        "createdAt" : "2020-07-03T07:37:30Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b71a2909-301f-4ed0-922b-813467c84478",
        "parentId" : "33d888f4-b2ab-4f88-a32a-164d6be0db38",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Thanks, addressed.",
        "createdAt" : "2020-07-03T13:41:19Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : null,
    "diffHunk" : "@@ -169,8 +170,25 @@ private[kvutils] class TransactionCommitter(\n                     RejectionReason.InvalidLedgerTime(reason))),\n               _ => StepContinue(transactionEntry)\n             )\n-        }\n-        .getOrElse(StepContinue(transactionEntry))\n+        case _ => // Pre-execution: propagate the time bounds and defer the checks to post-execution\n+          val maybeDeduplicateUntil =\n+            PartialFunction.condOpt(transactionEntry.submitterInfo.hasDeduplicateUntil) {"
  },
  {
    "id" : "8c2ce504-bba3-4b00-b19d-321f57be6e60",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "4a688a74-8d61-4092-88a6-e4fa4b4c387d",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "```suggestion\r\n        case None => // Pre-execution: propagate the time bounds and defer the checks to post-execution\r\n```\r\nI try to avoid wildcard case branches such that the compiler can warn me if the patterns are not exhaustive.",
        "createdAt" : "2020-07-03T07:38:47Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "22bac634-8ee0-4454-a6fb-861d7d50acbf",
        "parentId" : "4a688a74-8d61-4092-88a6-e4fa4b4c387d",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Yes, I think it's a safe policy; I was a bit torn between being more concise and being explicit in this case. In the end I went for conciseness because I don't expect we'll be branching the patterns further but it's very cheap extra safety, so I'll do as you suggest.",
        "createdAt" : "2020-07-03T09:12:23Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9bbcb125-7b1b-4162-b120-a241924c6e56",
        "parentId" : "4a688a74-8d61-4092-88a6-e4fa4b4c387d",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done",
        "createdAt" : "2020-07-03T15:26:37Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : null,
    "diffHunk" : "@@ -169,8 +170,25 @@ private[kvutils] class TransactionCommitter(\n                     RejectionReason.InvalidLedgerTime(reason))),\n               _ => StepContinue(transactionEntry)\n             )\n-        }\n-        .getOrElse(StepContinue(transactionEntry))\n+        case _ => // Pre-execution: propagate the time bounds and defer the checks to post-execution"
  },
  {
    "id" : "a4b64189-f671-4561-a926-50ccfe2a2aed",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "d49dba68-9887-46d8-8700-d11e547db113",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I think there's an off-by-one error here. Min record time and max record time are inclusive. However, the deduplication time window is inclusive on the \"reject side\"; at least that's what @miklos-da implemented in https://github.com/digital-asset/daml/pull/6568/files#diff-51a916eda78c1c741b9b676658bb9132R277 and in Sandbox https://github.com/digital-asset/daml/blob/master/ledger/sandbox/src/main/scala/com/digitalasset/platform/sandbox/stores/ledger/inmemory/InMemoryLedger.scala#L580.\r\n\r\nSo you want to use `maybeDeduplicateUntil.map(_ + leastMeasurableTimeUnit)` here. AFAIK our time unit is microseconds.",
        "createdAt" : "2020-07-03T07:51:51Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "17a466c2-37b8-44b9-b6e5-6263eaff2dc0",
        "parentId" : "d49dba68-9887-46d8-8700-d11e547db113",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Thanks, addressed.",
        "createdAt" : "2020-07-03T13:41:31Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : null,
    "diffHunk" : "@@ -614,4 +632,17 @@ private[kvutils] object TransactionCommitter {\n   def getContractState(commitContext: CommitContext, key: DamlStateKey): DamlContractState =\n     commitContext.get(key).getOrElse(throw Err.MissingInputState(key)).getContractState\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private def transactionMinimumRecordTime(\n+      maybeDeduplicateUntil: Option[Instant],\n+      ledgerTime: Instant,\n+      maxSkew: Duration,\n+      submissionTime: Instant): Instant =\n+    List(\n+      maybeDeduplicateUntil,"
  },
  {
    "id" : "5b283e56-f9f6-4871-a59b-854d587ac147",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "691c21f4-6828-4784-827c-31591e3344c4",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I suggest to move the computations of the bounds derived from ledger time to the TimeModel https://github.com/digital-asset/daml/blob/master/ledger/participant-state/src/main/scala/com/daml/ledger/participant/state/v1/TimeModel.scala#L19 such that they are next to the `checkTime` function and you can document that these checks must be equivalent. Ideally, you'd also rewrite `checkTime` such that it uses the bounds you're computing here.",
        "createdAt" : "2020-07-03T07:54:09Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "164ce499-872a-4aea-98df-2f44994d6242",
        "parentId" : "691c21f4-6828-4784-827c-31591e3344c4",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Agreed -- it's better to keep such tightly coupled logic in the same place.",
        "createdAt" : "2020-07-03T09:18:30Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4d78a2b2-2aa7-4e1f-b7fa-05811a2b5ebf",
        "parentId" : "691c21f4-6828-4784-827c-31591e3344c4",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "I moved them there and also refactored `TimeModel` slightly.",
        "createdAt" : "2020-07-03T15:31:25Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : null,
    "diffHunk" : "@@ -614,4 +632,17 @@ private[kvutils] object TransactionCommitter {\n   def getContractState(commitContext: CommitContext, key: DamlStateKey): DamlContractState =\n     commitContext.get(key).getOrElse(throw Err.MissingInputState(key)).getContractState\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private def transactionMinimumRecordTime(\n+      maybeDeduplicateUntil: Option[Instant],\n+      ledgerTime: Instant,\n+      maxSkew: Duration,\n+      submissionTime: Instant): Instant =\n+    List(\n+      maybeDeduplicateUntil,\n+      Some(ledgerTime.minus(maxSkew)),"
  },
  {
    "id" : "1e677969-b2a2-4da3-a9ca-7db0a59bd4de",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "76bcfa19-2dbb-4e4d-81a0-5707ca5c17a7",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "You want to test also the submission time skew here.",
        "createdAt" : "2020-07-03T07:59:10Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2af98cce-58ea-40d7-a79e-30d343252d92",
        "parentId" : "76bcfa19-2dbb-4e4d-81a0-5707ca5c17a7",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Could you expand on that or point me to the relevant definitions? Not really sure about the correct check here.",
        "createdAt" : "2020-07-03T10:06:18Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "983009c5-631c-4b3b-9825-e4c3395e7665",
        "parentId" : "76bcfa19-2dbb-4e4d-81a0-5707ca5c17a7",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "You want to make sure that record time - min_skew <= submission time <= record time. So you need to check record time <= submission time + min_skew, just like for ledger time.",
        "createdAt" : "2020-07-03T11:30:00Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "afb501e3-445e-4de0-882b-802aadc11304",
        "parentId" : "76bcfa19-2dbb-4e4d-81a0-5707ca5c17a7",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Thanks, addressed.",
        "createdAt" : "2020-07-03T13:51:47Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : null,
    "diffHunk" : "@@ -614,4 +632,17 @@ private[kvutils] object TransactionCommitter {\n   def getContractState(commitContext: CommitContext, key: DamlStateKey): DamlContractState =\n     commitContext.get(key).getOrElse(throw Err.MissingInputState(key)).getContractState\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private def transactionMinimumRecordTime(\n+      maybeDeduplicateUntil: Option[Instant],\n+      ledgerTime: Instant,\n+      maxSkew: Duration,\n+      submissionTime: Instant): Instant =\n+    List(\n+      maybeDeduplicateUntil,\n+      Some(ledgerTime.minus(maxSkew)),\n+      Some(submissionTime.minus(maxSkew))).flatten.max\n+\n+  private def transactionMaximumRecordTime(ledgerTime: Instant, minSkew: Duration): Instant =\n+    ledgerTime.plus(minSkew)"
  },
  {
    "id" : "82b0b8f1-ce55-4561-ad9b-9b0e94d1c178",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "14153fb0-99c2-4560-9609-c5889650c3ee",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "If you are pattern matching on an `Option` always have `case Some(_)` and `case None`. Otherwise, you could just keep the `.map` + `.getOrElse` that was used here.",
        "createdAt" : "2020-07-03T09:17:30Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3fd8bbb6-c1f5-463d-baca-dc5def2d7a8a",
        "parentId" : "14153fb0-99c2-4560-9609-c5889650c3ee",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Yes, made the `None` branch explicit as also suggested by @andreaslochbihler-da.",
        "createdAt" : "2020-07-03T15:27:19Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : 22,
    "diffHunk" : "@@ -151,11 +151,12 @@ private[kvutils] class TransactionCommitter(\n \n   /** Validate ledger effective time and the command's time-to-live. */\n   private[committer] def validateLedgerTime: Step =\n-    (commitContext, transactionEntry) =>\n-      commitContext.getRecordTime\n-        .map { recordTime =>\n-          val (_, config) = getCurrentConfiguration(defaultConfig, commitContext.inputs, logger)\n-          val timeModel = config.timeModel\n+    (commitContext, transactionEntry) => {\n+      val (_, config) = getCurrentConfiguration(defaultConfig, commitContext.inputs, logger)\n+      val timeModel = config.timeModel\n+\n+      commitContext.getRecordTime match {"
  },
  {
    "id" : "4894596b-1178-45fa-9cb1-7d8f23dc9c80",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "93201bf0-1283-46de-8ca4-698c15a22189",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Minor: I'd use the `TimeModel` methods here as well for uniformity, although it's not required.",
        "createdAt" : "2020-07-03T15:39:35Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : null,
    "diffHunk" : "@@ -614,4 +631,32 @@ private[kvutils] object TransactionCommitter {\n   def getContractState(commitContext: CommitContext, key: DamlStateKey): DamlContractState =\n     commitContext.get(key).getOrElse(throw Err.MissingInputState(key)).getContractState\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private def transactionMinRecordTime(\n+      submissionTime: Instant,\n+      ledgerTime: Instant,\n+      maybeDeduplicateUntil: Option[Instant],\n+      maxSkew: Duration): Instant =\n+    List(\n+      maybeDeduplicateUntil\n+        .map(_.plus(TimeModel.resolution)), // DeduplicateUntil defines a rejection window, endpoints inclusive\n+      Some(TimeModel.minRecordTime(ledgerTime, maxSkew)),\n+      Some(submissionTime.minus(maxSkew))"
  },
  {
    "id" : "13a48972-6a64-40e7-a429-4224730bad55",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "839a7b42-f455-4c1a-a313-cd27b2adfbff",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "For readability just calculating the max of these mins should be simpler either via `.map` + `.getOrElse` for the optional one or branching on the optional one or putting in place of it something like epoch start which won't be the maximum. Here we are calling `.flatten` on a `List` that will surely have 2 values.",
        "createdAt" : "2020-07-03T15:54:18Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "87aea752-c000-4d03-bad4-14754a24a4da",
        "parentId" : "839a7b42-f455-4c1a-a313-cd27b2adfbff",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Will probably move this logic into `TimeModel` later.",
        "createdAt" : "2020-07-06T15:19:58Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : 65,
    "diffHunk" : "@@ -614,4 +631,32 @@ private[kvutils] object TransactionCommitter {\n   def getContractState(commitContext: CommitContext, key: DamlStateKey): DamlContractState =\n     commitContext.get(key).getOrElse(throw Err.MissingInputState(key)).getContractState\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private def transactionMinRecordTime(\n+      submissionTime: Instant,\n+      ledgerTime: Instant,\n+      maybeDeduplicateUntil: Option[Instant],\n+      maxSkew: Duration): Instant =\n+    List(\n+      maybeDeduplicateUntil"
  },
  {
    "id" : "9ac27e19-7229-4b5d-b2cc-4ebeaa79bf49",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "17535f5e-8202-4192-8bd0-94a12d4e6611",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "I don't have any context (and the new `CommitContext.minimumRecordTime` property doesn't seem to be used anywhere) - what exactly is the minimum record time, and why does it depend on the submission time and the command deduplication time window?",
        "createdAt" : "2020-07-06T18:44:34Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a80c3f66-a03a-4e0d-9879-d99995fe85ab",
        "parentId" : "17535f5e-8202-4192-8bd0-94a12d4e6611",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "This property will be read by `KeyValueCommitting.dryRun` for pre-execution (see #6592 ). In case of pre-execution we are delaying the time-bound checks to post-execution as the record time will be only known then. Hence, we have to keep track of the time-bounds that are influenced by submission time and command deduplication time window in case of transactions. In the post-execution phase we only check the current record time against the time-bounds determined by the `Commiter`s.",
        "createdAt" : "2020-07-07T08:20:58Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : 59,
    "diffHunk" : "@@ -613,4 +630,32 @@ private[kvutils] object TransactionCommitter {\n   def getContractState(commitContext: CommitContext, key: DamlStateKey): DamlContractState =\n     commitContext.get(key).getOrElse(throw Err.MissingInputState(key)).getContractState\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private def transactionMinRecordTime("
  },
  {
    "id" : "f11051a2-f122-4522-b8a6-7cb2a284f28c",
    "prId" : 6591,
    "comments" : [
      {
        "id" : "3b61fece-d9ce-42a5-ae37-1270c1b0269c",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "The time model only describes a relation between the ledger time and the record time, the use of submission time here looks suspicious.",
        "createdAt" : "2020-07-06T18:46:28Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5a378336-959a-4389-9cb9-fc06c03d7ca4",
        "parentId" : "3b61fece-d9ce-42a5-ae37-1270c1b0269c",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "As explained above, for pre-execution we need to ensure that the submission is still valid at the record time determined at post-execution hence the use of submission time here (we verify submission time against record time normally as part of the validation steps performed by `TransactionCommitter` in case of normal execution).",
        "createdAt" : "2020-07-07T09:20:54Z",
        "updatedAt" : "2020-07-07T09:21:34Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3d287ab9-e22e-4fdd-8c26-9a70dd7a0f0f",
        "parentId" : "3b61fece-d9ce-42a5-ae37-1270c1b0269c",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Ok, I see - the validity of submission time is somewhat loosly defined by https://github.com/digital-asset/daml/blob/master/daml-lf/spec/contract-id.rst#submission-time, and you chose to use the ledger time model bounds for submission time check. ",
        "createdAt" : "2020-07-07T12:15:12Z",
        "updatedAt" : "2020-07-07T12:15:13Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "586131eb-9bee-4225-8267-fbec8784927e",
        "parentId" : "3b61fece-d9ce-42a5-ae37-1270c1b0269c",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Exactly!",
        "createdAt" : "2020-07-07T13:31:34Z",
        "updatedAt" : "2020-07-07T13:31:35Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "69acdd932ebffbf0a5f1f579bdea8256ed94439f",
    "line" : 68,
    "diffHunk" : "@@ -613,4 +630,32 @@ private[kvutils] object TransactionCommitter {\n   def getContractState(commitContext: CommitContext, key: DamlStateKey): DamlContractState =\n     commitContext.get(key).getOrElse(throw Err.MissingInputState(key)).getContractState\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Option2Iterable\"))\n+  private def transactionMinRecordTime(\n+      submissionTime: Instant,\n+      ledgerTime: Instant,\n+      maybeDeduplicateUntil: Option[Instant],\n+      timeModel: TimeModel): Instant =\n+    List(\n+      maybeDeduplicateUntil\n+        .map(_.plus(TimeModel.Resolution)), // DeduplicateUntil defines a rejection window, endpoints inclusive\n+      Some(timeModel.minRecordTime(ledgerTime)),\n+      Some(timeModel.minRecordTime(submissionTime))"
  },
  {
    "id" : "65551a3a-adc7-4b4a-8088-1974a79cda21",
    "prId" : 6538,
    "comments" : [
      {
        "id" : "ce6c9501-ded6-4a8f-bec4-1431365c209b",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Note that `import com.daml.ledger.participant.state.kvutils.committer.TransactionCommitter._` above seems to have become unused.",
        "createdAt" : "2020-07-01T09:13:34Z",
        "updatedAt" : "2020-07-01T13:47:51Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "91885873-de31-4e1f-b93d-054ec682219a",
        "parentId" : "ce6c9501-ded6-4a8f-bec4-1431365c209b",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Removed.",
        "createdAt" : "2020-07-01T12:48:07Z",
        "updatedAt" : "2020-07-01T13:47:51Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7fcd13b1e8abafa8318221497401dd1746cfe5e2",
    "line" : 9,
    "diffHunk" : "@@ -82,23 +82,27 @@ private[kvutils] class TransactionCommitter(\n "
  },
  {
    "id" : "901dee5b-5286-4e29-bf86-f9c04b896964",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "374e109d-8928-4134-92d3-1b1c5aac29f7",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Might be worth implementing `flatMap` on `StepResult`.",
        "createdAt" : "2020-05-07T21:27:22Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a3d77f16-0ab2-4399-8487-e14bc6c50e65",
        "parentId" : "374e109d-8928-4134-92d3-1b1c5aac29f7",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "I could also implement semigroup :-) I think it is not worth it for just one occurence",
        "createdAt" : "2020-05-08T18:08:36Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : null,
    "diffHunk" : "@@ -139,134 +132,117 @@ private[kvutils] class ProcessTransactionSubmission(\n     * If the \"open world\" setting is enabled we allow the submission even if the\n     * party is unallocated.\n     */\n-  private def authorizeSubmitter(\n-      recordTime: Timestamp,\n-      participantId: ParticipantId,\n-      transactionEntry: TransactionEntry,\n-  ): Commit[Unit] =\n-    get(partyStateKey(transactionEntry.submitter)).flatMap {\n+  private def authorizeSubmitter: Step = (ctx, digest) => {\n+    ctx.get(partyStateKey(digest.submitter)) match {\n       case Some(partyAllocation) =>\n-        if (partyAllocation.getParty.getParticipantId == participantId)\n-          pass\n+        if (partyAllocation.getParty.getParticipantId == ctx.getParticipantId)\n+          StepContinue(digest)\n         else\n           reject(\n-            recordTime,\n+            ctx.getRecordTime,\n             buildRejectionLogEntry(\n-              transactionEntry,\n+              digest,\n               RejectionReason.SubmitterCannotActViaParticipant(\n-                s\"Party '${transactionEntry.submitter}' not hosted by participant $participantId\"))\n+                s\"Party '${digest.submitter}' not hosted by participant $ctx.getParticipantId\"))\n           )\n       case None =>\n         reject(\n-          recordTime,\n+          ctx.getRecordTime,\n           buildRejectionLogEntry(\n-            transactionEntry,\n+            digest,\n             RejectionReason.PartyNotKnownOnLedger(\n-              s\"Submitting party '${transactionEntry.submitter}' not known\"))\n+              s\"Submitting party '${digest.submitter}' not known\"))\n         )\n     }\n+  }\n \n   /** Validate ledger effective time and the command's time-to-live. */\n-  private def validateLedgerTime(\n-      recordTime: Timestamp,\n-      transactionEntry: TransactionEntry,\n-      inputState: DamlStateMap,\n-  ): Commit[Unit] = delay {\n-    val (_, config) = Common.getCurrentConfiguration(defaultConfig, inputState, logger)\n+  private def validateLedgerTime: Step = (ctx, digest) => {\n+    val (_, config) = getCurrentConfiguration(defaultConfig, ctx.inputs, logger)\n     val timeModel = config.timeModel\n-    val givenLedgerTime = transactionEntry.ledgerEffectiveTime.toInstant\n+    val givenLedgerTime = digest.ledgerEffectiveTime.toInstant\n \n     timeModel\n-      .checkTime(ledgerTime = givenLedgerTime, recordTime = recordTime.toInstant)\n+      .checkTime(ledgerTime = givenLedgerTime, recordTime = ctx.getRecordTime.toInstant)\n       .fold(\n         reason =>\n           reject(\n-            recordTime,\n-            buildRejectionLogEntry(transactionEntry, RejectionReason.InvalidLedgerTime(reason))),\n-        _ => pass)\n+            ctx.getRecordTime,\n+            buildRejectionLogEntry(digest, RejectionReason.InvalidLedgerTime(reason))),\n+        _ => StepContinue(digest))\n   }\n \n   /** Validate the submission's conformance to the DAML model */\n-  private def validateModelConformance(\n-      engine: Engine,\n-      recordTime: Timestamp,\n-      participantId: ParticipantId,\n-      transactionEntry: TransactionEntry,\n-      inputState: DamlStateMap,\n-  ): Commit[Unit] = delay {\n-    // Pull all keys from referenced contracts. We require this for 'fetchByKey' calls\n-    // which are not evidenced in the transaction itself and hence the contract key state is\n-    // not included in the inputs.\n-    lazy val knownKeys: Map[DamlContractKey, Value.AbsoluteContractId] =\n-      inputState.collect {\n-        case (key, Some(value))\n-            if value.hasContractState\n-              && value.getContractState.hasContractKey\n-              && contractIsActiveAndVisibleToSubmitter(transactionEntry, value.getContractState) =>\n-          value.getContractState.getContractKey -> Conversions.stateKeyToContractId(key)\n-      }\n+  private def validateModelConformance: Step =\n+    (ctx, digest) =>\n+      metrics.daml.kvutils.committer.transaction.interpretTimer.time(() => {\n+        // Pull all keys from referenced contracts. We require this for 'fetchByKey' calls\n+        // which are not evidenced in the transaction itself and hence the contract key state is\n+        // not included in the inputs.\n+        lazy val knownKeys: Map[DamlContractKey, Value.AbsoluteContractId] =\n+          ctx.inputs.collect {\n+            case (key, Some(value))\n+                if value.hasContractState\n+                  && value.getContractState.hasContractKey\n+                  && contractIsActiveAndVisibleToSubmitter(digest, value.getContractState) =>\n+              value.getContractState.getContractKey -> Conversions.stateKeyToContractId(key)\n+          }\n \n-    engine\n-      .validate(\n-        transactionEntry.abs,\n-        transactionEntry.ledgerEffectiveTime,\n-        participantId,\n-        transactionEntry.submissionTime,\n-        transactionEntry.submissionSeed,\n-      )\n-      .consume(\n-        lookupContract(transactionEntry, inputState),\n-        lookupPackage(transactionEntry, inputState),\n-        lookupKey(transactionEntry, inputState, knownKeys),\n-      )\n-      .fold(\n-        err =>\n-          reject(\n-            recordTime,\n-            buildRejectionLogEntry(transactionEntry, RejectionReason.Disputed(err.msg))),\n-        _ => pass)\n-  }\n+        engine\n+          .validate(\n+            digest.abs,\n+            digest.ledgerEffectiveTime,\n+            ctx.getParticipantId,\n+            digest.submissionTime,\n+            digest.submissionSeed,\n+          )\n+          .consume(\n+            lookupContract(digest, ctx.inputs),\n+            lookupPackage(digest, ctx.inputs),\n+            lookupKey(digest, ctx.inputs, knownKeys),\n+          )\n+          .fold(\n+            err =>\n+              reject[TransactionCommitter.Digest](\n+                ctx.getRecordTime,\n+                buildRejectionLogEntry(digest, RejectionReason.Disputed(err.msg))),\n+            _ => StepContinue[TransactionCommitter.Digest](digest)\n+          )\n+      })\n \n   /** Validate the submission's conformance to the DAML model */\n-  private def authorizeAndBlind(\n-      recordTime: Timestamp,\n-      transactionEntry: TransactionEntry,\n-  ): Commit[BlindingInfo] = delay {\n-    Blinding\n-      .checkAuthorizationAndBlind(\n-        transactionEntry.abs,\n-        initialAuthorizers = Set(transactionEntry.submitter),\n-      )\n-      .fold(\n-        err =>\n-          reject(\n-            recordTime,\n-            buildRejectionLogEntry(transactionEntry, RejectionReason.Disputed(err.msg))),\n-        pure)\n-  }\n+  private def authorizeAndBlind: Step =\n+    (ctx, digest) =>\n+      Blinding\n+        .checkAuthorizationAndBlind(\n+          digest.abs,\n+          initialAuthorizers = Set(digest.submitter),\n+        )\n+        .fold(\n+          err =>\n+            reject(\n+              ctx.getRecordTime,\n+              buildRejectionLogEntry(digest, RejectionReason.Disputed(err.msg))),\n+          succ => buildFinalResult(ctx, digest, succ))\n+\n+  private def validateContractKeys: Step = (ctx, digest) => {\n+    val damlState = ctx.inputs.collect { case (k, Some(v)) => k -> v } ++ ctx.getOutputs\n+    val startingKeys = damlState.collect {\n+      case (k, v) if k.hasContractKey && v.getContractKeyState.getContractId.nonEmpty => k\n+    }.toSet\n+    validateContractKeyUniqueness(ctx.getRecordTime, digest, startingKeys) match {"
  },
  {
    "id" : "159ed7fc-6e9f-41c8-93f4-560fc1213816",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "9ddad4b6-b3ee-4177-9225-dd01cf30cf37",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n  case class DamlTransactionEntrySummary(submission: DamlTransactionEntry) {\r\n```",
        "createdAt" : "2020-05-08T07:15:02Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : null,
    "diffHunk" : "@@ -1,35 +1,46 @@\n // Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n-package com.daml.ledger.participant.state.kvutils.committing\n+package com.daml.ledger.participant.state.kvutils.committer\n \n import java.time.Instant\n \n import com.codahale.metrics.Counter\n import com.daml.ledger.participant.state.kvutils.Conversions._\n import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n-import com.daml.ledger.participant.state.kvutils.committing.Common.Commit._\n-import com.daml.ledger.participant.state.kvutils.committing.Common._\n-import com.daml.ledger.participant.state.kvutils.committing.ProcessTransactionSubmission._\n+import com.daml.ledger.participant.state.kvutils.committer.Committer._\n import com.daml.ledger.participant.state.kvutils.{Conversions, DamlStateMap, Err, InputsAndEffects}\n-import com.daml.ledger.participant.state.v1.{Configuration, ParticipantId, RejectionReason}\n+import com.daml.ledger.participant.state.v1.{Configuration, RejectionReason}\n import com.daml.lf.archive.Decode\n import com.daml.lf.archive.Reader.ParseError\n import com.daml.lf.crypto\n import com.daml.lf.data.Ref.{PackageId, Party}\n import com.daml.lf.data.Time.Timestamp\n import com.daml.lf.engine.{Blinding, Engine}\n import com.daml.lf.language.Ast\n-import com.daml.lf.transaction.Transaction.AbsTransaction\n import com.daml.lf.transaction.{BlindingInfo, GenTransaction, Node}\n+import com.daml.lf.transaction.Transaction.AbsTransaction\n import com.daml.lf.value.Value\n import com.daml.lf.value.Value.AbsoluteContractId\n import com.daml.metrics.Metrics\n import com.google.protobuf.{Timestamp => ProtoTimestamp}\n-import org.slf4j.{Logger, LoggerFactory}\n \n import scala.collection.JavaConverters._\n \n+private[kvutils] object TransactionCommitter {\n+\n+  case class Digest(submission: DamlTransactionEntry) {"
  },
  {
    "id" : "e31bdaa7-48ce-45c4-b911-a3d1b4a37487",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "885deec3-7e40-4d4a-97ac-0f7826824f67",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n    lazy val absoluteTransaction: AbsTransaction = Conversions.decodeTransaction(submission.getTransaction)\r\n```",
        "createdAt" : "2020-05-08T07:15:20Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c552ca8-0fa3-4bf8-9b77-aa96455cdbf9",
        "parentId" : "885deec3-7e40-4d4a-97ac-0f7826824f67",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Why does it help for it to be `lazy`?",
        "createdAt" : "2020-05-08T07:20:10Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b9e66017-742e-4f26-ba7c-6081e81c9c1f",
        "parentId" : "885deec3-7e40-4d4a-97ac-0f7826824f67",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "That was there in the original implementation. I am guessing it is to avoid decoding upfront, when the transaction can fail on a more rudimentary validation before",
        "createdAt" : "2020-05-08T08:44:12Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : null,
    "diffHunk" : "@@ -1,35 +1,46 @@\n // Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n-package com.daml.ledger.participant.state.kvutils.committing\n+package com.daml.ledger.participant.state.kvutils.committer\n \n import java.time.Instant\n \n import com.codahale.metrics.Counter\n import com.daml.ledger.participant.state.kvutils.Conversions._\n import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n-import com.daml.ledger.participant.state.kvutils.committing.Common.Commit._\n-import com.daml.ledger.participant.state.kvutils.committing.Common._\n-import com.daml.ledger.participant.state.kvutils.committing.ProcessTransactionSubmission._\n+import com.daml.ledger.participant.state.kvutils.committer.Committer._\n import com.daml.ledger.participant.state.kvutils.{Conversions, DamlStateMap, Err, InputsAndEffects}\n-import com.daml.ledger.participant.state.v1.{Configuration, ParticipantId, RejectionReason}\n+import com.daml.ledger.participant.state.v1.{Configuration, RejectionReason}\n import com.daml.lf.archive.Decode\n import com.daml.lf.archive.Reader.ParseError\n import com.daml.lf.crypto\n import com.daml.lf.data.Ref.{PackageId, Party}\n import com.daml.lf.data.Time.Timestamp\n import com.daml.lf.engine.{Blinding, Engine}\n import com.daml.lf.language.Ast\n-import com.daml.lf.transaction.Transaction.AbsTransaction\n import com.daml.lf.transaction.{BlindingInfo, GenTransaction, Node}\n+import com.daml.lf.transaction.Transaction.AbsTransaction\n import com.daml.lf.value.Value\n import com.daml.lf.value.Value.AbsoluteContractId\n import com.daml.metrics.Metrics\n import com.google.protobuf.{Timestamp => ProtoTimestamp}\n-import org.slf4j.{Logger, LoggerFactory}\n \n import scala.collection.JavaConverters._\n \n+private[kvutils] object TransactionCommitter {\n+\n+  case class Digest(submission: DamlTransactionEntry) {\n+    val ledgerEffectiveTime: Timestamp = parseTimestamp(submission.getLedgerEffectiveTime)\n+    val submitterInfo: DamlSubmitterInfo = submission.getSubmitterInfo\n+    val commandId: String = submitterInfo.getCommandId\n+    val submitter: Party = Party.assertFromString(submitterInfo.getSubmitter)\n+    lazy val abs: AbsTransaction = Conversions.decodeTransaction(submission.getTransaction)"
  },
  {
    "id" : "240c6a54-9248-4b5f-9f84-0a86fc7df7c1",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "821a570e-9abf-40d8-9dea-6cf985571a86",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n      commitContext: CommitContext,\r\n```",
        "createdAt" : "2020-05-08T07:15:36Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : null,
    "diffHunk" : "@@ -41,81 +52,63 @@ import scala.collection.JavaConverters._\n // * Adding and additional submission field commandDedupSubmissionTime field. While having participants\n //   provide this field *could* lead to possible exploits, they are not exploits that could do any harm.\n //   The bigger concern is adding a public API for the specific use case of Sandbox with static time.\n-private[kvutils] class ProcessTransactionSubmission(\n+private[kvutils] class TransactionCommitter(\n     defaultConfig: Configuration,\n     engine: Engine,\n-    metrics: Metrics,\n+    override protected val metrics: Metrics,\n     inStaticTimeMode: Boolean\n-) {\n-\n-  private implicit val logger: Logger = LoggerFactory.getLogger(this.getClass)\n-\n-  def run(\n-      entryId: DamlLogEntryId,\n-      recordTime: Timestamp,\n-      participantId: ParticipantId,\n-      txEntry: DamlTransactionEntry,\n-      inputState: DamlStateMap,\n-  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n-    metrics.daml.kvutils.committer.transaction.runTimer.time { () =>\n-      val transactionEntry = TransactionEntry(txEntry)\n-      runSequence(\n-        inputState = inputState,\n-        \"Authorize submitter\" -> authorizeSubmitter(recordTime, participantId, transactionEntry),\n-        \"Check Informee Parties Allocation\" ->\n-          checkInformeePartiesAllocation(recordTime, transactionEntry),\n-        \"Deduplicate\" -> deduplicateCommand(recordTime, transactionEntry),\n-        \"Validate Ledger Time\" -> validateLedgerTime(recordTime, transactionEntry, inputState),\n-        \"Validate Contract Keys\" ->\n-          validateContractKeys(recordTime, transactionEntry),\n-        \"Validate Model Conformance\" -> timed(\n-          metrics.daml.kvutils.committer.transaction.interpretTimer,\n-          validateModelConformance(engine, recordTime, participantId, transactionEntry, inputState),\n-        ),\n-        \"Authorize and build result\" ->\n-          authorizeAndBlind(recordTime, transactionEntry).flatMap(\n-            buildFinalResult(entryId, recordTime, transactionEntry))\n-      )\n-    }\n+) extends Committer[DamlTransactionEntry, TransactionCommitter.Digest] {\n+  override protected val committerName = \"transaction\"\n+\n+  override protected def init(\n+      ctx: CommitContext,"
  },
  {
    "id" : "2657fe99-c98e-4375-b6b7-b364a5b669f1",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "d29bd457-bf49-4d43-892b-26492905f98b",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Can this be shortened?",
        "createdAt" : "2020-05-08T07:18:01Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "86e26eb3-7e25-4db4-a6fa-2ede5243b85d",
        "parentId" : "d29bd457-bf49-4d43-892b-26492905f98b",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I find it quite handy because one can see the full metric patch.",
        "createdAt" : "2020-05-08T07:35:14Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a831f60f-752e-41b0-95af-a267c97c2d36",
        "parentId" : "d29bd457-bf49-4d43-892b-26492905f98b",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "True, I was thinking about aliasing with a shorter but still meaningful name such as `commitInterpreterTime`, the long name would only be a click away. Disavantage: not one click away on Github so, on second thought, I withdraw it.",
        "createdAt" : "2020-05-08T07:48:52Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : 240,
    "diffHunk" : "@@ -139,134 +132,117 @@ private[kvutils] class ProcessTransactionSubmission(\n     * If the \"open world\" setting is enabled we allow the submission even if the\n     * party is unallocated.\n     */\n-  private def authorizeSubmitter(\n-      recordTime: Timestamp,\n-      participantId: ParticipantId,\n-      transactionEntry: TransactionEntry,\n-  ): Commit[Unit] =\n-    get(partyStateKey(transactionEntry.submitter)).flatMap {\n+  private def authorizeSubmitter: Step = (ctx, digest) => {\n+    ctx.get(partyStateKey(digest.submitter)) match {\n       case Some(partyAllocation) =>\n-        if (partyAllocation.getParty.getParticipantId == participantId)\n-          pass\n+        if (partyAllocation.getParty.getParticipantId == ctx.getParticipantId)\n+          StepContinue(digest)\n         else\n           reject(\n-            recordTime,\n+            ctx.getRecordTime,\n             buildRejectionLogEntry(\n-              transactionEntry,\n+              digest,\n               RejectionReason.SubmitterCannotActViaParticipant(\n-                s\"Party '${transactionEntry.submitter}' not hosted by participant $participantId\"))\n+                s\"Party '${digest.submitter}' not hosted by participant $ctx.getParticipantId\"))\n           )\n       case None =>\n         reject(\n-          recordTime,\n+          ctx.getRecordTime,\n           buildRejectionLogEntry(\n-            transactionEntry,\n+            digest,\n             RejectionReason.PartyNotKnownOnLedger(\n-              s\"Submitting party '${transactionEntry.submitter}' not known\"))\n+              s\"Submitting party '${digest.submitter}' not known\"))\n         )\n     }\n+  }\n \n   /** Validate ledger effective time and the command's time-to-live. */\n-  private def validateLedgerTime(\n-      recordTime: Timestamp,\n-      transactionEntry: TransactionEntry,\n-      inputState: DamlStateMap,\n-  ): Commit[Unit] = delay {\n-    val (_, config) = Common.getCurrentConfiguration(defaultConfig, inputState, logger)\n+  private def validateLedgerTime: Step = (ctx, digest) => {\n+    val (_, config) = getCurrentConfiguration(defaultConfig, ctx.inputs, logger)\n     val timeModel = config.timeModel\n-    val givenLedgerTime = transactionEntry.ledgerEffectiveTime.toInstant\n+    val givenLedgerTime = digest.ledgerEffectiveTime.toInstant\n \n     timeModel\n-      .checkTime(ledgerTime = givenLedgerTime, recordTime = recordTime.toInstant)\n+      .checkTime(ledgerTime = givenLedgerTime, recordTime = ctx.getRecordTime.toInstant)\n       .fold(\n         reason =>\n           reject(\n-            recordTime,\n-            buildRejectionLogEntry(transactionEntry, RejectionReason.InvalidLedgerTime(reason))),\n-        _ => pass)\n+            ctx.getRecordTime,\n+            buildRejectionLogEntry(digest, RejectionReason.InvalidLedgerTime(reason))),\n+        _ => StepContinue(digest))\n   }\n \n   /** Validate the submission's conformance to the DAML model */\n-  private def validateModelConformance(\n-      engine: Engine,\n-      recordTime: Timestamp,\n-      participantId: ParticipantId,\n-      transactionEntry: TransactionEntry,\n-      inputState: DamlStateMap,\n-  ): Commit[Unit] = delay {\n-    // Pull all keys from referenced contracts. We require this for 'fetchByKey' calls\n-    // which are not evidenced in the transaction itself and hence the contract key state is\n-    // not included in the inputs.\n-    lazy val knownKeys: Map[DamlContractKey, Value.AbsoluteContractId] =\n-      inputState.collect {\n-        case (key, Some(value))\n-            if value.hasContractState\n-              && value.getContractState.hasContractKey\n-              && contractIsActiveAndVisibleToSubmitter(transactionEntry, value.getContractState) =>\n-          value.getContractState.getContractKey -> Conversions.stateKeyToContractId(key)\n-      }\n+  private def validateModelConformance: Step =\n+    (ctx, digest) =>\n+      metrics.daml.kvutils.committer.transaction.interpretTimer.time(() => {"
  },
  {
    "id" : "c36906e2-7bd8-4569-b5ed-cef474bbe0ad",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "af521158-6c66-4aa4-a13e-fb5b73308315",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n    \"authorize_and_blind\" -> authorizeAndBlind\r\n```",
        "createdAt" : "2020-05-08T14:09:37Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : null,
    "diffHunk" : "@@ -41,47 +40,34 @@ import scala.collection.JavaConverters._\n // * Adding and additional submission field commandDedupSubmissionTime field. While having participants\n //   provide this field *could* lead to possible exploits, they are not exploits that could do any harm.\n //   The bigger concern is adding a public API for the specific use case of Sandbox with static time.\n-private[kvutils] class ProcessTransactionSubmission(\n+private[kvutils] class TransactionCommitter(\n     defaultConfig: Configuration,\n     engine: Engine,\n-    metrics: Metrics,\n+    override protected val metrics: Metrics,\n     inStaticTimeMode: Boolean\n-) {\n-\n-  private implicit val logger: Logger = LoggerFactory.getLogger(this.getClass)\n-\n-  def run(\n-      entryId: DamlLogEntryId,\n-      recordTime: Timestamp,\n-      participantId: ParticipantId,\n-      txEntry: DamlTransactionEntry,\n-      inputState: DamlStateMap,\n-  ): (DamlLogEntry, Map[DamlStateKey, DamlStateValue]) =\n-    metrics.daml.kvutils.committer.transaction.runTimer.time { () =>\n-      val transactionEntry = TransactionEntry(txEntry)\n-      runSequence(\n-        inputState = inputState,\n-        \"Authorize submitter\" -> authorizeSubmitter(recordTime, participantId, transactionEntry),\n-        \"Check Informee Parties Allocation\" ->\n-          checkInformeePartiesAllocation(recordTime, transactionEntry),\n-        \"Deduplicate\" -> deduplicateCommand(recordTime, transactionEntry),\n-        \"Validate Ledger Time\" -> validateLedgerTime(recordTime, transactionEntry, inputState),\n-        \"Validate Contract Keys\" ->\n-          validateContractKeys(recordTime, transactionEntry),\n-        \"Validate Model Conformance\" -> timed(\n-          metrics.daml.kvutils.committer.transaction.interpretTimer,\n-          validateModelConformance(engine, recordTime, participantId, transactionEntry, inputState),\n-        ),\n-        \"Authorize and build result\" ->\n-          authorizeAndBlind(recordTime, transactionEntry).flatMap(\n-            buildFinalResult(entryId, recordTime, transactionEntry))\n-      )\n-    }\n+) extends Committer[DamlTransactionEntry, TransactionCommitter.DamlTransactionEntrySummary] {\n+  override protected val committerName = \"transaction\"\n+\n+  override protected def init(\n+      commitContext: CommitContext,\n+      transactionEntry: DamlTransactionEntry,\n+  ): TransactionCommitter.DamlTransactionEntrySummary =\n+    TransactionCommitter.DamlTransactionEntrySummary(transactionEntry)\n+\n+  override protected val steps: Iterable[(StepInfo, Step)] = Iterable(\n+    \"authorize_submitter\" -> authorizeSubmitter,\n+    \"check_informee_parties_allocation\" -> checkInformeePartiesAllocation,\n+    \"deduplicate\" -> deduplicateCommand,\n+    \"validate_ledger_time\" -> validateLedgerTime,\n+    \"validate_contract_keys\" -> validateContractKeys,\n+    \"validate_model_conformance\" -> validateModelConformance,\n+    \"authorize_and_build_result\" -> authorizeAndBlind"
  },
  {
    "id" : "612ba3c4-0470-4b16-baca-a32016f043b4",
    "prId" : 5901,
    "comments" : [
      {
        "id" : "0d223e8b-43e3-4986-8cd1-db5a85a251c7",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n                s\"Party '${transactionEntry.submitter}' not hosted by participant ${commitContext.getParticipantId}\")\r\n```",
        "createdAt" : "2020-05-08T14:17:53Z",
        "updatedAt" : "2020-05-08T18:45:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ee7ac8b5c8db2514f0b159448d9f9104133666c7",
    "line" : null,
    "diffHunk" : "@@ -139,134 +122,127 @@ private[kvutils] class ProcessTransactionSubmission(\n     * If the \"open world\" setting is enabled we allow the submission even if the\n     * party is unallocated.\n     */\n-  private def authorizeSubmitter(\n-      recordTime: Timestamp,\n-      participantId: ParticipantId,\n-      transactionEntry: TransactionEntry,\n-  ): Commit[Unit] =\n-    get(partyStateKey(transactionEntry.submitter)).flatMap {\n+  private def authorizeSubmitter: Step = (commitContext, transactionEntry) => {\n+    commitContext.get(partyStateKey(transactionEntry.submitter)) match {\n       case Some(partyAllocation) =>\n-        if (partyAllocation.getParty.getParticipantId == participantId)\n-          pass\n+        if (partyAllocation.getParty.getParticipantId == commitContext.getParticipantId)\n+          StepContinue(transactionEntry)\n         else\n           reject(\n-            recordTime,\n+            commitContext.getRecordTime,\n             buildRejectionLogEntry(\n               transactionEntry,\n               RejectionReason.SubmitterCannotActViaParticipant(\n-                s\"Party '${transactionEntry.submitter}' not hosted by participant $participantId\"))\n+                s\"Party '${transactionEntry.submitter}' not hosted by participant $commitContext.getParticipantId\")"
  }
]