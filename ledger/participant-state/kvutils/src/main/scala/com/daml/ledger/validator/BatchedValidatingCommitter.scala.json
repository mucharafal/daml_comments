[
  {
    "id" : "0efadf81-797a-4c9b-a81c-4a34f739079a",
    "prId" : 6186,
    "comments" : [
      {
        "id" : "e8f51df6-ed51-40a1-a073-338d8f3437e6",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n  * When caching is enabled (i.e., [[stateValueCache]] is not a [[Cache.none]]), for each\r\n```",
        "createdAt" : "2020-06-02T10:57:12Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "80a3f97a-648b-4699-b2ca-e2dd4a6c9748",
        "parentId" : "e8f51df6-ed51-40a1-a073-338d8f3437e6",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I'd go for `If` instead of `When` because this is conditional rather than temporal.",
        "createdAt" : "2020-06-02T11:19:35Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54fa77cf2c950cdc36630aa964677462b028d52a",
    "line" : null,
    "diffHunk" : "@@ -18,6 +18,37 @@ import com.daml.ledger.validator.batch.{\n import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n \n+/**\n+  * Orchestrates committing to a ledger after validating submissions. Supports parallel validation.\n+  * Example usage, assuming a [[com.daml.ledger.participant.state.kvutils.api.BatchingLedgerWriter]] sends the\n+  * batched submissions over the wire:\n+  * {{{\n+  *   ...\n+  *   private val ledgerStateOperations = ...\n+  *   private val validator = BatchedSubmissionValidator.create(ledgerStateOperations)\n+  *   private val validatingCommitter = BatchedValidatingCommitter(\n+  *       () => Instant.now(),\n+  *       validator)\n+  *   ...\n+  *\n+  *   def commitRequestHandler(request: CommitRequest): Future[CommitResponse] =\n+  *     validatingCommitter.commit(\n+  *         request.correlationId,\n+  *         request.envelope,\n+  *         request.participantId,\n+  *         ledgerStateOperations)\n+  *       .map(...)\n+  * }}}\n+  *\n+  * In case caching is enabled (i.e., [[stateValueCache]] is not a [[Cache.none]]) then for each"
  },
  {
    "id" : "d0722d5c-0135-4eaf-b510-2a94c238482e",
    "prId" : 6186,
    "comments" : [
      {
        "id" : "64e319ff-9420-4ad2-868c-5fe26027c8f3",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n  * @param now resolves the current time when processing submission\r\n```",
        "createdAt" : "2020-06-02T10:57:53Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54fa77cf2c950cdc36630aa964677462b028d52a",
    "line" : null,
    "diffHunk" : "@@ -18,6 +18,37 @@ import com.daml.ledger.validator.batch.{\n import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n \n+/**\n+  * Orchestrates committing to a ledger after validating submissions. Supports parallel validation.\n+  * Example usage, assuming a [[com.daml.ledger.participant.state.kvutils.api.BatchingLedgerWriter]] sends the\n+  * batched submissions over the wire:\n+  * {{{\n+  *   ...\n+  *   private val ledgerStateOperations = ...\n+  *   private val validator = BatchedSubmissionValidator.create(ledgerStateOperations)\n+  *   private val validatingCommitter = BatchedValidatingCommitter(\n+  *       () => Instant.now(),\n+  *       validator)\n+  *   ...\n+  *\n+  *   def commitRequestHandler(request: CommitRequest): Future[CommitResponse] =\n+  *     validatingCommitter.commit(\n+  *         request.correlationId,\n+  *         request.envelope,\n+  *         request.participantId,\n+  *         ledgerStateOperations)\n+  *       .map(...)\n+  * }}}\n+  *\n+  * In case caching is enabled (i.e., [[stateValueCache]] is not a [[Cache.none]]) then for each\n+  * request we cache the read state from the ledger and update the cache with the committed state.\n+  *\n+  * @param now function implementing resolution of current time when processing submission"
  },
  {
    "id" : "02260f2c-b50d-4db6-ba41-3d7433d4136c",
    "prId" : 6186,
    "comments" : [
      {
        "id" : "e567e3dd-5513-422f-8427-598dcb50e493",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n  * @param keySerializationStrategy strategy for serializing & namespacing state keys\r\n```",
        "createdAt" : "2020-06-02T10:58:10Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54fa77cf2c950cdc36630aa964677462b028d52a",
    "line" : null,
    "diffHunk" : "@@ -18,6 +18,37 @@ import com.daml.ledger.validator.batch.{\n import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n \n+/**\n+  * Orchestrates committing to a ledger after validating submissions. Supports parallel validation.\n+  * Example usage, assuming a [[com.daml.ledger.participant.state.kvutils.api.BatchingLedgerWriter]] sends the\n+  * batched submissions over the wire:\n+  * {{{\n+  *   ...\n+  *   private val ledgerStateOperations = ...\n+  *   private val validator = BatchedSubmissionValidator.create(ledgerStateOperations)\n+  *   private val validatingCommitter = BatchedValidatingCommitter(\n+  *       () => Instant.now(),\n+  *       validator)\n+  *   ...\n+  *\n+  *   def commitRequestHandler(request: CommitRequest): Future[CommitResponse] =\n+  *     validatingCommitter.commit(\n+  *         request.correlationId,\n+  *         request.envelope,\n+  *         request.participantId,\n+  *         ledgerStateOperations)\n+  *       .map(...)\n+  * }}}\n+  *\n+  * In case caching is enabled (i.e., [[stateValueCache]] is not a [[Cache.none]]) then for each\n+  * request we cache the read state from the ledger and update the cache with the committed state.\n+  *\n+  * @param now function implementing resolution of current time when processing submission\n+  * @param keySerializationStrategy instance to use for serializing & namespacing state keys"
  },
  {
    "id" : "8717d2b2-508b-4f94-b631-1388668fbe54",
    "prId" : 6186,
    "comments" : [
      {
        "id" : "e5daeb0b-7c35-4d58-945d-2f9a253a017d",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n  * @param stateValueCache cache to be used when reading from and committing to the ledger\r\n```",
        "createdAt" : "2020-06-02T10:59:06Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54fa77cf2c950cdc36630aa964677462b028d52a",
    "line" : null,
    "diffHunk" : "@@ -18,6 +18,37 @@ import com.daml.ledger.validator.batch.{\n import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n \n+/**\n+  * Orchestrates committing to a ledger after validating submissions. Supports parallel validation.\n+  * Example usage, assuming a [[com.daml.ledger.participant.state.kvutils.api.BatchingLedgerWriter]] sends the\n+  * batched submissions over the wire:\n+  * {{{\n+  *   ...\n+  *   private val ledgerStateOperations = ...\n+  *   private val validator = BatchedSubmissionValidator.create(ledgerStateOperations)\n+  *   private val validatingCommitter = BatchedValidatingCommitter(\n+  *       () => Instant.now(),\n+  *       validator)\n+  *   ...\n+  *\n+  *   def commitRequestHandler(request: CommitRequest): Future[CommitResponse] =\n+  *     validatingCommitter.commit(\n+  *         request.correlationId,\n+  *         request.envelope,\n+  *         request.participantId,\n+  *         ledgerStateOperations)\n+  *       .map(...)\n+  * }}}\n+  *\n+  * In case caching is enabled (i.e., [[stateValueCache]] is not a [[Cache.none]]) then for each\n+  * request we cache the read state from the ledger and update the cache with the committed state.\n+  *\n+  * @param now function implementing resolution of current time when processing submission\n+  * @param keySerializationStrategy instance to use for serializing & namespacing state keys\n+  * @param validator validator instance to use\n+  * @param stateValueCache cache instance to be used when reading from or committing to the ledger"
  },
  {
    "id" : "5c7c8ec4-3e2e-4d01-a8b3-da2c73ed1ef7",
    "prId" : 6186,
    "comments" : [
      {
        "id" : "2be32864-552d-405f-b21e-ea25d44320bf",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n  * @param validator\r\n```",
        "createdAt" : "2020-06-02T10:59:24Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "833df587-56b4-4b38-af5d-a14ab1d1634a",
        "parentId" : "2be32864-552d-405f-b21e-ea25d44320bf",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "@fabiotudone-da I find a `@param` tag without a description pretty useless. If there's nothing to document, then I'd completely omit the line here.",
        "createdAt" : "2020-06-02T11:19:15Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a80b5e06-6bff-4401-a556-9baa100176e4",
        "parentId" : "2be32864-552d-405f-b21e-ea25d44320bf",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Agreed regarding not adding a tag without meaningful descriptions. However, as not all arguments are trivial I'm leaning towards enumerating all of them rather than selectively describing some.",
        "createdAt" : "2020-06-02T13:18:21Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54fa77cf2c950cdc36630aa964677462b028d52a",
    "line" : null,
    "diffHunk" : "@@ -18,6 +18,37 @@ import com.daml.ledger.validator.batch.{\n import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n \n+/**\n+  * Orchestrates committing to a ledger after validating submissions. Supports parallel validation.\n+  * Example usage, assuming a [[com.daml.ledger.participant.state.kvutils.api.BatchingLedgerWriter]] sends the\n+  * batched submissions over the wire:\n+  * {{{\n+  *   ...\n+  *   private val ledgerStateOperations = ...\n+  *   private val validator = BatchedSubmissionValidator.create(ledgerStateOperations)\n+  *   private val validatingCommitter = BatchedValidatingCommitter(\n+  *       () => Instant.now(),\n+  *       validator)\n+  *   ...\n+  *\n+  *   def commitRequestHandler(request: CommitRequest): Future[CommitResponse] =\n+  *     validatingCommitter.commit(\n+  *         request.correlationId,\n+  *         request.envelope,\n+  *         request.participantId,\n+  *         ledgerStateOperations)\n+  *       .map(...)\n+  * }}}\n+  *\n+  * In case caching is enabled (i.e., [[stateValueCache]] is not a [[Cache.none]]) then for each\n+  * request we cache the read state from the ledger and update the cache with the committed state.\n+  *\n+  * @param now function implementing resolution of current time when processing submission\n+  * @param keySerializationStrategy instance to use for serializing & namespacing state keys\n+  * @param validator validator instance to use"
  },
  {
    "id" : "cc0b2e3d-71a4-4606-80af-ead383419fe1",
    "prId" : 6186,
    "comments" : [
      {
        "id" : "4977314f-5a8c-4d55-be34-90edcdaaf9cb",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Minor comment: I generally try to avoid code blocks in scaladoc comments because they quickly tend to become outdated, as they are not tested in CI. I'm sure there's an example implementation somewhere, e.g., in `com.daml.ledger.on.memory`. Would it make sense to move this example there and just set a pointer here?",
        "createdAt" : "2020-06-02T11:16:44Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bc3cbab9-536f-43bd-a11e-00081362cff5",
        "parentId" : "4977314f-5a8c-4d55-be34-90edcdaaf9cb",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Unfortunately, there's no good example for the general use-case hence I added it here. Such examples going out of date is a good point -- I'll look into how these could be validated in an automated way.",
        "createdAt" : "2020-06-02T13:04:48Z",
        "updatedAt" : "2020-06-03T09:37:09Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "54fa77cf2c950cdc36630aa964677462b028d52a",
    "line" : 8,
    "diffHunk" : "@@ -18,6 +18,37 @@ import com.daml.ledger.validator.batch.{\n import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n \n+/**\n+  * Orchestrates committing to a ledger after validating submissions. Supports parallel validation.\n+  * Example usage, assuming a [[com.daml.ledger.participant.state.kvutils.api.BatchingLedgerWriter]] sends the\n+  * batched submissions over the wire:\n+  * {{{"
  },
  {
    "id" : "5f24e6d7-fb48-4f46-a77d-60c08253571c",
    "prId" : 6111,
    "comments" : [
      {
        "id" : "02676761-0040-40e7-99ec-b26815c22cfc",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "The curly braces should not be needed here",
        "createdAt" : "2020-05-27T10:27:44Z",
        "updatedAt" : "2020-05-28T08:28:21Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9c655e49-b585-4990-961c-fe7cfaa05c74",
        "parentId" : "02676761-0040-40e7-99ec-b26815c22cfc",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Good catch -- removed.",
        "createdAt" : "2020-05-27T14:24:14Z",
        "updatedAt" : "2020-05-28T08:28:21Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eaa7219a57e7cae32f14958b2c32423ade3c9d3",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,89 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator\n+\n+import java.time.Instant\n+\n+import akka.stream.Materializer\n+import com.daml.caching.Cache\n+import com.daml.ledger.participant.state.kvutils.Bytes\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{DamlStateKey, DamlStateValue}\n+import com.daml.ledger.participant.state.v1.{ParticipantId, SubmissionResult}\n+import com.daml.ledger.validator.batch.{\n+  BatchedSubmissionValidator,\n+  BatchedSubmissionValidatorFactory\n+}\n+import com.daml.logging.LoggingContext.newLoggingContext\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Success}\n+\n+class BatchedValidatingCommitter[LogResult](\n+    now: () => Instant,\n+    keySerializationStrategy: StateKeySerializationStrategy,\n+    validator: BatchedSubmissionValidator[LogResult],\n+    stateValueCache: Cache[DamlStateKey, DamlStateValue]\n+)(implicit materializer: Materializer) {\n+  def commit(\n+      correlationId: String,\n+      envelope: Bytes,\n+      submittingParticipantId: ParticipantId,\n+      ledgerStateOperations: LedgerStateOperations[LogResult]\n+  )(implicit executionContext: ExecutionContext): Future[SubmissionResult] =\n+    newLoggingContext(\"correlationId\" -> correlationId) { implicit logCtx =>\n+      val (ledgerStateReader, commitStrategy) = readerAndCommitStrategyFrom(ledgerStateOperations)\n+      validator\n+        .validateAndCommit(\n+          envelope,\n+          correlationId,\n+          now(),\n+          submittingParticipantId,\n+          ledgerStateReader,\n+          commitStrategy\n+        )\n+        .transformWith {\n+          case Success(_) =>\n+            Future.successful(SubmissionResult.Acknowledged)\n+          case Failure(exception) =>\n+            Future.successful(SubmissionResult.InternalError(exception.getLocalizedMessage))\n+        }\n+    }\n+\n+  private def readerAndCommitStrategyFrom(ledgerStateOperations: LedgerStateOperations[LogResult])(\n+      implicit executionContext: ExecutionContext)\n+    : (DamlLedgerStateReader, CommitStrategy[LogResult]) =\n+    if (stateValueCache == Cache.none) {\n+      BatchedSubmissionValidatorFactory\n+        .readerAndCommitStrategyFrom(ledgerStateOperations, keySerializationStrategy)\n+    } else {\n+      BatchedSubmissionValidatorFactory\n+        .cachingReaderAndCommitStrategyFrom(\n+          ledgerStateOperations,\n+          stateValueCache,\n+          keySerializationStrategy)\n+    }\n+}\n+\n+object BatchedValidatingCommitter {\n+  def apply[LogResult](now: () => Instant, validator: BatchedSubmissionValidator[LogResult])(\n+      implicit materializer: Materializer): BatchedValidatingCommitter[LogResult] = {"
  },
  {
    "id" : "61308d6a-b52e-4403-97af-0084f312716a",
    "prId" : 6111,
    "comments" : [
      {
        "id" : "33abb1db-a15e-40ce-aa1e-1ec6e4493f75",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "The curly braces should not be needed here",
        "createdAt" : "2020-05-27T10:27:58Z",
        "updatedAt" : "2020-05-28T08:28:21Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bee2aa35-24e5-46cf-8887-3c7298aedc00",
        "parentId" : "33abb1db-a15e-40ce-aa1e-1ec6e4493f75",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Good catch -- removed.",
        "createdAt" : "2020-05-27T14:24:19Z",
        "updatedAt" : "2020-05-28T08:28:21Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eaa7219a57e7cae32f14958b2c32423ade3c9d3",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,89 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator\n+\n+import java.time.Instant\n+\n+import akka.stream.Materializer\n+import com.daml.caching.Cache\n+import com.daml.ledger.participant.state.kvutils.Bytes\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{DamlStateKey, DamlStateValue}\n+import com.daml.ledger.participant.state.v1.{ParticipantId, SubmissionResult}\n+import com.daml.ledger.validator.batch.{\n+  BatchedSubmissionValidator,\n+  BatchedSubmissionValidatorFactory\n+}\n+import com.daml.logging.LoggingContext.newLoggingContext\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.{Failure, Success}\n+\n+class BatchedValidatingCommitter[LogResult](\n+    now: () => Instant,\n+    keySerializationStrategy: StateKeySerializationStrategy,\n+    validator: BatchedSubmissionValidator[LogResult],\n+    stateValueCache: Cache[DamlStateKey, DamlStateValue]\n+)(implicit materializer: Materializer) {\n+  def commit(\n+      correlationId: String,\n+      envelope: Bytes,\n+      submittingParticipantId: ParticipantId,\n+      ledgerStateOperations: LedgerStateOperations[LogResult]\n+  )(implicit executionContext: ExecutionContext): Future[SubmissionResult] =\n+    newLoggingContext(\"correlationId\" -> correlationId) { implicit logCtx =>\n+      val (ledgerStateReader, commitStrategy) = readerAndCommitStrategyFrom(ledgerStateOperations)\n+      validator\n+        .validateAndCommit(\n+          envelope,\n+          correlationId,\n+          now(),\n+          submittingParticipantId,\n+          ledgerStateReader,\n+          commitStrategy\n+        )\n+        .transformWith {\n+          case Success(_) =>\n+            Future.successful(SubmissionResult.Acknowledged)\n+          case Failure(exception) =>\n+            Future.successful(SubmissionResult.InternalError(exception.getLocalizedMessage))\n+        }\n+    }\n+\n+  private def readerAndCommitStrategyFrom(ledgerStateOperations: LedgerStateOperations[LogResult])(\n+      implicit executionContext: ExecutionContext)\n+    : (DamlLedgerStateReader, CommitStrategy[LogResult]) =\n+    if (stateValueCache == Cache.none) {\n+      BatchedSubmissionValidatorFactory\n+        .readerAndCommitStrategyFrom(ledgerStateOperations, keySerializationStrategy)\n+    } else {\n+      BatchedSubmissionValidatorFactory\n+        .cachingReaderAndCommitStrategyFrom(\n+          ledgerStateOperations,\n+          stateValueCache,\n+          keySerializationStrategy)\n+    }\n+}\n+\n+object BatchedValidatingCommitter {\n+  def apply[LogResult](now: () => Instant, validator: BatchedSubmissionValidator[LogResult])(\n+      implicit materializer: Materializer): BatchedValidatingCommitter[LogResult] = {\n+    new BatchedValidatingCommitter[LogResult](\n+      now,\n+      DefaultStateKeySerializationStrategy,\n+      validator,\n+      Cache.none)\n+  }\n+\n+  def apply[LogResult](\n+      now: () => Instant,\n+      validator: BatchedSubmissionValidator[LogResult],\n+      stateValueCache: Cache[DamlStateKey, DamlStateValue])(\n+      implicit materializer: Materializer): BatchedValidatingCommitter[LogResult] = {"
  }
]