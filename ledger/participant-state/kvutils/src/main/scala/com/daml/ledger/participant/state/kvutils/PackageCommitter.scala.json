[
  {
    "id" : "1b81533d-cc7b-493b-89be-33672c58f395",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "8eb3ead3-ad21-48f9-a94d-11054f431537",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "No need to wrap the `ExecutorServer` into an `ExecutionContext`. The `execute` method from `ExecutorService` (really `Executor`) works the same way.",
        "createdAt" : "2019-10-08T08:28:14Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4d82fbb1-c1c3-4499-b3d8-903f75dd1758",
        "parentId" : "8eb3ead3-ad21-48f9-a94d-11054f431537",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : ":+1: ",
        "createdAt" : "2019-10-10T08:51:28Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.concurrent.Executors\n+import com.codahale.metrics.{Counter, Timer}\n+import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.committer.{Committer, Context}\n+import com.digitalasset.daml.lf.archive.Decode\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.language.Ast\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import scala.collection.JavaConverters._\n+import scala.concurrent.ExecutionContext\n+\n+private[kvutils] case class PackageCommitter(engine: Engine)\n+    extends Committer[DamlPackageUploadEntry, DamlPackageUploadEntry.Builder] {\n+\n+  private val serialContext =\n+    ExecutionContext.fromExecutor(Executors.newSingleThreadExecutor())"
  },
  {
    "id" : "9f67500c-188f-48e6-8f3a-a1c43c2536b2",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "4e16213c-a49e-4ee8-a23f-b453760be32e",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I kind of like having the metrics bundled together in a dedicated object ðŸ‘ ",
        "createdAt" : "2019-10-08T08:28:46Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.concurrent.Executors\n+import com.codahale.metrics.{Counter, Timer}\n+import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.committer.{Committer, Context}\n+import com.digitalasset.daml.lf.archive.Decode\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.language.Ast\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import scala.collection.JavaConverters._\n+import scala.concurrent.ExecutionContext\n+\n+private[kvutils] case class PackageCommitter(engine: Engine)\n+    extends Committer[DamlPackageUploadEntry, DamlPackageUploadEntry.Builder] {\n+\n+  private val serialContext =\n+    ExecutionContext.fromExecutor(Executors.newSingleThreadExecutor())\n+\n+  private object Metrics {"
  },
  {
    "id" : "2a8ee622-6316-4eaa-857a-9b1d5bf8c797",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "488ef0a4-2ff1-40b4-8413-fb04bdb8e248",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Why do we preload only the first element of the packages map?",
        "createdAt" : "2019-10-08T08:43:54Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aa93ab26-0ca2-4883-94d6-7a860daedfb6",
        "parentId" : "488ef0a4-2ff1-40b4-8413-fb04bdb8e248",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "uh oh, good catch. blindly copy-pasted this from original implementation and never noticed this. will fix it here, and do another PR to fix it in the original code (planning on keeping this proposal around until Marcin has reviewed).",
        "createdAt" : "2019-10-08T09:38:18Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.concurrent.Executors\n+import com.codahale.metrics.{Counter, Timer}\n+import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.committer.{Committer, Context}\n+import com.digitalasset.daml.lf.archive.Decode\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.language.Ast\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import scala.collection.JavaConverters._\n+import scala.concurrent.ExecutionContext\n+\n+private[kvutils] case class PackageCommitter(engine: Engine)\n+    extends Committer[DamlPackageUploadEntry, DamlPackageUploadEntry.Builder] {\n+\n+  private val serialContext =\n+    ExecutionContext.fromExecutor(Executors.newSingleThreadExecutor())\n+\n+  private object Metrics {\n+    val preloadTimer: Timer = metricsRegistry.timer(metricsName(\"preload-timer\"))\n+    val decodeTimer: Timer = metricsRegistry.timer(metricsName(\"decode-timer\"))\n+    val accepts: Counter = metricsRegistry.counter(metricsName(\"accepts\"))\n+  }\n+\n+  override def init(subm: DamlPackageUploadEntry): DamlPackageUploadEntry.Builder =\n+    subm.toBuilder\n+\n+  override val steps: Iterable[Step] = Iterable(\n+    filterDuplicates,\n+    (_, subm) => {\n+      serialContext.execute(preload(subm.getArchivesList.asScala))\n+      subm\n+    },\n+    finish\n+  )\n+\n+  private def filterDuplicates(ctx: Context, subm: DamlPackageUploadEntry.Builder) = {\n+    val archives = subm.getArchivesList.asScala.filter { archive =>\n+      val stateKey = DamlStateKey.newBuilder\n+        .setPackageId(archive.getHash)\n+        .build\n+      ctx.get(stateKey).isEmpty\n+    }\n+    subm.clearArchives().addAllArchives(archives.asJava)\n+  }\n+\n+  private def finish(ctx: Context, subm: DamlPackageUploadEntry.Builder) = {\n+    logger.trace(\n+      s\"Packages committed: ${subm.getArchivesList.asScala.map(_.getHash).mkString(\", \")}\")\n+\n+    subm.getArchivesList.forEach { archive =>\n+      ctx.set(\n+        DamlStateKey.newBuilder.setPackageId(archive.getHash).build,\n+        DamlStateValue.newBuilder.setArchive(archive).build\n+      )\n+    }\n+\n+    ctx.done(\n+      DamlLogEntry.newBuilder\n+        .setRecordTime(buildTimestamp(ctx.getRecordTime))\n+        .setPackageUploadEntry(subm)\n+        .build,\n+    )\n+  }\n+\n+  private def preload(archives: Iterable[Archive]): Runnable = { () =>\n+    val ctx = Metrics.preloadTimer.time()\n+    try {\n+      logger.trace(\"Preloading engine...\")\n+      val loadedPackages = engine.compiledPackages().packageIds\n+      val packages: Map[Ref.PackageId, Ast.Package] = Metrics.decodeTimer.time { () =>\n+        archives\n+          .filterNot(\n+            a =>\n+              Ref.PackageId\n+                .fromString(a.getHash)\n+                .fold(_ => false, loadedPackages.contains))\n+          .map { archive =>\n+            Decode.readArchiveAndVersion(archive)._1\n+          }\n+          .toMap\n+      }\n+      packages.headOption.foreach {"
  },
  {
    "id" : "dab9d947-e425-4609-ad08-439f36b9f2b2",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "5efaf931-5819-4ed1-a225-ce515ff1611f",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Might help debugging to include something like submission id and/or preloaded package ids in the trace message.",
        "createdAt" : "2019-10-08T08:44:46Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d7ff469d-3721-4245-990e-6520a47e590a",
        "parentId" : "5efaf931-5819-4ed1-a225-ce515ff1611f",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Ah yes. The original logger carried this context, but now it no longer does. I'll do a pass over the tracing to add relevant context.",
        "createdAt" : "2019-10-08T09:40:09Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.concurrent.Executors\n+import com.codahale.metrics.{Counter, Timer}\n+import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.committer.{Committer, Context}\n+import com.digitalasset.daml.lf.archive.Decode\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.language.Ast\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import scala.collection.JavaConverters._\n+import scala.concurrent.ExecutionContext\n+\n+private[kvutils] case class PackageCommitter(engine: Engine)\n+    extends Committer[DamlPackageUploadEntry, DamlPackageUploadEntry.Builder] {\n+\n+  private val serialContext =\n+    ExecutionContext.fromExecutor(Executors.newSingleThreadExecutor())\n+\n+  private object Metrics {\n+    val preloadTimer: Timer = metricsRegistry.timer(metricsName(\"preload-timer\"))\n+    val decodeTimer: Timer = metricsRegistry.timer(metricsName(\"decode-timer\"))\n+    val accepts: Counter = metricsRegistry.counter(metricsName(\"accepts\"))\n+  }\n+\n+  override def init(subm: DamlPackageUploadEntry): DamlPackageUploadEntry.Builder =\n+    subm.toBuilder\n+\n+  override val steps: Iterable[Step] = Iterable(\n+    filterDuplicates,\n+    (_, subm) => {\n+      serialContext.execute(preload(subm.getArchivesList.asScala))\n+      subm\n+    },\n+    finish\n+  )\n+\n+  private def filterDuplicates(ctx: Context, subm: DamlPackageUploadEntry.Builder) = {\n+    val archives = subm.getArchivesList.asScala.filter { archive =>\n+      val stateKey = DamlStateKey.newBuilder\n+        .setPackageId(archive.getHash)\n+        .build\n+      ctx.get(stateKey).isEmpty\n+    }\n+    subm.clearArchives().addAllArchives(archives.asJava)\n+  }\n+\n+  private def finish(ctx: Context, subm: DamlPackageUploadEntry.Builder) = {\n+    logger.trace(\n+      s\"Packages committed: ${subm.getArchivesList.asScala.map(_.getHash).mkString(\", \")}\")\n+\n+    subm.getArchivesList.forEach { archive =>\n+      ctx.set(\n+        DamlStateKey.newBuilder.setPackageId(archive.getHash).build,\n+        DamlStateValue.newBuilder.setArchive(archive).build\n+      )\n+    }\n+\n+    ctx.done(\n+      DamlLogEntry.newBuilder\n+        .setRecordTime(buildTimestamp(ctx.getRecordTime))\n+        .setPackageUploadEntry(subm)\n+        .build,\n+    )\n+  }\n+\n+  private def preload(archives: Iterable[Archive]): Runnable = { () =>\n+    val ctx = Metrics.preloadTimer.time()\n+    try {\n+      logger.trace(\"Preloading engine...\")\n+      val loadedPackages = engine.compiledPackages().packageIds\n+      val packages: Map[Ref.PackageId, Ast.Package] = Metrics.decodeTimer.time { () =>\n+        archives\n+          .filterNot(\n+            a =>\n+              Ref.PackageId\n+                .fromString(a.getHash)\n+                .fold(_ => false, loadedPackages.contains))\n+          .map { archive =>\n+            Decode.readArchiveAndVersion(archive)._1\n+          }\n+          .toMap\n+      }\n+      packages.headOption.foreach {\n+        case (pkgId, pkg) =>\n+          engine\n+            .preloadPackage(pkgId, pkg)\n+            .consume(\n+              _ => sys.error(\"Unexpected request to PCS in preloadPackage\"),\n+              pkgId => packages.get(pkgId),\n+              _ => sys.error(\"Unexpected request to keys in preloadPackage\")\n+            )\n+      }\n+      logger.trace(s\"Preload complete.\")"
  },
  {
    "id" : "6995f603-4c27-451e-9f9a-31781eba2463",
    "prId" : 3116,
    "comments" : [
      {
        "id" : "4ce78894-fd17-4055-98d4-3c2be9748e0a",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'm guessing we are okay with launching the preloading as a \"hidden\" side-effect. Maybe make this conscious decision explicit with a comment.",
        "createdAt" : "2019-10-08T08:45:49Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e311dfe5-45c0-432d-b9e9-1374ea667467",
        "parentId" : "4ce78894-fd17-4055-98d4-3c2be9748e0a",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "We're not that ok with this approach as we'd much rather want to fully validate the packages before accepting them. This however is currently rather problematic with couple integrations as it's very slow. I'll add comments on this.",
        "createdAt" : "2019-10-08T09:36:51Z",
        "updatedAt" : "2019-11-07T09:35:41Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "277edd527507019f9b414b28441de58c582a1c49",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils\n+\n+import java.util.concurrent.Executors\n+import com.codahale.metrics.{Counter, Timer}\n+import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.committer.{Committer, Context}\n+import com.digitalasset.daml.lf.archive.Decode\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.daml.lf.language.Ast\n+import com.digitalasset.daml_lf.DamlLf.Archive\n+import scala.collection.JavaConverters._\n+import scala.concurrent.ExecutionContext\n+\n+private[kvutils] case class PackageCommitter(engine: Engine)\n+    extends Committer[DamlPackageUploadEntry, DamlPackageUploadEntry.Builder] {\n+\n+  private val serialContext =\n+    ExecutionContext.fromExecutor(Executors.newSingleThreadExecutor())\n+\n+  private object Metrics {\n+    val preloadTimer: Timer = metricsRegistry.timer(metricsName(\"preload-timer\"))\n+    val decodeTimer: Timer = metricsRegistry.timer(metricsName(\"decode-timer\"))\n+    val accepts: Counter = metricsRegistry.counter(metricsName(\"accepts\"))\n+  }\n+\n+  override def init(subm: DamlPackageUploadEntry): DamlPackageUploadEntry.Builder =\n+    subm.toBuilder\n+\n+  override val steps: Iterable[Step] = Iterable(\n+    filterDuplicates,\n+    (_, subm) => {\n+      serialContext.execute(preload(subm.getArchivesList.asScala))"
  }
]