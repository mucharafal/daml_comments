[
  {
    "id" : "3ea8df45-7d71-4c87-a6ff-8e2e5e013486",
    "prId" : 7215,
    "comments" : [
      {
        "id" : "195a66d7-e2a1-4757-a20a-3729d9320033",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Can you refactor this into a utility method? It made sense even earlier but now with a default less (and a further parameter) it's a good moment to do so.",
        "createdAt" : "2020-08-25T11:03:35Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "34b62556-d538-4b66-956e-b5928243b644",
        "parentId" : "195a66d7-e2a1-4757-a20a-3729d9320033",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Well, given this is only used for tests, I'll push it into the `apply` method and make it package-private.",
        "createdAt" : "2020-08-25T11:16:22Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fe6ccf16-3edd-4c8c-accd-e9df771fe5f0",
        "parentId" : "195a66d7-e2a1-4757-a20a-3729d9320033",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Ended up moving this method into the test class itself and making it more useful there.",
        "createdAt" : "2020-08-25T14:28:26Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0020dd8e089d897ae22c94ce2643c7d7f6073b04",
    "line" : 47,
    "diffHunk" : "@@ -42,7 +44,9 @@ class BatchedSubmissionValidatorSpec\n       val validator = BatchedSubmissionValidator[Unit](\n         BatchedSubmissionValidatorParameters.reasonableDefault,\n         engine,\n-        metrics)\n+        metrics,\n+        NoOpLedgerDataExporter,\n+      )"
  },
  {
    "id" : "1f7fe44d-85da-48bc-a625-75325e469052",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "42c218ff-a61e-4a72-a5c6-97b5afd2ec1d",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Can it be made more precise?",
        "createdAt" : "2020-05-22T16:37:04Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a2ebf30f-52de-4edf-8b03-e181c90c6c06",
        "parentId" : "42c218ff-a61e-4a72-a5c6-97b5afd2ec1d",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We don't really care about the exact failure message here.",
        "createdAt" : "2020-05-25T10:15:38Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 58,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]"
  },
  {
    "id" : "b644a645-ef5f-46db-8254-0c0003fd41a2",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "694d2f8d-ae60-42e7-b4ea-8860e42e61b1",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Can it be made more precise?",
        "createdAt" : "2020-05-22T16:37:17Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cad74ebc-5634-4fbf-9281-5b2501ee97b0",
        "parentId" : "694d2f8d-ae60-42e7-b4ea-8860e42e61b1",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We don't really care about the exact failure message here.",
        "createdAt" : "2020-05-25T10:16:02Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 80,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid message type in envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val notASubmission = Envelope.enclose(DamlStateValue.getDefaultInstance)\n+\n+      validator\n+        .validateAndCommit(\n+          notASubmission,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]"
  },
  {
    "id" : "1a32b20d-ebb9-45c6-be76-906602674331",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "e96ed743-7b6e-4482-bb8e-aec7643bc062",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Can it be made more precise?",
        "createdAt" : "2020-05-22T16:37:33Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6765716e-de6b-40fb-986d-473ab9a2709e",
        "parentId" : "e96ed743-7b6e-4482-bb8e-aec7643bc062",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We don't really care about the exact failure message here.",
        "createdAt" : "2020-05-25T10:16:50Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 107,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid message type in envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val notASubmission = Envelope.enclose(DamlStateValue.getDefaultInstance)\n+\n+      validator\n+        .validateAndCommit(\n+          notASubmission,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid envelope in batch\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(anInvalidEnvelope))\n+        .build\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]"
  },
  {
    "id" : "56f6c98e-19d2-4bfa-affa-8bfe180de2d5",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "6085330f-6624-4040-979f-02304048a552",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "How about the value set?",
        "createdAt" : "2020-05-22T16:38:48Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5cc8447e-62e8-4a48-b781-cfaec35dec20",
        "parentId" : "6085330f-6624-4040-979f-02304048a552",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "That's an implementation detail of `KeyValueCommitting` that shouldn't be tested here.",
        "createdAt" : "2020-05-25T10:18:43Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 154,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid message type in envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val notASubmission = Envelope.enclose(DamlStateValue.getDefaultInstance)\n+\n+      validator\n+        .validateAndCommit(\n+          notASubmission,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid envelope in batch\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(anInvalidEnvelope))\n+        .build\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"validate a non-batched submission\" in {\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      val partySubmission = makePartySubmission(\"foo\")\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+      val outputStateCaptor = ArgumentCaptor.forClass(classOf[Map[DamlStateKey, DamlStateValue]])\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          logEntryCaptor.capture(),\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          outputStateCaptor.capture()))\n+        .thenReturn(Future.unit)\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(partySubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          // Verify that the log entry is committed.\n+          logEntryCaptor.getAllValues should have size 1\n+          val logEntry = logEntryCaptor.getValue.asInstanceOf[DamlLogEntry]\n+          logEntry.getPartyAllocationEntry should be(partySubmission.getPartyAllocationEntry)\n+\n+          // Verify that output state contains the expected values.\n+          outputStateCaptor.getAllValues should have size 1\n+          val outputState =\n+            outputStateCaptor.getValue.asInstanceOf[Map[DamlStateKey, DamlStateValue]]\n+          outputState should have size 2\n+          outputState.keySet should be(partySubmission.getInputDamlStateList.asScala.toSet)"
  },
  {
    "id" : "eb11de8b-df2c-4d48-9977-34eca3726c9e",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "4529bbab-1d9a-45d8-97a8-1a0af03b9f2b",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Aren't there more cases to be tested?",
        "createdAt" : "2020-05-22T16:39:47Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4a315b6e-b943-4c68-8c1e-d4de8e2b08bf",
        "parentId" : "4529bbab-1d9a-45d8-97a8-1a0af03b9f2b",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "I see diminishing returns with more tests here but let me know if you have specific suggestions.",
        "createdAt" : "2020-05-25T10:20:15Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c0c0d75a-c02a-4417-98c0-f8e6d4a9bf57",
        "parentId" : "4529bbab-1d9a-45d8-97a8-1a0af03b9f2b",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "I was mostly thinking about less submissions than committers.",
        "createdAt" : "2020-05-25T12:14:57Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8a745a7f-d8eb-4fcd-acd4-d545f7f2caf9",
        "parentId" : "4529bbab-1d9a-45d8-97a8-1a0af03b9f2b",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "In that case we won't be using some of the committer threads. We would be testing akka instead of our logic. The other test cases make sure certain edge cases work that we need to rely on.",
        "createdAt" : "2020-05-25T13:43:44Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 162,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid message type in envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val notASubmission = Envelope.enclose(DamlStateValue.getDefaultInstance)\n+\n+      validator\n+        .validateAndCommit(\n+          notASubmission,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid envelope in batch\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(anInvalidEnvelope))\n+        .build\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"validate a non-batched submission\" in {\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      val partySubmission = makePartySubmission(\"foo\")\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+      val outputStateCaptor = ArgumentCaptor.forClass(classOf[Map[DamlStateKey, DamlStateValue]])\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          logEntryCaptor.capture(),\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          outputStateCaptor.capture()))\n+        .thenReturn(Future.unit)\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(partySubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          // Verify that the log entry is committed.\n+          logEntryCaptor.getAllValues should have size 1\n+          val logEntry = logEntryCaptor.getValue.asInstanceOf[DamlLogEntry]\n+          logEntry.getPartyAllocationEntry should be(partySubmission.getPartyAllocationEntry)\n+\n+          // Verify that output state contains the expected values.\n+          outputStateCaptor.getAllValues should have size 1\n+          val outputState =\n+            outputStateCaptor.getValue.asInstanceOf[Map[DamlStateKey, DamlStateValue]]\n+          outputState should have size 2\n+          outputState.keySet should be(partySubmission.getInputDamlStateList.asScala.toSet)\n+        }\n+    }\n+\n+    \"validate a batch\" in {\n+      validateBatchSubmission(nSubmissions = 1000, commitParallelism = 2)\n+    }\n+\n+    \"validate a batch with 1 committer for each submission\" in {"
  },
  {
    "id" : "c0e97239-86c7-46dd-9635-9b15983af2d1",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "0b6dd324-cd2b-43d4-98d7-4ea1f5e17fba",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Wouldn't 2 be enough?",
        "createdAt" : "2020-05-22T16:40:25Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a2372027-9a61-4d47-bc02-9ba34f8be1d1",
        "parentId" : "0b6dd324-cd2b-43d4-98d7-4ea1f5e17fba",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You have a very small chance of getting 100 submissions committed in the right order unless you actually follow the contract (i.e., commit them explicitly in the order you received them). With 2 submissions a randomized order may end up to be right half the time.",
        "createdAt" : "2020-05-25T10:23:53Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6c34061a-9bca-4c68-b1b3-5914d7929edb",
        "parentId" : "0b6dd324-cd2b-43d4-98d7-4ea1f5e17fba",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Unless you produce them in the wrong order.",
        "createdAt" : "2020-05-25T12:16:30Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 167,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid message type in envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val notASubmission = Envelope.enclose(DamlStateValue.getDefaultInstance)\n+\n+      validator\n+        .validateAndCommit(\n+          notASubmission,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid envelope in batch\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(anInvalidEnvelope))\n+        .build\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"validate a non-batched submission\" in {\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      val partySubmission = makePartySubmission(\"foo\")\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+      val outputStateCaptor = ArgumentCaptor.forClass(classOf[Map[DamlStateKey, DamlStateValue]])\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          logEntryCaptor.capture(),\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          outputStateCaptor.capture()))\n+        .thenReturn(Future.unit)\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(partySubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          // Verify that the log entry is committed.\n+          logEntryCaptor.getAllValues should have size 1\n+          val logEntry = logEntryCaptor.getValue.asInstanceOf[DamlLogEntry]\n+          logEntry.getPartyAllocationEntry should be(partySubmission.getPartyAllocationEntry)\n+\n+          // Verify that output state contains the expected values.\n+          outputStateCaptor.getAllValues should have size 1\n+          val outputState =\n+            outputStateCaptor.getValue.asInstanceOf[Map[DamlStateKey, DamlStateValue]]\n+          outputState should have size 2\n+          outputState.keySet should be(partySubmission.getInputDamlStateList.asScala.toSet)\n+        }\n+    }\n+\n+    \"validate a batch\" in {\n+      validateBatchSubmission(nSubmissions = 1000, commitParallelism = 2)\n+    }\n+\n+    \"validate a batch with 1 committer for each submission\" in {\n+      validateBatchSubmission(nSubmissions = 4, commitParallelism = 4)\n+    }\n+\n+    \"serially commit a batch in case commitParallelism is set to 1\" in {\n+      val nSubmissions = 100"
  },
  {
    "id" : "2aa33376-dd7f-4483-91bd-9ff52d2fea80",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "afcb8aca-783f-4002-965a-dc34331d0937",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Is that needed?",
        "createdAt" : "2020-05-22T16:46:36Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2646a4ab-474c-4108-9726-41295b3e9425",
        "parentId" : "afcb8aca-783f-4002-965a-dc34331d0937",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Good catch -- removed.",
        "createdAt" : "2020-05-25T10:28:21Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid message type in envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val notASubmission = Envelope.enclose(DamlStateValue.getDefaultInstance)\n+\n+      validator\n+        .validateAndCommit(\n+          notASubmission,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid envelope in batch\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(anInvalidEnvelope))\n+        .build\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"validate a non-batched submission\" in {\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      val partySubmission = makePartySubmission(\"foo\")\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+      val outputStateCaptor = ArgumentCaptor.forClass(classOf[Map[DamlStateKey, DamlStateValue]])\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          logEntryCaptor.capture(),\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          outputStateCaptor.capture()))\n+        .thenReturn(Future.unit)\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(partySubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          // Verify that the log entry is committed.\n+          logEntryCaptor.getAllValues should have size 1\n+          val logEntry = logEntryCaptor.getValue.asInstanceOf[DamlLogEntry]\n+          logEntry.getPartyAllocationEntry should be(partySubmission.getPartyAllocationEntry)\n+\n+          // Verify that output state contains the expected values.\n+          outputStateCaptor.getAllValues should have size 1\n+          val outputState =\n+            outputStateCaptor.getValue.asInstanceOf[Map[DamlStateKey, DamlStateValue]]\n+          outputState should have size 2\n+          outputState.keySet should be(partySubmission.getInputDamlStateList.asScala.toSet)\n+        }\n+    }\n+\n+    \"validate a batch\" in {\n+      validateBatchSubmission(nSubmissions = 1000, commitParallelism = 2)\n+    }\n+\n+    \"validate a batch with 1 committer for each submission\" in {\n+      validateBatchSubmission(nSubmissions = 4, commitParallelism = 4)\n+    }\n+\n+    \"serially commit a batch in case commitParallelism is set to 1\" in {\n+      val nSubmissions = 100\n+      val (submissions, _, batchSubmissionBytes) = createBatchSubmissionOf(nSubmissions)\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          logEntryCaptor.capture(),\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          any[Map[DamlStateKey, DamlStateValue]]\n+        ))\n+        .thenReturn(Future.unit)\n+      val validatorConfig = BatchedSubmissionValidatorParameters.default.copy(commitParallelism = 1)\n+      val validator = BatchedSubmissionValidator[Unit](validatorConfig, engine, metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          batchSubmissionBytes,\n+          \"batch-correlationId\",\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          verify(mockCommit, times(nSubmissions)).commit(\n+            any[ParticipantId](),\n+            any[String](),\n+            any[DamlLogEntryId](),\n+            any[DamlLogEntry](),\n+            any[DamlInputState](),\n+            any[DamlOutputState]())\n+          // Verify that the log entries have been committed in the right order.\n+          val logEntries = logEntryCaptor.getAllValues.asScala.map(_.asInstanceOf[DamlLogEntry])\n+          logEntries.map(_.getPartyAllocationEntry) should be(\n+            submissions.map(_.getPartyAllocationEntry))\n+        }\n+    }\n+\n+    \"not commit the duplicate submission\" in {\n+      val submission = makePartySubmission(\"duplicate-test\")\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(Envelope.enclose(submission)))\n+        .addSubmissions(CorrelatedSubmission.newBuilder\n+          .setCorrelationId(\"anotherCorrelationId\")\n+          .setSubmission(Envelope.enclose(submission)))\n+        .build()\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          any[DamlLogEntry],\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          any[Map[DamlStateKey, DamlStateValue]]\n+        ))\n+        .thenReturn(Future.unit)\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          \"batch-correlationId\",\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          // We must have 1 commit only (for the first submission).\n+          verify(mockCommit, times(1)).commit(\n+            any[ParticipantId](),\n+            any[String](),\n+            any[DamlLogEntryId](),\n+            any[DamlLogEntry](),\n+            any[DamlInputState](),\n+            any[DamlOutputState]())\n+          succeed\n+        }\n+    }\n+\n+    \"collect size/count metrics for a batch\" in {\n+      val metrics = new Metrics(new MetricRegistry)\n+      val (submissions, batchSubmission, batchSubmissionBytes) = createBatchSubmissionOf(2)\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          any[DamlLogEntry],\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          any[Map[DamlStateKey, DamlStateValue]]\n+        ))\n+        .thenReturn(Future.unit)\n+      val validator =\n+        BatchedSubmissionValidator[Unit](\n+          BatchedSubmissionValidatorParameters.default,\n+          engine,\n+          metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          batchSubmissionBytes,\n+          \"batch-correlationId\",\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          validator.Metrics.batchSizes.getSnapshot.getValues should equal(Array(2))\n+          val Array(actualBatchSubmissionSize) =\n+            validator.Metrics.receivedBatchSubmissionBytes.getSnapshot.getValues\n+          actualBatchSubmissionSize should equal(batchSubmission.getSerializedSize)\n+          val expectedSubmissionSizes = submissions.map(_.getSerializedSize)\n+          validator.Metrics.receivedSubmissionBytes.getSnapshot.getValues.toSet should contain allElementsOf\n+            expectedSubmissionSizes\n+          succeed"
  },
  {
    "id" : "249ae0e5-6937-43ce-ad6a-6775c3443df9",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "355e6ce7-f8fa-45c6-88a5-dcd10b143a36",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "How about the values?",
        "createdAt" : "2020-05-22T16:47:11Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "32106db1-773a-472b-8aab-776771ff59a0",
        "parentId" : "355e6ce7-f8fa-45c6-88a5-dcd10b143a36",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "See https://github.com/digital-asset/daml/pull/6004#discussion_r429857249",
        "createdAt" : "2020-05-25T10:24:59Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 370,
    "diffHunk" : "@@ -0,0 +1,393 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator.batch\n+\n+import java.time.Clock\n+\n+import com.codahale.metrics.MetricRegistry\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlSubmissionBatch.CorrelatedSubmission\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.ParticipantId\n+import com.daml.ledger.validator.TestHelper.{aParticipantId, anInvalidEnvelope, makePartySubmission}\n+import com.daml.ledger.validator.{CommitStrategy, DamlLedgerStateReader, ValidationFailed}\n+import com.daml.lf.data.Time.Timestamp\n+import com.daml.lf.engine.Engine\n+import com.daml.metrics.Metrics\n+import com.google.protobuf.ByteString\n+import org.mockito.ArgumentCaptor\n+import org.mockito.ArgumentMatchers.{any, argThat}\n+import org.mockito.Mockito._\n+import org.scalatest.{Assertion, AsyncWordSpec, Inside, Matchers}\n+import org.scalatest.mockito.MockitoSugar\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.Future\n+\n+class BatchedSubmissionValidatorSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with AkkaBeforeAndAfterAll\n+    with MockitoSugar {\n+\n+  val engine = new Engine\n+  val metrics = new Metrics(new MetricRegistry)\n+\n+  \"validateAndCommit\" should {\n+\n+    \"return validation failure for invalid envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          anInvalidEnvelope,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid message type in envelope\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val notASubmission = Envelope.enclose(DamlStateValue.getDefaultInstance)\n+\n+      validator\n+        .validateAndCommit(\n+          notASubmission,\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"return validation failure for invalid envelope in batch\" in {\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(anInvalidEnvelope))\n+        .build\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mock[DamlLedgerStateReader],\n+          mock[CommitStrategy[Unit]]\n+        )\n+        .failed\n+        .map { result =>\n+          result shouldBe a[ValidationFailed]\n+        }\n+    }\n+\n+    \"validate a non-batched submission\" in {\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      val partySubmission = makePartySubmission(\"foo\")\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+      val outputStateCaptor = ArgumentCaptor.forClass(classOf[Map[DamlStateKey, DamlStateValue]])\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          logEntryCaptor.capture(),\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          outputStateCaptor.capture()))\n+        .thenReturn(Future.unit)\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(partySubmission),\n+          aCorrelationId,\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          // Verify that the log entry is committed.\n+          logEntryCaptor.getAllValues should have size 1\n+          val logEntry = logEntryCaptor.getValue.asInstanceOf[DamlLogEntry]\n+          logEntry.getPartyAllocationEntry should be(partySubmission.getPartyAllocationEntry)\n+\n+          // Verify that output state contains the expected values.\n+          outputStateCaptor.getAllValues should have size 1\n+          val outputState =\n+            outputStateCaptor.getValue.asInstanceOf[Map[DamlStateKey, DamlStateValue]]\n+          outputState should have size 2\n+          outputState.keySet should be(partySubmission.getInputDamlStateList.asScala.toSet)\n+        }\n+    }\n+\n+    \"validate a batch\" in {\n+      validateBatchSubmission(nSubmissions = 1000, commitParallelism = 2)\n+    }\n+\n+    \"validate a batch with 1 committer for each submission\" in {\n+      validateBatchSubmission(nSubmissions = 4, commitParallelism = 4)\n+    }\n+\n+    \"serially commit a batch in case commitParallelism is set to 1\" in {\n+      val nSubmissions = 100\n+      val (submissions, _, batchSubmissionBytes) = createBatchSubmissionOf(nSubmissions)\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          logEntryCaptor.capture(),\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          any[Map[DamlStateKey, DamlStateValue]]\n+        ))\n+        .thenReturn(Future.unit)\n+      val validatorConfig = BatchedSubmissionValidatorParameters.default.copy(commitParallelism = 1)\n+      val validator = BatchedSubmissionValidator[Unit](validatorConfig, engine, metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          batchSubmissionBytes,\n+          \"batch-correlationId\",\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          verify(mockCommit, times(nSubmissions)).commit(\n+            any[ParticipantId](),\n+            any[String](),\n+            any[DamlLogEntryId](),\n+            any[DamlLogEntry](),\n+            any[DamlInputState](),\n+            any[DamlOutputState]())\n+          // Verify that the log entries have been committed in the right order.\n+          val logEntries = logEntryCaptor.getAllValues.asScala.map(_.asInstanceOf[DamlLogEntry])\n+          logEntries.map(_.getPartyAllocationEntry) should be(\n+            submissions.map(_.getPartyAllocationEntry))\n+        }\n+    }\n+\n+    \"not commit the duplicate submission\" in {\n+      val submission = makePartySubmission(\"duplicate-test\")\n+      val batchSubmission = DamlSubmissionBatch.newBuilder\n+        .addSubmissions(\n+          CorrelatedSubmission.newBuilder\n+            .setCorrelationId(aCorrelationId)\n+            .setSubmission(Envelope.enclose(submission)))\n+        .addSubmissions(CorrelatedSubmission.newBuilder\n+          .setCorrelationId(\"anotherCorrelationId\")\n+          .setSubmission(Envelope.enclose(submission)))\n+        .build()\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          any[DamlLogEntry],\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          any[Map[DamlStateKey, DamlStateValue]]\n+        ))\n+        .thenReturn(Future.unit)\n+      val validator = BatchedSubmissionValidator[Unit](\n+        BatchedSubmissionValidatorParameters.default,\n+        engine,\n+        metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          Envelope.enclose(batchSubmission),\n+          \"batch-correlationId\",\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          // We must have 1 commit only (for the first submission).\n+          verify(mockCommit, times(1)).commit(\n+            any[ParticipantId](),\n+            any[String](),\n+            any[DamlLogEntryId](),\n+            any[DamlLogEntry](),\n+            any[DamlInputState](),\n+            any[DamlOutputState]())\n+          succeed\n+        }\n+    }\n+\n+    \"collect size/count metrics for a batch\" in {\n+      val metrics = new Metrics(new MetricRegistry)\n+      val (submissions, batchSubmission, batchSubmissionBytes) = createBatchSubmissionOf(2)\n+      val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+      // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+      when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+        .thenReturn(Future.successful(Seq(None, None)))\n+      val mockCommit = mock[CommitStrategy[Unit]]\n+      when(\n+        mockCommit.commit(\n+          any[ParticipantId],\n+          any[String],\n+          any[DamlLogEntryId],\n+          any[DamlLogEntry],\n+          any[Map[DamlStateKey, Option[DamlStateValue]]],\n+          any[Map[DamlStateKey, DamlStateValue]]\n+        ))\n+        .thenReturn(Future.unit)\n+      val validator =\n+        BatchedSubmissionValidator[Unit](\n+          BatchedSubmissionValidatorParameters.default,\n+          engine,\n+          metrics)\n+\n+      validator\n+        .validateAndCommit(\n+          batchSubmissionBytes,\n+          \"batch-correlationId\",\n+          newRecordTime().toInstant,\n+          aParticipantId,\n+          mockLedgerStateReader,\n+          mockCommit\n+        )\n+        .map { _ =>\n+          validator.Metrics.batchSizes.getSnapshot.getValues should equal(Array(2))\n+          val Array(actualBatchSubmissionSize) =\n+            validator.Metrics.receivedBatchSubmissionBytes.getSnapshot.getValues\n+          actualBatchSubmissionSize should equal(batchSubmission.getSerializedSize)\n+          val expectedSubmissionSizes = submissions.map(_.getSerializedSize)\n+          validator.Metrics.receivedSubmissionBytes.getSnapshot.getValues.toSet should contain allElementsOf\n+            expectedSubmissionSizes\n+          succeed\n+        }\n+    }\n+  }\n+\n+  type DamlInputState = Map[DamlStateKey, Option[DamlStateValue]]\n+  type DamlOutputState = Map[DamlStateKey, DamlStateValue]\n+\n+  private def newRecordTime(): Timestamp =\n+    Timestamp.assertFromInstant(Clock.systemUTC().instant())\n+\n+  private lazy val aCorrelationId: String = \"aCorrelationId\"\n+\n+  private def validateBatchSubmission(\n+      nSubmissions: Int,\n+      commitParallelism: Int): Future[Assertion] = {\n+    val (submissions, _, batchSubmissionBytes) = createBatchSubmissionOf(nSubmissions)\n+    val mockLedgerStateReader = mock[DamlLedgerStateReader]\n+    // Expect two keys, i.e., to retrieve the party and submission dedup values.\n+    when(mockLedgerStateReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 2)))\n+      .thenReturn(Future.successful(Seq(None, None)))\n+    val logEntryCaptor = ArgumentCaptor.forClass(classOf[DamlLogEntry])\n+    val outputStateCaptor = ArgumentCaptor.forClass(classOf[Map[DamlStateKey, DamlStateValue]])\n+    val mockCommit = mock[CommitStrategy[Unit]]\n+    when(\n+      mockCommit.commit(\n+        any[ParticipantId],\n+        any[String],\n+        any[DamlLogEntryId],\n+        logEntryCaptor.capture(),\n+        any[Map[DamlStateKey, Option[DamlStateValue]]],\n+        outputStateCaptor.capture()))\n+      .thenReturn(Future.unit)\n+    val validatorConfig =\n+      BatchedSubmissionValidatorParameters.default.copy(commitParallelism = commitParallelism)\n+    val validator = BatchedSubmissionValidator[Unit](validatorConfig, engine, metrics)\n+\n+    validator\n+      .validateAndCommit(\n+        batchSubmissionBytes,\n+        \"batch-correlationId\",\n+        newRecordTime().toInstant,\n+        aParticipantId,\n+        mockLedgerStateReader,\n+        mockCommit\n+      )\n+      .map { _ =>\n+        // We expected two state fetches and two commits.\n+        verify(mockLedgerStateReader, times(nSubmissions)).readState(any[Seq[DamlStateKey]]())\n+        verify(mockCommit, times(nSubmissions)).commit(\n+          any[ParticipantId](),\n+          any[String](),\n+          any[DamlLogEntryId](),\n+          any[DamlLogEntry](),\n+          any[DamlInputState](),\n+          any[DamlOutputState]())\n+        // Verify we have all the expected log entries.\n+        val logEntries = logEntryCaptor.getAllValues.asScala.map(_.asInstanceOf[DamlLogEntry])\n+        logEntries.map(_.getPartyAllocationEntry) should contain allElementsOf\n+          submissions.map(_.getPartyAllocationEntry)\n+        // Verify that output state contains all the expected values.\n+        val outputState = outputStateCaptor.getAllValues.asScala\n+          .map(_.asInstanceOf[Map[DamlStateKey, DamlStateValue]])\n+          .fold(Map.empty) { case (a, b) => a ++ b }\n+        outputState should have size (2 * nSubmissions.toLong) // party + submission dedup for each\n+        outputState.keySet should be(submissions.flatMap(_.getInputDamlStateList.asScala).toSet)"
  }
]