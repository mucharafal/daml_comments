[
  {
    "id" : "fee982a3-5587-4ed1-917f-997cfadae237",
    "prId" : 5790,
    "comments" : [
      {
        "id" : "4af2d628-d41a-4266-bb4f-e393bec1e126",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Move this into the companion object where the helper methods are, please.",
        "createdAt" : "2020-05-05T08:30:08Z",
        "updatedAt" : "2020-05-06T10:18:00Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7234f1f69f87d95d1420a0faa8a6f2a70e0433f0",
    "line" : 12,
    "diffHunk" : "@@ -25,6 +26,8 @@ class KeyValueParticipantStateReaderSpec\n \n   import KVOffset.{fromLong => toOffset}\n \n+  private def newMetrics = new Metrics(new MetricRegistry)"
  },
  {
    "id" : "40d9796d-a818-4eed-8870-677abe24ec1e",
    "prId" : 5790,
    "comments" : [
      {
        "id" : "da09e487-639a-4655-b62f-c620156e5168",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n  private def createMetrics() = new Metrics(new MetricRegistry)\r\n```\r\nor\r\n```scala\r\n  private def newMetrics() = new Metrics(new MetricRegistry)\r\n```",
        "createdAt" : "2020-05-05T08:32:03Z",
        "updatedAt" : "2020-05-06T10:18:00Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7234f1f69f87d95d1420a0faa8a6f2a70e0433f0",
    "line" : 12,
    "diffHunk" : "@@ -25,6 +26,8 @@ class KeyValueParticipantStateReaderSpec\n \n   import KVOffset.{fromLong => toOffset}\n \n+  private def newMetrics = new Metrics(new MetricRegistry)"
  },
  {
    "id" : "7213da47-44fe-4e0f-b4c2-a21ba801c192",
    "prId" : 5576,
    "comments" : [
      {
        "id" : "59990eaf-4961-4d95-8fb5-1e79ce3f75d8",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Thanks for removing unused code -- seems to have slipped through the cracks.",
        "createdAt" : "2020-04-16T10:06:37Z",
        "updatedAt" : "2020-04-16T10:18:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a6cc46564b5f71316b037986bcf0ce735aa9ce37",
    "line" : 98,
    "diffHunk" : "@@ -188,11 +186,4 @@ object KeyValueParticipantStateReaderSpec {\n     reader\n   }\n \n-  private def readerStreamingFromAnyOffset(items: LedgerRecord*): LedgerReader = {"
  },
  {
    "id" : "3a861637-b9c6-4b06-81f0-13875f1f09dc",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "8ba575a2-6d0c-4ff8-8811-0b7d9703c8af",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "You can remove the zeroes here. (And below.)",
        "createdAt" : "2020-03-16T15:08:29Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : null,
    "diffHunk" : "@@ -33,109 +33,113 @@ class KeyValueParticipantStateReaderSpec\n     with Matchers\n     with AkkaBeforeAndAfterAll {\n \n-  private val start: Instant = Instant.from(ZonedDateTime.of(2020, 1, 1, 12, 0, 0, 0, UTC))\n+  import KVOffset.{fromLong => toOffset}\n \n+  private val start: Instant = Instant.from(ZonedDateTime.of(2020, 1, 1, 12, 0, 0, 0, UTC))\n   \"participant state reader\" should {\n     \"stream offsets and heartbeats from the start\" in {\n       val reader = readerStreamingFrom(\n         offset = None,\n-        LedgerRecord(Offset(Array(1, 1)), aLogEntryId(1), aWrappedLogEntry),\n-        Heartbeat(Offset(Array(1, 2)), start.plusSeconds(1)),\n-        LedgerRecord(Offset(Array(1, 3)), aLogEntryId(3), aWrappedLogEntry),\n-        Heartbeat(Offset(Array(1, 4)), start.plusSeconds(2)),\n-        Heartbeat(Offset(Array(1, 5)), start.plusSeconds(3)),\n-        LedgerRecord(Offset(Array(1, 6)), aLogEntryId(6), aWrappedLogEntry),\n+        LedgerRecord(toOffset(1), aLogEntryId(1), aWrappedLogEntry),\n+        Heartbeat(toOffset(2), start.plusSeconds(1)),\n+        LedgerRecord(toOffset(3), aLogEntryId(3), aWrappedLogEntry),\n+        Heartbeat(toOffset(4), start.plusSeconds(2)),\n+        Heartbeat(toOffset(5), start.plusSeconds(3)),\n+        LedgerRecord(toOffset(6), aLogEntryId(6), aWrappedLogEntry),\n       )\n       val instance = new KeyValueParticipantStateReader(reader)\n       val stream = instance.stateUpdates(None)\n \n       offsetsFrom(stream).map { actual =>\n         actual should have size 6\n         actual shouldBe Seq(\n-          Offset(Array(1, 1, 0)),\n-          Offset(Array(1, 2, 0)),\n-          Offset(Array(1, 3, 0)),\n-          Offset(Array(1, 4, 0)),\n-          Offset(Array(1, 5, 0)),\n-          Offset(Array(1, 6, 0)),\n+          toOffset(1, 0),\n+          toOffset(2, 0),\n+          toOffset(3, 0),\n+          toOffset(4, 0),\n+          toOffset(5, 0),\n+          toOffset(6, 0),"
  },
  {
    "id" : "8de88889-39ca-4d3a-9e45-39da4d36c2f6",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "72e0a48b-595a-41cf-b389-24317ef11fa4",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "You could return a `Future[Seq[Offset]]` here, as you're using `AsyncWordSpec`.",
        "createdAt" : "2019-12-23T10:17:08Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "27a75567-47c8-4f0c-bd00-8b94b8bd498c",
        "parentId" : "72e0a48b-595a-41cf-b389-24317ef11fa4",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Changed.",
        "createdAt" : "2020-01-06T13:12:05Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api\n+\n+import akka.NotUsed\n+import com.google.protobuf.ByteString\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlPartyAllocationEntry\n+}\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.{Offset, Update}\n+import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito.when\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Await\n+import scala.concurrent.duration.Duration\n+\n+class KeyValueParticipantStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with MockitoSugar\n+    with AkkaBeforeAndAfterAll {\n+  \"participant state reader\" should {\n+    \"remove index suffix when streaming from underlying reader\" in {\n+      val reader = readerStreamingFrom(\n+        offset = Some(Offset(Array(1, 1))),\n+        LedgerRecord(Offset(Array(1, 2)), aLogEntryId, aWrappedLogEntry))\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(Some(Offset(Array(1, 1, 0))))\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 1\n+      result.head shouldBe Offset(Array(1, 2, 0))\n+    }\n+\n+    \"append index to internal offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(None)\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 2\n+      result shouldBe Seq(Offset(Array(1, 0)), Offset(Array(2, 0)))\n+    }\n+\n+    \"skip events before specified offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(3)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+\n+      offsetsFrom(instance.stateUpdates(None)).size shouldBe 3\n+      offsetsFrom(instance.stateUpdates(Some(Offset(Array(1, 0))))).size shouldBe 2\n+      offsetsFrom(instance.stateUpdates(Some(Offset(Array(3, 0))))).isEmpty shouldBe true\n+    }\n+  }\n+\n+  private val aLogEntry = DamlLogEntry\n+    .newBuilder()\n+    .setPartyAllocationEntry(\n+      DamlPartyAllocationEntry.newBuilder().setParty(\"aParty\").setParticipantId(\"aParticipant\"))\n+    .build()\n+\n+  private val aWrappedLogEntry = Envelope.enclose(aLogEntry).toByteArray()\n+\n+  private def aLogEntryId =\n+    DamlLogEntryId.newBuilder\n+      .setEntryId(ByteString.copyFrom(\"anId\".getBytes))\n+      .build\n+\n+  private val DefaultTimeout = Duration(1, \"minutes\")\n+\n+  private def readerStreamingFrom(offset: Option[Offset], items: LedgerRecord*): LedgerReader = {\n+    val reader = mock[LedgerReader]\n+    val stream = Source.fromIterator(() => items.toIterator)\n+    if (offset.isDefined) {\n+      when(reader.events(offset)).thenReturn(stream)\n+    } else {\n+      when(reader.events(any[Option[Offset]]())).thenReturn(stream)\n+    }\n+    reader\n+  }\n+\n+  private def offsetsFrom(stream: Source[(Offset, Update), NotUsed]): Seq[Offset] ="
  },
  {
    "id" : "82c49b36-b4f1-45e9-a3df-218d3d3b8858",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "9ba2194c-9240-48ae-a78b-de3dce3efe87",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "You can use `shouldBe empty` here.",
        "createdAt" : "2019-12-23T10:17:55Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api\n+\n+import akka.NotUsed\n+import com.google.protobuf.ByteString\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlPartyAllocationEntry\n+}\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.{Offset, Update}\n+import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito.when\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Await\n+import scala.concurrent.duration.Duration\n+\n+class KeyValueParticipantStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with MockitoSugar\n+    with AkkaBeforeAndAfterAll {\n+  \"participant state reader\" should {\n+    \"remove index suffix when streaming from underlying reader\" in {\n+      val reader = readerStreamingFrom(\n+        offset = Some(Offset(Array(1, 1))),\n+        LedgerRecord(Offset(Array(1, 2)), aLogEntryId, aWrappedLogEntry))\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(Some(Offset(Array(1, 1, 0))))\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 1\n+      result.head shouldBe Offset(Array(1, 2, 0))\n+    }\n+\n+    \"append index to internal offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(None)\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 2\n+      result shouldBe Seq(Offset(Array(1, 0)), Offset(Array(2, 0)))\n+    }\n+\n+    \"skip events before specified offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(3)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+\n+      offsetsFrom(instance.stateUpdates(None)).size shouldBe 3\n+      offsetsFrom(instance.stateUpdates(Some(Offset(Array(1, 0))))).size shouldBe 2\n+      offsetsFrom(instance.stateUpdates(Some(Offset(Array(3, 0))))).isEmpty shouldBe true"
  },
  {
    "id" : "65261ade-8d3c-4496-b45e-86fbe215b595",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "e37e7ed4-ec7d-4842-ae58-db068ad3ca48",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Not sure it's necessary to check the `size`; either just test `result` against a `Seq(Offset(â€¦))` or use `result.lone`.",
        "createdAt" : "2019-12-23T10:18:37Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0dfe1b33-8e11-43cf-9abb-bfe63617fa2d",
        "parentId" : "e37e7ed4-ec7d-4842-ae58-db068ad3ca48",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Changed.",
        "createdAt" : "2020-01-06T12:28:46Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api\n+\n+import akka.NotUsed\n+import com.google.protobuf.ByteString\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlPartyAllocationEntry\n+}\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.{Offset, Update}\n+import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito.when\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Await\n+import scala.concurrent.duration.Duration\n+\n+class KeyValueParticipantStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with MockitoSugar\n+    with AkkaBeforeAndAfterAll {\n+  \"participant state reader\" should {\n+    \"remove index suffix when streaming from underlying reader\" in {\n+      val reader = readerStreamingFrom(\n+        offset = Some(Offset(Array(1, 1))),\n+        LedgerRecord(Offset(Array(1, 2)), aLogEntryId, aWrappedLogEntry))\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(Some(Offset(Array(1, 1, 0))))\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 1\n+      result.head shouldBe Offset(Array(1, 2, 0))"
  },
  {
    "id" : "db3a135c-95a0-4b0f-aa88-eb4827e15d58",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "0f162765-0036-4777-94dd-8c30b0e5b19b",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Probably necessary; the next assertion will catch this and deliver a better error message.",
        "createdAt" : "2019-12-23T10:18:58Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "48892402-2d7f-4437-894c-eff810f17014",
        "parentId" : "0f162765-0036-4777-94dd-8c30b0e5b19b",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Removed.",
        "createdAt" : "2020-01-06T12:28:39Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "948b6856-1a5c-4ff1-91ab-a3d717fe2631",
        "parentId" : "0f162765-0036-4777-94dd-8c30b0e5b19b",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Not sure regarding @SamirTalwar's comment. Scalatest output when it comes to comparing sequences can be quite difficult to read, having a clear output telling you exactly the property which is making the test fail can probably be useful.\r\n\r\nThat said, I would suggest using this to have the most telling output from Scalatest if the property is not satisfied:\r\n\r\n    result should have size 2",
        "createdAt" : "2020-01-06T16:55:37Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api\n+\n+import akka.NotUsed\n+import com.google.protobuf.ByteString\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlPartyAllocationEntry\n+}\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.{Offset, Update}\n+import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito.when\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Await\n+import scala.concurrent.duration.Duration\n+\n+class KeyValueParticipantStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with MockitoSugar\n+    with AkkaBeforeAndAfterAll {\n+  \"participant state reader\" should {\n+    \"remove index suffix when streaming from underlying reader\" in {\n+      val reader = readerStreamingFrom(\n+        offset = Some(Offset(Array(1, 1))),\n+        LedgerRecord(Offset(Array(1, 2)), aLogEntryId, aWrappedLogEntry))\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(Some(Offset(Array(1, 1, 0))))\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 1\n+      result.head shouldBe Offset(Array(1, 2, 0))\n+    }\n+\n+    \"append index to internal offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(None)\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 2"
  },
  {
    "id" : "8d0fea5a-c527-4f4a-ac42-fae97bba2da5",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "5689af26-6a3d-4de0-b81f-b0f6af7b4ec5",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I think you can use `should have size 3` here.",
        "createdAt" : "2019-12-23T10:19:28Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ce491b15-d563-4396-892b-d7404beaabc6",
        "parentId" : "5689af26-6a3d-4de0-b81f-b0f6af7b4ec5",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Made assertions easier to read.",
        "createdAt" : "2020-01-06T13:12:28Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api\n+\n+import akka.NotUsed\n+import com.google.protobuf.ByteString\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlPartyAllocationEntry\n+}\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.{Offset, Update}\n+import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito.when\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Await\n+import scala.concurrent.duration.Duration\n+\n+class KeyValueParticipantStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with MockitoSugar\n+    with AkkaBeforeAndAfterAll {\n+  \"participant state reader\" should {\n+    \"remove index suffix when streaming from underlying reader\" in {\n+      val reader = readerStreamingFrom(\n+        offset = Some(Offset(Array(1, 1))),\n+        LedgerRecord(Offset(Array(1, 2)), aLogEntryId, aWrappedLogEntry))\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(Some(Offset(Array(1, 1, 0))))\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 1\n+      result.head shouldBe Offset(Array(1, 2, 0))\n+    }\n+\n+    \"append index to internal offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(None)\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 2\n+      result shouldBe Seq(Offset(Array(1, 0)), Offset(Array(2, 0)))\n+    }\n+\n+    \"skip events before specified offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(3)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+\n+      offsetsFrom(instance.stateUpdates(None)).size shouldBe 3"
  },
  {
    "id" : "ebc6ffb6-ed72-4e8c-8d1d-57dfeefe7ce6",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "769077c3-89a4-482d-9a9b-22798cdf0af1",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "`should have size 2`.",
        "createdAt" : "2019-12-23T10:19:42Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api\n+\n+import akka.NotUsed\n+import com.google.protobuf.ByteString\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlPartyAllocationEntry\n+}\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.{Offset, Update}\n+import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito.when\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Await\n+import scala.concurrent.duration.Duration\n+\n+class KeyValueParticipantStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with MockitoSugar\n+    with AkkaBeforeAndAfterAll {\n+  \"participant state reader\" should {\n+    \"remove index suffix when streaming from underlying reader\" in {\n+      val reader = readerStreamingFrom(\n+        offset = Some(Offset(Array(1, 1))),\n+        LedgerRecord(Offset(Array(1, 2)), aLogEntryId, aWrappedLogEntry))\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(Some(Offset(Array(1, 1, 0))))\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 1\n+      result.head shouldBe Offset(Array(1, 2, 0))\n+    }\n+\n+    \"append index to internal offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(None)\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 2\n+      result shouldBe Seq(Offset(Array(1, 0)), Offset(Array(2, 0)))\n+    }\n+\n+    \"skip events before specified offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(3)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+\n+      offsetsFrom(instance.stateUpdates(None)).size shouldBe 3\n+      offsetsFrom(instance.stateUpdates(Some(Offset(Array(1, 0))))).size shouldBe 2"
  },
  {
    "id" : "4d802562-8255-4d46-84dd-073ebf92fb56",
    "prId" : 3923,
    "comments" : [
      {
        "id" : "20fb3115-25c9-467b-9b0f-3e3b15aed202",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Why not just use `Source(items)`?",
        "createdAt" : "2019-12-23T10:20:17Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a70e7656-8764-4bf2-bed3-bba4e411d1f5",
        "parentId" : "20fb3115-25c9-467b-9b0f-3e3b15aed202",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Because that expects an immutable `Seq` whereas `items` is a mutable `Seq`. The above solution avoids copying the elements.",
        "createdAt" : "2020-01-06T13:01:33Z",
        "updatedAt" : "2020-01-10T10:31:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c820159bc8cad55858939f177705f0a8bab0fd13",
    "line" : 131,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.participant.state.kvutils.api\n+\n+import akka.NotUsed\n+import com.google.protobuf.ByteString\n+import akka.stream.scaladsl.{Sink, Source}\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntry,\n+  DamlLogEntryId,\n+  DamlPartyAllocationEntry\n+}\n+import com.daml.ledger.participant.state.kvutils.Envelope\n+import com.daml.ledger.participant.state.v1.{Offset, Update}\n+import com.digitalasset.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito.when\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Matchers}\n+\n+import scala.concurrent.Await\n+import scala.concurrent.duration.Duration\n+\n+class KeyValueParticipantStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with MockitoSugar\n+    with AkkaBeforeAndAfterAll {\n+  \"participant state reader\" should {\n+    \"remove index suffix when streaming from underlying reader\" in {\n+      val reader = readerStreamingFrom(\n+        offset = Some(Offset(Array(1, 1))),\n+        LedgerRecord(Offset(Array(1, 2)), aLogEntryId, aWrappedLogEntry))\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(Some(Offset(Array(1, 1, 0))))\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 1\n+      result.head shouldBe Offset(Array(1, 2, 0))\n+    }\n+\n+    \"append index to internal offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+      val stream = instance.stateUpdates(None)\n+      val result = offsetsFrom(stream)\n+\n+      result.size shouldBe 2\n+      result shouldBe Seq(Offset(Array(1, 0)), Offset(Array(2, 0)))\n+    }\n+\n+    \"skip events before specified offset\" in {\n+      val reader = readerStreamingFrom(\n+        offset = None,\n+        LedgerRecord(Offset(Array(1)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(2)), aLogEntryId, aWrappedLogEntry),\n+        LedgerRecord(Offset(Array(3)), aLogEntryId, aWrappedLogEntry)\n+      )\n+      val instance = new KeyValueParticipantStateReader(reader)\n+\n+      offsetsFrom(instance.stateUpdates(None)).size shouldBe 3\n+      offsetsFrom(instance.stateUpdates(Some(Offset(Array(1, 0))))).size shouldBe 2\n+      offsetsFrom(instance.stateUpdates(Some(Offset(Array(3, 0))))).isEmpty shouldBe true\n+    }\n+  }\n+\n+  private val aLogEntry = DamlLogEntry\n+    .newBuilder()\n+    .setPartyAllocationEntry(\n+      DamlPartyAllocationEntry.newBuilder().setParty(\"aParty\").setParticipantId(\"aParticipant\"))\n+    .build()\n+\n+  private val aWrappedLogEntry = Envelope.enclose(aLogEntry).toByteArray()\n+\n+  private def aLogEntryId =\n+    DamlLogEntryId.newBuilder\n+      .setEntryId(ByteString.copyFrom(\"anId\".getBytes))\n+      .build\n+\n+  private val DefaultTimeout = Duration(1, \"minutes\")\n+\n+  private def readerStreamingFrom(offset: Option[Offset], items: LedgerRecord*): LedgerReader = {\n+    val reader = mock[LedgerReader]\n+    val stream = Source.fromIterator(() => items.toIterator)"
  }
]