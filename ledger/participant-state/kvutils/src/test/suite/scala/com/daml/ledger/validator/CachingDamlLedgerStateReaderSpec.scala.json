[
  {
    "id" : "43d297b3-6089-4599-b943-f14b1c7d37a0",
    "prId" : 6111,
    "comments" : [
      {
        "id" : "77e550f1-33f2-4a2b-b27e-4650434b83b2",
        "parentId" : null,
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "We have a parameter for this in other ledgers, would it make sense to use it here as well?",
        "createdAt" : "2020-05-27T10:17:00Z",
        "updatedAt" : "2020-05-28T08:28:21Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2482bc4f-9eae-45e6-9176-2c6ea26b8fdc",
        "parentId" : "77e550f1-33f2-4a2b-b27e-4650434b83b2",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Can you elaborate, please? This just creates a small cache to test the caching logic without having to mock the cache instance.",
        "createdAt" : "2020-05-27T10:24:48Z",
        "updatedAt" : "2020-05-28T08:28:21Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "38ae9f82-5ce2-4710-a5ed-d5e70cb1aa04",
        "parentId" : "77e550f1-33f2-4a2b-b27e-4650434b83b2",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "please ignore, i didn't read filename",
        "createdAt" : "2020-05-27T10:59:58Z",
        "updatedAt" : "2020-05-28T08:28:21Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4eaa7219a57e7cae32f14958b2c32423ade3c9d3",
    "line" : 18,
    "diffHunk" : "@@ -68,9 +69,7 @@ class CachingDamlLedgerStateReaderSpec\n \n   private def newInstance(damlLedgerStateReader: DamlLedgerStateReader)(\n       implicit executionContext: ExecutionContext): CachingDamlLedgerStateReader = {\n-    val cache = Caffeine\n-      .newBuilder()\n-      .build[DamlStateKey, DamlStateValue]\n+    val cache = Cache.from[DamlStateKey, DamlStateValue](Configuration(1024))"
  },
  {
    "id" : "275c20f6-6d3a-449f-a689-69deb1ccd289",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "3ddaf9c6-c827-4842-a3a5-57562831da2a",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Isn't this test included in the next one?",
        "createdAt" : "2020-05-22T16:28:59Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5aaa2aa1-1187-4b51-8b87-a6f79393fcd9",
        "parentId" : "3ddaf9c6-c827-4842-a3a5-57562831da2a",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "No, the next one checks that we are not reading what's already in the cache whereas this one checks that we write the just read value back to the cache.",
        "createdAt" : "2020-05-25T10:04:01Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : 37,
    "diffHunk" : "@@ -0,0 +1,82 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{DamlStateKey, DamlStateValue}\n+import com.github.benmanes.caffeine.cache.Caffeine\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito._\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Inside, Matchers}\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+class CachingDamlLedgerStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with MockitoSugar {\n+\n+  private val keySerializationStrategy = DefaultStateKeySerializationStrategy\n+\n+  \"readState\" should {\n+    \"record read keys\" in {\n+      val mockReader = mock[DamlLedgerStateReader]\n+      when(mockReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 1)))\n+        .thenReturn(Future.successful(Seq(Some(aDamlStateValue()))))\n+      val instance = newInstance(mockReader)\n+\n+      instance.readState(Seq(aDamlStateKey)).map { actual =>\n+        actual should have size 1\n+        instance.getReadSet should be(\n+          Set(keySerializationStrategy.serializeStateKey(aDamlStateKey)))\n+      }\n+    }\n+\n+    \"write to cache what was read\" in {"
  },
  {
    "id" : "cd21d3fc-a18d-469d-8c20-62057f36e467",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "e9ee110e-c39a-4848-a49b-dd58695d7cb5",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "I'd rather not set an expiry time in this test, if possible; also not a max weight as it's not used.",
        "createdAt" : "2020-05-22T16:29:26Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e238614e-5ca5-4d89-964d-a34af4abd2f7",
        "parentId" : "e9ee110e-c39a-4848-a49b-dd58695d7cb5",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Simplified.",
        "createdAt" : "2020-05-25T10:03:09Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,82 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.validator\n+\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{DamlStateKey, DamlStateValue}\n+import com.github.benmanes.caffeine.cache.Caffeine\n+import org.mockito.ArgumentMatchers._\n+import org.mockito.Mockito._\n+import org.scalatest.mockito.MockitoSugar\n+import org.scalatest.{AsyncWordSpec, Inside, Matchers}\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+class CachingDamlLedgerStateReaderSpec\n+    extends AsyncWordSpec\n+    with Matchers\n+    with Inside\n+    with MockitoSugar {\n+\n+  private val keySerializationStrategy = DefaultStateKeySerializationStrategy\n+\n+  \"readState\" should {\n+    \"record read keys\" in {\n+      val mockReader = mock[DamlLedgerStateReader]\n+      when(mockReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 1)))\n+        .thenReturn(Future.successful(Seq(Some(aDamlStateValue()))))\n+      val instance = newInstance(mockReader)\n+\n+      instance.readState(Seq(aDamlStateKey)).map { actual =>\n+        actual should have size 1\n+        instance.getReadSet should be(\n+          Set(keySerializationStrategy.serializeStateKey(aDamlStateKey)))\n+      }\n+    }\n+\n+    \"write to cache what was read\" in {\n+      val mockReader = mock[DamlLedgerStateReader]\n+      when(mockReader.readState(argThat((keys: Seq[DamlStateKey]) => keys.size == 1)))\n+        .thenReturn(Future.successful(Seq(Some(aDamlStateValue()))))\n+      val instance = newInstance(mockReader)\n+\n+      instance.readState(Seq(aDamlStateKey)).map { _ =>\n+        instance.cache.getIfPresent(aDamlStateKey) should not be null\n+      }\n+    }\n+\n+    \"serve request from cache for seen key\" in {\n+      val mockReader = mock[DamlLedgerStateReader]\n+      when(mockReader.readState(any[Seq[DamlStateKey]]())).thenReturn(Future.successful(Seq(None)))\n+      val instance = newInstance(mockReader)\n+\n+      for {\n+        originalReadState <- instance.readState(Seq(aDamlStateKey))\n+        readAgain <- instance.readState(Seq(aDamlStateKey))\n+      } yield {\n+        verify(mockReader, times(1)).readState(_)\n+        readAgain shouldEqual originalReadState\n+      }\n+    }\n+  }\n+\n+  private lazy val aDamlStateKey = DamlStateKey.newBuilder\n+    .setContractId(\"aContractId\")\n+    .build\n+\n+  private def aDamlStateValue(): DamlStateValue = DamlStateValue.getDefaultInstance\n+\n+  private def newInstance(damlLedgerStateReader: DamlLedgerStateReader)(\n+      implicit executionContext: ExecutionContext): CachingDamlLedgerStateReader = {\n+    val cache = Caffeine\n+      .newBuilder()\n+      .expireAfterWrite(java.time.Duration.ofHours(1))"
  }
]