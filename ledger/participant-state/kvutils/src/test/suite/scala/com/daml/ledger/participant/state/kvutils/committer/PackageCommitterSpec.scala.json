[
  {
    "id" : "344d79d7-8df1-4162-a1d2-f319a77b56b8",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "94f8710a-1996-4d98-9c25-aefd5450df57",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n  \"PackageCommitter\" should {\r\n```",
        "createdAt" : "2020-10-05T16:00:23Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -3,69 +3,464 @@\n \n package com.daml.ledger.participant.state.kvutils.committer\n \n+import java.util.UUID\n+\n import com.codahale.metrics.MetricRegistry\n-import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlPackageUploadEntry\n-import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.daml_lf_dev.DamlLf\n import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n-import com.daml.lf.engine.Engine\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.ledger.participant.state.kvutils.committer.PackageCommitter._\n+import com.daml.lf.archive.Decode\n+import com.daml.lf.archive.testing.Encode\n+import com.daml.lf.data.Ref\n+import com.daml.lf.engine.{Engine, EngineConfig}\n+import com.daml.lf.language.Ast\n import com.daml.metrics.Metrics\n-import org.scalatest.mockito.MockitoSugar\n-import org.scalatest.{Matchers, WordSpec}\n+import com.google.protobuf.ByteString\n+import org.scalatest.{Matchers, ParallelTestExecution, WordSpec}\n \n-class PackageCommitterSpec extends WordSpec with Matchers with MockitoSugar {\n-  private val metrics = new Metrics(new MetricRegistry)\n-  private val anEmptyResult = DamlPackageUploadEntry.newBuilder\n-    .setSubmissionId(\"an ID\")\n-    .setParticipantId(\"a participant\")\n+import scala.collection.JavaConverters._\n \n-  \"buildLogEntry\" should {\n-    \"set record time in log entry if record time is available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = Some(theRecordTime))\n+class PackageCommitterSpec extends WordSpec with Matchers with ParallelTestExecution {\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+  import com.daml.lf.testing.parser.Implicits._\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe true\n-          actualLogEntry.getRecordTime shouldBe buildTimestamp(theRecordTime)\n-      }\n+  private[this] def encodePackage[P](pkg: Ast.Package) =\n+    Encode.encodeArchive(\n+      defaultParserParameters.defaultPackageId -> pkg,\n+      defaultParserParameters.languageVersion,\n+    )\n+\n+  private[this] val archive1 =\n+    encodePackage(p\"\"\"\n+        metadata ( 'Color' : '0.0.1' )\n+\n+        module Color {\n+          enum Primary = Red | Blue | Green ;\n+        }\n+      \"\"\")\n+  private[this] val (pkgId1, pkg1) = Decode.decodeArchive(archive1)\n+  private[this] val archive2 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'DamlZ' : '0.0.1' )\n+\n+        module DamlZ {\n+          variant Either a b = Left : a | Right : b ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId2, pkg2) = Decode.decodeArchive(archive2)\n+  private[this] val archive3 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'Quantum' : '0.0.1' )\n+\n+        module Chromodynamics {\n+          record Charge = { value: '${pkgId1}':Color:Primary } ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId3, _) = Decode.decodeArchive(archive3)\n+\n+  private[this] val archive4 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'IllTyped' : '0.0.1' )\n+\n+        module Wrong {\n+          val i: Numeric 10 = 1;  // 1 is an Int64 is not a Numeric\n+        }\n+      \"\"\"\n+    )\n+\n+  private[this] val participantId = Ref.ParticipantId.assertFromString(\"participant\")\n+\n+  private[this] class CommitterWrapper(\n+      validationMode: ValidationMode,\n+      preloadingMode: PreloadingMode,\n+  ) {\n+    val metrics = new Metrics(new MetricRegistry)\n+    var engine: Engine = _\n+    var packageCommitter: PackageCommitter = _\n+    var state = Map.empty[DamlStateKey, DamlStateValue]\n+    restart()\n+\n+    // simulate restart of the participant node\n+    def restart() = this.synchronized {\n+      engine = new Engine(EngineConfig.Dev.copy(packageValidation = false))\n+      packageCommitter = new PackageCommitter(engine, metrics, validationMode, preloadingMode)\n+    }\n+\n+    def submit(submission: DamlSubmission) = {\n+      val result @ (log2, output1) =\n+        packageCommitter.run(\n+          Some(com.daml.lf.data.Time.Timestamp.now()),\n+          submission,\n+          participantId,\n+          wrapMap(state))\n+      if (log2.hasPackageUploadRejectionEntry)\n+        assert(output1.isEmpty)\n+      else\n+        state ++= output1\n+      result\n+    }\n+  }\n+\n+  private[this] def buildSubmission(archives: DamlLf.Archive*) =\n+    DamlSubmission\n+      .newBuilder()\n+      .setPackageUploadEntry(\n+        DamlPackageUploadEntry\n+          .newBuilder()\n+          .setSubmissionId(UUID.randomUUID().toString)\n+          .setParticipantId(participantId)\n+          .addAllArchives(archives.asJava)\n+      )\n+      .build()\n+\n+  private[this] def wrapMap[K, V](m: Map[K, V]): Map[K, Option[V]] = new Map[K, Option[V]] {\n+    override def +[V1 >: Option[V]](kv: (K, V1)): Map[K, V1] = ???\n+    override def get(key: K): Option[Option[V]] = Some(m.get(key))\n+    override def iterator: Iterator[(K, Option[V])] = ???\n+    override def -(key: K): Map[K, Option[V]] = ???\n+  }\n+\n+  private[this] val emptyState = wrapMap(Map.empty[DamlStateKey, DamlStateValue])\n+\n+  private[this] def details(rejection: DamlPackageUploadRejectionEntry) = {\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+    rejection.getReasonCase match {\n+      case PARTICIPANT_NOT_AUTHORIZED =>\n+        rejection.getParticipantNotAuthorized.getDetails\n+      case DUPLICATE_SUBMISSION =>\n+        rejection.getDuplicateSubmission.getDetails\n+      case INVALID_PACKAGE =>\n+        rejection.getInvalidPackage.getDetails\n+      case REASON_NOT_SET =>\n+        \"\"\n+    }\n+  }\n+\n+  private[this] def shouldFailWith(\n+      output: (DamlLogEntry, _),\n+      reason: DamlPackageUploadRejectionEntry.ReasonCase,\n+      msg: String = \"\",\n+  ) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe true\n+    output._1.getPackageUploadRejectionEntry.getReasonCase shouldBe reason\n+    details(output._1.getPackageUploadRejectionEntry) should include(msg)\n+  }\n+\n+  private[this] def shouldSucceed(output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue])) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe false\n+    output._2 shouldBe 'nonEmpty\n+  }\n+\n+  private[this] def shouldSucceedWith(\n+      output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue]),\n+      committedPackages: Set[Ref.PackageId]) = {\n+    shouldSucceed(output)\n+    val archives = output._1.getPackageUploadEntry.getArchivesList\n+    archives.size() shouldBe committedPackages.size\n+    archives.iterator().asScala.map(_.getHash).toSet shouldBe committedPackages.toSet[String]\n+  }\n+\n+  s\"PackageCommitter\" should {"
  },
  {
    "id" : "a2d03f1a-f1c3-4e52-9af2-28ed15a13a57",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "b4240403-3047-49b7-ba88-8393721629d1",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n    // Don't need to run the below test cases for all instances of PackageCommitter.\r\n```",
        "createdAt" : "2020-10-05T16:01:23Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -3,69 +3,464 @@\n \n package com.daml.ledger.participant.state.kvutils.committer\n \n+import java.util.UUID\n+\n import com.codahale.metrics.MetricRegistry\n-import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlPackageUploadEntry\n-import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.daml_lf_dev.DamlLf\n import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n-import com.daml.lf.engine.Engine\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.ledger.participant.state.kvutils.committer.PackageCommitter._\n+import com.daml.lf.archive.Decode\n+import com.daml.lf.archive.testing.Encode\n+import com.daml.lf.data.Ref\n+import com.daml.lf.engine.{Engine, EngineConfig}\n+import com.daml.lf.language.Ast\n import com.daml.metrics.Metrics\n-import org.scalatest.mockito.MockitoSugar\n-import org.scalatest.{Matchers, WordSpec}\n+import com.google.protobuf.ByteString\n+import org.scalatest.{Matchers, ParallelTestExecution, WordSpec}\n \n-class PackageCommitterSpec extends WordSpec with Matchers with MockitoSugar {\n-  private val metrics = new Metrics(new MetricRegistry)\n-  private val anEmptyResult = DamlPackageUploadEntry.newBuilder\n-    .setSubmissionId(\"an ID\")\n-    .setParticipantId(\"a participant\")\n+import scala.collection.JavaConverters._\n \n-  \"buildLogEntry\" should {\n-    \"set record time in log entry if record time is available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = Some(theRecordTime))\n+class PackageCommitterSpec extends WordSpec with Matchers with ParallelTestExecution {\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+  import com.daml.lf.testing.parser.Implicits._\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe true\n-          actualLogEntry.getRecordTime shouldBe buildTimestamp(theRecordTime)\n-      }\n+  private[this] def encodePackage[P](pkg: Ast.Package) =\n+    Encode.encodeArchive(\n+      defaultParserParameters.defaultPackageId -> pkg,\n+      defaultParserParameters.languageVersion,\n+    )\n+\n+  private[this] val archive1 =\n+    encodePackage(p\"\"\"\n+        metadata ( 'Color' : '0.0.1' )\n+\n+        module Color {\n+          enum Primary = Red | Blue | Green ;\n+        }\n+      \"\"\")\n+  private[this] val (pkgId1, pkg1) = Decode.decodeArchive(archive1)\n+  private[this] val archive2 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'DamlZ' : '0.0.1' )\n+\n+        module DamlZ {\n+          variant Either a b = Left : a | Right : b ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId2, pkg2) = Decode.decodeArchive(archive2)\n+  private[this] val archive3 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'Quantum' : '0.0.1' )\n+\n+        module Chromodynamics {\n+          record Charge = { value: '${pkgId1}':Color:Primary } ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId3, _) = Decode.decodeArchive(archive3)\n+\n+  private[this] val archive4 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'IllTyped' : '0.0.1' )\n+\n+        module Wrong {\n+          val i: Numeric 10 = 1;  // 1 is an Int64 is not a Numeric\n+        }\n+      \"\"\"\n+    )\n+\n+  private[this] val participantId = Ref.ParticipantId.assertFromString(\"participant\")\n+\n+  private[this] class CommitterWrapper(\n+      validationMode: ValidationMode,\n+      preloadingMode: PreloadingMode,\n+  ) {\n+    val metrics = new Metrics(new MetricRegistry)\n+    var engine: Engine = _\n+    var packageCommitter: PackageCommitter = _\n+    var state = Map.empty[DamlStateKey, DamlStateValue]\n+    restart()\n+\n+    // simulate restart of the participant node\n+    def restart() = this.synchronized {\n+      engine = new Engine(EngineConfig.Dev.copy(packageValidation = false))\n+      packageCommitter = new PackageCommitter(engine, metrics, validationMode, preloadingMode)\n+    }\n+\n+    def submit(submission: DamlSubmission) = {\n+      val result @ (log2, output1) =\n+        packageCommitter.run(\n+          Some(com.daml.lf.data.Time.Timestamp.now()),\n+          submission,\n+          participantId,\n+          wrapMap(state))\n+      if (log2.hasPackageUploadRejectionEntry)\n+        assert(output1.isEmpty)\n+      else\n+        state ++= output1\n+      result\n+    }\n+  }\n+\n+  private[this] def buildSubmission(archives: DamlLf.Archive*) =\n+    DamlSubmission\n+      .newBuilder()\n+      .setPackageUploadEntry(\n+        DamlPackageUploadEntry\n+          .newBuilder()\n+          .setSubmissionId(UUID.randomUUID().toString)\n+          .setParticipantId(participantId)\n+          .addAllArchives(archives.asJava)\n+      )\n+      .build()\n+\n+  private[this] def wrapMap[K, V](m: Map[K, V]): Map[K, Option[V]] = new Map[K, Option[V]] {\n+    override def +[V1 >: Option[V]](kv: (K, V1)): Map[K, V1] = ???\n+    override def get(key: K): Option[Option[V]] = Some(m.get(key))\n+    override def iterator: Iterator[(K, Option[V])] = ???\n+    override def -(key: K): Map[K, Option[V]] = ???\n+  }\n+\n+  private[this] val emptyState = wrapMap(Map.empty[DamlStateKey, DamlStateValue])\n+\n+  private[this] def details(rejection: DamlPackageUploadRejectionEntry) = {\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+    rejection.getReasonCase match {\n+      case PARTICIPANT_NOT_AUTHORIZED =>\n+        rejection.getParticipantNotAuthorized.getDetails\n+      case DUPLICATE_SUBMISSION =>\n+        rejection.getDuplicateSubmission.getDetails\n+      case INVALID_PACKAGE =>\n+        rejection.getInvalidPackage.getDetails\n+      case REASON_NOT_SET =>\n+        \"\"\n+    }\n+  }\n+\n+  private[this] def shouldFailWith(\n+      output: (DamlLogEntry, _),\n+      reason: DamlPackageUploadRejectionEntry.ReasonCase,\n+      msg: String = \"\",\n+  ) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe true\n+    output._1.getPackageUploadRejectionEntry.getReasonCase shouldBe reason\n+    details(output._1.getPackageUploadRejectionEntry) should include(msg)\n+  }\n+\n+  private[this] def shouldSucceed(output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue])) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe false\n+    output._2 shouldBe 'nonEmpty\n+  }\n+\n+  private[this] def shouldSucceedWith(\n+      output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue]),\n+      committedPackages: Set[Ref.PackageId]) = {\n+    shouldSucceed(output)\n+    val archives = output._1.getPackageUploadEntry.getArchivesList\n+    archives.size() shouldBe committedPackages.size\n+    archives.iterator().asScala.map(_.getHash).toSet shouldBe committedPackages.toSet[String]\n+  }\n+\n+  s\"PackageCommitter\" should {\n+    def newCommitter = new CommitterWrapper(ValidationMode.No, PreloadingMode.No)\n+\n+    // Don't need to run those tests for all instance of PackageCommitter."
  },
  {
    "id" : "7ee12e63-7d7d-47fb-961e-e300707b087f",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "40d7f88f-66a2-45b2-a549-aa0e6a5937d4",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n    \"reject duplicate submissions\" in {\r\n```",
        "createdAt" : "2020-10-05T16:02:06Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -3,69 +3,464 @@\n \n package com.daml.ledger.participant.state.kvutils.committer\n \n+import java.util.UUID\n+\n import com.codahale.metrics.MetricRegistry\n-import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlPackageUploadEntry\n-import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.daml_lf_dev.DamlLf\n import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n-import com.daml.lf.engine.Engine\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.ledger.participant.state.kvutils.committer.PackageCommitter._\n+import com.daml.lf.archive.Decode\n+import com.daml.lf.archive.testing.Encode\n+import com.daml.lf.data.Ref\n+import com.daml.lf.engine.{Engine, EngineConfig}\n+import com.daml.lf.language.Ast\n import com.daml.metrics.Metrics\n-import org.scalatest.mockito.MockitoSugar\n-import org.scalatest.{Matchers, WordSpec}\n+import com.google.protobuf.ByteString\n+import org.scalatest.{Matchers, ParallelTestExecution, WordSpec}\n \n-class PackageCommitterSpec extends WordSpec with Matchers with MockitoSugar {\n-  private val metrics = new Metrics(new MetricRegistry)\n-  private val anEmptyResult = DamlPackageUploadEntry.newBuilder\n-    .setSubmissionId(\"an ID\")\n-    .setParticipantId(\"a participant\")\n+import scala.collection.JavaConverters._\n \n-  \"buildLogEntry\" should {\n-    \"set record time in log entry if record time is available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = Some(theRecordTime))\n+class PackageCommitterSpec extends WordSpec with Matchers with ParallelTestExecution {\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+  import com.daml.lf.testing.parser.Implicits._\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe true\n-          actualLogEntry.getRecordTime shouldBe buildTimestamp(theRecordTime)\n-      }\n+  private[this] def encodePackage[P](pkg: Ast.Package) =\n+    Encode.encodeArchive(\n+      defaultParserParameters.defaultPackageId -> pkg,\n+      defaultParserParameters.languageVersion,\n+    )\n+\n+  private[this] val archive1 =\n+    encodePackage(p\"\"\"\n+        metadata ( 'Color' : '0.0.1' )\n+\n+        module Color {\n+          enum Primary = Red | Blue | Green ;\n+        }\n+      \"\"\")\n+  private[this] val (pkgId1, pkg1) = Decode.decodeArchive(archive1)\n+  private[this] val archive2 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'DamlZ' : '0.0.1' )\n+\n+        module DamlZ {\n+          variant Either a b = Left : a | Right : b ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId2, pkg2) = Decode.decodeArchive(archive2)\n+  private[this] val archive3 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'Quantum' : '0.0.1' )\n+\n+        module Chromodynamics {\n+          record Charge = { value: '${pkgId1}':Color:Primary } ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId3, _) = Decode.decodeArchive(archive3)\n+\n+  private[this] val archive4 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'IllTyped' : '0.0.1' )\n+\n+        module Wrong {\n+          val i: Numeric 10 = 1;  // 1 is an Int64 is not a Numeric\n+        }\n+      \"\"\"\n+    )\n+\n+  private[this] val participantId = Ref.ParticipantId.assertFromString(\"participant\")\n+\n+  private[this] class CommitterWrapper(\n+      validationMode: ValidationMode,\n+      preloadingMode: PreloadingMode,\n+  ) {\n+    val metrics = new Metrics(new MetricRegistry)\n+    var engine: Engine = _\n+    var packageCommitter: PackageCommitter = _\n+    var state = Map.empty[DamlStateKey, DamlStateValue]\n+    restart()\n+\n+    // simulate restart of the participant node\n+    def restart() = this.synchronized {\n+      engine = new Engine(EngineConfig.Dev.copy(packageValidation = false))\n+      packageCommitter = new PackageCommitter(engine, metrics, validationMode, preloadingMode)\n+    }\n+\n+    def submit(submission: DamlSubmission) = {\n+      val result @ (log2, output1) =\n+        packageCommitter.run(\n+          Some(com.daml.lf.data.Time.Timestamp.now()),\n+          submission,\n+          participantId,\n+          wrapMap(state))\n+      if (log2.hasPackageUploadRejectionEntry)\n+        assert(output1.isEmpty)\n+      else\n+        state ++= output1\n+      result\n+    }\n+  }\n+\n+  private[this] def buildSubmission(archives: DamlLf.Archive*) =\n+    DamlSubmission\n+      .newBuilder()\n+      .setPackageUploadEntry(\n+        DamlPackageUploadEntry\n+          .newBuilder()\n+          .setSubmissionId(UUID.randomUUID().toString)\n+          .setParticipantId(participantId)\n+          .addAllArchives(archives.asJava)\n+      )\n+      .build()\n+\n+  private[this] def wrapMap[K, V](m: Map[K, V]): Map[K, Option[V]] = new Map[K, Option[V]] {\n+    override def +[V1 >: Option[V]](kv: (K, V1)): Map[K, V1] = ???\n+    override def get(key: K): Option[Option[V]] = Some(m.get(key))\n+    override def iterator: Iterator[(K, Option[V])] = ???\n+    override def -(key: K): Map[K, Option[V]] = ???\n+  }\n+\n+  private[this] val emptyState = wrapMap(Map.empty[DamlStateKey, DamlStateValue])\n+\n+  private[this] def details(rejection: DamlPackageUploadRejectionEntry) = {\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+    rejection.getReasonCase match {\n+      case PARTICIPANT_NOT_AUTHORIZED =>\n+        rejection.getParticipantNotAuthorized.getDetails\n+      case DUPLICATE_SUBMISSION =>\n+        rejection.getDuplicateSubmission.getDetails\n+      case INVALID_PACKAGE =>\n+        rejection.getInvalidPackage.getDetails\n+      case REASON_NOT_SET =>\n+        \"\"\n+    }\n+  }\n+\n+  private[this] def shouldFailWith(\n+      output: (DamlLogEntry, _),\n+      reason: DamlPackageUploadRejectionEntry.ReasonCase,\n+      msg: String = \"\",\n+  ) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe true\n+    output._1.getPackageUploadRejectionEntry.getReasonCase shouldBe reason\n+    details(output._1.getPackageUploadRejectionEntry) should include(msg)\n+  }\n+\n+  private[this] def shouldSucceed(output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue])) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe false\n+    output._2 shouldBe 'nonEmpty\n+  }\n+\n+  private[this] def shouldSucceedWith(\n+      output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue]),\n+      committedPackages: Set[Ref.PackageId]) = {\n+    shouldSucceed(output)\n+    val archives = output._1.getPackageUploadEntry.getArchivesList\n+    archives.size() shouldBe committedPackages.size\n+    archives.iterator().asScala.map(_.getHash).toSet shouldBe committedPackages.toSet[String]\n+  }\n+\n+  s\"PackageCommitter\" should {\n+    def newCommitter = new CommitterWrapper(ValidationMode.No, PreloadingMode.No)\n+\n+    // Don't need to run those tests for all instance of PackageCommitter.\n+    \"set record time in log entry if record time is available\" in {\n+      val submission1 = buildSubmission(archive1)\n+      val output = newCommitter.packageCommitter.run(\n+        Some(theRecordTime),\n+        submission1,\n+        participantId,\n+        emptyState)\n+      shouldSucceed(output)\n+      output._1.hasRecordTime shouldBe true\n+      output._1.getRecordTime shouldBe buildTimestamp(theRecordTime)\n     }\n \n     \"skip setting record time in log entry when it is not available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = None)\n+      val submission1 = buildSubmission(archive1)\n+      val output = newCommitter.packageCommitter.run(None, submission1, participantId, emptyState)\n+      shouldSucceed(output)\n+      output._1.hasRecordTime shouldBe false\n+    }\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+    \"filter out known packages\" in {\n+      val committer = newCommitter\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe false\n-      }\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1)), Set(pkgId1))\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1)), Set.empty)\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1, archive2)), Set(pkgId2))\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1, archive2)), Set.empty)\n+    }\n+  }\n+\n+  private[this] def lenientValidationTests(newCommitter: => CommitterWrapper) = {\n+\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+\n+    \"accept proper submissions\" in {\n+      shouldSucceedWith(newCommitter.submit(buildSubmission(archive1)), Set(pkgId1))\n+      shouldSucceedWith(\n+        newCommitter.submit(buildSubmission(archive1, archive2)),\n+        Set(pkgId1, pkgId2),\n+      )\n+    }\n+\n+    \"reject non authorize submissions\" in {\n+      val committer = newCommitter\n+\n+      val submission1 = buildSubmission(archive1)\n+      val output = committer.packageCommitter.run(\n+        None,\n+        submission1,\n+        Ref.ParticipantId.assertFromString(\"authorizedParticipant\"),\n+        emptyState,\n+      )\n+      shouldFailWith(output, PARTICIPANT_NOT_AUTHORIZED)\n+    }\n+\n+    \"reject double submissions\" in {"
  },
  {
    "id" : "bb6a03d7-feb3-4ea1-ba61-57cf795b9780",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "1281e348-ebbe-462e-b53c-e4c678e5c3e9",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Can you name these archives so that the name describes e.g. what test case they represent, please? I.e., it's hard to follow tests referring to numbered variables with a generic name. If these archives don't need to be distinct then let's generate them using a simple loop.",
        "createdAt" : "2020-10-05T16:04:35Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2342a722-c2f9-45ee-b85d-012627439b83",
        "parentId" : "1281e348-ebbe-462e-b53c-e4c678e5c3e9",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2020-10-06T07:40:42Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -3,69 +3,464 @@\n \n package com.daml.ledger.participant.state.kvutils.committer\n \n+import java.util.UUID\n+\n import com.codahale.metrics.MetricRegistry\n-import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlPackageUploadEntry\n-import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.daml_lf_dev.DamlLf\n import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n-import com.daml.lf.engine.Engine\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.ledger.participant.state.kvutils.committer.PackageCommitter._\n+import com.daml.lf.archive.Decode\n+import com.daml.lf.archive.testing.Encode\n+import com.daml.lf.data.Ref\n+import com.daml.lf.engine.{Engine, EngineConfig}\n+import com.daml.lf.language.Ast\n import com.daml.metrics.Metrics\n-import org.scalatest.mockito.MockitoSugar\n-import org.scalatest.{Matchers, WordSpec}\n+import com.google.protobuf.ByteString\n+import org.scalatest.{Matchers, ParallelTestExecution, WordSpec}\n \n-class PackageCommitterSpec extends WordSpec with Matchers with MockitoSugar {\n-  private val metrics = new Metrics(new MetricRegistry)\n-  private val anEmptyResult = DamlPackageUploadEntry.newBuilder\n-    .setSubmissionId(\"an ID\")\n-    .setParticipantId(\"a participant\")\n+import scala.collection.JavaConverters._\n \n-  \"buildLogEntry\" should {\n-    \"set record time in log entry if record time is available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = Some(theRecordTime))\n+class PackageCommitterSpec extends WordSpec with Matchers with ParallelTestExecution {\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+  import com.daml.lf.testing.parser.Implicits._\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe true\n-          actualLogEntry.getRecordTime shouldBe buildTimestamp(theRecordTime)\n-      }\n+  private[this] def encodePackage[P](pkg: Ast.Package) =\n+    Encode.encodeArchive(\n+      defaultParserParameters.defaultPackageId -> pkg,\n+      defaultParserParameters.languageVersion,\n+    )\n+\n+  private[this] val archive1 ="
  },
  {
    "id" : "67b9cb6f-0983-43af-9e99-d1925076f0af",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "d6ac6240-0c86-4b8e-bc8b-3d63af1faee6",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n    \"reject not authorized submissions\" in {\r\n```",
        "createdAt" : "2020-10-05T16:05:20Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -3,69 +3,464 @@\n \n package com.daml.ledger.participant.state.kvutils.committer\n \n+import java.util.UUID\n+\n import com.codahale.metrics.MetricRegistry\n-import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlPackageUploadEntry\n-import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.daml_lf_dev.DamlLf\n import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n-import com.daml.lf.engine.Engine\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.ledger.participant.state.kvutils.committer.PackageCommitter._\n+import com.daml.lf.archive.Decode\n+import com.daml.lf.archive.testing.Encode\n+import com.daml.lf.data.Ref\n+import com.daml.lf.engine.{Engine, EngineConfig}\n+import com.daml.lf.language.Ast\n import com.daml.metrics.Metrics\n-import org.scalatest.mockito.MockitoSugar\n-import org.scalatest.{Matchers, WordSpec}\n+import com.google.protobuf.ByteString\n+import org.scalatest.{Matchers, ParallelTestExecution, WordSpec}\n \n-class PackageCommitterSpec extends WordSpec with Matchers with MockitoSugar {\n-  private val metrics = new Metrics(new MetricRegistry)\n-  private val anEmptyResult = DamlPackageUploadEntry.newBuilder\n-    .setSubmissionId(\"an ID\")\n-    .setParticipantId(\"a participant\")\n+import scala.collection.JavaConverters._\n \n-  \"buildLogEntry\" should {\n-    \"set record time in log entry if record time is available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = Some(theRecordTime))\n+class PackageCommitterSpec extends WordSpec with Matchers with ParallelTestExecution {\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+  import com.daml.lf.testing.parser.Implicits._\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe true\n-          actualLogEntry.getRecordTime shouldBe buildTimestamp(theRecordTime)\n-      }\n+  private[this] def encodePackage[P](pkg: Ast.Package) =\n+    Encode.encodeArchive(\n+      defaultParserParameters.defaultPackageId -> pkg,\n+      defaultParserParameters.languageVersion,\n+    )\n+\n+  private[this] val archive1 =\n+    encodePackage(p\"\"\"\n+        metadata ( 'Color' : '0.0.1' )\n+\n+        module Color {\n+          enum Primary = Red | Blue | Green ;\n+        }\n+      \"\"\")\n+  private[this] val (pkgId1, pkg1) = Decode.decodeArchive(archive1)\n+  private[this] val archive2 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'DamlZ' : '0.0.1' )\n+\n+        module DamlZ {\n+          variant Either a b = Left : a | Right : b ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId2, pkg2) = Decode.decodeArchive(archive2)\n+  private[this] val archive3 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'Quantum' : '0.0.1' )\n+\n+        module Chromodynamics {\n+          record Charge = { value: '${pkgId1}':Color:Primary } ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId3, _) = Decode.decodeArchive(archive3)\n+\n+  private[this] val archive4 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'IllTyped' : '0.0.1' )\n+\n+        module Wrong {\n+          val i: Numeric 10 = 1;  // 1 is an Int64 is not a Numeric\n+        }\n+      \"\"\"\n+    )\n+\n+  private[this] val participantId = Ref.ParticipantId.assertFromString(\"participant\")\n+\n+  private[this] class CommitterWrapper(\n+      validationMode: ValidationMode,\n+      preloadingMode: PreloadingMode,\n+  ) {\n+    val metrics = new Metrics(new MetricRegistry)\n+    var engine: Engine = _\n+    var packageCommitter: PackageCommitter = _\n+    var state = Map.empty[DamlStateKey, DamlStateValue]\n+    restart()\n+\n+    // simulate restart of the participant node\n+    def restart() = this.synchronized {\n+      engine = new Engine(EngineConfig.Dev.copy(packageValidation = false))\n+      packageCommitter = new PackageCommitter(engine, metrics, validationMode, preloadingMode)\n+    }\n+\n+    def submit(submission: DamlSubmission) = {\n+      val result @ (log2, output1) =\n+        packageCommitter.run(\n+          Some(com.daml.lf.data.Time.Timestamp.now()),\n+          submission,\n+          participantId,\n+          wrapMap(state))\n+      if (log2.hasPackageUploadRejectionEntry)\n+        assert(output1.isEmpty)\n+      else\n+        state ++= output1\n+      result\n+    }\n+  }\n+\n+  private[this] def buildSubmission(archives: DamlLf.Archive*) =\n+    DamlSubmission\n+      .newBuilder()\n+      .setPackageUploadEntry(\n+        DamlPackageUploadEntry\n+          .newBuilder()\n+          .setSubmissionId(UUID.randomUUID().toString)\n+          .setParticipantId(participantId)\n+          .addAllArchives(archives.asJava)\n+      )\n+      .build()\n+\n+  private[this] def wrapMap[K, V](m: Map[K, V]): Map[K, Option[V]] = new Map[K, Option[V]] {\n+    override def +[V1 >: Option[V]](kv: (K, V1)): Map[K, V1] = ???\n+    override def get(key: K): Option[Option[V]] = Some(m.get(key))\n+    override def iterator: Iterator[(K, Option[V])] = ???\n+    override def -(key: K): Map[K, Option[V]] = ???\n+  }\n+\n+  private[this] val emptyState = wrapMap(Map.empty[DamlStateKey, DamlStateValue])\n+\n+  private[this] def details(rejection: DamlPackageUploadRejectionEntry) = {\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+    rejection.getReasonCase match {\n+      case PARTICIPANT_NOT_AUTHORIZED =>\n+        rejection.getParticipantNotAuthorized.getDetails\n+      case DUPLICATE_SUBMISSION =>\n+        rejection.getDuplicateSubmission.getDetails\n+      case INVALID_PACKAGE =>\n+        rejection.getInvalidPackage.getDetails\n+      case REASON_NOT_SET =>\n+        \"\"\n+    }\n+  }\n+\n+  private[this] def shouldFailWith(\n+      output: (DamlLogEntry, _),\n+      reason: DamlPackageUploadRejectionEntry.ReasonCase,\n+      msg: String = \"\",\n+  ) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe true\n+    output._1.getPackageUploadRejectionEntry.getReasonCase shouldBe reason\n+    details(output._1.getPackageUploadRejectionEntry) should include(msg)\n+  }\n+\n+  private[this] def shouldSucceed(output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue])) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe false\n+    output._2 shouldBe 'nonEmpty\n+  }\n+\n+  private[this] def shouldSucceedWith(\n+      output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue]),\n+      committedPackages: Set[Ref.PackageId]) = {\n+    shouldSucceed(output)\n+    val archives = output._1.getPackageUploadEntry.getArchivesList\n+    archives.size() shouldBe committedPackages.size\n+    archives.iterator().asScala.map(_.getHash).toSet shouldBe committedPackages.toSet[String]\n+  }\n+\n+  s\"PackageCommitter\" should {\n+    def newCommitter = new CommitterWrapper(ValidationMode.No, PreloadingMode.No)\n+\n+    // Don't need to run those tests for all instance of PackageCommitter.\n+    \"set record time in log entry if record time is available\" in {\n+      val submission1 = buildSubmission(archive1)\n+      val output = newCommitter.packageCommitter.run(\n+        Some(theRecordTime),\n+        submission1,\n+        participantId,\n+        emptyState)\n+      shouldSucceed(output)\n+      output._1.hasRecordTime shouldBe true\n+      output._1.getRecordTime shouldBe buildTimestamp(theRecordTime)\n     }\n \n     \"skip setting record time in log entry when it is not available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = None)\n+      val submission1 = buildSubmission(archive1)\n+      val output = newCommitter.packageCommitter.run(None, submission1, participantId, emptyState)\n+      shouldSucceed(output)\n+      output._1.hasRecordTime shouldBe false\n+    }\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+    \"filter out known packages\" in {\n+      val committer = newCommitter\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe false\n-      }\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1)), Set(pkgId1))\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1)), Set.empty)\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1, archive2)), Set(pkgId2))\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1, archive2)), Set.empty)\n+    }\n+  }\n+\n+  private[this] def lenientValidationTests(newCommitter: => CommitterWrapper) = {\n+\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+\n+    \"accept proper submissions\" in {\n+      shouldSucceedWith(newCommitter.submit(buildSubmission(archive1)), Set(pkgId1))\n+      shouldSucceedWith(\n+        newCommitter.submit(buildSubmission(archive1, archive2)),\n+        Set(pkgId1, pkgId2),\n+      )\n+    }\n+\n+    \"reject non authorize submissions\" in {"
  },
  {
    "id" : "2d1eab5d-7188-4e1e-bb81-ade855a5ee2b",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "4bc51987-217d-4391-bab4-576f615f30c5",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "```suggestion\r\n        s\"$pkgId1 appears more than once\",\r\n```",
        "createdAt" : "2020-10-05T16:05:56Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -3,69 +3,464 @@\n \n package com.daml.ledger.participant.state.kvutils.committer\n \n+import java.util.UUID\n+\n import com.codahale.metrics.MetricRegistry\n-import com.daml.ledger.participant.state.kvutils.DamlKvutils.DamlPackageUploadEntry\n-import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.daml_lf_dev.DamlLf\n import com.daml.ledger.participant.state.kvutils.Conversions.buildTimestamp\n-import com.daml.lf.engine.Engine\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils._\n+import com.daml.ledger.participant.state.kvutils.TestHelpers._\n+import com.daml.ledger.participant.state.kvutils.committer.PackageCommitter._\n+import com.daml.lf.archive.Decode\n+import com.daml.lf.archive.testing.Encode\n+import com.daml.lf.data.Ref\n+import com.daml.lf.engine.{Engine, EngineConfig}\n+import com.daml.lf.language.Ast\n import com.daml.metrics.Metrics\n-import org.scalatest.mockito.MockitoSugar\n-import org.scalatest.{Matchers, WordSpec}\n+import com.google.protobuf.ByteString\n+import org.scalatest.{Matchers, ParallelTestExecution, WordSpec}\n \n-class PackageCommitterSpec extends WordSpec with Matchers with MockitoSugar {\n-  private val metrics = new Metrics(new MetricRegistry)\n-  private val anEmptyResult = DamlPackageUploadEntry.newBuilder\n-    .setSubmissionId(\"an ID\")\n-    .setParticipantId(\"a participant\")\n+import scala.collection.JavaConverters._\n \n-  \"buildLogEntry\" should {\n-    \"set record time in log entry if record time is available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = Some(theRecordTime))\n+class PackageCommitterSpec extends WordSpec with Matchers with ParallelTestExecution {\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+  import com.daml.lf.testing.parser.Implicits._\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe true\n-          actualLogEntry.getRecordTime shouldBe buildTimestamp(theRecordTime)\n-      }\n+  private[this] def encodePackage[P](pkg: Ast.Package) =\n+    Encode.encodeArchive(\n+      defaultParserParameters.defaultPackageId -> pkg,\n+      defaultParserParameters.languageVersion,\n+    )\n+\n+  private[this] val archive1 =\n+    encodePackage(p\"\"\"\n+        metadata ( 'Color' : '0.0.1' )\n+\n+        module Color {\n+          enum Primary = Red | Blue | Green ;\n+        }\n+      \"\"\")\n+  private[this] val (pkgId1, pkg1) = Decode.decodeArchive(archive1)\n+  private[this] val archive2 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'DamlZ' : '0.0.1' )\n+\n+        module DamlZ {\n+          variant Either a b = Left : a | Right : b ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId2, pkg2) = Decode.decodeArchive(archive2)\n+  private[this] val archive3 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'Quantum' : '0.0.1' )\n+\n+        module Chromodynamics {\n+          record Charge = { value: '${pkgId1}':Color:Primary } ;\n+        }\n+      \"\"\"\n+    )\n+  private[this] val (pkgId3, _) = Decode.decodeArchive(archive3)\n+\n+  private[this] val archive4 =\n+    encodePackage(\n+      p\"\"\"\n+        metadata ( 'IllTyped' : '0.0.1' )\n+\n+        module Wrong {\n+          val i: Numeric 10 = 1;  // 1 is an Int64 is not a Numeric\n+        }\n+      \"\"\"\n+    )\n+\n+  private[this] val participantId = Ref.ParticipantId.assertFromString(\"participant\")\n+\n+  private[this] class CommitterWrapper(\n+      validationMode: ValidationMode,\n+      preloadingMode: PreloadingMode,\n+  ) {\n+    val metrics = new Metrics(new MetricRegistry)\n+    var engine: Engine = _\n+    var packageCommitter: PackageCommitter = _\n+    var state = Map.empty[DamlStateKey, DamlStateValue]\n+    restart()\n+\n+    // simulate restart of the participant node\n+    def restart() = this.synchronized {\n+      engine = new Engine(EngineConfig.Dev.copy(packageValidation = false))\n+      packageCommitter = new PackageCommitter(engine, metrics, validationMode, preloadingMode)\n+    }\n+\n+    def submit(submission: DamlSubmission) = {\n+      val result @ (log2, output1) =\n+        packageCommitter.run(\n+          Some(com.daml.lf.data.Time.Timestamp.now()),\n+          submission,\n+          participantId,\n+          wrapMap(state))\n+      if (log2.hasPackageUploadRejectionEntry)\n+        assert(output1.isEmpty)\n+      else\n+        state ++= output1\n+      result\n+    }\n+  }\n+\n+  private[this] def buildSubmission(archives: DamlLf.Archive*) =\n+    DamlSubmission\n+      .newBuilder()\n+      .setPackageUploadEntry(\n+        DamlPackageUploadEntry\n+          .newBuilder()\n+          .setSubmissionId(UUID.randomUUID().toString)\n+          .setParticipantId(participantId)\n+          .addAllArchives(archives.asJava)\n+      )\n+      .build()\n+\n+  private[this] def wrapMap[K, V](m: Map[K, V]): Map[K, Option[V]] = new Map[K, Option[V]] {\n+    override def +[V1 >: Option[V]](kv: (K, V1)): Map[K, V1] = ???\n+    override def get(key: K): Option[Option[V]] = Some(m.get(key))\n+    override def iterator: Iterator[(K, Option[V])] = ???\n+    override def -(key: K): Map[K, Option[V]] = ???\n+  }\n+\n+  private[this] val emptyState = wrapMap(Map.empty[DamlStateKey, DamlStateValue])\n+\n+  private[this] def details(rejection: DamlPackageUploadRejectionEntry) = {\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+    rejection.getReasonCase match {\n+      case PARTICIPANT_NOT_AUTHORIZED =>\n+        rejection.getParticipantNotAuthorized.getDetails\n+      case DUPLICATE_SUBMISSION =>\n+        rejection.getDuplicateSubmission.getDetails\n+      case INVALID_PACKAGE =>\n+        rejection.getInvalidPackage.getDetails\n+      case REASON_NOT_SET =>\n+        \"\"\n+    }\n+  }\n+\n+  private[this] def shouldFailWith(\n+      output: (DamlLogEntry, _),\n+      reason: DamlPackageUploadRejectionEntry.ReasonCase,\n+      msg: String = \"\",\n+  ) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe true\n+    output._1.getPackageUploadRejectionEntry.getReasonCase shouldBe reason\n+    details(output._1.getPackageUploadRejectionEntry) should include(msg)\n+  }\n+\n+  private[this] def shouldSucceed(output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue])) = {\n+    output._1.hasPackageUploadRejectionEntry shouldBe false\n+    output._2 shouldBe 'nonEmpty\n+  }\n+\n+  private[this] def shouldSucceedWith(\n+      output: (DamlLogEntry, Map[DamlStateKey, DamlStateValue]),\n+      committedPackages: Set[Ref.PackageId]) = {\n+    shouldSucceed(output)\n+    val archives = output._1.getPackageUploadEntry.getArchivesList\n+    archives.size() shouldBe committedPackages.size\n+    archives.iterator().asScala.map(_.getHash).toSet shouldBe committedPackages.toSet[String]\n+  }\n+\n+  s\"PackageCommitter\" should {\n+    def newCommitter = new CommitterWrapper(ValidationMode.No, PreloadingMode.No)\n+\n+    // Don't need to run those tests for all instance of PackageCommitter.\n+    \"set record time in log entry if record time is available\" in {\n+      val submission1 = buildSubmission(archive1)\n+      val output = newCommitter.packageCommitter.run(\n+        Some(theRecordTime),\n+        submission1,\n+        participantId,\n+        emptyState)\n+      shouldSucceed(output)\n+      output._1.hasRecordTime shouldBe true\n+      output._1.getRecordTime shouldBe buildTimestamp(theRecordTime)\n     }\n \n     \"skip setting record time in log entry when it is not available\" in {\n-      val instance = new PackageCommitter(mock[Engine], metrics)\n-      val context = new FakeCommitContext(recordTime = None)\n+      val submission1 = buildSubmission(archive1)\n+      val output = newCommitter.packageCommitter.run(None, submission1, participantId, emptyState)\n+      shouldSucceed(output)\n+      output._1.hasRecordTime shouldBe false\n+    }\n \n-      val actual = instance.buildLogEntry(context, anEmptyResult)\n+    \"filter out known packages\" in {\n+      val committer = newCommitter\n \n-      actual match {\n-        case StepContinue(_) => fail\n-        case StepStop(actualLogEntry) =>\n-          actualLogEntry.hasRecordTime shouldBe false\n-      }\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1)), Set(pkgId1))\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1)), Set.empty)\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1, archive2)), Set(pkgId2))\n+      shouldSucceedWith(committer.submit(buildSubmission(archive1, archive2)), Set.empty)\n+    }\n+  }\n+\n+  private[this] def lenientValidationTests(newCommitter: => CommitterWrapper) = {\n+\n+    import DamlPackageUploadRejectionEntry.ReasonCase._\n+\n+    \"accept proper submissions\" in {\n+      shouldSucceedWith(newCommitter.submit(buildSubmission(archive1)), Set(pkgId1))\n+      shouldSucceedWith(\n+        newCommitter.submit(buildSubmission(archive1, archive2)),\n+        Set(pkgId1, pkgId2),\n+      )\n+    }\n+\n+    \"reject non authorize submissions\" in {\n+      val committer = newCommitter\n+\n+      val submission1 = buildSubmission(archive1)\n+      val output = committer.packageCommitter.run(\n+        None,\n+        submission1,\n+        Ref.ParticipantId.assertFromString(\"authorizedParticipant\"),\n+        emptyState,\n+      )\n+      shouldFailWith(output, PARTICIPANT_NOT_AUTHORIZED)\n+    }\n+\n+    \"reject double submissions\" in {\n+      val committer = newCommitter\n+\n+      val submission = buildSubmission(archive1)\n+      shouldSucceed(committer.submit(submission))\n+\n+      shouldFailWith(committer.submit(submission), DUPLICATE_SUBMISSION)\n+    }\n+\n+    \"reject empty submissions\" in\n+      shouldFailWith(\n+        newCommitter.submit(buildSubmission()),\n+        INVALID_PACKAGE,\n+        \"No archives in submission\",\n+      )\n+\n+    \"reject submissions containing repeated packages\" in {\n+      val committer = newCommitter\n+      val submission1 = buildSubmission(archive1, archive2, archive1, archive3)\n+\n+      // when archive1 is unknown\n+      shouldFailWith(\n+        committer.submit(submission1),\n+        INVALID_PACKAGE,\n+        s\"${pkgId1} appears more than once\","
  }
]