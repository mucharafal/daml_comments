[
  {
    "id" : "c0f10ee8-4888-47a8-803d-51673fcb86a2",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "d4485f28-983f-43ec-a0ee-fe1d2203e130",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "The previous semantics were setting the dispatcher's new head to the last index (see `appendEntry`); it gets the size _before_ appending. This sets it to the size _after_ appending. You'll either need to redo everything to make sure this is consistent, or set this to `log.size - 1`.",
        "createdAt" : "2020-05-20T07:18:02Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "51a8f64c-9a1b-4aff-adf9-f5166724dd73",
        "parentId" : "d4485f28-983f-43ec-a0ee-fe1d2203e130",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Good catch -- changed accordingly.",
        "createdAt" : "2020-05-20T09:14:52Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : null,
    "diffHunk" : "@@ -16,17 +17,22 @@ import scala.concurrent.{ExecutionContext, Future}\n \n private[memory] class InMemoryState private (log: MutableLog, state: MutableState) {\n   private val lockCurrentState = new Semaphore(1, true)\n+  private val lastLogEntry = new AtomicInteger()\n \n   def readLog[A](action: ImmutableLog => A): A =\n     action(log) // `log` is mutable, but the interface is immutable\n \n+  def logSize(): Int = lastLogEntry.get()\n+\n   def write[A](action: (MutableLog, MutableState) => Future[A])(\n       implicit executionContext: ExecutionContext\n   ): Future[A] = {\n     lockCurrentState.acquire()\n     action(log, state)\n       .andThen {\n-        case _ => lockCurrentState.release()\n+        case _ =>\n+          lastLogEntry.set(log.size)"
  },
  {
    "id" : "17958096-a678-4759-8f9d-0c11b2a69c6f",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "bfcaa590-e27a-4765-a043-e6b5578c53a8",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "This should be performed in a Future as well.",
        "createdAt" : "2020-05-20T15:51:33Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "afbb0c91-fa9e-45fe-944a-199b1553c7b4",
        "parentId" : "bfcaa590-e27a-4765-a043-e6b5578c53a8",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Why?",
        "createdAt" : "2020-05-25T09:59:03Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "11ad68af-2d1c-4572-a0ab-ab523844f924",
        "parentId" : "bfcaa590-e27a-4765-a043-e6b5578c53a8",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Because you want to lock as close as possible (in time) to the actual task using the lock (ideally at beginning of the task's CPU lease, if at all possible, not in this case) and not synchronously upon call when building the task.",
        "createdAt" : "2020-05-25T12:24:33Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cdce5486-1101-43d7-855b-5b699481fbaa",
        "parentId" : "bfcaa590-e27a-4765-a043-e6b5578c53a8",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Already changed this variable to a `volatile`. In case of an `AtomicInteger.get()` call you don't lock but read from a `volatile` variable.",
        "createdAt" : "2020-05-25T13:44:46Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : null,
    "diffHunk" : "@@ -16,17 +17,22 @@ import scala.concurrent.{ExecutionContext, Future}\n \n private[memory] class InMemoryState private (log: MutableLog, state: MutableState) {\n   private val lockCurrentState = new Semaphore(1, true)\n+  private val lastLogEntryIndex = new AtomicInteger()\n \n   def readLog[A](action: ImmutableLog => A): A =\n     action(log) // `log` is mutable, but the interface is immutable\n \n+  def newHeadSinceLastWrite(): Int = lastLogEntryIndex.get()\n+\n   def write[A](action: (MutableLog, MutableState) => Future[A])(\n       implicit executionContext: ExecutionContext\n   ): Future[A] = {\n     lockCurrentState.acquire()"
  },
  {
    "id" : "3a60213f-03c6-4e06-9f44-49a245b6b6fe",
    "prId" : 6004,
    "comments" : [
      {
        "id" : "00ecf39e-c57b-4334-8349-4c85f1a62d77",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Volatile should suffice here, shouldn't it?",
        "createdAt" : "2020-05-20T15:53:30Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5faa3e80-dd5c-4f10-9d90-d847125fb703",
        "parentId" : "00ecf39e-c57b-4334-8349-4c85f1a62d77",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Indeed, that's the simplest solution. Replaced with a `@volatile var` even though seeing `var` in Scala code is not a pleasant sight.",
        "createdAt" : "2020-05-25T09:58:13Z",
        "updatedAt" : "2020-05-25T16:06:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f5039a2c00da681659f3cc8423f9ddfc9d993996",
    "line" : null,
    "diffHunk" : "@@ -16,17 +17,22 @@ import scala.concurrent.{ExecutionContext, Future}\n \n private[memory] class InMemoryState private (log: MutableLog, state: MutableState) {\n   private val lockCurrentState = new Semaphore(1, true)\n+  private val lastLogEntryIndex = new AtomicInteger()"
  },
  {
    "id" : "0f87f2fc-a88b-458d-9205-93a9f0cdc87f",
    "prId" : 4984,
    "comments" : [
      {
        "id" : "7c402d8c-b7d0-41e6-9202-7583bbf45dbc",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I guess it makes sense to use `Bytes` here too?",
        "createdAt" : "2020-03-16T08:28:53Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "df97e2cc-37ed-485b-99b8-1c7f42e4e8c3",
        "parentId" : "7c402d8c-b7d0-41e6-9202-7583bbf45dbc",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Yes, indeed -- changed.",
        "createdAt" : "2020-03-16T10:56:37Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8049c9ebb4015c70e4b3db0344c1e0bdf85699ec",
    "line" : null,
    "diffHunk" : "@@ -50,5 +50,5 @@ object InMemoryState {\n   type MutableState = mutable.Map[StateKey, StateValue] with ImmutableState\n \n   type StateKey = ByteString\n-  type StateValue = Array[Byte]\n+  type StateValue = ByteString"
  },
  {
    "id" : "303c52f4-5a71-4cc2-a8db-aeb936766908",
    "prId" : 4755,
    "comments" : [
      {
        "id" : "87d17ca3-bcb7-404a-80df-2df1eeb41a90",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "This immediately tries to acquire the lock and blocks the current thread. Is this the intention?",
        "createdAt" : "2020-02-28T16:54:56Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cdc27357-e977-4c18-b23d-7a7753b97fc6",
        "parentId" : "87d17ca3-bcb7-404a-80df-2df1eeb41a90",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Yes. If we acquired the lock afterwards, what would be the point?\r\n\r\nAFAIK, this has exactly the same semantics as:\r\n\r\n```\r\n    Future.successful(lockCurrentState.acquire())\r\n      .flatMap(_ => action(log, state))\r\n      .andThen { case _ => lockCurrentState.release() }",
        "createdAt" : "2020-03-02T13:41:28Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3ba0e87f-9f74-40b2-b4a2-f92f4e7f991d",
        "parentId" : "87d17ca3-bcb7-404a-80df-2df1eeb41a90",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Would it make sense to do this inside a `Future { }` block so that acquiring the lock happens in the right execution context?",
        "createdAt" : "2020-03-02T15:01:15Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7e6eb434-f839-43f8-96ac-18972f3d84fa",
        "parentId" : "87d17ca3-bcb7-404a-80df-2df1eeb41a90",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "That's fine, just wanted to check if you are good with immediately blocking the current thread when you call `withFutureWriteLock`.\r\nOf course, didn't want to question whether you need to lock before or after `action` (edited comment).",
        "createdAt" : "2020-03-02T15:01:46Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f9533d06-4718-4cd9-ade3-d5b796f581f7",
        "parentId" : "87d17ca3-bcb7-404a-80df-2df1eeb41a90",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Doesn't really matter; this is not a lock that's bound to a thread, it's a simple semaphore which can be acquired and released from anywhere. The developer is responsible for ensuring that it's not released unless it's acquired.\r\n\r\n@miklos-da, you wrote this code, I just moved it. ðŸ˜‰ ",
        "createdAt" : "2020-03-02T15:03:34Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6d36fdaa30a004657bd518f427ba4d9695681aa0",
    "line" : 37,
    "diffHunk" : "@@ -0,0 +1,54 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.memory\n+\n+import java.util.concurrent.Semaphore\n+\n+import com.daml.ledger.on.memory.InMemoryState._\n+import com.daml.ledger.participant.state.kvutils.api.LedgerEntry\n+import com.google.protobuf.ByteString\n+\n+import scala.collection.mutable\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+private[memory] class InMemoryState(\n+    log: MutableLog = mutable.ArrayBuffer(),\n+    state: MutableState = mutable.Map.empty,\n+) {\n+  private val lockCurrentState = new Semaphore(1, true)\n+\n+  // This only differs in the interface; it uses the same lock and provides the same objects.\n+  def withReadLock[A](action: (ImmutableLog, ImmutableState) => A): A =\n+    withWriteLock(action)\n+\n+  def withWriteLock[A](action: (MutableLog, MutableState) => A): A = {\n+    lockCurrentState.acquire()\n+    try {\n+      action(log, state)\n+    } finally {\n+      lockCurrentState.release()\n+    }\n+  }\n+\n+  def withFutureWriteLock[A](action: (MutableLog, MutableState) => Future[A])(\n+      implicit executionContext: ExecutionContext\n+  ): Future[A] = {\n+    lockCurrentState.acquire()"
  }
]