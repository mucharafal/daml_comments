[
  {
    "id" : "8b735154-e6d0-4de0-a905-289e70a5587b",
    "prId" : 7460,
    "comments" : [
      {
        "id" : "4dd27faa-240f-4695-ad43-bbd7e7bb5674",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Sort please.",
        "createdAt" : "2020-09-23T12:16:00Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0f38a4b6-0eec-4054-8ce9-afa9e1e2ea1c",
        "parentId" : "4dd27faa-240f-4695-ad43-bbd7e7bb5674",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2020-09-24T08:00:19Z",
        "updatedAt" : "2020-10-08T09:30:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a4599bcbf38cacac4088b9b73021b01c997c440",
    "line" : null,
    "diffHunk" : "@@ -17,7 +17,8 @@ import com.daml.ledger.participant.state.kvutils.{\n   Bytes,\n   Fingerprint,\n   FingerprintPlaceholder,\n-  KeyValueCommitting\n+  KeyValueCommitting,\n+  CommitPackageValidationMode"
  },
  {
    "id" : "1a485394-5015-4220-8433-02ec9ca19624",
    "prId" : 7215,
    "comments" : [
      {
        "id" : "5f24e58e-8628-4fee-8b24-82d72066b328",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\nimport com.daml.ledger.participant.state.kvutils.export.LedgerDataExporter\r\n```\r\n\r\nThis doesn't seem to be needed.",
        "createdAt" : "2020-08-25T10:24:27Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "478b4981-8f16-442a-b2fb-86055c506467",
        "parentId" : "5f24e58e-8628-4fee-8b24-82d72066b328",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Just for consistency. I'd like to change the package name to avoid this.",
        "createdAt" : "2020-08-25T11:15:44Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4e95e4d6-f141-4374-9c7c-7d0cdd0a5e65",
        "parentId" : "5f24e58e-8628-4fee-8b24-82d72066b328",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Oh, sorry, I totally misunderstood the comment here. Good catch.",
        "createdAt" : "2020-08-25T11:22:07Z",
        "updatedAt" : "2020-08-25T15:02:13Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0020dd8e089d897ae22c94ce2643c7d7f6073b04",
    "line" : null,
    "diffHunk" : "@@ -11,6 +11,7 @@ import com.daml.caching.Cache\n import com.daml.dec.DirectExecutionContext\n import com.daml.ledger.api.health.{HealthStatus, Healthy}\n import com.daml.ledger.participant.state.kvutils.DamlKvutils.{DamlStateKey, DamlStateValue}\n+import com.daml.ledger.participant.state.kvutils.`export`.LedgerDataExporter"
  },
  {
    "id" : "54ab0e01-0ede-48d3-8523-a9593e9e6a7d",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "e852d146-739b-464f-ae30-38638edb9445",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "If you want to use two different committer implementations I'd suggest injecting a function here instead of defining a trait. It will make the other changes easier as well.",
        "createdAt" : "2020-07-24T15:42:31Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cd370a21-5422-4bde-bfde-67dc3c5556f3",
        "parentId" : "e852d146-739b-464f-ae30-38638edb9445",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-03T16:46:35Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -33,7 +51,7 @@ final class InMemoryLedgerReaderWriter(\n     override val ledgerId: LedgerId,\n     dispatcher: Dispatcher[Index],\n     state: InMemoryState,\n-    committer: BatchedValidatingCommitter[Index],\n+    committer: StateAccessingValidatingCommitter[Index],"
  },
  {
    "id" : "395932bd-8c4d-4ed3-847f-5db836543b48",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "60e1af6e-b2ae-46ce-9153-e913008b3d6d",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Please create two different `Owner` methods for the different execution modes. That should help getting rid of irrelevant parameters when using one vs. the other implementation.",
        "createdAt" : "2020-07-24T15:44:59Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6806363f-cff2-4495-9d62-c74ff981af6e",
        "parentId" : "60e1af6e-b2ae-46ce-9153-e913008b3d6d",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-03T16:46:30Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -116,18 +139,40 @@ object InMemoryLedgerReaderWriter {\n           engine,\n           metrics,\n           inStaticTimeMode = needStaticTimeModeFor(timeProvider))\n-      val validator = BatchedSubmissionValidator[Index](\n-        BatchedSubmissionValidatorFactory.defaultParametersFor(\n-          batchingLedgerWriterConfig.enableBatching),\n-        keyValueCommitting,\n-        new ConflictDetection(metrics),\n-        metrics\n-      )\n-      val committer =\n+"
  },
  {
    "id" : "938a8a08-8f2a-47f8-94a2-6b6fe4ac52cb",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "090f424b-cd5c-44dd-b949-3202ad689b8a",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "To avoid having to prefix log entry IDs another option is to use a different key serialization strategy for pre-execution that prefixes state keys and does not prefix log entries (we already have the support for this).",
        "createdAt" : "2020-07-24T15:46:16Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0058e77c-c988-4ab9-9bef-48b12202b029",
        "parentId" : "090f424b-cd5c-44dd-b949-3202ad689b8a",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Addressed differently.",
        "createdAt" : "2020-08-03T16:46:22Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -116,18 +139,40 @@ object InMemoryLedgerReaderWriter {\n           engine,\n           metrics,\n           inStaticTimeMode = needStaticTimeModeFor(timeProvider))\n-      val validator = BatchedSubmissionValidator[Index](\n-        BatchedSubmissionValidatorFactory.defaultParametersFor(\n-          batchingLedgerWriterConfig.enableBatching),\n-        keyValueCommitting,\n-        new ConflictDetection(metrics),\n-        metrics\n-      )\n-      val committer =\n+\n+      val committer = if (preExecute) {\n+        val keySerializationStrategy = DefaultStateKeySerializationStrategy // TODO check if correct"
  },
  {
    "id" : "5fbf7e4a-e997-44a3-8745-9a569d72ccf8",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "5ed92b14-afee-45f7-ac21-447029cac61f",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You should not need this for a non-pre-executing in-memory ledger. See comment below for a suggested solution.",
        "createdAt" : "2020-07-24T15:47:05Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ccc4dc98-20b6-4cb5-9817-6eed2477c370",
        "parentId" : "5ed92b14-afee-45f7-ac21-447029cac61f",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Removed.",
        "createdAt" : "2020-08-03T16:45:55Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5ba5f01c-8567-49cb-9602-8b3a184e291e",
        "parentId" : "5ed92b14-afee-45f7-ac21-447029cac61f",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "It's still here. Just use the below `*Owner` classes instead of this one, please. The only addition you need is creating the dispatcher and an empty state.",
        "createdAt" : "2020-08-04T09:08:00Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -68,9 +83,12 @@ object InMemoryLedgerReaderWriter {\n   final class SingleParticipantOwner(\n       ledgerId: LedgerId,\n       batchingLedgerWriterConfig: BatchingLedgerWriterConfig,\n+      preExecute: Boolean,\n       participantId: ParticipantId,\n       timeProvider: TimeProvider = DefaultTimeProvider,\n       stateValueCache: Cache[DamlStateKey, DamlStateValue] = Cache.none,\n+      stateValueCacheForPreExecution: Cache[DamlStateKey, (DamlStateValue, Fingerprint)] ="
  },
  {
    "id" : "f5b6b926-c09c-4f74-ac77-31747acd1fe2",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "ba2337ff-da0e-40c8-a307-e18a4f9614f5",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Add the return type here, please.",
        "createdAt" : "2020-08-04T08:50:29Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5a7f0a6e-92dd-412d-aebc-a20355ed2053",
        "parentId" : "ba2337ff-da0e-40c8-a307-e18a4f9614f5",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-04T12:31:02Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -112,41 +145,177 @@ object InMemoryLedgerReaderWriter {\n         implicit executionContext: ExecutionContext\n     ): Resource[KeyValueLedger] = {\n       val keyValueCommitting =\n-        new KeyValueCommitting(\n-          engine,\n-          metrics,\n-          inStaticTimeMode = needStaticTimeModeFor(timeProvider))\n-      val validator = BatchedSubmissionValidator[Index](\n-        BatchedSubmissionValidatorFactory.defaultParametersFor(\n-          batchingLedgerWriterConfig.enableBatching),\n-        keyValueCommitting,\n-        new ConflictDetection(metrics),\n-        metrics\n-      )\n+        createKeyValueCommitting(metrics, timeProvider, engine)\n+\n       val committer =\n-        BatchedValidatingCommitter[Index](\n-          () => timeProvider.getCurrentTime,\n-          validator,\n+        createBatchedCommitter(\n+          keyValueCommitting,\n+          batchingLedgerWriterConfig,\n+          state,\n+          metrics,\n+          timeProvider,\n           stateValueCache)\n+\n       val readerWriter =\n-        new InMemoryLedgerReaderWriter(\n-          participantId,\n+        createInMemoryLedgerReaderWriter(\n           ledgerId,\n+          participantId,\n           dispatcher,\n           state,\n           committer,\n-          metrics\n-        )\n+          metrics)\n+\n       // We need to generate batched submissions for the validator in order to improve throughput.\n       // Hence, we have a BatchingLedgerWriter collect and forward batched submissions to the\n       // in-memory committer.\n-      val batchingLedgerWriter = newLoggingContext { implicit loggingContext =>\n+      val ledgerWriter = newLoggingContext { implicit loggingContext =>\n         BatchingLedgerWriter(batchingLedgerWriterConfig, readerWriter)\n       }\n-      Resource.successful(createKeyValueLedger(readerWriter, batchingLedgerWriter))\n+\n+      Resource.successful(createKeyValueLedger(readerWriter, ledgerWriter))\n+    }\n+  }\n+\n+  final class PreExecutingOwner(\n+      ledgerId: LedgerId,\n+      participantId: ParticipantId,\n+      keySerializationStrategy: StateKeySerializationStrategy,\n+      metrics: Metrics,\n+      timeProvider: TimeProvider = DefaultTimeProvider,\n+      stateValueCacheForPreExecution: Cache[DamlStateKey, (DamlStateValue, Fingerprint)] =\n+        Cache.none,\n+      dispatcher: Dispatcher[Index],\n+      state: InMemoryState,\n+      engine: Engine,\n+  )(implicit materializer: Materializer)\n+      extends ResourceOwner[KeyValueLedger] {\n+    override def acquire()(\n+        implicit executionContext: ExecutionContext): Resource[KeyValueLedger] = {\n+      val keyValueCommitting =\n+        createKeyValueCommitting(metrics, timeProvider, engine)\n+\n+      val committer =\n+        createPreExecutingCommitter(\n+          keyValueCommitting,\n+          keySerializationStrategy,\n+          state,\n+          metrics,\n+          timeProvider,\n+          stateValueCacheForPreExecution)\n+\n+      val readerWriter =\n+        createInMemoryLedgerReaderWriter(\n+          ledgerId,\n+          participantId,\n+          dispatcher,\n+          state,\n+          committer,\n+          metrics)\n+\n+      Resource.successful(createKeyValueLedger(readerWriter, readerWriter))\n     }\n   }\n \n+  private def createBatchedCommitter(\n+      keyValueCommitting: KeyValueCommitting,\n+      batchingLedgerWriterConfig: BatchingLedgerWriterConfig,\n+      state: InMemoryState,\n+      metrics: Metrics,\n+      timeProvider: TimeProvider = DefaultTimeProvider,\n+      stateValueCache: Cache[DamlStateKey, DamlStateValue] = Cache.none,\n+  )(\n+      implicit materializer: Materializer,\n+      executionContext: ExecutionContext,\n+  ): ValidateAndCommit = {\n+    val validator = BatchedSubmissionValidator[Index](\n+      BatchedSubmissionValidatorFactory.defaultParametersFor(\n+        batchingLedgerWriterConfig.enableBatching),\n+      keyValueCommitting,\n+      new ConflictDetection(metrics),\n+      metrics\n+    )\n+    val committer = BatchedValidatingCommitter[Index](\n+      () => timeProvider.getCurrentTime,\n+      validator,\n+      stateValueCache)\n+    def validateAndCommit(\n+        correlationId: String,\n+        submissionEnvelope: Bytes,\n+        submittingParticipantId: ParticipantId) =\n+      new InMemoryLedgerStateAccess(state, metrics).inTransaction { ledgerStateOperations =>\n+        committer\n+          .commit(correlationId, submissionEnvelope, submittingParticipantId, ledgerStateOperations)\n+      }\n+    validateAndCommit\n+  }\n+\n+  private def createPreExecutingCommitter(\n+      keyValueCommitting: KeyValueCommitting,\n+      keySerializationStrategy: StateKeySerializationStrategy,\n+      state: InMemoryState,\n+      metrics: Metrics,\n+      timeProvider: TimeProvider = DefaultTimeProvider,\n+      stateValueCacheForPreExecution: Cache[DamlStateKey, (DamlStateValue, Fingerprint)],\n+  )(\n+      implicit materializer: Materializer,\n+      executionContext: ExecutionContext,\n+  ): ValidateAndCommit = {\n+    val commitStrategy = new LogAppenderPreExecutingCommitStrategy(keySerializationStrategy)\n+    val valueToFingerprint: Option[Value] => Fingerprint =\n+      _.getOrElse(FingerprintPlaceholder)\n+    val validator = new PreExecutingSubmissionValidator[AnnotatedRawKeyValuePairs](\n+      keyValueCommitting,\n+      metrics,\n+      keySerializationStrategy,\n+      commitStrategy)\n+    val committer = new PreExecutingValidatingCommitter(\n+      () => timeProvider.getCurrentTime,\n+      keySerializationStrategy,\n+      validator,\n+      valueToFingerprint,\n+      new PostExecutionFinalizerWithFingerprintsFromValues[Index](valueToFingerprint),\n+      stateValueCache = stateValueCacheForPreExecution,\n+      ImmutablesOnlyCacheUpdatePolicy\n+    )\n+    def validateAndCommit(\n+        correlationId: String,\n+        submissionEnvelope: Bytes,\n+        submittingParticipantId: ParticipantId) =\n+      committer.commit(\n+        correlationId,\n+        submissionEnvelope,\n+        submittingParticipantId,\n+        new InMemoryLedgerStateAccess(state, metrics))\n+    validateAndCommit\n+  }\n+\n+  private def createInMemoryLedgerReaderWriter(\n+      ledgerId: LedgerId,\n+      participantId: ParticipantId,\n+      dispatcher: Dispatcher[Index],\n+      state: InMemoryState,\n+      validateAndCommit: ValidateAndCommit,\n+      metrics: Metrics,\n+  )(\n+      implicit materializer: Materializer,\n+      executionContext: ExecutionContext,\n+  ) ="
  },
  {
    "id" : "390198ca-ef1d-40ad-9237-bbf0a7617385",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "e258e189-b4a1-4393-92b8-c62186ed335a",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Instead of adding separate factory functions you might want to simply add a default constructor to the below `*Owner` classes.",
        "createdAt" : "2020-08-04T09:11:21Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "778bf043-9b45-458e-b66e-a410b4edbf29",
        "parentId" : "e258e189-b4a1-4393-92b8-c62186ed335a",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "The facade single-participant owner was and is actually only used by tests. Removed anyway and inlined in relevant tests.",
        "createdAt" : "2020-08-04T12:30:36Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -68,35 +75,61 @@ object InMemoryLedgerReaderWriter {\n   final class SingleParticipantOwner(\n       ledgerId: LedgerId,\n       batchingLedgerWriterConfig: BatchingLedgerWriterConfig,\n+      preExecute: Boolean,\n       participantId: ParticipantId,\n       timeProvider: TimeProvider = DefaultTimeProvider,\n       stateValueCache: Cache[DamlStateKey, DamlStateValue] = Cache.none,\n+      stateValueCacheForPreExecution: Cache[DamlStateKey, (DamlStateValue, Fingerprint)] =\n+        Cache.none,\n       metrics: Metrics,\n       engine: Engine,\n   )(implicit materializer: Materializer)\n       extends ResourceOwner[KeyValueLedger] {\n+\n     override def acquire()(\n         implicit executionContext: ExecutionContext\n     ): Resource[KeyValueLedger] = {\n       val state = InMemoryState.empty\n       for {\n         dispatcher <- dispatcherOwner.acquire()\n-        readerWriter <- new Owner(\n-          ledgerId,\n-          batchingLedgerWriterConfig,\n-          participantId,\n-          metrics,\n-          timeProvider,\n-          stateValueCache,\n-          dispatcher,\n-          state,\n-          engine\n-        ).acquire()\n+        readerWriter <- (if (preExecute)\n+                           createBatchingOwner(state, dispatcher)\n+                         else\n+                           createPreExecutingOwner(state, dispatcher)).acquire()\n       } yield readerWriter\n     }\n+\n+    private def createPreExecutingOwner("
  },
  {
    "id" : "b7e5fd48-c3de-48d4-99e4-0ceda8172821",
    "prId" : 6793,
    "comments" : [
      {
        "id" : "4533240f-44c2-418a-9a26-89945f69484d",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "This function is unnecessary once you add a factory method (`apply(...)`) to `InMemoryLedgerReaderWriter`.",
        "createdAt" : "2020-08-04T15:53:34Z",
        "updatedAt" : "2020-08-05T07:01:01Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "226b7bdc-26b0-40d3-b29f-2ac30daefd71",
        "parentId" : "4533240f-44c2-418a-9a26-89945f69484d",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-05T07:01:41Z",
        "updatedAt" : "2020-08-05T07:01:41Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b29591138330b767e0e3a5dc19bca73b14d0522c",
    "line" : null,
    "diffHunk" : "@@ -58,95 +63,198 @@ final class InMemoryLedgerReaderWriter(\n   override def currentHealth(): HealthStatus = Healthy\n \n   private val reader = new InMemoryLedgerReader(ledgerId, dispatcher, state, metrics)\n-\n-  private val ledgerStateAccess = new InMemoryLedgerStateAccess(state, metrics)\n }\n \n object InMemoryLedgerReaderWriter {\n   val DefaultTimeProvider: TimeProvider = TimeProvider.UTC\n \n-  final class SingleParticipantOwner(\n+  final class BatchingOwner(\n       ledgerId: LedgerId,\n       batchingLedgerWriterConfig: BatchingLedgerWriterConfig,\n       participantId: ParticipantId,\n+      metrics: Metrics,\n       timeProvider: TimeProvider = DefaultTimeProvider,\n       stateValueCache: Cache[DamlStateKey, DamlStateValue] = Cache.none,\n-      metrics: Metrics,\n+      dispatcher: Dispatcher[Index],\n+      state: InMemoryState,\n       engine: Engine,\n   )(implicit materializer: Materializer)\n       extends ResourceOwner[KeyValueLedger] {\n     override def acquire()(\n         implicit executionContext: ExecutionContext\n     ): Resource[KeyValueLedger] = {\n-      val state = InMemoryState.empty\n-      for {\n-        dispatcher <- dispatcherOwner.acquire()\n-        readerWriter <- new Owner(\n-          ledgerId,\n+      val keyValueCommitting =\n+        createKeyValueCommitting(metrics, timeProvider, engine)\n+\n+      val committer =\n+        createBatchedCommitter(\n+          keyValueCommitting,\n           batchingLedgerWriterConfig,\n-          participantId,\n+          state,\n           metrics,\n           timeProvider,\n-          stateValueCache,\n+          stateValueCache)\n+\n+      val readerWriter =\n+        createInMemoryLedgerReaderWriter(\n+          ledgerId,\n+          participantId,\n           dispatcher,\n           state,\n-          engine\n-        ).acquire()\n-      } yield readerWriter\n+          committer,\n+          metrics)\n+\n+      // We need to generate batched submissions for the validator in order to improve throughput.\n+      // Hence, we have a BatchingLedgerWriter collect and forward batched submissions to the\n+      // in-memory committer.\n+      val ledgerWriter = newLoggingContext { implicit loggingContext =>\n+        BatchingLedgerWriter(batchingLedgerWriterConfig, readerWriter)\n+      }\n+\n+      Resource.successful(createKeyValueLedger(readerWriter, ledgerWriter))\n     }\n   }\n \n-  final class Owner(\n+  final class PreExecutingOwner(\n       ledgerId: LedgerId,\n-      batchingLedgerWriterConfig: BatchingLedgerWriterConfig,\n       participantId: ParticipantId,\n+      keySerializationStrategy: StateKeySerializationStrategy,\n       metrics: Metrics,\n       timeProvider: TimeProvider = DefaultTimeProvider,\n-      stateValueCache: Cache[DamlStateKey, DamlStateValue] = Cache.none,\n+      stateValueCacheForPreExecution: Cache[DamlStateKey, (DamlStateValue, Fingerprint)] =\n+        Cache.none,\n       dispatcher: Dispatcher[Index],\n       state: InMemoryState,\n       engine: Engine,\n   )(implicit materializer: Materializer)\n       extends ResourceOwner[KeyValueLedger] {\n     override def acquire()(\n-        implicit executionContext: ExecutionContext\n-    ): Resource[KeyValueLedger] = {\n+        implicit executionContext: ExecutionContext): Resource[KeyValueLedger] = {\n       val keyValueCommitting =\n-        new KeyValueCommitting(\n-          engine,\n-          metrics,\n-          inStaticTimeMode = needStaticTimeModeFor(timeProvider))\n-      val validator = BatchedSubmissionValidator[Index](\n-        BatchedSubmissionValidatorFactory.defaultParametersFor(\n-          batchingLedgerWriterConfig.enableBatching),\n-        keyValueCommitting,\n-        new ConflictDetection(metrics),\n-        metrics\n-      )\n+        createKeyValueCommitting(metrics, timeProvider, engine)\n+\n       val committer =\n-        BatchedValidatingCommitter[Index](\n-          () => timeProvider.getCurrentTime,\n-          validator,\n-          stateValueCache)\n+        createPreExecutingCommitter(\n+          keyValueCommitting,\n+          keySerializationStrategy,\n+          state,\n+          metrics,\n+          timeProvider,\n+          stateValueCacheForPreExecution)\n+\n       val readerWriter =\n-        new InMemoryLedgerReaderWriter(\n-          participantId,\n+        createInMemoryLedgerReaderWriter(\n           ledgerId,\n+          participantId,\n           dispatcher,\n           state,\n           committer,\n-          metrics\n-        )\n-      // We need to generate batched submissions for the validator in order to improve throughput.\n-      // Hence, we have a BatchingLedgerWriter collect and forward batched submissions to the\n-      // in-memory committer.\n-      val batchingLedgerWriter = newLoggingContext { implicit loggingContext =>\n-        BatchingLedgerWriter(batchingLedgerWriterConfig, readerWriter)\n-      }\n-      Resource.successful(createKeyValueLedger(readerWriter, batchingLedgerWriter))\n+          metrics)\n+\n+      Resource.successful(createKeyValueLedger(readerWriter, readerWriter))\n     }\n   }\n \n+  private def createBatchedCommitter(\n+      keyValueCommitting: KeyValueCommitting,\n+      batchingLedgerWriterConfig: BatchingLedgerWriterConfig,\n+      state: InMemoryState,\n+      metrics: Metrics,\n+      timeProvider: TimeProvider = DefaultTimeProvider,\n+      stateValueCache: Cache[DamlStateKey, DamlStateValue] = Cache.none,\n+  )(\n+      implicit materializer: Materializer,\n+      executionContext: ExecutionContext,\n+  ): ValidateAndCommit = {\n+    val validator = BatchedSubmissionValidator[Index](\n+      BatchedSubmissionValidatorFactory.defaultParametersFor(\n+        batchingLedgerWriterConfig.enableBatching),\n+      keyValueCommitting,\n+      new ConflictDetection(metrics),\n+      metrics\n+    )\n+    val committer = BatchedValidatingCommitter[Index](\n+      () => timeProvider.getCurrentTime,\n+      validator,\n+      stateValueCache)\n+    def validateAndCommit(\n+        correlationId: String,\n+        submissionEnvelope: Bytes,\n+        submittingParticipantId: ParticipantId) =\n+      new InMemoryLedgerStateAccess(state, metrics).inTransaction { ledgerStateOperations =>\n+        committer\n+          .commit(correlationId, submissionEnvelope, submittingParticipantId, ledgerStateOperations)\n+      }\n+    validateAndCommit\n+  }\n+\n+  private def createPreExecutingCommitter(\n+      keyValueCommitting: KeyValueCommitting,\n+      keySerializationStrategy: StateKeySerializationStrategy,\n+      state: InMemoryState,\n+      metrics: Metrics,\n+      timeProvider: TimeProvider = DefaultTimeProvider,\n+      stateValueCacheForPreExecution: Cache[DamlStateKey, (DamlStateValue, Fingerprint)],\n+  )(\n+      implicit materializer: Materializer,\n+      executionContext: ExecutionContext,\n+  ): ValidateAndCommit = {\n+    val commitStrategy = new LogAppenderPreExecutingCommitStrategy(keySerializationStrategy)\n+    val valueToFingerprint: Option[Value] => Fingerprint =\n+      _.getOrElse(FingerprintPlaceholder)\n+    val validator = new PreExecutingSubmissionValidator[RawKeyValuePairsWithLogEntry](\n+      keyValueCommitting,\n+      metrics,\n+      keySerializationStrategy,\n+      commitStrategy)\n+    val committer = new PreExecutingValidatingCommitter(\n+      () => timeProvider.getCurrentTime,\n+      keySerializationStrategy,\n+      validator,\n+      valueToFingerprint,\n+      new PostExecutionFinalizer[Index](valueToFingerprint),\n+      stateValueCache = stateValueCacheForPreExecution,\n+      ImmutablesOnlyCacheUpdatePolicy\n+    )\n+    def validateAndCommit(\n+        correlationId: String,\n+        submissionEnvelope: Bytes,\n+        submittingParticipantId: ParticipantId) =\n+      committer.commit(\n+        correlationId,\n+        submissionEnvelope,\n+        submittingParticipantId,\n+        new InMemoryLedgerStateAccess(state, metrics))\n+    validateAndCommit\n+  }\n+\n+  private def createInMemoryLedgerReaderWriter("
  },
  {
    "id" : "34c86339-80d7-4f6e-87b0-2b027af67d39",
    "prId" : 6711,
    "comments" : [
      {
        "id" : "9e2405fe-0809-4eb3-9824-5b076b31a330",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "How do you plan to switch between the batched and pre-exec validators here?",
        "createdAt" : "2020-07-14T08:48:25Z",
        "updatedAt" : "2020-07-15T08:11:38Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "986d80db-d94b-40fb-9986-a60e54b869c2",
        "parentId" : "9e2405fe-0809-4eb3-9824-5b076b31a330",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "See the design doc, i.e., there will be a facade `LedgerWriter` implementation that will delegate to either batched or pre-executing validators depending on the interpretation cost.",
        "createdAt" : "2020-07-14T10:15:17Z",
        "updatedAt" : "2020-07-15T08:11:38Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c052cfae-2648-4a01-a895-842a9632fe99",
        "parentId" : "9e2405fe-0809-4eb3-9824-5b076b31a330",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Do you plan to prototype this at a later stage then?",
        "createdAt" : "2020-07-14T10:29:33Z",
        "updatedAt" : "2020-07-15T08:11:38Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "765d3f77-4a47-41a8-8d79-68e01bb946af",
        "parentId" : "9e2405fe-0809-4eb3-9824-5b076b31a330",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Yes, I consider this a fairly trivial piece and assume it'll be added as part of a separate PR.",
        "createdAt" : "2020-07-14T10:31:10Z",
        "updatedAt" : "2020-07-15T08:11:38Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e6145fdda1728eb9dd00d6dc94b3e0058872bbb2",
    "line" : 1,
    "diffHunk" : "@@ -126,8 +126,7 @@ object InMemoryLedgerReaderWriter {\n           batchingLedgerWriterConfig.enableBatching),"
  },
  {
    "id" : "0c080f45-56a8-4cfb-8e51-924cfb9ee293",
    "prId" : 6515,
    "comments" : [
      {
        "id" : "353a933e-9bca-482d-914c-905cc5a469e4",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n      metadata: CommitMetadata,\r\n    ): Future[SubmissionResult] =\r\n```",
        "createdAt" : "2020-06-29T07:37:24Z",
        "updatedAt" : "2020-06-30T08:52:03Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5b5d17d48af638f059d785c2d530c2f7d89eec0e",
    "line" : null,
    "diffHunk" : "@@ -40,7 +40,10 @@ final class InMemoryLedgerReaderWriter(\n     metrics: Metrics)(implicit materializer: Materializer, executionContext: ExecutionContext)\n     extends LedgerReader\n     with LedgerWriter {\n-  override def commit(correlationId: String, envelope: Bytes): Future[SubmissionResult] =\n+  override def commit(\n+      correlationId: String,\n+      envelope: Bytes,\n+      metadata: CommitMetadata): Future[SubmissionResult] ="
  },
  {
    "id" : "7194f4d3-a54e-4665-a7a8-cbbcef14b33c",
    "prId" : 5576,
    "comments" : [
      {
        "id" : "de2179a2-c626-4f48-a072-49c36389e243",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "This is a bit unfortunate, thanks for adding the comment.",
        "createdAt" : "2020-04-16T08:37:29Z",
        "updatedAt" : "2020-04-16T10:18:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "467398fe-be14-4df7-973a-55c43783d3d5",
        "parentId" : "de2179a2-c626-4f48-a072-49c36389e243",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I am sad about this too.",
        "createdAt" : "2020-04-16T10:19:11Z",
        "updatedAt" : "2020-04-16T10:19:11Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a6cc46564b5f71316b037986bcf0ce735aa9ce37",
    "line" : 34,
    "diffHunk" : "@@ -59,6 +60,7 @@ final class InMemoryLedgerReaderWriter private (\n   override def commit(correlationId: String, envelope: Bytes): Future[SubmissionResult] =\n     committer.commit(correlationId, envelope, participantId)\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\")) // so we can use `.view`"
  },
  {
    "id" : "74f532bf-2dea-4314-a195-3a7ae4ce20dc",
    "prId" : 5576,
    "comments" : [
      {
        "id" : "f5725106-9969-465a-bbc1-e24fd14d3141",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Thanks!",
        "createdAt" : "2020-04-16T08:38:30Z",
        "updatedAt" : "2020-04-16T10:18:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a6cc46564b5f71316b037986bcf0ce735aa9ce37",
    "line" : 70,
    "diffHunk" : "@@ -67,38 +69,43 @@ final class InMemoryLedgerReaderWriter private (\n           .getOrElse(StartIndex),\n         RangeSource((startExclusive, endInclusive) =>\n           Source.fromIterator(() => {\n-            val entries = state.readLog(_.zipWithIndex.slice(startExclusive + 1, endInclusive + 1))\n-            entries.iterator.map { case (entry, index) => index -> entry }\n+            Timed.value(\n+              Metrics.readLog,\n+              state\n+                .readLog(_.view.zipWithIndex.slice(startExclusive + 1, endInclusive + 1).map {\n+                  case (entry, index) => index -> entry\n+                })\n+                .iterator)\n           }))\n       )\n       .map { case (_, updates) => updates }\n-}\n \n-class InMemoryLedgerStateAccess(currentState: InMemoryState)(\n-    implicit executionContext: ExecutionContext\n-) extends LedgerStateAccess[Index] {\n+  object InMemoryLedgerStateAccess extends LedgerStateAccess[Index] {\n+    override def inTransaction[T](body: LedgerStateOperations[Index] => Future[T]): Future[T] =\n+      state.write { (log, state) =>\n+        body(new InMemoryLedgerStateOperations(log, state))\n+      }\n+  }\n \n-  override def inTransaction[T](body: LedgerStateOperations[Index] => Future[T]): Future[T] =\n-    currentState.write { (log, state) =>\n-      body(new InMemoryLedgerStateOperations(log, state))\n-    }\n-}\n+  private final class InMemoryLedgerStateOperations("
  },
  {
    "id" : "16585bfc-9900-40fd-92ab-59b1d1bba119",
    "prId" : 5576,
    "comments" : [
      {
        "id" : "fa675485-0bc1-498f-8124-3cd6febd49e3",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Uh, well done.",
        "createdAt" : "2020-04-16T08:38:54Z",
        "updatedAt" : "2020-04-16T10:18:53Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c209d0e1-46cd-4fd5-a005-315c4cf41626",
        "parentId" : "fa675485-0bc1-498f-8124-3cd6febd49e3",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "It's just indentation; moved it inside `InMemoryLedgerReaderWriter`.",
        "createdAt" : "2020-04-16T09:35:37Z",
        "updatedAt" : "2020-04-16T10:18:53Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a6cc46564b5f71316b037986bcf0ce735aa9ce37",
    "line" : 80,
    "diffHunk" : "@@ -67,38 +69,43 @@ final class InMemoryLedgerReaderWriter private (\n           .getOrElse(StartIndex),\n         RangeSource((startExclusive, endInclusive) =>\n           Source.fromIterator(() => {\n-            val entries = state.readLog(_.zipWithIndex.slice(startExclusive + 1, endInclusive + 1))\n-            entries.iterator.map { case (entry, index) => index -> entry }\n+            Timed.value(\n+              Metrics.readLog,\n+              state\n+                .readLog(_.view.zipWithIndex.slice(startExclusive + 1, endInclusive + 1).map {\n+                  case (entry, index) => index -> entry\n+                })\n+                .iterator)\n           }))\n       )\n       .map { case (_, updates) => updates }\n-}\n \n-class InMemoryLedgerStateAccess(currentState: InMemoryState)(\n-    implicit executionContext: ExecutionContext\n-) extends LedgerStateAccess[Index] {\n+  object InMemoryLedgerStateAccess extends LedgerStateAccess[Index] {\n+    override def inTransaction[T](body: LedgerStateOperations[Index] => Future[T]): Future[T] =\n+      state.write { (log, state) =>\n+        body(new InMemoryLedgerStateOperations(log, state))\n+      }\n+  }\n \n-  override def inTransaction[T](body: LedgerStateOperations[Index] => Future[T]): Future[T] =\n-    currentState.write { (log, state) =>\n-      body(new InMemoryLedgerStateOperations(log, state))\n-    }\n-}\n+  private final class InMemoryLedgerStateOperations(\n+      log: InMemoryState.MutableLog,\n+      state: InMemoryState.MutableState,\n+  ) extends BatchingLedgerStateOperations[Index] {\n+    override def readState(keys: Seq[Key]): Future[Seq[Option[Value]]] =\n+      Future.successful(keys.map(state.get))\n \n-private class InMemoryLedgerStateOperations(\n-    log: InMemoryState.MutableLog,\n-    state: InMemoryState.MutableState,\n-)(implicit executionContext: ExecutionContext)"
  },
  {
    "id" : "536e7afe-7df1-4547-a984-58f12dd31771",
    "prId" : 5576,
    "comments" : [
      {
        "id" : "f9cd2d97-11e3-4cfe-9a92-d919142622e9",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "If you want to be more concise:\r\n```suggestion\r\n                .readLog(_.view.zipWithIndex.slice(startExclusive + 1, endInclusive + 1).map(_.swap))\r\n```",
        "createdAt" : "2020-04-16T09:58:34Z",
        "updatedAt" : "2020-04-16T10:18:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ba00404a-a031-48c0-aeac-3695de12938a",
        "parentId" : "f9cd2d97-11e3-4cfe-9a92-d919142622e9",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Done. (I didn't want to apply the suggestion because it would fail formatting.)",
        "createdAt" : "2020-04-16T10:19:38Z",
        "updatedAt" : "2020-04-16T10:19:38Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a6cc46564b5f71316b037986bcf0ce735aa9ce37",
    "line" : null,
    "diffHunk" : "@@ -67,38 +69,43 @@ final class InMemoryLedgerReaderWriter private (\n           .getOrElse(StartIndex),\n         RangeSource((startExclusive, endInclusive) =>\n           Source.fromIterator(() => {\n-            val entries = state.readLog(_.zipWithIndex.slice(startExclusive + 1, endInclusive + 1))\n-            entries.iterator.map { case (entry, index) => index -> entry }\n+            Timed.value(\n+              Metrics.readLog,\n+              state\n+                .readLog(_.view.zipWithIndex.slice(startExclusive + 1, endInclusive + 1).map {\n+                  case (entry, index) => index -> entry\n+                })"
  },
  {
    "id" : "67997e5e-db95-4b2c-9cc8-a8e5e1d6df32",
    "prId" : 4755,
    "comments" : [
      {
        "id" : "9798d3b3-b0d8-415a-abdd-5adaf8ca7cb4",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n  // passing the `dispatcher` and `state` from the outside allows us to share\r\n```",
        "createdAt" : "2020-02-28T12:35:45Z",
        "updatedAt" : "2020-03-02T18:11:35Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d36fdaa30a004657bd518f427ba4d9695681aa0",
    "line" : null,
    "diffHunk" : "@@ -167,27 +135,34 @@ object InMemoryLedgerReaderWriter {\n       initialLedgerId: Option[LedgerId],\n       participantId: ParticipantId,\n       timeProvider: TimeProvider = DefaultTimeProvider,\n+      heartbeats: Source[Instant, NotUsed] = Source.empty,\n   )(\n-      implicit executionContext: ExecutionContext,\n+      implicit materializer: Materializer,\n+      executionContext: ExecutionContext,\n       logCtx: LoggingContext,\n-  ): ResourceOwner[InMemoryLedgerReaderWriter] =\n+  ): ResourceOwner[InMemoryLedgerReaderWriter] = {\n+    val state = new InMemoryState\n     for {\n       dispatcher <- dispatcher\n+      _ = publishHeartbeats(state, dispatcher, heartbeats)\n       readerWriter <- owner(\n         initialLedgerId,\n         participantId,\n-        dispatcher = dispatcher,\n-        inMemoryState = new InMemoryState)\n+        timeProvider,\n+        dispatcher,\n+        state,\n+      )\n     } yield readerWriter\n+  }\n \n-  // passing the Dispatcher and InMemoryState from the outside allows us to share\n+  // passing the `dispatcher` and `inMemoryState` from the outside allows us to share"
  },
  {
    "id" : "c2cfff53-245f-41c9-8eda-476891195cc9",
    "prId" : 4674,
    "comments" : [
      {
        "id" : "f8b95d5b-e9e7-490d-89cf-3667a345d163",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Win! But why not inject `InMemoryState` rather than `InMemoryLedgerStateAccess`, and move the lock into that object? `InMemoryLedgerStateAccess` doesn't _feel_ like a public API.",
        "createdAt" : "2020-02-25T12:52:10Z",
        "updatedAt" : "2020-02-26T13:34:02Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "718b1cf4-5cdf-407c-a6b6-114cb830e71f",
        "parentId" : "f8b95d5b-e9e7-490d-89cf-3667a345d163",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Fully agreed -- that's how it's done in the integration kit as well.",
        "createdAt" : "2020-02-25T15:10:35Z",
        "updatedAt" : "2020-02-26T13:34:02Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "678394cc-e990-4a03-9da3-e187b063f2ce",
        "parentId" : "f8b95d5b-e9e7-490d-89cf-3667a345d163",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Thanks, that's a great suggestion.",
        "createdAt" : "2020-02-25T15:58:50Z",
        "updatedAt" : "2020-02-26T13:34:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "357d1c3ef2feb3fb5236e1f22c00afbf960d0ce6",
    "line" : null,
    "diffHunk" : "@@ -46,38 +40,59 @@ private[memory] class InMemoryState(\n     val state: mutable.Map[ByteString, Array[Byte]] = mutable.Map.empty,\n )\n \n+// Dispatcher and LedgerStateAccess are passed in to allow for a multi-participant setup.\n final class InMemoryLedgerReaderWriter(\n     override val ledgerId: LedgerId,\n     override val participantId: ParticipantId,\n     now: () => Instant,\n     dispatcher: Dispatcher[Index],\n+    ledgerStateAccess: InMemoryLedgerStateAccess,"
  },
  {
    "id" : "4c49a7e7-af43-4d45-b283-4174abea6f13",
    "prId" : 4674,
    "comments" : [
      {
        "id" : "506d6bf8-4b0e-435c-86a1-cbe5ecb75574",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "I don't think we need this comment -- your method's naming perfectly tells the purpose.",
        "createdAt" : "2020-02-25T12:59:07Z",
        "updatedAt" : "2020-02-26T13:34:02Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "357d1c3ef2feb3fb5236e1f22c00afbf960d0ce6",
    "line" : null,
    "diffHunk" : "@@ -141,7 +139,17 @@ object InMemoryLedgerReaderWriter {\n \n   private val sequentialLogEntryId = new SequentialLogEntryId(NamespaceLogEntries)\n \n-  def owner(\n+  def dispatcher: ResourceOwner[Dispatcher[Index]] =\n+    ResourceOwner.forCloseable(\n+      () =>\n+        Dispatcher(\n+          \"in-memory-key-value-participant-state\",\n+          zeroIndex = StartIndex,\n+          headAtInitialization = StartIndex,\n+      ))\n+\n+  // convenience method if only a single participant is needed"
  },
  {
    "id" : "861b994b-7a4e-4c2d-86d4-d148b2c18ff5",
    "prId" : 4674,
    "comments" : [
      {
        "id" : "d628a89d-bcb5-406a-be6a-24e101e8c99c",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "If you used the same synchronization primitive as for reading/writing state then you could make `currentState` private and remove `synchronized` blocks when accessing the log. It may make sense to introduce a 'log lock' to gate access to  `currentState.log`.",
        "createdAt" : "2020-02-25T13:06:36Z",
        "updatedAt" : "2020-02-26T13:34:02Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c246e4c1-d5ac-4676-aafe-dd5e4506f582",
        "parentId" : "d628a89d-bcb5-406a-be6a-24e101e8c99c",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I was thinking the same, but wasn't sure.",
        "createdAt" : "2020-02-25T14:24:15Z",
        "updatedAt" : "2020-02-26T13:34:02Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "357d1c3ef2feb3fb5236e1f22c00afbf960d0ce6",
    "line" : null,
    "diffHunk" : "@@ -46,38 +40,59 @@ private[memory] class InMemoryState(\n     val state: mutable.Map[ByteString, Array[Byte]] = mutable.Map.empty,\n )\n \n+// Dispatcher and LedgerStateAccess are passed in to allow for a multi-participant setup.\n final class InMemoryLedgerReaderWriter(\n     override val ledgerId: LedgerId,\n     override val participantId: ParticipantId,\n     now: () => Instant,\n     dispatcher: Dispatcher[Index],\n+    ledgerStateAccess: InMemoryLedgerStateAccess,\n )(\n     implicit executionContext: ExecutionContext,\n     logCtx: LoggingContext,\n ) extends LedgerWriter\n     with LedgerReader {\n \n-  private val currentState = new InMemoryState()\n-\n-  private val lockCurrentState = new Semaphore(1, true)\n-\n   private val committer = new ValidatingCommitter(\n     participantId,\n     now,\n-    SubmissionValidator.create(InMemoryLedgerStateAccess, () => sequentialLogEntryId.next()),\n+    SubmissionValidator.create(ledgerStateAccess, () => sequentialLogEntryId.next()),\n     dispatcher.signalNewHead,\n   )\n \n-  private object InMemoryLedgerStateAccess extends LedgerStateAccess[Index] {\n-    override def inTransaction[T](body: LedgerStateOperations[Index] => Future[T]): Future[T] =\n-      Future\n-        .successful(lockCurrentState.acquire())\n-        .flatMap(_ => body(InMemoryLedgerStateOperations))\n-        .andThen {\n-          case _ =>\n-            lockCurrentState.release()\n-        }\n+  override def currentHealth(): HealthStatus =\n+    Healthy\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    committer.commit(correlationId, envelope)\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartIndex),\n+        OneAfterAnother[Int, List[LedgerRecord]](\n+          (index: Int, _) => index + 1,\n+          (index: Int) => Future.successful(List(retrieveLogEntry(index))),\n+        ),\n+      )\n+      .mapConcat { case (_, updates) => updates }\n+\n+  private def retrieveLogEntry(index: Int): LedgerRecord = {\n+    val logEntry = ledgerStateAccess.currentState.log.synchronized {"
  },
  {
    "id" : "30a42586-9010-4043-9c11-4fc64040a3ff",
    "prId" : 4674,
    "comments" : [
      {
        "id" : "7d7d8811-c9a2-41e5-a9d0-389b9aaf1628",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "`private`",
        "createdAt" : "2020-02-25T13:07:51Z",
        "updatedAt" : "2020-02-26T13:34:02Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "357d1c3ef2feb3fb5236e1f22c00afbf960d0ce6",
    "line" : null,
    "diffHunk" : "@@ -46,38 +40,59 @@ private[memory] class InMemoryState(\n     val state: mutable.Map[ByteString, Array[Byte]] = mutable.Map.empty,\n )\n \n+// Dispatcher and LedgerStateAccess are passed in to allow for a multi-participant setup.\n final class InMemoryLedgerReaderWriter(\n     override val ledgerId: LedgerId,\n     override val participantId: ParticipantId,\n     now: () => Instant,\n     dispatcher: Dispatcher[Index],\n+    ledgerStateAccess: InMemoryLedgerStateAccess,\n )(\n     implicit executionContext: ExecutionContext,\n     logCtx: LoggingContext,\n ) extends LedgerWriter\n     with LedgerReader {\n \n-  private val currentState = new InMemoryState()\n-\n-  private val lockCurrentState = new Semaphore(1, true)\n-\n   private val committer = new ValidatingCommitter(\n     participantId,\n     now,\n-    SubmissionValidator.create(InMemoryLedgerStateAccess, () => sequentialLogEntryId.next()),\n+    SubmissionValidator.create(ledgerStateAccess, () => sequentialLogEntryId.next()),\n     dispatcher.signalNewHead,\n   )\n \n-  private object InMemoryLedgerStateAccess extends LedgerStateAccess[Index] {\n-    override def inTransaction[T](body: LedgerStateOperations[Index] => Future[T]): Future[T] =\n-      Future\n-        .successful(lockCurrentState.acquire())\n-        .flatMap(_ => body(InMemoryLedgerStateOperations))\n-        .andThen {\n-          case _ =>\n-            lockCurrentState.release()\n-        }\n+  override def currentHealth(): HealthStatus =\n+    Healthy\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    committer.commit(correlationId, envelope)\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset\n+          .map(_.components.head.toInt)\n+          .getOrElse(StartIndex),\n+        OneAfterAnother[Int, List[LedgerRecord]](\n+          (index: Int, _) => index + 1,\n+          (index: Int) => Future.successful(List(retrieveLogEntry(index))),\n+        ),\n+      )\n+      .mapConcat { case (_, updates) => updates }\n+\n+  private def retrieveLogEntry(index: Int): LedgerRecord = {\n+    val logEntry = ledgerStateAccess.currentState.log.synchronized {\n+      ledgerStateAccess.currentState.log(index)\n+    }\n+    LedgerRecord(Offset(Array(index.toLong)), logEntry.entryId, logEntry.payload)\n   }\n+}\n+\n+class InMemoryLedgerStateAccess()(implicit executionContext: ExecutionContext)\n+    extends LedgerStateAccess[Index] {\n+\n+  private val lockCurrentState = new Semaphore(1, true)\n+\n+  val currentState = new InMemoryState()"
  },
  {
    "id" : "d2f5feed-a5f5-4fc3-bda6-b1a8b3c17db8",
    "prId" : 4669,
    "comments" : [
      {
        "id" : "91e86648-bb41-4bb9-887b-d1a68bca5fc5",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Just realized that this should be a `TimeProvider`, not a `TimeServiceBackend`.",
        "createdAt" : "2020-02-25T12:27:20Z",
        "updatedAt" : "2020-02-26T07:26:00Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ae0a86ecb50b24000dc0788888770635bf7f5fd9",
    "line" : null,
    "diffHunk" : "@@ -139,12 +139,15 @@ object InMemoryLedgerReaderWriter {\n \n   private val DefaultClock: Clock = Clock.systemUTC()\n \n+  val DefaultTimeServiceBackend: TimeServiceBackend =\n+    TimeServiceBackend.wallClock(DefaultClock)\n+\n   private val sequentialLogEntryId = new SequentialLogEntryId(NamespaceLogEntries)\n \n   def owner(\n       initialLedgerId: Option[LedgerId],\n       participantId: ParticipantId,\n-      now: () => Instant = () => DefaultClock.instant(),\n+      timeServiceBackend: TimeServiceBackend,"
  },
  {
    "id" : "e8c18686-73b7-47fa-a3d4-891eb9d026e3",
    "prId" : 4581,
    "comments" : [
      {
        "id" : "d1f46d29-ef56-48ee-80b0-a0f5e725ee23",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Nice. :slightly_smiling_face: Would a `() => Instant` work though?",
        "createdAt" : "2020-02-18T15:22:09Z",
        "updatedAt" : "2020-02-18T16:20:51Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7ccb22e6-9eb2-413a-afae-ddea50e12520",
        "parentId" : "d1f46d29-ef56-48ee-80b0-a0f5e725ee23",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Probably, but I find `Clock` quite a nice interface. Any reason you'd prefer the lambda?",
        "createdAt" : "2020-02-18T15:56:35Z",
        "updatedAt" : "2020-02-18T16:20:51Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d6e1109c232c3009ef399fb97b86a4e91ad577ed",
    "line" : null,
    "diffHunk" : "@@ -140,7 +140,11 @@ object InMemoryLedgerReaderWriter {\n   def owner(\n       ledgerId: LedgerId,\n       participantId: ParticipantId,\n-  )(implicit executionContext: ExecutionContext): ResourceOwner[InMemoryLedgerReaderWriter] =\n+      clock: Clock = Clock.systemUTC(),"
  },
  {
    "id" : "0ba8517a-3a4a-415a-b62e-c1f724d7ddd8",
    "prId" : 4437,
    "comments" : [
      {
        "id" : "c145b04e-106f-4a4d-bb4f-b10b7b50904d",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Is there a good reason to recreate the validator for each request separately? Related to my later comment about one engine per validator instance.",
        "createdAt" : "2020-02-07T08:12:42Z",
        "updatedAt" : "2020-02-10T12:53:39Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0094eef4-4272-4f90-aed2-9f1545f96a9d",
        "parentId" : "c145b04e-106f-4a4d-bb4f-b10b7b50904d",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Not anymore -- changed to reuse the same validator instance for each commit.",
        "createdAt" : "2020-02-07T10:34:38Z",
        "updatedAt" : "2020-02-10T12:53:39Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53e6c80e9907f181e0a6a6cfde60e0d2b6a3c21",
    "line" : null,
    "diffHunk" : "@@ -53,40 +49,57 @@ final class InMemoryLedgerReaderWriter(\n     extends LedgerWriter\n     with LedgerReader {\n \n-  private val engine = Engine()\n-\n   private val currentState = new InMemoryState()\n \n-  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n-    Future {\n-      val submission = Envelope\n-        .openSubmission(envelope)\n-        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n-      currentState.synchronized {\n-        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n-          submission.getInputDamlStateList.asScala\n-            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n-        val entryId = sequentialLogEntryId.next()\n-        val (logEntry, damlStateUpdates) =\n-          KeyValueCommitting.processSubmission(\n-            engine,\n-            entryId,\n-            currentRecordTime(),\n-            LedgerReader.DefaultConfiguration,\n-            submission,\n-            participantId,\n-            stateInputs,\n-          )\n-        val stateUpdates = damlStateUpdates.map {\n-          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+  private class InMemoryLedgerStateAccess(theParticipantId: ParticipantId)\n+      extends LedgerStateAccess {\n+    override def inTransaction[T](body: LedgerStateOperations => Future[T]): Future[T] =\n+      Future {\n+        currentState.state.synchronized {\n+          body(new InMemoryLedgerStateOperations)\n         }\n-        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n-        currentState.state ++= stateUpdates\n-        dispatcher.signalNewHead(currentState.log.size)\n-      }\n-      SubmissionResult.Acknowledged\n+      }.flatten\n+\n+    override def participantId: String = theParticipantId\n+  }\n+\n+  private class InMemoryLedgerStateOperations extends LedgerStateOperations {\n+    override def readState(key: Array[Byte]): Future[Option[Array[Byte]]] = Future.successful {\n+      currentState.state.get(ByteString.copyFrom(key))\n     }\n \n+    override def writeState(keyValuePairs: Seq[(Array[Byte], Array[Byte])]): Future[Unit] =\n+      Future.successful {\n+        currentState.state ++= keyValuePairs.map {\n+          case (keyBytes, valueBytes) => ByteString.copyFrom(keyBytes) -> valueBytes\n+        }\n+      }\n+\n+    override def appendToLog(key: Array[Byte], value: Array[Byte]): Future[Unit] =\n+      Future.successful {\n+        val damlLogEntryId = KeyValueCommitting.unpackDamlLogEntryId(key)\n+        val logEntry = LogEntry(damlLogEntryId, value)\n+        val newHead = currentState.log.synchronized {\n+          currentState.log += logEntry\n+          currentState.log.size\n+        }\n+        dispatcher.signalNewHead(newHead)\n+      }\n+  }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] = {\n+    val validator = SubmissionValidator.create("
  },
  {
    "id" : "cb8c2278-fe4d-4085-825d-778ec3c866d6",
    "prId" : 4437,
    "comments" : [
      {
        "id" : "d2212e6c-103e-411d-8962-e0a087e4bd1e",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This can probably be an `object`; there's no state.",
        "createdAt" : "2020-02-07T12:22:39Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1d1d8923-b53e-490c-9dd6-46664e21b07d",
        "parentId" : "d2212e6c-103e-411d-8962-e0a087e4bd1e",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Yes -- changed accordingly.",
        "createdAt" : "2020-02-07T15:46:52Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53e6c80e9907f181e0a6a6cfde60e0d2b6a3c21",
    "line" : null,
    "diffHunk" : "@@ -53,39 +49,58 @@ final class InMemoryLedgerReaderWriter(\n     extends LedgerWriter\n     with LedgerReader {\n \n-  private val engine = Engine()\n-\n   private val currentState = new InMemoryState()\n \n-  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n-    Future {\n-      val submission = Envelope\n-        .openSubmission(envelope)\n-        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n-      currentState.synchronized {\n-        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n-          submission.getInputDamlStateList.asScala\n-            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n-        val entryId = sequentialLogEntryId.next()\n-        val (logEntry, damlStateUpdates) =\n-          KeyValueCommitting.processSubmission(\n-            engine,\n-            entryId,\n-            currentRecordTime(),\n-            LedgerReader.DefaultConfiguration,\n-            submission,\n-            participantId,\n-            stateInputs,\n-          )\n-        val stateUpdates = damlStateUpdates.map {\n-          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+  private class InMemoryLedgerStateAccess(theParticipantId: ParticipantId)\n+      extends LedgerStateAccess {\n+    override def inTransaction[T](body: LedgerStateOperations => Future[T]): Future[T] =\n+      Future {\n+        currentState.state.synchronized {\n+          body(new InMemoryLedgerStateOperations)\n         }\n-        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n-        currentState.state ++= stateUpdates\n-        dispatcher.signalNewHead(currentState.log.size)\n+      }.flatten\n+\n+    override def participantId: String = theParticipantId\n+  }\n+\n+  private class InMemoryLedgerStateOperations extends BatchingLedgerStateOperations {"
  },
  {
    "id" : "fc8f694e-bda5-4154-ad60-af54e4b7033d",
    "prId" : 4437,
    "comments" : [
      {
        "id" : "1e878b41-35ad-460e-8d35-fd7892a43c78",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "What does it mean to synchronize over a `Future`? I think you need to use an explicit lock and unlock on a mutex here, otherwise the lock will be released when the future is returned, not when it completes.\r\n\r\nSomething like:\r\n\r\n```scala\r\nFuture(lock() /* example; not a thing */)\r\n  .flatMap(lock =>\r\n    body(new InMemoryLedgerStateOperations)\r\n      .transform { result =>\r\n         lock.unlock()\r\n         result\r\n      })\r\n```\r\n\r\nDon't use a `ReentrantLock` because that forces you to lock and unlock on the same thread. You'll probably need to use a `Semaphore`.",
        "createdAt" : "2020-02-07T12:28:02Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "97ce3cf0-e8e7-4eea-8422-035d029cee8d",
        "parentId" : "1e878b41-35ad-460e-8d35-fd7892a43c78",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "It doesn't make any sense -- changed according to your suggestion. I.e., state was only locked while the parent `Future` was running hence it did not have the effect needed.",
        "createdAt" : "2020-02-07T15:31:13Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53e6c80e9907f181e0a6a6cfde60e0d2b6a3c21",
    "line" : null,
    "diffHunk" : "@@ -53,39 +49,58 @@ final class InMemoryLedgerReaderWriter(\n     extends LedgerWriter\n     with LedgerReader {\n \n-  private val engine = Engine()\n-\n   private val currentState = new InMemoryState()\n \n-  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n-    Future {\n-      val submission = Envelope\n-        .openSubmission(envelope)\n-        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n-      currentState.synchronized {\n-        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n-          submission.getInputDamlStateList.asScala\n-            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n-        val entryId = sequentialLogEntryId.next()\n-        val (logEntry, damlStateUpdates) =\n-          KeyValueCommitting.processSubmission(\n-            engine,\n-            entryId,\n-            currentRecordTime(),\n-            LedgerReader.DefaultConfiguration,\n-            submission,\n-            participantId,\n-            stateInputs,\n-          )\n-        val stateUpdates = damlStateUpdates.map {\n-          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+  private class InMemoryLedgerStateAccess(theParticipantId: ParticipantId)\n+      extends LedgerStateAccess {\n+    override def inTransaction[T](body: LedgerStateOperations => Future[T]): Future[T] =\n+      Future {\n+        currentState.state.synchronized {\n+          body(new InMemoryLedgerStateOperations)\n         }"
  },
  {
    "id" : "e20fbd3e-5cc7-4d46-89aa-0b923659de4a",
    "prId" : 4437,
    "comments" : [
      {
        "id" : "21cb21b6-8311-4136-b71f-6ceb10def932",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Move this to the top of the class?",
        "createdAt" : "2020-02-07T12:28:54Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7b046f09-dd92-4fa8-b20d-ae5804c63d6b",
        "parentId" : "21cb21b6-8311-4136-b71f-6ceb10def932",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-02-07T15:31:22Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53e6c80e9907f181e0a6a6cfde60e0d2b6a3c21",
    "line" : null,
    "diffHunk" : "@@ -53,39 +49,58 @@ final class InMemoryLedgerReaderWriter(\n     extends LedgerWriter\n     with LedgerReader {\n \n-  private val engine = Engine()\n-\n   private val currentState = new InMemoryState()\n \n-  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n-    Future {\n-      val submission = Envelope\n-        .openSubmission(envelope)\n-        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n-      currentState.synchronized {\n-        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n-          submission.getInputDamlStateList.asScala\n-            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n-        val entryId = sequentialLogEntryId.next()\n-        val (logEntry, damlStateUpdates) =\n-          KeyValueCommitting.processSubmission(\n-            engine,\n-            entryId,\n-            currentRecordTime(),\n-            LedgerReader.DefaultConfiguration,\n-            submission,\n-            participantId,\n-            stateInputs,\n-          )\n-        val stateUpdates = damlStateUpdates.map {\n-          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+  private class InMemoryLedgerStateAccess(theParticipantId: ParticipantId)\n+      extends LedgerStateAccess {\n+    override def inTransaction[T](body: LedgerStateOperations => Future[T]): Future[T] =\n+      Future {\n+        currentState.state.synchronized {\n+          body(new InMemoryLedgerStateOperations)\n         }\n-        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n-        currentState.state ++= stateUpdates\n-        dispatcher.signalNewHead(currentState.log.size)\n+      }.flatten\n+\n+    override def participantId: String = theParticipantId\n+  }\n+\n+  private class InMemoryLedgerStateOperations extends BatchingLedgerStateOperations {\n+    override def readState(keys: Seq[Array[Byte]]): Future[Seq[Option[Array[Byte]]]] =\n+      Future.successful {\n+        keys.map(keyBytes => currentState.state.get(ByteString.copyFrom(keyBytes)))\n       }\n-      SubmissionResult.Acknowledged\n-    }\n+\n+    override def writeState(keyValuePairs: Seq[(Array[Byte], Array[Byte])]): Future[Unit] =\n+      Future.successful {\n+        currentState.state ++= keyValuePairs.map {\n+          case (keyBytes, valueBytes) => ByteString.copyFrom(keyBytes) -> valueBytes\n+        }\n+      }\n+\n+    override def appendToLog(key: Array[Byte], value: Array[Byte]): Future[Unit] =\n+      Future.successful {\n+        val damlLogEntryId = KeyValueCommitting.unpackDamlLogEntryId(key)\n+        val logEntry = LogEntry(damlLogEntryId, value)\n+        val newHead = currentState.log.synchronized {\n+          currentState.log += logEntry\n+          currentState.log.size\n+        }\n+        dispatcher.signalNewHead(newHead)\n+      }\n+  }\n+\n+  private val validator = SubmissionValidator.create(\n+    new InMemoryLedgerStateAccess(participantId),\n+    () => sequentialLogEntryId.next())"
  },
  {
    "id" : "bd0bd96b-4bfe-454e-b37b-ffc4f06fe5cd",
    "prId" : 4437,
    "comments" : [
      {
        "id" : "7851e62c-8d04-4130-b63b-16f0b63494d2",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This seems like boilerplate; can it be moved to KVUtils?",
        "createdAt" : "2020-02-07T12:30:03Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "24146608-11af-4d34-a356-78047f8b24c8",
        "parentId" : "7851e62c-8d04-4130-b63b-16f0b63494d2",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Good point -- let's move it when we move another ledger to use `SubmissionValidator`.",
        "createdAt" : "2020-02-07T15:32:36Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b53e6c80e9907f181e0a6a6cfde60e0d2b6a3c21",
    "line" : 141,
    "diffHunk" : "@@ -53,39 +49,58 @@ final class InMemoryLedgerReaderWriter(\n     extends LedgerWriter\n     with LedgerReader {\n \n-  private val engine = Engine()\n-\n   private val currentState = new InMemoryState()\n \n-  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n-    Future {\n-      val submission = Envelope\n-        .openSubmission(envelope)\n-        .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n-      currentState.synchronized {\n-        val stateInputs: Map[DamlStateKey, Option[DamlStateValue]] =\n-          submission.getInputDamlStateList.asScala\n-            .map(key => key -> currentState.state.get(key.toByteString))(breakOut)\n-        val entryId = sequentialLogEntryId.next()\n-        val (logEntry, damlStateUpdates) =\n-          KeyValueCommitting.processSubmission(\n-            engine,\n-            entryId,\n-            currentRecordTime(),\n-            LedgerReader.DefaultConfiguration,\n-            submission,\n-            participantId,\n-            stateInputs,\n-          )\n-        val stateUpdates = damlStateUpdates.map {\n-          case (damlStateKey, value) => damlStateKey.toByteString -> value\n+  private class InMemoryLedgerStateAccess(theParticipantId: ParticipantId)\n+      extends LedgerStateAccess {\n+    override def inTransaction[T](body: LedgerStateOperations => Future[T]): Future[T] =\n+      Future {\n+        currentState.state.synchronized {\n+          body(new InMemoryLedgerStateOperations)\n         }\n-        currentState.log += LogEntry(entryId, Envelope.enclose(logEntry).toByteArray)\n-        currentState.state ++= stateUpdates\n-        dispatcher.signalNewHead(currentState.log.size)\n+      }.flatten\n+\n+    override def participantId: String = theParticipantId\n+  }\n+\n+  private class InMemoryLedgerStateOperations extends BatchingLedgerStateOperations {\n+    override def readState(keys: Seq[Array[Byte]]): Future[Seq[Option[Array[Byte]]]] =\n+      Future.successful {\n+        keys.map(keyBytes => currentState.state.get(ByteString.copyFrom(keyBytes)))\n       }\n-      SubmissionResult.Acknowledged\n-    }\n+\n+    override def writeState(keyValuePairs: Seq[(Array[Byte], Array[Byte])]): Future[Unit] =\n+      Future.successful {\n+        currentState.state ++= keyValuePairs.map {\n+          case (keyBytes, valueBytes) => ByteString.copyFrom(keyBytes) -> valueBytes\n+        }\n+      }\n+\n+    override def appendToLog(key: Array[Byte], value: Array[Byte]): Future[Unit] =\n+      Future.successful {\n+        val damlLogEntryId = KeyValueCommitting.unpackDamlLogEntryId(key)\n+        val logEntry = LogEntry(damlLogEntryId, value)\n+        val newHead = currentState.log.synchronized {\n+          currentState.log += logEntry\n+          currentState.log.size\n+        }\n+        dispatcher.signalNewHead(newHead)\n+      }\n+  }\n+\n+  private val validator = SubmissionValidator.create(\n+    new InMemoryLedgerStateAccess(participantId),\n+    () => sequentialLogEntryId.next())\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] = {\n+    validator\n+      .validateAndCommit(envelope, correlationId, currentRecordTime())\n+      .map {\n+        case SubmissionValidated => SubmissionResult.Acknowledged\n+        case MissingInputState(_) => SubmissionResult.InternalError(\"Missing input state\")\n+        case ValidationError(reason) => SubmissionResult.InternalError(reason)\n+      }\n+  }"
  },
  {
    "id" : "c4eb4214-031b-4d0e-8f8c-b2ab29734ce8",
    "prId" : 4437,
    "comments" : [
      {
        "id" : "06b2f00b-a526-4fec-8650-1ddd02adb1c9",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "👍 ",
        "createdAt" : "2020-02-10T11:57:14Z",
        "updatedAt" : "2020-02-10T12:53:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b53e6c80e9907f181e0a6a6cfde60e0d2b6a3c21",
    "line" : 98,
    "diffHunk" : "@@ -51,32 +52,40 @@ final class InMemoryLedgerReaderWriter(\n \n   private val currentState = new InMemoryState()\n \n+  private val lockCurrentState = new Semaphore(1, true)\n+\n+  private val validator = SubmissionValidator.create(\n+    new InMemoryLedgerStateAccess(participantId),\n+    () => sequentialLogEntryId.next())\n+\n   private class InMemoryLedgerStateAccess(theParticipantId: ParticipantId)\n       extends LedgerStateAccess {\n     override def inTransaction[T](body: LedgerStateOperations => Future[T]): Future[T] =\n-      Future {\n-        currentState.state.synchronized {\n-          body(new InMemoryLedgerStateOperations)\n+      Future\n+        .successful(lockCurrentState.acquire())\n+        .flatMap(_ => body(InMemoryLedgerStateOperations))\n+        .andThen {\n+          case _ =>\n+            lockCurrentState.release()\n         }"
  }
]