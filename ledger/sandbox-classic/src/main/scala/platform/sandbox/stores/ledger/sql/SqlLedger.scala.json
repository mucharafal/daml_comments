[
  {
    "id" : "1086e3df-996c-4cf1-b5f9-8a6a698a4cdb",
    "prId" : 7200,
    "comments" : [
      {
        "id" : "3e63f7cb-d39a-458c-885f-68b1a16030d6",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Nice.",
        "createdAt" : "2020-08-21T11:08:45Z",
        "updatedAt" : "2020-08-21T13:01:52Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4d6c755d-7f54-4290-a260-5a8aa72012ea",
        "parentId" : "3e63f7cb-d39a-458c-885f-68b1a16030d6",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Thanks!",
        "createdAt" : "2020-08-21T11:19:10Z",
        "updatedAt" : "2020-08-21T13:01:52Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b117799f780981a359552cce2b3414250cc75823",
    "line" : 50,
    "diffHunk" : "@@ -71,89 +71,69 @@ private[sandbox] object SqlLedger {\n     override def acquire()(implicit executionContext: ExecutionContext): Resource[Ledger] =\n       for {\n         _ <- Resource.fromFuture(new FlywayMigrations(jdbcUrl).migrate())\n-        ledgerDao <- ledgerDaoOwner().acquire()\n+        dao <- ledgerDaoOwner().acquire()\n         _ <- startMode match {\n           case SqlStartMode.AlwaysReset =>\n-            Resource.fromFuture(ledgerDao.reset())\n+            Resource.fromFuture(dao.reset())\n           case SqlStartMode.ContinueIfExists =>\n             Resource.unit\n         }\n-        ledgerId <- Resource.fromFuture(initialize(ledgerDao))\n-        ledgerEnd <- Resource.fromFuture(ledgerDao.lookupLedgerEnd())\n-        ledgerConfig <- Resource.fromFuture(ledgerDao.lookupLedgerConfiguration())\n+        retrievedLedgerId <- Resource.fromFuture(dao.lookupLedgerId())\n+        ledgerId <- Resource.fromFuture(retrievedLedgerId.fold(initialize(dao))(resume))"
  },
  {
    "id" : "00d8180a-9c94-403e-9f59-42a23bccae49",
    "prId" : 7200,
    "comments" : [
      {
        "id" : "916c044c-77bd-4669-9875-d0cadf960bd0",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Can you move these to a companion object please?",
        "createdAt" : "2020-08-21T11:09:18Z",
        "updatedAt" : "2020-08-21T13:01:52Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "75537007-0eb3-4428-bec5-a9dfec11b259",
        "parentId" : "916c044c-77bd-4669-9875-d0cadf960bd0",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/7200/commits/8fab17caadb499296c892060cf323a2cc98592e3",
        "createdAt" : "2020-08-21T11:19:32Z",
        "updatedAt" : "2020-08-21T13:01:52Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b117799f780981a359552cce2b3414250cc75823",
    "line" : null,
    "diffHunk" : "@@ -71,89 +71,69 @@ private[sandbox] object SqlLedger {\n     override def acquire()(implicit executionContext: ExecutionContext): Resource[Ledger] =\n       for {\n         _ <- Resource.fromFuture(new FlywayMigrations(jdbcUrl).migrate())\n-        ledgerDao <- ledgerDaoOwner().acquire()\n+        dao <- ledgerDaoOwner().acquire()\n         _ <- startMode match {\n           case SqlStartMode.AlwaysReset =>\n-            Resource.fromFuture(ledgerDao.reset())\n+            Resource.fromFuture(dao.reset())\n           case SqlStartMode.ContinueIfExists =>\n             Resource.unit\n         }\n-        ledgerId <- Resource.fromFuture(initialize(ledgerDao))\n-        ledgerEnd <- Resource.fromFuture(ledgerDao.lookupLedgerEnd())\n-        ledgerConfig <- Resource.fromFuture(ledgerDao.lookupLedgerConfiguration())\n+        retrievedLedgerId <- Resource.fromFuture(dao.lookupLedgerId())\n+        ledgerId <- Resource.fromFuture(retrievedLedgerId.fold(initialize(dao))(resume))\n+        ledgerEnd <- Resource.fromFuture(dao.lookupLedgerEnd())\n+        ledgerConfig <- Resource.fromFuture(dao.lookupLedgerConfiguration())\n         dispatcher <- dispatcherOwner(ledgerEnd).acquire()\n         persistenceQueue <- new PersistenceQueueOwner(dispatcher).acquire()\n         // Close the dispatcher before the persistence queue.\n         _ <- Resource(Future.unit)(_ => Future.successful(dispatcher.close()))\n         ledger <- sqlLedgerOwner(\n           ledgerId,\n           ledgerConfig.map(_._2),\n-          ledgerDao,\n+          dao,\n           dispatcher,\n-          persistenceQueue).acquire()\n+          persistenceQueue,\n+        ).acquire()\n       } yield ledger\n \n-    private def initialize(\n-        ledgerDao: LedgerDao,\n-    )(implicit executionContext: ExecutionContext): Future[LedgerId] = {\n-      // Note that here we only store the ledger entry and we do not update anything else, such as the\n-      // headRef. This is OK since this initialization\n-      // step happens before we start up the sql ledger at all, so it's running in isolation.\n+    // Store only the ledger entries (no headref, etc.). This is OK since this initialization\n+    // step happens before we start up the sql ledger at all, so it's running in isolation.\n+    private def initialize(dao: LedgerDao)(implicit ec: ExecutionContext): Future[LedgerId] = {\n+      val ledgerId = providedLedgerId.or(LedgerIdGenerator.generateRandomId(name))\n+      logger.info(s\"Initializing node with ledger id '$ledgerId'\")\n       for {\n-        currentLedgerId <- ledgerDao.lookupLedgerId()\n-        initializationRequired = currentLedgerId.isEmpty\n-        ledgerId <- (currentLedgerId, initialLedgerId) match {\n-          case (Some(foundLedgerId), LedgerIdMode.Static(initialId))\n-              if foundLedgerId == initialId =>\n-            ledgerFound(foundLedgerId, initialLedgerEntries, packages)\n-\n-          case (Some(foundLedgerId), LedgerIdMode.Static(initialId)) =>\n-            Future.failed(\n-              new LedgerIdMismatchException(foundLedgerId, initialId) with StartupException)\n-\n-          case (Some(foundLedgerId), LedgerIdMode.Dynamic) =>\n-            ledgerFound(foundLedgerId, initialLedgerEntries, packages)\n-\n-          case (None, LedgerIdMode.Static(initialId)) =>\n-            Future.successful(initialId)\n-\n-          case (None, LedgerIdMode.Dynamic) =>\n-            val randomLedgerId = new LedgerIdGenerator(name).generateRandomId()\n-            Future.successful(randomLedgerId)\n-        }\n-        _ <- if (initializationRequired) {\n-          logger.info(s\"Initializing ledger with ID: $ledgerId\")\n-          for {\n-            _ <- ledgerDao.initializeLedger(ledgerId)\n-            _ <- initializeLedgerEntries(\n-              initialLedgerEntries,\n-              timeProvider,\n-              packages,\n-              ledgerDao,\n-            )\n-          } yield ()\n-        } else {\n-          Future.unit\n-        }\n+        _ <- dao.initializeLedger(ledgerId)\n+        _ <- initializeLedgerEntries(\n+          initialLedgerEntries,\n+          timeProvider,\n+          packages,\n+          dao,\n+        )\n       } yield ledgerId\n     }\n \n-    private def ledgerFound(\n-        foundLedgerId: LedgerId,\n-        initialLedgerEntries: ImmArray[LedgerEntryOrBump],\n-        packages: InMemoryPackageStore,\n-    ): Future[LedgerId] = {\n-      logger.info(s\"Found existing ledger with ID: $foundLedgerId\")\n-      if (initialLedgerEntries.nonEmpty) {\n-        logger.warn(\n-          s\"Initial ledger entries provided, presumably from scenario, but there is an existing database, and thus they will not be used.\")\n-      }\n-      if (packages.listLfPackagesSync().nonEmpty) {\n-        logger.warn(\n-          s\"Initial packages provided, presumably as command line arguments, but there is an existing database, and thus they will not be used.\")\n+    private val nonEmptyLedgerEntriesWarningMessage =\n+      \"Initial ledger entries provided, presumably from scenario, but there is an existing database, and thus they will not be used.\"\n+\n+    private val nonEmptyPackagesWarningMessage =\n+      \"Initial packages provided, presumably as command line arguments, but there is an existing database, and thus they will not be used.\"\n+"
  }
]