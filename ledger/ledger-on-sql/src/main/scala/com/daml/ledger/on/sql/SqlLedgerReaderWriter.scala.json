[
  {
    "id" : "21474a56-bc4c-4c28-ae1f-86e3c6992d70",
    "prId" : 7525,
    "comments" : [
      {
        "id" : "fcb591fc-61a6-4d5b-a96d-09f2b4373cb1",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I do encourage in the documentation renaming `scala.concurrent` itself and using the containing package as a qualifier in all references rather than renaming individual symbols, but you do you.",
        "createdAt" : "2020-10-01T15:04:10Z",
        "updatedAt" : "2020-10-01T15:56:24Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5c49435a-6db9-448a-b277-7b3f210a9409",
        "parentId" : "fcb591fc-61a6-4d5b-a96d-09f2b4373cb1",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Yeah, I think I'd like to be consistent there, so I'll change it.",
        "createdAt" : "2020-10-01T15:32:17Z",
        "updatedAt" : "2020-10-01T15:56:24Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f8c6b839ae9e9f6ab5b9641b851ed9bc7c99abb",
    "line" : null,
    "diffHunk" : "@@ -35,7 +36,7 @@ import com.daml.platform.common.MismatchException\n import com.daml.resources.{Resource, ResourceOwner}\n import com.google.protobuf.ByteString\n \n-import scala.concurrent.{ExecutionContext, Future}\n+import scala.concurrent.{ExecutionContext => ScalaExecutionContext, Future => ScalaFuture}"
  },
  {
    "id" : "262bfa1a-e441-4908-85ba-e1897be77076",
    "prId" : 7063,
    "comments" : [
      {
        "id" : "149d1e3b-83b8-48db-907f-45e2158e4c7d",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "```suggestion\r\n      database: Database,\r\n```",
        "createdAt" : "2020-08-10T07:25:53Z",
        "updatedAt" : "2020-08-10T07:49:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "18d594e5fd16fa8e21875d091137dd6808a8611b",
    "line" : null,
    "diffHunk" : "@@ -146,23 +102,27 @@ object SqlLedgerReaderWriter {\n           else Future.successful(uninitializedDatabase.migrate()))\n         ledgerId <- Resource.fromFuture(updateOrRetrieveLedgerId(ledgerId, database))\n         dispatcher <- new DispatcherOwner(database).acquire()\n-      } yield\n-        new SqlLedgerReaderWriter(\n-          ledgerId,\n-          participantId,\n-          engine,\n-          metrics,\n-          timeProvider,\n-          stateValueCache,\n-          database,\n-          dispatcher,\n-          seedService,\n+        validator = SubmissionValidator.createForTimeMode(\n+          new SqlLedgerStateAccess(database, metrics),\n+          allocateNextLogEntryId = new LogEntryIdAllocator(seedService).allocate _,\n+          stateValueCache = stateValueCache,\n+          engine = engine,\n+          metrics = metrics,\n+          inStaticTimeMode = timeProvider != TimeProvider.UTC,\n         )\n+        committer = new ValidatingCommitter[Index](\n+          () => timeProvider.getCurrentTime,\n+          validator = validator,\n+          postCommit = dispatcher.signalNewHead,\n+        )\n+      } yield\n+        new SqlLedgerReaderWriter(ledgerId, participantId, metrics, database, dispatcher, committer)\n   }\n \n   private def updateOrRetrieveLedgerId(\n       providedLedgerId: LedgerId,\n-      database: Database): Future[LedgerId] =\n+      database: Database"
  },
  {
    "id" : "b26ec981-8ae2-44fe-88b3-7a73c1cc34b9",
    "prId" : 7063,
    "comments" : [
      {
        "id" : "74a56cce-8084-4e6d-9c90-5dc1ac7d44dd",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "If I understand correctly, this will be also used by the ledger state in direct mode. I assume it worked correctly for you with DAML-on-SQL but there were deadlocks when I attempted to do so in DAML-on-Memory so I'd test this carefully. Also, any assessment on the performance implications?",
        "createdAt" : "2020-08-10T07:33:34Z",
        "updatedAt" : "2020-08-10T07:49:53Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cacd92d4-5227-49e3-bf1f-b363ea951dc8",
        "parentId" : "74a56cce-8084-4e6d-9c90-5dc1ac7d44dd",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Hmmm, not sure how to test it past running the conformance tests (which work fine).\r\n\r\nPerformance isn't impacted at all.\r\n\r\nMy understanding is that because [we only allocate a single executor for writing](https://github.com/digital-asset/daml/pull/7063/files#diff-1454db978c0fa4672d935447db837b38R77) anyway, this simply ensures the committer _also_ has a dedicated thread.\r\n",
        "createdAt" : "2020-08-10T07:52:26Z",
        "updatedAt" : "2020-08-10T07:52:27Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "18d594e5fd16fa8e21875d091137dd6808a8611b",
    "line" : 97,
    "diffHunk" : "@@ -115,8 +116,20 @@ object SqlLedgerReaderWriter {\n           validator = validator,\n           postCommit = dispatcher.signalNewHead,\n         )\n+        committerExecutionContext <- ResourceOwner\n+          .forExecutorService(() =>\n+            ExecutionContext.fromExecutorService(Executors.newSingleThreadExecutor()))"
  },
  {
    "id" : "7e5175cf-b5ae-4b6b-a163-4ed62cf5e5c8",
    "prId" : 6515,
    "comments" : [
      {
        "id" : "a8e6d024-8874-4319-b6df-8da74ab96176",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "```suggestion\r\n      metadata: CommitMetadata,\r\n    ): Future[SubmissionResult] =\r\n```",
        "createdAt" : "2020-06-29T07:37:48Z",
        "updatedAt" : "2020-06-30T08:52:03Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5b5d17d48af638f059d785c2d530c2f7d89eec0e",
    "line" : null,
    "diffHunk" : "@@ -90,7 +95,10 @@ final class SqlLedgerReaderWriter(\n       )\n       .map { case (_, entry) => entry }\n \n-  override def commit(correlationId: String, envelope: Bytes): Future[SubmissionResult] =\n+  override def commit(\n+      correlationId: String,\n+      envelope: Bytes,\n+      metadata: CommitMetadata): Future[SubmissionResult] ="
  },
  {
    "id" : "fcccc7ac-83ec-432a-927e-2b7d9e218f1a",
    "prId" : 4984,
    "comments" : [
      {
        "id" : "36b4a1b3-4d29-4846-a852-30c59503484e",
        "parentId" : null,
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "Can't it never be Unhealthy? If it can be then I'd leave the TODO.",
        "createdAt" : "2020-03-13T15:54:08Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c93de618-637f-4913-80b9-d73c847e266b",
        "parentId" : "36b4a1b3-4d29-4846-a852-30c59503484e",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Such TODOs should be tracked in an issue tracker. I.e., we need to introduce health checking for SQL-based ledgers which obviously depends on the backing server implementation.",
        "createdAt" : "2020-03-13T16:22:42Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bae0ec0f-c5f6-4488-8c38-1d457d968a92",
        "parentId" : "36b4a1b3-4d29-4846-a852-30c59503484e",
        "author" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "body" : "@miklos-da Still, I don't think this TODO removal belongs here; it would be better to have a separate PR that removes all health-related TODOs, after creating the tracking issue so we don't forget.",
        "createdAt" : "2020-03-13T16:32:10Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "fabiotudone-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/59609563?u=a3a8ac844c9aacd1d1bd319a77d1d0ac60d701a3&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0dd3f91d-2a0e-4dd2-a03f-a2c478b55455",
        "parentId" : "36b4a1b3-4d29-4846-a852-30c59503484e",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "@gerolf-da Do you want to create an issue to track this, please?",
        "createdAt" : "2020-03-13T18:39:17Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "61f27c30-d8ff-403b-810b-baa1b7aac94e",
        "parentId" : "36b4a1b3-4d29-4846-a852-30c59503484e",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Already exists: #4224",
        "createdAt" : "2020-03-16T08:27:43Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a752978e-094a-4fd5-9bf0-06f2cf6927f9",
        "parentId" : "36b4a1b3-4d29-4846-a852-30c59503484e",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I think it's fine to remove this; didn't have to be in this PR but there's no harm.",
        "createdAt" : "2020-03-16T08:28:03Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c322c172-ca6f-4cf7-a47d-bdb98d0e5a2d",
        "parentId" : "36b4a1b3-4d29-4846-a852-30c59503484e",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Thanks for the confirmation, @SamirTalwar-DA ",
        "createdAt" : "2020-03-16T09:39:33Z",
        "updatedAt" : "2020-03-16T14:56:06Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8049c9ebb4015c70e4b3db0344c1e0bdf85699ec",
    "line" : 13,
    "diffHunk" : "@@ -55,7 +56,6 @@ final class SqlLedgerReaderWriter(\n     latestSequenceNo => dispatcher.signalNewHead(latestSequenceNo + 1),\n   )\n \n-  // TODO: implement\n   override def currentHealth(): HealthStatus = Healthy"
  },
  {
    "id" : "cf939851-9cd9-4190-9a98-4b0b69d46190",
    "prId" : 4953,
    "comments" : [
      {
        "id" : "cb6a2556-38eb-4666-8f20-ea06cf7aa79a",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Why not use `.futureSource` and wrap `queries.selectFromLog(start, end)` in a `Source` with `.map(Source _)`?",
        "createdAt" : "2020-03-17T13:37:01Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "66a869a1-7537-435f-a9dc-85ea3e3ade9a",
        "parentId" : "cb6a2556-38eb-4666-8f20-ea06cf7aa79a",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "My mental mostly is mostly around initializing the stream and afterwards manipulating it in the way it's necessary. In this case it doesn't matter much I guess. Other than we then probably should use `DirectExecutionContext` to avoid having a thread context switch for simply turning `Seq[_]` to `Source[_]`.",
        "createdAt" : "2020-03-17T16:38:10Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "24c1e545-f296-45c5-90de-f4e3cfe39a1c",
        "parentId" : "cb6a2556-38eb-4666-8f20-ea06cf7aa79a",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Eh, leave it for now, and I'll see if I can get rid of the futures entirely at a later point. They're kind of pointless.",
        "createdAt" : "2020-03-17T16:40:47Z",
        "updatedAt" : "2020-03-17T19:46:55Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9c3ccf491dcebc26c083911d9714d2fa5d032f",
    "line" : 47,
    "diffHunk" : "@@ -53,30 +47,22 @@ final class SqlLedgerReaderWriter(\n     participantId,\n     () => timeProvider.getCurrentTime,\n     SubmissionValidator.create(SqlLedgerStateAccess),\n-    latestSequenceNo => dispatcher.signalNewHead(latestSequenceNo + 1),\n+    latestSequenceNo => dispatcher.signalNewHead(latestSequenceNo),\n   )\n \n   override def currentHealth(): HealthStatus = Healthy\n \n-  override def events(offset: Option[Offset]): Source[LedgerEntry, NotUsed] =\n+  override def events(startExclusive: Option[Offset]): Source[LedgerEntry, NotUsed] =\n     dispatcher\n       .startingAt(\n-        offset.getOrElse(StartOffset).components.head,\n+        KVOffset.highestIndex(startExclusive.getOrElse(StartOffset)),\n         RangeSource((start, end) => {\n           Source\n-            .futureSource(database\n-              .inReadTransaction(s\"Querying events [$start, $end[ from log\") { queries =>\n+            .future(database"
  },
  {
    "id" : "2a9ef5b8-5b01-4ea0-8f55-62c15f38e4f5",
    "prId" : 4755,
    "comments" : [
      {
        "id" : "ca4c75d1-982f-4544-b8d0-b2cddb940813",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Considering the body of `flatMap` only constructs futures as `failed` and `successful` you can `flatMap` on the `Try` to avoid the context switch over the dispatcher.",
        "createdAt" : "2020-02-28T12:40:04Z",
        "updatedAt" : "2020-03-02T18:11:35Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3e870a6b-d93f-4a03-b0f1-6a070a64b763",
        "parentId" : "ca4c75d1-982f-4544-b8d0-b2cddb940813",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Good point. Done!",
        "createdAt" : "2020-02-28T13:13:01Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d36fdaa30a004657bd518f427ba4d9695681aa0",
    "line" : null,
    "diffHunk" : "@@ -131,15 +137,16 @@ object SqlLedgerReaderWriter {\n     database.inWriteTransaction(\"Checking ledger ID at startup\") { queries =>\n       val providedLedgerId =\n         initialLedgerId.getOrElse(Ref.LedgerString.assertFromString(UUID.randomUUID.toString))\n-      val ledgerId = queries.updateOrRetrieveLedgerId(providedLedgerId)\n-      if (initialLedgerId.exists(_ != ledgerId)) {\n-        Future.failed(\n-          new LedgerIdMismatchException(\n-            domain.LedgerId(ledgerId),\n-            domain.LedgerId(initialLedgerId.get),\n-          ))\n-      } else {\n-        Future.successful(ledgerId)\n+      Future.fromTry(queries.updateOrRetrieveLedgerId(providedLedgerId)).flatMap { ledgerId =>"
  },
  {
    "id" : "b96d491d-815b-4204-9e2f-6ec768d1f895",
    "prId" : 4755,
    "comments" : [
      {
        "id" : "1ddd8310-d231-4dbc-bf01-ec832d8a9235",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "The indentation here is a bit hard to follow. Can you make it easier to read, please? E.g., you could break the line after `Future.fromTry` or extract the construction of the `Try`.",
        "createdAt" : "2020-03-02T09:50:55Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dccf598d-43c9-487f-9fe5-8a1a0c359743",
        "parentId" : "1ddd8310-d231-4dbc-bf01-ec832d8a9235",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Solid point. Should be easier now.",
        "createdAt" : "2020-03-02T13:54:13Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d36fdaa30a004657bd518f427ba4d9695681aa0",
    "line" : null,
    "diffHunk" : "@@ -131,16 +137,17 @@ object SqlLedgerReaderWriter {\n     database.inWriteTransaction(\"Checking ledger ID at startup\") { queries =>\n       val providedLedgerId =\n         initialLedgerId.getOrElse(Ref.LedgerString.assertFromString(UUID.randomUUID.toString))\n-      val ledgerId = queries.updateOrRetrieveLedgerId(providedLedgerId)\n-      if (initialLedgerId.exists(_ != ledgerId)) {\n-        Future.failed(\n-          new LedgerIdMismatchException(\n-            domain.LedgerId(ledgerId),\n-            domain.LedgerId(initialLedgerId.get),\n-          ))\n-      } else {\n-        Future.successful(ledgerId)\n-      }\n+      Future.fromTry(queries.updateOrRetrieveLedgerId(providedLedgerId).flatMap { ledgerId =>\n+        if (initialLedgerId.exists(_ != ledgerId)) {\n+          Failure(\n+            new LedgerIdMismatchException(\n+              domain.LedgerId(ledgerId),\n+              domain.LedgerId(initialLedgerId.get),\n+            ))\n+        } else {\n+          Success(ledgerId)\n+        }"
  },
  {
    "id" : "883fb730-3da8-4ddb-b392-60a31e6014f0",
    "prId" : 4755,
    "comments" : [
      {
        "id" : "43813e6d-2fe8-418d-8181-d4e219ab75bb",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "The indentation here is a bit hard to follow. Can you make it easier to read, please? E.g., you could break the line after `Future.fromTry` or extract the construction of the `Try`.",
        "createdAt" : "2020-03-02T12:27:19Z",
        "updatedAt" : "2020-03-02T18:11:36Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d36fdaa30a004657bd518f427ba4d9695681aa0",
    "line" : null,
    "diffHunk" : "@@ -131,16 +137,17 @@ object SqlLedgerReaderWriter {\n     database.inWriteTransaction(\"Checking ledger ID at startup\") { queries =>\n       val providedLedgerId =\n         initialLedgerId.getOrElse(Ref.LedgerString.assertFromString(UUID.randomUUID.toString))\n-      val ledgerId = queries.updateOrRetrieveLedgerId(providedLedgerId)\n-      if (initialLedgerId.exists(_ != ledgerId)) {\n-        Future.failed(\n-          new LedgerIdMismatchException(\n-            domain.LedgerId(ledgerId),\n-            domain.LedgerId(initialLedgerId.get),\n-          ))\n-      } else {\n-        Future.successful(ledgerId)\n-      }\n+      Future.fromTry(queries.updateOrRetrieveLedgerId(providedLedgerId).flatMap { ledgerId =>\n+        if (initialLedgerId.exists(_ != ledgerId)) {\n+          Failure(\n+            new LedgerIdMismatchException(\n+              domain.LedgerId(ledgerId),\n+              domain.LedgerId(initialLedgerId.get),\n+            ))\n+        } else {\n+          Success(ledgerId)\n+        }\n+      })"
  },
  {
    "id" : "be1c5eec-df30-4679-a84a-c06859bdc204",
    "prId" : 4669,
    "comments" : [
      {
        "id" : "ca066f9c-22da-4535-ab58-3a656c60cbfc",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "This should also be a `TimeProvider`.",
        "createdAt" : "2020-02-25T12:27:31Z",
        "updatedAt" : "2020-02-26T07:26:00Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ae0a86ecb50b24000dc0788888770635bf7f5fd9",
    "line" : null,
    "diffHunk" : "@@ -107,11 +107,14 @@ object SqlLedgerReaderWriter {\n \n   private val DefaultClock: Clock = Clock.systemUTC()\n \n+  val DefaultTimeServiceBackend: TimeServiceBackend =\n+    TimeServiceBackend.wallClock(DefaultClock)\n+\n   def owner(\n       initialLedgerId: Option[LedgerId],\n       participantId: ParticipantId,\n       jdbcUrl: String,\n-      now: () => Instant = () => DefaultClock.instant(),\n+      timeServiceBackend: TimeServiceBackend,"
  },
  {
    "id" : "35a148f1-74a8-4f1f-a31e-28134357686d",
    "prId" : 4607,
    "comments" : [
      {
        "id" : "76b5903b-935c-4634-bd61-9fbeddb9d6f5",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Probably worth putting the thunk passed to `ResourceOwner.forFuture` in its own method.",
        "createdAt" : "2020-02-19T16:07:18Z",
        "updatedAt" : "2020-02-19T20:48:13Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "95adb4ab-2ece-42ff-8deb-9e7587a4ad65",
        "parentId" : "76b5903b-935c-4634-bd61-9fbeddb9d6f5",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Pulled this and the other thunk out. 🙂 ",
        "createdAt" : "2020-02-19T20:48:45Z",
        "updatedAt" : "2020-02-19T20:48:46Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2631a6f3d08f69f84454f5b30c7ebcb7581b0e28",
    "line" : null,
    "diffHunk" : "@@ -122,9 +124,25 @@ object SqlLedgerReaderWriter {\n     for {\n       uninitializedDatabase <- Database.owner(jdbcUrl)\n       database = uninitializedDatabase.migrate()\n+      queries = database.queries\n+      ledgerId <- ResourceOwner.forFuture(() =>\n+        database.inWriteTransaction(\"Checking ledger ID at startup\") { implicit connection =>"
  },
  {
    "id" : "3df13d02-48a0-44e9-9d68-7cae15621fe9",
    "prId" : 4607,
    "comments" : [
      {
        "id" : "72ee41df-763d-4615-8594-3d07f812f8b3",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "This operation and the previous one can probably be composed in a `Future` as part of another method so that we don't have to wrap in a `ResourceOwner` twice over two steps.",
        "createdAt" : "2020-02-19T16:22:16Z",
        "updatedAt" : "2020-02-19T20:48:13Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "112a0a74-5e60-4511-8151-f3f3483b84f6",
        "parentId" : "72ee41df-763d-4615-8594-3d07f812f8b3",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "True, but then we have to return a tuple, which is less pleasant. I'm happy to combine this one with the next one, for the dispatcher.",
        "createdAt" : "2020-02-19T16:59:28Z",
        "updatedAt" : "2020-02-19T20:48:13Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2631a6f3d08f69f84454f5b30c7ebcb7581b0e28",
    "line" : null,
    "diffHunk" : "@@ -122,9 +124,25 @@ object SqlLedgerReaderWriter {\n     for {\n       uninitializedDatabase <- Database.owner(jdbcUrl)\n       database = uninitializedDatabase.migrate()\n+      queries = database.queries\n+      ledgerId <- ResourceOwner.forFuture(() =>\n+        database.inWriteTransaction(\"Checking ledger ID at startup\") { implicit connection =>\n+          val providedLedgerId =\n+            initialLedgerId.getOrElse(Ref.LedgerString.assertFromString(UUID.randomUUID.toString))\n+          val ledgerId = queries.updateOrRetrieveLedgerId(providedLedgerId)\n+          if (initialLedgerId.exists(_ != ledgerId)) {\n+            Future.failed(\n+              new LedgerIdMismatchException(\n+                domain.LedgerId(ledgerId),\n+                domain.LedgerId(initialLedgerId.get),\n+              ))\n+          } else {\n+            Future.successful(ledgerId)\n+          }\n+      })\n       head <- ResourceOwner.forFuture(() =>\n         database.inReadTransaction(\"Reading head at startup\") { implicit connection =>\n-          Future(database.queries.selectLatestLogEntryId().map(_ + 1).getOrElse(StartIndex))\n+          Future.successful(queries.selectLatestLogEntryId().map(_ + 1).getOrElse(StartIndex))"
  },
  {
    "id" : "954bc2f6-ba61-42af-9693-2ab3e48c3a21",
    "prId" : 4532,
    "comments" : [
      {
        "id" : "88fa5f92-289f-4440-b73f-26b2c435bb6f",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Nice negative delta.",
        "createdAt" : "2020-02-14T16:46:07Z",
        "updatedAt" : "2020-02-15T15:45:04Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "68d515d40507c5874ecc55d80ce5abcafc53a013",
    "line" : 99,
    "diffHunk" : "@@ -58,68 +65,69 @@ class SqlLedgerReaderWriter(\n       .startingAt(\n         offset.getOrElse(StartOffset).components.head,\n         RangeSource((start, end) => {\n-          val result = database.inReadTransaction(s\"Querying events [$start, $end[ from log\") {\n-            implicit connection =>\n-              queries.selectFromLog(start, end)\n-          }\n-          if (result.length < end - start) {\n-            val missing = TreeSet(start until end: _*) -- result.map(_._1)\n-            Source.failed(new IllegalStateException(s\"Missing entries: ${missing.mkString(\", \")}\"))\n-          } else {\n-            Source(result)\n-          }\n+          Source\n+            .futureSource(database\n+              .inReadTransaction(s\"Querying events [$start, $end[ from log\") {\n+                implicit connection =>\n+                  Future.successful(queries.selectFromLog(start, end))\n+              }\n+              .map { result =>\n+                if (result.length < end - start) {\n+                  val missing = TreeSet(start until end: _*) -- result.map(_._1)\n+                  Source.failed(\n+                    new IllegalStateException(s\"Missing entries: ${missing.mkString(\", \")}\"))\n+                } else {\n+                  Source(result)\n+                }\n+              })\n+            .mapMaterializedValue(_ => NotUsed)\n         }),\n       )\n       .map { case (_, record) => record }\n \n   override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n     withEnrichedLoggingContext(\"correlationId\" -> correlationId) { implicit logCtx =>\n-      Future {"
  },
  {
    "id" : "9c878c7e-86b4-41dc-b9e5-9242eee98f64",
    "prId" : 4177,
    "comments" : [
      {
        "id" : "05390c3d-71cf-4fbb-b848-cc0071a4fe6c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Always using `StartIndex` for `headAtInitialization` will break when starting the ledger with a non-empty non-in-memory database, but it's probably good enough for now.",
        "createdAt" : "2020-01-23T12:51:21Z",
        "updatedAt" : "2020-01-23T13:59:44Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f7768c50-9993-4ae8-98a8-1eb99a66d597",
        "parentId" : "05390c3d-71cf-4fbb-b848-cc0071a4fe6c",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Oh, good point, this'll be me not understanding the API correctly. Will fix in a different PR.",
        "createdAt" : "2020-01-23T13:57:01Z",
        "updatedAt" : "2020-01-23T13:59:44Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4e114137-668c-4929-97cd-5ab900800f3d",
        "parentId" : "05390c3d-71cf-4fbb-b848-cc0071a4fe6c",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I think it'd be good to have a conformance test that somehow restarts the ledger and makes sure everything is A-OK.",
        "createdAt" : "2020-01-23T13:58:25Z",
        "updatedAt" : "2020-01-23T13:59:44Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "47a82a5f-576c-4bfe-944d-70906ef52f79",
        "parentId" : "05390c3d-71cf-4fbb-b848-cc0071a4fe6c",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "That's not a conformance/ledger api test though, because we cannot remotely restart the ledger. But +1 on having such a test specifically for the KV SQL Ledger.",
        "createdAt" : "2020-01-23T15:54:06Z",
        "updatedAt" : "2020-01-23T15:54:07Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b9b2205d-8763-4e34-b62b-da0b372be408",
        "parentId" : "05390c3d-71cf-4fbb-b848-cc0071a4fe6c",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "The conformance test Bazel task knows how to start and stop the ledger, and therefore how to restart it. :-)",
        "createdAt" : "2020-01-23T15:58:45Z",
        "updatedAt" : "2020-01-23T15:58:46Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e8a324dd393a841e950e02d5e3e659caa3a9a9d4",
    "line" : 86,
    "diffHunk" : "@@ -214,24 +203,32 @@ class SqlLedgerReaderWriter(\n }\n \n object SqlLedgerReaderWriter {\n-  val FirstIndex: Index = 1\n+  val StartIndex: Index = 1\n \n-  private val FirstOffset: Offset = Offset(Array(FirstIndex))\n+  private val StartOffset: Offset = Offset(Array(StartIndex))\n \n-  def apply(\n+  def owner(\n       ledgerId: LedgerId,\n       participantId: ParticipantId,\n       jdbcUrl: String,\n   )(\n       implicit executionContext: ExecutionContext,\n       materializer: Materializer,\n       logCtx: LoggingContext,\n-  ): Future[SqlLedgerReaderWriter] =\n-    Future {\n-      val database = Database(jdbcUrl)\n-      new SqlLedgerReaderWriter(ledgerId, participantId, database)\n-    }.map { ledger =>\n-      ledger.migrate()\n-      ledger\n+  ): ResourceOwner[SqlLedgerReaderWriter] =\n+    for {\n+      dispatcher <- ResourceOwner.forCloseable(\n+        () =>\n+          Dispatcher(\n+            \"sql-participant-state\",\n+            zeroIndex = StartIndex,\n+            headAtInitialization = StartIndex,"
  },
  {
    "id" : "02448d60-26bc-4973-9653-a5a3e0dc6a9e",
    "prId" : 4155,
    "comments" : [
      {
        "id" : "729c69e1-e999-4577-ad52-58852e9c7a33",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n    logCtx: LoggingContext,\r\n```",
        "createdAt" : "2020-01-22T12:46:29Z",
        "updatedAt" : "2020-01-22T15:12:07Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d414ebd72f813c239463a48e245fc2e9fd9c0c8",
    "line" : null,
    "diffHunk" : "@@ -26,27 +25,36 @@ import com.digitalasset.daml.lf.data.Ref\n import com.digitalasset.daml.lf.data.Time.Timestamp\n import com.digitalasset.daml.lf.engine.Engine\n import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.logging.LoggingContext.withEnrichedLoggingContext\n+import com.digitalasset.logging.{ContextualizedLogger, LoggingContext}\n import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n import com.digitalasset.platform.akkastreams.dispatcher.SubSource.RangeSource\n import com.google.protobuf.ByteString\n-import com.zaxxer.hikari.{HikariConfig, HikariDataSource}\n import javax.sql.DataSource\n \n import scala.collection.JavaConverters._\n+import scala.collection.immutable.TreeSet\n import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.control.NonFatal\n \n class SqlLedgerReaderWriter(\n     ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n     val participantId: ParticipantId,\n-    queries: Queries,\n-    connectionSource: DataSource with AutoCloseable,\n-)(implicit executionContext: ExecutionContext, materializer: Materializer)\n-    extends LedgerWriter\n+    database: Database,\n+)(\n+    implicit executionContext: ExecutionContext,\n+    materializer: Materializer,\n+    loggingContext: LoggingContext,"
  },
  {
    "id" : "41baec31-dae7-4741-9c35-58bd43e9bef8",
    "prId" : 4155,
    "comments" : [
      {
        "id" : "6c2ec5f3-82c6-405e-ac3d-fd2da2c6103b",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n    withEnrichedLoggingContext(\"correlationId\" -> correlationId) { implicit logCtx =>\r\n```",
        "createdAt" : "2020-01-22T12:47:18Z",
        "updatedAt" : "2020-01-22T15:12:07Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d414ebd72f813c239463a48e245fc2e9fd9c0c8",
    "line" : null,
    "diffHunk" : "@@ -69,39 +77,46 @@ class SqlLedgerReaderWriter(\n       .startingAt(\n         offset.getOrElse(FirstOffset).components.head,\n         RangeSource((start, end) =>\n-          withDatabaseStream { implicit connection =>\n-            Source(queries.selectFromLog(start, end))\n+          withEnrichedLoggingContext(\"start\" -> start, \"end\" -> end) { implicit loggingContext =>\n+            val result = inDatabaseReadTransaction(\"Querying events from log\") {\n+              implicit connection =>\n+                queries.selectFromLog(start, end)\n+            }\n+            if (result.length < end - start) {\n+              val missing = TreeSet(start until end: _*) -- result.map(_._1)\n+              Source.failed(\n+                new IllegalStateException(s\"Missing entries: ${missing.mkString(\", \")}\"))\n+            } else {\n+              Source(result)\n+            }\n         })\n       )\n       .map { case (_, record) => record }\n \n   override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n-    inDatabaseTransaction { implicit connection =>\n+    withEnrichedLoggingContext(\"correlationId\" -> correlationId) { implicit loggingContext =>"
  },
  {
    "id" : "8f4632d6-b541-4b41-970c-09bf0c17b0bc",
    "prId" : 4155,
    "comments" : [
      {
        "id" : "c4c74376-52f9-4055-b3b8-38fdf4b620de",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n  )(implicit logCtx: LoggingContext): T = {\r\n```",
        "createdAt" : "2020-01-22T12:48:35Z",
        "updatedAt" : "2020-01-22T15:12:07Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d414ebd72f813c239463a48e245fc2e9fd9c0c8",
    "line" : null,
    "diffHunk" : "@@ -133,42 +161,57 @@ class SqlLedgerReaderWriter(\n       .result()\n   }\n \n-  private def migrate(): Future[Unit] =\n-    inDatabaseTransaction { implicit connection =>\n-      Future\n-        .sequence(\n-          Seq(\n-            Future(queries.createLogTable()),\n-            Future(queries.createStateTable()),\n-          ))\n-        .map(_ => ())\n+  private def migrate(): Unit = {\n+    inDatabaseWriteTransaction(\"Migrating the database\") { implicit connection =>\n+      queries.createLogTable()\n+      queries.createStateTable()\n     }\n+  }\n+\n+  private def inDatabaseReadTransaction[T](message: String)(\n+      body: Connection => T,\n+  )(implicit loggingContext: LoggingContext): T = {\n+    inDatabaseTransaction(message, database.readerConnectionPool)(body)\n+  }\n+\n+  private def inDatabaseWriteTransaction[T](message: String)(\n+      body: Connection => T,\n+  )(implicit loggingContext: LoggingContext): T = {\n+    inDatabaseTransaction(message, database.writerConnectionPool)(body)\n+  }\n \n-  private def inDatabaseTransaction[T](body: Connection => Future[T]): Future[T] = {\n-    val connection = connectionSource.getConnection()\n-    body(connection).transform(\n-      value => {\n+  private def inDatabaseTransaction[T](\n+      message: String,\n+      connectionPool: DataSource,\n+  )(\n+      body: Connection => T,\n+  )(implicit loggingContext: LoggingContext): T = {"
  },
  {
    "id" : "dc646714-12d7-421b-aa50-0496f3563d0e",
    "prId" : 4155,
    "comments" : [
      {
        "id" : "fe8782d5-bd13-41ee-a699-ba33dded03bf",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "```suggestion\r\n          withEnrichedLoggingContext(\"start\" -> start, \"end\" -> end) { implicit logCtx =>\r\n```",
        "createdAt" : "2020-01-22T13:02:38Z",
        "updatedAt" : "2020-01-22T15:12:07Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab84c4c6-ca0f-4f66-8fb6-76356b8fa3aa",
        "parentId" : "fe8782d5-bd13-41ee-a699-ba33dded03bf",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Fixed all of these.",
        "createdAt" : "2020-01-22T14:04:15Z",
        "updatedAt" : "2020-01-22T15:12:07Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d414ebd72f813c239463a48e245fc2e9fd9c0c8",
    "line" : null,
    "diffHunk" : "@@ -69,39 +77,46 @@ class SqlLedgerReaderWriter(\n       .startingAt(\n         offset.getOrElse(FirstOffset).components.head,\n         RangeSource((start, end) =>\n-          withDatabaseStream { implicit connection =>\n-            Source(queries.selectFromLog(start, end))\n+          withEnrichedLoggingContext(\"start\" -> start, \"end\" -> end) { implicit loggingContext =>"
  },
  {
    "id" : "c95b87ad-325e-4952-93f5-28531b4ff1c9",
    "prId" : 4155,
    "comments" : [
      {
        "id" : "4d22c154-3759-4333-a3c9-819f78156283",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Excellent solution! :+1: ",
        "createdAt" : "2020-01-22T14:22:37Z",
        "updatedAt" : "2020-01-22T15:12:07Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6d414ebd72f813c239463a48e245fc2e9fd9c0c8",
    "line" : 68,
    "diffHunk" : "@@ -68,40 +77,45 @@ class SqlLedgerReaderWriter(\n     dispatcher\n       .startingAt(\n         offset.getOrElse(FirstOffset).components.head,\n-        RangeSource((start, end) =>\n-          withDatabaseStream { implicit connection =>\n-            Source(queries.selectFromLog(start, end))\n+        RangeSource((start, end) => {\n+          val result = inDatabaseReadTransaction(s\"Querying events [$start, $end[ from log\") {"
  },
  {
    "id" : "561cd3d1-8ee8-439c-af62-ff1a761afb74",
    "prId" : 3940,
    "comments" : [
      {
        "id" : "11d1af3e-adf2-40da-95ab-e5a25d0b11e4",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "This assertion should move into `processSubmission` here and removed from here and from the other places that have this copied (file, in-memory).",
        "createdAt" : "2020-01-06T09:33:16Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "339d20ab-cb98-4cac-911d-d7d77f5ec7bd",
        "parentId" : "11d1af3e-adf2-40da-95ab-e5a25d0b11e4",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Agreed, just wanted to discuss this with you and @miklos-da first.",
        "createdAt" : "2020-01-06T09:42:38Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f944d69e-b1e1-47f3-82c2-29a07a5b1e85",
        "parentId" : "11d1af3e-adf2-40da-95ab-e5a25d0b11e4",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "I have added a ticket to track this work in the FCL Jira.",
        "createdAt" : "2020-01-15T13:15:12Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54297f1691f54ac9cff06e5a3d56297e6e32b48b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.sql\n+\n+import java.sql.Connection\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.sql.SqlLedgerReaderWriter._\n+import com.daml.ledger.on.sql.queries.Queries\n+import com.daml.ledger.on.sql.queries.Queries.Index\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.RangeSource\n+import com.google.protobuf.ByteString\n+import com.zaxxer.hikari.{HikariConfig, HikariDataSource}\n+import javax.sql.DataSource\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.Random\n+\n+class SqlLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId,\n+    queries: Queries,\n+    connectionSource: DataSource with AutoCloseable,\n+)(implicit executionContext: ExecutionContext, materializer: Materializer)\n+    extends LedgerWriter\n+    with LedgerReader\n+    with AutoCloseable {\n+\n+  private val engine = Engine()\n+\n+  private val dispatcher: Dispatcher[Index] =\n+    Dispatcher(\n+      \"sql-participant-state\",\n+      zeroIndex = FirstIndex,\n+      headAtInitialization = FirstIndex,\n+    )\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  // TODO: implement\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = {\n+    dispatcher.close()\n+    connectionSource.close()\n+  }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset.getOrElse(FirstOffset).components.head,\n+        RangeSource((start, end) =>\n+          withConnection { implicit connection =>\n+            Future(Source(queries.selectFromLog(start, end)))\n+        })\n+      )\n+      .map { case (_, record) => record }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    withConnection { implicit connection =>\n+      Future {\n+        val submission = Envelope\n+          .openSubmission(envelope)\n+          .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+        val stateInputKeys: Set[DamlStateKey] = submission.getInputDamlStateList.asScala.toSet\n+        val stateInputs = readState(stateInputKeys)\n+        val entryId = allocateEntryId()\n+        val (logEntry, stateUpdates) = KeyValueCommitting.processSubmission(\n+          engine,\n+          entryId,\n+          currentRecordTime(),\n+          LedgerReader.DefaultTimeModel,\n+          submission,\n+          participantId,\n+          stateInputs,\n+        )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(stateUpdates, entryId, submission)"
  },
  {
    "id" : "6bb0119f-2411-4b16-ae5c-eebd463f84ce",
    "prId" : 3940,
    "comments" : [
      {
        "id" : "cddbcdff-4b34-4f47-b626-f53f0fcb0de4",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "kvutils should probably provide a canonical way to allocate a random entry id with enough entropy. This way of allocating doesn't provide enough entropy. For the in-memory and SQL implementations we might want to consider just allocating the ids sequentially.\r\n\r\nkvutils also doesn't currently declare the outputs as inputs and hence does not check for conflicts on outputs itself (e.g. we might end up overwriting an existing log entry!). We might want to consider doing this check in kvutils itself. FYI @miklos-da.\r\n\r\n",
        "createdAt" : "2020-01-06T09:37:52Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b3b90a4c-ff26-4654-9c26-44809b5cdb07",
        "parentId" : "cddbcdff-4b34-4f47-b626-f53f0fcb0de4",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "It does have the downside that we end up doing more fetches for keys that we expect not to exist and depending on the ledger we might have other options for detecting the conflict (e.g. allocating entry ids in a conflict free way).",
        "createdAt" : "2020-01-06T09:39:54Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8f1fe199-105c-4efd-91b4-28ba36c2c9b1",
        "parentId" : "cddbcdff-4b34-4f47-b626-f53f0fcb0de4",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "You're right about just using sequential IDs here. Will fix at some point.",
        "createdAt" : "2020-01-06T09:44:01Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1f8808aa-6dad-4f2a-a4a9-f1b5a32782fc",
        "parentId" : "cddbcdff-4b34-4f47-b626-f53f0fcb0de4",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Regarding the checks, I think it's a good idea. Perhaps the implementation can decide whether to add it to the list of inputs or not.",
        "createdAt" : "2020-01-06T09:44:39Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54297f1691f54ac9cff06e5a3d56297e6e32b48b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.sql\n+\n+import java.sql.Connection\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.sql.SqlLedgerReaderWriter._\n+import com.daml.ledger.on.sql.queries.Queries\n+import com.daml.ledger.on.sql.queries.Queries.Index\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.RangeSource\n+import com.google.protobuf.ByteString\n+import com.zaxxer.hikari.{HikariConfig, HikariDataSource}\n+import javax.sql.DataSource\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.Random\n+\n+class SqlLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId,\n+    queries: Queries,\n+    connectionSource: DataSource with AutoCloseable,\n+)(implicit executionContext: ExecutionContext, materializer: Materializer)\n+    extends LedgerWriter\n+    with LedgerReader\n+    with AutoCloseable {\n+\n+  private val engine = Engine()\n+\n+  private val dispatcher: Dispatcher[Index] =\n+    Dispatcher(\n+      \"sql-participant-state\",\n+      zeroIndex = FirstIndex,\n+      headAtInitialization = FirstIndex,\n+    )\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  // TODO: implement\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = {\n+    dispatcher.close()\n+    connectionSource.close()\n+  }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset.getOrElse(FirstOffset).components.head,\n+        RangeSource((start, end) =>\n+          withConnection { implicit connection =>\n+            Future(Source(queries.selectFromLog(start, end)))\n+        })\n+      )\n+      .map { case (_, record) => record }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    withConnection { implicit connection =>\n+      Future {\n+        val submission = Envelope\n+          .openSubmission(envelope)\n+          .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+        val stateInputKeys: Set[DamlStateKey] = submission.getInputDamlStateList.asScala.toSet\n+        val stateInputs = readState(stateInputKeys)\n+        val entryId = allocateEntryId()\n+        val (logEntry, stateUpdates) = KeyValueCommitting.processSubmission(\n+          engine,\n+          entryId,\n+          currentRecordTime(),\n+          LedgerReader.DefaultTimeModel,\n+          submission,\n+          participantId,\n+          stateInputs,\n+        )\n+        verifyStateUpdatesAgainstPreDeclaredOutputs(stateUpdates, entryId, submission)\n+        val newHead = appendLog(entryId, Envelope.enclose(logEntry))\n+        queries.updateState(stateUpdates)\n+        dispatcher.signalNewHead(newHead)\n+        SubmissionResult.Acknowledged\n+      }\n+    }\n+\n+  private def verifyStateUpdatesAgainstPreDeclaredOutputs(\n+      actualStateUpdates: Map[DamlStateKey, DamlStateValue],\n+      entryId: DamlLogEntryId,\n+      submission: DamlSubmission,\n+  ): Unit = {\n+    val expectedStateUpdates = KeyValueCommitting.submissionOutputs(entryId, submission)\n+    if (!(actualStateUpdates.keySet subsetOf expectedStateUpdates)) {\n+      val unaccountedKeys = actualStateUpdates.keySet diff expectedStateUpdates\n+      sys.error(\n+        s\"CommitActor: State updates not a subset of expected updates! Keys [$unaccountedKeys] are unaccounted for!\")\n+    }\n+  }\n+\n+  private def currentRecordTime(): Timestamp =\n+    Timestamp.assertFromInstant(Clock.systemUTC().instant())\n+\n+  private def allocateEntryId(): DamlLogEntryId = {\n+    val nonce: Array[Byte] = Array.ofDim(8)"
  },
  {
    "id" : "8c5ed970-7f7d-4042-b846-269cb0d49682",
    "prId" : 3940,
    "comments" : [
      {
        "id" : "00d7a930-ec60-4a49-91a3-010267440397",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "The operations below (read / update state) should be performed in a single transaction.",
        "createdAt" : "2020-01-07T10:01:06Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "39a36f66-2d6f-4a4b-8cdd-789f74261f04",
        "parentId" : "00d7a930-ec60-4a49-91a3-010267440397",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "They are. We `setAutoCommit(false)` below, which means everything happens in a transaction. Acquiring the connection starts the transaction, and closing it implicitly commits. I'm not a big fan of implicit behavior, so [`withConnection`](https://github.com/digital-asset/daml/pull/3940/files#diff-9f45aadbe621258428069b8880a87344R160) explicitly commits if all goes well. It also catches exceptions and explicitly rolls back.",
        "createdAt" : "2020-01-13T09:41:14Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fc9b87a5-fea7-4d06-87ad-1bce97894e26",
        "parentId" : "00d7a930-ec60-4a49-91a3-010267440397",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Let's rename this to `inTransaction`.",
        "createdAt" : "2020-01-13T10:54:59Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0c64d3cb-8192-4411-8cf1-2b44e8a71f19",
        "parentId" : "00d7a930-ec60-4a49-91a3-010267440397",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'd suggest adding `DB` or `Database` (e.g. `inDbTransaction`) to the name as well. There are enough different kinds of transactions that warrant making it super clear which one is meant.",
        "createdAt" : "2020-01-13T15:49:57Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "41fce224-87d8-4e2d-9c89-49bf714d8c64",
        "parentId" : "00d7a930-ec60-4a49-91a3-010267440397",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Thanks for the clarification regarding transactions @SamirTalwar.",
        "createdAt" : "2020-01-13T17:15:18Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "40d8dcbe-2daa-4a14-9efa-84232f1a80d8",
        "parentId" : "00d7a930-ec60-4a49-91a3-010267440397",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Renamed it to `inDatabaseTransaction`, and renamed the other `withConnection` to `withDatabaseStream`.",
        "createdAt" : "2020-01-15T10:17:51Z",
        "updatedAt" : "2020-01-15T14:19:40Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54297f1691f54ac9cff06e5a3d56297e6e32b48b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,221 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.sql\n+\n+import java.sql.Connection\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.sql.SqlLedgerReaderWriter._\n+import com.daml.ledger.on.sql.queries.Queries\n+import com.daml.ledger.on.sql.queries.Queries.Index\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.RangeSource\n+import com.google.protobuf.ByteString\n+import com.zaxxer.hikari.{HikariConfig, HikariDataSource}\n+import javax.sql.DataSource\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.util.Random\n+\n+class SqlLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId,\n+    queries: Queries,\n+    connectionSource: DataSource with AutoCloseable,\n+)(implicit executionContext: ExecutionContext, materializer: Materializer)\n+    extends LedgerWriter\n+    with LedgerReader\n+    with AutoCloseable {\n+\n+  private val engine = Engine()\n+\n+  private val dispatcher: Dispatcher[Index] =\n+    Dispatcher(\n+      \"sql-participant-state\",\n+      zeroIndex = FirstIndex,\n+      headAtInitialization = FirstIndex,\n+    )\n+\n+  private val randomNumberGenerator = new Random()\n+\n+  // TODO: implement\n+  override def checkHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = {\n+    dispatcher.close()\n+    connectionSource.close()\n+  }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset.getOrElse(FirstOffset).components.head,\n+        RangeSource((start, end) =>\n+          withConnection { implicit connection =>\n+            Future(Source(queries.selectFromLog(start, end)))\n+        })\n+      )\n+      .map { case (_, record) => record }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    withConnection { implicit connection =>"
  },
  {
    "id" : "65a62ae6-2310-448f-8a0c-c9ab53ebe5cc",
    "prId" : 3940,
    "comments" : [
      {
        "id" : "f8429627-ef44-40e3-b069-6f9166458c10",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "@dajmaki: should the `participantId` here not rather come from the submission itself? Especially if the committing process is a remote process that serves multiple participants.\r\nAnyway, it's not a problem right now, just wondering whether I am missing something.",
        "createdAt" : "2020-01-16T09:52:34Z",
        "updatedAt" : "2020-01-16T09:52:48Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "54297f1691f54ac9cff06e5a3d56297e6e32b48b",
    "line" : 98,
    "diffHunk" : "@@ -0,0 +1,208 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.ledger.on.sql\n+\n+import java.sql.Connection\n+import java.time.Clock\n+import java.util.UUID\n+\n+import akka.NotUsed\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.Source\n+import com.daml.ledger.on.sql.SqlLedgerReaderWriter._\n+import com.daml.ledger.on.sql.queries.Queries\n+import com.daml.ledger.on.sql.queries.Queries.Index\n+import com.daml.ledger.participant.state.kvutils.DamlKvutils.{\n+  DamlLogEntryId,\n+  DamlStateKey,\n+  DamlStateValue,\n+  DamlSubmission\n+}\n+import com.daml.ledger.participant.state.kvutils.api.{LedgerReader, LedgerRecord, LedgerWriter}\n+import com.daml.ledger.participant.state.kvutils.{Envelope, KeyValueCommitting}\n+import com.daml.ledger.participant.state.v1._\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.Time.Timestamp\n+import com.digitalasset.daml.lf.engine.Engine\n+import com.digitalasset.ledger.api.health.{HealthStatus, Healthy}\n+import com.digitalasset.platform.akkastreams.dispatcher.Dispatcher\n+import com.digitalasset.platform.akkastreams.dispatcher.SubSource.RangeSource\n+import com.google.protobuf.ByteString\n+import com.zaxxer.hikari.{HikariConfig, HikariDataSource}\n+import javax.sql.DataSource\n+\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+class SqlLedgerReaderWriter(\n+    ledgerId: LedgerId = Ref.LedgerString.assertFromString(UUID.randomUUID.toString),\n+    val participantId: ParticipantId,\n+    queries: Queries,\n+    connectionSource: DataSource with AutoCloseable,\n+)(implicit executionContext: ExecutionContext, materializer: Materializer)\n+    extends LedgerWriter\n+    with LedgerReader\n+    with AutoCloseable {\n+\n+  private val engine = Engine()\n+\n+  private val dispatcher: Dispatcher[Index] =\n+    Dispatcher(\n+      \"sql-participant-state\",\n+      zeroIndex = FirstIndex,\n+      headAtInitialization = FirstIndex,\n+    )\n+\n+  // TODO: implement\n+  override def currentHealth(): HealthStatus = Healthy\n+\n+  override def close(): Unit = {\n+    dispatcher.close()\n+    connectionSource.close()\n+  }\n+\n+  override def retrieveLedgerId(): LedgerId = ledgerId\n+\n+  override def events(offset: Option[Offset]): Source[LedgerRecord, NotUsed] =\n+    dispatcher\n+      .startingAt(\n+        offset.getOrElse(FirstOffset).components.head,\n+        RangeSource((start, end) =>\n+          withDatabaseStream { implicit connection =>\n+            Source(queries.selectFromLog(start, end))\n+        })\n+      )\n+      .map { case (_, record) => record }\n+\n+  override def commit(correlationId: String, envelope: Array[Byte]): Future[SubmissionResult] =\n+    inDatabaseTransaction { implicit connection =>\n+      Future {\n+        val submission = Envelope\n+          .openSubmission(envelope)\n+          .getOrElse(throw new IllegalArgumentException(\"Not a valid submission in envelope\"))\n+        val stateInputKeys: Set[DamlStateKey] = submission.getInputDamlStateList.asScala.toSet\n+        val stateInputs = readState(stateInputKeys)\n+        val entryId = queries.nextEntryId()\n+        val logEntryId =\n+          DamlLogEntryId\n+            .newBuilder()\n+            .setEntryId(ByteString.copyFromUtf8(entryId.toHexString))\n+            .build()\n+        val (logEntry, stateUpdates) = KeyValueCommitting.processSubmission(\n+          engine,\n+          logEntryId,\n+          currentRecordTime(),\n+          LedgerReader.DefaultConfiguration,\n+          submission,\n+          participantId,"
  }
]