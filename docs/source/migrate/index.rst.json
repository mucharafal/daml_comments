[
  {
    "id" : "3e70f27e-2a3d-4c1d-b4b4-552eafb1875a",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "3164b82f-2909-411b-b9a1-6d1c9f7e6595",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why can't we determine this from the manifest in the DAR?",
        "createdAt" : "2019-08-19T10:56:53Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "59a29d67-52df-4bed-94a5-f1309cc8b81b",
        "parentId" : "3164b82f-2909-411b-b9a1-6d1c9f7e6595",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Should be possible, I'll try to change it.",
        "createdAt" : "2019-08-19T13:47:03Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the"
  },
  {
    "id" : "8f60c68c-859e-4917-988e-3040916ff249",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "88e7f523-f476-465e-a808-ff33d9d866b0",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does `daml migrate` generate `build.sh`?",
        "createdAt" : "2019-08-19T10:58:05Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f79f76f0-571f-4bc9-bd76-7ecd14d3226d",
        "parentId" : "88e7f523-f476-465e-a808-ff33d9d866b0",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "yes.",
        "createdAt" : "2019-08-19T11:26:10Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fbfe4d7d-2fee-4869-bb93-ad643c26c8af",
        "parentId" : "88e7f523-f476-465e-a808-ff33d9d866b0",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "no :P. I just tried it out and got the `.daml` files, but no build scripts.",
        "createdAt" : "2019-08-19T12:25:26Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : 41,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh"
  },
  {
    "id" : "c1e9c93f-a575-4363-a575-0934072eb256",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "8aaf259b-21e8-4879-ae26-e81abbd6f8f1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why does `daml build` not work? Can you please give a short explanation? Can we maybe actually make it work?",
        "createdAt" : "2019-08-19T10:58:35Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "51620989-e040-49ea-8c22-d3a3b69eb5af",
        "parentId" : "8aaf259b-21e8-4879-ae26-e81abbd6f8f1",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "`daml build` will initialize the package db from the given .dar dependencies. However, we want to generate the interface files from the .dars and put those into the package db. This is done during the `migrate` command. If you call `daml build` you will overwrite them again.",
        "createdAt" : "2019-08-19T11:27:05Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c20189fc-5b90-49c3-97b3-806ee66c7a98",
        "parentId" : "8aaf259b-21e8-4879-ae26-e81abbd6f8f1",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Does that mean `daml build` will bork the migration project? If so, we should fix that.",
        "createdAt" : "2019-08-19T12:25:59Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : 43,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual"
  },
  {
    "id" : "5f05a34d-45a3-4c79-b056-e41b6a5785f4",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "88c946b6-b9f7-4097-bcb1-fc65c0c2b560",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should put this in a separate file and use an include directive. I'm afraid the code will stop working at some point otherwise. Same below.",
        "createdAt" : "2019-08-19T10:59:51Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual\n+``daml build`` command to build the migration project.\n+\n+How migrations work and when it is necessary to write code manually\n+-------------------------------------------------------------------\n+\n+It is important to understand that the ``daml migrate`` command will not always succeed in\n+generating a migration project that will compile. To understand why, let's assume that the\n+``foo-1.0.0`` consists of a single module:\n+\n+.. code-block:: shell\n+\n+  foo-1.0.0\n+  ├── daml\n+  │   └── Foo.daml\n+  ├── daml.yaml\n+  └── ui-backend.conf\n+\n+where the ``Foo.daml`` file contains\n+\n+.. code-block:: daml"
  },
  {
    "id" : "8e450696-65a0-455b-bc0a-546d7ac14448",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "187e5646-046a-42da-92b2-6a76af662e79",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "As soon as `sigs` contains more than one party calling this choice needs another template to collect the signatures. We should generate that one as well. We should also base as much of this as possible on generic templates in the near future.",
        "createdAt" : "2019-08-19T11:04:36Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "52d551db-a0a0-4bd5-abf3-e153c17e0f70",
        "parentId" : "187e5646-046a-42da-92b2-6a76af662e79",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Agreed on the generic templates. I think we need some input anyways on how these upgrade templates should look like and what authorization they should have.",
        "createdAt" : "2019-08-19T11:31:14Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c9e9a37c-3f18-432a-aa7b-3f12badb7dcb",
        "parentId" : "187e5646-046a-42da-92b2-6a76af662e79",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "yes, we should include a workflow to collect signatures, either via generic templates, or by generating an `UpgradeAgreement` template, which collects signatures and has non-consuming choices for `op` to create and  trigger `Upgrade` on any of the generated templates.",
        "createdAt" : "2019-08-19T12:28:33Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual\n+``daml build`` command to build the migration project.\n+\n+How migrations work and when it is necessary to write code manually\n+-------------------------------------------------------------------\n+\n+It is important to understand that the ``daml migrate`` command will not always succeed in\n+generating a migration project that will compile. To understand why, let's assume that the\n+``foo-1.0.0`` consists of a single module:\n+\n+.. code-block:: shell\n+\n+  foo-1.0.0\n+  ├── daml\n+  │   └── Foo.daml\n+  ├── daml.yaml\n+  └── ui-backend.conf\n+\n+where the ``Foo.daml`` file contains\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+The package ``foo-2.0.0`` contains exactly the same modules, but a new template ``Bar`` has been\n+added to the ``Foo`` module.\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+  template Bar\n+    with\n+      t : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+If we generate a migration project with ``daml migrate`` as above, the directory contents of the\n+``foo-2.0.0-upgrade/daml`` directory is\n+\n+.. code-block:: shell\n+\n+  daml\n+  ├── FooAInstances.daml\n+  ├── FooBInstances.daml\n+  └── Foo.daml\n+\n+For every template that was defined in the module ``Foo`` in the ``foo-1.0.0`` package, you will\n+find two new templates. One to upgrade contract instances of this template to the changed template\n+defined in the module ``Foo`` in the package ``foo-2.0.0`` and one to rollback the process. Here is\n+an example:\n+\n+.. code-block:: daml\n+\n+   template FooUpgrade\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Upgrade: ContractId B.Foo\n+            with\n+                inC : ContractId A.Foo\n+                sigs : [Party]\n+            controller sigs"
  },
  {
    "id" : "c5b2c198-ebb1-4b87-a7e7-b02d5201f969",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "b94feeb9-2713-4c42-8ab1-81ec20c289e3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We need an explanation aiming at our users intuition here.",
        "createdAt" : "2019-08-19T11:09:05Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : 106,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual\n+``daml build`` command to build the migration project.\n+\n+How migrations work and when it is necessary to write code manually\n+-------------------------------------------------------------------\n+\n+It is important to understand that the ``daml migrate`` command will not always succeed in\n+generating a migration project that will compile. To understand why, let's assume that the\n+``foo-1.0.0`` consists of a single module:\n+\n+.. code-block:: shell\n+\n+  foo-1.0.0\n+  ├── daml\n+  │   └── Foo.daml\n+  ├── daml.yaml\n+  └── ui-backend.conf\n+\n+where the ``Foo.daml`` file contains\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+The package ``foo-2.0.0`` contains exactly the same modules, but a new template ``Bar`` has been\n+added to the ``Foo`` module.\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+  template Bar\n+    with\n+      t : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+If we generate a migration project with ``daml migrate`` as above, the directory contents of the\n+``foo-2.0.0-upgrade/daml`` directory is\n+\n+.. code-block:: shell\n+\n+  daml\n+  ├── FooAInstances.daml\n+  ├── FooBInstances.daml\n+  └── Foo.daml\n+\n+For every template that was defined in the module ``Foo`` in the ``foo-1.0.0`` package, you will\n+find two new templates. One to upgrade contract instances of this template to the changed template\n+defined in the module ``Foo`` in the package ``foo-2.0.0`` and one to rollback the process. Here is\n+an example:\n+\n+.. code-block:: daml\n+\n+   template FooUpgrade\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Upgrade: ContractId B.Foo\n+            with\n+                inC : ContractId A.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+   template FooRollback\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Rollback: ContractId A.Foo\n+            with\n+                inC : ContractId B.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+Currently, we only support one upgrade/rollback contract template pair. In the future we might\n+extend the ``migrate`` command with different possible upgrade/rollback templates. The above\n+contract template offers a choice to input a contract instance defined in ``foo-1.0.0``, convert it\n+with the ``conv`` function and create a new one that follows the data type definition in\n+``foo-2.0.0``. The heart of the migration code is the ``conv`` function. It is defined in the DAML\n+standard library in the module ``DA.Upgrade`` and has the following type signature:\n+\n+.. code-block:: daml\n+\n+  conv : (Generic a repA, Generic b repB, Conv repA repB) => a -> b\n+\n+From its type signature you can see that it can convert any two data types that are instances of the\n+``Generic`` class and whose generic representation can be converted itself."
  },
  {
    "id" : "11d69860-446b-4da0-8c6b-cf8abbcf52d2",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "7b122053-5b77-48d8-a0f5-31f7c8b9781f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is there  are function called `isomorphic`? If not, we should change the formatting from code-like to italic.",
        "createdAt" : "2019-08-19T11:09:42Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "676626be-c408-4a84-8da4-63e8ac22df74",
        "parentId" : "7b122053-5b77-48d8-a0f5-31f7c8b9781f",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2019-08-19T13:24:07Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual\n+``daml build`` command to build the migration project.\n+\n+How migrations work and when it is necessary to write code manually\n+-------------------------------------------------------------------\n+\n+It is important to understand that the ``daml migrate`` command will not always succeed in\n+generating a migration project that will compile. To understand why, let's assume that the\n+``foo-1.0.0`` consists of a single module:\n+\n+.. code-block:: shell\n+\n+  foo-1.0.0\n+  ├── daml\n+  │   └── Foo.daml\n+  ├── daml.yaml\n+  └── ui-backend.conf\n+\n+where the ``Foo.daml`` file contains\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+The package ``foo-2.0.0`` contains exactly the same modules, but a new template ``Bar`` has been\n+added to the ``Foo`` module.\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+  template Bar\n+    with\n+      t : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+If we generate a migration project with ``daml migrate`` as above, the directory contents of the\n+``foo-2.0.0-upgrade/daml`` directory is\n+\n+.. code-block:: shell\n+\n+  daml\n+  ├── FooAInstances.daml\n+  ├── FooBInstances.daml\n+  └── Foo.daml\n+\n+For every template that was defined in the module ``Foo`` in the ``foo-1.0.0`` package, you will\n+find two new templates. One to upgrade contract instances of this template to the changed template\n+defined in the module ``Foo`` in the package ``foo-2.0.0`` and one to rollback the process. Here is\n+an example:\n+\n+.. code-block:: daml\n+\n+   template FooUpgrade\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Upgrade: ContractId B.Foo\n+            with\n+                inC : ContractId A.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+   template FooRollback\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Rollback: ContractId A.Foo\n+            with\n+                inC : ContractId B.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+Currently, we only support one upgrade/rollback contract template pair. In the future we might\n+extend the ``migrate`` command with different possible upgrade/rollback templates. The above\n+contract template offers a choice to input a contract instance defined in ``foo-1.0.0``, convert it\n+with the ``conv`` function and create a new one that follows the data type definition in\n+``foo-2.0.0``. The heart of the migration code is the ``conv`` function. It is defined in the DAML\n+standard library in the module ``DA.Upgrade`` and has the following type signature:\n+\n+.. code-block:: daml\n+\n+  conv : (Generic a repA, Generic b repB, Conv repA repB) => a -> b\n+\n+From its type signature you can see that it can convert any two data types that are instances of the\n+``Generic`` class and whose generic representation can be converted itself.\n+\n+The ``migrate`` command takes care of defining generic instances for all relevant data types in the\n+two packages. In our example, you'll find them in the files ``FooAInstances.daml`` and\n+``FooBInstances.daml``.\n+\n+Generic representations can be converted when they are ``isomorphic``. That means the corresponding"
  },
  {
    "id" : "88b4106f-8cb1-4f00-98ec-3091f22df020",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "3f9f2b7d-f69e-485c-b3ff-d54c9d176467",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "daml/Foo.daml` from which package?",
        "createdAt" : "2019-08-19T11:11:22Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2afb4e3b-5aad-47fb-92e9-93ff04d46f9b",
        "parentId" : "3f9f2b7d-f69e-485c-b3ff-d54c9d176467",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "of the migration project you're building. I'll add it.",
        "createdAt" : "2019-08-19T11:33:26Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual\n+``daml build`` command to build the migration project.\n+\n+How migrations work and when it is necessary to write code manually\n+-------------------------------------------------------------------\n+\n+It is important to understand that the ``daml migrate`` command will not always succeed in\n+generating a migration project that will compile. To understand why, let's assume that the\n+``foo-1.0.0`` consists of a single module:\n+\n+.. code-block:: shell\n+\n+  foo-1.0.0\n+  ├── daml\n+  │   └── Foo.daml\n+  ├── daml.yaml\n+  └── ui-backend.conf\n+\n+where the ``Foo.daml`` file contains\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+The package ``foo-2.0.0`` contains exactly the same modules, but a new template ``Bar`` has been\n+added to the ``Foo`` module.\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+  template Bar\n+    with\n+      t : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+If we generate a migration project with ``daml migrate`` as above, the directory contents of the\n+``foo-2.0.0-upgrade/daml`` directory is\n+\n+.. code-block:: shell\n+\n+  daml\n+  ├── FooAInstances.daml\n+  ├── FooBInstances.daml\n+  └── Foo.daml\n+\n+For every template that was defined in the module ``Foo`` in the ``foo-1.0.0`` package, you will\n+find two new templates. One to upgrade contract instances of this template to the changed template\n+defined in the module ``Foo`` in the package ``foo-2.0.0`` and one to rollback the process. Here is\n+an example:\n+\n+.. code-block:: daml\n+\n+   template FooUpgrade\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Upgrade: ContractId B.Foo\n+            with\n+                inC : ContractId A.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+   template FooRollback\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Rollback: ContractId A.Foo\n+            with\n+                inC : ContractId B.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+Currently, we only support one upgrade/rollback contract template pair. In the future we might\n+extend the ``migrate`` command with different possible upgrade/rollback templates. The above\n+contract template offers a choice to input a contract instance defined in ``foo-1.0.0``, convert it\n+with the ``conv`` function and create a new one that follows the data type definition in\n+``foo-2.0.0``. The heart of the migration code is the ``conv`` function. It is defined in the DAML\n+standard library in the module ``DA.Upgrade`` and has the following type signature:\n+\n+.. code-block:: daml\n+\n+  conv : (Generic a repA, Generic b repB, Conv repA repB) => a -> b\n+\n+From its type signature you can see that it can convert any two data types that are instances of the\n+``Generic`` class and whose generic representation can be converted itself.\n+\n+The ``migrate`` command takes care of defining generic instances for all relevant data types in the\n+two packages. In our example, you'll find them in the files ``FooAInstances.daml`` and\n+``FooBInstances.daml``.\n+\n+Generic representations can be converted when they are ``isomorphic``. That means the corresponding\n+data types defined in package ``foo-1.0.0`` and ``foo-2.0.0`` have exactly the same shape. For\n+example the following two data types are isomorphic:\n+\n+.. code-block:: daml\n+\n+  data Either a b = Left a | Right b\n+  data UpDown a b = Up a | Down b\n+\n+while the following data types are not\n+\n+.. code-block:: daml\n+\n+  data Either a b = Left a | Right b\n+  data Maybe a = Just a | Nothing\n+\n+When the package ``foo-2.0.0`` contains an extended data type of the ``Foo`` template that is not\n+isomorphic, the build will fail. For example, let's assume the ``Foo`` module in the ``foo-2.0.0``\n+package has been extended to\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      b : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+Here is typical error message in this case:\n+\n+.. code-block:: shell\n+\n+\n+  daml/Foo.daml:22:30: error:\n+  • Could not deduce (DA.Upgrade.Conv\n+  (DA.Generics.M1\n+  DA.Generics.S\n+  ('DA.Generics.MetaSel\n+  ('DA.Generics.MetaSel0\n+  ('Some \"p\")\n+  'DA.Generics.NoSourceUnpackedness\n+  'DA.Generics.NoSourceStrictness))\n+  (DA.Generics.Rec0 Party))\n+  (DA.Generics.S1\n+  ('DA.Generics.MetaSel\n+  ...\n+\n+The important hint is that the compiler is not able to deduce that our data type is an instance of\n+the ``DA.Upgrade.Conv`` class and hence not convertible. In this case you will have to add your own\n+upgrade/rollback templates to ``daml/Foo.daml``, that describe how to convert a contract of the"
  },
  {
    "id" : "2df62b87-54e7-4ef9-8124-ae02da41e6e7",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "9730c5ca-601c-4133-9c24-fc014da020e5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's please remove the last sentence. I can be misread as a promise.",
        "createdAt" : "2019-08-19T11:12:57Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f69a538d-4e50-4e42-a35a-902c47c17562",
        "parentId" : "9730c5ca-601c-4133-9c24-fc014da020e5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "ok",
        "createdAt" : "2019-08-19T11:33:38Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual\n+``daml build`` command to build the migration project.\n+\n+How migrations work and when it is necessary to write code manually\n+-------------------------------------------------------------------\n+\n+It is important to understand that the ``daml migrate`` command will not always succeed in\n+generating a migration project that will compile. To understand why, let's assume that the\n+``foo-1.0.0`` consists of a single module:\n+\n+.. code-block:: shell\n+\n+  foo-1.0.0\n+  ├── daml\n+  │   └── Foo.daml\n+  ├── daml.yaml\n+  └── ui-backend.conf\n+\n+where the ``Foo.daml`` file contains\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+The package ``foo-2.0.0`` contains exactly the same modules, but a new template ``Bar`` has been\n+added to the ``Foo`` module.\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+  template Bar\n+    with\n+      t : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+If we generate a migration project with ``daml migrate`` as above, the directory contents of the\n+``foo-2.0.0-upgrade/daml`` directory is\n+\n+.. code-block:: shell\n+\n+  daml\n+  ├── FooAInstances.daml\n+  ├── FooBInstances.daml\n+  └── Foo.daml\n+\n+For every template that was defined in the module ``Foo`` in the ``foo-1.0.0`` package, you will\n+find two new templates. One to upgrade contract instances of this template to the changed template\n+defined in the module ``Foo`` in the package ``foo-2.0.0`` and one to rollback the process. Here is\n+an example:\n+\n+.. code-block:: daml\n+\n+   template FooUpgrade\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Upgrade: ContractId B.Foo\n+            with\n+                inC : ContractId A.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+   template FooRollback\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Rollback: ContractId A.Foo\n+            with\n+                inC : ContractId B.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+Currently, we only support one upgrade/rollback contract template pair. In the future we might\n+extend the ``migrate`` command with different possible upgrade/rollback templates. The above\n+contract template offers a choice to input a contract instance defined in ``foo-1.0.0``, convert it\n+with the ``conv`` function and create a new one that follows the data type definition in\n+``foo-2.0.0``. The heart of the migration code is the ``conv`` function. It is defined in the DAML\n+standard library in the module ``DA.Upgrade`` and has the following type signature:\n+\n+.. code-block:: daml\n+\n+  conv : (Generic a repA, Generic b repB, Conv repA repB) => a -> b\n+\n+From its type signature you can see that it can convert any two data types that are instances of the\n+``Generic`` class and whose generic representation can be converted itself.\n+\n+The ``migrate`` command takes care of defining generic instances for all relevant data types in the\n+two packages. In our example, you'll find them in the files ``FooAInstances.daml`` and\n+``FooBInstances.daml``.\n+\n+Generic representations can be converted when they are ``isomorphic``. That means the corresponding\n+data types defined in package ``foo-1.0.0`` and ``foo-2.0.0`` have exactly the same shape. For\n+example the following two data types are isomorphic:\n+\n+.. code-block:: daml\n+\n+  data Either a b = Left a | Right b\n+  data UpDown a b = Up a | Down b\n+\n+while the following data types are not\n+\n+.. code-block:: daml\n+\n+  data Either a b = Left a | Right b\n+  data Maybe a = Just a | Nothing\n+\n+When the package ``foo-2.0.0`` contains an extended data type of the ``Foo`` template that is not\n+isomorphic, the build will fail. For example, let's assume the ``Foo`` module in the ``foo-2.0.0``\n+package has been extended to\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      b : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+Here is typical error message in this case:\n+\n+.. code-block:: shell\n+\n+\n+  daml/Foo.daml:22:30: error:\n+  • Could not deduce (DA.Upgrade.Conv\n+  (DA.Generics.M1\n+  DA.Generics.S\n+  ('DA.Generics.MetaSel\n+  ('DA.Generics.MetaSel0\n+  ('Some \"p\")\n+  'DA.Generics.NoSourceUnpackedness\n+  'DA.Generics.NoSourceStrictness))\n+  (DA.Generics.Rec0 Party))\n+  (DA.Generics.S1\n+  ('DA.Generics.MetaSel\n+  ...\n+\n+The important hint is that the compiler is not able to deduce that our data type is an instance of\n+the ``DA.Upgrade.Conv`` class and hence not convertible. In this case you will have to add your own\n+upgrade/rollback templates to ``daml/Foo.daml``, that describe how to convert a contract of the\n+template in question of package ``foo-1.0.0`` to one of ``foo-2.0.0`` and vice versa. For example\n+\n+.. code-block:: daml\n+\n+   template FooUpgrade\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Upgrade: ContractId B.Foo\n+            with\n+                inC : ContractId A.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ Foo with a = d.a; b = \"updated\"; p = d.p\n+\n+   template FooRollback\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Rollback: ContractId A.Foo\n+            with\n+                inC : ContractId B.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ Foo with a = d.a; p = d.p\n+\n+In a future iteration, we will also be able to automatically convert data types for which merely\n+embeddings/projections exists instead of full isomorphisms and the above example would compile\n+without further manual help.\n+\n+Deploying the migration\n+-----------------------\n+\n+Once you've succeeded building the ``foo-upgrade-2.0.0`` package you can deploy it on the ledger\n+together with the ``foo-2.0.0`` package. Optionally you can bundle it with the ``foo-2.0.0`` package\n+into a single DAML archive by running\n+\n+.. code-block:: shell\n+\n+  daml damlc merge-dars foo-2.0.0/.daml/dist/foo-2.0.0.dar foo-upgrade-2.0.0/.daml/dist/foo-upgrade-2.0.0.dar --package-name foo-2.0.0-with-upgrades.dar\n+\n+You find more information on how to deploy DAML archive packages :ref:`here <deploy-ref_index>` .\n+After the ``foo-upgrade-2.0.0`` package has been deployed on the ledger, there exists for every\n+contract defined in ``foo-1.0.0`` a DAML workflow with a choice to upgrade it to ``foo-2.0.0`` or\n+roll it back. A future iteration might add DAML triggers to carry out the upgrade process"
  },
  {
    "id" : "b7f3f63c-fb2a-48b7-b15d-3bca0ff35285",
    "prId" : 2579,
    "comments" : [
      {
        "id" : "5f36e154-4201-4f90-90d1-68dc1cbb88b6",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I think it would be much nicer if it went through with as much as possible, but left stubs for `Conv` instances that it can't automatically derive. So the user can open `Main.daml` and fill in those `cv` definitions.",
        "createdAt" : "2019-08-19T12:30:43Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "16f87d92-2911-433e-bab0-00aed3cc7fba",
        "parentId" : "5f36e154-4201-4f90-90d1-68dc1cbb88b6",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "it will add the templates, but it won't compile so you really just have to change the line containing the application of the `conv` function.",
        "createdAt" : "2019-08-19T13:54:41Z",
        "updatedAt" : "2019-08-19T14:04:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dc3f0616-394d-4499-a0d0-ddc6114559d8",
        "parentId" : "5f36e154-4201-4f90-90d1-68dc1cbb88b6",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I added a sentence to the docs.",
        "createdAt" : "2019-08-19T14:06:05Z",
        "updatedAt" : "2019-08-19T14:06:06Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "54b72adcb69cdf4f0bee89d30ed6e55f4c8b4fe2",
    "line" : 129,
    "diffHunk" : "@@ -0,0 +1,274 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Migrating DAML ledgers\n+######################\n+\n+Building migration projects\n+---------------------------\n+\n+When we want to replace a DAML package ``foo-1.0.0`` that is deployed on a DAML ledger with an\n+updated version, say ``foo-2.0.0``, we need to migrate all the existing contracts that are active\n+and whose templates are defined in either ``foo-1.0.0`` or whose template definition depends directly\n+or indirectly on data defined in ``foo-1.0.0``. To help a DAML deployment with this task, the DAML\n+assistant offers the command ``daml migrate``.\n+\n+The ``migrate`` command takes as inputs the package ``foo-1.0.0`` and its new version ``foo-2.0.0``\n+and creates a new project containing generated code to migrate contracts from ``foo-1.0.0`` to\n+``foo-2.0.0``. Run ``daml migrate --help`` to see its full usage description:\n+\n+.. code-block:: shell\n+\n+  Usage: daml migrate TARGET_PATH SOURCE FROM_PATH TO_PATH\n+\n+  Available options:\n+    TARGET_PATH              Path where the new project should be located\n+    SOURCE                   Path to the main source file ('source' entry of the\n+                             project configuration files of the input projects).\n+    FROM_PATH                Path to the dar-package from which to migrate from\n+    TO_PATH                  Path to the dar-package to which to migrate to\n+    -h,--help                Show this help text\n+\n+For example, to create a migration project from ``foo-1.0.0`` to ``foo-2.0.0`` run\n+\n+.. code-block:: shell\n+\n+  daml migrate foo-upgrade-2.0.0 daml/Foo.daml foo-1.0.0/.daml/dist/foo-1.0.0.dar foo-2.0.0/.daml/dist/foo-2.0.0.dar\n+\n+This generates a migration project in the directory ``foo-upgrade-2.0.0``. To build it, change\n+directory to ``foo-upgrade-2.0.0`` and run\n+\n+.. code-block:: shell\n+\n+  ./build.sh\n+\n+respectively ``.\\build.cmd`` if your on a Windows system.  Note that you can **not** use the usual\n+``daml build`` command to build the migration project.\n+\n+How migrations work and when it is necessary to write code manually\n+-------------------------------------------------------------------\n+\n+It is important to understand that the ``daml migrate`` command will not always succeed in\n+generating a migration project that will compile. To understand why, let's assume that the\n+``foo-1.0.0`` consists of a single module:\n+\n+.. code-block:: shell\n+\n+  foo-1.0.0\n+  ├── daml\n+  │   └── Foo.daml\n+  ├── daml.yaml\n+  └── ui-backend.conf\n+\n+where the ``Foo.daml`` file contains\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+The package ``foo-2.0.0`` contains exactly the same modules, but a new template ``Bar`` has been\n+added to the ``Foo`` module.\n+\n+.. code-block:: daml\n+\n+  daml 1.2\n+  module Foo where\n+\n+  template Foo\n+    with\n+      a : Int\n+      p : Party\n+    where\n+      signatory p\n+\n+  template Bar\n+    with\n+      t : Text\n+      p : Party\n+    where\n+      signatory p\n+\n+\n+If we generate a migration project with ``daml migrate`` as above, the directory contents of the\n+``foo-2.0.0-upgrade/daml`` directory is\n+\n+.. code-block:: shell\n+\n+  daml\n+  ├── FooAInstances.daml\n+  ├── FooBInstances.daml\n+  └── Foo.daml\n+\n+For every template that was defined in the module ``Foo`` in the ``foo-1.0.0`` package, you will\n+find two new templates. One to upgrade contract instances of this template to the changed template\n+defined in the module ``Foo`` in the package ``foo-2.0.0`` and one to rollback the process. Here is\n+an example:\n+\n+.. code-block:: daml\n+\n+   template FooUpgrade\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Upgrade: ContractId B.Foo\n+            with\n+                inC : ContractId A.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+   template FooRollback\n+    with\n+        op : Party\n+    where\n+        signatory op\n+        nonconsuming choice Rollback: ContractId A.Foo\n+            with\n+                inC : ContractId B.Foo\n+                sigs : [Party]\n+            controller sigs\n+                do\n+                    d <- fetch inC\n+                    assert $ fromList sigs == fromList (signatory d)\n+                    create $ conv d\n+\n+Currently, we only support one upgrade/rollback contract template pair. In the future we might\n+extend the ``migrate`` command with different possible upgrade/rollback templates. The above\n+contract template offers a choice to input a contract instance defined in ``foo-1.0.0``, convert it\n+with the ``conv`` function and create a new one that follows the data type definition in\n+``foo-2.0.0``. The heart of the migration code is the ``conv`` function. It is defined in the DAML\n+standard library in the module ``DA.Upgrade`` and has the following type signature:\n+\n+.. code-block:: daml\n+\n+  conv : (Generic a repA, Generic b repB, Conv repA repB) => a -> b\n+\n+From its type signature you can see that it can convert any two data types that are instances of the\n+``Generic`` class and whose generic representation can be converted itself.\n+\n+The ``migrate`` command takes care of defining generic instances for all relevant data types in the\n+two packages. In our example, you'll find them in the files ``FooAInstances.daml`` and\n+``FooBInstances.daml``.\n+\n+Generic representations can be converted when they are ``isomorphic``. That means the corresponding\n+data types defined in package ``foo-1.0.0`` and ``foo-2.0.0`` have exactly the same shape. For\n+example the following two data types are isomorphic:\n+\n+.. code-block:: daml\n+\n+  data Either a b = Left a | Right b\n+  data UpDown a b = Up a | Down b\n+\n+while the following data types are not\n+\n+.. code-block:: daml\n+\n+  data Either a b = Left a | Right b\n+  data Maybe a = Just a | Nothing\n+\n+When the package ``foo-2.0.0`` contains an extended data type of the ``Foo`` template that is not\n+isomorphic, the build will fail. For example, let's assume the ``Foo`` module in the ``foo-2.0.0``"
  }
]