[
  {
    "id" : "d138824b-ecbf-4ade-b3f1-5259565feed8",
    "prId" : 7609,
    "comments" : [
      {
        "id" : "4dc97500-500c-4364-ac4f-0a94d9ab23f2",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\nParty-specific requests, i.e., command submissions and queries, require a JWT with some additional restrictions compared to the the format :doc:`described in the Token Payload section here </tools/sandbox>`. For command submissions, the set of parties listed in ``actAs`` and ``readAs`` must contain exactly one party. Queries require at least one party (note that before SDK 1.7.0, queries also required exactly one party). In addition to that, the application id and ledger id are mandatory. HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol.\r\n```",
        "createdAt" : "2020-10-08T15:49:41Z",
        "updatedAt" : "2020-10-08T15:51:17Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c562311de6b15749b24c4f405a5b6b3149c33779",
    "line" : null,
    "diffHunk" : "@@ -138,7 +138,7 @@ If the token cannot be read from the provided path or the Ledger API reports an\n Party-specific Access Tokens\n ----------------------------\n \n-Party-specific requests, i.e., command submissions and queries, require a JWT with some additional restrictions compared to the the format :doc:`described in the Token Payload section here </tools/sandbox>`. The set of parties listed in `actAs` and `readAs` must contain exactly one party. In addition to that, the application id and ledger id are mandatory. HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol.\n+Party-specific requests, i.e., command submissions and queries, require a JWT with some additional restrictions compared to the the format :doc:`described in the Token Payload section here </tools/sandbox>`. For command submissions, The set of parties listed in `actAs` and `readAs` must contain exactly one party. Queries require at least one party (note that before SDK 1.7.0, queries also required exactly one party). In addition to that, the application id and ledger id are mandatory. HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol."
  },
  {
    "id" : "adc78aa4-ddc6-4975-b026-5c9ebfcbf83b",
    "prId" : 7480,
    "comments" : [
      {
        "id" : "fcb323e6-951c-4d9f-9a32-8c760a9155ac",
        "parentId" : null,
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "slightly confusing as not completely true anymore, JSON API provides some pkg management",
        "createdAt" : "2020-09-24T17:09:27Z",
        "updatedAt" : "2020-09-24T17:09:28Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8a091c52b9c6e52908f9f8e4d5eac38d9593d3ea",
    "line" : 4,
    "diffHunk" : "@@ -20,7 +20,6 @@ complicating concerns including, but not limited to:\n - inspecting transactions,\n - asynchronous submit/completion workflows,\n - temporal queries (e.g. active contracts *as of a certain time*), and\n-- ledger metaprogramming (e.g. retrieving packages and templates)."
  },
  {
    "id" : "9320c84d-f984-4a40-863b-cecd2b545b8b",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "b1f450db-1b4c-4e6c-a52d-d608001fff79",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "I actually think this is the most useful part of the doc :). I was planning to extend this section with `curl` examples showing how to submit a contract, exercise a choice and query the ACS:\r\n```\r\ncurl -X POST -H \"Authorization: Bearer $JWT\" -H \"Content-Type: application/json\" -d @./create.json http://localhost:7575/v1/create\r\n```\r\n\r\nBut I am fine removing this section if you think it should not be here.",
        "createdAt" : "2020-08-14T14:11:37Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f786db47-b3d4-4b21-9f9c-8975c33b10ba",
        "parentId" : "b1f450db-1b4c-4e6c-a52d-d608001fff79",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@anthonylusardi-da I like the rest of the changes. Thanks a lot!",
        "createdAt" : "2020-08-14T14:19:47Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1528020f-4fdf-414d-b99e-28428ce9f255",
        "parentId" : "b1f450db-1b4c-4e6c-a52d-d608001fff79",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "We still have all of this, it's just parted out differently\r\n\r\nhttps://github.com/digital-asset/daml/pull/7133/files/25338ca7845acd0a7b4b8857497a8a648ba9e39a#diff-acc1415ff18516eee3cce71dc3407d5cR50\r\n\r\nAgree adding `curl` examples would be a great addition.",
        "createdAt" : "2020-08-14T17:10:44Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "518395da-61aa-48b2-a00b-d6aba738c5ef",
        "parentId" : "b1f450db-1b4c-4e6c-a52d-d608001fff79",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "While outside of this PR we could put the curl examples after the Authorization with WebSockets section/before HTTP Status Codes. This should generally match the order of operations for people developing DAML applications.",
        "createdAt" : "2020-08-14T17:43:21Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2e7dc4b8-3cdf-4e5f-86b1-b3b89a70e164",
        "parentId" : "b1f450db-1b4c-4e6c-a52d-d608001fff79",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "sounds good!",
        "createdAt" : "2020-08-14T21:41:38Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : 148,
    "diffHunk" : "@@ -32,125 +32,96 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+Start a DAML Ledger\n+===================\n \n-From a DAML project directory:\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n \n-From a DAML project directory:\n+Basic\n+-----\n+\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization\n+================================\n \n-.. code-block:: shell\n+The Ledger API and JSON API use the terms Authentication and Authorization to describe different aspects of their operation.\n+While these terms may sound similar they mean different things.\n+\n+The JSON API essentially performs two separate tasks:\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575"
  },
  {
    "id" : "fb68840f-81a7-48d0-b85a-8faa1031e142",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "ad3e5ceb-e9e2-4234-936a-d0207bb53013",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\r\n```\r\nFollows the spelling nginx uses on their own website.",
        "createdAt" : "2020-08-17T06:47:51Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_."
  },
  {
    "id" : "9387e465-64b5-459e-91bc-0194344f93ed",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "b6748b76-08a8-491d-ac51-4f05e9a2d1d7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nYou can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\r\n```",
        "createdAt" : "2020-08-17T06:50:09Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:"
  },
  {
    "id" : "5cf1af0e-1de0-4eeb-afe1-cc50cac83859",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "b1af0853-1b2d-4286-b0d7-bb44e9c381cc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nThis will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\r\n```",
        "createdAt" : "2020-08-17T06:52:00Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``"
  },
  {
    "id" : "ac025b4c-fa18-4374-a2b2-7088bf7e075c",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "482c6ed5-20e6-4ea3-adea-eff22a68350a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t think this section is correct.\r\n1. Authentication isn’t handled by the ledger API. It is handled by your IAM, e.g., in our auth blogpost auth0 takes care of that.\r\n2. The tokens are called access tokens not authentication tokens and authorization tokens or at least I have never heard that being used and it doesn’t match what we use in https://docs.daml.com/app-dev/authorization.html.\r\n3. Related to that, I don’t understand why getting packages should be authentication and user requests are authorization. I think the crucial point here is that one request is initiated by the JSON API itself and it needs its own token for that (this needs documentation on which claims are required here) whereas the user-initiated requests just proxy the token from users.",
        "createdAt" : "2020-08-17T07:15:18Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7cd49734-971e-4a62-93f8-9c2b04fdb821",
        "parentId" : "482c6ed5-20e6-4ea3-adea-eff22a68350a",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "1. Fixed.\r\n2. This was an attempt to disambiguate which access token the docs are talking about as it's a regular source of confusion. In hindsight leveraging these terms was the wrong approach. Let me know if the new commit makes sense and if there's any other changes to this section.",
        "createdAt" : "2020-08-17T16:12:39Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization"
  },
  {
    "id" : "7b35d639-067c-431c-a4de-4b27e7438e5d",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "2f6a0eab-df04-4053-a975-f617be03ab23",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Meaning no claims, those are both public endpoints. You just need a valid token.",
        "createdAt" : "2020-08-17T07:16:08Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "71e22393-dd07-43c1-a680-cd8844cd238a",
        "parentId" : "2f6a0eab-df04-4053-a975-f617be03ab23",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Should I remove this then?\r\n```\r\nA token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\r\nPlease refer to your ledger operator's documentation to find out how.\r\n```",
        "createdAt" : "2020-08-17T16:14:17Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9d75fff7-fe48-4c55-99c2-c1b34a72fd7a",
        "parentId" : "2f6a0eab-df04-4053-a975-f617be03ab23",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Made a suggestion.",
        "createdAt" : "2020-08-18T06:57:47Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization\n+================================\n \n-.. code-block:: shell\n+The Ledger API and JSON API use the terms Authentication and Authorization to describe different aspects of their operation.\n+While these terms may sound similar they mean different things.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+The JSON API essentially performs two separate tasks:\n \n-Choosing a party\n-****************\n+1. It talks to the Ledger API to get data it needs to operate, for this it needs to may need to provide an *authentication token* to the Ledger API if the Ledger API requires *authentication*.\n+2. It handles the requests coming from one or more Parties, for this each party needs to provide an *authorization token* with each request it sends to the JSON API.\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+Authentication\n+--------------\n \n-In testing environments, you can use https://jwt.io to generate your\n+The authentication token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should an authentication token be provided to an end user, these are for internal use only.\n+\n+Every authentication token is different and will depend on what your specific ledger or ledger operator requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that."
  },
  {
    "id" : "85ed1d31-a085-4895-a1ae-fbda4f3f5991",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "99dcad1d-018f-476a-b26e-d25ddea7a285",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without restarting your JSON API service.\r\n```",
        "createdAt" : "2020-08-17T07:16:36Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization\n+================================\n \n-.. code-block:: shell\n+The Ledger API and JSON API use the terms Authentication and Authorization to describe different aspects of their operation.\n+While these terms may sound similar they mean different things.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+The JSON API essentially performs two separate tasks:\n \n-Choosing a party\n-****************\n+1. It talks to the Ledger API to get data it needs to operate, for this it needs to may need to provide an *authentication token* to the Ledger API if the Ledger API requires *authentication*.\n+2. It handles the requests coming from one or more Parties, for this each party needs to provide an *authorization token* with each request it sends to the JSON API.\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+Authentication\n+--------------\n \n-In testing environments, you can use https://jwt.io to generate your\n+The authentication token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should an authentication token be provided to an end user, these are for internal use only.\n+\n+Every authentication token is different and will depend on what your specific ledger or ledger operator requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without interrupting your JSON API service."
  },
  {
    "id" : "62f4ef0c-0113-4b02-9c05-01f7aceb3e28",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "32e881b1-692f-4393-ba66-f7cee8349ce2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "> As such each token format is ledger/implementation-specific and the below example reflects only the format that is used for the DAML Sandbox.\r\n\r\nThis is at least partially wrong. The JSON API doesn’t validate the token but it does decode it and extract the claims from it. That’s why you don’t have to specify the party, application id or ledger id when submitting a command via the JSON API. So while there can be additional fields that will be validated by the ledger, you need to have the standard format. In fact there are even more limitations: The JSON API requires `applicationId`, `ledgerId` and requires that the set of ``act_as `union` readAs`` contains exactly one party.",
        "createdAt" : "2020-08-17T07:20:10Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "33072610-6733-4cdc-8d8c-8f7ef0c0133d",
        "parentId" : "32e881b1-692f-4393-ba66-f7cee8349ce2",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Where does `readAs` come from?",
        "createdAt" : "2020-08-17T16:15:36Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization\n+================================\n \n-.. code-block:: shell\n+The Ledger API and JSON API use the terms Authentication and Authorization to describe different aspects of their operation.\n+While these terms may sound similar they mean different things.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+The JSON API essentially performs two separate tasks:\n \n-Choosing a party\n-****************\n+1. It talks to the Ledger API to get data it needs to operate, for this it needs to may need to provide an *authentication token* to the Ledger API if the Ledger API requires *authentication*.\n+2. It handles the requests coming from one or more Parties, for this each party needs to provide an *authorization token* with each request it sends to the JSON API.\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+Authentication\n+--------------\n \n-In testing environments, you can use https://jwt.io to generate your\n+The authentication token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should an authentication token be provided to an end user, these are for internal use only.\n+\n+Every authentication token is different and will depend on what your specific ledger or ledger operator requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without interrupting your JSON API service.\n+\n+Authorization\n+-------------\n+\n+Every request from a client to the JSON API requires you to specify a party and some other settings,\n+with a JWT token.  Normal HTTP requests pass the token in an ``Authorization`` header, \n+while WebSocket requests pass the token in a subprotocol.\n+\n+.. note:: While the JSON API receives the token it doesn't handle it itself. Upon receiving a token it will pass it on to the underlying Ledger's AuthService which will then determine if the token is valid and authorized. As such each token format is ledger/implementation-specific and the below example reflects only the format that is used for the DAML Sandbox."
  },
  {
    "id" : "4e79d5f0-34d2-4808-9d4e-c20ef069c6a9",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "6b4de755-0a68-4e16-9e37-ecfdfd21de70",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m not sure this is an improvement. This suggest that it is important that it has this specific value which is not the case.",
        "createdAt" : "2020-08-17T07:21:45Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization\n+================================\n \n-.. code-block:: shell\n+The Ledger API and JSON API use the terms Authentication and Authorization to describe different aspects of their operation.\n+While these terms may sound similar they mean different things.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+The JSON API essentially performs two separate tasks:\n \n-Choosing a party\n-****************\n+1. It talks to the Ledger API to get data it needs to operate, for this it needs to may need to provide an *authentication token* to the Ledger API if the Ledger API requires *authentication*.\n+2. It handles the requests coming from one or more Parties, for this each party needs to provide an *authorization token* with each request it sends to the JSON API.\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+Authentication\n+--------------\n \n-In testing environments, you can use https://jwt.io to generate your\n+The authentication token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should an authentication token be provided to an end user, these are for internal use only.\n+\n+Every authentication token is different and will depend on what your specific ledger or ledger operator requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without interrupting your JSON API service.\n+\n+Authorization\n+-------------\n+\n+Every request from a client to the JSON API requires you to specify a party and some other settings,\n+with a JWT token.  Normal HTTP requests pass the token in an ``Authorization`` header, \n+while WebSocket requests pass the token in a subprotocol.\n+\n+.. note:: While the JSON API receives the token it doesn't handle it itself. Upon receiving a token it will pass it on to the underlying Ledger's AuthService which will then determine if the token is valid and authorized. As such each token format is ledger/implementation-specific and the below example reflects only the format that is used for the DAML Sandbox.\n+\n+In the DAML Sandbox testing environment, you can use https://jwt.io to generate your\n token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n \n .. code-block:: json\n \n     {\n       \"https://daml.com/ledger-api\": {\n         \"ledgerId\": \"MyLedger\",\n-        \"applicationId\": \"foobar\",\n+        \"applicationId\": \"HTTP-JSON-API-Gateway\","
  },
  {
    "id" : "8be8a67f-e054-408b-89a7-01e4131cb3db",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "ba2e176c-88e7-44dc-91b1-e92855937761",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t think this is true. As far as I can tell the `applicationId` you pass in via the command line flag is just unused atm. It definitely doesn’t need to match the one in the token (I wrote a test for that last week).",
        "createdAt" : "2020-08-17T07:30:43Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6c62a563-3892-4b6c-97f6-a454d4bab097",
        "parentId" : "ba2e176c-88e7-44dc-91b1-e92855937761",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "If `applicationId` doesn't need to match anything that's pretty confusing for end users.\r\n\r\nI believe `ledgerId` needs to match the DAML Ledger though.",
        "createdAt" : "2020-08-17T13:37:38Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization\n+================================\n \n-.. code-block:: shell\n+The Ledger API and JSON API use the terms Authentication and Authorization to describe different aspects of their operation.\n+While these terms may sound similar they mean different things.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+The JSON API essentially performs two separate tasks:\n \n-Choosing a party\n-****************\n+1. It talks to the Ledger API to get data it needs to operate, for this it needs to may need to provide an *authentication token* to the Ledger API if the Ledger API requires *authentication*.\n+2. It handles the requests coming from one or more Parties, for this each party needs to provide an *authorization token* with each request it sends to the JSON API.\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+Authentication\n+--------------\n \n-In testing environments, you can use https://jwt.io to generate your\n+The authentication token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should an authentication token be provided to an end user, these are for internal use only.\n+\n+Every authentication token is different and will depend on what your specific ledger or ledger operator requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without interrupting your JSON API service.\n+\n+Authorization\n+-------------\n+\n+Every request from a client to the JSON API requires you to specify a party and some other settings,\n+with a JWT token.  Normal HTTP requests pass the token in an ``Authorization`` header, \n+while WebSocket requests pass the token in a subprotocol.\n+\n+.. note:: While the JSON API receives the token it doesn't handle it itself. Upon receiving a token it will pass it on to the underlying Ledger's AuthService which will then determine if the token is valid and authorized. As such each token format is ledger/implementation-specific and the below example reflects only the format that is used for the DAML Sandbox.\n+\n+In the DAML Sandbox testing environment, you can use https://jwt.io to generate your\n token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n \n .. code-block:: json\n \n     {\n       \"https://daml.com/ledger-api\": {\n         \"ledgerId\": \"MyLedger\",\n-        \"applicationId\": \"foobar\",\n+        \"applicationId\": \"HTTP-JSON-API-Gateway\",\n         \"actAs\": [\"Alice\"]\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the ``daml sandbox`` this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+The value of the ``applicationId`` field must match that provided to the ``daml json-api`` command with the flag"
  },
  {
    "id" : "8bfda00f-670f-4fb8-b850-900d8f673c44",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "c1bd05f0-ab01-4e07-8b4e-66c2f6df4c15",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not quite. There are still restrictions on valid party names. And I think this is the wrong place to explain implicit party allocation anyway.",
        "createdAt" : "2020-08-17T07:31:39Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "12ac8ca4-7c53-4cce-bbaf-ac2a84164a0e",
        "parentId" : "c1bd05f0-ab01-4e07-8b4e-66c2f6df4c15",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Wouldn't `provided that it's a valid party on the ledger` cover `valid party names`?\r\n\r\nI know as a user of the JSON API I would want to know how I can specify the party I want to use.\r\n\r\nWe should have a link to the section of the docs that explains implicit party allocation though.",
        "createdAt" : "2020-08-17T13:40:28Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6f215952-e741-4ad2-88ed-d04e841c41c8",
        "parentId" : "c1bd05f0-ab01-4e07-8b4e-66c2f6df4c15",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "There are two cases:\r\n1. The party is allocated on the ledger. Then it is clearly also a valid party string. This is what you should usually be working with on any ledger that doesn’t have implicit party allocation.\r\n2. The party is not allocated but it is a valid party string. This only works if you have implicit party allocation. Otherwise, things will fail.",
        "createdAt" : "2020-08-18T07:36:09Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,140 +32,123 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via nginx <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any Ledger API you want, if you don't have a Ledger API you want to run it with then start a sandbox ledger as so:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will connect to your ledger that is running on ``localhost:6865`` and start your JSON API server which you'll be able to query on ``localhost:7575``\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Authentication and Authorization\n+================================\n \n-.. code-block:: shell\n+The Ledger API and JSON API use the terms Authentication and Authorization to describe different aspects of their operation.\n+While these terms may sound similar they mean different things.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+The JSON API essentially performs two separate tasks:\n \n-Choosing a party\n-****************\n+1. It talks to the Ledger API to get data it needs to operate, for this it needs to may need to provide an *authentication token* to the Ledger API if the Ledger API requires *authentication*.\n+2. It handles the requests coming from one or more Parties, for this each party needs to provide an *authorization token* with each request it sends to the JSON API.\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+Authentication\n+--------------\n \n-In testing environments, you can use https://jwt.io to generate your\n+The authentication token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should an authentication token be provided to an end user, these are for internal use only.\n+\n+Every authentication token is different and will depend on what your specific ledger or ledger operator requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without interrupting your JSON API service.\n+\n+Authorization\n+-------------\n+\n+Every request from a client to the JSON API requires you to specify a party and some other settings,\n+with a JWT token.  Normal HTTP requests pass the token in an ``Authorization`` header, \n+while WebSocket requests pass the token in a subprotocol.\n+\n+.. note:: While the JSON API receives the token it doesn't handle it itself. Upon receiving a token it will pass it on to the underlying Ledger's AuthService which will then determine if the token is valid and authorized. As such each token format is ledger/implementation-specific and the below example reflects only the format that is used for the DAML Sandbox.\n+\n+In the DAML Sandbox testing environment, you can use https://jwt.io to generate your\n token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n \n .. code-block:: json\n \n     {\n       \"https://daml.com/ledger-api\": {\n         \"ledgerId\": \"MyLedger\",\n-        \"applicationId\": \"foobar\",\n+        \"applicationId\": \"HTTP-JSON-API-Gateway\",\n         \"actAs\": [\"Alice\"]\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the ``daml sandbox`` this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+The value of the ``applicationId`` field must match that provided to the ``daml json-api`` command with the flag\n+``--application-id`` (default is ``HTTP-JSON-API-Gateway``).\n+\n+The value for ``actAs`` is specified as a list. You can replace ``Alice`` with whatever party you want to use,\n+provided that it is a valid party on the ledger.\n+For the ``daml sandbox`` any string will create a party with that name."
  },
  {
    "id" : "8a331545-479f-4490-a1f6-6d8d33b4b5ca",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "aa4c9f08-a5b0-4515-aac6-a67ef24d6177",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think this section should just go. I’m not aware of any intention to develop such a tool and frankly I don’t think it makes sense to have such a tool. The tokens are generated by your IAM.",
        "createdAt" : "2020-08-17T07:32:42Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -175,24 +158,38 @@ the service as described in the following sections.\n \n Alternatively, here are two tokens you can use for testing:\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Alice\"]}}``:\n+\n+.. code-block:: none\n+\n+    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk\n+\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Bob\"]}}``:\n+\n+.. code-block:: none\n+\n+    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJCb2IiXX19.0uPPZtM1AmKvnGixt_Qo53cMDcpnziCjKKiWLvMX2VM\n \n For production use, we have a tool in development for generating proper\n RSA-encrypted tokens locally, which will arrive when the service also\n supports such tokens.\n \n-Passing token with HTTP\n-=======================\n+In the meantime you can also use whichever JWT libraries are available in the language of your choice."
  },
  {
    "id" : "b475b107-ac75-4f2a-b722-84884b4cf1fa",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "003fdf85-b45c-4f5f-a09a-9a9b248cbbe6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nThe JSON command below, demonstrates how to exercise the ``Archive`` choice on the ``Account`` contract with a ``(Party, Text)`` :doc:`contract key </daml/reference/contract-keys>` defined like this:\r\n```",
        "createdAt" : "2020-08-17T07:34:33Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -526,7 +529,7 @@ Where:\n Exercise by Contract Key\n ************************\n \n-The JSON command below, demonstrates how to exercise ``Archive`` choice on ``Account`` contract with a ``(Party, Text)`` key defined like this:\n+The JSON command below, demonstrates how to exercise ``Archive`` a choice on ``Account`` contract with a ``(Party, Text)`` :doc:`contract key </daml/reference/contract-keys>` defined like this:"
  },
  {
    "id" : "0f84ff62-f5da-43ea-9c0a-42c8a706528e",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "c3642984-9ffc-4c52-ac8d-a1732d27eec0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nGet all Active Contracts Matching a Given Query\r\n```\r\nMakes it clearer what the difference between the one above and this one is.",
        "createdAt" : "2020-08-17T07:35:34Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -828,8 +833,8 @@ HTTP Response\n \n The response is the same as for the POST method below.\n \n-Contract Search\n-***************\n+Query all Active Contracts"
  },
  {
    "id" : "02161fa3-5b80-49c0-b6be-62046b3f8500",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "eca46f86-ac3b-4f58-bef0-82c37dddd263",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "hm, do we really want to start with a warning here? I feel like most users that reach this section are quite a bit before the point where they want to put something in production. We do already have a warning if you don’t have a reverse proxy.",
        "createdAt" : "2020-08-18T06:47:34Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0cf0944a-22cd-47cc-ae54-849189ead909",
        "parentId" : "eca46f86-ac3b-4f58-bef0-82c37dddd263",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Changing it to a note.",
        "createdAt" : "2020-08-18T17:18:42Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_."
  },
  {
    "id" : "84e21f39-b822-451a-ae14-02cc0a69e528",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "0e94491c-be28-4a54-a6e7-bcbda10a2e85",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nTo improve the performance of the JSON API you can configure it to use a PostgreSQL backend as a cache. This is particularly beneficial if your ACS changes only very little (compared to the whole ACS size) between queries. Note that the PostgreSQL backend acts purely as a cache. It is save to reinitialize the database at any time.\r\n```",
        "createdAt" : "2020-08-18T06:50:24Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only)."
  },
  {
    "id" : "253485e0-cdd9-4f48-94de-7627157f1f2f",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think you misunderstood my comment about the IAM. in our auth0 daml blogpost, the IAM would be auth0 which signs the tokens not the ledger API.",
        "createdAt" : "2020-08-18T06:52:03Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "313cdd3c-555a-4549-a4d2-0be977447da9",
        "parentId" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Just to clarify the IAM sits in front of the Ledger API? \r\n\r\nIf my understanding is correct then from the perspective of someone running the JSON API and producing a client facing frontend the IAM and Ledger API are essentially indistinguishable as they're sitting at the same endpoint and part of the same workflow which is why I'm calling it the `IAM of the Ledger API`.\r\n\r\nI also don't think this sentence implies that the Ledger API signs tokens.",
        "createdAt" : "2020-08-18T17:26:24Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b999238-b422-4e0e-9b32-2be8473bd32f",
        "parentId" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "No it doesn’t sit in front  of the ledger API. The JSON API communicates directly with the ledger API without an IAM in between. user communicate with the IAM to get tokens.",
        "createdAt" : "2020-08-18T17:31:41Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fc3894bd-26e0-4058-9ff4-7be88cab7743",
        "parentId" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Okay and after they get the token they give it to the JSON API which sends it to ?",
        "createdAt" : "2020-08-18T17:43:06Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2115f89e-a58b-4ec1-9b23-1ae1ce0177f6",
        "parentId" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "They give it to the JSON API which sends it to the Ledger API. But how you acquire the token is really independent of the JSON API so I wouldn’t mention this at all. Just link to the section on ledger authentication. The important part for the JSON API is which token it needs and which restrictions they need to obey to.",
        "createdAt" : "2020-08-18T17:49:23Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6552bc91-fe4a-4df0-83f9-ba8b934faa98",
        "parentId" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Thanks for clarifying. I tweaked it a bit more but want to mention and distinguish between both of these access tokens to avoid confusion.",
        "createdAt" : "2020-08-18T19:48:41Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ea2c2c1e-eaed-4542-9b7a-e5058b1ddcc4",
        "parentId" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Now you have one section called Ledger API Auth and one called Party Auth. That’s still very confusing. Both are about ledger API authorization. There is a meaningful difference here but let’s please stick to the one that actually exists and not invent a new one:\r\n\r\n1. The token supplied via the `--access-token-file` flag. This token is not decoded by the JSON API and only used for public endpoints for queries made by the JSON API itself not for user requests.\r\n2. Party-specific tokens passed in by users when they make a request. Those tokens are decoded and thereby need to obey the JWT format + a couple of extra restrictions. Those tokens will be used for user requests.\r\n\r\nI don’t think there is more to it. This isn’t authorization vs authentication, iam vs ledger API, ledger API vs parties or whatever else. Both are tokens passed from the JSON API to the ledger API which validates those tokens and checks that they have sufficient claims for the endpoints they are used on.",
        "createdAt" : "2020-08-18T20:45:32Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bf601785-b84c-4c62-b9e1-9cf5bb0f0a8e",
        "parentId" : "01eb4ad6-d7c4-44b9-89da-b5d74ac45156",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Yes but from the perspective of a developer they're both used at different parts of their program and someone developing the client facing portion of a DAML application is going to care more about when they use each token than the exact details of what is happening between JSON API and Ledger API other than getting the JSON API talking to the Ledger API. I've been writing with this user in mind since this is the \"Building applications\" section.\r\n\r\nI also clearly botched some of the terminology earlier so let's get past that unless there's any remainders to fix. 🙂 \r\n\r\nLastly some questions:\r\n\r\n- What should we call what I'm currently calling \"Ledger API Auth\"? Now changed to \"Internal Access Token\"\r\n- Can you give me the docs.daml.com fully qualified link for the JWT documentation where it says <insert link here>. I want to make sure I'm linking to the right thing (is it this? https://docs.daml.com/daml-script/index.html#using-daml-script-in-distributed-topologies). I'll turn it into a relative link.\r\n\r\nSidenote, longterm I think it's worth having broad discussions on what types of documentation we need and how to keep a clear delineation between the various types (ex. Tutorial-style, Howto-style, and Reference-style).",
        "createdAt" : "2020-08-18T21:38:16Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Access Tokens\n+=============\n \n-.. code-block:: shell\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the IAM of the Ledger API to get data it needs to operate, for this it may need to *provide an access token to an IAM* that requires authentication."
  },
  {
    "id" : "41754a1f-56d0-4a94-a08a-43c3149eeed3",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "287460df-2880-4659-9718-d3b6699c8f84",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What are you getting at with “one or more parties” here? The JSON API only accepts tokens with a single party.",
        "createdAt" : "2020-08-18T06:52:42Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb7ec420-fbf7-4718-a193-1f977d08ae93",
        "parentId" : "287460df-2880-4659-9718-d3b6699c8f84",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Yes but it can handle multiple requests from multiple parties, even though each request comes with a token to a single party.",
        "createdAt" : "2020-08-18T17:27:18Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Access Tokens\n+=============\n \n-.. code-block:: shell\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the IAM of the Ledger API to get data it needs to operate, for this it may need to *provide an access token to an IAM* that requires authentication.\n+2. It handles requests coming from one or more Parties, for this each party needs to provide an *access token with each request* it sends to the JSON API."
  },
  {
    "id" : "18656728-97c0-4ba2-a269-2b457f977aee",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "7b88d815-38d3-4adb-9eee-ec9f48cf0635",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n.. note:: By default, the DAML Sandbox does not enable authorization and does not require access tokens. In this case, you can omit the token used by the JSON API to request packages. However, you still need to provide a token when submitting commands or queries as a party. The token will not be validated in this case but it will be decoded to extract information like the party submitting the command.\r\n```",
        "createdAt" : "2020-08-18T06:54:58Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Access Tokens\n+=============\n \n-.. code-block:: shell\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the IAM of the Ledger API to get data it needs to operate, for this it may need to *provide an access token to an IAM* that requires authentication.\n+2. It handles requests coming from one or more Parties, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n+\n+.. note:: By default sandboxes do not have an IAM and do not need the access token mentioned in point 1"
  },
  {
    "id" : "149affc0-0792-4ed1-9fe4-33ca4b7922bc",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "c6315a8b-51e3-477c-adae-76569d064f13",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Remove IAM in this whole section.",
        "createdAt" : "2020-08-18T06:56:07Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Access Tokens\n+=============\n \n-.. code-block:: shell\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the IAM of the Ledger API to get data it needs to operate, for this it may need to *provide an access token to an IAM* that requires authentication.\n+2. It handles requests coming from one or more Parties, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n+\n+.. note:: By default sandboxes do not have an IAM and do not need the access token mentioned in point 1\n+\n+Ledger API Auth with IAM"
  },
  {
    "id" : "8ac35aaf-11c1-48c6-90bd-d3fc7124aa5c",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "aea23a73-1825-4771-ae67-433f5062b79b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nThe JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\r\nThese services are public meaning that you need a valid token to access them but no party-specific claims or an admin claim.\r\n```",
        "createdAt" : "2020-08-18T06:57:42Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Access Tokens\n+=============\n \n-.. code-block:: shell\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the IAM of the Ledger API to get data it needs to operate, for this it may need to *provide an access token to an IAM* that requires authentication.\n+2. It handles requests coming from one or more Parties, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n+\n+.. note:: By default sandboxes do not have an IAM and do not need the access token mentioned in point 1\n+\n+Ledger API Auth with IAM\n+------------------------\n+\n+The IAM access token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should this access token be provided to an end user, these are for internal use only.\n+\n+Every IAM access token is different and will depend on what your specific ledger operator's IAM requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that."
  },
  {
    "id" : "8ca7eccc-f9b1-4834-aebf-99532781877b",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "0e1031a8-e3a7-489e-a616-167a44ed3993",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nParty-specific requests, i.e., command submissions and queries, require a JWT with some additional restrictions compared to the JWT imposed on the format described in <insert link here>: The set of parties listed in `actAs` and `readAs` must contain exactly one party. In addition to that, the application id and ledger id are mandatory. HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol.\r\n```\r\nNot too fussed about the wording but this needs to be documented precisely. It is also not true that all requests need this, e.g., allocating a party just proxies to the underlying service on the ledger API and does not attempt to decode the token.",
        "createdAt" : "2020-08-18T07:29:33Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Access Tokens\n+=============\n \n-.. code-block:: shell\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the IAM of the Ledger API to get data it needs to operate, for this it may need to *provide an access token to an IAM* that requires authentication.\n+2. It handles requests coming from one or more Parties, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n+\n+.. note:: By default sandboxes do not have an IAM and do not need the access token mentioned in point 1\n+\n+Ledger API Auth with IAM\n+------------------------\n+\n+The IAM access token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should this access token be provided to an end user, these are for internal use only.\n+\n+Every IAM access token is different and will depend on what your specific ledger operator's IAM requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without restarting your JSON API service.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+Party Auth\n+----------\n \n-Choosing a party\n-****************\n+Every request from a client to the JSON API requires you to specify a party and some other settings,\n+with a JWT token.  HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol."
  },
  {
    "id" : "3e3380c2-1758-46ee-85ba-dc95d8706746",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "a3e09b4f-20bc-48b0-91ce-1d5254d875b7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n.. note:: While the JSON API receives the token it doesn't validate it itself. Upon receiving a token it will pass it on to the Ledger API's AuthService which will then determine if the token is valid and authorized. However, the JSON API does decode the token to extract ledger id, application id and party so it requires that you use the JWT format documented here <insert link>.\r\n```\r\nIt does decode the token for party-specific requests so it doesn’t actually work if your ledger requires a different token format.",
        "createdAt" : "2020-08-18T07:33:28Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,100 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+.. warning:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-From a DAML project directory:\n+Start a DAML Ledger\n+===================\n+\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n+\n+Basic\n+-----\n \n-From a DAML project directory:\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+With Query Store\n+------------------\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+Often when running the JSON API you'll want to cache queries, especially large queries, to decrease the workload of your underlying ledger.\n+The JSON API provides a way to do this by allowing you to specify a database to cache queries (currently PostgreSQL only).\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. code-block:: shell\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-Example session\n-***************\n+Access Tokens\n+=============\n \n-.. code-block:: shell\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the IAM of the Ledger API to get data it needs to operate, for this it may need to *provide an access token to an IAM* that requires authentication.\n+2. It handles requests coming from one or more Parties, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n+\n+.. note:: By default sandboxes do not have an IAM and do not need the access token mentioned in point 1\n+\n+Ledger API Auth with IAM\n+------------------------\n+\n+The IAM access token is used exclusively for maintaining the internal list of known packages and templates.\n+\n+.. note:: At no point should this access token be provided to an end user, these are for internal use only.\n+\n+Every IAM access token is different and will depend on what your specific ledger operator's IAM requires.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without restarting your JSON API service.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+Party Auth\n+----------\n \n-Choosing a party\n-****************\n+Every request from a client to the JSON API requires you to specify a party and some other settings,\n+with a JWT token.  HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol.\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+.. note:: While the JSON API receives the token it doesn't handle it itself. Upon receiving a token it will pass it on to the Ledger API's AuthService which will then determine if the token is valid and authorized. As such each token format is ledger/implementation-specific and the below example reflects only the format that is used for the DAML Sandbox."
  },
  {
    "id" : "b336c71e-93d9-4df5-a467-cfeab4f2e537",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "3ed7c542-6a53-45d5-8532-9c4d0d80d012",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n.. note:: The value of ``applicationId`` will be used for commands submitted using that token.\r\n```",
        "createdAt" : "2020-08-18T07:34:17Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "22f43cd1-9d14-4497-a4d3-50db93760fba",
        "parentId" : "3ed7c542-6a53-45d5-8532-9c4d0d80d012",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I would just ignore the `--application-id` flag for now. I don’t see any case where it matters. I’ll open an issue for that.",
        "createdAt" : "2020-08-18T07:34:46Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -165,7 +138,14 @@ token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the ``daml sandbox`` this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+.. note:: The value of ``applicationId`` can currently be anything and does not need to correspond to ``daml json-api --application-id <value>``."
  },
  {
    "id" : "899b5af9-ad0e-4198-a35c-d807338e9c1c",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "34faf272-25bb-468f-bc41-399b2e187ab2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is a lie. It doesn’t matter what secret you use here. The JSON API only decodes the token. It doesn’t validate it which is the part where the secret would matter.",
        "createdAt" : "2020-08-18T07:36:41Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -165,7 +138,14 @@ token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the ``daml sandbox`` this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+.. note:: The value of ``applicationId`` can currently be anything and does not need to correspond to ``daml json-api --application-id <value>``.\n+\n+The value for ``actAs`` is specified as a list. You can replace ``Alice`` with whatever party you want to use,\n+provided that it is a valid party on the ledger.\n+For the ``daml sandbox`` any string will create a party with that name.\n \n Under \"Verify Signature\", put ``secret`` as the secret (*not* base64"
  },
  {
    "id" : "b6f25c49-85f3-4499-98a9-cfc0fb61c0fc",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "22054858-0967-4bd5-9178-7e5469d6c66c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nAuth via HTTP\r\n```\r\nThis doesn’t just apply to party-specific requests. It also applies to requests like allocating a party.",
        "createdAt" : "2020-08-18T07:37:29Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -175,24 +155,32 @@ the service as described in the following sections.\n \n Alternatively, here are two tokens you can use for testing:\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Alice\"]}}``:\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n+.. code-block:: none\n \n-For production use, we have a tool in development for generating proper\n-RSA-encrypted tokens locally, which will arrive when the service also\n-supports such tokens.\n+    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk\n \n-Passing token with HTTP\n-=======================\n \n-Set HTTP header ``Authorization: Bearer copy-paste-token-here`` for\n-normal requests.\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Bob\"]}}``:\n \n-Passing token with WebSockets\n-=============================\n+.. code-block:: none\n+\n+    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJCb2IiXX19.0uPPZtM1AmKvnGixt_Qo53cMDcpnziCjKKiWLvMX2VM\n+\n+Party Auth via HTTP"
  },
  {
    "id" : "f3c5a721-1eb4-46df-bf4f-e476784b2212",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "befa4623-bc8c-468a-87e9-ea70aabb5983",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Technically all websocket requests are party-specific atm but I would still recommend removing the “Party” prefix. There isn’t anything that stops us from adding non-party specific endpoints.",
        "createdAt" : "2020-08-18T07:38:12Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -175,24 +155,32 @@ the service as described in the following sections.\n \n Alternatively, here are two tokens you can use for testing:\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Alice\"]}}``:\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n+.. code-block:: none\n \n-For production use, we have a tool in development for generating proper\n-RSA-encrypted tokens locally, which will arrive when the service also\n-supports such tokens.\n+    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk\n \n-Passing token with HTTP\n-=======================\n \n-Set HTTP header ``Authorization: Bearer copy-paste-token-here`` for\n-normal requests.\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Bob\"]}}``:\n \n-Passing token with WebSockets\n-=============================\n+.. code-block:: none\n+\n+    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJCb2IiXX19.0uPPZtM1AmKvnGixt_Qo53cMDcpnziCjKKiWLvMX2VM\n+\n+Party Auth via HTTP\n+^^^^^^^^^^^^^^^^^^^\n+\n+Set HTTP header ``Authorization: Bearer paste-jwt-here``\n+\n+Example: \n+\n+.. code-block:: none \n+\n+    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk\n+\n+Party Auth via WebSockets"
  },
  {
    "id" : "0a4aa033-7d57-4bf2-a082-36eec057b2b1",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "6d6f9766-eef8-4a2b-88ed-6ff1dbb07a48",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nWhen creating a new contract you may specify an optional ``meta`` field. This allows you to control the `commandId` used when submitting a commend to the ledger.\r\n```",
        "createdAt" : "2020-08-18T07:38:46Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -407,10 +399,12 @@ Where:\n \n .. _create-request-with-meta:\n \n-Create a new Contract with an optional meta field\n-*************************************************\n+Creating a Contract with a Command ID\n+*************************************\n+\n+When creating a new contract you may specify an optional ``meta`` field."
  },
  {
    "id" : "617a1e0c-508b-481d-a616-a6f2f5ef37f1",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "569ef055-978a-4cfa-9c53-8e58f7de41a6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Pretty sure you need more stars here.",
        "createdAt" : "2020-08-18T07:41:25Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : 332,
    "diffHunk" : "@@ -828,8 +824,8 @@ HTTP Response\n \n The response is the same as for the POST method below.\n \n-Contract Search\n-***************\n+Get all Active Contracts Matching a Given Query"
  },
  {
    "id" : "5f11b205-b1fa-48a2-903b-a8c5adcef924",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "28b6f4e2-dde2-4bdc-9d68-636e240de5e1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nTo enable the PostgreSQL backend you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \r\n```",
        "createdAt" : "2020-08-24T11:43:04Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,98 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+Start a DAML Ledger\n+===================\n \n-From a DAML project directory:\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n \n-From a DAML project directory:\n+Basic\n+-----\n+\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+.. note:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+With Query Store\n+------------------\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+To improve the performance of the JSON API you can configure it to use a PostgreSQL backend as a cache. This is particularly beneficial if your ACS changes only very little (compared to the whole ACS size) between queries. Note that the PostgreSQL backend acts purely as a cache. It is save to reinitialize the database at any time.\n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. "
  },
  {
    "id" : "b52ffead-3779-4990-96ad-a8d6b92b0eb5",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "caf15c96-185d-48ac-8a03-901f0eac1dfa",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n1. It talks to the Ledger API to get data it needs to operate, for this you need to *provide an access token* if your Ledger requires authorization. Learn more in the :doc:`/app-dev/authorization` docs.\r\n```\r\nNote where the link to the docs goes to :slightly_smiling_face: ",
        "createdAt" : "2020-08-24T11:44:06Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,98 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+Start a DAML Ledger\n+===================\n \n-From a DAML project directory:\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n \n-From a DAML project directory:\n+Basic\n+-----\n+\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+.. note:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+With Query Store\n+------------------\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+To improve the performance of the JSON API you can configure it to use a PostgreSQL backend as a cache. This is particularly beneficial if your ACS changes only very little (compared to the whole ACS size) between queries. Note that the PostgreSQL backend acts purely as a cache. It is save to reinitialize the database at any time.\n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+.. code-block:: shell\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-Example session\n-***************\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-.. code-block:: shell\n+Access Tokens\n+=============\n+\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the Ledger API to get data it needs to operate, for this it may need to *provide an access token* if your Ledger requires authentication. Learn more in the :doc:`/app-dev/authorization` docs."
  },
  {
    "id" : "275897f8-8117-48a0-bcca-eeae9581e06a",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "c4891cb5-b35b-4180-81b1-316e562afbb6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Seems like there should be something after `how`.",
        "createdAt" : "2020-08-24T11:45:39Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,98 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+Start a DAML Ledger\n+===================\n \n-From a DAML project directory:\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n \n-From a DAML project directory:\n+Basic\n+-----\n+\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+.. note:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+With Query Store\n+------------------\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+To improve the performance of the JSON API you can configure it to use a PostgreSQL backend as a cache. This is particularly beneficial if your ACS changes only very little (compared to the whole ACS size) between queries. Note that the PostgreSQL backend acts purely as a cache. It is save to reinitialize the database at any time.\n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+.. code-block:: shell\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-Example session\n-***************\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-.. code-block:: shell\n+Access Tokens\n+=============\n+\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the Ledger API to get data it needs to operate, for this it may need to *provide an access token* if your Ledger requires authentication. Learn more in the :doc:`/app-dev/authorization` docs.\n+2. It accepts requests from Parties and passes them on to the Ledger API, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+.. note:: By default, the DAML Sandbox does not does not require access tokens. In this case, you can omit the token used by the JSON API to request packages. However, you still need to provide a party-specific access token when submitting commands or queries as a party. The token will not be validated in this case but it will be decoded to extract information like the party submitting the command.\n \n-Choosing a party\n-****************\n+Internal Access Token\n+---------------------\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+This access token is used exclusively by the JSON API service for maintaining the internal list of known packages and templates that it gets from the Ledger API.\n \n-In testing environments, you can use https://jwt.io to generate your\n+.. note:: At no point should this access token be provided to an end user, these are for internal use only.\n+\n+Every access token is different and will depend on your specific ledger operator's requirements.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+These services are public meaning that you need a valid token to access them but no party-specific claims or an admin claim.\n+Please refer to your ledger operator's documentation to find out how."
  },
  {
    "id" : "b02abca0-d7ed-469d-a632-37da864613e3",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "f084e00a-aef8-4a6c-bd73-87c9b2092735",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Needs an actual link in place of `<insert link here>`.",
        "createdAt" : "2020-08-24T11:46:13Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a2681720-53d3-48f1-a950-e9f5bfc0c286",
        "parentId" : "f084e00a-aef8-4a6c-bd73-87c9b2092735",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Yup, see point 2 here, can do you know which link is correct for this? https://github.com/digital-asset/daml/pull/7133#discussion_r472507970",
        "createdAt" : "2020-08-24T15:58:47Z",
        "updatedAt" : "2020-08-25T17:07:07Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ad5c0b52-2ac8-4c00-adee-ec8cfcfa30b2",
        "parentId" : "f084e00a-aef8-4a6c-bd73-87c9b2092735",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "https://docs.daml.com/tools/sandbox.html#token-payload",
        "createdAt" : "2020-08-24T16:03:10Z",
        "updatedAt" : "2020-08-25T17:07:07Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,98 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+Start a DAML Ledger\n+===================\n \n-From a DAML project directory:\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n \n-From a DAML project directory:\n+Basic\n+-----\n+\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+.. note:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+With Query Store\n+------------------\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+To improve the performance of the JSON API you can configure it to use a PostgreSQL backend as a cache. This is particularly beneficial if your ACS changes only very little (compared to the whole ACS size) between queries. Note that the PostgreSQL backend acts purely as a cache. It is save to reinitialize the database at any time.\n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+.. code-block:: shell\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-Example session\n-***************\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-.. code-block:: shell\n+Access Tokens\n+=============\n+\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the Ledger API to get data it needs to operate, for this it may need to *provide an access token* if your Ledger requires authentication. Learn more in the :doc:`/app-dev/authorization` docs.\n+2. It accepts requests from Parties and passes them on to the Ledger API, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+.. note:: By default, the DAML Sandbox does not does not require access tokens. In this case, you can omit the token used by the JSON API to request packages. However, you still need to provide a party-specific access token when submitting commands or queries as a party. The token will not be validated in this case but it will be decoded to extract information like the party submitting the command.\n \n-Choosing a party\n-****************\n+Internal Access Token\n+---------------------\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+This access token is used exclusively by the JSON API service for maintaining the internal list of known packages and templates that it gets from the Ledger API.\n \n-In testing environments, you can use https://jwt.io to generate your\n+.. note:: At no point should this access token be provided to an end user, these are for internal use only.\n+\n+Every access token is different and will depend on your specific ledger operator's requirements.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+These services are public meaning that you need a valid token to access them but no party-specific claims or an admin claim.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without restarting your JSON API service.\n+\n+Party-specific Access Tokens\n+----------------------------\n+\n+Party-specific requests, i.e., command submissions and queries, require a JWT with some additional restrictions compared to the JWT imposed on the format described in <insert link here>: The set of parties listed in `actAs` and `readAs` must contain exactly one party. In addition to that, the application id and ledger id are mandatory. HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol."
  },
  {
    "id" : "359cb503-ce55-462d-8960-739b35c2ab46",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "bf8f1f78-fa9b-4e2b-9a06-d44b650d7b0d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nFor a ledger without authorization, e.g., the default configuration of DAML Sandbox, you can use https://jwt.io (or the JWT library of your choice) to generate your\r\n```",
        "createdAt" : "2020-08-24T11:47:10Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,98 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+Start a DAML Ledger\n+===================\n \n-From a DAML project directory:\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n \n-From a DAML project directory:\n+Basic\n+-----\n+\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+.. note:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+With Query Store\n+------------------\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+To improve the performance of the JSON API you can configure it to use a PostgreSQL backend as a cache. This is particularly beneficial if your ACS changes only very little (compared to the whole ACS size) between queries. Note that the PostgreSQL backend acts purely as a cache. It is save to reinitialize the database at any time.\n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+.. code-block:: shell\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-Example session\n-***************\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-.. code-block:: shell\n+Access Tokens\n+=============\n+\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the Ledger API to get data it needs to operate, for this it may need to *provide an access token* if your Ledger requires authentication. Learn more in the :doc:`/app-dev/authorization` docs.\n+2. It accepts requests from Parties and passes them on to the Ledger API, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+.. note:: By default, the DAML Sandbox does not does not require access tokens. In this case, you can omit the token used by the JSON API to request packages. However, you still need to provide a party-specific access token when submitting commands or queries as a party. The token will not be validated in this case but it will be decoded to extract information like the party submitting the command.\n \n-Choosing a party\n-****************\n+Internal Access Token\n+---------------------\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+This access token is used exclusively by the JSON API service for maintaining the internal list of known packages and templates that it gets from the Ledger API.\n \n-In testing environments, you can use https://jwt.io to generate your\n+.. note:: At no point should this access token be provided to an end user, these are for internal use only.\n+\n+Every access token is different and will depend on your specific ledger operator's requirements.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+These services are public meaning that you need a valid token to access them but no party-specific claims or an admin claim.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without restarting your JSON API service.\n+\n+Party-specific Access Tokens\n+----------------------------\n+\n+Party-specific requests, i.e., command submissions and queries, require a JWT with some additional restrictions compared to the JWT imposed on the format described in <insert link here>: The set of parties listed in `actAs` and `readAs` must contain exactly one party. In addition to that, the application id and ledger id are mandatory. HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol.\n+\n+.. note:: While the JSON API receives the token it doesn't validate it itself. Upon receiving a token it will pass it, and all data contained within the request, on to the Ledger API's AuthService which will then determine if the token is valid and authorized. However, the JSON API does decode the token to extract the ledger id, application id and party so it requires that you use the JWT format documented below.\n+\n+In the DAML Sandbox testing environment, you can use https://jwt.io (or the JWT library of your choice) to generate your"
  },
  {
    "id" : "b781bb68-9c42-4c81-82d2-b14f817e0a5f",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "4d0f603f-5218-469f-8411-ec2dc5103ecd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\ntoken.  You can use an arbitrary secret here. The default \"header\" is fine.  Under \"Payload\", fill in:\r\n```",
        "createdAt" : "2020-08-24T11:47:27Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -32,127 +32,98 @@ We welcome feedback about the JSON API on `our issue tracker\n \n .. toctree::\n    :hidden:\n+   :maxdepth: 3\n \n    lf-value-specification\n    search-query-language\n \n-How to start\n-************\n+Running the JSON API\n+********************\n \n-Start sandbox\n-=============\n+Start a DAML Ledger\n+===================\n \n-From a DAML project directory:\n+You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don't have an existing ledger, you can start an in-memory sandbox:\n \n .. code-block:: shell\n \n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n+    daml new my_project --template quickstart-java\n+    cd my_project\n+    daml build\n+    daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n \n .. _start-http-service:\n \n-Start HTTP service\n-==================\n+Start the HTTP JSON API Service\n+===============================\n \n-From a DAML project directory:\n+Basic\n+-----\n+\n+The most basic way to start the JSON API is with the command:\n \n .. code-block:: shell\n \n-    $ daml json-api --ledger-host localhost --ledger-port 6865 \\\n-        --http-port 7575 --max-inbound-message-size 4194304 --package-reload-interval 5s \\\n-        --application-id HTTP-JSON-API-Gateway --static-content \"prefix=static,directory=./static-content\" \\\n-        --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n \n-.. code-block:: none\n+This will start the JSON API on port 7575 and connect it to a ledger running on ``localhost:6865``.\n \n-    $ daml json-api --help\n-    HTTP JSON API daemon\n-    Usage: http-json-binary [options]\n-\n-      --help\n-            Print this usage text\n-      --ledger-host <value>\n-            Ledger host name or IP address\n-      --ledger-port <value>\n-            Ledger port number\n-      --address <value>\n-            IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n-      --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0.\n-      --port-file <value>\n-            Optional unique file name where to write the allocated HTTP port number. If process terminates gracefully, this file will be deleted automatically. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created.\n-      --application-id <value>\n-            Optional application ID to use for ledger registration. Defaults to HTTP-JSON-API-Gateway\n-      --pem <value>\n-            TLS: The pem file to be used as the private key.\n-      --crt <value>\n-            TLS: The crt file to be used as the cert chain.\n-            Required for client authentication.\n-      --cacrt <value>\n-            TLS: The crt file to be used as the trusted root CA.\n-      --tls\n-            TLS: Enable tls. This is redundant if --pem, --crt or --cacrt are set\n-      --package-reload-interval <value>\n-            Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds\n-      --max-inbound-message-size <value>\n-            Optional max inbound message size in bytes. Defaults to 4194304\n-      --query-store-jdbc-config \"driver=<JDBC driver class name>,url=<JDBC connection url>,user=<user>,password=<password>,createSchema=<true|false>\"\n-            Optional query store JDBC configuration string. Query store is a search index, use it if you need to query large active contract sets. Contains comma-separated key-value pairs. Where:\n-            driver -- JDBC driver class name, only org.postgresql.Driver supported right now,\n-            url -- JDBC connection URL, only jdbc:postgresql supported right now,\n-            user -- database user name,\n-            password -- database user password,\n-            createSchema -- boolean flag, if set to true, the process will re-create database schema and terminate immediately.\n-            Example: \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n-      --static-content \"prefix=<URL prefix>,directory=<directory>\"\n-            DEV MODE ONLY (not recommended for production). Optional static content configuration string. Contains comma-separated key-value pairs. Where:\n-            prefix -- URL prefix,\n-            directory -- local directory that will be mapped to the URL prefix.\n-            Example: \"prefix=static,directory=./static-content\"\n-      --allow-insecure-tokens\n-            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS.\n-      --access-token-file <value>\n-            provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n-      --websocket-config \"maxDuration=<Maximum websocket session duration in minutes>,heartBeatPer=Server-side heartBeat interval in seconds\"\n-            Optional websocket configuration string. Contains comma-separated key-value pairs. Where:\n-            maxDuration -- Maximum websocket session duration in minutes\n-            heartBeatPer -- Server-side heartBeat interval in seconds\n-            Example: \"maxDuration=120,heartBeatPer=5\"\n-\n-With Authentication\n-===================\n+.. note:: Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a `reverse proxy, such as via NGINX <https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/>`_.\n \n-Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+With Query Store\n+------------------\n \n-For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+To improve the performance of the JSON API you can configure it to use a PostgreSQL backend as a cache. This is particularly beneficial if your ACS changes only very little (compared to the whole ACS size) between queries. Note that the PostgreSQL backend acts purely as a cache. It is save to reinitialize the database at any time.\n \n-Note that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+In this case you can use the ``--query-store-jdbc-config`` flag, an example of which is below. \n \n-The HTTP JSON API server requires no access to party-specific data, only access to the ledger identity and package services. A token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\n+.. note:: When you use the Query Store you'll want your first run to specify ``createSchema=true`` so that all the necessary tables are created. After the first run make sure ``createSchema=false`` so that it doesn't attempt to create the tables again.\n \n-Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file. Give the path to it with the ``--access-token-file`` command line option.\n+.. code-block:: shell\n \n-If the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token, and it will be picked up at the next attempt to send a request.\n+    daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575 \\\n+    --query-store-jdbc-config \"driver=org.postgresql.Driver,url=jdbc:postgresql://localhost:5432/test?&ssl=true,user=postgres,password=password,createSchema=false\"\n \n-Example session\n-***************\n+.. note:: The JSON API provides many other useful configuration flags, run ``daml json-api --help`` to see all of them.\n \n-.. code-block:: shell\n+Access Tokens\n+=============\n+\n+The JSON API essentially performs two separate tasks:\n+\n+1. It talks to the Ledger API to get data it needs to operate, for this it may need to *provide an access token* if your Ledger requires authentication. Learn more in the :doc:`/app-dev/authorization` docs.\n+2. It accepts requests from Parties and passes them on to the Ledger API, for this each party needs to provide an *access token with each request* it sends to the JSON API.\n \n-    $ daml new iou-quickstart-java --template quickstart-java\n-    $ cd iou-quickstart-java/\n-    $ daml build\n-    $ daml sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar\n-    $ daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575\n+.. note:: By default, the DAML Sandbox does not does not require access tokens. In this case, you can omit the token used by the JSON API to request packages. However, you still need to provide a party-specific access token when submitting commands or queries as a party. The token will not be validated in this case but it will be decoded to extract information like the party submitting the command.\n \n-Choosing a party\n-****************\n+Internal Access Token\n+---------------------\n \n-Every request requires you to specify a party and some other settings,\n-with a JWT token.  Normal HTTP requests pass the token in an\n-``Authentication`` header, while WebSocket requests pass the token in a\n-subprotocol.\n+This access token is used exclusively by the JSON API service for maintaining the internal list of known packages and templates that it gets from the Ledger API.\n \n-In testing environments, you can use https://jwt.io to generate your\n+.. note:: At no point should this access token be provided to an end user, these are for internal use only.\n+\n+Every access token is different and will depend on your specific ledger operator's requirements.\n+The JSON API server requires no access to party-specific data, only access to the ledger identity and package services.\n+These services are public meaning that you need a valid token to access them but no party-specific claims or an admin claim.\n+Please refer to your ledger operator's documentation to find out how.\n+\n+Once you have retrieved your access token, you can provide it to the JSON API by storing it in a file\n+and starting ``daml json-api`` with the flag ``--access-token-file /path/to/your/token.file``.\n+\n+If the token cannot be read from the provided path or the Ledger API reports an authentication error\n+(for example due to token expiration), the JSON API will report the error via logging. \n+\n+.. note:: If the token file is updated with a new token it will be picked up at the next attempt to send a request. You can use this to handle cases where an old token expires without restarting your JSON API service.\n+\n+Party-specific Access Tokens\n+----------------------------\n+\n+Party-specific requests, i.e., command submissions and queries, require a JWT with some additional restrictions compared to the JWT imposed on the format described in <insert link here>: The set of parties listed in `actAs` and `readAs` must contain exactly one party. In addition to that, the application id and ledger id are mandatory. HTTP requests pass the token in a header, while WebSocket requests pass the token in a subprotocol.\n+\n+.. note:: While the JSON API receives the token it doesn't validate it itself. Upon receiving a token it will pass it, and all data contained within the request, on to the Ledger API's AuthService which will then determine if the token is valid and authorized. However, the JSON API does decode the token to extract the ledger id, application id and party so it requires that you use the JWT format documented below.\n+\n+In the DAML Sandbox testing environment, you can use https://jwt.io (or the JWT library of your choice) to generate your\n token.  The default \"header\" is fine.  Under \"Payload\", fill in:"
  },
  {
    "id" : "73962298-b61f-4d96-966f-875827d5e8f9",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "987ad692-ce1a-44bd-829f-1bd18dc0b83e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nThe party should reference an already allocated party.\r\n```\r\nThis is really not the right place to explain implicit party allocation. If you want to document this, add something to the sandbox docs and reference it here but I recommend leaving that to a separate PR.",
        "createdAt" : "2020-08-24T11:49:40Z",
        "updatedAt" : "2020-08-25T17:07:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -165,34 +136,58 @@ token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the Sandbox this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+.. note:: The value of ``applicationId`` will be used for commands submitted using that token.\n+\n+The value for ``actAs`` is specified as a list and you provide it with the party that you want to use.\n+Such as the example which uses ``Alice`` for a party. Each request can only be for one party.\n+For example you couldn't have ``actAs`` defined as ``[\"Alice\", \"Bob\"]``.\n \n-Under \"Verify Signature\", put ``secret`` as the secret (*not* base64\n-encoded); that is the hardcoded secret for testing.\n+For the Sandbox any string will create use a party with that name if it exists, \n+or create it if it does not. This is known as \"implicit party allocation\" and is unique to the Sandbox.\n+\n+For non-Sandbox ledgers the party must already exist on the ledger in order to be used.\n+This is known as \"explicit party allocation\" and is common on all non-Sandbox ledgers."
  },
  {
    "id" : "a87408b1-f503-4ce8-baa7-d13683f4bbdf",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "9ab98f62-34fd-4676-b6e6-87ef88c8aa54",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n```\r\nThis is about the JSON API not party allocation.",
        "createdAt" : "2020-08-24T11:49:54Z",
        "updatedAt" : "2020-08-25T17:07:07Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -165,34 +136,58 @@ token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the Sandbox this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+.. note:: The value of ``applicationId`` will be used for commands submitted using that token.\n+\n+The value for ``actAs`` is specified as a list and you provide it with the party that you want to use.\n+Such as the example which uses ``Alice`` for a party. Each request can only be for one party.\n+For example you couldn't have ``actAs`` defined as ``[\"Alice\", \"Bob\"]``.\n \n-Under \"Verify Signature\", put ``secret`` as the secret (*not* base64\n-encoded); that is the hardcoded secret for testing.\n+For the Sandbox any string will create use a party with that name if it exists, \n+or create it if it does not. This is known as \"implicit party allocation\" and is unique to the Sandbox.\n+\n+For non-Sandbox ledgers the party must already exist on the ledger in order to be used.\n+This is known as \"explicit party allocation\" and is common on all non-Sandbox ledgers.\n+\n+.. note:: To explicitly allocate parties you can use :doc:`DAML Script </daml-script/index>` or ``daml ledger allocate-parties``"
  },
  {
    "id" : "77636a3b-622e-4b7f-9390-bffd9d9f5aa2",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "43079d4a-d801-47c2-924d-87bdb23a6a3e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n.. note:: As mentioned above the JSON API does not validate tokens so if your ledger runs without authorization you can use an arbitrary secret.\r\n```\r\n```",
        "createdAt" : "2020-08-24T11:51:06Z",
        "updatedAt" : "2020-08-25T17:07:07Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : null,
    "diffHunk" : "@@ -165,34 +136,58 @@ token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the Sandbox this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+.. note:: The value of ``applicationId`` will be used for commands submitted using that token.\n+\n+The value for ``actAs`` is specified as a list and you provide it with the party that you want to use.\n+Such as the example which uses ``Alice`` for a party. Each request can only be for one party.\n+For example you couldn't have ``actAs`` defined as ``[\"Alice\", \"Bob\"]``.\n \n-Under \"Verify Signature\", put ``secret`` as the secret (*not* base64\n-encoded); that is the hardcoded secret for testing.\n+For the Sandbox any string will create use a party with that name if it exists, \n+or create it if it does not. This is known as \"implicit party allocation\" and is unique to the Sandbox.\n+\n+For non-Sandbox ledgers the party must already exist on the ledger in order to be used.\n+This is known as \"explicit party allocation\" and is common on all non-Sandbox ledgers.\n+\n+.. note:: To explicitly allocate parties you can use :doc:`DAML Script </daml-script/index>` or ``daml ledger allocate-parties``\n+\n+Under \"Verify Signature\", put ``secret`` (or any other text) as the secret (*not* base64 encoded).\n+\n+.. note:: At the moment ``secret`` is not validated"
  },
  {
    "id" : "28d765c9-973e-4caa-87fa-c771f37f7c32",
    "prId" : 7133,
    "comments" : [
      {
        "id" : "5dc25c16-0524-4d42-b0d5-97468c9f3998",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Does this actually render as code? I thought two newlines mean it no longer belongs to the code block.",
        "createdAt" : "2020-08-24T11:51:51Z",
        "updatedAt" : "2020-08-25T17:07:07Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d9161df2-e737-4619-8259-8684e2c9116d",
        "parentId" : "5dc25c16-0524-4d42-b0d5-97468c9f3998",
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Yes all is rendering correctly, there's 1 newline after the `code-block` delegation and two newlines separating the inline code block that displays the json-encoded token.\r\n",
        "createdAt" : "2020-08-24T16:10:14Z",
        "updatedAt" : "2020-08-25T17:07:07Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2af64453c630fe4f2fd7ceb6dc355343dcac5a66",
    "line" : 243,
    "diffHunk" : "@@ -165,34 +136,58 @@ token.  The default \"header\" is fine.  Under \"Payload\", fill in:\n       }\n     }\n \n-Keep in mind that the value of the ``ledgerId`` payload field has to match the one passed to the sandbox with the ``--ledgerid`` argument. You can replace ``Alice`` with whatever party you want to use.\n+The value of the ``ledgerId`` field has to match the ``ledgerId` of your underlying DAML Ledger.\n+For the Sandbox this corresponds to the ``--ledgerid MyLedger`` flag.\n+\n+.. note:: The value of ``applicationId`` will be used for commands submitted using that token.\n+\n+The value for ``actAs`` is specified as a list and you provide it with the party that you want to use.\n+Such as the example which uses ``Alice`` for a party. Each request can only be for one party.\n+For example you couldn't have ``actAs`` defined as ``[\"Alice\", \"Bob\"]``.\n \n-Under \"Verify Signature\", put ``secret`` as the secret (*not* base64\n-encoded); that is the hardcoded secret for testing.\n+For the Sandbox any string will create use a party with that name if it exists, \n+or create it if it does not. This is known as \"implicit party allocation\" and is unique to the Sandbox.\n+\n+For non-Sandbox ledgers the party must already exist on the ledger in order to be used.\n+This is known as \"explicit party allocation\" and is common on all non-Sandbox ledgers.\n+\n+.. note:: To explicitly allocate parties you can use :doc:`DAML Script </daml-script/index>` or ``daml ledger allocate-parties``\n+\n+Under \"Verify Signature\", put ``secret`` (or any other text) as the secret (*not* base64 encoded).\n+\n+.. note:: At the moment ``secret`` is not validated\n \n Then the \"Encoded\" box should have your **token**, ready for passing to\n the service as described in the following sections.\n \n Alternatively, here are two tokens you can use for testing:\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Alice\"]}}``:\n \n-- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n+.. code-block:: none\n \n-For production use, we have a tool in development for generating proper\n-RSA-encrypted tokens locally, which will arrive when the service also\n-supports such tokens.\n+    eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk\n \n-Passing token with HTTP\n-=======================\n \n-Set HTTP header ``Authorization: Bearer copy-paste-token-here`` for\n-normal requests.\n+``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"HTTP-JSON-API-Gateway\", \"actAs\": [\"Bob\"]}}``:\n \n-Passing token with WebSockets\n-=============================\n+.. code-block:: none\n+"
  },
  {
    "id" : "4c3cd67f-0010-4cb1-85a5-5b2a993d4513",
    "prId" : 6179,
    "comments" : [
      {
        "id" : "388a95ea-b737-4bed-a066-49704de77108",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This looks weird?",
        "createdAt" : "2020-06-02T06:32:58Z",
        "updatedAt" : "2020-06-02T13:32:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "90bf50c8fd21fab98489774c39c31891c6846fb8",
    "line" : null,
    "diffHunk" : "@@ -332,12 +332,14 @@ Examples\n Create a new Contract\n *********************\n \n-See the request documentation below on how to create an instance of ``Iou`` contract from the :doc:`Quickstart guide </app-dev/bindings-java/quickstart>`:\n+To create an instance of an ``Iou`` contract from the :doc:`Quickstart guide </app-dev/bindings-java/quickstart>`:\n \n .. literalinclude:: ../app-dev/bindings-java/quickstart/template-root/daml/Iou.daml\n   :language: daml\n   :lines: 9-15\n \n+One can make a"
  },
  {
    "id" : "ebc785e9-5dd0-4b5b-be8f-a5c4cc60d673",
    "prId" : 6179,
    "comments" : [
      {
        "id" : "8fdd3b86-36e5-4147-a72c-2e78ef28b560",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n*************************************************\r\n```\r\nThe number of stars needs to match the header length in Rst.",
        "createdAt" : "2020-06-02T06:33:27Z",
        "updatedAt" : "2020-06-02T13:32:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "90bf50c8fd21fab98489774c39c31891c6846fb8",
    "line" : null,
    "diffHunk" : "@@ -407,7 +409,7 @@ Where:\n \n .. _create-request-with-meta:\n \n-Create a new Contract with optional meta field\n+Create a new Contract with an optional meta field\n **********************************************"
  },
  {
    "id" : "075644b1-33be-4fed-9825-ecc61c69e3d9",
    "prId" : 6179,
    "comments" : [
      {
        "id" : "48575ce5-c580-4b69-8258-19273ff5c21b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n- a ``created`` event for the contract that is the result of exercising the choice (``\"contractId\": \"#1:2\"``).\r\n```",
        "createdAt" : "2020-06-02T08:54:03Z",
        "updatedAt" : "2020-06-02T13:32:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "90bf50c8fd21fab98489774c39c31891c6846fb8",
    "line" : null,
    "diffHunk" : "@@ -615,7 +617,7 @@ HTTP Response\n Please note that the response below is for a consuming choice, so it contains:\n \n - ``created`` and ``archived`` events for the initial contract (``\"contractId\": \"#1:0\"``), which was created and archived right away when a consuming choice was exercised on it,\n-- a ``created`` event for the contract that is the result of the choice exercise (``\"contractId\": \"#1:2\"``).\n+- a ``created`` event for the contract that is the result of the exercise choice (``\"contractId\": \"#1:2\"``)."
  },
  {
    "id" : "60c7eb1f-2b37-444a-8c10-f3bf8295cf09",
    "prId" : 5660,
    "comments" : [
      {
        "id" : "1007dee0-c040-4add-af29-2a32bbf2ffc1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not sure if the reference to firesheep is appropriate. What do you think about a more neutral name like `--allow-tokens-without-tls`? I wouldn't be surprised if this breaks `create-daml-app` can you please test that it still works after this change, for instance by using `daml-sdk-head` and doing the first few steps of the getting started guide.",
        "createdAt" : "2020-04-23T14:45:40Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cfc61749-5916-4873-a9f5-a28b3edd597e",
        "parentId" : "1007dee0-c040-4add-af29-2a32bbf2ffc1",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "The current name comes from @garyverhaegen-da , how's this alternative?",
        "createdAt" : "2020-04-23T15:03:59Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1302f279-7488-4541-879b-934b964f6276",
        "parentId" : "1007dee0-c040-4add-af29-2a32bbf2ffc1",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "I also do not think the firesheep reference is necessarily appropriate. I'm also slowly realizing there are a lot of people in the internet that may be too young to understand it 😢\r\n\r\nI do think it needs to be \"scary\", though. I like cURL's `--insecure`, but could see something more specific, like `--allow-insecure-tokens` or the like.\r\n\r\n",
        "createdAt" : "2020-04-23T15:33:07Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "66a9cc18-21a9-4069-b86c-3a04bc65f832",
        "parentId" : "1007dee0-c040-4add-af29-2a32bbf2ffc1",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "> I'm also slowly realizing there are a lot of people in the internet that may be too young to understand it\r\n\r\nI seem to fall into that group :slightly_smiling_face: ",
        "createdAt" : "2020-04-23T15:34:50Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6df7a43a-245a-4f32-80dc-150c06ce548b",
        "parentId" : "1007dee0-c040-4add-af29-2a32bbf2ffc1",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "TIL I've been listening to Security Now for over 10 years.\r\n\r\n[Security Now, Episode #272: Firesheep](https://twit.tv/shows/security-now/episodes/272).",
        "createdAt" : "2020-04-23T15:38:20Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bf4ea346-c888-4057-8c96-a1b63a2213be",
        "parentId" : "1007dee0-c040-4add-af29-2a32bbf2ffc1",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Changed to `--allow-insecure-tokens` in abb4034c5e6835fa794b209061e178da8b3954dd.",
        "createdAt" : "2020-04-27T20:38:59Z",
        "updatedAt" : "2020-04-27T20:39:00Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "185ea518a2b61c43eb373b611650bcf599b2e5ee",
    "line" : 5,
    "diffHunk" : "@@ -103,6 +103,8 @@ From a DAML project directory:\n             prefix -- URL prefix,\n             directory -- local directory that will be mapped to the URL prefix.\n             Example: \"prefix=static,directory=./static-content\"\n+      --leak-passwords-firesheep-style\n+            DEV MODE ONLY (not recommended for production). Allow connections without a reverse proxy providing HTTPS."
  },
  {
    "id" : "c0ac0502-0e18-4030-975f-117a30c59e9e",
    "prId" : 5613,
    "comments" : [
      {
        "id" : "013ff0ad-ecad-4a03-8153-853dcc72bbeb",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "someone suggested `application/dalf`... I would rather use `application/octet-stream`.",
        "createdAt" : "2020-04-20T20:51:36Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b39c7815-82a6-413d-a270-eac6653ea601",
        "parentId" : "013ff0ad-ecad-4a03-8153-853dcc72bbeb",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I prefer the more generic `application/octet-stream`. I mean, what is a DALF in the grand scheme of things?",
        "createdAt" : "2020-04-21T11:50:49Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df0a5ae3b0ae4b91bca78266ae32c865a9e2fa97",
    "line" : null,
    "diffHunk" : "@@ -1064,6 +1064,120 @@ HTTP Response\n       \"status\": 200\n     }\n \n+List All DALF Packages\n+**********************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages``\n+- Method: ``GET``\n+- Content: <EMPTY>\n+\n+HTTP Response\n+=============\n+\n+.. code-block:: json\n+\n+    {\n+      \"result\": [\n+        \"c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd\",\n+        \"733e38d36a2759688a4b2c4cec69d48e7b55ecc8dedc8067b815926c917a182a\",\n+        \"bfcd37bd6b84768e86e432f5f6c33e25d9e7724a9d42e33875ff74f6348e733f\",\n+        \"40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7\",\n+        \"8a7806365bbd98d88b4c13832ebfa305f6abaeaf32cfa2b7dd25c4fa489b79fb\"\n+      ],\n+      \"status\": 200\n+    }\n+\n+Where ``result`` is the JSON array containing package IDs of all loaded DALFs.\n+\n+Download a DALF Package\n+***********************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages/download``\n+- Method: ``POST``\n+- Content-Type: ``application/json``\n+- Content:\n+\n+.. code-block:: json\n+\n+    {\n+      \"packageId\": \"c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd\"\n+    }\n+\n+HTTP Response, status: 200 OK\n+=============================\n+\n+- Transfer-Encoding: ``chunked``\n+- Content-Type: ``application/dalf``"
  },
  {
    "id" : "317614ad-5c77-4d98-8d99-f398e2d7f60d",
    "prId" : 5613,
    "comments" : [
      {
        "id" : "e384fe6f-e2c7-46bc-86f2-1555d5a21836",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n- URL: ``/v1/packages/list``\r\n```\r\nOtherwise `/v1/packages` is a prefix of the two other packaging endpoints which always has potential for confusion.",
        "createdAt" : "2020-04-21T09:30:21Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "39d7606f-dd0c-4131-b364-efc3dc47e793",
        "parentId" : "e384fe6f-e2c7-46bc-86f2-1555d5a21836",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "https://restfulapi.net/resource-naming/\r\nsee `Never use CRUD function names in URIs`",
        "createdAt" : "2020-04-21T19:43:05Z",
        "updatedAt" : "2020-04-21T19:43:05Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df0a5ae3b0ae4b91bca78266ae32c865a9e2fa97",
    "line" : 10,
    "diffHunk" : "@@ -1064,6 +1064,120 @@ HTTP Response\n       \"status\": 200\n     }\n \n+List All DALF Packages\n+**********************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages``"
  },
  {
    "id" : "7f0e132d-ea95-4d3e-968b-19138424eaa1",
    "prId" : 5613,
    "comments" : [
      {
        "id" : "d6299e35-c952-4d24-9958-9134dfca94d6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "How hard would this be?\r\n```suggestion\r\n- URL: ``/v1/packages/download/<package-id>``\r\n- Method: ``GET``\r\n```\r\nThat would greatly simplify downloading DALFs.",
        "createdAt" : "2020-04-21T11:49:07Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b86a2763-e151-4069-a484-8677bf5c29cb",
        "parentId" : "d6299e35-c952-4d24-9958-9134dfca94d6",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "this would be inconsistent with the query and fetch endpoints and would require to deal with akka DSL for routes, which I tried to avoid for as long as I could :)",
        "createdAt" : "2020-04-21T12:23:24Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "80ae0102-14e3-4e37-be29-2154d06b1528",
        "parentId" : "d6299e35-c952-4d24-9958-9134dfca94d6",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "if we really want to have REST-like endpoints, we should change it to:\r\nGET `/v1/packages` -- list packages\r\nGET `/v1/packages/<id>` -- download package\r\nPOST `/v1/packags` -- upload\r\n",
        "createdAt" : "2020-04-21T12:25:02Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "49cb5f82-39d9-435e-bd52-b7d556b8ede3",
        "parentId" : "d6299e35-c952-4d24-9958-9134dfca94d6",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit I have implemented it as I specified in the previous comment.",
        "createdAt" : "2020-04-21T17:08:51Z",
        "updatedAt" : "2020-04-21T17:08:52Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df0a5ae3b0ae4b91bca78266ae32c865a9e2fa97",
    "line" : null,
    "diffHunk" : "@@ -1064,6 +1064,120 @@ HTTP Response\n       \"status\": 200\n     }\n \n+List All DALF Packages\n+**********************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages``\n+- Method: ``GET``\n+- Content: <EMPTY>\n+\n+HTTP Response\n+=============\n+\n+.. code-block:: json\n+\n+    {\n+      \"result\": [\n+        \"c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd\",\n+        \"733e38d36a2759688a4b2c4cec69d48e7b55ecc8dedc8067b815926c917a182a\",\n+        \"bfcd37bd6b84768e86e432f5f6c33e25d9e7724a9d42e33875ff74f6348e733f\",\n+        \"40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7\",\n+        \"8a7806365bbd98d88b4c13832ebfa305f6abaeaf32cfa2b7dd25c4fa489b79fb\"\n+      ],\n+      \"status\": 200\n+    }\n+\n+Where ``result`` is the JSON array containing package IDs of all loaded DALFs.\n+\n+Download a DALF Package\n+***********************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages/download``\n+- Method: ``POST``"
  },
  {
    "id" : "1792c9ca-2a2a-4e29-81f6-2c7f16e0514d",
    "prId" : 5613,
    "comments" : [
      {
        "id" : "66d9ef91-93b9-40ad-9bb1-889a0add1434",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "To me \"spray-json encoded `Unit`\" does make only very little sense and I wouldn't be surprised if it didn't make any sense at all to our users. That said, can we please remove this sentence. The result field could carry the number of successfully uploaded DARs and this problem would go away, right?",
        "createdAt" : "2020-04-21T11:53:46Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9cf3aa45-4f5b-4ac9-9cee-873a3a03fa66",
        "parentId" : "66d9ef91-93b9-40ad-9bb1-889a0add1434",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "it does not have any other meaning but Unit :)... but I am fine with removing this sentence completely.",
        "createdAt" : "2020-04-21T12:26:15Z",
        "updatedAt" : "2020-04-21T17:06:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df0a5ae3b0ae4b91bca78266ae32c865a9e2fa97",
    "line" : null,
    "diffHunk" : "@@ -1064,6 +1064,120 @@ HTTP Response\n       \"status\": 200\n     }\n \n+List All DALF Packages\n+**********************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages``\n+- Method: ``GET``\n+- Content: <EMPTY>\n+\n+HTTP Response\n+=============\n+\n+.. code-block:: json\n+\n+    {\n+      \"result\": [\n+        \"c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd\",\n+        \"733e38d36a2759688a4b2c4cec69d48e7b55ecc8dedc8067b815926c917a182a\",\n+        \"bfcd37bd6b84768e86e432f5f6c33e25d9e7724a9d42e33875ff74f6348e733f\",\n+        \"40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7\",\n+        \"8a7806365bbd98d88b4c13832ebfa305f6abaeaf32cfa2b7dd25c4fa489b79fb\"\n+      ],\n+      \"status\": 200\n+    }\n+\n+Where ``result`` is the JSON array containing package IDs of all loaded DALFs.\n+\n+Download a DALF Package\n+***********************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages/download``\n+- Method: ``POST``\n+- Content-Type: ``application/json``\n+- Content:\n+\n+.. code-block:: json\n+\n+    {\n+      \"packageId\": \"c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd\"\n+    }\n+\n+HTTP Response, status: 200 OK\n+=============================\n+\n+- Transfer-Encoding: ``chunked``\n+- Content-Type: ``application/dalf``\n+- Content: <DALF bytes>\n+\n+The content (body) of the HTTP response contains raw DALF package bytes, without any encoding. Note that the ``packageId`` passed in the request is actually the SHA-256 hash of the downloaded DALF package and can be used to validate the integrity of the downloaded content.\n+\n+HTTP Response with Error, any status different from 200 OK\n+==========================================================\n+\n+Any status different from ``200 OK`` will be in the format specified below.\n+\n+- Content-Type: ``application/json``\n+- Content:\n+\n+.. code-block:: json\n+\n+    {\n+        \"errors\": [\n+            \"io.grpc.StatusRuntimeException: NOT_FOUND\"\n+        ],\n+        \"status\": 500\n+    }\n+\n+Upload a DAR File\n+*****************\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/packages/upload``\n+- Method: ``POST``\n+- Content-Type: ``application/octet-stream``\n+- Content: <DAR bytes>\n+\n+The content (body) of the HTTP request contains raw DAR file bytes, without any encoding.\n+\n+HTTP Response, status: 200 OK\n+=============================\n+\n+- Content-Type: ``application/json``\n+- Content:\n+\n+.. code-block:: json\n+\n+    {\n+        \"result\": 1,\n+        \"status\": 200\n+    }\n+\n+Where ``1`` is the spray-json encoded ``Unit``, there is not any additional meaning to this value."
  },
  {
    "id" : "f6ee7485-f956-47d9-94ec-46b03c6133da",
    "prId" : 5501,
    "comments" : [
      {
        "id" : "9b228021-4abb-4900-99e7-8ef825614593",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@gerolf-da do we want to keep it as Quickstart guide for now?\r\nCarol mentioned that `we are replacing Quickstart with Getting Started in SDK 1.0`...\r\nchanging the title to Getting Started, link does not change.",
        "createdAt" : "2020-04-08T17:43:41Z",
        "updatedAt" : "2020-04-09T14:47:57Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5a8aed55-20e3-4107-8e5c-5a25a486c49d",
        "parentId" : "9b228021-4abb-4900-99e7-8ef825614593",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please keep the title as quickstart. We should continue to use unambiguous names between the two. Ideally the JSON API docs use templates and examples from the new getting started guide. ",
        "createdAt" : "2020-04-08T17:49:50Z",
        "updatedAt" : "2020-04-09T14:47:57Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cc12f298-9eed-479e-afb6-aad54cd27b3c",
        "parentId" : "9b228021-4abb-4900-99e7-8ef825614593",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "reverted this part back to Quickstart guide, did not know there will be a new doc... thought we are only renaming Quickstart to Getting Started.",
        "createdAt" : "2020-04-08T18:10:38Z",
        "updatedAt" : "2020-04-09T14:47:57Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ae340745-e33e-412c-bc37-b738b0a04996",
        "parentId" : "9b228021-4abb-4900-99e7-8ef825614593",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Shall we call it the \"Java bindings quickstart guide\" to be even more clear?",
        "createdAt" : "2020-04-09T11:13:58Z",
        "updatedAt" : "2020-04-09T14:47:57Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "52ffb3c48d7534f75fc8804ac38c76a758fdd6d8",
    "line" : null,
    "diffHunk" : "@@ -316,7 +314,7 @@ Examples\n Create a new Contract\n *********************\n \n-See the request documentation below on how to create an instance of ``Iou`` contract from the :doc:`Quickstart guide </app-dev/bindings-java/quickstart>`:\n+See the request documentation below on how to create an instance of ``Iou`` contract from the :doc:`Getting Started guide </app-dev/bindings-java/quickstart>`:"
  },
  {
    "id" : "1949bd0b-2240-4e25-9f7c-f31210de561a",
    "prId" : 5456,
    "comments" : [
      {
        "id" : "ee56f2ec-bb84-432c-be9a-216047321b6a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would merge this section and the one about empty responses and say here that the result might be an empty list if none of the parties is known.\r\n```suggestion\r\nResponse with Unknown Parties Warning\r\n```",
        "createdAt" : "2020-04-07T13:56:01Z",
        "updatedAt" : "2020-04-07T13:56:33Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "973dad8b65873fb44284364221d1463b0b8030e2",
    "line" : 17,
    "diffHunk" : "@@ -977,8 +977,8 @@ Where\n - ``displayName`` -- optional human readable name associated with the party. Might not be unique,\n - ``isLocal`` -- true if party is hosted by the backing participant.\n \n-HTTP Response OK(200) with Unknown Parties Warning\n-==================================================\n+Nonempty Response with Unknown Parties Warning"
  },
  {
    "id" : "4d47b57f-1c99-4ed4-82e5-4c7db718f39f",
    "prId" : 5454,
    "comments" : [
      {
        "id" : "cd1c27d6-5428-4726-927f-a3479cd20e0e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n            Optional file where to write the allocated HTTP port number. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is, no file gets created/updated.\r\n```",
        "createdAt" : "2020-04-06T18:10:53Z",
        "updatedAt" : "2020-04-08T16:28:33Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d9cec789b9965322dc5e0bca30fec585e45ff851",
    "line" : null,
    "diffHunk" : "@@ -72,7 +72,9 @@ From a DAML project directory:\n       --address <value>\n             IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n       --http-port <value>\n-            HTTP JSON API service port number\n+            HTTP JSON API service port number. A port number of 0 will let the system pick up an ephemeral port. Consider specifying port-file option with port number 0.\n+      --port-file <value>\n+            Optional file where to write the allocated HTTP port number. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is file does not get created/updated."
  },
  {
    "id" : "02799319-3dfb-4fa1-858e-5d0fd5f67b0b",
    "prId" : 5454,
    "comments" : [
      {
        "id" : "4e7a9273-6a2b-4829-b51c-71a3a350d984",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying the ``--port-file`` option with port number 0.\r\n```",
        "createdAt" : "2020-04-06T18:11:25Z",
        "updatedAt" : "2020-04-08T16:28:33Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d9cec789b9965322dc5e0bca30fec585e45ff851",
    "line" : null,
    "diffHunk" : "@@ -72,7 +72,9 @@ From a DAML project directory:\n       --address <value>\n             IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n       --http-port <value>\n-            HTTP JSON API service port number\n+            HTTP JSON API service port number. A port number of 0 will let the system pick up an ephemeral port. Consider specifying port-file option with port number 0."
  },
  {
    "id" : "d31e783b-7192-48d5-9e01-ec9b6f42700a",
    "prId" : 5454,
    "comments" : [
      {
        "id" : "bed09409-fe00-48ad-96d1-1fb5adc5b2e9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n            Optional file where to write the allocated HTTP port number. This can be used to inform clients in CI about which port the HTTP JSON API listens on. Defaults to none, that is, no file gets created/updated.\r\n```",
        "createdAt" : "2020-04-06T18:12:53Z",
        "updatedAt" : "2020-04-08T16:28:33Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d9cec789b9965322dc5e0bca30fec585e45ff851",
    "line" : null,
    "diffHunk" : "@@ -72,7 +72,9 @@ From a DAML project directory:\n       --address <value>\n             IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n       --http-port <value>\n-            HTTP JSON API service port number\n+            HTTP JSON API service port number. A port number of 0 will let the system pick up an ephemeral port. Consider specifying port-file option with port number 0.\n+      --port-file <value>\n+            Optional file where to write the allocated HTTP port number. Used to inform clients in CI about which port HTTP JSON API listens on. Defaults to none, that is file does not get created/updated."
  },
  {
    "id" : "280599f2-7104-4c4f-acc9-081ca8520ebb",
    "prId" : 5454,
    "comments" : [
      {
        "id" : "85ca1131-390f-4a27-9ebf-db2aea3ad744",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Isn't it like this in RST?\r\n```suggestion\r\n            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying ``--port-file`` option with port number 0.\r\n```",
        "createdAt" : "2020-04-07T09:18:50Z",
        "updatedAt" : "2020-04-08T16:28:33Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c5566bc0-ad37-4f18-84b0-4d133cb8a414",
        "parentId" : "85ca1131-390f-4a27-9ebf-db2aea3ad744",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "yes, it is like this in rst, but this is a copy/paste from `daml json-api --help`.",
        "createdAt" : "2020-04-07T13:54:52Z",
        "updatedAt" : "2020-04-08T16:28:33Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d9cec789b9965322dc5e0bca30fec585e45ff851",
    "line" : 5,
    "diffHunk" : "@@ -72,9 +72,9 @@ From a DAML project directory:\n       --address <value>\n             IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.\n       --http-port <value>\n-            HTTP JSON API service port number. A port number of 0 will let the system pick up an ephemeral port. Consider specifying port-file option with port number 0.\n+            HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port. Consider specifying `--port-file` option with port number 0."
  },
  {
    "id" : "1a54cad2-7b6a-4073-a255-a015be8c55ed",
    "prId" : 5395,
    "comments" : [
      {
        "id" : "937b8dce-850e-4056-9487-2792710b34dd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not convinced this is the right behaviour. I assume the intent is to bring it line with the `query` endpoint. However, parties are a runtime thing whereas templates are a compile time thing. Thus, asking for a list of templates that happens to be empty is very likely a programming error. In contrast, asking for a list of parties where none of them can be resolved seems like more usual business to me. Thus, changing the behaviour depending on whether at least one party could be resolved is the wrong thing to do in my opinion. (Asking for an empty list of parties should still be an error though since that's clearly a programming error.)",
        "createdAt" : "2020-04-06T11:36:17Z",
        "updatedAt" : "2020-04-06T11:36:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7b25fa7d-4f24-4311-8bfa-658d959780ee",
        "parentId" : "937b8dce-850e-4056-9487-2792710b34dd",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit yes, that is the intent.\r\n\r\nIn my experience if you are fetching something by ID (template ID or party ID) and there is no entity with that ID, -- this is an error. It is a common practice in RESTful APIs to return 40x status in this case.... we are not RESTful though....\r\n\r\nWe currently return an error only if all of the IDs do not exist. I think we should return an error, if at least one of the IDs does not exist, but I remember you had a strong opinion about non-existent template IDs.\r\n\r\nUp to you if you want to treat template IDs and party IDs differently, it is easy to change this error to OK(200) for the party lookup by ID.",
        "createdAt" : "2020-04-06T18:44:33Z",
        "updatedAt" : "2020-04-06T19:11:23Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "deec5503-0367-47fc-af4a-58fdc3236747",
        "parentId" : "937b8dce-850e-4056-9487-2792710b34dd",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "PR: #5456",
        "createdAt" : "2020-04-06T19:10:45Z",
        "updatedAt" : "2020-04-06T19:10:45Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a6c0705ce91a60c3ff16e10f07520b7ae462f835",
    "line" : 34,
    "diffHunk" : "@@ -1004,13 +1004,29 @@ HTTP Response with Unknown Parties Warning\n         }\n       ],\n       \"warnings\": {\n-        \"unknownParties\": [\n-          \"Erin\"\n-        ]\n+        \"unknownParties\": [\"Erin\"]\n       },\n       \"status\": 200\n     }\n \n+BadRequest(400) Response with Unknown Parties Warning"
  },
  {
    "id" : "42277475-69e1-4359-b381-8fe4180d30c0",
    "prId" : 5234,
    "comments" : [
      {
        "id" : "c9c40297-edea-41ff-9cc9-47f2e22071c6",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "you need it when you run it from command line, the line above mentions Node.js BTW:\r\n> JavaScript/Node.js example demonstrating how to establish Streaming API connection:\r\n\r\nRemove Node.js and say something like In-browser JavaScript.\r\n",
        "createdAt" : "2020-03-27T15:15:12Z",
        "updatedAt" : "2020-03-27T15:15:13Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "03d6534ca2c69aef98b2e55b0da8e55e1bfacf49",
    "line" : 4,
    "diffHunk" : "@@ -1053,25 +1053,21 @@ JavaScript/Node.js example demonstrating how to establish Streaming API connecti\n \n .. code-block:: javascript\n \n-    const WebSocket = require(\"ws\")"
  },
  {
    "id" : "bfb06e27-39ae-4538-bba6-dd22857927b9",
    "prId" : 5141,
    "comments" : [
      {
        "id" : "84b4d703-727b-4054-9b73-aa3a7f5be83b",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I think you would typically write the JS object as an object and then encode it to JSON, yes?",
        "createdAt" : "2020-03-24T18:26:34Z",
        "updatedAt" : "2020-03-24T19:01:57Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "83da5cc0-5ce9-4726-a7c3-e582add5a3ae",
        "parentId" : "84b4d703-727b-4054-9b73-aa3a7f5be83b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "this is Javascript, no types who cares :) but yeah `JSON.stringify` should do the trick. I will change it.\r\n",
        "createdAt" : "2020-03-24T18:52:33Z",
        "updatedAt" : "2020-03-24T19:01:57Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e2d5bf5f-1614-475f-a3ba-38a4d79bd4a4",
        "parentId" : "84b4d703-727b-4054-9b73-aa3a7f5be83b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "```\r\n    ws.on(\"open\", function open() {\r\n      ws.send(JSON.stringify({templateIds: [\"Iou:Iou\"]}))\r\n    })\r\n```",
        "createdAt" : "2020-03-24T19:02:29Z",
        "updatedAt" : "2020-03-24T19:02:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ad01f95f-5c9f-4282-958d-1027c38a4cbd",
        "parentId" : "84b4d703-727b-4054-9b73-aa3a7f5be83b",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "For sure :) you can at least catch dumb syntax typos like missing `}` or `\"` this way.",
        "createdAt" : "2020-03-24T19:06:13Z",
        "updatedAt" : "2020-03-24T19:06:13Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "50f66c76e24700666f441ee9f3f1d09467881486",
    "line" : null,
    "diffHunk" : "@@ -1053,6 +1055,54 @@ Streaming API\n Two subprotocols must be passed with every request, as described in\n `Passing token with WebSockets <#passing-token-with-websockets>`__.\n \n+JavaScript/Node.js example demonstrating how to establish Streaming API connection:\n+\n+.. code-block:: javascript\n+\n+    const WebSocket = require(\"ws\")\n+\n+    console.log(\"Starting\")\n+\n+    const tokenPrefix = \"jwt.token.\"\n+    const wsProtocol = \"daml.ws.auth\"\n+    const jwt =\n+      \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU\"\n+    const subprotocol = `${tokenPrefix}${jwt},${wsProtocol}`\n+\n+    const ws = new WebSocket(\"ws://localhost:7575/v1/stream/query\", [subprotocol])\n+\n+    ws.on(\"open\", function open() {\n+      ws.send(`{\"templateIds\": [\"Iou:Iou\"]}`)"
  },
  {
    "id" : "a6d5aeed-d5bc-4f1c-8e70-fe4ed65683fe",
    "prId" : 5003,
    "comments" : [
      {
        "id" : "ec4d26d8-00e9-4d99-a8a4-7842105ac8d3",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit we should rename `offsetHint` to `contractIdHint` or `activeContractHint`.\r\n\r\nRemember we have ledger offset/bookmark tick defined as:\r\n```\r\n{\"events\":[],\"offset\":\"5609\"}\r\n```\r\nThe `offset` value from the tick is `domain.Offset` and `offsetHint` from the streaming fetch request is `domain.ContractId` -- two totally different types.\r\n",
        "createdAt" : "2020-03-25T21:44:12Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c2aac822-8c00-493b-b1a0-260529e2e108",
        "parentId" : "ec4d26d8-00e9-4d99-a8a4-7842105ac8d3",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "let's merge it... and discuss the rename during the catch-up meeting.",
        "createdAt" : "2020-03-25T21:55:42Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7f31affb-44fe-4132-99e4-5e3f0dcf2930",
        "parentId" : "ec4d26d8-00e9-4d99-a8a4-7842105ac8d3",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Yes, I think `contractIdHint` (or maybe `contractIdAtOffset`?) would be a better name.",
        "createdAt" : "2020-03-26T15:54:27Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fb758989-55bc-4703-a2f4-1d2d7459efdc",
        "parentId" : "ec4d26d8-00e9-4d99-a8a4-7842105ac8d3",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "> `contractIdAtOffset`\r\n\r\nWhat we've decided on.",
        "createdAt" : "2020-03-26T16:07:35Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "34690538c6de2edd3408eda80d4411bf3daabe19",
    "line" : null,
    "diffHunk" : "@@ -1302,3 +1302,27 @@ Example:\n     ]\n \n The output stream has the same format as the output from the `Contracts Query Stream`_. We further guarantee that for every ``archived`` event appearing on the stream there has been a matching ``created`` event earlier in the stream.\n+\n+You may supply an optional ``offset`` for the stream, exactly as with\n+query streams.  However, you must supply with each ``{templateId,\n+key}`` pair an ``offsetHint``, which is the contract ID currently\n+associated with that pair at the point of the given offset, or\n+``null`` if no contract ID was associated with the pair at that\n+offset.  For example, with the above keys, if you had one ``\"abc123\"``\n+contract but no `\"def345\"` contract, you might specify:\n+\n+.. code-block:: json\n+\n+    [\n+        {\"templateId\": \"Account:Account\", \"key\": {\"_1\": \"Alice\", \"_2\": \"abc123\"},\n+         \"offsetHint\": \"#1:0\"},\n+        {\"templateId\": \"Account:Account\", \"key\": {\"_1\": \"Alice\", \"_2\": \"def345\"},\n+         \"offsetHint\": null}\n+    ]"
  },
  {
    "id" : "2f2b7cd6-219b-4b4f-8fbf-34444c6dad52",
    "prId" : 5003,
    "comments" : [
      {
        "id" : "b4d6761f-c4c4-4f1a-8646-49112ffeae21",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\ncontract but no ``\"def345\"`` contract, you might specify:\r\n```",
        "createdAt" : "2020-03-26T15:54:57Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47f93660-4624-47ad-8f82-d7a7a5f708b6",
        "parentId" : "b4d6761f-c4c4-4f1a-8646-49112ffeae21",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "811a1a9952, thanks",
        "createdAt" : "2020-03-26T16:00:43Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "34690538c6de2edd3408eda80d4411bf3daabe19",
    "line" : null,
    "diffHunk" : "@@ -1302,3 +1302,27 @@ Example:\n     ]\n \n The output stream has the same format as the output from the `Contracts Query Stream`_. We further guarantee that for every ``archived`` event appearing on the stream there has been a matching ``created`` event earlier in the stream.\n+\n+You may supply an optional ``offset`` for the stream, exactly as with\n+query streams.  However, you must supply with each ``{templateId,\n+key}`` pair an ``offsetHint``, which is the contract ID currently\n+associated with that pair at the point of the given offset, or\n+``null`` if no contract ID was associated with the pair at that\n+offset.  For example, with the above keys, if you had one ``\"abc123\"``\n+contract but no `\"def345\"` contract, you might specify:"
  },
  {
    "id" : "a999d8d5-d7bf-45c4-a929-e0fc1cec1392",
    "prId" : 5003,
    "comments" : [
      {
        "id" : "ccb992ed-1a81-41ca-9dd9-ad85b29d9533",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is there an explanation of what \"phantom archives\" are elsewhere?",
        "createdAt" : "2020-03-26T15:55:51Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "794592c9-0476-4b5e-9c8a-e64ece2f7954",
        "parentId" : "ccb992ed-1a81-41ca-9dd9-ad85b29d9533",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "[Yes, above.](https://github.com/digital-asset/daml/commit/fb4284595933a22c74304df39d64d6ccb78b5589#diff-acc1415ff18516eee3cce71dc3407d5cR1212-R1218)",
        "createdAt" : "2020-03-26T15:59:10Z",
        "updatedAt" : "2020-03-26T18:10:34Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "34690538c6de2edd3408eda80d4411bf3daabe19",
    "line" : null,
    "diffHunk" : "@@ -1302,3 +1302,27 @@ Example:\n     ]\n \n The output stream has the same format as the output from the `Contracts Query Stream`_. We further guarantee that for every ``archived`` event appearing on the stream there has been a matching ``created`` event earlier in the stream.\n+\n+You may supply an optional ``offset`` for the stream, exactly as with\n+query streams.  However, you must supply with each ``{templateId,\n+key}`` pair an ``offsetHint``, which is the contract ID currently\n+associated with that pair at the point of the given offset, or\n+``null`` if no contract ID was associated with the pair at that\n+offset.  For example, with the above keys, if you had one ``\"abc123\"``\n+contract but no `\"def345\"` contract, you might specify:\n+\n+.. code-block:: json\n+\n+    [\n+        {\"templateId\": \"Account:Account\", \"key\": {\"_1\": \"Alice\", \"_2\": \"abc123\"},\n+         \"offsetHint\": \"#1:0\"},\n+        {\"templateId\": \"Account:Account\", \"key\": {\"_1\": \"Alice\", \"_2\": \"def345\"},\n+         \"offsetHint\": null}\n+    ]\n+\n+If every ``offsetHint`` is specified, as is so in the example above,\n+you will not receive any ``archived`` events for contracts created\n+before the offset *unless* those contracts are identified in an\n+``offsetHint``.  By contrast, if any ``offsetHint`` is missing,\n+``archived`` event filtering will be disabled, and you will receive\n+\"phantom archives\" as with query streams."
  },
  {
    "id" : "6992c0fc-5b6d-426e-97be-798d4be93c6b",
    "prId" : 4886,
    "comments" : [
      {
        "id" : "3c728f3a-0fc4-4504-a4f6-6715c027649f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would qualify under which circumstances you can ignore them, namely when you don't care about ledger offsets.",
        "createdAt" : "2020-03-09T08:34:52Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "41ee53013c9760d2123824d5705920e4ed550345",
    "line" : null,
    "diffHunk" : "@@ -1075,7 +1075,9 @@ off an initial \"loading\" indicator::\n To keep the stream alive, you'll occasionally see messages like this,\n which can be safely ignored::"
  },
  {
    "id" : "f8cbaa06-f64f-4b63-ac0e-6e32d4934713",
    "prId" : 4819,
    "comments" : [
      {
        "id" : "bd978a95-4e66-4c9f-9e0c-62d2299521ee",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would move that block after the description of the \"main\" query format and replace *first* by something *before* the \"main\" query. My rationale is that I want the simple use case to come first and the more advanced stuff later. Other than that, the docs and the API are fine. Thanks a lot.",
        "createdAt" : "2020-03-12T16:34:28Z",
        "updatedAt" : "2020-03-12T21:56:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e7111767-fc79-464a-9c2a-0bb795573ca1",
        "parentId" : "bd978a95-4e66-4c9f-9e0c-62d2299521ee",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Moved to just before we start talking about output in e6995900820f8938086428468eb8627902072729",
        "createdAt" : "2020-03-12T21:24:10Z",
        "updatedAt" : "2020-03-12T21:56:01Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7292b064dc3328ac908ca2a8760915e6a17e30c7",
    "line" : null,
    "diffHunk" : "@@ -1021,6 +1021,13 @@ Contracts Query Stream\n List currently active contracts that match a given query, with\n continuous updates.\n \n+An optional ``offset`` returned by a prior query (see output examples\n+below) may be specified *first*, as a separate body.  It must be a\n+string, and if specified, the stream will begin immediately *after* the\n+response body that included that offset::\n+\n+    {\"offset\": \"5609\"}"
  },
  {
    "id" : "548ec163-7033-4d38-9288-ad483e4aabf5",
    "prId" : 4754,
    "comments" : [
      {
        "id" : "acccbd11-4cd0-49a9-9bbf-e343e50622b4",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit are you sure you want this? The original contract created and archived, we do not conflate here like we do in the streaming API.\r\n\r\n#4507 says:\r\n> Response format: exactly the resulting transaction tree you get from ledger-API in submit-and-wait, formatted exactly as for the exercise endpoint.",
        "createdAt" : "2020-02-28T19:13:21Z",
        "updatedAt" : "2020-03-02T17:35:31Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f7c4a2e3-3ab9-4555-9cd2-1b262f38f19f",
        "parentId" : "acccbd11-4cd0-49a9-9bbf-e343e50622b4",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "When using the streaming API, one is more interested in getting \"actionable\" contracts. For `create-and-exercise` I think it can make sense to return the response as is.\r\nFor the response to a regular `exercise` command we don't do any conflation of transient contracts either.",
        "createdAt" : "2020-03-02T14:54:49Z",
        "updatedAt" : "2020-03-02T17:35:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "303b6921-e0f1-44f2-b98d-a478db69f87a",
        "parentId" : "acccbd11-4cd0-49a9-9bbf-e343e50622b4",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "all right... leaving it as is.",
        "createdAt" : "2020-03-02T15:21:36Z",
        "updatedAt" : "2020-03-02T17:35:31Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bf2028f0-be2d-4c77-8923-457ad74bfd72",
        "parentId" : "acccbd11-4cd0-49a9-9bbf-e343e50622b4",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I prefer to _not_ conflate here. So, all good.",
        "createdAt" : "2020-03-04T15:53:07Z",
        "updatedAt" : "2020-03-04T15:54:31Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "37358a488d97c38be7a565409fb1d175d37a70b3",
    "line" : 47,
    "diffHunk" : "@@ -546,6 +546,111 @@ HTTP Response\n \n Formatted similar to :ref:`Exercise by Contract ID response <exercise-response>`.\n \n+Create and Exercise in the Same Transaction\n+*******************************************\n+\n+This command allows creating a contract and exercising a choice on the newly created contract in the same transaction.\n+\n+HTTP Request\n+============\n+\n+- URL: ``/v1/create-and-exercise``\n+- Method: ``POST``\n+- Content-Type: ``application/json``\n+- Content:\n+\n+.. code-block:: json\n+\n+    {\n+      \"templateId\": \"Iou:Iou\",\n+      \"payload\": {\n+        \"observers\": [],\n+        \"issuer\": \"Alice\",\n+        \"amount\": \"999.99\",\n+        \"currency\": \"USD\",\n+        \"owner\": \"Alice\"\n+      },\n+      \"choice\": \"Iou_Transfer\",\n+      \"argument\": {\n+        \"newOwner\": \"Bob\"\n+      }\n+    }\n+\n+Where:\n+\n+- ``templateId`` -- the initial contract template identifier, in the same format as in same as in the :ref:`create request <create-request>`,\n+- ``payload`` -- the initial contract fields as defined in the DAML template and formatted according to :doc:`lf-value-specification`,\n+- ``choice`` -- DAML contract choice, that is being exercised,\n+- ``argument`` -- contract choice argument(s).\n+\n+HTTP Response\n+=============\n+\n+Please note that the response below is for a consuming choice, so it contains:\n+\n+- ``created`` and ``archived`` events for the initial contract (``\"contractId\": \"#1:0\"``), which was created and archived right away when a consuming choice was exercised on it,\n+- a ``created`` event for the contract that is the result of the choice exercise (``\"contractId\": \"#1:2\"``)."
  },
  {
    "id" : "7d1a856b-43bc-48e7-af22-6c92853f43dd",
    "prId" : 4680,
    "comments" : [
      {
        "id" : "73ebc416-dc24-4cd6-8e7b-34913f402681",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not convinced that is a good idea. I prefer staying consistent and returning an empty array in that situation. If we want to be able to get all parties on the POST endpoint, we should signal this by sending no content at all. But do we actually want this?",
        "createdAt" : "2020-02-25T09:18:46Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "60962659-778a-4a34-8210-7ea08a9ce33c",
        "parentId" : "73ebc416-dc24-4cd6-8e7b-34913f402681",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "all right, we will return only parties specified in the input. Empty input array would mean empty array in the output.",
        "createdAt" : "2020-02-25T14:54:05Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2de26e43-ff31-4724-abb0-787284613724",
        "parentId" : "73ebc416-dc24-4cd6-8e7b-34913f402681",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "we actually expect a NonEmptyList of party ids now, if empty array passed, the current implementation returns a documented error:\r\n```\r\n{\r\n  \"status\": 400,\r\n  \"errors\": [\r\n    \"JsonReaderError. Cannot read JSON: <[]>. Cause: spray.json.DeserializationException: must be a list with at least 1 element\"\r\n  ]\r\n}\r\n```\r\nI think error makes more sense, why would you ask for an empty array. @hurryabit if you really want an empty response instead of an error, let me know.",
        "createdAt" : "2020-02-25T22:28:44Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "10b0c04a-f408-477c-a3cc-5f56937fb4dd",
        "parentId" : "73ebc416-dc24-4cd6-8e7b-34913f402681",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Erroring out on the empty list is fine too.",
        "createdAt" : "2020-02-26T09:22:41Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1c893cbb4ae4c432898f1636e3e8be6fbf07f824",
    "line" : null,
    "diffHunk" : "@@ -803,12 +803,19 @@ Nonempty HTTP Response with Unknown Template IDs Warning\n         \"status\": 200\n     }\n \n-Fetch All Known Parties\n-***********************\n+Fetch Parties by Identifiers\n+****************************\n \n - URL: ``/v1/parties``\n-- Method: ``GET``\n-- Content: <EMPTY>\n+- Method: ``POST``\n+- Content-Type: ``application/json``\n+- Content:\n+\n+.. code-block:: json\n+\n+    [\"Alice\", \"Bob\", \"Dave\"]\n+\n+If empty JSON array is passed: ``[]``, this endpoint will return all known parties."
  },
  {
    "id" : "f3d23875-c439-4df2-8612-d93292b150f3",
    "prId" : 4680,
    "comments" : [
      {
        "id" : "db3d6e7d-4d1c-4a67-90d3-f3123d589b89",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What happens if there are some known parties and some unknown parties? I expect that we only receive records for the known parties. We should consider adding a `warnings` field containing the unknown parties, but I'm fine doing this in a separate PR.",
        "createdAt" : "2020-02-25T09:20:37Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9074feca-19f7-49da-b128-68be87712042",
        "parentId" : "db3d6e7d-4d1c-4a67-90d3-f3123d589b89",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "~I will add warnings in the follow up PR~",
        "createdAt" : "2020-02-25T15:02:29Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "610c31dd-efff-47c4-99dd-a8830424ae41",
        "parentId" : "db3d6e7d-4d1c-4a67-90d3-f3123d589b89",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "scratch the above it is a rather small change, easier to add it to this PR and update the docs once.",
        "createdAt" : "2020-02-25T16:43:57Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1772ee64-1117-4049-a022-8821c870bf2c",
        "parentId" : "db3d6e7d-4d1c-4a67-90d3-f3123d589b89",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "scratch the above it is a rather small change, easier to add it to this PR and update the docs once.",
        "createdAt" : "2020-02-25T16:44:09Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1c893cbb4ae4c432898f1636e3e8be6fbf07f824",
    "line" : 62,
    "diffHunk" : "@@ -819,15 +826,47 @@ HTTP Response\n .. code-block:: json\n \n     {\n-        \"status\": 200,\n-        \"result\": [\n-            {\n-                \"party\": \"Alice\",\n-                \"isLocal\": true\n-            }\n-        ]\n+      \"status\": 200,\n+      \"result\": [\n+        {\n+          \"identifier\": \"Alice\",\n+          \"displayName\": \"Alice & Co. LLC\",\n+          \"isLocal\": true\n+        },\n+        {\n+          \"identifier\": \"Bob\",\n+          \"displayName\": \"Bob & Co. LLC\",\n+          \"isLocal\": true\n+        },\n+        {\n+          \"identifier\": \"Dave\",\n+          \"isLocal\": true\n+        }\n+      ]\n     }\n \n+Please note that the order of the party objects in the response is not guaranteed to match the order of the passed party identifiers."
  },
  {
    "id" : "7c9dc571-6fa4-4439-90f4-bcc1d01c94ec",
    "prId" : 4680,
    "comments" : [
      {
        "id" : "cd5d784f-ead8-464c-a3e6-297abbdf623e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If we clarify what happens with unknown parties above, this should not be needed anymore.",
        "createdAt" : "2020-02-25T09:21:05Z",
        "updatedAt" : "2020-02-26T14:39:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1c893cbb4ae4c432898f1636e3e8be6fbf07f824",
    "line" : null,
    "diffHunk" : "@@ -819,15 +826,47 @@ HTTP Response\n .. code-block:: json\n \n     {\n-        \"status\": 200,\n-        \"result\": [\n-            {\n-                \"party\": \"Alice\",\n-                \"isLocal\": true\n-            }\n-        ]\n+      \"status\": 200,\n+      \"result\": [\n+        {\n+          \"identifier\": \"Alice\",\n+          \"displayName\": \"Alice & Co. LLC\",\n+          \"isLocal\": true\n+        },\n+        {\n+          \"identifier\": \"Bob\",\n+          \"displayName\": \"Bob & Co. LLC\",\n+          \"isLocal\": true\n+        },\n+        {\n+          \"identifier\": \"Dave\",\n+          \"isLocal\": true\n+        }\n+      ]\n     }\n \n+Please note that the order of the party objects in the response is not guaranteed to match the order of the passed party identifiers.\n+\n+An empty JSON array will be returned in the ``result`` element of the response if passed identifiers did not match any party."
  },
  {
    "id" : "d6d339fb-304e-4225-bfcf-ce7ce554b67d",
    "prId" : 4593,
    "comments" : [
      {
        "id" : "6edeb175-9a06-4ba1-bfaf-78937e3ff51f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we say something about the type of the offset? Is it always a string? Or shall we treat it as something opaque whose only purpose it to pass it to the next call of this endpoint?",
        "createdAt" : "2020-02-26T16:54:44Z",
        "updatedAt" : "2020-02-26T17:16:56Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e7a78ffb-0823-489d-8637-959a8eaf9d0c",
        "parentId" : "6edeb175-9a06-4ba1-bfaf-78937e3ff51f",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "The previous paragraph mentions the rules for what it might be; do you think there is too much detail there?",
        "createdAt" : "2020-02-26T16:58:00Z",
        "updatedAt" : "2020-02-26T17:16:56Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2a7908a4-3e47-4887-85ba-bc2fc965408e",
        "parentId" : "6edeb175-9a06-4ba1-bfaf-78937e3ff51f",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Oh right\r\n> it may be `null` instead of a string.\r\n\r\nCan we guarantee that it's either a string or null? Or could it be something else? Particularly on other ledgers which can't represent the offset by a single number.",
        "createdAt" : "2020-02-26T17:00:16Z",
        "updatedAt" : "2020-02-26T17:16:56Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9f4d3f47-1ee6-412c-a6f6-2ff6cd583667",
        "parentId" : "6edeb175-9a06-4ba1-bfaf-78937e3ff51f",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Even for ledgers that want to use more structure, the ledger API requires them to string-encode it, and we merely pass-through for the purpose of #4509.\r\n\r\nhttps://github.com/digital-asset/daml/blob/4d734939c9490bd0cdfd5faf36351d1fcba12e73/ledger-api/grpc-definitions/com/digitalasset/ledger/api/v1/ledger_offset.proto#L14-L22",
        "createdAt" : "2020-02-26T17:10:57Z",
        "updatedAt" : "2020-02-26T17:16:56Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f9d2874d-3f2d-4931-aace-21030fb64805",
        "parentId" : "6edeb175-9a06-4ba1-bfaf-78937e3ff51f",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Then it makes sense. Thansl.",
        "createdAt" : "2020-02-26T18:20:17Z",
        "updatedAt" : "2020-02-26T18:20:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d8c3640f424750f2bb6655ae779d003b71b15bca",
    "line" : 63,
    "diffHunk" : "@@ -862,41 +862,40 @@ output a series of JSON documents, each ``payload`` formatted according\n to :doc:`lf-value-specification`::\n \n     {\n-        \"events\": [\n-            {\n-                \"created\": {\n+        \"events\": [{\n+            \"created\": {\n+                \"observers\": [],\n+                \"agreementText\": \"\",\n+                \"payload\": {\n                     \"observers\": [],\n-                    \"agreementText\": \"\",\n-                    \"payload\": {\n-                        \"observers\": [],\n-                        \"issuer\": \"Alice\",\n-                        \"amount\": \"999.99\",\n-                        \"currency\": \"USD\",\n-                        \"owner\": \"Alice\"\n-                    },\n-                    \"signatories\": [\n-                        \"Alice\"\n-                    ],\n-                    \"contractId\": \"#1:0\",\n-                    \"templateId\": \"b70bbfbc77a4790f66d4840cb19f657dd20848f5e2f64e39ad404a6cbd98cf75:Iou:Iou\"\n+                    \"issuer\": \"Alice\",\n+                    \"amount\": \"999.99\",\n+                    \"currency\": \"USD\",\n+                    \"owner\": \"Alice\"\n                 },\n-                \"matchedQueries\": [\n-                    1,\n-                    2\n-                ]\n-            }\n-        ]\n+                \"signatories\": [\"Alice\"],\n+                \"contractId\": \"#1:0\",\n+                \"templateId\": \"eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou\"\n+            },\n+            \"matchedQueries\": [1, 2]\n+        }]\n     }\n \n where ``matchedQueries`` indicates the 0-based indices into the request\n list of queries that matched this contract.\n \n-When the stream reaches the end of contracts that existed when the\n-request started, you'll receive a special message indicating the start\n-of \"live\" updates.  For example, you might use it to turn off an initial\n-\"loading\" indicator::\n+Every ``events`` block following the end of contracts that existed when\n+the request started includes an ``offset``.  The stream is guaranteed to\n+send an offset immediately at the beginning of this \"live\" data, which\n+may or may not contain any ``events``; if it does not contain events and\n+no events were emitted before, it may be ``null`` instead of a string.\n+For example, you might use it to turn off an initial \"loading\"\n+indicator::\n \n-    {\"live\": true}\n+    {\n+        \"events\": [],\n+        \"offset\": \"2\""
  },
  {
    "id" : "a3dd6297-df87-4730-bb51-7792ff2395cf",
    "prId" : 4593,
    "comments" : [
      {
        "id" : "e2c8c6e9-c63f-4bcd-9bd8-18dd8b27538d",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\nno events were emitted before, it may be ``null`` or a string; otherwise, it will be a string.\r\n```\r\n\r\nHow about this @hurryabit ?",
        "createdAt" : "2020-02-26T17:03:09Z",
        "updatedAt" : "2020-02-26T17:16:56Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c37c6716-39ad-49d6-9fed-2876fc1aeb86",
        "parentId" : "e2c8c6e9-c63f-4bcd-9bd8-18dd8b27538d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "So, we're guaranteeing that a proper ledger offset is always a string? Is that true on ledgers more distributed than the sandbox?",
        "createdAt" : "2020-02-26T17:05:40Z",
        "updatedAt" : "2020-02-26T17:16:56Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4f9c5a9f-6ae0-4432-a113-b65a4501145e",
        "parentId" : "e2c8c6e9-c63f-4bcd-9bd8-18dd8b27538d",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "See previous thread https://github.com/digital-asset/daml/pull/4593#discussion_r384637525",
        "createdAt" : "2020-02-26T18:16:22Z",
        "updatedAt" : "2020-02-26T18:16:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d8c3640f424750f2bb6655ae779d003b71b15bca",
    "line" : null,
    "diffHunk" : "@@ -862,41 +862,40 @@ output a series of JSON documents, each ``payload`` formatted according\n to :doc:`lf-value-specification`::\n \n     {\n-        \"events\": [\n-            {\n-                \"created\": {\n+        \"events\": [{\n+            \"created\": {\n+                \"observers\": [],\n+                \"agreementText\": \"\",\n+                \"payload\": {\n                     \"observers\": [],\n-                    \"agreementText\": \"\",\n-                    \"payload\": {\n-                        \"observers\": [],\n-                        \"issuer\": \"Alice\",\n-                        \"amount\": \"999.99\",\n-                        \"currency\": \"USD\",\n-                        \"owner\": \"Alice\"\n-                    },\n-                    \"signatories\": [\n-                        \"Alice\"\n-                    ],\n-                    \"contractId\": \"#1:0\",\n-                    \"templateId\": \"b70bbfbc77a4790f66d4840cb19f657dd20848f5e2f64e39ad404a6cbd98cf75:Iou:Iou\"\n+                    \"issuer\": \"Alice\",\n+                    \"amount\": \"999.99\",\n+                    \"currency\": \"USD\",\n+                    \"owner\": \"Alice\"\n                 },\n-                \"matchedQueries\": [\n-                    1,\n-                    2\n-                ]\n-            }\n-        ]\n+                \"signatories\": [\"Alice\"],\n+                \"contractId\": \"#1:0\",\n+                \"templateId\": \"eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou\"\n+            },\n+            \"matchedQueries\": [1, 2]\n+        }]\n     }\n \n where ``matchedQueries`` indicates the 0-based indices into the request\n list of queries that matched this contract.\n \n-When the stream reaches the end of contracts that existed when the\n-request started, you'll receive a special message indicating the start\n-of \"live\" updates.  For example, you might use it to turn off an initial\n-\"loading\" indicator::\n+Every ``events`` block following the end of contracts that existed when\n+the request started includes an ``offset``.  The stream is guaranteed to\n+send an offset immediately at the beginning of this \"live\" data, which\n+may or may not contain any ``events``; if it does not contain events and\n+no events were emitted before, it may be ``null`` instead of a string."
  },
  {
    "id" : "64c10c00-8b89-4341-8896-ca0058ea72a3",
    "prId" : 4463,
    "comments" : [
      {
        "id" : "60b2894a-ef27-4f3e-8e95-099fb1ecd4e4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The MDN docs of the WebSocket class speak of \"protocols\" instead of \"subprotocols\". Should we say something like\r\n```suggestion\r\nWebSocket clients support a \"subprotocols\" (sometimes simply called \"protocols\") argument; this is usually in\r\n```",
        "createdAt" : "2020-02-10T19:12:47Z",
        "updatedAt" : "2020-02-10T19:35:16Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab714ccb-1a77-4311-a4a0-129fda47dd06",
        "parentId" : "60b2894a-ef27-4f3e-8e95-099fb1ecd4e4",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "50ce596438bcd3a53436ea5e1e232de1dd23b7ff ; thanks",
        "createdAt" : "2020-02-10T19:36:03Z",
        "updatedAt" : "2020-02-10T19:36:03Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "50ce596438bcd3a53436ea5e1e232de1dd23b7ff",
    "line" : null,
    "diffHunk" : "@@ -178,8 +179,28 @@ For production use, we have a tool in development for generating proper\n RSA-encrypted tokens locally, which will arrive when the service also\n supports such tokens.\n \n+Passing token with HTTP\n+=======================\n+\n+Set HTTP header ``Authorization: Bearer copy-paste-token-here`` for\n+normal requests.\n+\n+Passing token with WebSockets\n+=============================\n+\n+WebSocket clients support a \"subprotocols\" argument; this is usually in"
  },
  {
    "id" : "c82a702e-4356-4d2b-a7ec-eb74612d19b4",
    "prId" : 4436,
    "comments" : [
      {
        "id" : "ebb33ee8-c493-4e75-87b0-6375b02627ae",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "you did not update the Where section that explains what `contracts` now `events` element is",
        "createdAt" : "2020-02-06T19:42:53Z",
        "updatedAt" : "2020-02-06T19:47:31Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e8f6a561-2ff4-4633-9b7e-3a3e8e5660de",
        "parentId" : "ebb33ee8-c493-4e75-87b0-6375b02627ae",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "a9afe39b5e",
        "createdAt" : "2020-02-06T19:47:37Z",
        "updatedAt" : "2020-02-06T19:47:37Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a9afe39b5e87a6e8baf6081a1af87ec1223dffcc",
    "line" : 5,
    "diffHunk" : "@@ -431,7 +431,7 @@ HTTP Response\n         \"status\": 200,\n         \"result\": {\n             \"exerciseResult\": \"#201:1\",\n-            \"contracts\": [\n+            \"events\": ["
  },
  {
    "id" : "ba221afb-e532-4c44-b367-f5d28b1ca900",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "501ef752-8021-44a0-a234-f65d5dfc78a6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nList currently active contracts that match one of the given ``{templateId, key}`` pairs, with continuous updates.\r\n```",
        "createdAt" : "2020-02-05T19:20:30Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -892,27 +924,41 @@ Some notes on behavior:\n    results if you walk the array forwards, backwards, or in random\n    order.\n \n-Fetch All Known Parties\n-=======================\n+Fetch by Key Contracts Stream\n+-----------------------------\n \n-- URL: ``/parties``\n-- Method: ``GET``\n-- Content: <EMPTY>\n+- URL: ``/stream/fetch``\n+- Scheme: ``ws``\n+- Protocol: ``WebSocket``\n \n-HTTP Response\n--------------\n+List currently active contracts that match one of the given ``templateId - key`` pairs, with continuous updates."
  },
  {
    "id" : "4209fcf0-e188-4f5f-9f7c-42cf1255fb96",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "46febf6a-19b4-432c-8911-ad789c8197c9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we please always put the commas at the end of the previous line. This looks even weird to me as a Haskeller.",
        "createdAt" : "2020-02-05T19:21:50Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -892,27 +924,41 @@ Some notes on behavior:\n    results if you walk the array forwards, backwards, or in random\n    order.\n \n-Fetch All Known Parties\n-=======================\n+Fetch by Key Contracts Stream\n+-----------------------------\n \n-- URL: ``/parties``\n-- Method: ``GET``\n-- Content: <EMPTY>\n+- URL: ``/stream/fetch``\n+- Scheme: ``ws``\n+- Protocol: ``WebSocket``\n \n-HTTP Response\n--------------\n+List currently active contracts that match one of the given ``templateId - key`` pairs, with continuous updates.\n \n-- Content-Type: ``application/json``\n-- Content:\n+Similarly to `Contracts Query Stream`_, two subprotocols must be passed, as described in `Choosing a party\n+<#choosing-a-party>`__.\n+\n+``application/json`` body must be sent first, formatted according to the following rule:\n+\n+.. code-block:: none\n+\n+    [\n+        {\"templateId\": \"<template ID 1>\", \"key\": <key 1>}"
  },
  {
    "id" : "be715e5c-7d35-4a28-bce9-c1b7070a019a",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "9a423846-9ec8-4636-a246-1c2696fb6cf9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        {\"templateId\": \"Account:Account\", \"key\": {\"_1\": \"Alice\", \"_2\": \"abc123\"}}\r\n```\r\nI assume you wanted a pair here. They are encoded as `{_1: ..., _2: ...}`. Getting a key that would actually produce an array would be quite weird in surface DAML.",
        "createdAt" : "2020-02-05T19:24:17Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "87dab4ab-79e0-461f-856c-87c0f69e1e04",
        "parentId" : "9a423846-9ec8-4636-a246-1c2696fb6cf9",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "you can encode a pair both ways, I have a test that proves this.",
        "createdAt" : "2020-02-05T20:05:59Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0c175858-18d4-41f6-bb89-084d5dcaef31",
        "parentId" : "9a423846-9ec8-4636-a246-1c2696fb6cf9",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit \r\n\r\ndo you want the field names `_1` and `_2`? I will have to update the entire doc for consistency, because examples for non streaming fetch and exercise by key, use an array to encode `Tuple2`\r\n\r\nSee LF JSON spec: https://docs.daml.com/json-api/lf-value-specification.html#record\r\n> `[42, true]`\r\n> The motivation for the array format for records is to allow specifying tuple types closer to what it looks like in DAML. ",
        "createdAt" : "2020-02-05T20:10:29Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9e87bb9d-1b12-4a4a-acce-2a77d4cd4406",
        "parentId" : "9a423846-9ec8-4636-a246-1c2696fb6cf9",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "You're absolutely right. However, since the JSON API always returns pairs in the format I described, it would be better to use that format in the docs and leave the other format as a convenience feature for our users.",
        "createdAt" : "2020-02-05T20:10:31Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7bb0506d-d25f-446a-a98f-d2c503f3cb23",
        "parentId" : "9a423846-9ec8-4636-a246-1c2696fb6cf9",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If that's the same everywhere in the docs, then let's be consistent for now and fix it in the whole doc in one go.",
        "createdAt" : "2020-02-05T20:17:22Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "651cc40b-f7d0-4bed-8cda-b99b9fa35ffc",
        "parentId" : "9a423846-9ec8-4636-a246-1c2696fb6cf9",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "#4418 created to address the above documentation issue. Keeping the docs consistent for now.",
        "createdAt" : "2020-02-05T20:52:22Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -892,27 +924,41 @@ Some notes on behavior:\n    results if you walk the array forwards, backwards, or in random\n    order.\n \n-Fetch All Known Parties\n-=======================\n+Fetch by Key Contracts Stream\n+-----------------------------\n \n-- URL: ``/parties``\n-- Method: ``GET``\n-- Content: <EMPTY>\n+- URL: ``/stream/fetch``\n+- Scheme: ``ws``\n+- Protocol: ``WebSocket``\n \n-HTTP Response\n--------------\n+List currently active contracts that match one of the given ``templateId - key`` pairs, with continuous updates.\n \n-- Content-Type: ``application/json``\n-- Content:\n+Similarly to `Contracts Query Stream`_, two subprotocols must be passed, as described in `Choosing a party\n+<#choosing-a-party>`__.\n+\n+``application/json`` body must be sent first, formatted according to the following rule:\n+\n+.. code-block:: none\n+\n+    [\n+        {\"templateId\": \"<template ID 1>\", \"key\": <key 1>}\n+        , {\"templateId\": \"<template ID 2>\", \"key\": <key 2>}\n+        ...\n+        , {\"templateId\": \"<template ID N>\", \"key\": <key N>}\n+    ]\n+\n+Where:\n+\n+- ``templateId`` -- contract template identifier, same as in :ref:`create request <create-request>`,\n+- ``key`` -- contract key, formatted according to the :doc:`lf-value-specification`,\n+\n+Example:\n \n .. code-block:: json\n \n-    {\n-        \"status\": 200,\n-        \"result\": [\n-            {\n-                \"party\": \"Alice\",\n-                \"isLocal\": true\n-            }\n-        ]\n-    }\n+    [\n+        {\"templateId\": \"Account:Account\", \"key\": [\"Alice\", \"abc123\"]}"
  },
  {
    "id" : "479a3958-0fc1-491d-ac20-569f89901585",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "a8265488-b018-4a17-8933-170be3dee470",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nThe output stream has the same format as the output from the `Contracts Query Stream`_. We further guarantee that for every ``archived`` event appearing on the stream there has been a matching ``created`` event earlier in the stream.\r\n```",
        "createdAt" : "2020-02-05T19:26:11Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -892,27 +924,41 @@ Some notes on behavior:\n    results if you walk the array forwards, backwards, or in random\n    order.\n \n-Fetch All Known Parties\n-=======================\n+Fetch by Key Contracts Stream\n+-----------------------------\n \n-- URL: ``/parties``\n-- Method: ``GET``\n-- Content: <EMPTY>\n+- URL: ``/stream/fetch``\n+- Scheme: ``ws``\n+- Protocol: ``WebSocket``\n \n-HTTP Response\n--------------\n+List currently active contracts that match one of the given ``templateId - key`` pairs, with continuous updates.\n \n-- Content-Type: ``application/json``\n-- Content:\n+Similarly to `Contracts Query Stream`_, two subprotocols must be passed, as described in `Choosing a party\n+<#choosing-a-party>`__.\n+\n+``application/json`` body must be sent first, formatted according to the following rule:\n+\n+.. code-block:: none\n+\n+    [\n+        {\"templateId\": \"<template ID 1>\", \"key\": <key 1>}\n+        , {\"templateId\": \"<template ID 2>\", \"key\": <key 2>}\n+        ...\n+        , {\"templateId\": \"<template ID N>\", \"key\": <key N>}\n+    ]\n+\n+Where:\n+\n+- ``templateId`` -- contract template identifier, same as in :ref:`create request <create-request>`,\n+- ``key`` -- contract key, formatted according to the :doc:`lf-value-specification`,\n+\n+Example:\n \n .. code-block:: json\n \n-    {\n-        \"status\": 200,\n-        \"result\": [\n-            {\n-                \"party\": \"Alice\",\n-                \"isLocal\": true\n-            }\n-        ]\n-    }\n+    [\n+        {\"templateId\": \"Account:Account\", \"key\": [\"Alice\", \"abc123\"]}\n+        , {\"templateId\": \"Account:Account\", \"key\": [\"Alice\", \"def345\"]}\n+    ]\n+\n+The output stream is similar to the output from the `Contracts Query Stream`_. With only one exception: \"phantom archives\" *are* being filtered out."
  },
  {
    "id" : "cc2caa0e-9f66-4cf0-a9e5-ea162cd94f93",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "aa1d58eb-b06b-42d3-aa03-09eeeea9076f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What happens if the list is empty? Do we also allow the format `{\"templateId\": ..., \"key\": ...}` if the list contains only one element, i.e., `N = 1`? We should try to be consistent with the other endpoints in this regard. If we're not, I'm fine with addressing this in a separate PR.",
        "createdAt" : "2020-02-05T19:28:48Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "347c6448-ee6b-4047-a807-9d821795ea2a",
        "parentId" : "aa1d58eb-b06b-42d3-aa03-09eeeea9076f",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit \r\n\r\n1. Empty list would cause an error: `result: Vector(TextMessage.Strict({\"error\":\"Cannot resolve any templateId from request: List(), unresolved templateIds: Set()\"}))`\r\n2. The request must be a list of pairs. If all templates fails resolution, we return error.\r\n\r\nI will create a ticket to address the consistency.",
        "createdAt" : "2020-02-05T20:29:21Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6b2493b7-acff-4cf3-ba02-9eb8d3d9f537",
        "parentId" : "aa1d58eb-b06b-42d3-aa03-09eeeea9076f",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "#4417 created to validate and address the consistency.",
        "createdAt" : "2020-02-05T20:38:26Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : 86,
    "diffHunk" : "@@ -892,27 +924,41 @@ Some notes on behavior:\n    results if you walk the array forwards, backwards, or in random\n    order.\n \n-Fetch All Known Parties\n-=======================\n+Fetch by Key Contracts Stream\n+-----------------------------\n \n-- URL: ``/parties``\n-- Method: ``GET``\n-- Content: <EMPTY>\n+- URL: ``/stream/fetch``\n+- Scheme: ``ws``\n+- Protocol: ``WebSocket``\n \n-HTTP Response\n--------------\n+List currently active contracts that match one of the given ``templateId - key`` pairs, with continuous updates.\n \n-- Content-Type: ``application/json``\n-- Content:\n+Similarly to `Contracts Query Stream`_, two subprotocols must be passed, as described in `Choosing a party\n+<#choosing-a-party>`__.\n+\n+``application/json`` body must be sent first, formatted according to the following rule:\n+\n+.. code-block:: none\n+\n+    [\n+        {\"templateId\": \"<template ID 1>\", \"key\": <key 1>}\n+        , {\"templateId\": \"<template ID 2>\", \"key\": <key 2>}\n+        ...\n+        , {\"templateId\": \"<template ID N>\", \"key\": <key N>}\n+    ]"
  },
  {
    "id" : "e6fb38eb-84ec-473f-8d62-7f1766d3ac87",
    "prId" : 4390,
    "comments" : [
      {
        "id" : "26e1bc54-6102-4438-bb30-57831fa02d51",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n   contracts with the same template ID and contract key, the ``archived`` is\r\n```",
        "createdAt" : "2020-02-04T18:34:45Z",
        "updatedAt" : "2020-02-04T18:39:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b9eb4941-f7e6-409a-b39e-da60fa667be9",
        "parentId" : "26e1bc54-6102-4438-bb30-57831fa02d51",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Applied in 76472278d3; thanks",
        "createdAt" : "2020-02-04T18:39:30Z",
        "updatedAt" : "2020-02-04T18:39:31Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "76472278d3a75d2a5e32db91d58a3f93d4a9fd09",
    "line" : null,
    "diffHunk" : "@@ -873,15 +873,19 @@ Some notes on behavior:\n    ``created`` first or the ``archived`` first and be guaranteed to get\n    the same results.\n \n-3. You will almost certainly receive contract IDs in ``archived`` that\n+3. Within a given array, if an ``archived`` and ``created`` refer to\n+   contracts with the same template ID and key, the ``archived`` is"
  },
  {
    "id" : "6dc065ca-d359-4e7b-b89f-c111449312a5",
    "prId" : 4363,
    "comments" : [
      {
        "id" : "1a95b881-b54e-4b3c-a4af-903262d33776",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "@hurryabit Currently `\"matchedQueries\"` are always emitted as demonstrated in docs even if only one query is supplied; please let me know if this is undesirable.",
        "createdAt" : "2020-02-05T01:03:04Z",
        "updatedAt" : "2020-02-06T14:50:14Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "260ff18b-af34-4f61-9c07-7f6e6109a1e9",
        "parentId" : "1a95b881-b54e-4b3c-a4af-903262d33776",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think this is perfectly fine. Ignoring a field is no hard work.",
        "createdAt" : "2020-02-05T09:21:59Z",
        "updatedAt" : "2020-02-06T14:50:14Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0eebf6edfa656f053fe4aa62ae2b225acfed08a5",
    "line" : 24,
    "diffHunk" : "@@ -801,10 +810,14 @@ to :doc:`lf-value-specification`::\n             },\n             \"signatories\": [\"Alice\"],\n             \"contractId\": \"#1:0\",\n-            \"templateId\": \"6cc82609ede6576e5092e8c89a2c7a658efe15ae1347fc38eb316f787fa132bc:Iou:Iou\"\n-        }\n+            \"templateId\": \"b70bbfbc77a4790f66d4840cb19f657dd20848f5e2f64e39ad404a6cbd98cf75:Iou:Iou\"\n+        },\n+        \"matchedQueries\": [1, 2]"
  },
  {
    "id" : "4d8302c2-01a4-4f58-993e-8bf1240efb4a",
    "prId" : 4312,
    "comments" : [
      {
        "id" : "6c9ed067-9033-48ef-837e-0a15af1841f1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I like documentation. Thanks.",
        "createdAt" : "2020-01-30T21:28:24Z",
        "updatedAt" : "2020-01-30T21:28:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "78599c17af9a135b4807e32f1657f935a368ec00",
    "line" : 4,
    "diffHunk" : "@@ -847,6 +847,14 @@ and archives the one above, the same stream will eventually produce::\n         \"archived\": \"#1:0\"\n     }]\n \n+If any template IDs are found not to resolve, the first non-heartbeat"
  },
  {
    "id" : "06aef640-a68e-4021-9d25-33beb0df6b14",
    "prId" : 4173,
    "comments" : [
      {
        "id" : "f983a736-c4f2-410c-963c-008819f9926f",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Keep the description here informal, describing categories of functionality not enumerating features; fetch is already covered by \"query the current active contract set\".",
        "createdAt" : "2020-01-22T22:35:10Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b8cf409e8cef5b8914ce1acd514a03c9c86e5086",
    "line" : null,
    "diffHunk" : "@@ -12,22 +12,22 @@ tracker\n <https://github.com/digital-asset/daml/issues/new?milestone=HTTP+JSON+API+Maintenance>`_\n or `on Slack <https://hub.daml.com/slack/>`_.\n \n-The JSON API provides a significantly simpler way than :doc:`the Ledger\n-API </app-dev/index>` to access *basic active contract set\n-functionality*:\n+The **JSON API** provides a significantly simpler way than :doc:`the Ledger\n+API </app-dev/index>` to interact with a ledger by providing *basic active contract set functionality*:\n \n-- creating contracts,\n-- exercising choices on contracts, and\n-- querying the current active contract set.\n+- create contract,\n+- fetch active contract by contract ID or contract key,"
  },
  {
    "id" : "122b9bc6-eac7-4dff-aa48-5c9fbb5c2fb3",
    "prId" : 4173,
    "comments" : [
      {
        "id" : "ed3d6d34-e7a0-44c1-b600-c9594d9b3ad5",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\nIf client's HTTP GET or POST request reaches an API endpoint, the corresponding response will always contain a JSON object with ``status`` field and either ``errors`` or ``result``:\r\n```",
        "createdAt" : "2020-01-22T22:36:45Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b8cf409e8cef5b8914ce1acd514a03c9c86e5086",
    "line" : null,
    "diffHunk" : "@@ -152,243 +152,143 @@ add the subprotocols ``jwt.token.copy-paste-token-here`` and\n \n Here are two tokens you can use for testing:\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Alice\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQWxpY2UifQ.4HYfzjlYr1ApUDot0a6a4zB49zS_jrwRUOCkAiPMqo0``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Bob\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQm9iIn0.2LE3fAvUzLx495JWpuSzHye9YaH3Ddt4d2Pj0L1jSjA``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n   \n For production use, we have a tool in development for generating proper\n RSA-encrypted tokens locally, which will arrive when the service also\n supports such tokens.\n \n-GET ``/contracts/search``\n-=========================\n+Error Reporting\n+===============\n \n-List all currently active contracts for all known templates. Note that the retrieved contracts do not get persisted into query store database.\n+See the following blog post for more details: `REST API Error Codes 101 <https://blog.restcase.com/rest-api-error-codes-101/>`_.\n \n-The response is the same as for the POST method below.\n+The **JSON API** divides HTTP status codes in 3 groups indicating:\n \n-POST ``/contracts/search``\n-==========================\n+1. success (200)\n+2. failure due to a client-side problem (400, 401, 404)\n+3. failure due to a server-side problem (500)\n \n-List currently active contracts that match a given query.\n+The **JSON API** can return one of the following HTTP status codes:\n \n-Request\n--------\n+- 200 - OK\n+- 400 - Bad Request (Client Error)\n+- 401 - Unauthorized, authentication required\n+- 404 - Not Found\n+- 500 - Internal Server Error\n \n-application/json body, formatted according to the :doc:`search-query-language`:\n+If client's HTTP request reaches an API endpoint, the corresponding response will always contain a JSON object with ``status`` field and either ``errors`` or ``result``:"
  },
  {
    "id" : "de96bef3-feef-40f7-af7c-d8467c441ebc",
    "prId" : 4173,
    "comments" : [
      {
        "id" : "3a78e398-2eda-405c-bcb6-162d08855278",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It feels strange to me to start with a link to an external blog post. IMO, there should be at least a sentence stating that we use standard REST API error codes or something similar.",
        "createdAt" : "2020-01-23T09:37:12Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b8cf409e8cef5b8914ce1acd514a03c9c86e5086",
    "line" : null,
    "diffHunk" : "@@ -152,243 +152,143 @@ add the subprotocols ``jwt.token.copy-paste-token-here`` and\n \n Here are two tokens you can use for testing:\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Alice\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQWxpY2UifQ.4HYfzjlYr1ApUDot0a6a4zB49zS_jrwRUOCkAiPMqo0``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Bob\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQm9iIn0.2LE3fAvUzLx495JWpuSzHye9YaH3Ddt4d2Pj0L1jSjA``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n   \n For production use, we have a tool in development for generating proper\n RSA-encrypted tokens locally, which will arrive when the service also\n supports such tokens.\n \n-GET ``/contracts/search``\n-=========================\n+Error Reporting\n+===============\n \n-List all currently active contracts for all known templates. Note that the retrieved contracts do not get persisted into query store database.\n+See the following blog post for more details: `REST API Error Codes 101 <https://blog.restcase.com/rest-api-error-codes-101/>`_."
  },
  {
    "id" : "885b5f9c-c9a5-4848-b06b-34102fa88b6e",
    "prId" : 4173,
    "comments" : [
      {
        "id" : "c389196b-bd41-457c-bc8d-cdaa04f75a05",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We have `warnings` as well now.",
        "createdAt" : "2020-01-23T09:37:54Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b8cf409e8cef5b8914ce1acd514a03c9c86e5086",
    "line" : null,
    "diffHunk" : "@@ -152,243 +152,143 @@ add the subprotocols ``jwt.token.copy-paste-token-here`` and\n \n Here are two tokens you can use for testing:\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Alice\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQWxpY2UifQ.4HYfzjlYr1ApUDot0a6a4zB49zS_jrwRUOCkAiPMqo0``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Bob\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQm9iIn0.2LE3fAvUzLx495JWpuSzHye9YaH3Ddt4d2Pj0L1jSjA``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n   \n For production use, we have a tool in development for generating proper\n RSA-encrypted tokens locally, which will arrive when the service also\n supports such tokens.\n \n-GET ``/contracts/search``\n-=========================\n+Error Reporting\n+===============\n \n-List all currently active contracts for all known templates. Note that the retrieved contracts do not get persisted into query store database.\n+See the following blog post for more details: `REST API Error Codes 101 <https://blog.restcase.com/rest-api-error-codes-101/>`_.\n \n-The response is the same as for the POST method below.\n+The **JSON API** divides HTTP status codes in 3 groups indicating:\n \n-POST ``/contracts/search``\n-==========================\n+1. success (200)\n+2. failure due to a client-side problem (400, 401, 404)\n+3. failure due to a server-side problem (500)\n \n-List currently active contracts that match a given query.\n+The **JSON API** can return one of the following HTTP status codes:\n \n-Request\n--------\n+- 200 - OK\n+- 400 - Bad Request (Client Error)\n+- 401 - Unauthorized, authentication required\n+- 404 - Not Found\n+- 500 - Internal Server Error\n \n-application/json body, formatted according to the :doc:`search-query-language`:\n+If client's HTTP request reaches an API endpoint, the corresponding response will always contain a JSON object with ``status`` field and either ``errors`` or ``result``:\n \n-.. code-block:: json\n+.. code-block:: none\n \n     {\n-        \"templateIds\": [\"Iou:Iou\"],\n-        \"query\": {\"amount\": 999.99}\n+        \"status\": <400 | 401 | 404 | 500>,\n+        [ \"errors\": <JSON array of strings> ] | [ \"result\": <JSON object> ]\n     }\n \n-Empty Response\n---------------\n-\n-.. code-block:: json\n+Where:\n \n-    {\n-        \"status\": 200,\n-        \"result\": []\n-    }\n+- ``status`` -- a JSON Number which matches the HTTP response status code returned in the HTTP header,\n+- ``errors`` -- a JSON array of strings, each string represents one error,\n+- ``result`` -- a JSON object or JSON array, representing one or many results."
  },
  {
    "id" : "b5088a5f-8934-4a6c-a81a-d82be05f2126",
    "prId" : 4173,
    "comments" : [
      {
        "id" : "9cfa2d28-9cdb-4714-8f25-bc5fe036a57b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Haven't we renamed this to `payload`? If not, we should in order to make it consistent.",
        "createdAt" : "2020-01-23T09:39:48Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fe6af738-4019-45cd-89ab-8c341d76dd74",
        "parentId" : "9cfa2d28-9cdb-4714-8f25-bc5fe036a57b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit it is renamed only in the response. See #3826 :\r\n> I suggest we rename the argument field of the contracts you receive from the JSON API to payload.\r\n\r\nThis particular JSON is a create command, a request sent to JSON API.",
        "createdAt" : "2020-01-23T15:41:28Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6645d9c4-fd8e-4d05-84c4-e3b89089a63f",
        "parentId" : "9cfa2d28-9cdb-4714-8f25-bc5fe036a57b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "if you want to rename `argument` to the `payload` in the requests, this should be addressed in #4189.",
        "createdAt" : "2020-01-23T15:57:57Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b8cf409e8cef5b8914ce1acd514a03c9c86e5086",
    "line" : 449,
    "diffHunk" : "@@ -152,243 +152,143 @@ add the subprotocols ``jwt.token.copy-paste-token-here`` and\n \n Here are two tokens you can use for testing:\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Alice\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQWxpY2UifQ.4HYfzjlYr1ApUDot0a6a4zB49zS_jrwRUOCkAiPMqo0``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Alice\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJBbGljZSJdfX0.VdDI96mw5hrfM5ZNxLyetSVwcD7XtLT4dIdHIOa9lcU``\n \n-- ``{\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"party\": \"Bob\"}``\n-  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsZWRnZXJJZCI6Ik15TGVkZ2VyIiwiYXBwbGljYXRpb25JZCI6ImZvb2JhciIsInBhcnR5IjoiQm9iIn0.2LE3fAvUzLx495JWpuSzHye9YaH3Ddt4d2Pj0L1jSjA``\n+- ``{\"https://daml.com/ledger-api\": {\"ledgerId\": \"MyLedger\", \"applicationId\": \"foobar\", \"actAs\": [\"Bob\"]}}``\n+  ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJmb29iYXIiLCJhY3RBcyI6WyJCb2IiXX19.zU-iMSFG90na8IHacrS25xho3u6AKnSlTKbvpkaSyYw``\n   \n For production use, we have a tool in development for generating proper\n RSA-encrypted tokens locally, which will arrive when the service also\n supports such tokens.\n \n-GET ``/contracts/search``\n-=========================\n+Error Reporting\n+===============\n \n-List all currently active contracts for all known templates. Note that the retrieved contracts do not get persisted into query store database.\n+See the following blog post for more details: `REST API Error Codes 101 <https://blog.restcase.com/rest-api-error-codes-101/>`_.\n \n-The response is the same as for the POST method below.\n+The **JSON API** divides HTTP status codes in 3 groups indicating:\n \n-POST ``/contracts/search``\n-==========================\n+1. success (200)\n+2. failure due to a client-side problem (400, 401, 404)\n+3. failure due to a server-side problem (500)\n \n-List currently active contracts that match a given query.\n+The **JSON API** can return one of the following HTTP status codes:\n \n-Request\n--------\n+- 200 - OK\n+- 400 - Bad Request (Client Error)\n+- 401 - Unauthorized, authentication required\n+- 404 - Not Found\n+- 500 - Internal Server Error\n \n-application/json body, formatted according to the :doc:`search-query-language`:\n+If client's HTTP request reaches an API endpoint, the corresponding response will always contain a JSON object with ``status`` field and either ``errors`` or ``result``:\n \n-.. code-block:: json\n+.. code-block:: none\n \n     {\n-        \"templateIds\": [\"Iou:Iou\"],\n-        \"query\": {\"amount\": 999.99}\n+        \"status\": <400 | 401 | 404 | 500>,\n+        [ \"errors\": <JSON array of strings> ] | [ \"result\": <JSON object> ]\n     }\n \n-Empty Response\n---------------\n-\n-.. code-block:: json\n+Where:\n \n-    {\n-        \"status\": 200,\n-        \"result\": []\n-    }\n+- ``status`` -- a JSON Number which matches the HTTP response status code returned in the HTTP header,\n+- ``errors`` -- a JSON array of strings, each string represents one error,\n+- ``result`` -- a JSON object or JSON array, representing one or many results.\n \n-Nonempty Response\n------------------\n+Successful response, HTTP status: 200 OK\n+----------------------------------------\n \n-Each contract formatted according to :doc:`lf-value-specification`.\n+- Content-Type: ``application/json``\n+- Content:\n \n-.. code-block:: json\n+.. code-block:: none\n \n     {\n-        \"result\": [\n-            {\n-                \"observers\": [],\n-                \"agreementText\": \"\",\n-                \"payload\": {\n-                    \"observers\": [],\n-                    \"issuer\": \"Alice\",\n-                    \"amount\": \"999.99\",\n-                    \"currency\": \"USD\",\n-                    \"owner\": \"Alice\"\n-                },\n-                \"signatories\": [\n-                    \"Alice\"\n-                ],\n-                \"contractId\": \"#52:0\",\n-                \"templateId\": \"b10d22d6c2f2fae41b353315cf893ed66996ecb0abe4424ea6a81576918f658a:Iou:Iou\"\n-            }\n-        ],\n-        \"status\": 200\n+        \"status\": 200,\n+        \"result\": <JSON object>\n     }\n \n-Nonempty Response with Unknown Template IDs Warning\n----------------------------------------------------\n+Failure, HTTP status: 400 | 401 | 404 | 500\n+-------------------------------------------\n \n-.. code-block:: json\n+- Content-Type: ``application/json``\n+- Content:\n+\n+.. code-block:: none\n \n     {\n-        \"warnings\": {\n-            \"unknownTemplateIds\": [\"UnknownModule:UnknownEntity\"]\n-        },\n-        \"result\": [\n-            {\n-                \"observers\": [],\n-                \"agreementText\": \"\",\n-                \"payload\": {\n-                    \"observers\": [],\n-                    \"issuer\": \"Alice\",\n-                    \"amount\": \"999.99\",\n-                    \"currency\": \"USD\",\n-                    \"owner\": \"Alice\"\n-                },\n-                \"signatories\": [\n-                    \"Alice\"\n-                ],\n-                \"contractId\": \"#52:0\",\n-                \"templateId\": \"b10d22d6c2f2fae41b353315cf893ed66996ecb0abe4424ea6a81576918f658a:Iou:Iou\"\n-            }\n-        ],\n-        \"status\": 200\n+        \"status\": <400 | 401 | 404 | 500>,\n+        \"errors\": <JSON array of strings>\n     }\n \n-WebSocket ``/contracts/searchForever``\n-======================================\n-\n-List currently active contracts that match a given query, with\n-continuous updates.\n-\n-Two subprotocols must be passed, as described in `Choosing a party\n-<#choosing-a-party>`__.\n-\n-application/json body must be sent first, formatted according to the\n-:doc:`search-query-language`::\n-\n-    {\"templateIds\": [\"Iou:Iou\"]}\n-\n-output a series of JSON documents, each ``payload`` formatted according\n-to :doc:`lf-value-specification`::\n-\n-    [{\n-        \"created\": {\n-            \"observers\": [],\n-            \"agreementText\": \"\",\n-            \"payload\": {\n-                \"observers\": [],\n-                \"issuer\": \"Alice\",\n-                \"amount\": \"999.99\",\n-                \"currency\": \"USD\",\n-                \"owner\": \"Alice\"\n-            },\n-            \"signatories\": [\"Alice\"],\n-            \"contractId\": \"#1:0\",\n-            \"templateId\": \"6cc82609ede6576e5092e8c89a2c7a658efe15ae1347fc38eb316f787fa132bc:Iou:Iou\"\n-        }\n-    }]\n+Examples\n+--------\n \n-To keep the stream alive, you'll occasionally see messages like this,\n-which can be safely ignored::\n+.. code-block:: none\n \n-    {\"heartbeat\": \"ping\"}\n+    {\"status\": 200, result = [{\"templateId\": \"....\", \"moduleName\" : \"...\", …}, … {....}]}\n \n-After submitting an ``Iou_Split`` exercise, which creates two contracts\n-and archives the one above, the same stream will eventually produce::\n+.. code-block:: json\n \n-    [{\n-        \"created\": {\n-            \"observers\": [],\n-            \"agreementText\": \"\",\n-            \"payload\": {\n-                \"observers\": [],\n-                \"issuer\": \"Alice\",\n-                \"amount\": \"42.42\",\n-                \"currency\": \"USD\",\n-                \"owner\": \"Alice\"\n-            },\n-            \"signatories\": [\"Alice\"],\n-            \"contractId\": \"#2:1\",\n-            \"templateId\": \"6cc82609ede6576e5092e8c89a2c7a658efe15ae1347fc38eb316f787fa132bc:Iou:Iou\"\n-        }\n-    }, {\n-        \"created\": {\n-            \"observers\": [],\n-            \"agreementText\": \"\",\n-            \"payload\": {\n-                \"observers\": [],\n-                \"issuer\": \"Alice\",\n-                \"amount\": \"957.57\",\n-                \"currency\": \"USD\",\n-                \"owner\": \"Alice\"\n-            },\n-            \"signatories\": [\"Alice\"],\n-            \"contractId\": \"#2:2\",\n-            \"templateId\": \"6cc82609ede6576e5092e8c89a2c7a658efe15ae1347fc38eb316f787fa132bc:Iou:Iou\"\n-        }\n-    }, {\n-        \"archived\": \"#1:0\"\n-    }]\n+    {\"status\": 401, \"errors\": [\"Authentication Required\"]}\n \n-Aside from ``\"created\"`` and ``\"archived\"`` elements, ``\"error\"``\n-elements may appear, which contain a string describing the error.  The\n-stream will continue in these cases, rather than terminating.\n+.. code-block:: json\n \n-Some notes on behavior:\n+    {\"status\": 400, \"errors\": [\"JSON parser error: Unexpected character 'f' at input index 27 (line 1, position 28)\"]}\n \n-1. Each result array means \"this is what would have changed if you just\n-   polled ``/contracts/search`` iteratively.\"  In particular, just as\n-   polling search can \"miss\" contracts (as a create and archive can be\n-   paired between polls), such contracts may or may not appear in any\n-   result object.\n+.. code-block:: json\n \n-2. No ``archived`` ever contains a contract ID occurring within an\n-   ``created`` in the same array.  So, for example, supposing you are\n-   keeping an internal map of active contracts, you can apply the\n-   ``created`` first or the ``archived`` first and be guaranteed to get\n-   the same results.\n+    {\"status\": 500, \"errors\": [\"Cannot initialize Ledger API\"]}\n \n-3. You will almost certainly receive contract IDs in ``archived`` that\n-   you never received a ``created`` for.  These are contracts that\n-   query filtered out, but for which the server no longer is aware of\n-   that.  You can safely ignore these.  However, such \"phantom archives\"\n-   *are* guaranteed to represent an actual archival *on the ledger*, so\n-   if you are keeping a more global dataset outside the context of this\n-   specific search, you can use that archival information as you wish.\n+Create a new Contract\n+=====================\n \n-4. Within a single response array, the order of ``created`` and\n-   ``archived`` is undefined and does not imply that any element\n-   occurred \"before\" or \"after\" any other one.  As specified in note #2,\n-   order of application of changes doesn't matter; you will get the same\n-   results if you walk the array forwards, backwards, or in random\n-   order.\n+See the request documentation below on how to create an instance of ``Iou`` contract from the :doc:`Quickstart guide </getting-started/quickstart>`:\n \n-POST ``/command/create``\n-========================\n+.. literalinclude:: ../getting-started/quickstart/template-root/daml/Iou.daml\n+  :language: daml\n+  :lines: 9-15\n \n-Create a contract.\n+.. _create-request:\n \n-Request\n--------\n+HTTP Request\n+------------\n \n-application/json body, ``argument`` formatted according to :doc:`lf-value-specification`:\n+- URL: ``/command/create``\n+- Method: ``POST``\n+- Content-Type: ``application/json``\n+- Content:\n \n .. code-block:: json\n \n     {\n       \"templateId\": \"Iou:Iou\",\n       \"argument\": {\n-        \"observers\": [],\n         \"issuer\": \"Alice\",\n-        \"amount\": \"999.99\",\n+        \"owner\": \"Alice\",\n         \"currency\": \"USD\",\n-        \"owner\": \"Alice\"\n+        \"amount\": \"999.99\",\n+        \"observers\": []\n       }\n     }\n \n-Response\n---------\n+Where:\n+\n+- ``templateId`` is the contract template identifier, which can be formatted as either:\n+\n+  + ``\"<package ID>:<module>:<entity>\"`` or\n+  + ``\"<module>:<entity>\"`` if contract template can be uniquely identified by it's module and entity name.\n+\n+- ``argument`` field contains contract fields as defined in the DAML template and formatted according to :doc:`lf-value-specification`."
  },
  {
    "id" : "e8553396-6af7-42aa-ad78-9723094af6f3",
    "prId" : 4173,
    "comments" : [
      {
        "id" : "af15fc08-3ff7-42bb-91c1-90e666554b58",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nFetch Contract by Key\r\n```",
        "createdAt" : "2020-01-23T13:08:27Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b8cf409e8cef5b8914ce1acd514a03c9c86e5086",
    "line" : null,
    "diffHunk" : "@@ -569,26 +549,29 @@ Contract Found Response\n         }\n     }\n \n-Lookup by Contract Key\n-----------------------\n+Fetch Contract by Contract Key"
  },
  {
    "id" : "31e7a73f-b81a-4a66-9471-45c1766ee053",
    "prId" : 4173,
    "comments" : [
      {
        "id" : "c69271a1-ead1-4bd9-a696-d4a8900408af",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is there any explanation of what the \"query store database\" is? I couldn't find any.",
        "createdAt" : "2020-01-23T13:10:22Z",
        "updatedAt" : "2020-01-23T19:01:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b8cf409e8cef5b8914ce1acd514a03c9c86e5086",
    "line" : null,
    "diffHunk" : "@@ -626,3 +612,261 @@ Contract Found Response\n             \"templateId\": \"11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account\"\n         }\n     }\n+\n+\n+Contract Search, All Templates\n+==============================\n+\n+List all currently active contracts for all known templates. Note that the retrieved contracts do not get persisted into query store database."
  },
  {
    "id" : "5b323504-e473-4906-af5f-8693ebf34e5b",
    "prId" : 4078,
    "comments" : [
      {
        "id" : "f64f0f06-5bea-40f2-a5f3-850d5af7e745",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Right, archived events don't have the payload (template args) to apply the search filter to.\r\nShould we explain this in the doc, so we don't get asked why we don't filter out the \"phantom\" archived events?",
        "createdAt" : "2020-01-16T19:04:37Z",
        "updatedAt" : "2020-01-17T19:35:10Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e5308867-e876-40b9-b47b-437c479a865f",
        "parentId" : "f64f0f06-5bea-40f2-a5f3-850d5af7e745",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I've already explained this in a more abstract, interface-y sense; I hope anyone who cared enough about the implementation details beyond that would dig and find your comment.",
        "createdAt" : "2020-01-16T19:29:13Z",
        "updatedAt" : "2020-01-17T19:35:10Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "15ed1efe32a67f4760758a7431a61151e87a99ab",
    "line" : 94,
    "diffHunk" : "@@ -321,33 +323,44 @@ and archives the one above, the same stream will eventually produce::\n             },\n             \"signatories\": [\"Alice\"],\n             \"contractId\": \"#2:2\",\n-            \"templateId\": \"f95486336ffb3c982319625bed0c88f68799b780b26b558b1e119277614ed634:Iou:Iou\"\n-        }],\n-        \"archived\": [\"#1:0\"]\n-    }\n+            \"templateId\": \"6cc82609ede6576e5092e8c89a2c7a658efe15ae1347fc38eb316f787fa132bc:Iou:Iou\"\n+        }\n+    }, {\n+        \"archived\": \"#1:0\"\n+    }]\n+\n+Aside from ``\"created\"`` and ``\"archived\"`` elements, ``\"error\"``\n+elements may appear, which contain a string describing the error.  The\n+stream will continue in these cases, rather than terminating.\n \n Some notes on behavior:\n \n-1. Each result object means \"this is what would have changed if you just\n+1. Each result array means \"this is what would have changed if you just\n    polled ``/contracts/search`` iteratively.\"  In particular, just as\n    polling search can \"miss\" contracts (as a create and archive can be\n    paired between polls), such contracts may or may not appear in any\n    result object.\n \n 2. No ``archived`` ever contains a contract ID occurring within an\n-   ``created`` in the same object.  So, for example, supposing you are\n+   ``created`` in the same array.  So, for example, supposing you are\n    keeping an internal map of active contracts, you can apply the\n    ``created`` first or the ``archived`` first and be guaranteed to get\n    the same results.\n \n-3. You will almost certainly receive contract IDs in the ``archived``\n-   set that you never received an ``created`` for.  These are contracts\n-   that query filtered out, but for which the server no longer is aware\n-   of that.  You can safely ignore these.  However, such \"phantom\n-   archives\" *are* guaranteed to represent an actual archival *on the\n-   ledger*, so if you are keeping a more global dataset outside the\n-   context of this specific search, you can use that archival\n-   information as you wish.\n+3. You will almost certainly receive contract IDs in ``archived`` that"
  },
  {
    "id" : "910e1df2-d48e-4ad4-a86f-7a1ba8959d09",
    "prId" : 4078,
    "comments" : [
      {
        "id" : "2e904bb9-c999-4cb5-993b-5b3311842dc8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n   you never received a ``created`` for.  These are contracts that\r\n```",
        "createdAt" : "2020-01-17T10:53:37Z",
        "updatedAt" : "2020-01-17T19:35:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "15ed1efe32a67f4760758a7431a61151e87a99ab",
    "line" : null,
    "diffHunk" : "@@ -321,33 +323,44 @@ and archives the one above, the same stream will eventually produce::\n             },\n             \"signatories\": [\"Alice\"],\n             \"contractId\": \"#2:2\",\n-            \"templateId\": \"f95486336ffb3c982319625bed0c88f68799b780b26b558b1e119277614ed634:Iou:Iou\"\n-        }],\n-        \"archived\": [\"#1:0\"]\n-    }\n+            \"templateId\": \"6cc82609ede6576e5092e8c89a2c7a658efe15ae1347fc38eb316f787fa132bc:Iou:Iou\"\n+        }\n+    }, {\n+        \"archived\": \"#1:0\"\n+    }]\n+\n+Aside from ``\"created\"`` and ``\"archived\"`` elements, ``\"error\"``\n+elements may appear, which contain a string describing the error.  The\n+stream will continue in these cases, rather than terminating.\n \n Some notes on behavior:\n \n-1. Each result object means \"this is what would have changed if you just\n+1. Each result array means \"this is what would have changed if you just\n    polled ``/contracts/search`` iteratively.\"  In particular, just as\n    polling search can \"miss\" contracts (as a create and archive can be\n    paired between polls), such contracts may or may not appear in any\n    result object.\n \n 2. No ``archived`` ever contains a contract ID occurring within an\n-   ``created`` in the same object.  So, for example, supposing you are\n+   ``created`` in the same array.  So, for example, supposing you are\n    keeping an internal map of active contracts, you can apply the\n    ``created`` first or the ``archived`` first and be guaranteed to get\n    the same results.\n \n-3. You will almost certainly receive contract IDs in the ``archived``\n-   set that you never received an ``created`` for.  These are contracts\n-   that query filtered out, but for which the server no longer is aware\n-   of that.  You can safely ignore these.  However, such \"phantom\n-   archives\" *are* guaranteed to represent an actual archival *on the\n-   ledger*, so if you are keeping a more global dataset outside the\n-   context of this specific search, you can use that archival\n-   information as you wish.\n+3. You will almost certainly receive contract IDs in ``archived`` that\n+   you never received an ``created`` for.  These are contracts that"
  },
  {
    "id" : "cca279de-e5af-44aa-bea4-f7b38dd69b1c",
    "prId" : 3936,
    "comments" : [
      {
        "id" : "c3205992-b67e-4daf-b3b1-bc88b1c77cdb",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "I remember removing `witnessParties` in favor of `signatories` and `observers`.",
        "createdAt" : "2020-01-15T21:36:04Z",
        "updatedAt" : "2020-01-15T22:27:19Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e8879db8-7d2f-4c1d-80be-ae8dfb322729",
        "parentId" : "c3205992-b67e-4daf-b3b1-bc88b1c77cdb",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Replaced in 42dc6b964d58ed8555c3240c816715f024c263fe; thanks.",
        "createdAt" : "2020-01-15T22:48:06Z",
        "updatedAt" : "2020-01-15T22:48:06Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3e5537e2aecde8437425b615b2f58a501c67967",
    "line" : null,
    "diffHunk" : "@@ -251,6 +253,105 @@ Nonempty Response with Unknown Template IDs Warning\n         \"status\": 200\n     }\n \n+WebSocket ``/contracts/searchForever``\n+======================================\n+\n+List currently active contracts that match a given query, with\n+continuous updates.\n+\n+Two subprotocols must be passed, as described in `Choosing a party\n+<#choosing-a-party>`__.\n+\n+application/json body must be sent first, formatted according to the\n+:doc:`search-query-language`::\n+\n+    {\"%templates\": [\"Iou:Iou\"]}\n+\n+output a series of JSON documents, each ``argument`` formatted according\n+to :doc:`lf-value-specification`::\n+\n+    {\n+        \"created\": [{\n+            \"observers\": [],\n+            \"agreementText\": \"\",\n+            \"signatories\": [\"Alice\"],\n+            \"contractId\": \"#1:0\",\n+            \"templateId\": \"398e67533888ab6532c3e62c2c3445182e2cdd291457732f174d2698a7d1db2d:Iou:Iou\",\n+            \"witnessParties\": [\"Alice\"],"
  },
  {
    "id" : "51827865-7cee-4efb-8ed0-07288a0be190",
    "prId" : 3936,
    "comments" : [
      {
        "id" : "ae13609e-c2a2-4481-af87-7d44ce8b3188",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This format differs from what you get from the `/commands/exercise` endpoint. Her you get something looking like\r\n```\r\n{\r\n  created: [C1, C2],\r\n  archived: [A1, A2]\r\n}\r\n```\r\nThere you'd instead get\r\n```\r\n[\r\n  {created: C1},\r\n  {created: C2},\r\n  {archived: A1},\r\n  {archived: A2}\r\n]\r\n```\r\nI'd prefer if the encoding is the same for both endpoints. Since the `/commands/exercise` endpoint does not work with the first format, we need to use the second in both places. It would be nice if could keep the order of the events we don't filter out during consolidation for the `/contracts/searchForever` endpoint, but I don't consider it a hard requirement.",
        "createdAt" : "2020-01-16T10:54:27Z",
        "updatedAt" : "2020-01-16T10:55:30Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c3e5537e2aecde8437425b615b2f58a501c67967",
    "line" : 57,
    "diffHunk" : "@@ -251,6 +253,102 @@ Nonempty Response with Unknown Template IDs Warning\n         \"status\": 200\n     }\n \n+WebSocket ``/contracts/searchForever``\n+======================================\n+\n+List currently active contracts that match a given query, with\n+continuous updates.\n+\n+Two subprotocols must be passed, as described in `Choosing a party\n+<#choosing-a-party>`__.\n+\n+application/json body must be sent first, formatted according to the\n+:doc:`search-query-language`::\n+\n+    {\"%templates\": [\"Iou:Iou\"]}\n+\n+output a series of JSON documents, each ``argument`` formatted according\n+to :doc:`lf-value-specification`::\n+\n+    {\n+        \"created\": [{\n+            \"observers\": [],\n+            \"agreementText\": \"\",\n+            \"payload\": {\n+                \"observers\": [],\n+                \"issuer\": \"Alice\",\n+                \"amount\": \"999.99\",\n+                \"currency\": \"USD\",\n+                \"owner\": \"Alice\"\n+            },\n+            \"signatories\": [\"Alice\"],\n+            \"contractId\": \"#1:0\",\n+            \"templateId\": \"f95486336ffb3c982319625bed0c88f68799b780b26b558b1e119277614ed634:Iou:Iou\"\n+        }]\n+    }\n+\n+To keep the stream alive, you'll occasionally see messages like this,\n+which can be safely ignored::\n+\n+    {\"heartbeat\": \"ping\"}\n+\n+After submitting an ``Iou_Split`` exercise, which creates two contracts\n+and archives the one above, the same stream will eventually produce::\n+\n+    {"
  },
  {
    "id" : "301d6d0b-ed05-49b3-b8b3-e4e889b0ff01",
    "prId" : 3657,
    "comments" : [
      {
        "id" : "ad282514-4a0f-4155-a5e4-091bcb25cfec",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "The last `it` may refer to either the _HTTP JSON API_ or the _Ledger API Server_",
        "createdAt" : "2019-11-27T17:27:08Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8b36f8e5-711b-4629-8ab9-c6302c9dd930",
        "parentId" : "ad282514-4a0f-4155-a5e4-091bcb25cfec",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3657/commits/1bfdf8281ba0f599cc4a87d595f2afd120f8c413",
        "createdAt" : "2019-11-27T17:42:53Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "705bc9ec5185e3e0aeeba2d7a3239407280d5e20",
    "line" : null,
    "diffHunk" : "@@ -93,6 +93,21 @@ Start HTTP service from a DAML project directory\n             prefix -- URL prefix,\n             directory -- local directory that will be mapped to the URL prefix.\n             Example: \"prefix=static,directory=./static-content\"\n+      --access-token-file <value>\n+        provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n+\n+With Authentication\n+===================\n+\n+If you are running the HTTP JSON API against a Ledger API server that requires authentication, you must provide the access token when you start it."
  },
  {
    "id" : "01805556-2f25-421a-9c13-c9dc99df04a6",
    "prId" : 3657,
    "comments" : [
      {
        "id" : "1383058a-0291-448f-971b-fd57cc7b97ef",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nThe access token retrieval depends on the specific DAML setup you are working with: please refer to the ledger operator to learn how to retrieve a token.\r\n```",
        "createdAt" : "2019-11-27T17:28:09Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "705bc9ec5185e3e0aeeba2d7a3239407280d5e20",
    "line" : null,
    "diffHunk" : "@@ -93,6 +93,21 @@ Start HTTP service from a DAML project directory\n             prefix -- URL prefix,\n             directory -- local directory that will be mapped to the URL prefix.\n             Example: \"prefix=static,directory=./static-content\"\n+      --access-token-file <value>\n+        provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n+\n+With Authentication\n+===================\n+\n+If you are running the HTTP JSON API against a Ledger API server that requires authentication, you must provide the access token when you start it.\n+\n+The access token retrieval depends on the specific DAML setup you are working with: please refer to the ledger operator to learn how."
  },
  {
    "id" : "ee5c1014-12e9-48e5-bbe1-60440c1d6636",
    "prId" : 3657,
    "comments" : [
      {
        "id" : "27954537-62c3-48bc-8b16-d1b890001ad2",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nIf the token cannot be read from the provided path or the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token and it will be picked up at the next attempt to send a request.\r\n```",
        "createdAt" : "2019-11-27T17:29:14Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "705bc9ec5185e3e0aeeba2d7a3239407280d5e20",
    "line" : null,
    "diffHunk" : "@@ -93,6 +93,21 @@ Start HTTP service from a DAML project directory\n             prefix -- URL prefix,\n             directory -- local directory that will be mapped to the URL prefix.\n             Example: \"prefix=static,directory=./static-content\"\n+      --access-token-file <value>\n+        provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n+\n+With Authentication\n+===================\n+\n+If you are running the HTTP JSON API against a Ledger API server that requires authentication, you must provide the access token when you start it.\n+\n+The access token retrieval depends on the specific DAML setup you are working with: please refer to the ledger operator to learn how.\n+\n+Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file and provide the path to it using the ``--access-token-file`` command line option.\n+\n+Both in the case in which the token cannot be read from the provided path or if the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token and it will be picked up at the next attempt."
  },
  {
    "id" : "705ee586-d716-4daf-a807-b814229901fb",
    "prId" : 3657,
    "comments" : [
      {
        "id" : "f130812c-1eda-42fd-805d-80ce59de4646",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nNote that this token is used exclusively for the HTTP JSON API server and that it will not be used to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\r\n```",
        "createdAt" : "2019-11-27T17:30:02Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f7ff4ee4-88f8-4ac6-a862-dacc648339a8",
        "parentId" : "f130812c-1eda-42fd-805d-80ce59de4646",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "It is not clear up to this point why the HTTP JSON API needs to be started with a token on its own that doesn't necessarily represent claims to a party (and probably it should be advised to not provide such a token?).",
        "createdAt" : "2019-11-27T17:31:04Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7196fa08-2681-4140-aed6-62bcb5aa0ee6",
        "parentId" : "f130812c-1eda-42fd-805d-80ce59de4646",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3657/commits/1bfdf8281ba0f599cc4a87d595f2afd120f8c413",
        "createdAt" : "2019-11-27T17:42:58Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "705bc9ec5185e3e0aeeba2d7a3239407280d5e20",
    "line" : null,
    "diffHunk" : "@@ -93,6 +93,21 @@ Start HTTP service from a DAML project directory\n             prefix -- URL prefix,\n             directory -- local directory that will be mapped to the URL prefix.\n             Example: \"prefix=static,directory=./static-content\"\n+      --access-token-file <value>\n+        provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n+\n+With Authentication\n+===================\n+\n+If you are running the HTTP JSON API against a Ledger API server that requires authentication, you must provide the access token when you start it.\n+\n+The access token retrieval depends on the specific DAML setup you are working with: please refer to the ledger operator to learn how.\n+\n+Once you have retrieved your access token, you can provide it to the HTTP JSON API by storing it in a file and provide the path to it using the ``--access-token-file`` command line option.\n+\n+Both in the case in which the token cannot be read from the provided path or if the Ledger API reports an authentication error (for example due to token expiration), the HTTP JSON API will report the error via logging. The token file can be updated with a valid token and it will be picked up at the next attempt.\n+\n+Note that this token is used exclusively for the HTTP JSON API server and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call."
  },
  {
    "id" : "253ee38b-6750-45ee-ba8a-7e65be148767",
    "prId" : 3657,
    "comments" : [
      {
        "id" : "4d9d476e-aa18-444b-bf6e-cb34c89d3021",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\nNote that this token is used exclusively for maintaining the internal list of known packages and templates, and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\r\n```",
        "createdAt" : "2019-11-27T20:25:18Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "705bc9ec5185e3e0aeeba2d7a3239407280d5e20",
    "line" : null,
    "diffHunk" : "@@ -93,6 +93,23 @@ Start HTTP service from a DAML project directory\n             prefix -- URL prefix,\n             directory -- local directory that will be mapped to the URL prefix.\n             Example: \"prefix=static,directory=./static-content\"\n+      --access-token-file <value>\n+        provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n+\n+With Authentication\n+===================\n+\n+Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+\n+For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+\n+Note that this token is used exclusively for the HTTP JSON API server and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call."
  },
  {
    "id" : "2d377d4d-1878-41de-82dc-922535aa28f4",
    "prId" : 3657,
    "comments" : [
      {
        "id" : "86bbc620-f269-40ec-be01-5e858c0d5906",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\nThe HTTP JSON API servers requires no access to party-specific data, only access to the ledger identity and package services: a token issued for the HTTP JSON API server should contain enough claims to contact these two services but no more than that. Please refer to your ledger operator's documentation to find out how.\r\n```",
        "createdAt" : "2019-11-27T20:25:41Z",
        "updatedAt" : "2019-11-28T08:57:03Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "705bc9ec5185e3e0aeeba2d7a3239407280d5e20",
    "line" : null,
    "diffHunk" : "@@ -93,6 +93,23 @@ Start HTTP service from a DAML project directory\n             prefix -- URL prefix,\n             directory -- local directory that will be mapped to the URL prefix.\n             Example: \"prefix=static,directory=./static-content\"\n+      --access-token-file <value>\n+        provide the path from which the access token will be read, required to interact with an authenticated ledger, no default\n+\n+With Authentication\n+===================\n+\n+Apart from interacting with the Ledger API on behalf of the user, the HTTP JSON API server must also interact with the Ledger API to maintain some relevant internal state.\n+\n+For this reason, you must provide an access token when you start the HTTP JSON API if you're running it against a Ledger API server that requires authentication.\n+\n+Note that this token is used exclusively for the HTTP JSON API server and that it will not be use to authenticate client calls to the HTTP JSON API: the user is expected to provide a valid authentication token with each call.\n+\n+The HTTP JSON API servers requires no access to party-specific data and requires exclusively access to the ledger identity and package services: a token issued for the HTTP JSON API server should contain enough claims to contact these two service but no more than that. Please refer to your ledger operator's documentation to find out how."
  },
  {
    "id" : "ef3a6d64-881b-4e13-ad68-ea073250f5e9",
    "prId" : 3012,
    "comments" : [
      {
        "id" : "e8b64804-2370-4a6f-bde9-bf97fd76cf77",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Please change the `daml-head` references to just `daml`.",
        "createdAt" : "2019-09-24T20:07:59Z",
        "updatedAt" : "2019-09-24T20:17:25Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2ef7908343297b9e6dc5a35bd3cd1ae9e972779",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,297 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+HTTP JSON API Service\n+#####################\n+\n+**WARNING:** the HTTP JSON API described in this document is actively\n+being designed and is *subject to breaking changes*, including all\n+request and response elements demonstrated below or otherwise\n+implemented by the API.  We welcome feedback about the API on `our issue\n+tracker\n+<https://github.com/digital-asset/daml/issues/new?milestone=HTTP+JSON+API+Maintenance>`_\n+or `on Slack <https://damldriven.slack.com/>`_.\n+\n+The JSON API provides a significantly simpler way than :doc:`the Ledger\n+API </app-dev/index>` to access *basic active contract set\n+functionality*:\n+\n+- creating contracts,\n+- exercising choices on contracts, and\n+- querying the current active contract set.\n+\n+The goal is to get you up and running writing effective\n+ledger-integrated applications quickly, so we have deliberately excluded\n+complicating concerns, including but not limited to\n+\n+- inspecting transactions,\n+- asynchronous submit/completion workflows,\n+- temporal queries (e.g. active contracts *as of a certain time*), and\n+- ledger metaprogramming (e.g. packages and templates).\n+\n+For these and other features, use :doc:`the Ledger API </app-dev/index>`\n+instead.\n+\n+.. toctree::\n+   :hidden:\n+\n+   lf-value-specification\n+   search-query-language\n+\n+How to start\n+************\n+\n+Start sandbox from a DAML project directory\n+===========================================\n+\n+::\n+\n+    $ daml-head sandbox --wall-clock-time --ledgerid MyLedger ./.daml/dist/quickstart-0.0.1.dar"
  }
]