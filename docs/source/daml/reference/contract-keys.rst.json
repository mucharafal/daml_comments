[
  {
    "id" : "c4e8649b-b188-40db-b0e0-5dc6b5bb2116",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "75f2c4b1-7c44-431d-a346-e575ad5a0d89",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "As per the forum discussion, it's not just DoS, but privacy protection as well. Without these rules, you could poll contract keys without authorization to gain information",
        "createdAt" : "2020-08-17T07:23:33Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "21f45f21-25c3-4b79-9991-f26020c372b3",
        "parentId" : "75f2c4b1-7c44-431d-a346-e575ad5a0d89",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "I've substantially rewritten this in a way that explains why the authorization is needed for the system to work, rather than what could go wrong if we did something else. I think that's better, but open to the idea that I may be wrong here.",
        "createdAt" : "2020-08-17T14:31:59Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -62,6 +62,17 @@ Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholde\n \n This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting Party doesn't know about it, or there are issues with authorization.\n \n+.. _doescontractexistforkey:\n+\n+canSeeContractWithKey\n+=====================\n+\n+``boolean <- canSeeContractWithKey contractKey``\n+\n+Use ``canSeeContractWithKey`` to check whether, in the current context, you can see an active contract for the current key. If the contract exists and the current context has the permission to see it, returns `True`, otherwise returns `False`.\n+\n+``canSeeContractWithKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. Without this restriction, a malicious Party could legitimately request another Party to validate any number of negative contract key lookups without that other Party ever having signed anything."
  },
  {
    "id" : "9b9373b6-c5da-481c-8c0a-db76150a93de",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "388c3856-acfb-483c-ab03-d9276ad108cb",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Not quite. `fetchByKey` returns a tuple `(cid, args)` so it would be `(Some . fst) <$> fetchByKey k`",
        "createdAt" : "2020-08-17T07:25:41Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a132cec5-91f9-4bce-aeb6-87fad5cea3d6",
        "parentId" : "388c3856-acfb-483c-ab03-d9276ad108cb",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Replaced with code I actually tested this time.",
        "createdAt" : "2020-08-17T14:32:23Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -71,7 +82,18 @@ lookupByKey\n \n Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``Some contractId``, where ``contractId`` is the ID of the contract; otherwise, it returns ``None``.\n \n-``lookupByKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. Without this restriction, a malicious Party could legitimately request another Party to validate any number of negative contract key lookups without that other Party ever having signed anything.\n+``lookupByKey`` is conceptually equivalent to\n+\n+.. code-block:: daml\n+\n+   lookupByKey k = do\n+     canSee <- canSeeContractWithKey k\n+     if canSee then\n+       Some <$> fetchByKey k"
  },
  {
    "id" : "e86db3af-fd9d-4cbc-81fc-261cab285d3f",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "c0b3a11f-0c44-4b2b-a700-d422f4499371",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nUse ``canSeeContractWithKey`` to check whether, in the current context, you can see an active contract for the current key. If the contract exists and the current context has the permission to see it, returns ``True``, otherwise returns ``False``.\r\n```",
        "createdAt" : "2020-08-17T13:31:51Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a0e013dd-8ea9-4287-8476-7a2be142c62b",
        "parentId" : "c0b3a11f-0c44-4b2b-a700-d422f4499371",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Done, thanks.",
        "createdAt" : "2020-08-17T14:27:09Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -62,6 +62,17 @@ Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholde\n \n This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting Party doesn't know about it, or there are issues with authorization.\n \n+.. _doescontractexistforkey:\n+\n+canSeeContractWithKey\n+=====================\n+\n+``boolean <- canSeeContractWithKey contractKey``\n+\n+Use ``canSeeContractWithKey`` to check whether, in the current context, you can see an active contract for the current key. If the contract exists and the current context has the permission to see it, returns `True`, otherwise returns `False`."
  },
  {
    "id" : "de38058d-5cfb-489a-ad1a-9186964238b9",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "5bde3947-0b56-46e5-9437-7ca75113f172",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n``canSeeContractWithKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. Without this restriction, a malicious party could legitimately request another Party to validate any number of negative contract key lookups without that other party ever having signed anything.\r\n```",
        "createdAt" : "2020-08-17T13:32:21Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1787deaf-8bb0-4bdc-be91-94426eea5060",
        "parentId" : "5bde3947-0b56-46e5-9437-7ca75113f172",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Text substantially changed and does not contain \"party\" anymore. Note that \"Party\" is capitalized in both `lookupByKey` and `fetchByKey` sections (untouched by this PR); should I update those?",
        "createdAt" : "2020-08-17T14:29:20Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "482033d1-b38e-488c-9494-95538729c8a9",
        "parentId" : "5bde3947-0b56-46e5-9437-7ca75113f172",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@bame-da Do you remember if there was a specific reason to capitalize the word \"party\" in some sections? Or was it an oversight?",
        "createdAt" : "2020-08-18T07:45:46Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e6444f85-529d-4d05-b2ff-f23f2fe2014a",
        "parentId" : "5bde3947-0b56-46e5-9437-7ca75113f172",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I think it's to distinguish party in the loose sense against Party in the technical sense. Of course, a Party can't be malicious as it's a technical context, not do Parties validate anything so I don't see a good case for capitalizing here.",
        "createdAt" : "2020-08-18T07:54:55Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "83c5da79-ec83-45dc-854f-6f308a24ff88",
        "parentId" : "5bde3947-0b56-46e5-9437-7ca75113f172",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "All existing cases of \"Party\" are in the context of \"the submitting Party\", so I guess given the explanation it makes sense to keep the capitalization.",
        "createdAt" : "2020-08-18T13:44:04Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -62,6 +62,17 @@ Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholde\n \n This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting Party doesn't know about it, or there are issues with authorization.\n \n+.. _doescontractexistforkey:\n+\n+canSeeContractWithKey\n+=====================\n+\n+``boolean <- canSeeContractWithKey contractKey``\n+\n+Use ``canSeeContractWithKey`` to check whether, in the current context, you can see an active contract for the current key. If the contract exists and the current context has the permission to see it, returns `True`, otherwise returns `False`.\n+\n+``canSeeContractWithKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. Without this restriction, a malicious Party could legitimately request another Party to validate any number of negative contract key lookups without that other Party ever having signed anything."
  },
  {
    "id" : "baa95c43-2926-486d-876d-f0ce5e943dc3",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "43bfab1d-4986-4a4b-8164-e21b96cab8e9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's not put the burden of point free code or the `<$>` operator on our readers.\r\n```suggestion\r\n     if canSee then do\r\n       (cid, _payload) <- fetchByKey k\r\n       pure cid\r\n```",
        "createdAt" : "2020-08-17T13:34:23Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c93bd8f7-a3b7-4a02-94c3-01e0044f88ea",
        "parentId" : "43bfab1d-4986-4a4b-8164-e21b96cab8e9",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Code replaced with a version that actually compiles (almost); it's not point free anymore.",
        "createdAt" : "2020-08-17T14:33:51Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -71,7 +82,18 @@ lookupByKey\n \n Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``Some contractId``, where ``contractId`` is the ID of the contract; otherwise, it returns ``None``.\n \n-``lookupByKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. Without this restriction, a malicious Party could legitimately request another Party to validate any number of negative contract key lookups without that other Party ever having signed anything.\n+``lookupByKey`` is conceptually equivalent to\n+\n+.. code-block:: daml\n+\n+   lookupByKey k = do\n+     canSee <- canSeeContractWithKey k\n+     if canSee then\n+       Some <$> fetchByKey k"
  },
  {
    "id" : "b60bde67-4704-4b77-8bdc-261b097f6cc7",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "6c6a9f2c-2ba3-4a0c-b458-8cb553997df5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t think we use `context` anywhere else. This should probably say something like “with the current authorization”.",
        "createdAt" : "2020-08-17T15:27:53Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d414002c-70ed-46d5-9e59-636a4bb3978d",
        "parentId" : "6c6a9f2c-2ba3-4a0c-b458-8cb553997df5",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-17T17:40:41Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -62,6 +62,21 @@ Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholde\n \n This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting Party doesn't know about it, or there are issues with authorization.\n \n+.. _doescontractexistforkey:\n+\n+canSeeContractWithKey\n+=====================\n+\n+``boolean <- canSeeContractWithKey @ContractType contractKey``\n+\n+Use ``canSeeContractWithKey`` to check whether, in the current context, you can see an active contract for the current key. If the contract exists and the current context has the permission to see it, returns ``True``, otherwise returns ``False``."
  },
  {
    "id" : "e3e34845-0c30-4470-9707-d3f94d096a45",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "fa9efed1-bd1f-4924-bbb4-ecbb991772b8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n3. ``visibleByKey`` will abort the transaction at interpretation time if, at the point of call, we are missing the authorization from any one maintainer of the key.\r\n```",
        "createdAt" : "2020-08-24T11:19:52Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -62,6 +64,26 @@ Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholde\n \n This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting Party doesn't know about it, or there are issues with authorization.\n \n+.. _visiblebykey:\n+\n+visibleByKey\n+============\n+\n+``boolean <- visibleByKey @ContractType contractKey``\n+\n+Use ``visibleByKey`` to check whether you can see an active contract for the given key with the current authorizations. If the contract exists and you have permission to see it, returns ``True``, otherwise returns ``False``.\n+\n+To clarify, ignoring contention:\n+\n+1. ``visibleByKey`` will return ``True`` if all of these are true: there exists a contract for the given key, the submitter is a stakeholder on that contract, and at the point of call we have the authorization of **all** of the maintainers of the key.\n+2. ``visibleByKey`` will return ``False`` if all of those are true: there is no contract for the given key, and at the point of call we have authorization from **all** the maintainers of the key.\n+3. ``visibleByKey`` will abort the transaction at execution time if, at the point of call, we are missing the authorization from any one maintainer of the key."
  },
  {
    "id" : "e83453c6-6977-44f9-b882-08da48333bde",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "d69e4ec0-e0e7-4383-b9ce-c1513881cfbf",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n4. ``visibleByKey`` will fail at validation time (after returning ``False`` at interpretation time) if all of these are true: at the point of call, we have the authorization of **all** the maintainers, and a valid contract exists for the given key, but the submitter is not a stakeholder on that contract.\r\n```",
        "createdAt" : "2020-08-24T11:20:12Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -62,6 +64,26 @@ Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholde\n \n This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting Party doesn't know about it, or there are issues with authorization.\n \n+.. _visiblebykey:\n+\n+visibleByKey\n+============\n+\n+``boolean <- visibleByKey @ContractType contractKey``\n+\n+Use ``visibleByKey`` to check whether you can see an active contract for the given key with the current authorizations. If the contract exists and you have permission to see it, returns ``True``, otherwise returns ``False``.\n+\n+To clarify, ignoring contention:\n+\n+1. ``visibleByKey`` will return ``True`` if all of these are true: there exists a contract for the given key, the submitter is a stakeholder on that contract, and at the point of call we have the authorization of **all** of the maintainers of the key.\n+2. ``visibleByKey`` will return ``False`` if all of those are true: there is no contract for the given key, and at the point of call we have authorization from **all** the maintainers of the key.\n+3. ``visibleByKey`` will abort the transaction at execution time if, at the point of call, we are missing the authorization from any one maintainer of the key.\n+4. ``visibleByKey`` will fail at validation time (after returning ``False`` at execution time) if all of these are true: at the point of call, we have the authorization of **all** the maintainers, and a valid contract exists for the given key, but the submitter is not a stakeholder on that contract."
  },
  {
    "id" : "84129d3e-c53f-4533-8873-93a98b31b625",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "3de9a3fe-39f3-4766-b4ba-a0c460311604",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe worth pointing out that the restrictions are the same as the one for `fetchByKey` + `exerciseByKey`?",
        "createdAt" : "2020-05-11T09:06:37Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "50f5bafa-a99a-4325-a9d1-3346ebdaa3e6",
        "parentId" : "3de9a3fe-39f3-4766-b4ba-a0c460311604",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@cocreature probably means `fetchByKey + exercise`. Referring to that combination is a great idea.",
        "createdAt" : "2020-05-11T10:10:35Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8361e719-e979-4de3-a80f-34c569611dea",
        "parentId" : "3de9a3fe-39f3-4766-b4ba-a0c460311604",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":facepalm: yeah I definitely mean `exercise` not `exerciseByKey`",
        "createdAt" : "2020-05-11T10:13:38Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract.\n \n .. _fetchbykey:\n \n-``fetchByKey``\n+fetchByKey\n ==============\n \n ``(fetchedContractId, fetchedContract) <- fetchByKey @ContractType contractKey``\n \n-Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to ``fetch`` and behaves the same in most ways. \n \n It returns a tuple of the ID and the contract object (containing all its data).\n \n-``fetchByKey`` is authorized like ``fetch`` so it needs to be\n-authorized by at least one stakeholder. There are no restrictions on\n-the submitter.\n+Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholder.\n \n ``fetchByKey`` fails and aborts the transaction if:\n \n-- Missing authorization, i.e., no authorization from a\n-  stakeholder of the contract you are trying to fetch.\n+- The submitting party is not a stakeholder on a contract with the givem key, or\n+- A contract was found, but the ``fetchByKey`` violates the authorization rule, meaning no stakeholder authorized the ``fetch``..\n \n-This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting party doesn't know about it, or there are issues with authorization.\n \n Because different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\n \n .. _lookupbykey:\n \n-``lookupByKey``\n+lookupByKey\n ===============\n \n ``optionalContractId <- lookupByKey @ContractType contractKey``\n \n Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``Some contractId``, where ``contractId`` is the ID of the contract; otherwise, it returns ``None``.\n \n-``lookupByKey`` needs to be authorized by **all** maintainers of the\n-contract you are trying to lookup. There are no restrictions on the\n-submitter.\n+``lookupByKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. WIthout this restriction, a malicious Party could legitimately request another party to validate any number of negative contract key lookups without that other party ever having signed anything.\n \n-If the lookup fails (ie returns ``None``), this guarantees that no contract has this key.\n+Unlike ``fetchByKey``, the transaction **does not fail** if no contract with the given key is found. Instead, ``lookupByKey`` just returns ``None``. However, that does not guarantee that no such contract exists. The submitting party may simply not know about it.\n+\n+``lookupByKey`` fails and aborts the transaction if:\n+\n+- Authorization from at least one maintainer is missing. This check fails at interpretation time.\n+- The lookup is incorrect. This can happen either due to contention, or because the submitter didn't know of the contract. This check fails at validation time.\n \n-Unlike ``fetchByKey``, the transaction **does not fail** if a contract with the key doesn't exist: instead, ``lookupByKey`` just returns ``None``.\n \n To get the data from the contract once you've confirmed it exists, you'll still need to use ``fetch``.\n \n Because different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\n \n-``exerciseByKey``\n+exerciseByKey\n =================\n \n ``exerciseByKey @ContractType contractKey``\n \n-Use ``exerciseByKey`` to exercise a choice on a contract identified by its ``key`` (compared to ``exercise``, which lets you exercise a contract identified by its ``ContractId``). To run ``exerciseByKey`` you need authorization from the controllers of the choice and at least one of the key maintainers.\n+Use ``exerciseByKey`` to exercise a choice on a contract identified by its ``key`` (compared to ``exercise``, which lets you exercise a contract identified by its ``ContractId``). To run ``exerciseByKey`` you need authorization from the controllers of the choice and at least one stakeholder."
  },
  {
    "id" : "1cd9609d-d126-4bf9-b951-70d5ff9cdcd5",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "416fff25-5c19-49da-898b-609a6e678ad6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n- The submitting party is not a stakeholder on a contract with the given key, or\r\n```",
        "createdAt" : "2020-05-11T09:08:05Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract.\n \n .. _fetchbykey:\n \n-``fetchByKey``\n+fetchByKey\n ==============\n \n ``(fetchedContractId, fetchedContract) <- fetchByKey @ContractType contractKey``\n \n-Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to ``fetch`` and behaves the same in most ways. \n \n It returns a tuple of the ID and the contract object (containing all its data).\n \n-``fetchByKey`` is authorized like ``fetch`` so it needs to be\n-authorized by at least one stakeholder. There are no restrictions on\n-the submitter.\n+Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholder.\n \n ``fetchByKey`` fails and aborts the transaction if:\n \n-- Missing authorization, i.e., no authorization from a\n-  stakeholder of the contract you are trying to fetch.\n+- The submitting party is not a stakeholder on a contract with the givem key, or"
  },
  {
    "id" : "481e34b8-b8fc-4ea2-9359-f4cc1b4e2ef7",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "5d8610db-b321-432d-8b14-4ce7b68eb621",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`exerciseByKey` is now in the `Contract Lookups` section which kind of makes sense but seems a bit weird.",
        "createdAt" : "2020-05-11T09:11:22Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "214a7862-9c94-4ca0-b8be-33bf0db26be8",
        "parentId" : "5d8610db-b321-432d-8b14-4ce7b68eb621",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I agree that it seems a bit weird. I would suggest we move it next to the regular `exercise` with a reference to this section.",
        "createdAt" : "2020-05-11T10:05:39Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "20f705cf-ffe0-43f9-87c8-5d03c4cacadd",
        "parentId" : "5d8610db-b321-432d-8b14-4ce7b68eb621",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I'd keep it here because of the proviso for resolution time (and concurrent access, that IMO should be added).",
        "createdAt" : "2020-05-11T11:14:51Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : 25,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups"
  },
  {
    "id" : "61115c28-2b89-46c9-9f6d-3ac36757b69f",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "1bcb23ea-20f1-42c5-a9db-1c6142ca35d5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does that paragraph really explain anything? Whenever the maintainers of two keys are different the keys must necessarily be different since there's a function (in the mathematical sense) computing the maintainers from the key.",
        "createdAt" : "2020-05-11T10:04:26Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b6a8b0ed-ac0e-413a-b674-b8477296697b",
        "parentId" : "1bcb23ea-20f1-42c5-a9db-1c6142ca35d5",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I think it's useful to say that maintainer sets partition the space of keys, even if it's implicit from maintainers being a function of keys.",
        "createdAt" : "2020-05-11T10:51:34Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``."
  },
  {
    "id" : "2a294a7f-b5dc-488e-9353-255c3d626a03",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "e9d754c7-1a01-482d-ae81-296dd6b198e0",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nfetchByKey\r\n==========\r\n```",
        "createdAt" : "2020-05-11T10:06:37Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract.\n \n .. _fetchbykey:\n \n-``fetchByKey``\n+fetchByKey\n =============="
  },
  {
    "id" : "cba1318b-bea8-4568-a410-376602ff0e87",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "a34c6026-3f56-40d5-8fbe-a6488edffd28",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nlookupByKey\r\n===========\r\n```",
        "createdAt" : "2020-05-11T10:08:06Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract.\n \n .. _fetchbykey:\n \n-``fetchByKey``\n+fetchByKey\n ==============\n \n ``(fetchedContractId, fetchedContract) <- fetchByKey @ContractType contractKey``\n \n-Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to ``fetch`` and behaves the same in most ways. \n \n It returns a tuple of the ID and the contract object (containing all its data).\n \n-``fetchByKey`` is authorized like ``fetch`` so it needs to be\n-authorized by at least one stakeholder. There are no restrictions on\n-the submitter.\n+Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholder.\n \n ``fetchByKey`` fails and aborts the transaction if:\n \n-- Missing authorization, i.e., no authorization from a\n-  stakeholder of the contract you are trying to fetch.\n+- The submitting party is not a stakeholder on a contract with the givem key, or\n+- A contract was found, but the ``fetchByKey`` violates the authorization rule, meaning no stakeholder authorized the ``fetch``..\n \n-This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting party doesn't know about it, or there are issues with authorization.\n \n Because different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\n \n .. _lookupbykey:\n \n-``lookupByKey``\n+lookupByKey\n ==============="
  },
  {
    "id" : "f4b8cd74-75d0-4604-9949-58f56cca5b33",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "b35ceb0d-b0fc-41dc-99d7-7a8996b85866",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n``lookupByKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. Without this restriction, a malicious Party could legitimately request another party to validate any number of negative contract key lookups without that other party ever having signed anything.\r\n```",
        "createdAt" : "2020-05-11T10:08:27Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d4171a7f-0fbb-40f3-a130-7fb5652a43c7",
        "parentId" : "b35ceb0d-b0fc-41dc-99d7-7a8996b85866",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Typo: `Party` vs `party`",
        "createdAt" : "2020-05-11T11:11:50Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract.\n \n .. _fetchbykey:\n \n-``fetchByKey``\n+fetchByKey\n ==============\n \n ``(fetchedContractId, fetchedContract) <- fetchByKey @ContractType contractKey``\n \n-Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to ``fetch`` and behaves the same in most ways. \n \n It returns a tuple of the ID and the contract object (containing all its data).\n \n-``fetchByKey`` is authorized like ``fetch`` so it needs to be\n-authorized by at least one stakeholder. There are no restrictions on\n-the submitter.\n+Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholder.\n \n ``fetchByKey`` fails and aborts the transaction if:\n \n-- Missing authorization, i.e., no authorization from a\n-  stakeholder of the contract you are trying to fetch.\n+- The submitting party is not a stakeholder on a contract with the givem key, or\n+- A contract was found, but the ``fetchByKey`` violates the authorization rule, meaning no stakeholder authorized the ``fetch``..\n \n-This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting party doesn't know about it, or there are issues with authorization.\n \n Because different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\n \n .. _lookupbykey:\n \n-``lookupByKey``\n+lookupByKey\n ===============\n \n ``optionalContractId <- lookupByKey @ContractType contractKey``\n \n Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``Some contractId``, where ``contractId`` is the ID of the contract; otherwise, it returns ``None``.\n \n-``lookupByKey`` needs to be authorized by **all** maintainers of the\n-contract you are trying to lookup. There are no restrictions on the\n-submitter.\n+``lookupByKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. WIthout this restriction, a malicious Party could legitimately request another party to validate any number of negative contract key lookups without that other party ever having signed anything."
  },
  {
    "id" : "30413802-1019-4a3b-89df-13fb79aefb0f",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "3e42da4a-40a1-4837-a4ff-83dbdcee8659",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What happens if such a key does exist? Then validation fails? We should mention that here.",
        "createdAt" : "2020-05-11T10:09:22Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract.\n \n .. _fetchbykey:\n \n-``fetchByKey``\n+fetchByKey\n ==============\n \n ``(fetchedContractId, fetchedContract) <- fetchByKey @ContractType contractKey``\n \n-Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to ``fetch`` and behaves the same in most ways. \n \n It returns a tuple of the ID and the contract object (containing all its data).\n \n-``fetchByKey`` is authorized like ``fetch`` so it needs to be\n-authorized by at least one stakeholder. There are no restrictions on\n-the submitter.\n+Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholder.\n \n ``fetchByKey`` fails and aborts the transaction if:\n \n-- Missing authorization, i.e., no authorization from a\n-  stakeholder of the contract you are trying to fetch.\n+- The submitting party is not a stakeholder on a contract with the givem key, or\n+- A contract was found, but the ``fetchByKey`` violates the authorization rule, meaning no stakeholder authorized the ``fetch``..\n \n-This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting party doesn't know about it, or there are issues with authorization.\n \n Because different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\n \n .. _lookupbykey:\n \n-``lookupByKey``\n+lookupByKey\n ===============\n \n ``optionalContractId <- lookupByKey @ContractType contractKey``\n \n Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``Some contractId``, where ``contractId`` is the ID of the contract; otherwise, it returns ``None``.\n \n-``lookupByKey`` needs to be authorized by **all** maintainers of the\n-contract you are trying to lookup. There are no restrictions on the\n-submitter.\n+``lookupByKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. WIthout this restriction, a malicious Party could legitimately request another party to validate any number of negative contract key lookups without that other party ever having signed anything.\n \n-If the lookup fails (ie returns ``None``), this guarantees that no contract has this key.\n+Unlike ``fetchByKey``, the transaction **does not fail** if no contract with the given key is found. Instead, ``lookupByKey`` just returns ``None``. However, that does not guarantee that no such contract exists. The submitting party may simply not know about it."
  },
  {
    "id" : "edf3195c-b62a-4656-8416-10593ec6177b",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "b29405b6-f817-44d1-818a-595007d378da",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nexerciseByKey\r\n=============\r\n```",
        "createdAt" : "2020-05-11T10:09:32Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : null,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract.\n \n .. _fetchbykey:\n \n-``fetchByKey``\n+fetchByKey\n ==============\n \n ``(fetchedContractId, fetchedContract) <- fetchByKey @ContractType contractKey``\n \n-Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to ``fetch`` and behaves the same in most ways. \n \n It returns a tuple of the ID and the contract object (containing all its data).\n \n-``fetchByKey`` is authorized like ``fetch`` so it needs to be\n-authorized by at least one stakeholder. There are no restrictions on\n-the submitter.\n+Like ``fetch``, ``fetchByKey`` needs to be authorized by at least one stakeholder.\n \n ``fetchByKey`` fails and aborts the transaction if:\n \n-- Missing authorization, i.e., no authorization from a\n-  stakeholder of the contract you are trying to fetch.\n+- The submitting party is not a stakeholder on a contract with the givem key, or\n+- A contract was found, but the ``fetchByKey`` violates the authorization rule, meaning no stakeholder authorized the ``fetch``..\n \n-This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that the submitting party doesn't know about it, or there are issues with authorization.\n \n Because different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\n \n .. _lookupbykey:\n \n-``lookupByKey``\n+lookupByKey\n ===============\n \n ``optionalContractId <- lookupByKey @ContractType contractKey``\n \n Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``Some contractId``, where ``contractId`` is the ID of the contract; otherwise, it returns ``None``.\n \n-``lookupByKey`` needs to be authorized by **all** maintainers of the\n-contract you are trying to lookup. There are no restrictions on the\n-submitter.\n+``lookupByKey`` needs to be authorized by **all** maintainers of the contract you are trying to lookup. The reason for that is denial of service protection. WIthout this restriction, a malicious Party could legitimately request another party to validate any number of negative contract key lookups without that other party ever having signed anything.\n \n-If the lookup fails (ie returns ``None``), this guarantees that no contract has this key.\n+Unlike ``fetchByKey``, the transaction **does not fail** if no contract with the given key is found. Instead, ``lookupByKey`` just returns ``None``. However, that does not guarantee that no such contract exists. The submitting party may simply not know about it.\n+\n+``lookupByKey`` fails and aborts the transaction if:\n+\n+- Authorization from at least one maintainer is missing. This check fails at interpretation time.\n+- The lookup is incorrect. This can happen either due to contention, or because the submitter didn't know of the contract. This check fails at validation time.\n \n-Unlike ``fetchByKey``, the transaction **does not fail** if a contract with the key doesn't exist: instead, ``lookupByKey`` just returns ``None``.\n \n To get the data from the contract once you've confirmed it exists, you'll still need to use ``fetch``.\n \n Because different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\n \n-``exerciseByKey``\n+exerciseByKey\n ================="
  },
  {
    "id" : "30555b3b-b1bb-4ddc-9bc1-9c2e72b45773",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "f7b4e797-118e-445d-b410-ce18937f6e38",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I think there's a significant difference: signatories \"owning\" a contract is a DAML-level (or ledger model-level) authorization concern, in that they must authorize the creation at the DAML level. Preventing double spends or ensuring key uniqueness is an implementation concern. For example, it's done through the committers in vDAML, and signatories/maintainers have nothing to do with it.",
        "createdAt" : "2020-05-11T10:49:47Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "550c64bd-38b2-4519-8ba8-acb55b9cf9a7",
        "parentId" : "f7b4e797-118e-445d-b410-ce18937f6e38",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "To me, that's an issue with ledger fidelity. In kvutil ledgers, the participants have simply delegated their responsibility / right to validate transactions to centralized validating nodes. I still think the maintainers conceptually own the index / keys and have the responsibility to maintain uniqueness.\r\n\r\nThink of a deployment situation where parties can be hosted on multiple Participants on different domains. It is exactly the maintainers responsibility not to allocate keys on different domains and thus violate uniqueness.",
        "createdAt" : "2020-05-11T11:28:31Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bf8036f4-e7ae-431d-b501-1bd437a49691",
        "parentId" : "f7b4e797-118e-445d-b410-ce18937f6e38",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Another way of thinking about it is this:\r\n\r\nIn an idealised DAML Ledger where Parties correspond to Participants and DAML's privacy model is fully implemented, if all signatories collaborate, they can double spend their contracts, for nobody else knows about these contracts at all.\r\n\r\nIf all maintainers collaborate, they can double-allocate a key, for if C1 has key K with signatories M u S and maintainers M, they may be able to create a disjoint set S' and create C2 with key K, signatories M u S' and maintainers M. Since only M know about C1 and C2, nobody is any the wiser.\r\n",
        "createdAt" : "2020-05-11T11:32:54Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f0d7f0cd-c706-4df4-a56e-d880e1de4562",
        "parentId" : "f7b4e797-118e-445d-b410-ce18937f6e38",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Sure, but this presupposes that signatories/maintainers collaborate in some way during validation. I can also take your example and consider the case where my participant node just chooses to show me some contracts as double-spent locally, without any of the other signatories' participants being any the wiser. Can now any node double spend the contract? Should we talk about that in the DAML docs too? \r\n\r\nWhat I'm trying to say, there are many ways to slice it, the question is which ones are the most useful/understandable. While validation is part of the process of every implementation, I think it's confusing to talk about it at the level of the language/abstract ledger model, where the details of the validation process are unclear.",
        "createdAt" : "2020-05-11T15:57:02Z",
        "updatedAt" : "2020-05-11T15:57:02Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : 13,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. "
  },
  {
    "id" : "aef1ef6a-763b-4c69-b67a-3ce64f54be60",
    "prId" : 5923,
    "comments" : [
      {
        "id" : "862e7066-da12-4a9b-9604-10f77d59dfa5",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "This looks like a good place for a note on the ramifications for concurrent access to keys in a parallel/distributed setting.",
        "createdAt" : "2020-05-11T11:10:00Z",
        "updatedAt" : "2020-05-11T11:40:10Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c59b3f653972a4c96542fa6a0f77d69f1f863be",
    "line" : 29,
    "diffHunk" : "@@ -19,76 +19,76 @@ Here's an example of setting up a contract key for a bank account, to act as a b\n What can be a contract key\n **************************\n \n-The key can be an arbitrary expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n+The key can be an arbitrary serializable expression that does **not** contain contract IDs. However, it **must** include every party that you want to use as a ``maintainer`` (see `Specifying maintainers`_ below).\n \n It's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\n \n Specifying maintainers\n **********************\n \n-If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers.  However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key.  Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories of the contract.\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. The maintainers \"own\" the key in the same way the signatories \"own\" a contract. Just like signatories of contracts prevent double spends or use of false contract data, maintainers of keys prevent double allocation or incorrect lookups. Since the key is part of the contract, the maintainers **must** be signatories of the contract. However, maintainers are computed from the ``key`` instead of the template arguments.  In the example above, the ``bank`` is ultimately the maintainer of the key. \n \n-Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+Keys are unique to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could re-use that ``accountID``.\n \n-When you're writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+When you are writing DAML models, the maintainers matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n \n Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n \n-Contract keys functions\n-***********************\n+Contract Lookups\n+****************\n \n-Contract keys introduce several new functions.\n+The primary purpose of contract keys is to provide a stable, and possibly meaningful, identifier for contracts that can be used in DAML to fetch contracts. There are two functions to perform such lookups: :ref:`fetchbykey` and :ref:`lookupbykey`. Both types of lookup are performed at interpretation time on the submitting Partipant Node, on a best-effort basis. Currently, that best-effort means lookups only return contracts if the submitting Party is a stakeholder of that contract."
  },
  {
    "id" : "366d8ba4-099c-4618-9104-c827f3ee68a1",
    "prId" : 3835,
    "comments" : [
      {
        "id" : "3b521439-b41b-4782-91d8-2b95b0d51f82",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not sure this conveys the correct meaning. In particular, it's not clear who is \"you\". The authorization context might contain multiple parties. In my understanding, the that context needs to contain at least one stakeholder for a `fetchByKey` to be well-authorized. There are no conditions on the submitter though. \r\n@bame-da can you confirm?",
        "createdAt" : "2019-12-12T17:45:24Z",
        "updatedAt" : "2019-12-12T17:53:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "652ee320bd05c0959a84e98698e5455db4e270c5",
    "line" : null,
    "diffHunk" : "@@ -50,12 +50,11 @@ Use ``fetchByKey`` to fetch the ID and data of the contract with the specified k\n \n It returns a tuple of the ID and the contract object (containing all its data).\n \n-You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+``fetchByKey`` is authorized like ``fetch`` so you need to be a stakeholder to run ``fetchByKey``."
  },
  {
    "id" : "8d8706fc-0804-404f-93d4-79747ff66299",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "a46a0aa2-7889-49cc-9048-60be49bc0cbe",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2019-07-18T11:13:40Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -1,6 +1,8 @@\n .. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n+.. _daml-ref-contract-keys:"
  },
  {
    "id" : "83cced4f-3af9-4e92-8ca9-e408cf83a028",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "4cf51b69-b0fd-45f0-a57f-3c81a525285f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nContract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances: that can be a single parameter to the template or a combination of parameters (eg, in a tuple).\r\n```",
        "createdAt" : "2019-05-13T17:54:42Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,83 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying instances of that contract: that can be a single parameter to the template or a combination of parameters (eg, in a tuple)."
  },
  {
    "id" : "ede1b27e-bc79-45eb-a6d6-9d16682ad5c4",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "71467d9d-a0e2-4a75-9f3e-3ae358d2b102",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think flexible is the wrong word. It's rather very limited. You can't basically use anything but tuples and record projections. I would also say something like \"you will probably want to put multiple template parameters into a tuple\". I guess what you're referring to is setting up a type _synonym_ for the type of the key expression. I'm not sure we should actually recommend that.",
        "createdAt" : "2019-05-13T17:55:55Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,83 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying instances of that contract: that can be a single parameter to the template or a combination of parameters (eg, in a tuple).\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+What you can specify is pretty flexible - you will probably want to set up a data type for your key, which is either a tuple or a record."
  },
  {
    "id" : "41a13460-3586-4ee9-8f4b-f8044f90bd60",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "95e60371-46a8-45b9-80dc-1c52324ef0e6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We need to explain the `@Account` part from the example above. This is about ambiguous types. I'll explain the details in person tomorrow.\r\nSame for `lookupByKey` and `exerciseByKey`.",
        "createdAt" : "2019-05-13T18:02:25Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : 45,
    "diffHunk" : "@@ -0,0 +1,83 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying instances of that contract: that can be a single parameter to the template or a combination of parameters (eg, in a tuple).\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+What you can specify is pretty flexible - you will probably want to set up a data type for your key, which is either a tuple or a record.\n+\n+However, the contract key *must* include every party that you specify as a ``maintainer``. For example, with ``maintainer bank``, ``key (bank, number) : AccountKey`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify ``maintainer``(s), in a similar way to specifying signatories or observers.\n+\n+Maintainers are the parties that know about all of the keys that they are party to, and so it's their responsibility to guarantee uniqueness of contract keys. The maintainers **must** be signatories or observers of the contract.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``"
  },
  {
    "id" : "3ebef51f-3f62-4e38-82cf-a9eea4e1714e",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "40877b13-7fe0-4f6e-8425-15489cfc97e9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nIf you don't include the ``maintainer``s in your ``key``, you'll see the following error::\r\n```\r\nThe exact error message might look slightly different but still shitty.",
        "createdAt" : "2019-05-13T18:05:36Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,83 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying instances of that contract: that can be a single parameter to the template or a combination of parameters (eg, in a tuple).\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+What you can specify is pretty flexible - you will probably want to set up a data type for your key, which is either a tuple or a record.\n+\n+However, the contract key *must* include every party that you specify as a ``maintainer``. For example, with ``maintainer bank``, ``key (bank, number) : AccountKey`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify ``maintainer``(s), in a similar way to specifying signatories or observers.\n+\n+Maintainers are the parties that know about all of the keys that they are party to, and so it's their responsibility to guarantee uniqueness of contract keys. The maintainers **must** be signatories or observers of the contract.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+\n+``fetchByKey`` fails and aborts the transaction if:\n+\n+- you don't have sufficient authorization\n+- you're not a stakeholder of the contract you're trying to fetch\n+\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+\n+TODO code example.\n+\n+``lookupByKey``\n+===============\n+\n+Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``ContractId`` of the contract; otherwise, it returns ``None``.\n+\n+You need authorization from **all** of the maintainers to run ``lookupByKey``, and it can only be submitted by one of the maintainers. TODO what the failure will look like.\n+\n+If the lookup fails (ie returns ``None``), this guarantees that no contract has this key.\n+\n+To get the data from the contract once you've confirmed it exists, you'll still need to use ``fetch``.\n+\n+TODO code example.\n+\n+``exerciseByKey``\n+=================\n+\n+Use ``exerciseByKey`` to exercise a choice on a contract identified by its ``key`` (compared to ``exercise``, which lets you exercise a contract identified by its ``ContractId``).\n+\n+Error messages\n+**************\n+\n+If you don't include the ``maintainer``s in your ``key``, you'll see the following errror::"
  },
  {
    "id" : "18a15b7c-7642-4bc8-8d06-6b12de5b5890",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "880fa96a-5fd1-459e-a0a2-4d96874b8bb2",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "this sounds like advice but it's currently an order",
        "createdAt" : "2019-05-14T13:56:12Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4f2c3fe9-95fa-458d-b606-276a1bf5d6a8",
        "parentId" : "880fa96a-5fd1-459e-a0a2-4d96874b8bb2",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "you can't use a list?",
        "createdAt" : "2019-05-14T14:00:52Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04d79254-02db-4e2b-af30-a45b711d44ef",
        "parentId" : "880fa96a-5fd1-459e-a0a2-4d96874b8bb2",
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "I misunderstood what you were saying here, please ignore this comment.\r\n\r\nYou cannot _form_ new lists in the key, but you can use keys that are arguments.",
        "createdAt" : "2019-05-14T14:04:49Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c018328e-3bf7-433b-bdcf-e6d9640751e1",
        "parentId" : "880fa96a-5fd1-459e-a0a2-4d96874b8bb2",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nIt's best to use simple types for your keys like ``Text`` or ``Int``, rather than a list or more complex type.\r\n```",
        "createdAt" : "2019-05-15T11:06:55Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type."
  },
  {
    "id" : "e0706617-1f21-497f-9db4-c6a919ac847e",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "51d7a642-5f81-40fa-b578-068b3f6868b0",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "i think it'd be better to do\r\n```suggestion\r\n``(fetchedContractId, fetchedContract) <- fetchByKey @ContractType contractKey``\r\n```",
        "createdAt" : "2019-05-14T13:57:25Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "410e5b07-d9a5-46fa-af87-a96eda8d2f23",
        "parentId" : "51d7a642-5f81-40fa-b578-068b3f6868b0",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I agree.",
        "createdAt" : "2019-05-15T11:07:48Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``"
  },
  {
    "id" : "13d3d5a6-27d8-489f-90a1-45bf6b73c8bc",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "d82b1a14-f250-4e49-bc72-d51990b85d05",
        "parentId" : null,
        "author" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "body" : "```suggestion\r\n   Unbound reference to this in maintainer with evar.\r\n   \r\nWe plan to improve the error messages in the near future.\r\n```",
        "createdAt" : "2019-05-14T13:59:04Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bitonic",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/556090?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ac3794b5-e74f-49b3-829c-4e297fd54064",
        "parentId" : "d82b1a14-f250-4e49-bc72-d51990b85d05",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Nope - I really don't like committing to future improvements in the docs. Doesn't help the users at the point they read it, just makes us feel better.",
        "createdAt" : "2019-05-14T14:02:32Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "51750c1f-7b42-499b-ae09-1cdef5fc6f3b",
        "parentId" : "d82b1a14-f250-4e49-bc72-d51990b85d05",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Oops, the \"We plan to improve the error messages in the near future.\" was not meant to be part of the suggestion.",
        "createdAt" : "2019-05-14T16:08:40Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : 97,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+\n+``fetchByKey`` fails and aborts the transaction if:\n+\n+- you don't have sufficient authorization\n+- you're not a stakeholder of the contract you're trying to fetch\n+\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+``lookupByKey``\n+===============\n+\n+``contractId <- lookupByKey @ContractType contractKey``\n+\n+Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``ContractId`` of the contract; otherwise, it returns ``None``.\n+\n+You need authorization from **all** of the maintainers to run ``lookupByKey``, and it can only be submitted by one of the maintainers.\n+\n+If the lookup fails (ie returns ``None``), this guarantees that no contract has this key.\n+\n+Unlike ``fetchByKey``, the transaction **does not fail** if a contract with the key doesn't exist: instead, ``lookupByKey`` just returns ``None``.\n+\n+To get the data from the contract once you've confirmed it exists, you'll still need to use ``fetch``.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+``exerciseByKey``\n+=================\n+\n+``exerciseByKey @ContractType contractKey``\n+\n+Use ``exerciseByKey`` to exercise a choice on a contract identified by its ``key`` (compared to ``exercise``, which lets you exercise a contract identified by its ``ContractId``).\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+Error messages\n+**************\n+\n+If you don't include the ``maintainer`` in your ``key``, you'll see the following error::\n+\n+   Failure to process DAML program, this feature is not currently supported.\n+   Unbound reference to this in maintainer with evar."
  },
  {
    "id" : "461e6665-8c9e-4e14-97cb-83c3f7edb6d4",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "fa5c1d4c-a7b0-4f13-8f36-57a5ffd82c85",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not sure we should explain how to authorize something here. We should instead do this in a more general setting because it is relevant for `create` and `exercise` as well. Can we just drop the second sentence for now?",
        "createdAt" : "2019-05-15T11:10:03Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5d8ee5de-902d-4e77-a6fb-bbce29ebc159",
        "parentId" : "fa5c1d4c-a7b0-4f13-8f36-57a5ffd82c85",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "I think this should be \"as well as\" rather than \"instead\"? I'd like to have the authorization information at the point of need - ie here - but also we could have a more general page explaining how it works overall.",
        "createdAt" : "2019-05-15T12:00:03Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a41e2be8-c62e-4116-9040-3bb93ffa63a2",
        "parentId" : "fa5c1d4c-a7b0-4f13-8f36-57a5ffd82c85",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The authorization model is not simple enough to repeat it inline wherever it is needed. The explanation we have is not quite accurate. A proper explanation would be too long:\r\n> A maintainer can authorize by being a signatory of the contract containing the choice in whose body the `fetchByKey` is run or by being a controller of this choice.",
        "createdAt" : "2019-05-15T12:05:32Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ee5e4075-5e62-41f3-ade6-08c5082b7f7f",
        "parentId" : "fa5c1d4c-a7b0-4f13-8f36-57a5ffd82c85",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Oh, I see what you mean. Hmm.",
        "createdAt" : "2019-05-15T14:28:33Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : 54,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice."
  },
  {
    "id" : "397ff73f-2d8f-4b75-81dd-23afd9cc2d60",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "a02d710d-e5e5-4396-9b0d-63afae74f170",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n``optContractId <- lookupByKey @ContractType contractKey``\r\n```\r\nThe result is not an actual `ContractId a` but an `Optional (ContractId a)`. The `opt` prefix should make this clearer.",
        "createdAt" : "2019-05-15T11:11:52Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+\n+``fetchByKey`` fails and aborts the transaction if:\n+\n+- you don't have sufficient authorization\n+- you're not a stakeholder of the contract you're trying to fetch\n+\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+``lookupByKey``\n+===============\n+\n+``contractId <- lookupByKey @ContractType contractKey``"
  },
  {
    "id" : "dcf7d503-379e-4d7e-8ca7-aa4896c01577",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "9afa588e-6ec7-4f55-89b0-850ae9ca5688",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nUse ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``Some contractId``, where ``contractId`` is the ID of the contract; otherwise, it returns ``None``.\r\n```",
        "createdAt" : "2019-05-15T11:13:10Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+\n+``fetchByKey`` fails and aborts the transaction if:\n+\n+- you don't have sufficient authorization\n+- you're not a stakeholder of the contract you're trying to fetch\n+\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+``lookupByKey``\n+===============\n+\n+``contractId <- lookupByKey @ContractType contractKey``\n+\n+Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``ContractId`` of the contract; otherwise, it returns ``None``."
  },
  {
    "id" : "1e9ce93e-07ea-45d6-bb7f-92d0be42b29b",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "cffc1c42-90df-43b0-95f0-4d9583ef826b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Authorization is a local thing within a transaction because it can be delegated from the signatories of a contract into the choices of that contract. The condition that a transaction containing a `lookupByKey` needs to be submitted by one of the maintainers is a global condition. (Is that actually true, @bitonic?) I would split that sentence definitely into two sentences. Maybe like:\r\n```suggestion\r\nYou need authorization from **all** of the maintainers to run ``lookupByKey``. A transaction containing a ``lookupByKey`` needs to be submitted by one of the maintainers.\r\n```",
        "createdAt" : "2019-05-15T11:17:19Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "de0c0f83-874b-4ef2-9016-62d94e33ec8b",
        "parentId" : "cffc1c42-90df-43b0-95f0-4d9583ef826b",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "I'll wait on the answer from @bitonic about whether this is actually right before I add this in :) ",
        "createdAt" : "2019-05-15T12:02:26Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : 72,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+\n+``fetchByKey`` fails and aborts the transaction if:\n+\n+- you don't have sufficient authorization\n+- you're not a stakeholder of the contract you're trying to fetch\n+\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+``lookupByKey``\n+===============\n+\n+``contractId <- lookupByKey @ContractType contractKey``\n+\n+Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``ContractId`` of the contract; otherwise, it returns ``None``.\n+\n+You need authorization from **all** of the maintainers to run ``lookupByKey``, and it can only be submitted by one of the maintainers."
  },
  {
    "id" : "b59103f7-b1cd-496a-8589-6c03effb2616",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "809ccf2d-92cb-4343-84fd-9dbc9b67d378",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nBecause different templates can use the same key type, you need to specify the type of the contract you are trying to fetch using the ``@ContractType`` syntax.\r\n```\r\nSame below for `lookupByKey` and `exerciseByKey`.",
        "createdAt" : "2019-05-15T11:20:11Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+\n+``fetchByKey`` fails and aborts the transaction if:\n+\n+- you don't have sufficient authorization\n+- you're not a stakeholder of the contract you're trying to fetch\n+\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``."
  },
  {
    "id" : "37dc9c3c-253d-40f3-b19b-c38d4ab77a77",
    "prId" : 1112,
    "comments" : [
      {
        "id" : "9261906b-7b61-4e8e-b891-fe6acfd9d051",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nUse ``exerciseByKey`` to exercise a choice on a contract identified by its ``key`` (compared to ``exercise``, which lets you exercise a contract identified by its ``ContractId``). To run ``exerciseByKey`` you need authorization from the controllers of the choice and at least one of the key maintainers.\r\n```",
        "createdAt" : "2019-05-15T11:22:38Z",
        "updatedAt" : "2019-05-16T15:46:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "25c156ef290597fc1251dafd7bcb3842902f98cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,95 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Contract keys\n+#############\n+\n+Contract keys are an optional addition to templates. They let you specify a way of uniquely identifying contract instances, using the parameters to the template - similar to a primary key for a database.\n+\n+You can use contract keys to stably refer to a contract, even through iterations of instances of it.\n+\n+Here's an example of setting up a contract key for a bank account, to act as a bank account ID:\n+\n+.. literalinclude:: ../code-snippets/ContractKeys.daml\n+   :language: daml\n+   :start-after: -- start contract key setup snippet\n+   :end-before: -- end contract key setup snippet\n+\n+What can be a contract key\n+**************************\n+\n+The key should either be a tuple or a record, and it **must** include every party that you specify as a ``maintainer`` (see `Specifying maintainers`_ below).\n+\n+For example, with ``maintainer bank``, ``key (bank, number) : (Party, Text)`` is valid; but wouldn't be if you removed ``bank`` from the key.\n+\n+It's best to use simple types for your keys like ``Text`` or ``Integer``, rather than a list or more complex type.\n+\n+Specifying maintainers\n+**********************\n+\n+If you specify a contract key for a template, you must also specify a ``maintainer`` or maintainers, in a similar way to specifying signatories or observers. Maintainers are the parties that know about all of the keys that they are party to, and are used by the engine to guarantee uniqueness of contract keys.  The maintainers **must** be signatories or observers of the contract.\n+\n+Keys are unique only to their maintainers. For example, say you have a key that you're using as the identifer for a ``BankAccount`` contract. You might have ``key (bank, accountId) : (Party, Text)``. When you create a new bank account, the contract key ensures that no-one else can have an account with the same ``accountID`` at that bank. But that doesn't apply to other banks: for a contract with a different bank as maintainer, you could happily re-use that ``accountID``.\n+\n+When you're writing DAML models, the maintainers only matter since they affect authorization -- much like signatories and observers. You don't need to do anything to \"maintain\" the keys.\n+\n+Checking of the keys is done automatically at execution time, by the DAML exeuction engine: if someone tries to create a new contract that duplicates an existing contract key, the execution engine will cause that creation to fail. \n+\n+Contract keys functions\n+***********************\n+\n+Contract keys introduce several new functions.\n+\n+``fetchByKey``\n+==============\n+\n+``fetchedContract <- fetchByKey @ContractType contractKey``\n+\n+Use ``fetchByKey`` to fetch the ID and data of the contract with the specified key. It is an alternative to the currently-used ``fetch``.\n+\n+It returns a tuple of the ID and the contract object (containing all its data). \n+\n+You need authorization from **at least one** of the maintainers to run ``fetchByKey``. A maintainer can authorize by being a signatory, or by submitting the command/being a controller for the choice.\n+\n+``fetchByKey`` fails and aborts the transaction if:\n+\n+- you don't have sufficient authorization\n+- you're not a stakeholder of the contract you're trying to fetch\n+\n+This means that if it fails, it doesn't guarantee that a contract with that key doesn't exist, just that you can't see one.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+``lookupByKey``\n+===============\n+\n+``contractId <- lookupByKey @ContractType contractKey``\n+\n+Use ``lookupByKey`` to check whether a contract with the specified key exists. If it does exist, ``lookupByKey`` returns the ``ContractId`` of the contract; otherwise, it returns ``None``.\n+\n+You need authorization from **all** of the maintainers to run ``lookupByKey``, and it can only be submitted by one of the maintainers.\n+\n+If the lookup fails (ie returns ``None``), this guarantees that no contract has this key.\n+\n+Unlike ``fetchByKey``, the transaction **does not fail** if a contract with the key doesn't exist: instead, ``lookupByKey`` just returns ``None``.\n+\n+To get the data from the contract once you've confirmed it exists, you'll still need to use ``fetch``.\n+\n+Because the type is ambiguous, when calling you need to specify what you expect with ``@`` and the type, for example ``@MyTemplateType``.\n+\n+``exerciseByKey``\n+=================\n+\n+``exerciseByKey @ContractType contractKey``\n+\n+Use ``exerciseByKey`` to exercise a choice on a contract identified by its ``key`` (compared to ``exercise``, which lets you exercise a contract identified by its ``ContractId``)."
  }
]