[
  {
    "id" : "2feae921-3962-4163-858a-ee2783631000",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "b15be546-2625-4125-ac7d-1593f8a64e14",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nSometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\r\n```\r\n\r\nAt least to me “such as assets” doesn’t help make things clearer so I would just remove it.",
        "createdAt" : "2019-09-03T06:53:56Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means."
  },
  {
    "id" : "3a717280-4ffe-414d-985f-c617d9a08148",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "beb4fdfa-b00e-4355-938a-1932040f62ca",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "> Generic templates allow you to abstract template code from some of the data that would occur in the contracts.\r\n\r\nThat sentence is a bit confusing imho since both “template code” and “some of the data that would occur in the contracts” are very fuzzy terms. How about the following\r\n\r\n> Generic templates allow you to capture logic shared by different templates in a single place instead of having to duplicate it for every template.",
        "createdAt" : "2019-09-03T06:58:44Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means."
  },
  {
    "id" : "5745561d-abd3-459f-9743-d5086cbe1892",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "c75e0b55-4f2b-4ce0-a179-3123118a221f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nThis is how a generic ``Proposal`` template looks in DAML.\r\n```",
        "createdAt" : "2019-09-03T06:59:33Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\n+\n+Example: Generic Proposal\n+*************************\n+\n+Suppose we want to model a propose and accept workflow. This means that a party can propose a contract to some number of receiving parties, and any one of them can accept it with the terms of that contract. We see this pattern occur frequently for different types of contracts. Of course, we could implement one proposal template for every underlying template. However this is tedious and error prone. Alternatively, we can write it once and for all using a generic template.\n+\n+This is how a generic Proposal template looks in DAML."
  },
  {
    "id" : "c9daf70c-60fd-49cb-843c-5810399b0d86",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "484805c7-4c46-4d9c-bd7b-cb1430429adb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nSecondly, the ``asset`` parameter to the template has the abstract type ``t``. We don't know anything about ``asset`` other than the fact that it has an instance of `Template`. However this is all we need to implement the proposal template.\r\n```",
        "createdAt" : "2019-09-03T07:01:04Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\n+\n+Example: Generic Proposal\n+*************************\n+\n+Suppose we want to model a propose and accept workflow. This means that a party can propose a contract to some number of receiving parties, and any one of them can accept it with the terms of that contract. We see this pattern occur frequently for different types of contracts. Of course, we could implement one proposal template for every underlying template. However this is tedious and error prone. Alternatively, we can write it once and for all using a generic template.\n+\n+This is how a generic Proposal template looks in DAML.\n+\n+.. literalinclude:: ../code-snippets/Proposal.daml\n+   :language: daml\n+   :start-after: -- start proposal body\n+   :end-before: -- end proposal body\n+\n+There are several things to notice in this short template.\n+\n+Firstly, where there is usually just a template name, there is now a *template header* ``Template t => Proposal t``. Here ``Proposal`` takes a single type parameter ``t`` representing the type of the underlying asset. The ``Template`` constraint says that ``t`` is not just any type but a contract template with signatories, choices, etc.\n+\n+Secondly, the ``asset`` parameter to the template has the abstract type ``t``. We don't know anything about ``asset`` other than the fact that it has a template type. However this is all we need to implement the proposal template."
  },
  {
    "id" : "27510a63-69fa-42f5-ad6a-dd8ed17641ed",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "d49944af-5ea1-4d62-82fc-6bc486d9302c",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "\"any one of them can accept\" doesn't match your model. \"the receiving parties can jointly accept\" would be correct.",
        "createdAt" : "2019-09-03T07:01:48Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bd8253e3-0b78-4a4c-a45f-72a5a5f0bd36",
        "parentId" : "d49944af-5ea1-4d62-82fc-6bc486d9302c",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point! Would something like the following do the trick?\r\n```\r\n    choice Accept : ContractId t with\r\n        receiver : Party\r\n     controller receiver\r\n     do assert $ receiver `elem` receivers\r\n          create asset\r\n```",
        "createdAt" : "2019-09-03T07:11:57Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "16c1d361-1fcd-44eb-872e-b12d32910bc9",
        "parentId" : "d49944af-5ea1-4d62-82fc-6bc486d9302c",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Ah true. I think to keep this example simple I'll just make it a proposal to a single party. Then I won't need any assertion because the `receiver` will need to exercise the `Accept` choice.",
        "createdAt" : "2019-09-03T14:11:41Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\n+\n+Example: Generic Proposal\n+*************************\n+\n+Suppose we want to model a propose and accept workflow. This means that a party can propose a contract to some number of receiving parties, and any one of them can accept it with the terms of that contract. We see this pattern occur frequently for different types of contracts. Of course, we could implement one proposal template for every underlying template. However this is tedious and error prone. Alternatively, we can write it once and for all using a generic template."
  },
  {
    "id" : "0c262f82-7403-4cfb-a693-f31e9cf6412b",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "6deab008-c03b-4489-ae84-f87c8c0f6218",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Again, this is not correct. `controller receivers can` means that the receivers have *joint* control, ie must exercise the choice together.",
        "createdAt" : "2019-09-03T07:03:47Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\n+\n+Example: Generic Proposal\n+*************************\n+\n+Suppose we want to model a propose and accept workflow. This means that a party can propose a contract to some number of receiving parties, and any one of them can accept it with the terms of that contract. We see this pattern occur frequently for different types of contracts. Of course, we could implement one proposal template for every underlying template. However this is tedious and error prone. Alternatively, we can write it once and for all using a generic template.\n+\n+This is how a generic Proposal template looks in DAML.\n+\n+.. literalinclude:: ../code-snippets/Proposal.daml\n+   :language: daml\n+   :start-after: -- start proposal body\n+   :end-before: -- end proposal body\n+\n+There are several things to notice in this short template.\n+\n+Firstly, where there is usually just a template name, there is now a *template header* ``Template t => Proposal t``. Here ``Proposal`` takes a single type parameter ``t`` representing the type of the underlying asset. The ``Template`` constraint says that ``t`` is not just any type but a contract template with signatories, choices, etc.\n+\n+Secondly, the ``asset`` parameter to the template has the abstract type ``t``. We don't know anything about ``asset`` other than the fact that it has a template type. However this is all we need to implement the proposal template.\n+\n+Notice that the signatories of the proposal are obtained from the signatories of the underlying contract. This is done by calling the overloaded ``signatory`` method. The observers on the other hand are independent of the underlying asset.\n+\n+Finally let's look at the ``Accept`` choice which characterizes the propose and accept workflow. Any receiver can ``Accept`` which results in a contract of the underlying asset type being created. We are able to call ``create`` on the asset since we know it satisfies the ``Template`` constraint."
  },
  {
    "id" : "69e63e20-8cb4-4537-a108-b771509efc0d",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "792c4d3f-db7f-4748-8a4b-a9845f4a7a5c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`template header` sounds a bit weird to me but I don’t have a better proposal (no pun intended) sadly. I think it might also be worth pointing out that this is not something completely different but simply a generalization of the simple case where there is only a template name.",
        "createdAt" : "2019-09-03T07:05:24Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\n+\n+Example: Generic Proposal\n+*************************\n+\n+Suppose we want to model a propose and accept workflow. This means that a party can propose a contract to some number of receiving parties, and any one of them can accept it with the terms of that contract. We see this pattern occur frequently for different types of contracts. Of course, we could implement one proposal template for every underlying template. However this is tedious and error prone. Alternatively, we can write it once and for all using a generic template.\n+\n+This is how a generic Proposal template looks in DAML.\n+\n+.. literalinclude:: ../code-snippets/Proposal.daml\n+   :language: daml\n+   :start-after: -- start proposal body\n+   :end-before: -- end proposal body\n+\n+There are several things to notice in this short template.\n+\n+Firstly, where there is usually just a template name, there is now a *template header* ``Template t => Proposal t``. Here ``Proposal`` takes a single type parameter ``t`` representing the type of the underlying asset. The ``Template`` constraint says that ``t`` is not just any type but a contract template with signatories, choices, etc."
  },
  {
    "id" : "4bf1bb0a-c12a-4415-9b3f-c3689150e5b2",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "3d96ffc3-9f1f-424b-80eb-7352c2272748",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t understand what you are trying to say with “Note that we use two different data types”.",
        "createdAt" : "2019-09-03T07:08:33Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\n+\n+Example: Generic Proposal\n+*************************\n+\n+Suppose we want to model a propose and accept workflow. This means that a party can propose a contract to some number of receiving parties, and any one of them can accept it with the terms of that contract. We see this pattern occur frequently for different types of contracts. Of course, we could implement one proposal template for every underlying template. However this is tedious and error prone. Alternatively, we can write it once and for all using a generic template.\n+\n+This is how a generic Proposal template looks in DAML.\n+\n+.. literalinclude:: ../code-snippets/Proposal.daml\n+   :language: daml\n+   :start-after: -- start proposal body\n+   :end-before: -- end proposal body\n+\n+There are several things to notice in this short template.\n+\n+Firstly, where there is usually just a template name, there is now a *template header* ``Template t => Proposal t``. Here ``Proposal`` takes a single type parameter ``t`` representing the type of the underlying asset. The ``Template`` constraint says that ``t`` is not just any type but a contract template with signatories, choices, etc.\n+\n+Secondly, the ``asset`` parameter to the template has the abstract type ``t``. We don't know anything about ``asset`` other than the fact that it has a template type. However this is all we need to implement the proposal template.\n+\n+Notice that the signatories of the proposal are obtained from the signatories of the underlying contract. This is done by calling the overloaded ``signatory`` method. The observers on the other hand are independent of the underlying asset.\n+\n+Finally let's look at the ``Accept`` choice which characterizes the propose and accept workflow. Any receiver can ``Accept`` which results in a contract of the underlying asset type being created. We are able to call ``create`` on the asset since we know it satisfies the ``Template`` constraint.\n+\n+Template Instances\n+******************\n+\n+The above template soundly represents the proposal workflow, but we have not yet used it on a concrete (non-generic) template. We call the concrete instantiation a *template instance*.\n+\n+Let's introduce a very simple ``Coin`` contract that we can use in the proposal.\n+\n+.. literalinclude:: ../code-snippets/Coin.daml\n+   :language: daml\n+   :start-after: -- start coin\n+   :end-before: -- end coin\n+\n+We would like to model an issuing party (e.g. a bank) proposing a coin contract for an individual to accept. To do this, we need to explicitly state our intention to use ``Coin`` in a ``Proposal``. We do this using the ``template instance`` syntax.\n+\n+.. literalinclude:: ../code-snippets/Coin.daml\n+   :language: daml\n+   :start-after: -- start instance\n+   :end-before: -- end instance\n+\n+Note that we must choose a name, here ``CoinProposal``, for creating contracts of this template in some client languages (for example when using the Java ledger bindings).\n+\n+With a template instance in place, we can create and exercise choices on contracts of this type.\n+\n+.. literalinclude:: ../code-snippets/Coin.daml\n+   :language: daml\n+   :start-after: -- start scenario\n+   :end-before: -- end scenario\n+\n+Note that we use two different data types, ``Coin`` and ``Proposal``, to construct the underlying asset and the proposal data. The bank is able to create the coin proposal which Alice can then accept. This scenario results in two contract creations: first the proposal contract, which is consumed to give rise to the coin contract."
  },
  {
    "id" : "b4b6d1d5-46d5-4875-94e3-8a50ab721cfe",
    "prId" : 2731,
    "comments" : [
      {
        "id" : "96d609de-66a3-41ba-b263-6c2e1350b167",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Two questions that you haven’t addressed are:\r\n\r\n1. Does my type parameter always have to be a template? Afaik, the answer is “no”. That’s only true in this example since you require it to be an instance of “Template”.\r\n2. Can my generic template be parametrized by multiple types? Afaik, the answer is “yes” but I’ve admittedly never tried that.\r\n\r\nTotally fine, to address that in separate PRs.",
        "createdAt" : "2019-09-03T07:10:18Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "35ac3571-6848-46b0-9ed7-08fed3e58775",
        "parentId" : "96d609de-66a3-41ba-b263-6c2e1350b167",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Your answers to both questions is correct. I'll hint at this when I introduce \"template headers\", and will probably demonstrate it with another example in a later PR.",
        "createdAt" : "2019-09-03T19:20:49Z",
        "updatedAt" : "2019-09-03T19:23:32Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6b4025b4e24d4cc9fc8b6270ceb9ece9bfbb7a71",
    "line" : 59,
    "diffHunk" : "@@ -0,0 +1,60 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+\n+Generic Templates\n+#################\n+\n+Sometimes different DAML templates have a common structure. Typically this occurs when there is some logic (usually in choices) that can be applied to many different underlying contracts, such as assets. Generic templates allow you to abstract template code from some of the data that would occur in the contracts. Let's see a simple example to understand what this means.\n+\n+Example: Generic Proposal\n+*************************\n+\n+Suppose we want to model a propose and accept workflow. This means that a party can propose a contract to some number of receiving parties, and any one of them can accept it with the terms of that contract. We see this pattern occur frequently for different types of contracts. Of course, we could implement one proposal template for every underlying template. However this is tedious and error prone. Alternatively, we can write it once and for all using a generic template.\n+\n+This is how a generic Proposal template looks in DAML.\n+\n+.. literalinclude:: ../code-snippets/Proposal.daml\n+   :language: daml\n+   :start-after: -- start proposal body\n+   :end-before: -- end proposal body\n+\n+There are several things to notice in this short template.\n+\n+Firstly, where there is usually just a template name, there is now a *template header* ``Template t => Proposal t``. Here ``Proposal`` takes a single type parameter ``t`` representing the type of the underlying asset. The ``Template`` constraint says that ``t`` is not just any type but a contract template with signatories, choices, etc.\n+\n+Secondly, the ``asset`` parameter to the template has the abstract type ``t``. We don't know anything about ``asset`` other than the fact that it has a template type. However this is all we need to implement the proposal template.\n+\n+Notice that the signatories of the proposal are obtained from the signatories of the underlying contract. This is done by calling the overloaded ``signatory`` method. The observers on the other hand are independent of the underlying asset.\n+\n+Finally let's look at the ``Accept`` choice which characterizes the propose and accept workflow. Any receiver can ``Accept`` which results in a contract of the underlying asset type being created. We are able to call ``create`` on the asset since we know it satisfies the ``Template`` constraint.\n+\n+Template Instances\n+******************\n+\n+The above template soundly represents the proposal workflow, but we have not yet used it on a concrete (non-generic) template. We call the concrete instantiation a *template instance*.\n+\n+Let's introduce a very simple ``Coin`` contract that we can use in the proposal.\n+\n+.. literalinclude:: ../code-snippets/Coin.daml\n+   :language: daml\n+   :start-after: -- start coin\n+   :end-before: -- end coin\n+\n+We would like to model an issuing party (e.g. a bank) proposing a coin contract for an individual to accept. To do this, we need to explicitly state our intention to use ``Coin`` in a ``Proposal``. We do this using the ``template instance`` syntax.\n+\n+.. literalinclude:: ../code-snippets/Coin.daml\n+   :language: daml\n+   :start-after: -- start instance\n+   :end-before: -- end instance\n+\n+Note that we must choose a name, here ``CoinProposal``, for creating contracts of this template in some client languages (for example when using the Java ledger bindings).\n+\n+With a template instance in place, we can create and exercise choices on contracts of this type.\n+\n+.. literalinclude:: ../code-snippets/Coin.daml\n+   :language: daml\n+   :start-after: -- start scenario\n+   :end-before: -- end scenario\n+"
  }
]