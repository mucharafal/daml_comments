[
  {
    "id" : "f16456c5-7d69-444b-9328-5bd8a712745e",
    "prId" : 7505,
    "comments" : [
      {
        "id" : "6386d82d-476e-40c2-8fd7-6f2696ad07de",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You should always include `daml-stdlib` as well. Otherwise, you cannot define a template and in general you cannot do much.",
        "createdAt" : "2020-09-29T07:20:35Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "31d7e8ba8b9d4ac2cf7e14d94f7e500d9f067699",
    "line" : null,
    "diffHunk" : "@@ -16,23 +16,23 @@ The model in this section is not a single DAML file, but a DAML project consisti\n \n .. hint::\n \n-  Remember that you can load all the code for this section into a folder called ``7_Composing`` by running ``daml new 7_Composing --template daml-intro-7``\n+  Remember that you can load all the code for this section into a folder called ``7_Composing`` by running ``daml new 7Composing --template daml-intro-7``\n \n DAML projects\n -------------\n \n-DAML is organized in packages and modules. A DAML project is specified using a single ``daml.yaml`` file, and compiles into a package. Each DAML file within a project becomes a DAML module. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+DAML is organized in projects, packages and modules. A DAML project is specified using a single ``daml.yaml`` file, and compiles into a package in DAML's intermediate language, or bytecode equivalent, DAML-LF. Each DAML file within a project becomes a DAML module, which is a bit like a namespace. Each DAML project has a source root specified in the ``source`` parameter in the project's ``daml.yaml`` file. The package will include all modules specified in ``*.daml`` files beneath that source directory.\n \n-Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal. A minimal project would contain just a ``daml.yaml`` file and an empty directory of source files.\n \n-A minimal project would contain just a ``daml.yaml`` file and an empty directory of source files. Take a look at the ``daml.yaml`` for this project:\n+ Take a look at the ``daml.yaml`` for the chapter 7 project:\n \n .. literalinclude:: daml/daml-intro-7/daml.yaml.template\n   :language: yaml\n \n-You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies: you should always include ``daml-prim``, and ``daml-stdlib`` gives access to the DAML standard library.\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` does what the name suggests: It includes dependencies. You should always include ``daml-prim`` as it contains internals of compiler and DAML Runtime. ``daml-stdlib`` gives access to the DAML Standard Library, and ``daml-script`` contains the types and standard library for DAML Script."
  },
  {
    "id" : "ed77f462-eae1-442e-9234-cfaad2895df9",
    "prId" : 7505,
    "comments" : [
      {
        "id" : "95109b8f-e228-4fb4-8ba6-2dd0f22cf3f4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Side node: We should probably decide on whether we want to call this requester or committer. Currently the ledger model uses requester but our code, DAML studio and other places use committer.",
        "createdAt" : "2020-09-29T07:20:53Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fc8e6592-572e-4149-94db-5fbee0efd4ef",
        "parentId" : "95109b8f-e228-4fb4-8ba6-2dd0f22cf3f4",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "submitter and committer have different meanings elsewhere:\r\n- Submitter being the submitting participant\r\n- Committer being special nodes in some topologies\r\nI've therefore gone all in on requester.",
        "createdAt" : "2020-09-29T07:28:56Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b917b874-cc78-449c-ad62-24b6b953f21f",
        "parentId" : "95109b8f-e228-4fb4-8ba6-2dd0f22cf3f4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Then we seem to use `committer` wrong in quite a lot of cases. E.g., there is an error message in DAML Studio that something is not visible to the committer which refers to the party submiting the commands.",
        "createdAt" : "2020-09-29T07:30:36Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "31d7e8ba8b9d4ac2cf7e14d94f7e500d9f067699",
    "line" : 59,
    "diffHunk" : "@@ -211,18 +211,28 @@ DAML's execution model\n \n DAML's execution model is fairly easy to understand, but has some important consequences. You can imagine the life of a transaction as follows:\n \n-1. A party submits a list of ``Commands``.\n-2. The transaction is interpreted, meaning the ``Update`` corresponding to each command is evaluated in the context of the ledger to calculate all consequences, including transitive ones (consequences of consequences, etc.).\n-3. The views of the transaction that parties get to see (see :ref:`privacy`) are calculated in a process called *blinding*, or *projecting*.\n-4. The blinded views are distributed to the parties.\n-5. The transaction is *validated* based on the blinded views and a consensus protocol depending on the underlying infrastructure.\n-6. If validation succeeds, the transaction is *committed*.\n+Command\n+  A user submits a list of Commands via the Ledger API of a Participant Node, acting as a `Party` hosted on that Node. That party is called the requester."
  },
  {
    "id" : "bafe20d0-2746-48ef-84b8-88a47b1d3338",
    "prId" : 7505,
    "comments" : [
      {
        "id" : "5db39d53-9232-4d12-b7d7-98a616c671e8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This sounds like you call submission only the part where the participant sends it? This is slightly confusing since you call a Submit endpoint when you are sending it _to_ the participant as well.\r\n",
        "createdAt" : "2020-09-29T07:21:18Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "aa7dee30-8f22-4f7d-8733-ec8e54f557ef",
        "parentId" : "5db39d53-9232-4d12-b7d7-98a616c671e8",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "It's true, the service is called `CommandSubmission`, and the requests things like `SubmitAndWait`. We are overall not that consistent in our terminology. Maybe I'll call this transaction submission just to be super clear.",
        "createdAt" : "2020-09-29T07:31:21Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "31d7e8ba8b9d4ac2cf7e14d94f7e500d9f067699",
    "line" : 65,
    "diffHunk" : "@@ -211,18 +211,28 @@ DAML's execution model\n \n DAML's execution model is fairly easy to understand, but has some important consequences. You can imagine the life of a transaction as follows:\n \n-1. A party submits a list of ``Commands``.\n-2. The transaction is interpreted, meaning the ``Update`` corresponding to each command is evaluated in the context of the ledger to calculate all consequences, including transitive ones (consequences of consequences, etc.).\n-3. The views of the transaction that parties get to see (see :ref:`privacy`) are calculated in a process called *blinding*, or *projecting*.\n-4. The blinded views are distributed to the parties.\n-5. The transaction is *validated* based on the blinded views and a consensus protocol depending on the underlying infrastructure.\n-6. If validation succeeds, the transaction is *committed*.\n+Command\n+  A user submits a list of Commands via the Ledger API of a Participant Node, acting as a `Party` hosted on that Node. That party is called the requester.\n+Interpretation\n+  Each Command corresponds to one or more Actions. During this step, the ``Update`` corresponding to each Action is evaluated in the context of the ledger to calculate all consequences, including transitive ones (consequences of consequences, etc.). The result of this is a complete Transaction. Together with its requestor, this is also known as a Commit.\n+Blinding\n+  On ledgers with strong privacy, projections (see :ref:`privacy`) for all involved parties are created. This is also called *projecting*.\n+Submission\n+  The Transaction/Commit is submitted to the network."
  },
  {
    "id" : "2b29c86c-59db-4870-be38-a3f7bfbaefad",
    "prId" : 7505,
    "comments" : [
      {
        "id" : "966580e1-8028-44be-a3db-332a666da54d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "perhaps worth making it more explicit that it always includes all dependencies and is therefore self-contained since this isn’t the case for all JARs.",
        "createdAt" : "2020-09-29T07:27:12Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "31d7e8ba8b9d4ac2cf7e14d94f7e500d9f067699",
    "line" : null,
    "diffHunk" : "@@ -16,23 +16,23 @@ The model in this section is not a single DAML file, but a DAML project consisti\n \n .. hint::\n \n-  Remember that you can load all the code for this section into a folder called ``7_Composing`` by running ``daml new 7_Composing --template daml-intro-7``\n+  Remember that you can load all the code for this section into a folder called ``7_Composing`` by running ``daml new 7Composing --template daml-intro-7``\n \n DAML projects\n -------------\n \n-DAML is organized in packages and modules. A DAML project is specified using a single ``daml.yaml`` file, and compiles into a package. Each DAML file within a project becomes a DAML module. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+DAML is organized in projects, packages and modules. A DAML project is specified using a single ``daml.yaml`` file, and compiles into a package in DAML's intermediate language, or bytecode equivalent, DAML-LF. Each DAML file within a project becomes a DAML module, which is a bit like a namespace. Each DAML project has a source root specified in the ``source`` parameter in the project's ``daml.yaml`` file. The package will include all modules specified in ``*.daml`` files beneath that source directory.\n \n-Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal. A minimal project would contain just a ``daml.yaml`` file and an empty directory of source files.\n \n-A minimal project would contain just a ``daml.yaml`` file and an empty directory of source files. Take a look at the ``daml.yaml`` for this project:\n+ Take a look at the ``daml.yaml`` for the chapter 7 project:\n \n .. literalinclude:: daml/daml-intro-7/daml.yaml.template\n   :language: yaml\n \n-You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies: you should always include ``daml-prim``, and ``daml-stdlib`` gives access to the DAML standard library.\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` does what the name suggests: It includes dependencies. You should always include ``daml-prim`` as it contains internals of compiler and DAML Runtime. ``daml-stdlib`` gives access to the DAML Standard Library, and ``daml-script`` contains the types and standard library for DAML Script.\n \n-You compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``.daml/dist/dist/project_name-project_version.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java: it's the artifact that gets deployed to a ledger to load the contract model.\n+You compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` file in ``.daml/dist/dist/project_name-project_version.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java: it's the artifact that gets deployed to a ledger to load the package and its dependencies."
  },
  {
    "id" : "83532960-045d-4f6f-b0cc-3d9eea48f1fc",
    "prId" : 7264,
    "comments" : [
      {
        "id" : "9614dc26-20e4-4d8d-bed1-cc1a8fc6efb0",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Should this also mention `ApplicativeDo`?",
        "createdAt" : "2020-09-01T08:26:34Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2f91b480-09b1-4fcb-958b-d8dcb9c017ea",
        "parentId" : "9614dc26-20e4-4d8d-bed1-cc1a8fc6efb0",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, I’ll add something.",
        "createdAt" : "2020-09-01T10:35:58Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "de29540f-829f-483e-acff-539da6eea21c",
        "parentId" : "9614dc26-20e4-4d8d-bed1-cc1a8fc6efb0",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We don’t actually use it in this example after the changes. It is mentioned in a preceding section so I’m omitting it here.",
        "createdAt" : "2020-09-01T11:33:55Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "edfcefed5831fd27018f4cb3fdeb4a98f8ea266a",
    "line" : 9,
    "diffHunk" : "@@ -78,6 +78,13 @@ import only the selected names:\n \n   import DA.List (sortOn, groupOn)\n \n+If your module contains any DAML Scripts, you need to import the\n+corresponding functionality:\n+\n+.. code-block:: daml\n+\n+  import Daml.Script"
  },
  {
    "id" : "a5b22652-e46a-4d89-88c2-fe43aa38d4a8",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "3d889ad8-08da-4245-95d5-3ca40dedbd0d",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n7 Composing choices\r\n```",
        "createdAt" : "2019-06-17T14:39:32Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices"
  },
  {
    "id" : "a5826cc8-bbae-4e63-8cd7-0bbb24e75005",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "b94c28a1-5927-4d45-8ce3-5f39944a3482",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nIt's time to put everything you've learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading. This application will have capabilities similar to the one in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\r\n```",
        "createdAt" : "2019-06-17T14:39:59Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:"
  },
  {
    "id" : "9aa6534f-71a6-44ad-bdea-837bcc64266e",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "15a0f876-134c-4bfc-aeaf-1953dfbadfe3",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n- DAML projects, packages and modules\r\n```",
        "createdAt" : "2019-06-17T14:40:14Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules"
  },
  {
    "id" : "a6633a4f-ad0b-4d03-b62e-57b13e30b277",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "49c95978-f759-424e-9e3c-230797b4d73f",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n- Observers and stakeholders\r\n```",
        "createdAt" : "2019-06-17T14:40:25Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders"
  },
  {
    "id" : "d148d087-16ec-425e-958d-3b867af3b8d8",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "a2945e01-59bd-4c9d-b5b5-4b5a6ee9844f",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nDAML projects\r\n```",
        "createdAt" : "2019-06-17T14:40:37Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects"
  },
  {
    "id" : "8a252eb8-638d-4724-9961-bfa0ecf9692e",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "22b5e881-9a26-431f-b112-9efa1cae7a84",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "I've clarified this but let me know if it's not actually correct, as the sense did change a little\r\n\r\n```suggestion\r\nDAML is organized in packages and modules. A DAML project is specified using a single ``daml.yaml`` file, and compiles into a package. Each DAML file within a project becomes a DAML module. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\r\n```",
        "createdAt" : "2019-06-17T14:41:43Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal."
  },
  {
    "id" : "8dc5a289-9c74-447b-9261-5647e4685942",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "a6d32699-0d1b-44df-b218-5c4ea38580bf",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nYou can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies: you should always include ``daml-prim``, and ``daml-stdlib`` gives access to the DAML standard library.\r\n```",
        "createdAt" : "2019-06-17T14:42:54Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library."
  },
  {
    "id" : "8ab1bd17-4b42-4fe8-b1d7-3a8bf0712a06",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "fc5e696a-5b14-4df3-823a-e2b69ff9277d",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nYou compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java: it's the artifact that gets deployed to a ledger to load the contract model.\r\n```",
        "createdAt" : "2019-06-17T14:43:51Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model."
  },
  {
    "id" : "edcf9e2a-39ee-4627-8151-9b33494ff5d2",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "02398ebe-26cf-4ccd-9c74-bce76ca1962d",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Bit confusing to have it called both a dar \"file\" and \"package\" - maybe feels more correct to say that a dar file is a package/DAML package? Not sure",
        "createdAt" : "2019-06-17T14:44:29Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model."
  },
  {
    "id" : "132f0717-f902-4b48-8067-06adb3b84832",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "9fa325f4-7c0d-4ec6-94f7-e4adf502553f",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nProject structure\r\n```",
        "createdAt" : "2019-06-17T14:44:38Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure"
  },
  {
    "id" : "1b17bbc6-51f5-4584-a8be-d49890226e8e",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "1026e9ff-339c-4950-a833-26a3b22a7ee3",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThis project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules: ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\r\n```",
        "createdAt" : "2019-06-17T14:45:08Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``."
  },
  {
    "id" : "7b7a75eb-ef21-4285-89a6-56bec3399d5f",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "d137a487-1ce7-479e-8c29-1a3d6327f904",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nYou can import one module into another using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\r\n```",
        "createdAt" : "2019-06-17T14:45:29Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:"
  },
  {
    "id" : "24adbc45-02cf-4bdc-8601-b700ecf7c442",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "e5302eca-bf78-4c19-bc6f-cf1ca11ee337",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nImports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and lets you only import selected names.\r\n\r\nIn this case, it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional.\r\n```",
        "createdAt" : "2019-06-17T14:46:02Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/LibraryModules.daml\n+  :language: daml\n+  :start-after: -- IMPORTS_BEGIN\n+\n+Imports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and allows one to only import selected names. In this case it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional."
  },
  {
    "id" : "332bf0b2-e3ed-4a17-bb30-eeaee26c2352",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "8a777fce-8592-4aec-a261-8c39a686e55f",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nProject overview\r\n```",
        "createdAt" : "2019-06-17T14:46:14Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/LibraryModules.daml\n+  :language: daml\n+  :start-after: -- IMPORTS_BEGIN\n+\n+Imports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and allows one to only import selected names. In this case it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional.\n+\n+A more typical import statement is ``import Intro.Asset`` as found in ``Test.Intro.Asset``.\n+\n+Project Overview"
  },
  {
    "id" : "dc3523df-1f2f-4063-9212-eb5fd0863f7b",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "30448b42-9e5a-4141-af19-32684257a34d",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThe project both changes and adds to the ``Iou`` model presented in :doc:`6_Parties`:\r\n```",
        "createdAt" : "2019-06-17T14:47:19Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/LibraryModules.daml\n+  :language: daml\n+  :start-after: -- IMPORTS_BEGIN\n+\n+Imports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and allows one to only import selected names. In this case it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional.\n+\n+A more typical import statement is ``import Intro.Asset`` as found in ``Test.Intro.Asset``.\n+\n+Project Overview\n+----------------\n+\n+The project both changes and additions compared to the ``Iou`` model presented in :doc:`6_Parties`:"
  },
  {
    "id" : "5371632d-9c99-417e-9431-1f5f53c1d350",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "94fa73df-fb7a-4663-8b2f-e82fd1028a17",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n2. The transaction is interpreted, meaning the ``Update`` corresponding to each action is evaluated in the context of the ledger to calculate all consequeces, including transitive ones (consequences of consequences, etc).\r\n```",
        "createdAt" : "2019-06-17T14:48:22Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/LibraryModules.daml\n+  :language: daml\n+  :start-after: -- IMPORTS_BEGIN\n+\n+Imports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and allows one to only import selected names. In this case it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional.\n+\n+A more typical import statement is ``import Intro.Asset`` as found in ``Test.Intro.Asset``.\n+\n+Project Overview\n+----------------\n+\n+The project both changes and additions compared to the ``Iou`` model presented in :doc:`6_Parties`:\n+\n+- Assets are fungible in the sense that they have ``Merge`` and ``Split`` choices that allow the ``owner`` to manage their holdings.\n+- Transfer proposals now need the authorities of both ``issuer`` and ``newOwner`` to accept. This makes ``Asset`` safer than ``Iou`` from the issuer's point of view.\n+\n+  With the ``Iou`` model, an ``issuer`` could end up owing cash to anyone as transfers were authorized by just ``owner`` and ``newOwner``. In this project, only parties having an ``AssetHolder`` contract can end up owning assets. This allows the ``issuer`` to determine which parties may own their assets.\n+- The ``Trade`` template adds a swap of two assets to the model.\n+\n+Composed choices and scenarios\n+------------------------------\n+\n+This project showcases how you can put the ``Update`` and ``Scenario`` actions you learnt about in in :doc:`6_Parties` to good use. For example, the ``Merge`` and ``Split`` choices each perform several actions in their consequences.\n+\n+- Two create actions in case of ``Split``\n+- One create and one archive action in case of ``Merge``\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset.daml\n+  :language: daml\n+  :start-after: -- MERGE_SPLIT_BEGIN\n+  :end-before: -- MERGE_SPLIT_END\n+\n+The ``return`` function used in ``Split`` is available in any ``Action`` context. The result of ``return x`` is a no-op containing the value ``x``. It has an alias ``pure``, indicating that it's a pure value, as opposed to a value with side-effects. The ``return`` name makes sense when it's used as the last statement in a ``do`` block as its argument is indeed the \"return\"-value of the ``do`` block in that case.\n+\n+Taking transaction composition a step further, the ``Trade_Settle`` choice on ``Trade`` composes two ``exercise`` actions:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Trade.daml\n+  :language: daml\n+  :start-after: -- TRADE_SETTLE_BEGIN\n+  :end-before: -- TRADE_SETTLE_END\n+\n+The resulting transaction, with its two nested levels of consequences, can be seen in the ``test_trade`` scenario in ``Test.Intro.Asset.Trade``:\n+\n+.. code-block:: none\n+\n+  TX #15 1970-01-01T00:00:00Z (Test.Intro.Asset.Trade:77:23)\n+  #15:0\n+  │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+  └─> 'Bob' exercises Trade_Settle on #13:1 (Intro.Asset.Trade:Trade)\n+            with\n+              quoteAssetCid = #10:1; baseApprovalCid = #14:2\n+      children:\n+      #15:1\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+      #15:2\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+      #15:3\n+      │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+      └─> 'Alice',\n+          'Bob' exercises TransferApproval_Transfer on #14:2 (Intro.Asset:TransferApproval)\n+                with\n+                  assetCid = #11:1\n+          children:\n+          #15:4\n+          │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+          └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+          #15:5\n+          │   known to (since): 'Alice' (#15), 'USD_Bank' (#15), 'Bob' (#15)\n+          └─> 'Alice', 'USD_Bank' exercises Archive on #11:1 (Intro.Asset:Asset)\n+\n+          #15:6\n+          │   referenced by #17:0\n+          │   known to (since): 'Bob' (#15), 'USD_Bank' (#15), 'Alice' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'USD_Bank'; owner = 'Bob'; symbol = \"USD\"; quantity = 100.0; observers = []\n+\n+      #15:7\n+      │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+      └─> 'Bob',\n+          'Alice' exercises TransferApproval_Transfer on #12:1 (Intro.Asset:TransferApproval)\n+                  with\n+                    assetCid = #10:1\n+          children:\n+          #15:8\n+          │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+          └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+          #15:9\n+          │   known to (since): 'Bob' (#15), 'EUR_Bank' (#15), 'Alice' (#15)\n+          └─> 'Bob', 'EUR_Bank' exercises Archive on #10:1 (Intro.Asset:Asset)\n+\n+          #15:10\n+          │   referenced by #16:0\n+          │   known to (since): 'Alice' (#15), 'EUR_Bank' (#15), 'Bob' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'EUR_Bank'; owner = 'Alice'; symbol = \"EUR\"; quantity = 90.0; observers = []\n+\n+Similar to choices, you can see how the scenarios in this project are built up from each other:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Test/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- TEST_ISSUANCE_BEGIN\n+  :end-before: -- TEST_ISSUANCE_END\n+\n+In the above, the ``test_issuance`` scenario in ``Test.Intro.Asset.Role`` uses the output of the ``setupRoles`` scenario in the same module.\n+\n+The same line shows a new kind of pattern matching. Rather than writing ``setupResults <- setupRoles`` and then accessing the components of ``setupResults`` using ``_1``, ``_2``, etc., you can give them names. It's equivelent to writing\n+\n+.. code-block:: daml\n+\n+  setupResults <- setupRoles\n+  case setupResults of\n+    (alice, bob, bank, aha, ahb) -> ...\n+\n+Just writing ``(alice, bob, bank, aha, ahb) <- setupRoles`` would also be legal, but ``setupResults`` is used in the return value of ``test_issuance`` so it makes sense to give it a name, too. The notation with ``@`` allows you to give both the whole value as well as its constituents names in one go.\n+\n+.. _execution_model:\n+\n+DAML's execution model\n+----------------------\n+\n+DAML's execution model is fairly easy to understand, but has some important consequences. You can imagine the life of a transaction as follows:\n+\n+1. A party submits a transaction. Remember, a transaction is just a list of actions.\n+2. The transaction is interpreted, meaning the ``Update`` corresponding to each action is evaluated in the context of the ledger to calculate all consequeces, including transitive ones (consequences of consequences, etc.)"
  },
  {
    "id" : "d6c51e50-67e3-44ab-a845-a8b4c80dc06c",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "7216c479-9308-4edc-8158-3950f48e613e",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "What does that mean? (I don't think you've touched on anything that would explain this so far)",
        "createdAt" : "2019-06-17T14:48:57Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8d49ecf4-15ba-451e-8c19-856407679493",
        "parentId" : "7216c479-9308-4edc-8158-3950f48e613e",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "What does what mean? I say what \"blinded\" means in item 3.",
        "createdAt" : "2019-06-18T08:31:25Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : 204,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/LibraryModules.daml\n+  :language: daml\n+  :start-after: -- IMPORTS_BEGIN\n+\n+Imports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and allows one to only import selected names. In this case it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional.\n+\n+A more typical import statement is ``import Intro.Asset`` as found in ``Test.Intro.Asset``.\n+\n+Project Overview\n+----------------\n+\n+The project both changes and additions compared to the ``Iou`` model presented in :doc:`6_Parties`:\n+\n+- Assets are fungible in the sense that they have ``Merge`` and ``Split`` choices that allow the ``owner`` to manage their holdings.\n+- Transfer proposals now need the authorities of both ``issuer`` and ``newOwner`` to accept. This makes ``Asset`` safer than ``Iou`` from the issuer's point of view.\n+\n+  With the ``Iou`` model, an ``issuer`` could end up owing cash to anyone as transfers were authorized by just ``owner`` and ``newOwner``. In this project, only parties having an ``AssetHolder`` contract can end up owning assets. This allows the ``issuer`` to determine which parties may own their assets.\n+- The ``Trade`` template adds a swap of two assets to the model.\n+\n+Composed choices and scenarios\n+------------------------------\n+\n+This project showcases how you can put the ``Update`` and ``Scenario`` actions you learnt about in in :doc:`6_Parties` to good use. For example, the ``Merge`` and ``Split`` choices each perform several actions in their consequences.\n+\n+- Two create actions in case of ``Split``\n+- One create and one archive action in case of ``Merge``\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset.daml\n+  :language: daml\n+  :start-after: -- MERGE_SPLIT_BEGIN\n+  :end-before: -- MERGE_SPLIT_END\n+\n+The ``return`` function used in ``Split`` is available in any ``Action`` context. The result of ``return x`` is a no-op containing the value ``x``. It has an alias ``pure``, indicating that it's a pure value, as opposed to a value with side-effects. The ``return`` name makes sense when it's used as the last statement in a ``do`` block as its argument is indeed the \"return\"-value of the ``do`` block in that case.\n+\n+Taking transaction composition a step further, the ``Trade_Settle`` choice on ``Trade`` composes two ``exercise`` actions:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Trade.daml\n+  :language: daml\n+  :start-after: -- TRADE_SETTLE_BEGIN\n+  :end-before: -- TRADE_SETTLE_END\n+\n+The resulting transaction, with its two nested levels of consequences, can be seen in the ``test_trade`` scenario in ``Test.Intro.Asset.Trade``:\n+\n+.. code-block:: none\n+\n+  TX #15 1970-01-01T00:00:00Z (Test.Intro.Asset.Trade:77:23)\n+  #15:0\n+  │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+  └─> 'Bob' exercises Trade_Settle on #13:1 (Intro.Asset.Trade:Trade)\n+            with\n+              quoteAssetCid = #10:1; baseApprovalCid = #14:2\n+      children:\n+      #15:1\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+      #15:2\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+      #15:3\n+      │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+      └─> 'Alice',\n+          'Bob' exercises TransferApproval_Transfer on #14:2 (Intro.Asset:TransferApproval)\n+                with\n+                  assetCid = #11:1\n+          children:\n+          #15:4\n+          │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+          └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+          #15:5\n+          │   known to (since): 'Alice' (#15), 'USD_Bank' (#15), 'Bob' (#15)\n+          └─> 'Alice', 'USD_Bank' exercises Archive on #11:1 (Intro.Asset:Asset)\n+\n+          #15:6\n+          │   referenced by #17:0\n+          │   known to (since): 'Bob' (#15), 'USD_Bank' (#15), 'Alice' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'USD_Bank'; owner = 'Bob'; symbol = \"USD\"; quantity = 100.0; observers = []\n+\n+      #15:7\n+      │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+      └─> 'Bob',\n+          'Alice' exercises TransferApproval_Transfer on #12:1 (Intro.Asset:TransferApproval)\n+                  with\n+                    assetCid = #10:1\n+          children:\n+          #15:8\n+          │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+          └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+          #15:9\n+          │   known to (since): 'Bob' (#15), 'EUR_Bank' (#15), 'Alice' (#15)\n+          └─> 'Bob', 'EUR_Bank' exercises Archive on #10:1 (Intro.Asset:Asset)\n+\n+          #15:10\n+          │   referenced by #16:0\n+          │   known to (since): 'Alice' (#15), 'EUR_Bank' (#15), 'Bob' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'EUR_Bank'; owner = 'Alice'; symbol = \"EUR\"; quantity = 90.0; observers = []\n+\n+Similar to choices, you can see how the scenarios in this project are built up from each other:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Test/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- TEST_ISSUANCE_BEGIN\n+  :end-before: -- TEST_ISSUANCE_END\n+\n+In the above, the ``test_issuance`` scenario in ``Test.Intro.Asset.Role`` uses the output of the ``setupRoles`` scenario in the same module.\n+\n+The same line shows a new kind of pattern matching. Rather than writing ``setupResults <- setupRoles`` and then accessing the components of ``setupResults`` using ``_1``, ``_2``, etc., you can give them names. It's equivelent to writing\n+\n+.. code-block:: daml\n+\n+  setupResults <- setupRoles\n+  case setupResults of\n+    (alice, bob, bank, aha, ahb) -> ...\n+\n+Just writing ``(alice, bob, bank, aha, ahb) <- setupRoles`` would also be legal, but ``setupResults`` is used in the return value of ``test_issuance`` so it makes sense to give it a name, too. The notation with ``@`` allows you to give both the whole value as well as its constituents names in one go.\n+\n+.. _execution_model:\n+\n+DAML's execution model\n+----------------------\n+\n+DAML's execution model is fairly easy to understand, but has some important consequences. You can imagine the life of a transaction as follows:\n+\n+1. A party submits a transaction. Remember, a transaction is just a list of actions.\n+2. The transaction is interpreted, meaning the ``Update`` corresponding to each action is evaluated in the context of the ledger to calculate all consequeces, including transitive ones (consequences of consequences, etc.)\n+3. The transaction is *blinded*, or *projected*, meaning the views that different parties have on the transaction are calculated.\n+4. The blinded views are distributed to the parties."
  },
  {
    "id" : "81dd9ee0-92fc-4e25-96df-0e7414f9357b",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "8d87b704-1b13-475a-baf2-5deade194963",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n5. The transaction is *validated* based on the blinded views and a consensus protocol depending on the underlying infrastructure.\r\n6. If validation succeeds, the transaction is *committed*.\r\n```",
        "createdAt" : "2019-06-17T14:49:31Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/LibraryModules.daml\n+  :language: daml\n+  :start-after: -- IMPORTS_BEGIN\n+\n+Imports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and allows one to only import selected names. In this case it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional.\n+\n+A more typical import statement is ``import Intro.Asset`` as found in ``Test.Intro.Asset``.\n+\n+Project Overview\n+----------------\n+\n+The project both changes and additions compared to the ``Iou`` model presented in :doc:`6_Parties`:\n+\n+- Assets are fungible in the sense that they have ``Merge`` and ``Split`` choices that allow the ``owner`` to manage their holdings.\n+- Transfer proposals now need the authorities of both ``issuer`` and ``newOwner`` to accept. This makes ``Asset`` safer than ``Iou`` from the issuer's point of view.\n+\n+  With the ``Iou`` model, an ``issuer`` could end up owing cash to anyone as transfers were authorized by just ``owner`` and ``newOwner``. In this project, only parties having an ``AssetHolder`` contract can end up owning assets. This allows the ``issuer`` to determine which parties may own their assets.\n+- The ``Trade`` template adds a swap of two assets to the model.\n+\n+Composed choices and scenarios\n+------------------------------\n+\n+This project showcases how you can put the ``Update`` and ``Scenario`` actions you learnt about in in :doc:`6_Parties` to good use. For example, the ``Merge`` and ``Split`` choices each perform several actions in their consequences.\n+\n+- Two create actions in case of ``Split``\n+- One create and one archive action in case of ``Merge``\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset.daml\n+  :language: daml\n+  :start-after: -- MERGE_SPLIT_BEGIN\n+  :end-before: -- MERGE_SPLIT_END\n+\n+The ``return`` function used in ``Split`` is available in any ``Action`` context. The result of ``return x`` is a no-op containing the value ``x``. It has an alias ``pure``, indicating that it's a pure value, as opposed to a value with side-effects. The ``return`` name makes sense when it's used as the last statement in a ``do`` block as its argument is indeed the \"return\"-value of the ``do`` block in that case.\n+\n+Taking transaction composition a step further, the ``Trade_Settle`` choice on ``Trade`` composes two ``exercise`` actions:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Trade.daml\n+  :language: daml\n+  :start-after: -- TRADE_SETTLE_BEGIN\n+  :end-before: -- TRADE_SETTLE_END\n+\n+The resulting transaction, with its two nested levels of consequences, can be seen in the ``test_trade`` scenario in ``Test.Intro.Asset.Trade``:\n+\n+.. code-block:: none\n+\n+  TX #15 1970-01-01T00:00:00Z (Test.Intro.Asset.Trade:77:23)\n+  #15:0\n+  │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+  └─> 'Bob' exercises Trade_Settle on #13:1 (Intro.Asset.Trade:Trade)\n+            with\n+              quoteAssetCid = #10:1; baseApprovalCid = #14:2\n+      children:\n+      #15:1\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+      #15:2\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+      #15:3\n+      │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+      └─> 'Alice',\n+          'Bob' exercises TransferApproval_Transfer on #14:2 (Intro.Asset:TransferApproval)\n+                with\n+                  assetCid = #11:1\n+          children:\n+          #15:4\n+          │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+          └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+          #15:5\n+          │   known to (since): 'Alice' (#15), 'USD_Bank' (#15), 'Bob' (#15)\n+          └─> 'Alice', 'USD_Bank' exercises Archive on #11:1 (Intro.Asset:Asset)\n+\n+          #15:6\n+          │   referenced by #17:0\n+          │   known to (since): 'Bob' (#15), 'USD_Bank' (#15), 'Alice' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'USD_Bank'; owner = 'Bob'; symbol = \"USD\"; quantity = 100.0; observers = []\n+\n+      #15:7\n+      │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+      └─> 'Bob',\n+          'Alice' exercises TransferApproval_Transfer on #12:1 (Intro.Asset:TransferApproval)\n+                  with\n+                    assetCid = #10:1\n+          children:\n+          #15:8\n+          │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+          └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+          #15:9\n+          │   known to (since): 'Bob' (#15), 'EUR_Bank' (#15), 'Alice' (#15)\n+          └─> 'Bob', 'EUR_Bank' exercises Archive on #10:1 (Intro.Asset:Asset)\n+\n+          #15:10\n+          │   referenced by #16:0\n+          │   known to (since): 'Alice' (#15), 'EUR_Bank' (#15), 'Bob' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'EUR_Bank'; owner = 'Alice'; symbol = \"EUR\"; quantity = 90.0; observers = []\n+\n+Similar to choices, you can see how the scenarios in this project are built up from each other:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Test/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- TEST_ISSUANCE_BEGIN\n+  :end-before: -- TEST_ISSUANCE_END\n+\n+In the above, the ``test_issuance`` scenario in ``Test.Intro.Asset.Role`` uses the output of the ``setupRoles`` scenario in the same module.\n+\n+The same line shows a new kind of pattern matching. Rather than writing ``setupResults <- setupRoles`` and then accessing the components of ``setupResults`` using ``_1``, ``_2``, etc., you can give them names. It's equivelent to writing\n+\n+.. code-block:: daml\n+\n+  setupResults <- setupRoles\n+  case setupResults of\n+    (alice, bob, bank, aha, ahb) -> ...\n+\n+Just writing ``(alice, bob, bank, aha, ahb) <- setupRoles`` would also be legal, but ``setupResults`` is used in the return value of ``test_issuance`` so it makes sense to give it a name, too. The notation with ``@`` allows you to give both the whole value as well as its constituents names in one go.\n+\n+.. _execution_model:\n+\n+DAML's execution model\n+----------------------\n+\n+DAML's execution model is fairly easy to understand, but has some important consequences. You can imagine the life of a transaction as follows:\n+\n+1. A party submits a transaction. Remember, a transaction is just a list of actions.\n+2. The transaction is interpreted, meaning the ``Update`` corresponding to each action is evaluated in the context of the ledger to calculate all consequeces, including transitive ones (consequences of consequences, etc.)\n+3. The transaction is *blinded*, or *projected*, meaning the views that different parties have on the transaction are calculated.\n+4. The blinded views are distributed to the parties.\n+5. The transaction is *validated* and *committed* based on the blinded views and a consensus protocol depending on the underlying infrastructure."
  },
  {
    "id" : "88cbd7c4-3c90-4664-9363-c3438cfac9bd",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "0329769e-b442-4461-baa9-a3bedc868dba",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nSome DAML ledgers, like the scenario runner and the Sandbox, work on the principle of \"data minimization\", meaning nothing more than the above information is distributed. That is, the \"projection\" of the overall transaction that gets distributed to EUR_Bank in step 4 of :ref:`execution_model` would consist only of the ``TransferApproval_Transfer`` and its consequences.\r\n```",
        "createdAt" : "2019-06-17T14:51:21Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+7 Composing Choices\n+===================\n+\n+It is time to put everything you have learnt so far together into a complete and secure DAML model for asset issuance, management, transfer, and trading, with capabilities similar to that presented in :doc:`/getting-started/quickstart`. In the process you will learn about a few more concepts:\n+\n+- DAML Projects, Packages and Modules\n+- Composition of transactions\n+- Observers and Stakeholders\n+- DAML's execution model\n+- Privacy\n+\n+The model in this section is not a single DAML file, but a DAML project consisting of several files that depend on each other.\n+\n+DAML Projects\n+-------------\n+\n+DAML is organized in packages and modules. DAML projects are specified using a ``daml.yaml`` file and compile into packages. DAML files within a project become DAML modules. You can start a new project with a skeleton structure using ``daml new project_name`` in the terminal.\n+\n+Each DAML project has a main source file, which is the entry point for the compiler. A common pattern is to have a main file called ``LibraryModules.daml``, which simply lists all the other modules to include.\n+\n+A minimal project would contain just two files: ``daml.yaml`` and ``daml/LibraryModules.daml``. Take a look at the ``daml.yaml`` for this project:\n+\n+.. literalinclude:: daml/daml-intro-7/daml.yaml.template\n+  :language: yaml\n+\n+You can generally set ``name`` and ``version`` freely to describe your project. ``dependencies`` lists package dependencies. ``daml-prim`` should always be included. ``daml-stdlib`` gives access to the DAML standard library.\n+\n+You can compile a DAML project by running ``daml build`` from the project root directory. This creates a ``dar`` package in ``dist/project_name.dar``. A ``dar`` file is DAML's equivalent of a ``JAR`` file in Java. It's the artifact that gets deployed to a ledger to load the contract model.\n+\n+Project Structure\n+-----------------\n+\n+This project contains an asset holding model for transferrable, fungible assets and a separate trade workflow. The templates are structured in three modules ``Intro.Asset``, ``Intro.Asset.Role``, and ``Intro.Asset.Trade``.\n+\n+In addition, there are tests in modules ``Test.Intro.Asset``, ``Test.Intro.Asset.Role``, and ``Test.Intro.Asset.Trade``.\n+\n+All but the last ``.``-separated segment in module names correspond to paths, and the last one to a file name. The folder structure therefore looks like this:\n+\n+.. code-block:: none\n+\n+  .\n+  ├── daml\n+  │   ├── Intro\n+  │   │   ├── Asset\n+  │   │   │   ├── Role.daml\n+  │   │   │   └── Trade.daml\n+  │   │   └── Asset.daml\n+  │   ├── LibraryModules.daml\n+  │   └── Test\n+  │       └── Intro\n+  │           ├── Asset\n+  │           │   ├── Role.daml\n+  │           │   └── Trade.daml\n+  │           └── Asset.daml\n+  └── daml.yaml\n+\n+Each file contains the DAML pragma and module header. For example, ``daml/Intro/Asset/Role.daml``:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- PRAGMA_BEGIN\n+  :end-before: -- PRAGMA_END\n+\n+Modules can be imported in each other using the ``import`` keyword. The ``LibraryModules`` module imports all six modules:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/LibraryModules.daml\n+  :language: daml\n+  :start-after: -- IMPORTS_BEGIN\n+\n+Imports always have to appear just below the module declaration. The ``()`` behind each ``import`` above is optional, and allows one to only import selected names. In this case it suppresses an \"unused import\" warning. ``LibraryModules`` is not actually using any of the imports in ``LibraryModules``. The ``()`` tells the compiler that this is intentional.\n+\n+A more typical import statement is ``import Intro.Asset`` as found in ``Test.Intro.Asset``.\n+\n+Project Overview\n+----------------\n+\n+The project both changes and additions compared to the ``Iou`` model presented in :doc:`6_Parties`:\n+\n+- Assets are fungible in the sense that they have ``Merge`` and ``Split`` choices that allow the ``owner`` to manage their holdings.\n+- Transfer proposals now need the authorities of both ``issuer`` and ``newOwner`` to accept. This makes ``Asset`` safer than ``Iou`` from the issuer's point of view.\n+\n+  With the ``Iou`` model, an ``issuer`` could end up owing cash to anyone as transfers were authorized by just ``owner`` and ``newOwner``. In this project, only parties having an ``AssetHolder`` contract can end up owning assets. This allows the ``issuer`` to determine which parties may own their assets.\n+- The ``Trade`` template adds a swap of two assets to the model.\n+\n+Composed choices and scenarios\n+------------------------------\n+\n+This project showcases how you can put the ``Update`` and ``Scenario`` actions you learnt about in in :doc:`6_Parties` to good use. For example, the ``Merge`` and ``Split`` choices each perform several actions in their consequences.\n+\n+- Two create actions in case of ``Split``\n+- One create and one archive action in case of ``Merge``\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset.daml\n+  :language: daml\n+  :start-after: -- MERGE_SPLIT_BEGIN\n+  :end-before: -- MERGE_SPLIT_END\n+\n+The ``return`` function used in ``Split`` is available in any ``Action`` context. The result of ``return x`` is a no-op containing the value ``x``. It has an alias ``pure``, indicating that it's a pure value, as opposed to a value with side-effects. The ``return`` name makes sense when it's used as the last statement in a ``do`` block as its argument is indeed the \"return\"-value of the ``do`` block in that case.\n+\n+Taking transaction composition a step further, the ``Trade_Settle`` choice on ``Trade`` composes two ``exercise`` actions:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset/Trade.daml\n+  :language: daml\n+  :start-after: -- TRADE_SETTLE_BEGIN\n+  :end-before: -- TRADE_SETTLE_END\n+\n+The resulting transaction, with its two nested levels of consequences, can be seen in the ``test_trade`` scenario in ``Test.Intro.Asset.Trade``:\n+\n+.. code-block:: none\n+\n+  TX #15 1970-01-01T00:00:00Z (Test.Intro.Asset.Trade:77:23)\n+  #15:0\n+  │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+  └─> 'Bob' exercises Trade_Settle on #13:1 (Intro.Asset.Trade:Trade)\n+            with\n+              quoteAssetCid = #10:1; baseApprovalCid = #14:2\n+      children:\n+      #15:1\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+      #15:2\n+      │   known to (since): 'Alice' (#15), 'Bob' (#15)\n+      └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+      #15:3\n+      │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+      └─> 'Alice',\n+          'Bob' exercises TransferApproval_Transfer on #14:2 (Intro.Asset:TransferApproval)\n+                with\n+                  assetCid = #11:1\n+          children:\n+          #15:4\n+          │   known to (since): 'USD_Bank' (#15), 'Bob' (#15), 'Alice' (#15)\n+          └─> fetch #11:1 (Intro.Asset:Asset)\n+\n+          #15:5\n+          │   known to (since): 'Alice' (#15), 'USD_Bank' (#15), 'Bob' (#15)\n+          └─> 'Alice', 'USD_Bank' exercises Archive on #11:1 (Intro.Asset:Asset)\n+\n+          #15:6\n+          │   referenced by #17:0\n+          │   known to (since): 'Bob' (#15), 'USD_Bank' (#15), 'Alice' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'USD_Bank'; owner = 'Bob'; symbol = \"USD\"; quantity = 100.0; observers = []\n+\n+      #15:7\n+      │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+      └─> 'Bob',\n+          'Alice' exercises TransferApproval_Transfer on #12:1 (Intro.Asset:TransferApproval)\n+                  with\n+                    assetCid = #10:1\n+          children:\n+          #15:8\n+          │   known to (since): 'EUR_Bank' (#15), 'Alice' (#15), 'Bob' (#15)\n+          └─> fetch #10:1 (Intro.Asset:Asset)\n+\n+          #15:9\n+          │   known to (since): 'Bob' (#15), 'EUR_Bank' (#15), 'Alice' (#15)\n+          └─> 'Bob', 'EUR_Bank' exercises Archive on #10:1 (Intro.Asset:Asset)\n+\n+          #15:10\n+          │   referenced by #16:0\n+          │   known to (since): 'Alice' (#15), 'EUR_Bank' (#15), 'Bob' (#15)\n+          └─> create Intro.Asset:Asset\n+              with\n+                issuer = 'EUR_Bank'; owner = 'Alice'; symbol = \"EUR\"; quantity = 90.0; observers = []\n+\n+Similar to choices, you can see how the scenarios in this project are built up from each other:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Test/Intro/Asset/Role.daml\n+  :language: daml\n+  :start-after: -- TEST_ISSUANCE_BEGIN\n+  :end-before: -- TEST_ISSUANCE_END\n+\n+In the above, the ``test_issuance`` scenario in ``Test.Intro.Asset.Role`` uses the output of the ``setupRoles`` scenario in the same module.\n+\n+The same line shows a new kind of pattern matching. Rather than writing ``setupResults <- setupRoles`` and then accessing the components of ``setupResults`` using ``_1``, ``_2``, etc., you can give them names. It's equivelent to writing\n+\n+.. code-block:: daml\n+\n+  setupResults <- setupRoles\n+  case setupResults of\n+    (alice, bob, bank, aha, ahb) -> ...\n+\n+Just writing ``(alice, bob, bank, aha, ahb) <- setupRoles`` would also be legal, but ``setupResults`` is used in the return value of ``test_issuance`` so it makes sense to give it a name, too. The notation with ``@`` allows you to give both the whole value as well as its constituents names in one go.\n+\n+.. _execution_model:\n+\n+DAML's execution model\n+----------------------\n+\n+DAML's execution model is fairly easy to understand, but has some important consequences. You can imagine the life of a transaction as follows:\n+\n+1. A party submits a transaction. Remember, a transaction is just a list of actions.\n+2. The transaction is interpreted, meaning the ``Update`` corresponding to each action is evaluated in the context of the ledger to calculate all consequeces, including transitive ones (consequences of consequences, etc.)\n+3. The transaction is *blinded*, or *projected*, meaning the views that different parties have on the transaction are calculated.\n+4. The blinded views are distributed to the parties.\n+5. The transaction is *validated* and *committed* based on the blinded views and a consensus protocol depending on the underlying infrastructure.\n+\n+The first important consequence of the above is that all transactions are committed atomically. Either a transaction is committed as a whole and for all participants, or it fails.\n+\n+That's important in the context of the ``Trade_Settle`` choice shown above. The choice transfers a ``baseAsset`` one way and a ``quoteAsset`` the other way. Thanks to transaction atomicity, there is no chance that either party is left out of pocket.\n+\n+The second consequence, due to 2., is that the submitter of a transaction knows all consequences of their submitted transaction -- there are no surprises in DAML. However, it also means that the submitter must have all the information to interpret the transaction.\n+\n+That's also imprtant in the context of ``Trade``. In order to allow Bob to interpret a transaction that transfers Alice's cash to Bob, Bob needs to know both about Alice's ``Asset`` contract, as well as about some way for ``Alice`` to accept a transfer -- remember, accepting a transfer needs the authority of ``issuer`` in this example.\n+\n+Observers\n+---------\n+\n+*Observers* are DAML's mechanism to disclose contracts to other parties. They are declared just like signatories, but using the ``observer`` keyword, as shown in the ``Asset`` template:\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Intro/Asset.daml\n+  :language: daml\n+  :start-after: -- ASSET_BEGIN\n+  :end-before: -- ASSET_END\n+\n+The ``Asset`` template also gives the ``owner`` a choice to set the observers, and you can see how Alice uses it to show her ``Asset`` to Bob just before proposeing the trade. You can try out what happens if she didn't do that by removing that transaction.\n+\n+.. literalinclude:: daml/daml-intro-7/daml/Test/Intro/Asset/Trade.daml\n+  :language: daml\n+  :start-after: -- SET_OBSERVER_BEGIN\n+  :end-before: -- SET_OBSERVER_END\n+\n+Observers have guarantees in DAML. In particular, they are guaranteed to see actions that create and archive the contract on which they are an observer.\n+\n+Since observers are calculated from the arguments of the contract, they always know about each other. That's why, rather than adding Bob as an observer on Alice's ``AssetHolder`` contract, and using that to authorize the transfer in ``Trade_Settle``, Alice creates a one-time authorization in the form of a ``TransferAuthorization``. If Alice had lots of couterparties, she would otherwise end up leaking them to each other.\n+\n+Controllers declared via the ``controller cs can`` syntax are automatically made observers. Controllers declared in the ``choice`` syntax are not, as they can only be calculated at the point in time when the choice arguments are known.\n+\n+Privacy\n+-------\n+\n+DAML's privacy model is based on two principles:\n+\n+1. Parties see those actions that they have a stake in.\n+2. Every party that sees an action sees its (transitive) consequences.\n+\n+Item 2. is necessary to ensure that every party can independently verify the validity of every transaction they see.\n+\n+A party has a stake in an action if\n+\n+- they are a required authorizer of it\n+- they are a signatory of on the contract on which the action is performed\n+- they are an observer on the contract, and the action creates or archives it\n+\n+What does that mean for the ``exercise tradeCid Trade_Settle`` action from ``test_trade``?\n+\n+Alice is the signatory of ``tradeCid`` and Bob a required authorizer of the ``Trade_Settled`` action, so both of them see it. According to rule 2. above, that means they get to see everything in the transaction.\n+\n+The consequences contain, next to some ``fetch`` actions, two ``exercise`` actions of the choice ``TransferApproval_Transfer``.\n+\n+Each of the two involved ``TransferApproval`` contracts is signed by a different ``issuer``, which see the action on \"their\" contract. So the EUR_Bank sees the ``TransferApproval_Transfer`` action for the EUR ``Asset`` and the USD_Bank sees the ``TransferApproval_Transfer`` action for the USD ``Asset``.\n+\n+Some DAML ledgers, like the scenario runner and the Sandbox work on the principle of \"data minimization\", meaning nothing more than the above information is distributed. Ie the \"projecion\" of the overall transaction that gets distributed to EUR_Bank in step 4 of :ref:`execution_model` would consist only of the ``TransferApproval_Transfer`` and its consequences."
  }
]