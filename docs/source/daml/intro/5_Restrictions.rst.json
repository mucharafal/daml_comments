[
  {
    "id" : "654708cd-17f8-490b-84b1-84dc898a357d",
    "prId" : 7264,
    "comments" : [
      {
        "id" : "cf9e052c-fc87-4174-97cd-fbc3b1686a90",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\nExpressions like ``getTime``, ``allocateParty party``, ``passTime time``, ``submit party commands``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\r\n```\r\nAssuming that this refers to the `Script` `submit`.",
        "createdAt" : "2020-09-01T08:22:25Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "edfcefed5831fd27018f4cb3fdeb4a98f8ea266a",
    "line" : null,
    "diffHunk" : "@@ -135,29 +135,46 @@ Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`\n Actions and impurity\n ~~~~~~~~~~~~~~~~~~~~~\n \n-Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\".\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Script`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\".\n \n You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils. When cooking the recipe you have an effect -- you change the state of the kitchen -- and a return value -- the thing you leave the kitchen with.\n \n - An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, has the effect of changing the ledger, and returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n-- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, has the effect of changing the ledger in ways analogous to those available via the API, and returns a value of type ``a``\".\n+- A ``Script a`` is \"a recipe for a test, which, when performed against a ledger, has the effect of changing the ledger in ways analogous to those available via the API, and returns a value of type ``a``\".\n \n-Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+Expressions like ``getTime``, ``allocateParty party``, ``passTime time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:"
  },
  {
    "id" : "4ab41ac1-b0e2-49ff-bf73-705a1b338910",
    "prId" : 6839,
    "comments" : [
      {
        "id" : "bd3d3368-1f8d-48a5-b1a2-35ca9c3abcb9",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "@axos88-da I added this specific hint at the highlighted section as well.",
        "createdAt" : "2020-07-23T09:18:40Z",
        "updatedAt" : "2020-09-02T13:20:34Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f28a535621854053790b029ea20f965e8902ee4f",
    "line" : 15,
    "diffHunk" : "@@ -33,6 +37,9 @@ The ``ensure`` keyword takes a single expression of type ``Bool``. If you want t\n   :start-after: ensure\n   :end-before: -- RESTRICTED_IOU_END\n \n+.. hint::"
  },
  {
    "id" : "47d88aea-aa2b-4923-862d-d67e72805911",
    "prId" : 6705,
    "comments" : [
      {
        "id" : "3f0ce436-92e4-4bee-9b1a-e23066af347e",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "We have \"LET\" and \"LT\", let's pick one and change it throughout the docs (also gRPC reference, if we go with \"LT\").\r\n\r\nAlso:\r\n1. I'd replace \"participant\" by \"submitting participant\" or \"submitter's participant node\" (there can be many).\r\n2. I'd say \"set by the ledger\", as the ledger doesn't have to have a consensus protocol",
        "createdAt" : "2020-07-14T09:43:51Z",
        "updatedAt" : "2020-07-17T14:41:06Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "491fff55-c5cd-4366-b37e-7a9792cd16c9",
        "parentId" : "3f0ce436-92e4-4bee-9b1a-e23066af347e",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Changed \"LET\" to \"LT\".",
        "createdAt" : "2020-07-16T14:26:03Z",
        "updatedAt" : "2020-07-17T14:41:06Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "92a1f771c9356f590c2119e8a66c419baaba461b",
    "line" : null,
    "diffHunk" : "@@ -78,16 +78,18 @@ There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choi\n Time on DAML ledgers\n --------------------\n \n-Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol.\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the participant, the record time is set by the consensus protocol."
  },
  {
    "id" : "e16e3747-4008-402d-8e11-ab63955b6d76",
    "prId" : 6705,
    "comments" : [
      {
        "id" : "8e35f666-6c8d-4655-8e74-e090aaf5a34a",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "What happens between 17:55:55 and 17:59:56?\r\n\r\nAlso, the difference given in the example is `<= 10 seconds`, not `< 10 seconds`",
        "createdAt" : "2020-07-14T09:48:54Z",
        "updatedAt" : "2020-07-17T14:41:06Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "54951e66-a4ec-4e0f-b655-4ae22dd4c09b",
        "parentId" : "8e35f666-6c8d-4655-8e74-e090aaf5a34a",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Rewritten to fix the issues.",
        "createdAt" : "2020-07-16T14:26:22Z",
        "updatedAt" : "2020-07-17T14:41:06Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "92a1f771c9356f590c2119e8a66c419baaba461b",
    "line" : null,
    "diffHunk" : "@@ -78,16 +78,18 @@ There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choi\n Time on DAML ledgers\n --------------------\n \n-Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol.\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the participant, the record time is set by the consensus protocol.\n \n-Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The participant has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n \n ``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18.\n \n-Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid transaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected.\n+Consider the following example: Suppose that the ledger had a skew of 10 seconds. At 17:55:55, Alice submits a transaction to redeem an Iou. The transaction is assigned a LET of 17:59:56, but then takes 10 seconds to commit and is recorded on the ledger at 18:00:06. Even though it was committed after business hours, it would be a valid transaction and be committed successfully as ``getTime`` will return 17:59:56 so ``hrs == 17``. Since the RT is 18:00:06, ``LET - RT < 10 seconds`` and the transaction won't be rejected."
  },
  {
    "id" : "c2c4e1ae-33a4-485a-9670-8ccae90b415b",
    "prId" : 3509,
    "comments" : [
      {
        "id" : "1a90870f-6eb1-45e4-85f1-07b871699847",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "I think this one made more sense before; \"changes hands\" is the phrase (meaning that party A gave something to party B).",
        "createdAt" : "2019-11-18T15:11:42Z",
        "updatedAt" : "2019-11-20T09:42:42Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c44e92ac-9f7d-4d93-b95a-c2506cbed6a1",
        "parentId" : "1a90870f-6eb1-45e4-85f1-07b871699847",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You're right -- changed back.",
        "createdAt" : "2019-11-18T16:15:57Z",
        "updatedAt" : "2019-11-20T09:42:42Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "04a187679d9dc48783dc4667ae0234f9ac48f725",
    "line" : null,
    "diffHunk" : "@@ -59,7 +59,7 @@ For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``o\n   :start-after: -- TRANSFER_TEST_BEGIN\n   :end-before: -- TRANSFER_TEST_END\n \n-Similarly, you can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on weekdays. The choice doesn't do anything other than archiving the ``SimpleIou``. (This assumes that actual cash changes hands off-ledger.)\n+Similarly, you can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on weekdays. The choice doesn't do anything other than archiving the ``SimpleIou``. (This assumes that actual cash changes are handled off-ledger.)"
  },
  {
    "id" : "183fced5-deba-4652-882e-57b354b0f3a5",
    "prId" : 2763,
    "comments" : [
      {
        "id" : "20bb5667-29aa-49ef-bce0-4b6afe8900b1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nAbove, you've learnt about ``assertMsg`` and ``abort``, which represent (potentially) failing actions. Actions only have an effect when they are performed, so the following scenario succeeds or fails depending on the value of ``abortScenario``:\r\n```\r\nDo we use _performed_ for actions or _executed_?",
        "createdAt" : "2019-09-05T10:52:30Z",
        "updatedAt" : "2019-09-05T11:29:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8595f5ecfdc29822bde1ecb774508262169c4f5e",
    "line" : null,
    "diffHunk" : "@@ -217,6 +217,41 @@ More generally, if you want to learn more about Actions (aka Monads), we recomme\n - `Programming in Haskell (Graham Hutton) <http://www.cs.nott.ac.uk/~pszgmh/pih.html>`__\n - `Real World Haskell (Bryan O'Sullivan, Don Stewart, John Goerzen) <http://book.realworldhaskell.org/>`__\n \n+Errors\n+------\n+\n+Above, you've learnt about ``assertMsg`` and ``abort``, which represent (potentially) failing actions. Actions only have an effect only if they are performed, so the following scenario succeeds or fails depending on the value of ``abortScenario``:"
  },
  {
    "id" : "b323b3b3-8fed-49ae-afb6-4a68a985fbcd",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "2c70a8cd-ad8c-421d-b9cd-e70c95f54f65",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nYou will often want to constrain the data stored or the allowed data transformations in your contract models. In this section, you will learn about the two main mechanisms provided in DAML:\r\n```",
        "createdAt" : "2019-06-17T13:43:44Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:"
  },
  {
    "id" : "569f7d6b-54b8-4e46-b992-c70c8187453b",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "6b6bc832-0df8-425b-aeda-daa5f15e532d",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Not an ordered list\r\n```suggestion\r\n- The ``ensure`` keyword.\r\n```",
        "createdAt" : "2019-06-17T13:43:59Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword."
  },
  {
    "id" : "37d4d035-ca03-4b74-819a-51c78ef4b896",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "888deef2-24a0-4abd-ae68-866dced128c2",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n- The ``assert``, ``abort`` and ``error`` keywords.\r\n```",
        "createdAt" : "2019-06-17T13:44:07Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords."
  },
  {
    "id" : "b0c78811-d77a-4435-834f-c8eab8d5bcdf",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "b845a439-ed2a-4da7-b581-15da239f95cd",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThe first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template.\r\n\r\nSuppose, for example, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. You can enforce this using the ``ensure`` keyword:\r\n```",
        "createdAt" : "2019-06-17T13:44:39Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword."
  },
  {
    "id" : "c0deb7a6-5453-4a9e-99e0-ce1b396998a3",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "7c961ea6-eac3-46e9-859a-ef642a381165",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThe ``ensure`` keyword takes a single expression of type ``Bool``. If you want to add more restrictions, use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters:\r\n```",
        "createdAt" : "2019-06-17T13:45:06Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters."
  },
  {
    "id" : "2fcf10fe-05c0-4769-8f9b-66c9f1345a35",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "554d8a0f-8cf6-471c-818c-504bab7fbc72",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nAssertions and errors\r\n```",
        "createdAt" : "2019-06-17T13:45:46Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors"
  },
  {
    "id" : "3c430ba8-703a-44b9-a4e3-3bd500490830",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "5c59e883-bf0f-44d7-afb4-93645bb3d65f",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nA second common kind of restriction is one on data transformations.\r\n\r\nFor example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. \r\n\r\n``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\r\n```",
        "createdAt" : "2019-06-17T13:46:11Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:"
  },
  {
    "id" : "b9192d8b-f9d5-4b18-b1be-89a52b1be4d1",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "23380386-665e-4e8d-a4d1-c98744c82c2d",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nSimilarly, you can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on weekdays. The choice doesn't do anything other than archiving the ``SimpleIou``. (This assumes that actual cash changes hands off-ledger.)\r\n```",
        "createdAt" : "2019-06-17T13:47:11Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger."
  },
  {
    "id" : "69a1781f-afd2-4538-83b1-722a7af826f8",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "6ab4fdb1-fa0d-4345-903b-51e4b0e8c384",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThere are quite a few new time-related functions from the ``DA.Time`` and ``DA.Date`` libraries here. Their names should be reasonably descriptive so how they work won't be covered here, but given that DAML assumes it is run in a distributed setting, we will still discuss time in DAML.\r\n```",
        "createdAt" : "2019-06-17T13:47:52Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML."
  },
  {
    "id" : "fef4772c-ff38-4454-ab02-30531a939007",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "45dc3c7b-fc1c-45d9-91e3-e829afd58c88",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nEach transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol.\r\n\r\nEach DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\r\n```",
        "createdAt" : "2019-06-17T13:48:15Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected."
  },
  {
    "id" : "04dc1cfc-17b0-45d9-8dd7-ec277eb2b446",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "aa9f1ec6-4ab3-4c2e-934c-1ff680f7a454",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18.\r\n\r\nSuppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid transaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected.\r\n\r\nTime therefore has to be considered slightly fuzzy in DAML, with the fuzziness depending on the skew parameter.\r\n```",
        "createdAt" : "2019-06-17T13:49:00Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter."
  },
  {
    "id" : "6d8af3ff-2f5d-4947-9ca0-16285657c260",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "4416955d-81d3-4fa5-80ad-3d5369b41453",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nYou have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. You can construct ``Actions`` conveniently using ``do`` notation.\r\n\r\nUnderstanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test them, so this section will explain them in some detail.\r\n```",
        "createdAt" : "2019-06-17T13:50:18Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test."
  },
  {
    "id" : "009ba5ed-ac73-447f-8a95-15467a701d06",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "23759a45-8f35-402e-9e8c-e449e4a2bca0",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nPure expressions compared to Actions\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\nExpressions in DAML are pure in the sense that they have no side-effects: they neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper.\r\n\r\nHowever, the expressions you've seen that used the ``<-`` notation are not like that. For example, take ``getTime``, which is an ``Action``. Here's the example we used earlier:\r\n```",
        "createdAt" : "2019-06-17T13:51:48Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that."
  },
  {
    "id" : "4fb60c2e-ea52-4ce7-bad3-7d119b7ddf3b",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "68c960df-bb04-445d-99fc-10c44122b33b",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nActions and impurity\r\n~~~~~~~~~~~~~~~~~~~~~\r\n\r\nActions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\".\r\n\r\nYou can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\r\n```",
        "createdAt" : "2019-06-17T13:53:32Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dccaac23-ad70-4f4a-88d4-4ce6e5e2a486",
        "parentId" : "68c960df-bb04-445d-99fc-10c44122b33b",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Not sure if this is the right heading, but I think we need something to make it easier to follow the thread of this section.",
        "createdAt" : "2019-06-17T13:54:48Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils."
  },
  {
    "id" : "cf6c5c8c-cea3-4cf4-aa7e-f8c34aa1f0de",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "bf831919-ba5f-4fda-a405-22fce3fcc1e5",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "This feels like it could do with a heading as well. \"how transactions and scenarios relate to actions\" or something",
        "createdAt" : "2019-06-17T13:55:40Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dd2ac71d-a0d4-47e7-af88-4d39a42c81ae",
        "parentId" : "bf831919-ba5f-4fda-a405-22fce3fcc1e5",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Or perhaps something to do with do blocks...",
        "createdAt" : "2019-06-17T13:56:20Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : 155,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:"
  },
  {
    "id" : "a05a569d-8162-4398-9079-77a3038f3f56",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "87954a8f-69b2-4feb-b672-49e32fd96bd2",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n- A transaction is a list of actions. So a transaction followed by another transaction is again a transaction.\r\n```",
        "createdAt" : "2019-06-17T13:55:54Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction."
  },
  {
    "id" : "c3f5bc22-20c3-4f0d-a24e-f453dcc8920b",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "3d0067c1-4679-43b2-a6aa-7b1b2320616b",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc). So a scenario followed by another scenario is again a scenario.\r\n```",
        "createdAt" : "2019-06-17T13:56:06Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario."
  },
  {
    "id" : "8544013b-500b-47ae-8a3d-967800b8e739",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "6844c1db-3a41-4e9b-8fe7-e46ee9f82e2b",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "> Since ``do`` blocks always return the value of their last action\r\n\r\nThis feels like a big point to me - is it worth emphasising a little more?",
        "createdAt" : "2019-06-17T13:57:09Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : 172,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario.\n+\n+This is where ``do`` blocks come in. ``do`` blocks allow you to combine small actions in to bigger actions, using the results of earlier actions in later ones.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- DO_DEMO_BEGIN\n+  :end-before: -- DO_DEMO_END\n+\n+Above, we see ``do`` blocks in action for both ``Scenario`` and ``Update``.\n+\n+You may already have noticed the use of ``return`` in the redeem choice. ``return x`` is a no-op action which returns value ``x`` so ``return 42 : Update Int``. Since ``do`` blocks always return the value of their last action, ``sub_scenario2 : Scenario Int``."
  },
  {
    "id" : "c15cc2b7-cce1-48b5-9780-7d2cf8b7526c",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "1fc93fa4-5c3d-4cb9-8a60-0cd1c5887ce0",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nFailing actions\r\n```",
        "createdAt" : "2019-06-17T13:57:15Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario.\n+\n+This is where ``do`` blocks come in. ``do`` blocks allow you to combine small actions in to bigger actions, using the results of earlier actions in later ones.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- DO_DEMO_BEGIN\n+  :end-before: -- DO_DEMO_END\n+\n+Above, we see ``do`` blocks in action for both ``Scenario`` and ``Update``.\n+\n+You may already have noticed the use of ``return`` in the redeem choice. ``return x`` is a no-op action which returns value ``x`` so ``return 42 : Update Int``. Since ``do`` blocks always return the value of their last action, ``sub_scenario2 : Scenario Int``.\n+\n+Failing Actions"
  },
  {
    "id" : "9109d50b-3eb6-4d4f-99e5-2b274166607d",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "075eeb4e-6490-441e-85a6-a6454f0aea1f",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nEach has a special action ``abort txt`` that represents failure, and that takes on type ``Update ()`` or ``Scenario ()`` depending on context .\r\n\r\nTransactions and scenarios succeed or fail *atomically* as a whole. So an occurrence of an ``abort`` action will always fail the **entire** evaluation of the current ``Scenario`` or ``Update``.\r\n```",
        "createdAt" : "2019-06-17T14:00:13Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario.\n+\n+This is where ``do`` blocks come in. ``do`` blocks allow you to combine small actions in to bigger actions, using the results of earlier actions in later ones.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- DO_DEMO_BEGIN\n+  :end-before: -- DO_DEMO_END\n+\n+Above, we see ``do`` blocks in action for both ``Scenario`` and ``Update``.\n+\n+You may already have noticed the use of ``return`` in the redeem choice. ``return x`` is a no-op action which returns value ``x`` so ``return 42 : Update Int``. Since ``do`` blocks always return the value of their last action, ``sub_scenario2 : Scenario Int``.\n+\n+Failing Actions\n+---------------\n+\n+Not only are ``Update`` and ``Scenario`` examples of ``Action``, they are both examples of actions that can fail, e.g. because a transaction is illegal or the party retrieved via ``getParty`` doesn't exist on the ledger.\n+\n+Each has a special action ``abort txt`` which takes on type ``Update ()`` or ``Scenario ()`` depending on context and represents failure. Transactions and scenarios succeed or fail *atomically* as a whole so an occurrence of an ``abort`` action will always fail the entire evaluation of the current ``Scenario`` or ``Update``."
  },
  {
    "id" : "35c764ad-f594-4ab5-a7f5-9252a15810a7",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "6ecdfeed-795d-4d9d-90aa-f2821eae4221",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThe last expression in the ``do`` block of the ``Redeem`` choice is a pattern matching expression on ``dow``. It has type ``Update ()`` and is either an ``abort`` or ``return`` depending on the day of week. So during the week, it's a no-op and on weekends, it's the special failure action. Thanks to the atomicity of transactions, no transaction can ever make use of the ``Redeem`` choice on weekends, because it fails the entire transaction.\r\n```",
        "createdAt" : "2019-06-17T14:01:22Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario.\n+\n+This is where ``do`` blocks come in. ``do`` blocks allow you to combine small actions in to bigger actions, using the results of earlier actions in later ones.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- DO_DEMO_BEGIN\n+  :end-before: -- DO_DEMO_END\n+\n+Above, we see ``do`` blocks in action for both ``Scenario`` and ``Update``.\n+\n+You may already have noticed the use of ``return`` in the redeem choice. ``return x`` is a no-op action which returns value ``x`` so ``return 42 : Update Int``. Since ``do`` blocks always return the value of their last action, ``sub_scenario2 : Scenario Int``.\n+\n+Failing Actions\n+---------------\n+\n+Not only are ``Update`` and ``Scenario`` examples of ``Action``, they are both examples of actions that can fail, e.g. because a transaction is illegal or the party retrieved via ``getParty`` doesn't exist on the ledger.\n+\n+Each has a special action ``abort txt`` which takes on type ``Update ()`` or ``Scenario ()`` depending on context and represents failure. Transactions and scenarios succeed or fail *atomically* as a whole so an occurrence of an ``abort`` action will always fail the entire evaluation of the current ``Scenario`` or ``Update``.\n+\n+The last expression in the ``do`` block of the ``Redeem`` choice is a pattern matching expression on ``dow``. It has type ``Update ()`` and is either an ``abort`` or ``return`` depending on the day of week. So during the week, it's a no-op and on weekends, it's the special failure action. Thanks to the atomicity of transactions, no transaction can ever make use of the ``Redeem`` choice on weekends."
  },
  {
    "id" : "e195a9a0-072d-445f-92d6-ab7dbdabc7b1",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "19cd5a12-d99a-4786-9cad-54ddfdc71e2f",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n``Coin`` and ``play`` are deliberately left obscure in the above. All you have is an action ``getCoin`` to get your hands on a ``Coin`` in a ``Scenario`` context and an action ``flipCoin`` which represents the simplest possible game: a single coin flip resulting in a  ``Face``.\r\n\r\nYou can't play any ``CoinGame`` game on pen and paper as you don't have a coin, but you can write down a script or recipe for a game:\r\n```",
        "createdAt" : "2019-06-17T14:02:09Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario.\n+\n+This is where ``do`` blocks come in. ``do`` blocks allow you to combine small actions in to bigger actions, using the results of earlier actions in later ones.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- DO_DEMO_BEGIN\n+  :end-before: -- DO_DEMO_END\n+\n+Above, we see ``do`` blocks in action for both ``Scenario`` and ``Update``.\n+\n+You may already have noticed the use of ``return`` in the redeem choice. ``return x`` is a no-op action which returns value ``x`` so ``return 42 : Update Int``. Since ``do`` blocks always return the value of their last action, ``sub_scenario2 : Scenario Int``.\n+\n+Failing Actions\n+---------------\n+\n+Not only are ``Update`` and ``Scenario`` examples of ``Action``, they are both examples of actions that can fail, e.g. because a transaction is illegal or the party retrieved via ``getParty`` doesn't exist on the ledger.\n+\n+Each has a special action ``abort txt`` which takes on type ``Update ()`` or ``Scenario ()`` depending on context and represents failure. Transactions and scenarios succeed or fail *atomically* as a whole so an occurrence of an ``abort`` action will always fail the entire evaluation of the current ``Scenario`` or ``Update``.\n+\n+The last expression in the ``do`` block of the ``Redeem`` choice is a pattern matching expression on ``dow``. It has type ``Update ()`` and is either an ``abort`` or ``return`` depending on the day of week. So during the week, it's a no-op and on weekends, it's the special failure action. Thanks to the atomicity of transactions, no transaction can ever make use of the ``Redeem`` choice on weekends.\n+\n+A sample Action\n+---------------\n+\n+If the above didn't make complete sense, here's another example. ``CoinGame a`` is an ``Action a`` in which a ``Coin`` is flipped and based on the ``Heads`` and ``Tails`` results, a value of type ``a`` is calulated.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A ``CoinGame a`` exposes a function ``play`` which takes a ``Coin`` and returns a new ``Coin`` and a result ``a``. More on the ``->`` syntax for functions later.\n+\n+``Coin`` and ``play`` are deliberately left obscure in the above. All you have is an action ``getCoin`` to get your hands on a ``Coin`` in a ``Scenario`` context and an action ``flipCoin`` which represents the simplest possible game: A single coin flip resulting in a  ``Face``. You can't play any ``CoinGame`` game on pen and paper as you don't have a coin, but you can write down a script or recipe for a game:"
  },
  {
    "id" : "796a800c-1872-4bd1-849d-9bb06ed7ce9a",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "a83ee6b5-1461-4891-9e6b-bbb23e07f51e",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "This isn't super useful without linking to a specific resource, I'd say - can we recommend eg Learn you a Haskell, even linking to the relevant chapter?",
        "createdAt" : "2019-06-17T14:03:46Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a4253780-89f4-47e3-abae-46a78efb2a41",
        "parentId" : "a83ee6b5-1461-4891-9e6b-bbb23e07f51e",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Will try to crowdsource some suggestions. I like Learn you a Haskell, but apparently it's a love it/hate it sort of book.",
        "createdAt" : "2019-06-18T07:31:06Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario.\n+\n+This is where ``do`` blocks come in. ``do`` blocks allow you to combine small actions in to bigger actions, using the results of earlier actions in later ones.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- DO_DEMO_BEGIN\n+  :end-before: -- DO_DEMO_END\n+\n+Above, we see ``do`` blocks in action for both ``Scenario`` and ``Update``.\n+\n+You may already have noticed the use of ``return`` in the redeem choice. ``return x`` is a no-op action which returns value ``x`` so ``return 42 : Update Int``. Since ``do`` blocks always return the value of their last action, ``sub_scenario2 : Scenario Int``.\n+\n+Failing Actions\n+---------------\n+\n+Not only are ``Update`` and ``Scenario`` examples of ``Action``, they are both examples of actions that can fail, e.g. because a transaction is illegal or the party retrieved via ``getParty`` doesn't exist on the ledger.\n+\n+Each has a special action ``abort txt`` which takes on type ``Update ()`` or ``Scenario ()`` depending on context and represents failure. Transactions and scenarios succeed or fail *atomically* as a whole so an occurrence of an ``abort`` action will always fail the entire evaluation of the current ``Scenario`` or ``Update``.\n+\n+The last expression in the ``do`` block of the ``Redeem`` choice is a pattern matching expression on ``dow``. It has type ``Update ()`` and is either an ``abort`` or ``return`` depending on the day of week. So during the week, it's a no-op and on weekends, it's the special failure action. Thanks to the atomicity of transactions, no transaction can ever make use of the ``Redeem`` choice on weekends.\n+\n+A sample Action\n+---------------\n+\n+If the above didn't make complete sense, here's another example. ``CoinGame a`` is an ``Action a`` in which a ``Coin`` is flipped and based on the ``Heads`` and ``Tails`` results, a value of type ``a`` is calulated.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A ``CoinGame a`` exposes a function ``play`` which takes a ``Coin`` and returns a new ``Coin`` and a result ``a``. More on the ``->`` syntax for functions later.\n+\n+``Coin`` and ``play`` are deliberately left obscure in the above. All you have is an action ``getCoin`` to get your hands on a ``Coin`` in a ``Scenario`` context and an action ``flipCoin`` which represents the simplest possible game: A single coin flip resulting in a  ``Face``. You can't play any ``CoinGame`` game on pen and paper as you don't have a coin, but you can write down a script or recipe for a game:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- COIN_SCENARIO_BEGIN\n+  :end-before: -- COIN_SCENARIO_END\n+\n+The ``game`` expression is a ``CoinGame`` in which a coin is flipped three times. If all three tosses return ``Heads``, the result is ``\"Win\"``, or else ``\"Loss\"``.\n+\n+In a ``Scenario`` context you can get a ``Coin``, which is actually a pseudo-random number generator based on LET, and play the game.\n+\n+*Somehow* the ``Coin`` is threaded through the various actions. If you want to look through the looking glass and understand in-depth what's going on, you can look at the source file to see how the ``CoinGame`` action is implemented, though be warned that the implementation uses a lot of DAML features we haven't introduced yet in this introduction.\n+\n+More generally, if you want to learn more about Actions (aka Monads), we recommend a general course on functional programming, and Haskell in particular."
  },
  {
    "id" : "10b439a1-7d8c-4466-9cf2-2ab333196905",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "c682bee1-7e58-4873-ae23-6f44ca3c0d96",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nNext up\r\n```",
        "createdAt" : "2019-06-17T14:03:55Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,183 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+5 Adding constraints to a contract\n+==================================\n+\n+Oftentimes, contract models will have constraints on the data stored, or the allowed data transformations. In this section, you will learn about the two main mechanisms provided in DAML:\n+\n+1. The ``ensure`` keyword.\n+2. The ``assert``, ``abort`` and ``error`` keywords.\n+\n+To make sense of the latter, you'll also learn more about the ``Update`` and ``Scenario`` types and ``do`` blocks, which will be good preparation for :doc:`7_Composing`, where you will use ``do`` blocks to compose choices into complex transactions.\n+\n+Lastly, you will learn about time on the ledger and in scenarios.\n+\n+Template preconditions\n+----------------------\n+\n+The first kind of restriction you may want to put on the contract model are called *template pre-conditions*. These are simply restrictions on the data that can be stored on a contract from that template. Suppose, for examples, that the ``SimpleIou`` contract from :ref:`simple_iou` should only be able to store positive amounts. This can be enforced using the ``ensure`` keyword.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTED_IOU_BEGIN\n+  :end-before: &&\n+\n+The ``ensure`` keyword takes a single expression of type ``Bool``. If you wanted to add more restrictions, you can use logical operators ``&&``, ``||`` and ``not`` to build up expressions. The below shows the additional restriction that currencies are three capital letters.\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: ensure\n+  :end-before: -- RESTRICTED_IOU_END\n+\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- RESTRICTIONS_TEST_BEGIN\n+  :end-before: -- RESTRICTIONS_TEST_END\n+\n+\n+Assertions and Errors\n+---------------------\n+\n+A second common kind of restriction is one on data transformations. For example, the simple Iou in :ref:`simple_iou` allowed the no-op where the ``owner`` transfers to themselves. You can prevent that using an ``assert`` statement, which you have already encountered in the context of scenarios. ``assert`` does not return an informative error so often it's better to use the function ``assertMsg``, which takes a custom error message:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_CHOICE_BEGIN\n+  :end-before: -- TRANSFER_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- TRANSFER_TEST_BEGIN\n+  :end-before: -- TRANSFER_TEST_END\n+\n+In a similar vein, yu can write a ``Redeem`` choice, which allows the ``owner`` to redeem an ``Iou`` during business hours on week days. The choice doesn't do anything other than archiving the ``SimpleIou``. The assumption here is that actual cash changes hands off-ledger.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_CHOICE_BEGIN\n+  :end-before: -- REDEEM_CHOICE_END\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- REDEEM_TEST_BEGIN\n+  :end-before: -- REDEEM_TEST_END\n+\n+There are quite a few new time-related functions from the `DA.Time` and `DA.Date` libraries here. Their names should be reasonably descriptive so they won't be covered here, but given that you have to assume that DAML is run in a distributed setting, we will still discuss time in DAML.\n+\n+There's also quite a lot going on inside the ``do`` block of the ``Redeem`` choice, with several uses of the ``<-`` operator. ``do`` blocks and ``<-`` deserve a proper explanation at this point.\n+\n+Time on DAML ledgers\n+--------------------\n+\n+Each transaction on a DAML ledger has two timestamps called the *ledger effective time (LET)* and the *record time (RT)*. The ledger effective time is set by the submitter of a transaction, the record time is set by the consensus protocol. Each DAML ledger has a policy on the allowed difference between LET and RT called the *skew*. The submitter has to take a good guess at what the record time will be. If it's too far off, the transaction will be rejected.\n+\n+``getTime`` is an action that gets the LET from the ledger. In the above example, that time is taken apart into day of week and hour of day using standard library functions from ``DA.Date`` and ``DA.Time``. The hour of the day is checked to be in the range from 8 to 18. Suppose now that the ledger had a skew of 10 seconds, but a submission took less than 4 seconds to commit. At 18:00:05, Alice could submit a transaction with a LET of 17:59:59 to redeem an Iou. It would be a valid trasnaction and be committed successfully as ``getTime`` will return 17:59:59 so ``hrs == 17``. Since RT will be before 18:00:09, ``LET - RT < 10 seconds`` and the transaction won't be rejected. Time therefore has to be considered slightly fuzzy in DAML, with the fuzzyness depending on the skew parameter.\n+\n+Time in scenarios\n+~~~~~~~~~~~~~~~~~\n+\n+In scenarios, record and ledger effective time are always equal. You can set them using the following functions:\n+\n+- ``passToDate``, which takes a date sets the time to midnight (UTC) of that date and ``pass``\n+- ``pass``, which takes a ``Reltime`` (a relative time) and moves the ledger by that much\n+\n+Time on ledgers\n+~~~~~~~~~~~~~~~~~\n+\n+On a distributed DAML ledger, there are no guarantees that ledger effective time or relative time are strictly increasing. The only guarantee is that ledger effective time is increasing with causality. That is, if a transaction ``TX2`` depends on a transaction ``TX1``, then the ledger enforces that the LET of ``TX2`` is greater than or equal to that of ``TX1``:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- CAUSALITY_TEST_BEGIN\n+  :end-before: -- CAUSALITY_TEST_END\n+\n+Actions and ``do`` blocks\n+-------------------------\n+\n+You have come across ``do`` blocks and ``<-`` notations in two contexts by now: ``Scenario`` and ``Update``. Both of these are examples of an ``Action``, also called a *Monad* in functional programming. ``Actions`` can be constructed in a convenient way using ``do`` notation. Understanding ``Actions`` and ``do`` blocks is therefore crucial to being able to construct correct contract models and test.\n+\n+Expressions in DAML are pure in the sense that they have no side-effects. They neither read nor modify any external state. If you know the value of all variables in scope and write an expression, you can work out the value of that expression on pen and paper. The expressions you've seen that used the ``<-`` notation are not like that.\n+\n+``getTime`` is a good example of an ``Action``. Here's the example we used earlier\n+\n+.. code-block:: daml\n+\n+   now <- getTime\n+\n+You cannot work out the value of ``now`` based on any variable in scope. To put it another way, there is no expression ``expr`` that you could put on the right hand side of ``now = expr``. To get the ledger effective time, you must be in the context of a submitted transaction, and then look at that context.\n+\n+Similarly, you've come across ``fetch``. If you have ``cid : ContractId Account`` in scope and you come across the expression ``fetch cid``, you can't evaluate that to an ``Account`` so you can't write ``account = fetch cid``. To do so, you'd have to have a ledger you can look that contract id up on.\n+\n+Actions are a way to handle such \"impure\" expressions. ``Action a`` is a type class with a single parameter ``a``, and ``Update`` and ``Scenario`` are instances of ``Action``. A value of such a type ``m a`` where ``m`` is an instance of ``Action`` can be interpreted as \"a recipe for an action of type ``m``, which, when executed, returns a value ``a``\". You can always write a recipe using just pen and paper, but you can't cook it up unless you are in the context of a kitchen with the right ingredients and utensils.\n+\n+- An ``Update a`` is \"a recipe to update a DAML ledger, which, when committed, returns a value of type ``a``\". An update to a DAML ledger is a transaction so equivalently, an ``Update a`` is \"a recipe to construct a transaction, which, when executed in the context of a ledger, returns a value of type ``a``\".\n+- A ``Scenario a`` is \"a recipe for a test, which, when performed against a ledger, returns a value of type ``a``\".\n+\n+Expressions like ``getTime``, ``getParty party``, ``pass time``, ``submit party update``, ``create contract`` and ``exercise choice`` should make more sense in that light. For example:\n+\n+- ``getTime : Update Time`` is the recipe for an empty transaction that also happens to return a value of type ``Time``.\n+- ``pass (days 10) : Scenario ()`` is a recipe for a transaction that doesn't submit any transactions, but has the side-effect of changing the LET of the test ledger. It returns ``()``, also called ``Unit`` and can be thought of as a zero-tuple.\n+- ``create iou : Update (ContractId Iou)``, where ``iou : Iou`` is a recipe for a transaction consisting of a single ``create`` action, and returns the contract id of the created contract if successful.\n+- ``submit alice (create iou) : Scenario (ContractId Iou)`` is a recipe for a scenario in which Alice evaluates the result of ``create iou`` to get a transaction and a return value of type ``ContractId Iou``, and then submits that transaction to the ledger.\n+\n+Any DAML ledger knows how to perform actions of type ``Update a``. Only some know how to run scenarions, meaning they can perform actions of type ``Scenario a``.\n+\n+An action followed by another action, possibly depending on the result of the first action, is just another action. Specifically:\n+\n+- A transacion is a list of actions so a transaction followed by another transaction is again a transaction.\n+- A scenario is a list of interactions with the ledger (``submit``, ``getParty``, ``pass``, etc.) so a scenario followed by another scenario is again a scenario.\n+\n+This is where ``do`` blocks come in. ``do`` blocks allow you to combine small actions in to bigger actions, using the results of earlier actions in later ones.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- DO_DEMO_BEGIN\n+  :end-before: -- DO_DEMO_END\n+\n+Above, we see ``do`` blocks in action for both ``Scenario`` and ``Update``.\n+\n+You may already have noticed the use of ``return`` in the redeem choice. ``return x`` is a no-op action which returns value ``x`` so ``return 42 : Update Int``. Since ``do`` blocks always return the value of their last action, ``sub_scenario2 : Scenario Int``.\n+\n+Failing Actions\n+---------------\n+\n+Not only are ``Update`` and ``Scenario`` examples of ``Action``, they are both examples of actions that can fail, e.g. because a transaction is illegal or the party retrieved via ``getParty`` doesn't exist on the ledger.\n+\n+Each has a special action ``abort txt`` which takes on type ``Update ()`` or ``Scenario ()`` depending on context and represents failure. Transactions and scenarios succeed or fail *atomically* as a whole so an occurrence of an ``abort`` action will always fail the entire evaluation of the current ``Scenario`` or ``Update``.\n+\n+The last expression in the ``do`` block of the ``Redeem`` choice is a pattern matching expression on ``dow``. It has type ``Update ()`` and is either an ``abort`` or ``return`` depending on the day of week. So during the week, it's a no-op and on weekends, it's the special failure action. Thanks to the atomicity of transactions, no transaction can ever make use of the ``Redeem`` choice on weekends.\n+\n+A sample Action\n+---------------\n+\n+If the above didn't make complete sense, here's another example. ``CoinGame a`` is an ``Action a`` in which a ``Coin`` is flipped and based on the ``Heads`` and ``Tails`` results, a value of type ``a`` is calulated.\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A ``CoinGame a`` exposes a function ``play`` which takes a ``Coin`` and returns a new ``Coin`` and a result ``a``. More on the ``->`` syntax for functions later.\n+\n+``Coin`` and ``play`` are deliberately left obscure in the above. All you have is an action ``getCoin`` to get your hands on a ``Coin`` in a ``Scenario`` context and an action ``flipCoin`` which represents the simplest possible game: A single coin flip resulting in a  ``Face``. You can't play any ``CoinGame`` game on pen and paper as you don't have a coin, but you can write down a script or recipe for a game:\n+\n+.. literalinclude:: daml/daml-intro-5/Restrictions.daml\n+  :language: daml\n+  :start-after: -- COIN_SCENARIO_BEGIN\n+  :end-before: -- COIN_SCENARIO_END\n+\n+The ``game`` expression is a ``CoinGame`` in which a coin is flipped three times. If all three tosses return ``Heads``, the result is ``\"Win\"``, or else ``\"Loss\"``.\n+\n+In a ``Scenario`` context you can get a ``Coin``, which is actually a pseudo-random number generator based on LET, and play the game.\n+\n+*Somehow* the ``Coin`` is threaded through the various actions. If you want to look through the looking glass and understand in-depth what's going on, you can look at the source file to see how the ``CoinGame`` action is implemented, though be warned that the implementation uses a lot of DAML features we haven't introduced yet in this introduction.\n+\n+More generally, if you want to learn more about Actions (aka Monads), we recommend a general course on functional programming, and Haskell in particular.\n+\n+Next Up"
  }
]