[
  {
    "id" : "383e998c-d620-4a96-8ebb-50e9e497e29d",
    "prId" : 7507,
    "comments" : [
      {
        "id" : "f89df7a6-7be6-49de-bddd-a9cea8d00dfa",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n- DAML doesn't support all features of Haskell's type system. For example, there are no existential types or GADTs.\r\n```",
        "createdAt" : "2020-09-29T08:17:48Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "56781b9351d93757f344927f4f2fc3ac98edb262",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,498 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+9 Functional Programming 101\n+============================\n+\n+In this chapter, we will use both the Asset, as well as the Upgrade models from Chapter 8 to learn more about expressing complex logic in a functional language like DAML. You'll learn about\n+\n+- Function signatures and functions\n+- Advanced control flow (``if...else``, folds, recursion, ``when``)\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Upgrading` to get hold of the code for this chapter.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-9`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+.. _haskell-connection:\n+\n+The Haskell Connection\n+----------------------\n+\n+The previous chapters of this introduction to DAML have mostly covered the structure of templates, and their connection to the :doc:`DAML Ledger Model </concepts/ledger-model/index>`. The logic of what happens within the ``do`` blocks of choices has been kept relatively simple. In this chapter, we will dive deeper into DAML's expression language, the part that allows you to write logic inside those ``do`` blocks. But we can only scratch the surface here. DAML borrows a lot of its language from `Haskell <https://www.haskell.org>`__. If you want to dive deeper, or learn about specific aspects of the language you can refer to standard literature on Haskell. Some recommendations:\n+\n+- `Finding Success and Failure in Haskell (Julie Maronuki, Chris Martin) <https://joyofhaskell.com/>`__\n+- `Haskell Programming from first principles (Christopher Allen, Julie Moronuki) <http://haskellbook.com/>`__\n+- `Learn You a Haskell for Great Good! (Miran Lipovaƒça) <http://learnyouahaskell.com/>`__\n+- `Programming in Haskell (Graham Hutton) <http://www.cs.nott.ac.uk/~pszgmh/pih.html>`__\n+- `Real World Haskell (Bryan O'Sullivan, Don Stewart, John Goerzen) <http://book.realworldhaskell.org/>`__\n+\n+When comparing DAML to Haskell it's worth noting:\n+\n+-   Haskell is a lazy language, which allows you to write things like ``head [1..]``, meaning \"take the first element of an infinite list\". DAML by contrast is strict. Expressions are fully evaluated, which means it it not possible to work with infinite data structures.\n+- DAML has a ``with`` syntax for records, and dot syntax for record field access, neither of which present in Haskell. But DAML supports Haskell's curly brace record notation.\n+- DAML has a number of Haskell compiler extensions active by default.\n+- DAML doesn't support all features of Haskell's type system. For example, there are no existential types of GADTs."
  },
  {
    "id" : "d55f9ab7-22e1-483e-bf9a-092e76b0ee98",
    "prId" : 7507,
    "comments" : [
      {
        "id" : "5c292837-5e2a-4061-a630-780051f6a247",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n- Actions are called Monads in Haskell.\r\n```",
        "createdAt" : "2020-09-29T08:18:06Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "56781b9351d93757f344927f4f2fc3ac98edb262",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,498 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+9 Functional Programming 101\n+============================\n+\n+In this chapter, we will use both the Asset, as well as the Upgrade models from Chapter 8 to learn more about expressing complex logic in a functional language like DAML. You'll learn about\n+\n+- Function signatures and functions\n+- Advanced control flow (``if...else``, folds, recursion, ``when``)\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Upgrading` to get hold of the code for this chapter.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-9`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+.. _haskell-connection:\n+\n+The Haskell Connection\n+----------------------\n+\n+The previous chapters of this introduction to DAML have mostly covered the structure of templates, and their connection to the :doc:`DAML Ledger Model </concepts/ledger-model/index>`. The logic of what happens within the ``do`` blocks of choices has been kept relatively simple. In this chapter, we will dive deeper into DAML's expression language, the part that allows you to write logic inside those ``do`` blocks. But we can only scratch the surface here. DAML borrows a lot of its language from `Haskell <https://www.haskell.org>`__. If you want to dive deeper, or learn about specific aspects of the language you can refer to standard literature on Haskell. Some recommendations:\n+\n+- `Finding Success and Failure in Haskell (Julie Maronuki, Chris Martin) <https://joyofhaskell.com/>`__\n+- `Haskell Programming from first principles (Christopher Allen, Julie Moronuki) <http://haskellbook.com/>`__\n+- `Learn You a Haskell for Great Good! (Miran Lipovaƒça) <http://learnyouahaskell.com/>`__\n+- `Programming in Haskell (Graham Hutton) <http://www.cs.nott.ac.uk/~pszgmh/pih.html>`__\n+- `Real World Haskell (Bryan O'Sullivan, Don Stewart, John Goerzen) <http://book.realworldhaskell.org/>`__\n+\n+When comparing DAML to Haskell it's worth noting:\n+\n+-   Haskell is a lazy language, which allows you to write things like ``head [1..]``, meaning \"take the first element of an infinite list\". DAML by contrast is strict. Expressions are fully evaluated, which means it it not possible to work with infinite data structures.\n+- DAML has a ``with`` syntax for records, and dot syntax for record field access, neither of which present in Haskell. But DAML supports Haskell's curly brace record notation.\n+- DAML has a number of Haskell compiler extensions active by default.\n+- DAML doesn't support all features of Haskell's type system. For example, there are no existential types of GADTs.\n+- Actions, called Monads in Haskell."
  },
  {
    "id" : "357bcfe2-fc1e-479c-ab2b-fde878777270",
    "prId" : 7507,
    "comments" : [
      {
        "id" : "46f1814c-5fe8-426c-903d-3ed53174a055",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe worth mentioning that `when` is also control flow in the sense that it short circuits.",
        "createdAt" : "2020-09-29T08:24:42Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5549c94b-c1c5-42e1-b017-0b357e7ef93c",
        "parentId" : "46f1814c-5fe8-426c-903d-3ed53174a055",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "It only short circuits Action execution, though, not evaluation.",
        "createdAt" : "2020-09-29T09:50:45Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "52762515-e774-415c-ae5a-aeae826a58b9",
        "parentId" : "46f1814c-5fe8-426c-903d-3ed53174a055",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "it does short circuit evaluation. It‚Äôs hacked up in the compiler",
        "createdAt" : "2020-09-29T09:53:47Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d23d8819-27dc-405f-abfd-586dc1c28ed1",
        "parentId" : "46f1814c-5fe8-426c-903d-3ed53174a055",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I had no idea!",
        "createdAt" : "2020-09-29T14:15:28Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "56781b9351d93757f344927f4f2fc3ac98edb262",
    "line" : 333,
    "diffHunk" : "@@ -0,0 +1,498 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+9 Functional Programming 101\n+============================\n+\n+In this chapter, we will use both the Asset, as well as the Upgrade models from Chapter 8 to learn more about expressing complex logic in a functional language like DAML. You'll learn about\n+\n+- Function signatures and functions\n+- Advanced control flow (``if...else``, folds, recursion, ``when``)\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Upgrading` to get hold of the code for this chapter.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-9`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+.. _haskell-connection:\n+\n+The Haskell Connection\n+----------------------\n+\n+The previous chapters of this introduction to DAML have mostly covered the structure of templates, and their connection to the :doc:`DAML Ledger Model </concepts/ledger-model/index>`. The logic of what happens within the ``do`` blocks of choices has been kept relatively simple. In this chapter, we will dive deeper into DAML's expression language, the part that allows you to write logic inside those ``do`` blocks. But we can only scratch the surface here. DAML borrows a lot of its language from `Haskell <https://www.haskell.org>`__. If you want to dive deeper, or learn about specific aspects of the language you can refer to standard literature on Haskell. Some recommendations:\n+\n+- `Finding Success and Failure in Haskell (Julie Maronuki, Chris Martin) <https://joyofhaskell.com/>`__\n+- `Haskell Programming from first principles (Christopher Allen, Julie Moronuki) <http://haskellbook.com/>`__\n+- `Learn You a Haskell for Great Good! (Miran Lipovaƒça) <http://learnyouahaskell.com/>`__\n+- `Programming in Haskell (Graham Hutton) <http://www.cs.nott.ac.uk/~pszgmh/pih.html>`__\n+- `Real World Haskell (Bryan O'Sullivan, Don Stewart, John Goerzen) <http://book.realworldhaskell.org/>`__\n+\n+When comparing DAML to Haskell it's worth noting:\n+\n+-   Haskell is a lazy language, which allows you to write things like ``head [1..]``, meaning \"take the first element of an infinite list\". DAML by contrast is strict. Expressions are fully evaluated, which means it it not possible to work with infinite data structures.\n+- DAML has a ``with`` syntax for records, and dot syntax for record field access, neither of which present in Haskell. But DAML supports Haskell's curly brace record notation.\n+- DAML has a number of Haskell compiler extensions active by default.\n+- DAML doesn't support all features of Haskell's type system. For example, there are no existential types of GADTs.\n+- Actions, called Monads in Haskell.\n+\n+Functions\n+---------\n+\n+In :doc:`3_Data` you learnt about one half of DAML's type system: Data types. It's now time to learn about the other, which are Function types. Function types in DAML can be spotted by looking for ``->`` which can be read as \"maps to\".\n+\n+For example, the function signature ``Int -> Int`` maps an integer to another integer. There are many such functions, but one would be:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INCREMENT_BEGIN\n+  :end-before: -- INCREMENT_END\n+\n+You can see here that the function declaration and the function definitions are separate. The declaration can be omitted in cases where the type can be inferred by the compiler, but for top-level functions (ie ones at the same level as templates, directly under a module), it's often a good idea to include them for readability.\n+\n+In the case of ``increment`` it could have been omitted. Similarly, we could define a function ``add`` without a declaration:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD_BEGIN\n+  :end-before: -- ADD_END\n+\n+If you do this, and wonder what type the compiler has inferred, you can hover over the function name in the IDE:\n+\n+.. figure:: images/9_Functional101/signature.png\n+\n+What you see here is a slightly more complex signature:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD_SIG_BEGIN\n+  :end-before: -- ADD_SIG_END\n+\n+There are two interesting things going on here:\n+\n+1. We have more than one ``->``.\n+2. We have a type parameter ``a`` with a constraint ``Additive a``.\n+\n+Function Application\n+....................\n+\n+Let's start by looking at the right hand part ``a -> a -> a``. The ``->`` is right associative, meaning ``a -> a -> a`` is equivalent to ``a -> (a -> a)``. Using the \"maps to\" way of reading ``->`` we get \"a maps to a function that maps a to a``.\n+\n+And this is indeed what happens. We can define a different version of ``increment`` by *partially applying* ``add``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INCREMENT2_BEGIN\n+  :end-before: -- INCREMENT2_END\n+\n+If you try this out in your IDE, you'll see that the compiler infers type ``Int -> Int`` again. It can do so because the literal ``1 : Int``.\n+\n+So if we have a function ``f : a -> b -> c -> d`` and a value ``valA : a``, we get ``f valA : b -> c -> d`` ie we can apply the function argument by argument. If we also had ``valB : b``, we have ``f valA valB : c -> d``. What this tells you is that function *application* is left associative: ``f valA valB == (f valA) valB``.\n+\n+Infix Functions\n+...............\n+\n+Now ``add`` is clearly just an alias for ``+``, but what is ``+``? ``+`` is just a function. It's only special because it starts with a symbol. Functions that start with a symbol are *infix* by default which means they can be written between two arguments. That's why we can write ``1 + 2`` rather than ``+ 1 2``. The rules for converting between normal and infix functions are simple. Wrap an infix function in parentheses to use it as a normal function, and wrap a normal function in backticks to make it infix:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INFIX_BEGIN\n+  :end-before: -- INFIX_END\n+\n+With that knowledge, we could have defined ``add`` more succinctly as the alias that it is:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD2_BEGIN\n+  :end-before: -- ADD2_END\n+\n+If we want to partially apply an infix operation we can also do that as follows:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INFIX2_BEGIN\n+  :end-before: -- INFIX2_END\n+\n+.. note::\n+\n+  While function application is left associative by default, infix operators can be declared left or right associative and given a precedence. Good examples are the boolean operations ``&&`` and ``||``, which are declared right associative with precedences 3, and 2, respectively. This allows you to write ``False && True || True && True`` and get value ``True``. See section 4.4.2 of `the Haskell 98 report <https://www.haskell.org/onlinereport/decls.html>`_ for more on fixities. \n+\n+Type Constraints\n+................\n+\n+The ``Additive a =>`` part of the signature of ``add`` is a type constraint on the type parameter ``a``. ``Additive`` here is a typeclass. You already met typeclasses like ``Eq`` and ``Show`` in :doc:`3_Data`. The ``Additive`` typeclass says that you can add a thing. Ie there is a function ``(+) : a -> a -> a``. Now the way to read the full signature of ``add`` is \"Given that a has an instance for the Additive typeclass, a maps to a function which maps a to a\".\n+\n+Typeclasses in DAML are a bit like interfaces in other languages. To be able to add two things using the ``+`` function, those things need to expose the ``+`` interface.\n+\n+Unlike interfaces, typeclasses can have multiple type parameters. A good example, which also demonstrates the use of multiple constraints at the same time, is the signature of the ``exercise`` function:\n+\n+.. code-block:: daml\n+\n+  exercise : (Template t, Choice t c r) => ContractId t -> c -> Update r\n+\n+Let's turn this into prose: Given that ``t`` is the type of a template, and that ``t`` has a choice ``c`` with return type ``r``, map a ``ContractId`` for a contract of type ``t`` to a function that takes the choice arguments of type ``c`` and returns an ``Update`` resulting in type ``r``.\n+\n+That's quite a mouthful, and does require one to know what *meaning* the typeclass ``Choice`` gives to parameters ``t`` ``c`` and ``r``, but in many cases, that's obvious from the context or names of typeclasses and variables.\n+\n+Pattern Matching in Arguments\n+.............................\n+\n+You met pattern matching in :doc:`3_Data`, using ``case`` statements which is one way of pattern matching. However, it can also be convenient to do the pattern matching at the level of function arguments. Think about implementing the function ``uncurry``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- UNCURRY_SIG_BEGIN\n+  :end-before: -- UNCURRY_SIG_END\n+\n+``uncurry`` takes a function with two arguments (or more, since ``c`` could be a function), and turns it into a function from a 2-tuple to ``c``. Here are three ways of implementing it, using tuple accessors, ``case`` pattern matching, and function pattern matching:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- UNCURRY_BEGIN\n+  :end-before: -- UNCURRY_END\n+\n+Using function pattern matching is clearly the most elegant here. We never need the tuple as a whole, just its members. Any pattern matching you can do in ``case`` you can also do at the function level, and the compiler helpfully warns you if you did not cover all cases, which is called \"non-exhaustive\".\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- FROM_SOME_BEGIN\n+  :end-before: -- FROM_SOME_END\n+\n+The above will give you a warning: \n+\n+  .. code-block:: none\n+  \n+    warning:\n+      Pattern match(es) are non-exhaustive\n+      In an equation for ‚ÄòfromSome‚Äô: Patterns not matched: None\n+\n+This means ``fromSome`` is a partial function. ``fromSome None`` will cause a runtime error.\n+\n+We can use function level pattern matching together with a feature called *Record Wildcards* to write the function ``mapV1AssetToV2`` in the Chapter 8 upgrade package:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- MAP_ASSET_BEGIN\n+  :end-before: -- MAP_ASSET_END\n+\n+The ``..`` in the pattern match here means bind all fields from the given record to local variables, so we have local variables ``issuer``, ``owner``, etc.\n+\n+The ``..`` at the end means fill all fields of the new record using local variables of the matching name. So the function succinctly transfers all fields except for ``owner``, which is set explicitly, from the V1 Asset to the V2 Asset.\n+\n+Functions Everywhere\n+....................\n+\n+You have probably already guessed it: Anywhere you can put a value in DAML you can also put a function. Even inside data types:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- FUNCTION_IN_DATA_BEGIN\n+  :end-before: -- FUNCTION_IN_DATA_END\n+\n+More commonly, it makes sense to define functions locally, inside a ``let`` clause or similar. A good example of this is the ``upgradeAsset`` function defined locally in the ``UpgradeContracts`` choice of the upgrade model from Chapter 8:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_CONTRACTS_BEGIN\n+  :end-before: -- UPGRADE_CONTRACTS_END\n+\n+You can see that the function signature is inferred from the context here. If you look closely (or hover over the function in the IDE), you'll see that it has signature \n+\n+.. code-block:: daml\n+\n+    upgradeAsset : ContractId AssetV1.Asset -> Update (ContractId AssetV2.Asset)\n+\n+.. note::\n+\n+    Bear in mind that functions are not serializable, so you can't use them inside template arguments, or as choice in- or outputs. They also don't have instances of the ``Eq`` or ``Show`` typeclasses which one would commonly want on data types.\n+\n+You can probably guess what the ``mapA`` at the end of the above choice does. It somehow loops through the list ``assetCids``, applies the function ``upgradeAsset`` to each, and performs the resulting ``Update`` action. We'll look at that more closely under :ref:`looping` below.\n+\n+Lambdas\n+.......\n+\n+Like in most modern languages, DAML also supports inline functions called lambdas. They are defined using ``(\\x y z -> ...)`` syntax. For example, a lambda version of ``increment`` would be ``(\\n -> n + 1)``.\n+\n+Control Flow\n+------------\n+\n+In this section, we will cover branching and looping, and look at a few common patterns of how to translate procedural code into functional code.\n+\n+Branching\n+.........\n+\n+Until Chapter 7 the only real kind of control flow introduced has been ``case``, which is a powerful tool for branching. \n+\n+If..Else\n+~~~~~~~~\n+\n+Chapter 5 also showed a seemingly self-explanatory ``if..else`` statement, but didn't explain it further. And they are actually the same thing. Let's implement the function ``boolToInt : Bool -> Int`` which in tyipcal fashion maps ``True`` to ``1`` and ``False`` to ``0`. Here is an implementation using ``case``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- BOOL_TO_INT_BEGIN\n+  :end-before: -- BOOL_TO_INT_END\n+\n+If you write this function in the IDE, you'll get a warning from the linter:\n+\n+.. code-block:: none\n+\n+    Suggestion: Use if\n+    Found:\n+    case b of\n+        True -> 1\n+        False -> 0\n+    Perhaps:\n+    if b then 1 else 0\n+\n+The linter knows the equivalence and suggests a better implementation:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- BOOL_TO_INT2_BEGIN\n+  :end-before: -- BOOL_TO_INT2_END\n+\n+In short: ``if..else`` statements are equivalent to a ``case`` statement, but are easier to read.\n+\n+Control Flow as Expressions\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+``case`` statements and ``if..else`` really are control flow in the sense that they short circuit:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TEXT_TO_BOOL_BEGIN\n+  :end-before: -- TEXT_TO_BOOL_END\n+\n+This function behaves as you expect. The error only gets evaluated if an invalid text is passed in.\n+\n+This is different to functions, where all arguments are evaluated immediately:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- IFELSE_BEGIN\n+  :end-before: -- IFELSE_END\n+\n+In the above, ``boom`` is an error.\n+\n+But while being proper control flow, ``case`` and ``if..else`` statements are also expressions in the sense that they result in a value when evaluated. You can actually see that in the function definitions above. Since each of the functions is defined just as a ``case`` or ``if`` statement, the value of the evaluated function is just the value of the ``case``/``if`` statement. Things that have a value have a type. The ``if..else`` expression in ``boolToInt2`` has type ``Int`` as that's what the function returns, the ``case`` expression in ``doError`` has type ``Bool``. To be able to give such expressions an unambiguous type, each branch needs to have the same type. The below function does not compile as one branch tries to return an ``Int`` and the other a ``Text``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TYPE_ERROR_BEGIN\n+  :end-before: -- TYPE_ERROR_END\n+\n+If we need functions that can return two (or more) types of things we need to encode that in the return type. For two possibilities, it's common to use the ``Either`` type:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INT_OR_TEXT_BEGIN\n+  :end-before: -- INT_OR_TEXT_END\n+\n+Branching in Actions\n+~~~~~~~~~~~~~~~~~~~~\n+\n+The most common case where this becomes important is inside ``do`` blocks. Say we want to create a contract of one type in one case, and of another type in another case. Let's say we have two template types and want to write a function that creates an ``S`` if a condition is met, and a ``T`` otherwise.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- S_T_BEGIN\n+  :end-before: -- S_T_END\n+\n+It would be tempting to write a simple ``if..else``, but it won't typecheck:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TYPE_ERROR2_BEGIN\n+  :end-before: -- TYPE_ERROR2_END\n+\n+We have two options:\n+\n+1. Use the ``Either`` trick from above.\n+2. Get rid of the return types.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- S_OR_T_BEGIN\n+  :end-before: -- S_OR_T_END\n+\n+The latter is so common that there is a utility function in ``DA.Action`` to get rid of the return type: ``void : Functor f => f a -> f ()``.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- VOID_BEGIN\n+  :end-before: -- VOID_END\n+\n+``void`` also helps express control flow of the type \"Create a ``T`` only if a condition is met.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CUSTOM_WHEN_BEGIN\n+  :end-before: -- CUSTOM_WHEN_END\n+\n+Note that we still need the ``else`` clause of the same type ``()``. This pattern is so common, it's encapsulated in the standard library function ``DA.Action.when : (Applicative f) => Bool -> f () -> f ()``. "
  },
  {
    "id" : "08e542d7-b778-40b4-809c-c9ce178aafd1",
    "prId" : 7507,
    "comments" : [
      {
        "id" : "a746ec5b-fd8d-4113-addc-e241df399153",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Those examples seem like a somewhat weird mix of javascript and not quite javascript. Maybe just go for full javascript?",
        "createdAt" : "2020-09-29T08:26:16Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "48e8cc89-7aca-4506-a2f1-83ff692838db",
        "parentId" : "a746ec5b-fd8d-4113-addc-e241df399153",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "But then I'd have to test that it's valid javascript üò¢ ",
        "createdAt" : "2020-09-29T09:51:15Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bc047632-0f8b-4b9c-a2f8-8a2c1d836178",
        "parentId" : "a746ec5b-fd8d-4113-addc-e241df399153",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Ok, that was easier than I thought. It's now actual JavaScript",
        "createdAt" : "2020-09-29T09:59:03Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "56781b9351d93757f344927f4f2fc3ac98edb262",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,498 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+9 Functional Programming 101\n+============================\n+\n+In this chapter, we will use both the Asset, as well as the Upgrade models from Chapter 8 to learn more about expressing complex logic in a functional language like DAML. You'll learn about\n+\n+- Function signatures and functions\n+- Advanced control flow (``if...else``, folds, recursion, ``when``)\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Upgrading` to get hold of the code for this chapter.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-9`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+.. _haskell-connection:\n+\n+The Haskell Connection\n+----------------------\n+\n+The previous chapters of this introduction to DAML have mostly covered the structure of templates, and their connection to the :doc:`DAML Ledger Model </concepts/ledger-model/index>`. The logic of what happens within the ``do`` blocks of choices has been kept relatively simple. In this chapter, we will dive deeper into DAML's expression language, the part that allows you to write logic inside those ``do`` blocks. But we can only scratch the surface here. DAML borrows a lot of its language from `Haskell <https://www.haskell.org>`__. If you want to dive deeper, or learn about specific aspects of the language you can refer to standard literature on Haskell. Some recommendations:\n+\n+- `Finding Success and Failure in Haskell (Julie Maronuki, Chris Martin) <https://joyofhaskell.com/>`__\n+- `Haskell Programming from first principles (Christopher Allen, Julie Moronuki) <http://haskellbook.com/>`__\n+- `Learn You a Haskell for Great Good! (Miran Lipovaƒça) <http://learnyouahaskell.com/>`__\n+- `Programming in Haskell (Graham Hutton) <http://www.cs.nott.ac.uk/~pszgmh/pih.html>`__\n+- `Real World Haskell (Bryan O'Sullivan, Don Stewart, John Goerzen) <http://book.realworldhaskell.org/>`__\n+\n+When comparing DAML to Haskell it's worth noting:\n+\n+-   Haskell is a lazy language, which allows you to write things like ``head [1..]``, meaning \"take the first element of an infinite list\". DAML by contrast is strict. Expressions are fully evaluated, which means it it not possible to work with infinite data structures.\n+- DAML has a ``with`` syntax for records, and dot syntax for record field access, neither of which present in Haskell. But DAML supports Haskell's curly brace record notation.\n+- DAML has a number of Haskell compiler extensions active by default.\n+- DAML doesn't support all features of Haskell's type system. For example, there are no existential types of GADTs.\n+- Actions, called Monads in Haskell.\n+\n+Functions\n+---------\n+\n+In :doc:`3_Data` you learnt about one half of DAML's type system: Data types. It's now time to learn about the other, which are Function types. Function types in DAML can be spotted by looking for ``->`` which can be read as \"maps to\".\n+\n+For example, the function signature ``Int -> Int`` maps an integer to another integer. There are many such functions, but one would be:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INCREMENT_BEGIN\n+  :end-before: -- INCREMENT_END\n+\n+You can see here that the function declaration and the function definitions are separate. The declaration can be omitted in cases where the type can be inferred by the compiler, but for top-level functions (ie ones at the same level as templates, directly under a module), it's often a good idea to include them for readability.\n+\n+In the case of ``increment`` it could have been omitted. Similarly, we could define a function ``add`` without a declaration:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD_BEGIN\n+  :end-before: -- ADD_END\n+\n+If you do this, and wonder what type the compiler has inferred, you can hover over the function name in the IDE:\n+\n+.. figure:: images/9_Functional101/signature.png\n+\n+What you see here is a slightly more complex signature:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD_SIG_BEGIN\n+  :end-before: -- ADD_SIG_END\n+\n+There are two interesting things going on here:\n+\n+1. We have more than one ``->``.\n+2. We have a type parameter ``a`` with a constraint ``Additive a``.\n+\n+Function Application\n+....................\n+\n+Let's start by looking at the right hand part ``a -> a -> a``. The ``->`` is right associative, meaning ``a -> a -> a`` is equivalent to ``a -> (a -> a)``. Using the \"maps to\" way of reading ``->`` we get \"a maps to a function that maps a to a``.\n+\n+And this is indeed what happens. We can define a different version of ``increment`` by *partially applying* ``add``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INCREMENT2_BEGIN\n+  :end-before: -- INCREMENT2_END\n+\n+If you try this out in your IDE, you'll see that the compiler infers type ``Int -> Int`` again. It can do so because the literal ``1 : Int``.\n+\n+So if we have a function ``f : a -> b -> c -> d`` and a value ``valA : a``, we get ``f valA : b -> c -> d`` ie we can apply the function argument by argument. If we also had ``valB : b``, we have ``f valA valB : c -> d``. What this tells you is that function *application* is left associative: ``f valA valB == (f valA) valB``.\n+\n+Infix Functions\n+...............\n+\n+Now ``add`` is clearly just an alias for ``+``, but what is ``+``? ``+`` is just a function. It's only special because it starts with a symbol. Functions that start with a symbol are *infix* by default which means they can be written between two arguments. That's why we can write ``1 + 2`` rather than ``+ 1 2``. The rules for converting between normal and infix functions are simple. Wrap an infix function in parentheses to use it as a normal function, and wrap a normal function in backticks to make it infix:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INFIX_BEGIN\n+  :end-before: -- INFIX_END\n+\n+With that knowledge, we could have defined ``add`` more succinctly as the alias that it is:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD2_BEGIN\n+  :end-before: -- ADD2_END\n+\n+If we want to partially apply an infix operation we can also do that as follows:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INFIX2_BEGIN\n+  :end-before: -- INFIX2_END\n+\n+.. note::\n+\n+  While function application is left associative by default, infix operators can be declared left or right associative and given a precedence. Good examples are the boolean operations ``&&`` and ``||``, which are declared right associative with precedences 3, and 2, respectively. This allows you to write ``False && True || True && True`` and get value ``True``. See section 4.4.2 of `the Haskell 98 report <https://www.haskell.org/onlinereport/decls.html>`_ for more on fixities. \n+\n+Type Constraints\n+................\n+\n+The ``Additive a =>`` part of the signature of ``add`` is a type constraint on the type parameter ``a``. ``Additive`` here is a typeclass. You already met typeclasses like ``Eq`` and ``Show`` in :doc:`3_Data`. The ``Additive`` typeclass says that you can add a thing. Ie there is a function ``(+) : a -> a -> a``. Now the way to read the full signature of ``add`` is \"Given that a has an instance for the Additive typeclass, a maps to a function which maps a to a\".\n+\n+Typeclasses in DAML are a bit like interfaces in other languages. To be able to add two things using the ``+`` function, those things need to expose the ``+`` interface.\n+\n+Unlike interfaces, typeclasses can have multiple type parameters. A good example, which also demonstrates the use of multiple constraints at the same time, is the signature of the ``exercise`` function:\n+\n+.. code-block:: daml\n+\n+  exercise : (Template t, Choice t c r) => ContractId t -> c -> Update r\n+\n+Let's turn this into prose: Given that ``t`` is the type of a template, and that ``t`` has a choice ``c`` with return type ``r``, map a ``ContractId`` for a contract of type ``t`` to a function that takes the choice arguments of type ``c`` and returns an ``Update`` resulting in type ``r``.\n+\n+That's quite a mouthful, and does require one to know what *meaning* the typeclass ``Choice`` gives to parameters ``t`` ``c`` and ``r``, but in many cases, that's obvious from the context or names of typeclasses and variables.\n+\n+Pattern Matching in Arguments\n+.............................\n+\n+You met pattern matching in :doc:`3_Data`, using ``case`` statements which is one way of pattern matching. However, it can also be convenient to do the pattern matching at the level of function arguments. Think about implementing the function ``uncurry``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- UNCURRY_SIG_BEGIN\n+  :end-before: -- UNCURRY_SIG_END\n+\n+``uncurry`` takes a function with two arguments (or more, since ``c`` could be a function), and turns it into a function from a 2-tuple to ``c``. Here are three ways of implementing it, using tuple accessors, ``case`` pattern matching, and function pattern matching:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- UNCURRY_BEGIN\n+  :end-before: -- UNCURRY_END\n+\n+Using function pattern matching is clearly the most elegant here. We never need the tuple as a whole, just its members. Any pattern matching you can do in ``case`` you can also do at the function level, and the compiler helpfully warns you if you did not cover all cases, which is called \"non-exhaustive\".\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- FROM_SOME_BEGIN\n+  :end-before: -- FROM_SOME_END\n+\n+The above will give you a warning: \n+\n+  .. code-block:: none\n+  \n+    warning:\n+      Pattern match(es) are non-exhaustive\n+      In an equation for ‚ÄòfromSome‚Äô: Patterns not matched: None\n+\n+This means ``fromSome`` is a partial function. ``fromSome None`` will cause a runtime error.\n+\n+We can use function level pattern matching together with a feature called *Record Wildcards* to write the function ``mapV1AssetToV2`` in the Chapter 8 upgrade package:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- MAP_ASSET_BEGIN\n+  :end-before: -- MAP_ASSET_END\n+\n+The ``..`` in the pattern match here means bind all fields from the given record to local variables, so we have local variables ``issuer``, ``owner``, etc.\n+\n+The ``..`` at the end means fill all fields of the new record using local variables of the matching name. So the function succinctly transfers all fields except for ``owner``, which is set explicitly, from the V1 Asset to the V2 Asset.\n+\n+Functions Everywhere\n+....................\n+\n+You have probably already guessed it: Anywhere you can put a value in DAML you can also put a function. Even inside data types:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- FUNCTION_IN_DATA_BEGIN\n+  :end-before: -- FUNCTION_IN_DATA_END\n+\n+More commonly, it makes sense to define functions locally, inside a ``let`` clause or similar. A good example of this is the ``upgradeAsset`` function defined locally in the ``UpgradeContracts`` choice of the upgrade model from Chapter 8:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_CONTRACTS_BEGIN\n+  :end-before: -- UPGRADE_CONTRACTS_END\n+\n+You can see that the function signature is inferred from the context here. If you look closely (or hover over the function in the IDE), you'll see that it has signature \n+\n+.. code-block:: daml\n+\n+    upgradeAsset : ContractId AssetV1.Asset -> Update (ContractId AssetV2.Asset)\n+\n+.. note::\n+\n+    Bear in mind that functions are not serializable, so you can't use them inside template arguments, or as choice in- or outputs. They also don't have instances of the ``Eq`` or ``Show`` typeclasses which one would commonly want on data types.\n+\n+You can probably guess what the ``mapA`` at the end of the above choice does. It somehow loops through the list ``assetCids``, applies the function ``upgradeAsset`` to each, and performs the resulting ``Update`` action. We'll look at that more closely under :ref:`looping` below.\n+\n+Lambdas\n+.......\n+\n+Like in most modern languages, DAML also supports inline functions called lambdas. They are defined using ``(\\x y z -> ...)`` syntax. For example, a lambda version of ``increment`` would be ``(\\n -> n + 1)``.\n+\n+Control Flow\n+------------\n+\n+In this section, we will cover branching and looping, and look at a few common patterns of how to translate procedural code into functional code.\n+\n+Branching\n+.........\n+\n+Until Chapter 7 the only real kind of control flow introduced has been ``case``, which is a powerful tool for branching. \n+\n+If..Else\n+~~~~~~~~\n+\n+Chapter 5 also showed a seemingly self-explanatory ``if..else`` statement, but didn't explain it further. And they are actually the same thing. Let's implement the function ``boolToInt : Bool -> Int`` which in tyipcal fashion maps ``True`` to ``1`` and ``False`` to ``0`. Here is an implementation using ``case``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- BOOL_TO_INT_BEGIN\n+  :end-before: -- BOOL_TO_INT_END\n+\n+If you write this function in the IDE, you'll get a warning from the linter:\n+\n+.. code-block:: none\n+\n+    Suggestion: Use if\n+    Found:\n+    case b of\n+        True -> 1\n+        False -> 0\n+    Perhaps:\n+    if b then 1 else 0\n+\n+The linter knows the equivalence and suggests a better implementation:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- BOOL_TO_INT2_BEGIN\n+  :end-before: -- BOOL_TO_INT2_END\n+\n+In short: ``if..else`` statements are equivalent to a ``case`` statement, but are easier to read.\n+\n+Control Flow as Expressions\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+``case`` statements and ``if..else`` really are control flow in the sense that they short circuit:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TEXT_TO_BOOL_BEGIN\n+  :end-before: -- TEXT_TO_BOOL_END\n+\n+This function behaves as you expect. The error only gets evaluated if an invalid text is passed in.\n+\n+This is different to functions, where all arguments are evaluated immediately:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- IFELSE_BEGIN\n+  :end-before: -- IFELSE_END\n+\n+In the above, ``boom`` is an error.\n+\n+But while being proper control flow, ``case`` and ``if..else`` statements are also expressions in the sense that they result in a value when evaluated. You can actually see that in the function definitions above. Since each of the functions is defined just as a ``case`` or ``if`` statement, the value of the evaluated function is just the value of the ``case``/``if`` statement. Things that have a value have a type. The ``if..else`` expression in ``boolToInt2`` has type ``Int`` as that's what the function returns, the ``case`` expression in ``doError`` has type ``Bool``. To be able to give such expressions an unambiguous type, each branch needs to have the same type. The below function does not compile as one branch tries to return an ``Int`` and the other a ``Text``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TYPE_ERROR_BEGIN\n+  :end-before: -- TYPE_ERROR_END\n+\n+If we need functions that can return two (or more) types of things we need to encode that in the return type. For two possibilities, it's common to use the ``Either`` type:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INT_OR_TEXT_BEGIN\n+  :end-before: -- INT_OR_TEXT_END\n+\n+Branching in Actions\n+~~~~~~~~~~~~~~~~~~~~\n+\n+The most common case where this becomes important is inside ``do`` blocks. Say we want to create a contract of one type in one case, and of another type in another case. Let's say we have two template types and want to write a function that creates an ``S`` if a condition is met, and a ``T`` otherwise.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- S_T_BEGIN\n+  :end-before: -- S_T_END\n+\n+It would be tempting to write a simple ``if..else``, but it won't typecheck:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TYPE_ERROR2_BEGIN\n+  :end-before: -- TYPE_ERROR2_END\n+\n+We have two options:\n+\n+1. Use the ``Either`` trick from above.\n+2. Get rid of the return types.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- S_OR_T_BEGIN\n+  :end-before: -- S_OR_T_END\n+\n+The latter is so common that there is a utility function in ``DA.Action`` to get rid of the return type: ``void : Functor f => f a -> f ()``.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- VOID_BEGIN\n+  :end-before: -- VOID_END\n+\n+``void`` also helps express control flow of the type \"Create a ``T`` only if a condition is met.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CUSTOM_WHEN_BEGIN\n+  :end-before: -- CUSTOM_WHEN_END\n+\n+Note that we still need the ``else`` clause of the same type ``()``. This pattern is so common, it's encapsulated in the standard library function ``DA.Action.when : (Applicative f) => Bool -> f () -> f ()``. \n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- WHEN_BEGIN\n+  :end-before: -- WHEN_END\n+\n+You've already seen this in use in Chapter 8:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Test/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- RUN_COMPLETE_UPGRADE_BEGIN\n+  :end-before: -- RUN_COMPLETE_UPGRADE_END\n+\n+With ``case``, ``if..else``, ``void`` and ``when``, you can express all branching. However, one additional feature you may want to learn is guards. They are not covered here, but can help avoid deeply nested ``if..else`` blocks. Here's just one example. The Haskell sources at the beginning of the chapter cover this topic in more depth.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TELL_SIZE_BEGIN\n+  :end-before: -- TELL_SIZE_END\n+\n+.. _looping:\n+\n+Looping\n+.......\n+\n+Other than branching, the most common form of control flow is looping. Looping is usually used to iteratively modify some state. We'll use pseudocode in this section to illustrate the procedural way of doing things. \n+\n+.. code-block:: JavaScript\n+\n+  function sum(intArr) {\n+    int result = 0;"
  },
  {
    "id" : "80a17d2b-3495-47fd-9375-32541a6bd151",
    "prId" : 7507,
    "comments" : [
      {
        "id" : "b0e11969-c005-473f-a3e6-e06a730cc4ab",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n Intuitively, it's clear how to fix this: we want the compound action consisting of performing each of the actions in the list in turn. There's a function for that, of course. ``sequence : : Applicative m => [m a] -> m [a]`` implements that intuition and allows us to take the ``Update`` out of the list. So we could write ``sequence (map upgradeAsset assetCids)``. This is so common that it's encapsulated in the ``mapA`` function, a possible implementation of which is\r\n```\r\nMaybe worth pointing out that `mapA` is more efficient.",
        "createdAt" : "2020-09-29T08:29:04Z",
        "updatedAt" : "2020-09-29T17:18:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "56781b9351d93757f344927f4f2fc3ac98edb262",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,498 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+9 Functional Programming 101\n+============================\n+\n+In this chapter, we will use both the Asset, as well as the Upgrade models from Chapter 8 to learn more about expressing complex logic in a functional language like DAML. You'll learn about\n+\n+- Function signatures and functions\n+- Advanced control flow (``if...else``, folds, recursion, ``when``)\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Upgrading` to get hold of the code for this chapter.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-9`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+.. _haskell-connection:\n+\n+The Haskell Connection\n+----------------------\n+\n+The previous chapters of this introduction to DAML have mostly covered the structure of templates, and their connection to the :doc:`DAML Ledger Model </concepts/ledger-model/index>`. The logic of what happens within the ``do`` blocks of choices has been kept relatively simple. In this chapter, we will dive deeper into DAML's expression language, the part that allows you to write logic inside those ``do`` blocks. But we can only scratch the surface here. DAML borrows a lot of its language from `Haskell <https://www.haskell.org>`__. If you want to dive deeper, or learn about specific aspects of the language you can refer to standard literature on Haskell. Some recommendations:\n+\n+- `Finding Success and Failure in Haskell (Julie Maronuki, Chris Martin) <https://joyofhaskell.com/>`__\n+- `Haskell Programming from first principles (Christopher Allen, Julie Moronuki) <http://haskellbook.com/>`__\n+- `Learn You a Haskell for Great Good! (Miran Lipovaƒça) <http://learnyouahaskell.com/>`__\n+- `Programming in Haskell (Graham Hutton) <http://www.cs.nott.ac.uk/~pszgmh/pih.html>`__\n+- `Real World Haskell (Bryan O'Sullivan, Don Stewart, John Goerzen) <http://book.realworldhaskell.org/>`__\n+\n+When comparing DAML to Haskell it's worth noting:\n+\n+-   Haskell is a lazy language, which allows you to write things like ``head [1..]``, meaning \"take the first element of an infinite list\". DAML by contrast is strict. Expressions are fully evaluated, which means it it not possible to work with infinite data structures.\n+- DAML has a ``with`` syntax for records, and dot syntax for record field access, neither of which present in Haskell. But DAML supports Haskell's curly brace record notation.\n+- DAML has a number of Haskell compiler extensions active by default.\n+- DAML doesn't support all features of Haskell's type system. For example, there are no existential types of GADTs.\n+- Actions, called Monads in Haskell.\n+\n+Functions\n+---------\n+\n+In :doc:`3_Data` you learnt about one half of DAML's type system: Data types. It's now time to learn about the other, which are Function types. Function types in DAML can be spotted by looking for ``->`` which can be read as \"maps to\".\n+\n+For example, the function signature ``Int -> Int`` maps an integer to another integer. There are many such functions, but one would be:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INCREMENT_BEGIN\n+  :end-before: -- INCREMENT_END\n+\n+You can see here that the function declaration and the function definitions are separate. The declaration can be omitted in cases where the type can be inferred by the compiler, but for top-level functions (ie ones at the same level as templates, directly under a module), it's often a good idea to include them for readability.\n+\n+In the case of ``increment`` it could have been omitted. Similarly, we could define a function ``add`` without a declaration:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD_BEGIN\n+  :end-before: -- ADD_END\n+\n+If you do this, and wonder what type the compiler has inferred, you can hover over the function name in the IDE:\n+\n+.. figure:: images/9_Functional101/signature.png\n+\n+What you see here is a slightly more complex signature:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD_SIG_BEGIN\n+  :end-before: -- ADD_SIG_END\n+\n+There are two interesting things going on here:\n+\n+1. We have more than one ``->``.\n+2. We have a type parameter ``a`` with a constraint ``Additive a``.\n+\n+Function Application\n+....................\n+\n+Let's start by looking at the right hand part ``a -> a -> a``. The ``->`` is right associative, meaning ``a -> a -> a`` is equivalent to ``a -> (a -> a)``. Using the \"maps to\" way of reading ``->`` we get \"a maps to a function that maps a to a``.\n+\n+And this is indeed what happens. We can define a different version of ``increment`` by *partially applying* ``add``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INCREMENT2_BEGIN\n+  :end-before: -- INCREMENT2_END\n+\n+If you try this out in your IDE, you'll see that the compiler infers type ``Int -> Int`` again. It can do so because the literal ``1 : Int``.\n+\n+So if we have a function ``f : a -> b -> c -> d`` and a value ``valA : a``, we get ``f valA : b -> c -> d`` ie we can apply the function argument by argument. If we also had ``valB : b``, we have ``f valA valB : c -> d``. What this tells you is that function *application* is left associative: ``f valA valB == (f valA) valB``.\n+\n+Infix Functions\n+...............\n+\n+Now ``add`` is clearly just an alias for ``+``, but what is ``+``? ``+`` is just a function. It's only special because it starts with a symbol. Functions that start with a symbol are *infix* by default which means they can be written between two arguments. That's why we can write ``1 + 2`` rather than ``+ 1 2``. The rules for converting between normal and infix functions are simple. Wrap an infix function in parentheses to use it as a normal function, and wrap a normal function in backticks to make it infix:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INFIX_BEGIN\n+  :end-before: -- INFIX_END\n+\n+With that knowledge, we could have defined ``add`` more succinctly as the alias that it is:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- ADD2_BEGIN\n+  :end-before: -- ADD2_END\n+\n+If we want to partially apply an infix operation we can also do that as follows:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INFIX2_BEGIN\n+  :end-before: -- INFIX2_END\n+\n+.. note::\n+\n+  While function application is left associative by default, infix operators can be declared left or right associative and given a precedence. Good examples are the boolean operations ``&&`` and ``||``, which are declared right associative with precedences 3, and 2, respectively. This allows you to write ``False && True || True && True`` and get value ``True``. See section 4.4.2 of `the Haskell 98 report <https://www.haskell.org/onlinereport/decls.html>`_ for more on fixities. \n+\n+Type Constraints\n+................\n+\n+The ``Additive a =>`` part of the signature of ``add`` is a type constraint on the type parameter ``a``. ``Additive`` here is a typeclass. You already met typeclasses like ``Eq`` and ``Show`` in :doc:`3_Data`. The ``Additive`` typeclass says that you can add a thing. Ie there is a function ``(+) : a -> a -> a``. Now the way to read the full signature of ``add`` is \"Given that a has an instance for the Additive typeclass, a maps to a function which maps a to a\".\n+\n+Typeclasses in DAML are a bit like interfaces in other languages. To be able to add two things using the ``+`` function, those things need to expose the ``+`` interface.\n+\n+Unlike interfaces, typeclasses can have multiple type parameters. A good example, which also demonstrates the use of multiple constraints at the same time, is the signature of the ``exercise`` function:\n+\n+.. code-block:: daml\n+\n+  exercise : (Template t, Choice t c r) => ContractId t -> c -> Update r\n+\n+Let's turn this into prose: Given that ``t`` is the type of a template, and that ``t`` has a choice ``c`` with return type ``r``, map a ``ContractId`` for a contract of type ``t`` to a function that takes the choice arguments of type ``c`` and returns an ``Update`` resulting in type ``r``.\n+\n+That's quite a mouthful, and does require one to know what *meaning* the typeclass ``Choice`` gives to parameters ``t`` ``c`` and ``r``, but in many cases, that's obvious from the context or names of typeclasses and variables.\n+\n+Pattern Matching in Arguments\n+.............................\n+\n+You met pattern matching in :doc:`3_Data`, using ``case`` statements which is one way of pattern matching. However, it can also be convenient to do the pattern matching at the level of function arguments. Think about implementing the function ``uncurry``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- UNCURRY_SIG_BEGIN\n+  :end-before: -- UNCURRY_SIG_END\n+\n+``uncurry`` takes a function with two arguments (or more, since ``c`` could be a function), and turns it into a function from a 2-tuple to ``c``. Here are three ways of implementing it, using tuple accessors, ``case`` pattern matching, and function pattern matching:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- UNCURRY_BEGIN\n+  :end-before: -- UNCURRY_END\n+\n+Using function pattern matching is clearly the most elegant here. We never need the tuple as a whole, just its members. Any pattern matching you can do in ``case`` you can also do at the function level, and the compiler helpfully warns you if you did not cover all cases, which is called \"non-exhaustive\".\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- FROM_SOME_BEGIN\n+  :end-before: -- FROM_SOME_END\n+\n+The above will give you a warning: \n+\n+  .. code-block:: none\n+  \n+    warning:\n+      Pattern match(es) are non-exhaustive\n+      In an equation for ‚ÄòfromSome‚Äô: Patterns not matched: None\n+\n+This means ``fromSome`` is a partial function. ``fromSome None`` will cause a runtime error.\n+\n+We can use function level pattern matching together with a feature called *Record Wildcards* to write the function ``mapV1AssetToV2`` in the Chapter 8 upgrade package:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- MAP_ASSET_BEGIN\n+  :end-before: -- MAP_ASSET_END\n+\n+The ``..`` in the pattern match here means bind all fields from the given record to local variables, so we have local variables ``issuer``, ``owner``, etc.\n+\n+The ``..`` at the end means fill all fields of the new record using local variables of the matching name. So the function succinctly transfers all fields except for ``owner``, which is set explicitly, from the V1 Asset to the V2 Asset.\n+\n+Functions Everywhere\n+....................\n+\n+You have probably already guessed it: Anywhere you can put a value in DAML you can also put a function. Even inside data types:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- FUNCTION_IN_DATA_BEGIN\n+  :end-before: -- FUNCTION_IN_DATA_END\n+\n+More commonly, it makes sense to define functions locally, inside a ``let`` clause or similar. A good example of this is the ``upgradeAsset`` function defined locally in the ``UpgradeContracts`` choice of the upgrade model from Chapter 8:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_CONTRACTS_BEGIN\n+  :end-before: -- UPGRADE_CONTRACTS_END\n+\n+You can see that the function signature is inferred from the context here. If you look closely (or hover over the function in the IDE), you'll see that it has signature \n+\n+.. code-block:: daml\n+\n+    upgradeAsset : ContractId AssetV1.Asset -> Update (ContractId AssetV2.Asset)\n+\n+.. note::\n+\n+    Bear in mind that functions are not serializable, so you can't use them inside template arguments, or as choice in- or outputs. They also don't have instances of the ``Eq`` or ``Show`` typeclasses which one would commonly want on data types.\n+\n+You can probably guess what the ``mapA`` at the end of the above choice does. It somehow loops through the list ``assetCids``, applies the function ``upgradeAsset`` to each, and performs the resulting ``Update`` action. We'll look at that more closely under :ref:`looping` below.\n+\n+Lambdas\n+.......\n+\n+Like in most modern languages, DAML also supports inline functions called lambdas. They are defined using ``(\\x y z -> ...)`` syntax. For example, a lambda version of ``increment`` would be ``(\\n -> n + 1)``.\n+\n+Control Flow\n+------------\n+\n+In this section, we will cover branching and looping, and look at a few common patterns of how to translate procedural code into functional code.\n+\n+Branching\n+.........\n+\n+Until Chapter 7 the only real kind of control flow introduced has been ``case``, which is a powerful tool for branching. \n+\n+If..Else\n+~~~~~~~~\n+\n+Chapter 5 also showed a seemingly self-explanatory ``if..else`` statement, but didn't explain it further. And they are actually the same thing. Let's implement the function ``boolToInt : Bool -> Int`` which in tyipcal fashion maps ``True`` to ``1`` and ``False`` to ``0`. Here is an implementation using ``case``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- BOOL_TO_INT_BEGIN\n+  :end-before: -- BOOL_TO_INT_END\n+\n+If you write this function in the IDE, you'll get a warning from the linter:\n+\n+.. code-block:: none\n+\n+    Suggestion: Use if\n+    Found:\n+    case b of\n+        True -> 1\n+        False -> 0\n+    Perhaps:\n+    if b then 1 else 0\n+\n+The linter knows the equivalence and suggests a better implementation:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- BOOL_TO_INT2_BEGIN\n+  :end-before: -- BOOL_TO_INT2_END\n+\n+In short: ``if..else`` statements are equivalent to a ``case`` statement, but are easier to read.\n+\n+Control Flow as Expressions\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+``case`` statements and ``if..else`` really are control flow in the sense that they short circuit:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TEXT_TO_BOOL_BEGIN\n+  :end-before: -- TEXT_TO_BOOL_END\n+\n+This function behaves as you expect. The error only gets evaluated if an invalid text is passed in.\n+\n+This is different to functions, where all arguments are evaluated immediately:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- IFELSE_BEGIN\n+  :end-before: -- IFELSE_END\n+\n+In the above, ``boom`` is an error.\n+\n+But while being proper control flow, ``case`` and ``if..else`` statements are also expressions in the sense that they result in a value when evaluated. You can actually see that in the function definitions above. Since each of the functions is defined just as a ``case`` or ``if`` statement, the value of the evaluated function is just the value of the ``case``/``if`` statement. Things that have a value have a type. The ``if..else`` expression in ``boolToInt2`` has type ``Int`` as that's what the function returns, the ``case`` expression in ``doError`` has type ``Bool``. To be able to give such expressions an unambiguous type, each branch needs to have the same type. The below function does not compile as one branch tries to return an ``Int`` and the other a ``Text``:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TYPE_ERROR_BEGIN\n+  :end-before: -- TYPE_ERROR_END\n+\n+If we need functions that can return two (or more) types of things we need to encode that in the return type. For two possibilities, it's common to use the ``Either`` type:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INT_OR_TEXT_BEGIN\n+  :end-before: -- INT_OR_TEXT_END\n+\n+Branching in Actions\n+~~~~~~~~~~~~~~~~~~~~\n+\n+The most common case where this becomes important is inside ``do`` blocks. Say we want to create a contract of one type in one case, and of another type in another case. Let's say we have two template types and want to write a function that creates an ``S`` if a condition is met, and a ``T`` otherwise.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- S_T_BEGIN\n+  :end-before: -- S_T_END\n+\n+It would be tempting to write a simple ``if..else``, but it won't typecheck:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TYPE_ERROR2_BEGIN\n+  :end-before: -- TYPE_ERROR2_END\n+\n+We have two options:\n+\n+1. Use the ``Either`` trick from above.\n+2. Get rid of the return types.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- S_OR_T_BEGIN\n+  :end-before: -- S_OR_T_END\n+\n+The latter is so common that there is a utility function in ``DA.Action`` to get rid of the return type: ``void : Functor f => f a -> f ()``.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- VOID_BEGIN\n+  :end-before: -- VOID_END\n+\n+``void`` also helps express control flow of the type \"Create a ``T`` only if a condition is met.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CUSTOM_WHEN_BEGIN\n+  :end-before: -- CUSTOM_WHEN_END\n+\n+Note that we still need the ``else`` clause of the same type ``()``. This pattern is so common, it's encapsulated in the standard library function ``DA.Action.when : (Applicative f) => Bool -> f () -> f ()``. \n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- WHEN_BEGIN\n+  :end-before: -- WHEN_END\n+\n+You've already seen this in use in Chapter 8:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Test/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- RUN_COMPLETE_UPGRADE_BEGIN\n+  :end-before: -- RUN_COMPLETE_UPGRADE_END\n+\n+With ``case``, ``if..else``, ``void`` and ``when``, you can express all branching. However, one additional feature you may want to learn is guards. They are not covered here, but can help avoid deeply nested ``if..else`` blocks. Here's just one example. The Haskell sources at the beginning of the chapter cover this topic in more depth.\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TELL_SIZE_BEGIN\n+  :end-before: -- TELL_SIZE_END\n+\n+.. _looping:\n+\n+Looping\n+.......\n+\n+Other than branching, the most common form of control flow is looping. Looping is usually used to iteratively modify some state. We'll use pseudocode in this section to illustrate the procedural way of doing things. \n+\n+.. code-block:: JavaScript\n+\n+  function sum(intArr) {\n+    int result = 0;\n+    forEach (i in intArr) {\n+      result += i;\n+    }\n+    return result;\n+  }\n+\n+A more general loop looks like this:\n+\n+.. code-block:: JavaScript\n+\n+  function whileFunction(arr) {\n+    var rev = initialize(input);\n+    while (continue (state)) {\n+      state = process (state);\n+    }\n+    return finalize(state);\n+  }\n+\n+The only real difference is that the iterator is explicit in the former, and implicit in the latter.\n+\n+In both cases, state is being mutated: ``result`` in the former, ``state`` in the latter. Values in DAML are immutable, so it needs to work differently. In DAML we will do this with folds and recursion.\n+\n+.. _folds:\n+\n+Folds\n+~~~~~\n+\n+Folds correspond to looping with an explicit iterator: ``for`` and ``forEach`` loops in procedural languages. The most common iterator is a list, as is the case in the ``sum`` function above. For such cases, DAML has the ``foldl`` function. The ``l`` stands for \"left\" and means the list is processed from the left. There is also a corresponding ``foldr`` which processes from the right.\n+\n+.. code-block:: daml\n+\n+  foldl : (b -> a -> b) -> b -> [a] -> b\n+\n+Let's give the type parameters semantic names. ``b`` is the state, ``a`` is an item. ``foldl``\\ s first argument is a function which takes a state and an item and returns a new state. That's the equivalent of the inner block of the ``forEach``. It then takes a state, which is the initial state, and a list of items, which is the iterator. The result is again a state. The ``sum`` function above can be translated to DAML almost instantly with those correspondences in mind:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- SUM_BEGIN\n+  :end-before: -- SUM_END\n+\n+If we wanted to be more verbose, we could replace ``(+)`` with a lambda ``(\\result i -> result + i)`` which makes the correspondence to ``result += i`` from the pseudocode clearer.\n+\n+Almost all loops with explicit iterators can be translated to folds, though we have to take a bit of care with performance when it comes to translating ``for`` loops:\n+\n+.. code-block:: JavaScript\n+\n+  function sumArrs(arr1, arr2) {\n+    val l = min (arr1.length, arr2.length);\n+    int[] result = new int[l];\n+    for(int i = 0; i < l; i++) {\n+      result[i] = arr1[i] + arr2[i];\n+    }\n+    return result;\n+  }\n+\n+Translating the ``for`` into a ``forEach`` is easy if you can get your hands on an array containing values ``[0..(l-1)]``. And that's literally how you do it in DAML, using *ranges*. ``[0..(l-1)]`` is shorthand for ``enumFromTo 0 (l-1)``, which returns the list you'd expect.\n+\n+DAML also has an operator ``(!!) : [a] -> Int -> a`` which returns an element in a list. You may now be tempted to write ``sumArrs`` like this:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- SUM_ARR_BEGIN\n+  :end-before: -- SUM_ARR_END\n+\n+But you should immediately forget again that you just learnt about ``(!!)``. Lists in DAML are linked lists, which makes access using ``(!!)`` slow and idiosyncratic. The way to do this in DAML is to get rid of the ``i`` altogether and instead merge the lists first, and then iterate over the \"zipped\" up lists:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- SUM_ARR2_BEGIN\n+  :end-before: -- SUM_ARR2_END\n+\n+``zip : [a] -> [b] -> [(a, b)]`` takes two lists, and merges them into a single list where the first element is the 2-tuple containing the first elements to the two input lists, and so on. It drops any left-over elements of the longer list, thus making the ``min`` logic unnecessary.\n+\n+Maps\n+~~~~\n+\n+You've probably noticed that what we've done in this second version of ``sumArr`` is pretty standard, we have taken a list ``zip arr1 arr2`` applied a function ``\\(x, y) -> x + y``  to each element, and returned the list of results. This operation is called ``map : (a -> b) -> [a] -> [b]``. We can now write ``sumArr`` even more nicely:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- SUM_ARR3_BEGIN\n+  :end-before: -- SUM_ARR3_END\n+\n+As a rule of thumb: Use ``map`` if the result has the same shape as the input and you don't need to carry state from one iteration to the next. Use folds if you need to accumulate state in any way.\n+\n+Recursion\n+~~~~~~~~~\n+\n+If there is no explicit iterator, you can use recursion. Let's try to write a function that reverses a list, for example. We want to avoid ``(!!)`` so there is no sensible iterator here. Instead, we use recursion:\n+\n+.. literalinclude:: daml/daml-intro-9/daml/Main.daml\n+  :language: daml\n+  :start-after: -- REVERSE_BEGIN\n+  :end-before: -- REVERSE_END\n+\n+You may be tempted to make ``reverseWorker`` a local definition inside ``reverse``, but DAML only supports recursion for top-level functions so the recursive part ``recurseWorker`` has to be its own top-level function.\n+\n+Folds and Maps in Action Contexts\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The folds and ``map`` function above are pure in the sense introduced in :doc:`5_Restrictions`: The functions used to map or process items have no side-effects. In day-to-day DAML that's the exception rather than the rule. If you have looked at the Chapter 8 models, you'll have noticed ``mapA``, and ``_forA`` all over the place. A good example is the ``mapA`` in ``UpdateContracts``:\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml/Intro/Asset/Upgrade/V2.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_CONTRACTS_BEGIN\n+  :end-before: -- UPGRADE_CONTRACTS_END\n+\n+Here we have a list ``assetCids : [ContractId AssetV1.Asset]`` and a function ``upgradeAsset : ContractId AssetV1.Asset -> Update (ContractId AssetV2.Asset)``. We want ``UpgradeContracts`` to return a list ``[ContractId AssetV1.Asset]``. Using the map function almost gets us there. ``map upgradeAsset assetCids : [Update (ContractId AssetV2.Asset)]``. This is a list of actions, each resulting in a ``ContractId AssetV2.Asset``. What we need is an ``Update`` action resulting in a ``[ContractId AssetV2.Asset]``. The list and ``Update`` are the wrong way around for our purposes.\n+\n+\n+ Intuitively, it's clear how to fix this: we want the compound action consisting of performing each of the actions in the list in turn. There's a function for that, of course. ``sequence : : Applicative m => [m a] -> m [a]`` implements that intuition and allows us to take the ``Update`` out of the list. So we could write ``sequence (map upgradeAsset assetCids``. This is so common that it's encapsulated in the ``mapA`` function, a possible implementation of which is"
  }
]