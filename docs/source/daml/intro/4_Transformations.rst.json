[
  {
    "id" : "0c532dec-f876-45e3-b956-96f7b1d3cd2c",
    "prId" : 7264,
    "comments" : [
      {
        "id" : "8cdcd266-fca4-4ee0-9441-d61555217932",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\n``exerciseCmd`` returns a ``Commands r`` where ``r`` is the return\r\n```",
        "createdAt" : "2020-09-01T08:19:57Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "edfcefed5831fd27018f4cb3fdeb4a98f8ea266a",
    "line" : null,
    "diffHunk" : "@@ -48,14 +58,34 @@ Now to exercise the new choice in a scenario:\n \n You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n \n-``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+``exerciseCmd`` returns an ``Commands r`` where ``r`` is the return"
  },
  {
    "id" : "f5ec373c-68ac-487c-b1e8-edf51180a4fc",
    "prId" : 4169,
    "comments" : [
      {
        "id" : "1d0e1fc1-0ffe-4b83-8915-a435cf7b3b47",
        "parentId" : null,
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "https://docs.daml.com/concepts/ledger-model/ledger-structure.html also mentions _key assertions_ . `create` is not \"perfomed on a contract\" imho.",
        "createdAt" : "2020-01-22T16:45:00Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e9b16ad4-e8ba-4ff5-8d1d-dd3a2a2b05ae",
        "parentId" : "1d0e1fc1-0ffe-4b83-8915-a435cf7b3b47",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I'd list all action types then, since there's only one more (otherwise, it's unclear if there are 50 other ones). The crappy part is that the ledger model and the implementation diverge here, as the implementation has a `LookupByKey` action, where's the ledger model only has `Fetch` and `NoSuchKey`. This should however be resolved when https://github.com/digital-asset/daml/pull/4029 lands",
        "createdAt" : "2020-01-23T12:04:59Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a5d8d7bc-af07-4db9-9d3d-c03a495843f6",
        "parentId" : "1d0e1fc1-0ffe-4b83-8915-a435cf7b3b47",
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "ok, I added ``key assertion``, just copied it from Ledger model docs.",
        "createdAt" : "2020-01-23T13:08:57Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4a1b81657cb88709cf77d667729c4b5f6a811d9c",
    "line" : null,
    "diffHunk" : "@@ -76,13 +76,13 @@ Choices in the Ledger Model\n \n In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions.\n \n-A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+A *transaction* is a list of *actions*, and the most common kinds of action are ``create``, ``exercise`` and ``fetch``."
  },
  {
    "id" : "dca49ef4-de96-4810-9f20-37da8c951523",
    "prId" : 4169,
    "comments" : [
      {
        "id" : "90b5f1a0-dd58-44f7-b770-81f2a06b4703",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "```suggestion\r\n- An ``exercise`` action exercises a choice on a contract resulting in a transaction (list of sub-actions) called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\r\n```",
        "createdAt" : "2020-01-23T12:09:21Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4a1b81657cb88709cf77d667729c4b5f6a811d9c",
    "line" : null,
    "diffHunk" : "@@ -76,13 +76,13 @@ Choices in the Ledger Model\n \n In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions.\n \n-A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+A *transaction* is a list of *actions*, and the most common kinds of action are ``create``, ``exercise`` and ``fetch``.\n \n-- A ``create`` action contains the contract arguments and changes the contract's status from *non-existent* to *active*.\n-- A ``fetch`` action  checks the existence and activeness of a contract.\n-- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``create`` action creates a new contract with the given arguments and sets its status to *active*.\n+- A ``fetch`` action checks the existence and activeness of a contract.\n+- An ``exercise`` action exercises a choice on a contract resulting in a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*."
  },
  {
    "id" : "6c60a1bd-cc77-45e3-b312-c60a597c056f",
    "prId" : 4169,
    "comments" : [
      {
        "id" : "3c38f073-d478-4fb8-be3e-3d82a4a587f8",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "```suggestion\r\nEach action can be visualized as a tree, where the action is the root node, and its children are its consequences. Every consequence may have further consequences. As ``fetch`` and ``create`` actions have no consequences, they are leaf nodes. You can see the actions and their consequences in the transaction view of the above scenario:\r\n```",
        "createdAt" : "2020-01-23T12:10:38Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4a1b81657cb88709cf77d667729c4b5f6a811d9c",
    "line" : null,
    "diffHunk" : "@@ -76,13 +76,13 @@ Choices in the Ledger Model\n \n In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions.\n \n-A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+A *transaction* is a list of *actions*, and the most common kinds of action are ``create``, ``exercise`` and ``fetch``.\n \n-- A ``create`` action contains the contract arguments and changes the contract's status from *non-existent* to *active*.\n-- A ``fetch`` action  checks the existence and activeness of a contract.\n-- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``create`` action creates a new contract with the given arguments and sets its status to *active*.\n+- A ``fetch`` action checks the existence and activeness of a contract.\n+- An ``exercise`` action exercises a choice on a contract resulting in a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n \n-The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions. You can see the action and their consequences in the transaction view of the above scenario:\n+Each action can be visualized as a tree, where the action is the root node, and its children are its consequences. Every consequence may have further consequences. Naturally, if the action is a ``fetch`` or a ``create``, then it is a leaf (without further child). You can see the action and their consequences in the transaction view of the above scenario:"
  },
  {
    "id" : "d12a01ba-57b0-46ab-872b-92de732ca773",
    "prId" : 4169,
    "comments" : [
      {
        "id" : "2a7b4552-4eaf-4064-b2a0-6d3f9adb1d1a",
        "parentId" : null,
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "Note: I used the word _active_, while https://docs.daml.com/concepts/ledger-model/ledger-structure.html used the word _unconsumed_.",
        "createdAt" : "2020-01-23T13:12:25Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4a1b81657cb88709cf77d667729c4b5f6a811d9c",
    "line" : 13,
    "diffHunk" : "@@ -76,13 +76,14 @@ Choices in the Ledger Model\n \n In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions.\n \n-A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+A *transaction* is a list of *actions*, and there are just four kinds of action: ``create``, ``exercise``, ``fetch`` and ``key assertion``.\n \n-- A ``create`` action contains the contract arguments and changes the contract's status from *non-existent* to *active*.\n-- A ``fetch`` action  checks the existence and activeness of a contract.\n-- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``create`` action creates a new contract with the given arguments and sets its status to *active*.\n+- A ``fetch`` action checks the existence and activeness of a contract.\n+- An ``exercise`` action exercises a choice on a contract resulting in a transaction (list of sub-actions) called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``key assertion`` records the assertion that the given contract key (see :ref:`contract_keys`) is not assigned to any active contract on the ledger."
  },
  {
    "id" : "9ba75d14-8019-45d2-b700-9986abd7d5c0",
    "prId" : 4169,
    "comments" : [
      {
        "id" : "cfe46d16-b2c6-4d71-8743-d7c6a47bcc12",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "exercises can also be leaf nodes. E.g. some user use nonconsuming choices to emit events. ",
        "createdAt" : "2020-01-24T15:34:44Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d8790d5b-43a1-4fcc-ad9a-1b2f6e6c7c38",
        "parentId" : "cfe46d16-b2c6-4d71-8743-d7c6a47bcc12",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'd say `Archive` is the most prominent choice that produces an exercise node without children.",
        "createdAt" : "2020-01-25T10:17:17Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1b412ad1-1374-4ca8-92e9-d85349ee1a89",
        "parentId" : "cfe46d16-b2c6-4d71-8743-d7c6a47bcc12",
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "How about adding this? _Even the ``exercise`` action may have no consequence, e.g. the ``Archive`` choice._",
        "createdAt" : "2020-01-27T10:06:44Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8423e4d6-24a2-4f5a-b95e-d8b1e8ea8a38",
        "parentId" : "cfe46d16-b2c6-4d71-8743-d7c6a47bcc12",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I wouldn't say the `Archive` choice has no consequences since archiving a contract is clearly a consequence. However, the consequence is part of the exercise node itself, namely the `consuming` bit set to true.\r\n@bame-da More evidence that we got the primitives wrong...",
        "createdAt" : "2020-01-28T09:22:53Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b064388e-5b83-4044-9ac4-56683bbc9308",
        "parentId" : "cfe46d16-b2c6-4d71-8743-d7c6a47bcc12",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "@hurryabit in the strict sense of the Ledger Model, `Archive` has no consequences. ",
        "createdAt" : "2020-01-29T09:48:30Z",
        "updatedAt" : "2020-01-29T09:48:30Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4a1b81657cb88709cf77d667729c4b5f6a811d9c",
    "line" : null,
    "diffHunk" : "@@ -76,13 +76,14 @@ Choices in the Ledger Model\n \n In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions.\n \n-A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+A *transaction* is a list of *actions*, and there are just four kinds of action: ``create``, ``exercise``, ``fetch`` and ``key assertion``.\n \n-- A ``create`` action contains the contract arguments and changes the contract's status from *non-existent* to *active*.\n-- A ``fetch`` action  checks the existence and activeness of a contract.\n-- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``create`` action creates a new contract with the given arguments and sets its status to *active*.\n+- A ``fetch`` action checks the existence and activeness of a contract.\n+- An ``exercise`` action exercises a choice on a contract resulting in a transaction (list of sub-actions) called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``key assertion`` records the assertion that the given contract key (see :ref:`contract_keys`) is not assigned to any active contract on the ledger.\n \n-The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions. You can see the action and their consequences in the transaction view of the above scenario:\n+Each action can be visualized as a tree, where the action is the root node, and its children are its consequences. Every consequence may have further consequences. As ``fetch``, ``create`` and ``key assertion`` actions have no consequences, they are leaf nodes. You can see the actions and their consequences in the transaction view of the above scenario:"
  },
  {
    "id" : "dab7c311-60bd-47bb-a1ef-dc67b3005b73",
    "prId" : 4169,
    "comments" : [
      {
        "id" : "98d5dc62-d4eb-46f4-9695-93a8426ef02b",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\nEach action can be visualized as a tree, where the action is the root node, and its children are its direct consequences. Every consequence may have further consequences. As ``fetch``, ``create`` and ``key assertion`` actions have no consequences, they are always leaf nodes. You can see the actions and their consequences in the transaction view of the above scenario:\r\n```",
        "createdAt" : "2020-01-24T15:35:39Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "53305d9c-2819-4351-b864-6917b0421eed",
        "parentId" : "98d5dc62-d4eb-46f4-9695-93a8426ef02b",
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "I'm including the `always` word.\r\n\r\nHowever, I suggest to avoid the `direct` word, because the _consequenses_ are introduced as the (direct) children of the execution. So the implied _indirect consequences_ would require to change this definition (we can do this, but I intended this PR as a tidy-up only) here and on https://docs.daml.com/concepts/ledger-model/ledger-structure.html#actions-and-transactions  , where the transitive closure is called the set of _non-proper subactions_ instead.",
        "createdAt" : "2020-01-27T10:03:48Z",
        "updatedAt" : "2020-01-29T09:45:46Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "066b3c6b-9ccf-4d7b-9ec0-bd76fcd35b2c",
        "parentId" : "98d5dc62-d4eb-46f4-9695-93a8426ef02b",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "fine",
        "createdAt" : "2020-01-29T09:48:05Z",
        "updatedAt" : "2020-01-29T09:48:05Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4a1b81657cb88709cf77d667729c4b5f6a811d9c",
    "line" : null,
    "diffHunk" : "@@ -76,13 +76,14 @@ Choices in the Ledger Model\n \n In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions.\n \n-A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+A *transaction* is a list of *actions*, and there are just four kinds of action: ``create``, ``exercise``, ``fetch`` and ``key assertion``.\n \n-- A ``create`` action contains the contract arguments and changes the contract's status from *non-existent* to *active*.\n-- A ``fetch`` action  checks the existence and activeness of a contract.\n-- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``create`` action creates a new contract with the given arguments and sets its status to *active*.\n+- A ``fetch`` action checks the existence and activeness of a contract.\n+- An ``exercise`` action exercises a choice on a contract resulting in a transaction (list of sub-actions) called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+- A ``key assertion`` records the assertion that the given contract key (see :ref:`contract_keys`) is not assigned to any active contract on the ledger.\n \n-The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions. You can see the action and their consequences in the transaction view of the above scenario:\n+Each action can be visualized as a tree, where the action is the root node, and its children are its consequences. Every consequence may have further consequences. As ``fetch``, ``create`` and ``key assertion`` actions have no consequences, they are leaf nodes. You can see the actions and their consequences in the transaction view of the above scenario:"
  },
  {
    "id" : "08d782d7-6af8-4b2b-bc21-38cc8b5fc221",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "adc6ca6f-f173-439e-b152-971176c1235c",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nChoices as methods\r\n```",
        "createdAt" : "2019-06-17T13:29:55Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods"
  },
  {
    "id" : "0cee43d4-92c9-48bf-b279-e7f021838e42",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "5d39450d-088e-4fab-a1d0-5ba4fa47e5fe",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThe above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions.\r\n\r\nLet's unpack the code snippet above:\r\n```",
        "createdAt" : "2019-06-17T13:31:11Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above."
  },
  {
    "id" : "fddf3a46-fede-4d5d-b279-a6912af1b249",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "d6352ca2-4168-4f35-a4f9-b6a437c2efd1",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nChoices as delegation\r\n```",
        "createdAt" : "2019-06-17T13:32:05Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation"
  },
  {
    "id" : "a8786919-87dd-43c1-b2bd-68d5423f4161",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "d13f2344-ac83-4f39-9b35-7d86137a84d2",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nUp to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``.\r\n\r\nThe below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\r\n```",
        "createdAt" : "2019-06-17T13:33:00Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:"
  },
  {
    "id" : "03d2a88a-899e-4fce-8b7b-6a4e7c1a1a02",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "8af86c11-23e2-4cd3-a0ed-25ef6a85c7fa",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "This looks like title case, but I haven't edited it because it feels like the Ledger Model is a Thing.",
        "createdAt" : "2019-06-17T13:33:36Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : 74,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model"
  },
  {
    "id" : "94b7cb94-58e0-48b0-8cd4-17fe624cc2f6",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "d4fff03a-2cbb-4735-808f-884d59a0a667",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nIn :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions.\r\n\r\nA *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\r\n```",
        "createdAt" : "2019-06-17T13:33:53Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract."
  },
  {
    "id" : "78aaecae-6a8e-47e0-8873-0b848130fbd1",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "d84cc0ab-e9ab-4a56-acf6-e703694c86f9",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "`inexistent` is a word but an obscure one - I'd prefer `non-existent`.",
        "createdAt" : "2019-06-17T13:34:50Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aa317240-3bc6-454d-9dce-69697434927f",
        "parentId" : "d84cc0ab-e9ab-4a56-acf6-e703694c86f9",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\n- A ``create`` action contains the contract arguments and changes the contract's status from *non-existent* to *active*.\r\n```",
        "createdAt" : "2019-06-18T07:03:03Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*."
  },
  {
    "id" : "141c1a54-b732-47d0-836a-b164e6ada7d8",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "ef602fa9-6139-4710-86d8-23cda1809f01",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n- A ``fetch`` action  checks the existence and activeness of a contract.\r\n```",
        "createdAt" : "2019-06-17T13:34:59Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract"
  },
  {
    "id" : "2de14f0b-302a-49a5-a47f-ccf9f0282ddb",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "c7648701-22b0-4db6-a8af-3a184e91f8a8",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "I don't feel \"kind\" needs to feel like it's a term to be defined, but you may disagree\r\n```suggestion\r\n- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two kinds called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\r\n```",
        "createdAt" : "2019-06-17T13:35:32Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*."
  },
  {
    "id" : "e1608bd3-b31b-46fa-bfa4-425a1f7bb09d",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "02166b74-4dfe-4630-a826-0e305bd11fb9",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "> or, equivalently, a forest of actions\r\n\r\nI'm not familiar with this concept. Personally, I'd leave it out, but if you feel it adds explanatory value for a particular audience then I don't mind if it stays in",
        "createdAt" : "2019-06-17T13:36:28Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "55e0bb67-724a-4cdf-aa66-5a183fb4ad70",
        "parentId" : "02166b74-4dfe-4630-a826-0e305bd11fb9",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I think it's important the readers understand the relationship between actions and transactions. This deserves a visualization, though.",
        "createdAt" : "2019-06-18T07:54:42Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions."
  },
  {
    "id" : "91ec73a9-338f-40fa-838b-24b728ca8994",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "43b9d2c3-578f-4e3c-80fa-ddefdd73e87c",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "I'm not sure about this explanation, as I don't find it super clear what it means / what the consequences of this information are. But I can't suggest anything better off the top of my head so probably leave it as is.",
        "createdAt" : "2019-06-17T13:37:25Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f54faea0-c779-4e44-8cc9-6f68986c17ea",
        "parentId" : "43b9d2c3-578f-4e3c-80fa-ddefdd73e87c",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Update after reading the below - I think if you moved the paragraph beneath this to somewhere else, you could tack something onto the tree bit here to say that you'll be able to see the tree structure in the snippet below.",
        "createdAt" : "2019-06-17T13:41:31Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions."
  },
  {
    "id" : "ff3707c2-d538-4a64-b814-01083c57e4c9",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "3c059572-32bf-4562-9ee2-b55b27b7607c",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "This is useful information, but it's pretty random to put it here. I would either preface it with something like \"unrelated to the above, but useful to know\", or even move it to its own mini-section with the heading \"Archiving contracts using choices\" or something.",
        "createdAt" : "2019-06-17T13:39:37Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions.\n+\n+Each contract has an implicit choice ``Archive`` with the signatories as controllers and ``archive cid`` is just shorthand for ``exercise cid Archive``."
  },
  {
    "id" : "70d7d46c-68bc-4935-95a8-beab4d145728",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "f2791dd1-f6b6-47e2-8d1e-531df6a28b7a",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nThere are four commits corresponding to the four ``submit`` statements in the scenario. Within each commit, we see that it's actually actions that have IDs of the form ``#commit_number:action_number``. Contract IDs are just the ID of their ``create`` action.\r\n\r\nSo commits ``#2`` and ``#4`` contain ``exercise`` actions with ids ``#2:1`` and ``#4:1``. The ``create`` actions of the updated, ``Contact`` contracts,  ``#2:2`` and ``#4:2``, are indented and found below a line reading ``children:``, making the tree structure apparent.\r\n```",
        "createdAt" : "2019-06-17T13:40:34Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions.\n+\n+Each contract has an implicit choice ``Archive`` with the signatories as controllers and ``archive cid`` is just shorthand for ``exercise cid Archive``.\n+\n+With that new background, it's time to take a look at the transaction view of the above scenario:\n+\n+.. code-block:: none\n+\n+  Transactions:\n+    TX #0 1970-01-01T00:00:00Z (Contact:43:17)\n+    #0:0\n+    │   consumed by: #2:0\n+    │   referenced by #2:0\n+    │   known to (since): 'Alice' (#0), 'Bob' (#0)\n+    └─> create Contact:Contact\n+        with\n+          owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"012 345 6789\"\n+\n+    TX #1 1970-01-01T00:00:00Z\n+      mustFailAt 'Bob' (Contact:52:3)\n+\n+    TX #2 1970-01-01T00:00:00Z (Contact:56:22)\n+    #2:0\n+    │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+    └─> 'Alice' exercises UpdateTelephone on #0:0 (Contact:Contact)\n+                with\n+                  newTelephone = \"098 7654 321\"\n+        children:\n+        #2:1\n+        │   consumed by: #4:0\n+        │   referenced by #3:0, #4:0\n+        │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"098 7654 321\"\n+\n+    TX #3 1970-01-01T00:00:00Z (Contact:60:3)\n+    #3:0\n+    └─> fetch #2:1 (Contact:Contact)\n+\n+    TX #4 1970-01-01T00:00:00Z (Contact:66:22)\n+    #4:0\n+    │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+    └─> 'Bob' exercises UpdateAddress on #2:1 (Contact:Contact)\n+              with\n+                newAddress = \"1-10 Bobstreet\"\n+        children:\n+        #4:1\n+        │   referenced by #5:0\n+        │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice';\n+              party = 'Bob';\n+              address = \"1-10 Bobstreet\";\n+              telephone = \"098 7654 321\"\n+\n+    TX #5 1970-01-01T00:00:00Z (Contact:70:3)\n+    #5:0\n+    └─> fetch #4:1 (Contact:Contact)\n+\n+  Active contracts:  #4:1\n+\n+  Return value: {}\n+\n+There are four commits corresponding to the four ``submit`` statements in the scenario. Within each commit, we see that it's actually actions that have ids of the form ``#commit_number:action_number``. Contract ids are just the id of their ``create`` action. Commits ``#2`` and ``#4`` contain ``exercise`` actions with ids ``#2:1`` and ``#4:1``. The ``create`` actions of the updated, ``Contact`` contracts,  ``#2:2`` and ``#4:2``, are indented and found below a line reading ``children:``, making the tree structure apparent."
  },
  {
    "id" : "60393609-899b-4af4-9ce9-111e02c4315c",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "e91b1217-6fa4-4284-81d6-4ad03ac43085",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nA simple cash model\r\n```",
        "createdAt" : "2019-06-17T13:41:45Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions.\n+\n+Each contract has an implicit choice ``Archive`` with the signatories as controllers and ``archive cid`` is just shorthand for ``exercise cid Archive``.\n+\n+With that new background, it's time to take a look at the transaction view of the above scenario:\n+\n+.. code-block:: none\n+\n+  Transactions:\n+    TX #0 1970-01-01T00:00:00Z (Contact:43:17)\n+    #0:0\n+    │   consumed by: #2:0\n+    │   referenced by #2:0\n+    │   known to (since): 'Alice' (#0), 'Bob' (#0)\n+    └─> create Contact:Contact\n+        with\n+          owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"012 345 6789\"\n+\n+    TX #1 1970-01-01T00:00:00Z\n+      mustFailAt 'Bob' (Contact:52:3)\n+\n+    TX #2 1970-01-01T00:00:00Z (Contact:56:22)\n+    #2:0\n+    │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+    └─> 'Alice' exercises UpdateTelephone on #0:0 (Contact:Contact)\n+                with\n+                  newTelephone = \"098 7654 321\"\n+        children:\n+        #2:1\n+        │   consumed by: #4:0\n+        │   referenced by #3:0, #4:0\n+        │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"098 7654 321\"\n+\n+    TX #3 1970-01-01T00:00:00Z (Contact:60:3)\n+    #3:0\n+    └─> fetch #2:1 (Contact:Contact)\n+\n+    TX #4 1970-01-01T00:00:00Z (Contact:66:22)\n+    #4:0\n+    │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+    └─> 'Bob' exercises UpdateAddress on #2:1 (Contact:Contact)\n+              with\n+                newAddress = \"1-10 Bobstreet\"\n+        children:\n+        #4:1\n+        │   referenced by #5:0\n+        │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice';\n+              party = 'Bob';\n+              address = \"1-10 Bobstreet\";\n+              telephone = \"098 7654 321\"\n+\n+    TX #5 1970-01-01T00:00:00Z (Contact:70:3)\n+    #5:0\n+    └─> fetch #4:1 (Contact:Contact)\n+\n+  Active contracts:  #4:1\n+\n+  Return value: {}\n+\n+There are four commits corresponding to the four ``submit`` statements in the scenario. Within each commit, we see that it's actually actions that have ids of the form ``#commit_number:action_number``. Contract ids are just the id of their ``create`` action. Commits ``#2`` and ``#4`` contain ``exercise`` actions with ids ``#2:1`` and ``#4:1``. The ``create`` actions of the updated, ``Contact`` contracts,  ``#2:2`` and ``#4:2``, are indented and found below a line reading ``children:``, making the tree structure apparent.\n+\n+.. _simple_iou:\n+\n+A Simple Cash Model"
  },
  {
    "id" : "9577d8be-3477-432d-93ef-65cd6fc37da2",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "e2b88da4-7a10-4a9e-b9bf-56a3ec2cca94",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nWith the power of choices, you can build your first interesting model: issuance of cash IOUs (I owe you). The model presented here is simpler than the one in :doc:`3_Data` as it's not concerned with the location of the physical cash, but merely with liabilities:\r\n```",
        "createdAt" : "2019-06-17T13:42:09Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions.\n+\n+Each contract has an implicit choice ``Archive`` with the signatories as controllers and ``archive cid`` is just shorthand for ``exercise cid Archive``.\n+\n+With that new background, it's time to take a look at the transaction view of the above scenario:\n+\n+.. code-block:: none\n+\n+  Transactions:\n+    TX #0 1970-01-01T00:00:00Z (Contact:43:17)\n+    #0:0\n+    │   consumed by: #2:0\n+    │   referenced by #2:0\n+    │   known to (since): 'Alice' (#0), 'Bob' (#0)\n+    └─> create Contact:Contact\n+        with\n+          owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"012 345 6789\"\n+\n+    TX #1 1970-01-01T00:00:00Z\n+      mustFailAt 'Bob' (Contact:52:3)\n+\n+    TX #2 1970-01-01T00:00:00Z (Contact:56:22)\n+    #2:0\n+    │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+    └─> 'Alice' exercises UpdateTelephone on #0:0 (Contact:Contact)\n+                with\n+                  newTelephone = \"098 7654 321\"\n+        children:\n+        #2:1\n+        │   consumed by: #4:0\n+        │   referenced by #3:0, #4:0\n+        │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"098 7654 321\"\n+\n+    TX #3 1970-01-01T00:00:00Z (Contact:60:3)\n+    #3:0\n+    └─> fetch #2:1 (Contact:Contact)\n+\n+    TX #4 1970-01-01T00:00:00Z (Contact:66:22)\n+    #4:0\n+    │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+    └─> 'Bob' exercises UpdateAddress on #2:1 (Contact:Contact)\n+              with\n+                newAddress = \"1-10 Bobstreet\"\n+        children:\n+        #4:1\n+        │   referenced by #5:0\n+        │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice';\n+              party = 'Bob';\n+              address = \"1-10 Bobstreet\";\n+              telephone = \"098 7654 321\"\n+\n+    TX #5 1970-01-01T00:00:00Z (Contact:70:3)\n+    #5:0\n+    └─> fetch #4:1 (Contact:Contact)\n+\n+  Active contracts:  #4:1\n+\n+  Return value: {}\n+\n+There are four commits corresponding to the four ``submit`` statements in the scenario. Within each commit, we see that it's actually actions that have ids of the form ``#commit_number:action_number``. Contract ids are just the id of their ``create`` action. Commits ``#2`` and ``#4`` contain ``exercise`` actions with ids ``#2:1`` and ``#4:1``. The ``create`` actions of the updated, ``Contact`` contracts,  ``#2:2`` and ``#4:2``, are indented and found below a line reading ``children:``, making the tree structure apparent.\n+\n+.. _simple_iou:\n+\n+A Simple Cash Model\n+-------------------\n+\n+With the power of choices, you can build you first interesting model: Issuance of cash Ious (I owe you). The model presented here is simpler than the one in :doc:`3_Data` as it's not concerned with the location of the physical cash, but merely with liabilities."
  },
  {
    "id" : "0705756e-ce7a-4f6e-80da-76ec74b6344b",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "7d2f37b8-1790-4720-b54e-cdf51cb38431",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nNext up\r\n```",
        "createdAt" : "2019-06-17T13:42:32Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions.\n+\n+Each contract has an implicit choice ``Archive`` with the signatories as controllers and ``archive cid`` is just shorthand for ``exercise cid Archive``.\n+\n+With that new background, it's time to take a look at the transaction view of the above scenario:\n+\n+.. code-block:: none\n+\n+  Transactions:\n+    TX #0 1970-01-01T00:00:00Z (Contact:43:17)\n+    #0:0\n+    │   consumed by: #2:0\n+    │   referenced by #2:0\n+    │   known to (since): 'Alice' (#0), 'Bob' (#0)\n+    └─> create Contact:Contact\n+        with\n+          owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"012 345 6789\"\n+\n+    TX #1 1970-01-01T00:00:00Z\n+      mustFailAt 'Bob' (Contact:52:3)\n+\n+    TX #2 1970-01-01T00:00:00Z (Contact:56:22)\n+    #2:0\n+    │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+    └─> 'Alice' exercises UpdateTelephone on #0:0 (Contact:Contact)\n+                with\n+                  newTelephone = \"098 7654 321\"\n+        children:\n+        #2:1\n+        │   consumed by: #4:0\n+        │   referenced by #3:0, #4:0\n+        │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"098 7654 321\"\n+\n+    TX #3 1970-01-01T00:00:00Z (Contact:60:3)\n+    #3:0\n+    └─> fetch #2:1 (Contact:Contact)\n+\n+    TX #4 1970-01-01T00:00:00Z (Contact:66:22)\n+    #4:0\n+    │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+    └─> 'Bob' exercises UpdateAddress on #2:1 (Contact:Contact)\n+              with\n+                newAddress = \"1-10 Bobstreet\"\n+        children:\n+        #4:1\n+        │   referenced by #5:0\n+        │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice';\n+              party = 'Bob';\n+              address = \"1-10 Bobstreet\";\n+              telephone = \"098 7654 321\"\n+\n+    TX #5 1970-01-01T00:00:00Z (Contact:70:3)\n+    #5:0\n+    └─> fetch #4:1 (Contact:Contact)\n+\n+  Active contracts:  #4:1\n+\n+  Return value: {}\n+\n+There are four commits corresponding to the four ``submit`` statements in the scenario. Within each commit, we see that it's actually actions that have ids of the form ``#commit_number:action_number``. Contract ids are just the id of their ``create`` action. Commits ``#2`` and ``#4`` contain ``exercise`` actions with ids ``#2:1`` and ``#4:1``. The ``create`` actions of the updated, ``Contact`` contracts,  ``#2:2`` and ``#4:2``, are indented and found below a line reading ``children:``, making the tree structure apparent.\n+\n+.. _simple_iou:\n+\n+A Simple Cash Model\n+-------------------\n+\n+With the power of choices, you can build you first interesting model: Issuance of cash Ious (I owe you). The model presented here is simpler than the one in :doc:`3_Data` as it's not concerned with the location of the physical cash, but merely with liabilities.\n+\n+.. literalinclude:: daml/daml-intro-4/SimpleIou.daml\n+  :language: daml\n+\n+The above model is fine as long as everyone trusts Dora. Dora could revoke the `SimpleIou` at any point by archiving it. However, the provenance of all transactions would be on the ledger so the owner could *prove* that Dora was dishonest and cancelled her debt.\n+\n+Next Up"
  },
  {
    "id" : "04596a62-71e9-4bec-85e4-da67a65f7c4c",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "75bd5fa1-494e-49ec-b3a5-ee658d01d105",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nYou can now store and transform data on the ledger, even giving other parties specific write access through choices.\r\n\r\nIn :doc:`5_Restrictions`, you will learn how to restrict data and transformations further. In that context, you will also learn about time on DAML ledgers, ``do`` blocks and ``<-`` notation within those.\r\n```",
        "createdAt" : "2019-06-17T13:42:52Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,161 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+4 Transforming data using choices\n+=================================\n+\n+In the example in :ref:`contract_keys` the accountant party wanted to change some data on a contract. They did so by archiving the contract and re-creating it with the updated data. That works because the accountant is the sole signatory on the ``Account`` contract defined there.\n+\n+But what if the accountant wanted to allow the bank to change their own telephone number? Or what if the owner of a ``CashBalance`` should be able to transfer ownership to someone else?\n+\n+In this section you will learn about how to define simple data transformations using *choices* and how to delegate the right to *exercise* these choices to other parties.\n+\n+Choices as Methods\n+------------------\n+\n+If you think of templates as classes and contracts as objects, where are the methods?\n+\n+Take as an example a ``Contact`` contract on which the contact owner wants to be able to change the telephone number, just like on the ``Account`` in :ref:`contract_keys`. Rather than requiring them to manually look up the contract, archive the old one and create a new one, you can provide them a convenience method on ``Contact``:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_BEGIN\n+  :end-before: -- CHOICE_END\n+\n+The above defines a *choice* called ``UpdateTelephone``. Choices are part of a contract template. They're permissioned functions that result in an ``Update``. Using choices, authority can be passed around, allowing the construction of complex transactions. Let's unpack in the above.\n+\n+- The first line, ``controller owner can`` says that the following choices are *controlled* by ``owner``, meaning ``owner`` is the only party that is allowed *exercise* them. The line starts a new block in which multiple choices can be defined.\n+- ``UpdateTelephone`` is the name of a choice. It starts a new block in which that choice is defined.\n+- ``: ContractId Contact`` is the return type of the choice.\n+\n+  This particular choice archives the current ``Contact``, and creates a new one. What it returns is a reference to the new contract, in the form of a ``ContractId Contact``\n+- The following ``with`` block is that of a record. Just like with templates, in the background, a new record type is declared: ``data UpdateTelephone = UpdateTelephone with``\n+- The ``do`` starts a block defining the action the choice should perform when exercised. In this case a new ``Contact`` is created.\n+- The new ``Contact`` is created using ``this with``. ``this`` is a special value available within the ``where`` block of templates and takes the value of the current contract's arguments.\n+\n+There is nothing here explicitly saying that the current ``Contact`` should be archived. That's because choices are *consuming* by default. That means when the above choice is exercised on a contract, that contract is archived.\n+\n+If you paid a lot of attention in :doc:`3_Data`, you may have noticed that the ``create`` statement returns an ``Update (ContractId Contact)``, not a ``ContractId Contact``. As a ``do`` block always returns the value of the last statement within it, the whole ``do`` block returns an ``Update``, but the return type on the choice is just a ``ContractId Contact``. This is a conveneience. Choices *always* return an ``Update`` so for readability it's omitted on the type declaration of a choice.\n+\n+Now to exercise the new choice in a scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- CHOICE_TEST_BEGIN\n+  :end-before: -- CHOICE_TEST_END\n+\n+You exercise choices using the ``exercise`` function, which takes a ``ContractId a``, and a value of type ``c``, where ``c`` is a choice on template ``a``. Since ``c`` is just a record, you can also just fill in the choice parameters using the ``with`` syntax you are already familiar with.\n+\n+``exercise`` returns an ``Update r`` where ``r`` is the return type specified on the choice, allowing the new ``ContractId Contact`` to be stored in the variable ``new_contactCid``.\n+\n+Choices as Delegation\n+---------------------\n+\n+Up to this point all the contracts only involved one party. ``party`` may have been stored as ``Party`` field in the above, which suggests they are actors on the ledger, but they couldn't see the contracts, nor change them in any way. It would be reasonable for the party for which a ``Contact`` is stored to be able to update their own address and telephone number. In other words, the ``owner`` of a ``Contact`` should be able to *delegate* the right to perform a certain kind of data transformation to ``party``. The below demonstrates this using an ``UpdateAddress`` choice and corresponding extension of the scenario:\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_BEGIN\n+  :end-before: -- DELEGATION_END\n+\n+.. literalinclude:: daml/daml-intro-4/Contact.daml\n+  :language: daml\n+  :start-after: -- DELEGATION_TEST_BEGIN\n+  :end-before: -- DELEGATION_TEST_END\n+\n+If you open the scenario view in the IDE, you will notice that Bob sees the ``Contact``. Controllers specified via ``controller c can`` syntax become *observers* of the contract. More on *observers* later, but in short, they get to see any changes to the contract.\n+\n+.. _choices:\n+\n+Choices in the Ledger Model\n+---------------------------\n+\n+In :doc:`1_Token` you learned about the high-level structure of a DAML ledger. With choices and the `exercise` function, you have the next important ingredient to understand the structure of the ledger and transactions. A *transaction* is a list of *actions*, and there are just three kinds of action: ``create``, ``exercise`` and ``fetch``. All actions are performed on a contract.\n+\n+- A ``create`` action contains the contract arguments and changes the contract's status from *inexistent* to *active*.\n+- A ``fetch`` action  checks the existence and activeness of a contract\n+- An ``exercise`` action contains the choice arguments and a transaction called the *consequences*. Exercises come in two *kinds* called ``consuming`` and ``nonconsuming``. ``consuming`` is the default kind and changes the contract's status from *active* to *archived*.\n+\n+The consequences of exercise nodes turn each transaction into an ordered tree of (sub-) transactions, or, equivalently, a forest of actions. Actions are in one-to-one correspondence with proper sub-transactions.\n+\n+Each contract has an implicit choice ``Archive`` with the signatories as controllers and ``archive cid`` is just shorthand for ``exercise cid Archive``.\n+\n+With that new background, it's time to take a look at the transaction view of the above scenario:\n+\n+.. code-block:: none\n+\n+  Transactions:\n+    TX #0 1970-01-01T00:00:00Z (Contact:43:17)\n+    #0:0\n+    │   consumed by: #2:0\n+    │   referenced by #2:0\n+    │   known to (since): 'Alice' (#0), 'Bob' (#0)\n+    └─> create Contact:Contact\n+        with\n+          owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"012 345 6789\"\n+\n+    TX #1 1970-01-01T00:00:00Z\n+      mustFailAt 'Bob' (Contact:52:3)\n+\n+    TX #2 1970-01-01T00:00:00Z (Contact:56:22)\n+    #2:0\n+    │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+    └─> 'Alice' exercises UpdateTelephone on #0:0 (Contact:Contact)\n+                with\n+                  newTelephone = \"098 7654 321\"\n+        children:\n+        #2:1\n+        │   consumed by: #4:0\n+        │   referenced by #3:0, #4:0\n+        │   known to (since): 'Alice' (#2), 'Bob' (#2)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice'; party = 'Bob'; address = \"1 Bobstreet\"; telephone = \"098 7654 321\"\n+\n+    TX #3 1970-01-01T00:00:00Z (Contact:60:3)\n+    #3:0\n+    └─> fetch #2:1 (Contact:Contact)\n+\n+    TX #4 1970-01-01T00:00:00Z (Contact:66:22)\n+    #4:0\n+    │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+    └─> 'Bob' exercises UpdateAddress on #2:1 (Contact:Contact)\n+              with\n+                newAddress = \"1-10 Bobstreet\"\n+        children:\n+        #4:1\n+        │   referenced by #5:0\n+        │   known to (since): 'Alice' (#4), 'Bob' (#4)\n+        └─> create Contact:Contact\n+            with\n+              owner = 'Alice';\n+              party = 'Bob';\n+              address = \"1-10 Bobstreet\";\n+              telephone = \"098 7654 321\"\n+\n+    TX #5 1970-01-01T00:00:00Z (Contact:70:3)\n+    #5:0\n+    └─> fetch #4:1 (Contact:Contact)\n+\n+  Active contracts:  #4:1\n+\n+  Return value: {}\n+\n+There are four commits corresponding to the four ``submit`` statements in the scenario. Within each commit, we see that it's actually actions that have ids of the form ``#commit_number:action_number``. Contract ids are just the id of their ``create`` action. Commits ``#2`` and ``#4`` contain ``exercise`` actions with ids ``#2:1`` and ``#4:1``. The ``create`` actions of the updated, ``Contact`` contracts,  ``#2:2`` and ``#4:2``, are indented and found below a line reading ``children:``, making the tree structure apparent.\n+\n+.. _simple_iou:\n+\n+A Simple Cash Model\n+-------------------\n+\n+With the power of choices, you can build you first interesting model: Issuance of cash Ious (I owe you). The model presented here is simpler than the one in :doc:`3_Data` as it's not concerned with the location of the physical cash, but merely with liabilities.\n+\n+.. literalinclude:: daml/daml-intro-4/SimpleIou.daml\n+  :language: daml\n+\n+The above model is fine as long as everyone trusts Dora. Dora could revoke the `SimpleIou` at any point by archiving it. However, the provenance of all transactions would be on the ledger so the owner could *prove* that Dora was dishonest and cancelled her debt.\n+\n+Next Up\n+-------\n+\n+You can now store and transform data on the ledger, even giving other parties specific write access through choices. In :doc:`5_Restrictions`, you will learn how to restrict data and transformations further. In that context, you will also learn about time on DAML ledgers, ``do`` blocks and ``<-`` notation within those."
  }
]