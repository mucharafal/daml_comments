[
  {
    "id" : "e686fb17-7cd6-4c8e-8af3-728ecfb0f850",
    "prId" : 7506,
    "comments" : [
      {
        "id" : "89229618-66c2-45c4-8871-1f7075f51f07",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nThere are two important things to note about how the new version of the Asset model, and the Upgrade model are structured:\r\n```",
        "createdAt" : "2020-09-29T07:19:17Z",
        "updatedAt" : "2020-09-29T15:50:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bbae240e40255c19a1415b4c9bd363fdf8d29bf9",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,163 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+8 Upgrading\n+===========\n+\n+The application from Chapter 7 is a complete and secure model for atomic swaps of assets, but it leaves a lot to be desired. The trade process requires several transactions to set up, first to get the right quantity on an ``Asset`` contract, then to create tha approval. Client applications need to handle Cids and pass them into choices. Trades only swap one ``Asset`` for another, there are no multi-leg swaps. In this chapter, we will improve the model from Chapter 7 in several respects, and run an Upgrade, meaning we will move from the Chapter 7 model to the Chapter 8 model while preserving data. In the process, you will learn about\n+\n+- The software architecture of the DAML Stack\n+- Dependencies and Data Dependencies\n+- Identifiers\n+- Structuring Upgrade projects\n+- Writing Upgrade Contracts and performing an upgrade\n+\n+\n+Since we are upgrading from chapter 7, the setup for this chapter is slightly more complex:\n+\n+#. In a base directory, load the chapter 7 project using ``daml new 7Composing --template daml-intro-7``. The directory ``7_Composing`` here is important as it'll be referenced by the other projects we are creating.\n+#. In the same directory, load the chapter 8 Asset project using ``daml new 8Assets --template daml-intro-8-assets``.\n+#. In the same directory, load the chapter 8 Upgrade project using ``daml new 8Upgrade --template daml-intro-8-upgrade``.\n+\n+``8_Assets`` is an improved version of the chapter 7 model, and ``8_Upgrade`` is a DAML model used to upgrade an existing, running application of the chapter 7 model to the new improved ``8_Assets`` model. The upgraded model has one major new feature: Multi-signatory owners. Wherever we had ``owner : Party`` in chapter 7, we now have ``owner : [Party]`` or something similar. This changes almost all templates. We can't just use composition and add new templates to the ledger, we need to convert old ``Asset`` contracts into new ones. We will use this feature to explore control flow, typeclasses, functions, and the Standard Libary in chapters 9 and 10, but for now, we will concentrate on the Upgrading part.\n+\n+DAR, DALF, DAML-LF, and the Engine\n+----------------------------------\n+\n+In :doc:`7_Composing` you already learnt a little about projects, DAML-LF, DAR files, and dependencies. In this chapter we will actually need to have dependencies from the upgrade project to the chapter 7 and 8 asset projects so it's time to learn a little more about all this.\n+\n+Let's have a look inside the DAR file of chapter 7. DAR files, like Java JAR files are just ZIP archives, but the DAML SDK also has a utility to inspect DARs out of the box:\n+\n+#. Navigate into the ``7Composing`` directory.\n+#. Build using ``daml build -o assets.dar``\n+#. Run ``daml damlc inspect-dar assets.dar``\n+\n+You'll get a whole lot of output. Under the header \"DAR archive contains the following files:\" you'll see that the DAR contains\n+\n+#. ``*.dalf`` files for the project and all its dependencies\n+#. The original DAML source code\n+#. ``*.hi`` and ``*.hie`` files for each ``*.daml`` file\n+#. Some meta-inf and config files\n+\n+The first file is something like ``7Composing-1.0.0-887056cbb313b94ab9a6caf34f7fe4fbfe19cb0c861e50d1594c665567ab7625.dalf`` which is the actual compiled package for the project. ``*.dalf`` files contain DAML-LF, which is DAML's intermediate language. The file contents are a binary encoded protobuf message from the `daml-lf schema <https://github.com/digital-asset/daml/tree/master/daml-lf/archive>`_.  DAML-LF is evaluated on the Ledger by the DAML Engine, which is a JVM component that is part of tools like the IDE's Script runner, the Sandbox, or proper production ledgers. If DAML-LF is to DAML what Java Bytecode is to Java, the DAML Engine is to DAML what the JVM is to Java.\n+\n+Hashes and Identifiers\n+----------------------\n+\n+The  ``*.hi`` and ``*.hie`` files are interface files, which tell the DAML compiler how to map the bytecode back to DAML types.\n+\n+Under the heading \"DAR archive contains the following packages:\" you get a similar looking list of package names, paired with only the long random string repeated. That hexadecimal string, ``887056cbb313b94ab9a6caf34f7fe4fbfe19cb0c861e50d1594c665567ab7625`` in this case, is the package hash and the primary and only identifier for a package that's guaranteed to be available and preserved. Meta information like name (\"7Composing\") and version (\"1.0.0\") help make it human readable but should not be relied upon. You may not always get DAR files from your compiler, but be loading them from a running Ledger, or get them from an artifact repository.\n+\n+We can see this in action. When a DAR file gets deployed to a ledger, not all meta information is preserved. \n+\n+#. Note down your main package hash from running ``inspect-dar`` above\n+#. Start the project using ``daml start``\n+#. Open a second terminal and run ``daml ledger fetch-dar --host localhost --port 6865 --main-package-id \"887056cbb313b94ab9a6caf34f7fe4fbfe19cb0c861e50d1594c665567ab7625\" -o assets_ledger.dar``, making sure to replace the hash with the appropriate one.\n+#. Run ``daml damlc inspect-dar assets_ledger.dar``\n+\n+You'll notice two things. Firstly, a lot of the dependencies have lost their names, they are now only identifiable by hash. We could of course also create a second project ``7Composing-1.0.0`` with completely different contents so even when name and version are available, package hash is the only safe identifier.\n+\n+That's why over the Ledger API, all types, like templates and records are identified by the triple ``(entity name, module name, package hash)``. Your client application should know the package hashes it wants to interact with. To aid that, ``inspect-dar`` also provides a machine-readable format for the information it emits: ``daml damlc inspect-dar --json assets_ledger.dar``. The ``main_package_id`` field in the resulting JSON payload is the package hash of our project.\n+\n+Secondly, you'll notice that all the ``*.daml``, ``*.hi`` and ``*.hie`` files are gone. This leads us to data dependencies.\n+\n+Dependencies and Data Dependencies\n+----------------------------------\n+\n+Dependencies under the ``daml.yaml`` ``dependencies`` group rely on the ``*.hi`` and ``*.hie`` files, which are interface files that allow the compiler to map the low-level DAML-LF back to high level DAML types and typeclasses. This sort of information is crucial for dependencies like the Standard Library, which provides functions, types and typeclasses.\n+\n+However, as you can see above, this information isn't preserved. Furthermore, preserving this information may not even be desireable. Imagine we had built ``7Composing`` with SDK 1.100.0, and are building ``8_Upgrading`` with SDK 1.101.0. An inbuilt typeclass like ``Eq`` may have changed in between so we now have two different ``==`` functions. The one from the 1.100.0 Standard Library and the one from 1.101.0. This gets messy fast, which is why the SDK does not support ``dependencies`` across SDK versions. For dependencies on contract models that were fetched from a ledger, or come from an older SDK version, there is a simpler kind of dependency called ``data-dependencies``. The syntax for ``data-dependencies`` is the same, but they only rely on the \"binary\" ``*.dalf`` files. The name tries to confer that the main purpose of such dependencies is to handle data: Records, Choices, Templates. The stuff one needs to use contract composability across projects.\n+\n+For an upgrade model like this one, ``data-dependencies`` are appropriate so the ``upgrade`` project includes both the old and new asset models that way.\n+\n+.. literalinclude:: daml/daml-intro-8-upgrade/daml.yaml.template\n+  :language: yaml\n+  :start-after:   - daml-stdlib\n+  :end-before: sandbox-options:\n+\n+Structuring Projects for Upgrades\n+---------------------------------\n+\n+There are two important things to not about how the new version of the Asset model, and the Upgrade model are structured:"
  }
]