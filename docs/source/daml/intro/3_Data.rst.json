[
  {
    "id" : "cd52515b-fd0c-46b0-afdd-774df6b4ae8d",
    "prId" : 7505,
    "comments" : [
      {
        "id" : "52c05a01-0ba3-47c2-8d74-09a1e56dcd9d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "As menitoned on the other PR, `ContractId a` is also an instance of `Show`.",
        "createdAt" : "2020-09-29T07:26:05Z",
        "updatedAt" : "2020-09-29T07:36:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "31d7e8ba8b9d4ac2cf7e14d94f7e500d9f067699",
    "line" : null,
    "diffHunk" : "@@ -142,11 +144,11 @@ In the ``assert`` statements above, we always compared values of in-built types.\n   :start-after: -- EQ_TEST_BEGIN\n   :end-before: -- EQ_TEST_END\n \n-``Eq`` is what is called a *type-class*. You can think of a type-class as being like an interface in other languages: it is the mechanism by which you can define a set of functions (for example, ``==`` and ``/=`` in the case of ``Eq``) to work on multiple types, with a specific implementation for each type they can apply to.\n+``Eq`` is what is called a *typeclass*. You can think of a typeclass as being like an interface in other languages: it is the mechanism by which you can define a set of functions (for example, ``==`` and ``/=`` in the case of ``Eq``) to work on multiple types, with a specific implementation for each type they can apply to.\n \n-There are some other type-classes that the compiler can derive automatically. Most prominently, ``Show`` to get access to the function ``show`` (equivalent to ``toString`` in many languages) and ``Ord``, which gives access to comparison operators ``<``, ``>``, ``<=``, ``>=``.\n+There are some other typeclasses that the compiler can derive automatically. Most prominently, ``Show`` to get access to the function ``show`` (equivalent to ``toString`` in many languages) and ``Ord``, which gives access to comparison operators ``<``, ``>``, ``<=``, ``>=``.\n \n-It's a good idea to always derive ``Eq`` and ``Show`` using ``deriving (Eq, Show)``. The record types created using ``template T with`` do this automatically.\n+It's a good idea to always derive ``Eq`` and ``Show`` using ``deriving (Eq, Show)``. The record types created using ``template T with`` do this automatically, and the native types have appropriate typeclass instances. Eg `Int` derives `Eq`, `Show` and `Ord`, and `ContractId a` derives `Eq`."
  },
  {
    "id" : "24cdc78d-37ed-499d-a3b4-286f5f9eb4f3",
    "prId" : 7264,
    "comments" : [
      {
        "id" : "2c668828-7fb7-4396-b8c8-56b914d46ef6",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Do we have a function `script : Script a -> Script a`?",
        "createdAt" : "2020-08-31T14:29:51Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "08ed5c3e-03c2-44fa-aa29-1b8fa69ad004",
        "parentId" : "2c668828-7fb7-4396-b8c8-56b914d46ef6",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yes, see comment above.",
        "createdAt" : "2020-08-31T14:30:24Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "edfcefed5831fd27018f4cb3fdeb4a98f8ea266a",
    "line" : 38,
    "diffHunk" : "@@ -49,19 +49,19 @@ You have already encountered a few native DAML types: ``Party`` in :doc:`1_Token\n - ``RelTime``\n   Stores a difference in time.\n \n-The below scenario instantiates each one of these types, manipulates it where appropriate, and tests the result.\n+The below script instantiates each one of these types, manipulates it where appropriate, and tests the result.\n \n .. literalinclude:: daml/daml-intro-3/Native.daml\n   :language: daml\n   :start-after: -- NATIVE_TEST_BEGIN\n   :end-before: -- NATIVE_TEST_END\n \n-Despite its simplicity, there are quite a few things to note in this scenario:\n+Despite its simplicity, there are quite a few things to note in this script:\n \n-- The ``import`` statements at the top import two packages from the DAML Standard Library, which contain all the date and time related functions we use here. More on packages, imports and the standard library later.\n+- The ``import`` statements at the top import two packages from the DAML Standard Library, which contain all the date and time related functions we use here as well as the functions used in DAML Scripts. More on packages, imports and the standard library later.\n - Most of the variables are declared inside a ``let`` block.\n \n-  That's because the ``scenario do`` block expects scenario actions like ``submit`` or ``getParty``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action.\n+  That's because the ``script do`` block expects script actions like ``submit`` or ``Party``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action."
  },
  {
    "id" : "badf16d7-1d09-4af6-af4b-a62623547074",
    "prId" : 7264,
    "comments" : [
      {
        "id" : "5fb16e7a-0a3e-42d1-ba5e-5ffb50dbcd57",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Wouldn't it be better to introduce the query functionality here?",
        "createdAt" : "2020-08-31T14:30:47Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "39fa9dd4-94b3-4ce7-a8be-1d64855cd0f1",
        "parentId" : "5fb16e7a-0a3e-42d1-ba5e-5ffb50dbcd57",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The problem with `query` is that you cannot generalize it if you want to combine this with more commands in a single transaction. I’m open to using it here but I think section 4 needs to mention this pattern.",
        "createdAt" : "2020-08-31T14:32:28Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1fc3a41d-59ad-4bf5-9f22-7c0e954accad",
        "parentId" : "5fb16e7a-0a3e-42d1-ba5e-5ffb50dbcd57",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "It always struck me as odd that I have to do fetch-assert pairs in a submit block anyway. Couldn't we offer a `fetch`-like function on the `Script` Action so that one can just do `args <- fetchContract @T cid; assert(args.foo == bar)` or similar?",
        "createdAt" : "2020-08-31T14:47:42Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b9c31010-491d-4806-9dfe-3cf513e1beaf",
        "parentId" : "5fb16e7a-0a3e-42d1-ba5e-5ffb50dbcd57",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Fair enough, I guess if the JSON API already provides that endpoint this is reasonable. I still don’t like the fact that I have to do a linear search over the gRPC API but it’s not too bad either. Do you want to stick with `fetchContract` or do you have another name suggestion?",
        "createdAt" : "2020-08-31T14:58:11Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ec5c4364-195f-4343-96ab-5640aeb207ef",
        "parentId" : "5fb16e7a-0a3e-42d1-ba5e-5ffb50dbcd57",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Replaced by `queryContractId`.",
        "createdAt" : "2020-09-01T12:04:44Z",
        "updatedAt" : "2020-09-08T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "edfcefed5831fd27018f4cb3fdeb4a98f8ea266a",
    "line" : null,
    "diffHunk" : "@@ -218,7 +218,7 @@ You have already met the type ``ContractId a``, which references a contract of t\n   :start-after: -- ID_REF_TEST_BEGIN\n   :end-before: -- ID_REF_TEST_END\n \n-The scenario above uses the ``fetch`` function, which retrieves the arguments of an active contract using its contract ID.\n+The script above uses the ``fetch`` function, which retrieves the arguments of an active contract using its contract ID. ``fetch`` is not directly exposed to ledger clients. Therefore, we create a helper template with the functionality relying on ``fetch`` exposed via choices. We will learn more about choices in :doc:`the next section <4_Transformations>`. We can call those choices by specifying the template and the choice as arguments to ``createAndExerciseCmd``. Note that within the choices we omit the ``cmd`` suffix since that code is executed directly by the ledger instead of building up commands on the client."
  },
  {
    "id" : "adba02bb-05e3-44f1-b0da-702099c0a901",
    "prId" : 6210,
    "comments" : [
      {
        "id" : "f0703f97-008e-4f08-b042-c543ba6f01fb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't really understand\r\n> This is the case for ``0.001 : Decimal`` which could be any ``Numeric n``.\r\n\r\nWould it make sense to remove the `Decimal` type annotation and say\r\n> This is the case for ``0.001``, which could be of type ``Numeric n`` for any ``n``. Here, we specify...",
        "createdAt" : "2020-06-03T15:37:16Z",
        "updatedAt" : "2020-06-03T15:37:16Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6dccffd2-8cee-40c1-8c58-e987cfc7a7ed",
        "parentId" : "f0703f97-008e-4f08-b042-c543ba6f01fb",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/6214",
        "createdAt" : "2020-06-03T15:40:44Z",
        "updatedAt" : "2020-06-03T15:40:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ed87096b60c0c2c61d512ea7f823d73eba95ad10",
    "line" : 13,
    "diffHunk" : "@@ -62,11 +62,14 @@ Despite its simplicity, there are quite a few things to note in this scenario:\n - Most of the variables are declared inside a ``let`` block.\n \n   That's because the ``scenario do`` block expects scenario actions like ``submit`` or ``getParty``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action.\n-- Few of the variables have annotations to say what type they are.\n+- Most variables do not have annotations to say what type they are.\n \n   That's because DAML is very good at *inferring* types. The compiler knows that ``123`` is an ``Int``, so if you declare ``my_int = 123``, it can infer that ``my_int`` is also an ``Int``. This means you don't have to write the type annotation ``my_int : Int = 123``.\n \n-  However, if the type is ambiguous so that the compiler can't infer it, you do have to add a type annotation. And you can always choose to add them to aid readability.\n+  However, if the type is ambiguous so that the compiler can't infer\n+  it, you do have to add a type annotation. This is the case for\n+  ``0.001 : Decimal`` which could be any ``Numeric n``. Here we\n+  specify ``Decimal`` which is a synonym for ``Numeric 10``. You can always choose to add type annotations to aid readability."
  },
  {
    "id" : "ad590476-fa63-4add-ba8d-55bae871fcd3",
    "prId" : 4151,
    "comments" : [
      {
        "id" : "630fe392-1683-45d2-b816-8985149b7f06",
        "parentId" : null,
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "Please verify if the last sentence is true and also helpful.",
        "createdAt" : "2020-01-21T16:51:02Z",
        "updatedAt" : "2020-01-21T21:35:43Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e5ac4407a28c3b374db6ca6d03028cf565e778b9",
    "line" : 14,
    "diffHunk" : "@@ -226,7 +226,7 @@ You can define *stable* keys for contracts using the ``key`` and ``maintainer``\n   :start-after: -- KEY_TEST_BEGIN\n   :end-before: -- KEY_TEST_END\n \n-Since DAML is designed to run on distributed systems, you have to assume that there is no global entity that can guarantee uniqueness, which is why each ``key`` expression must come with a ``maintainer`` expression. ``maintainer`` takes one or several parties, all of which have to be signatories of the contract and be part of the key. That way the index can be partitioned amongst sets of maintainers, and each set of maintainers can independently ensure the uniqueness constraint on their piece of the index. The constraint that maintainters are part of the key is ensured by only having the variable `key`\n+Since DAML is designed to run on distributed systems, you have to assume that there is no global entity that can guarantee uniqueness, which is why each ``key`` expression must come with a ``maintainer`` expression. ``maintainer`` takes one or several parties, all of which have to be signatories of the contract and be part of the key. That way the index can be partitioned amongst sets of maintainers, and each set of maintainers can independently ensure the uniqueness constraint on their piece of the index. The constraint that maintainers are part of the key is ensured by only having the variable `key` in each maintainer expression."
  },
  {
    "id" : "10cc33d4-df45-46af-a92d-06d46d88c75c",
    "prId" : 4151,
    "comments" : [
      {
        "id" : "a677eebd-b3e5-4a76-881e-552676d46d6c",
        "parentId" : null,
        "author" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "body" : "Alternatively, we could remove the last sentence:\r\n```suggestion\r\n  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions.\r\n```",
        "createdAt" : "2020-01-21T16:51:28Z",
        "updatedAt" : "2020-01-21T21:35:43Z",
        "lastEditedBy" : {
          "login" : "richardkapolnai-da",
          "name" : "Richard Kapolnai",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/53859003?u=c5f7df62435454a9c8d1a01b0efb50a2a035eab9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e5ac4407a28c3b374db6ca6d03028cf565e778b9",
    "line" : 5,
    "diffHunk" : "@@ -31,7 +31,7 @@ Native types\n You have already encountered a few native DAML types: ``Party`` in :doc:`1_Token`, and ``Text`` and ``ContractId`` in :doc:`2_Scenario`. Here are those native types and more:\n \n - ``Party``\n-  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions. In general, ``Party`` is Oblique.\n+  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions. In general, ``Party`` is opaque."
  },
  {
    "id" : "0f0b9bb7-1ada-4103-9373-7d8626382864",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "21268e9f-a8e2-4135-b6cb-35d6f779ff41",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "sentence case\r\n```suggestion\r\nNative types\r\n```",
        "createdAt" : "2019-06-17T13:28:20Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,241 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+3 Data types\n+============\n+\n+In :doc:`1_Token`, you learnt about contract templates, which specify the types of contracts that can be created on the ledger, and what data those contracts hold in their arguments.\n+\n+In :doc:`2_Scenario`, you learnt about the scenario view in DAML Studio, which displays the current ledger state. It shows one table per template, with one row per contract of that type and one column per field in the arguments.\n+\n+This actually provides a useful way of thinking about templates: like tables in databases. Templates specify a data schema for the ledger:\n+\n+- each template corresponds to a table\n+- each field in the ``with`` block of a template corresponds to a column in that table\n+- each contract instance of that type corresponds to a table row\n+\n+In this section, you'll learn how to create rich data schemas for your ledger. Specifically you'll learn about:\n+\n+- DAML's built-in and native data types\n+- Record types\n+- Derivation of standard properties\n+- Variants\n+- Manipulating immutable data\n+- Contract keys\n+\n+After this section, you should be able to use a DAML ledger as a simple database where individual parties can write, read and delete complex data.\n+\n+Native Types"
  },
  {
    "id" : "5b9789bd-3cf6-406e-8223-37bebac36717",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "4c6d893e-7d38-49d3-8a0e-3e146bd3a6e0",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n  However, if the type is ambiguous so that the compiler can't infer it, you do have to add a type annotation. And you can always choose to add them to aid readability.\r\n```",
        "createdAt" : "2019-06-17T13:28:31Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,241 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+3 Data types\n+============\n+\n+In :doc:`1_Token`, you learnt about contract templates, which specify the types of contracts that can be created on the ledger, and what data those contracts hold in their arguments.\n+\n+In :doc:`2_Scenario`, you learnt about the scenario view in DAML Studio, which displays the current ledger state. It shows one table per template, with one row per contract of that type and one column per field in the arguments.\n+\n+This actually provides a useful way of thinking about templates: like tables in databases. Templates specify a data schema for the ledger:\n+\n+- each template corresponds to a table\n+- each field in the ``with`` block of a template corresponds to a column in that table\n+- each contract instance of that type corresponds to a table row\n+\n+In this section, you'll learn how to create rich data schemas for your ledger. Specifically you'll learn about:\n+\n+- DAML's built-in and native data types\n+- Record types\n+- Derivation of standard properties\n+- Variants\n+- Manipulating immutable data\n+- Contract keys\n+\n+After this section, you should be able to use a DAML ledger as a simple database where individual parties can write, read and delete complex data.\n+\n+Native Types\n+------------\n+\n+You have already encountered a few native DAML types: ``Party`` in :doc:`1_Token`, and ``Text`` and ``ContractId`` in :doc:`2_Scenario`. Here are those native types and more:\n+\n+- ``Party``\n+  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions. In general, ``Party`` is Oblique.\n+- ``Text``\n+  Stores a unicode character string like ``\"Alice\"``.\n+- ``ContractId a``\n+  Stores a reference to a contract of type ``a``.\n+- ``Int``\n+  Stores signed 64-bit integers. For example, ``-123``.\n+- ``Decimal``\n+  Stores fixed-point number with 28 digits before and 10 digits after the decimal point. For example, ``0.0000000001`` or ``-9999999999999999999999999999.9999999999``.\n+- ``Bool``\n+  Stores ``True`` or ``False``.\n+- ``Date``\n+  Stores a date.\n+- ``Time``\n+  Stores absolute UTC time.\n+- ``RelTime``\n+  Stores a difference in time.\n+\n+The below scenario instantiates each one of these types, manipulates it where appropriate, and tests the result.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- NATIVE_TEST_BEGIN\n+  :end-before: -- NATIVE_TEST_END\n+\n+Despite its simplicity, there are quite a few things to note in this scenario:\n+\n+- The ``import`` statements at the top import two packages from the DAML Standard Library, which contain all the date and time related functions we use here. More on packages, imports and the standard library later.\n+- Most of the variables are declared inside a ``let`` block.\n+\n+  That's because the ``scenario do`` block expects scenario actions like ``submit`` or ``getParty``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action.\n+- None of the variables have annotations to say what type they are.\n+\n+  That's because DAML is very good at *inferring* types. The compiler knows that ``123`` is an ``Int``, so if you declare ``my_int = 123``, it can infer that ``my_int`` is also an ``Int``. This means you don't have to write the type annotation ``my_int : Int = 123``.\n+\n+   However, if the type is ambiguous so that the compiler can't infer it, you do have to add a type annotation. And you can always choose to add them to aid readability."
  },
  {
    "id" : "676f34db-91b6-4854-9689-74d48b3a8cea",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "b167ace1-c871-47cd-a04e-7ad046809a96",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "because it's an important thing covered in this section\r\n```suggestion\r\nVariants and pattern matching\r\n```",
        "createdAt" : "2019-06-17T13:29:01Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,241 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+3 Data types\n+============\n+\n+In :doc:`1_Token`, you learnt about contract templates, which specify the types of contracts that can be created on the ledger, and what data those contracts hold in their arguments.\n+\n+In :doc:`2_Scenario`, you learnt about the scenario view in DAML Studio, which displays the current ledger state. It shows one table per template, with one row per contract of that type and one column per field in the arguments.\n+\n+This actually provides a useful way of thinking about templates: like tables in databases. Templates specify a data schema for the ledger:\n+\n+- each template corresponds to a table\n+- each field in the ``with`` block of a template corresponds to a column in that table\n+- each contract instance of that type corresponds to a table row\n+\n+In this section, you'll learn how to create rich data schemas for your ledger. Specifically you'll learn about:\n+\n+- DAML's built-in and native data types\n+- Record types\n+- Derivation of standard properties\n+- Variants\n+- Manipulating immutable data\n+- Contract keys\n+\n+After this section, you should be able to use a DAML ledger as a simple database where individual parties can write, read and delete complex data.\n+\n+Native Types\n+------------\n+\n+You have already encountered a few native DAML types: ``Party`` in :doc:`1_Token`, and ``Text`` and ``ContractId`` in :doc:`2_Scenario`. Here are those native types and more:\n+\n+- ``Party``\n+  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions. In general, ``Party`` is Oblique.\n+- ``Text``\n+  Stores a unicode character string like ``\"Alice\"``.\n+- ``ContractId a``\n+  Stores a reference to a contract of type ``a``.\n+- ``Int``\n+  Stores signed 64-bit integers. For example, ``-123``.\n+- ``Decimal``\n+  Stores fixed-point number with 28 digits before and 10 digits after the decimal point. For example, ``0.0000000001`` or ``-9999999999999999999999999999.9999999999``.\n+- ``Bool``\n+  Stores ``True`` or ``False``.\n+- ``Date``\n+  Stores a date.\n+- ``Time``\n+  Stores absolute UTC time.\n+- ``RelTime``\n+  Stores a difference in time.\n+\n+The below scenario instantiates each one of these types, manipulates it where appropriate, and tests the result.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- NATIVE_TEST_BEGIN\n+  :end-before: -- NATIVE_TEST_END\n+\n+Despite its simplicity, there are quite a few things to note in this scenario:\n+\n+- The ``import`` statements at the top import two packages from the DAML Standard Library, which contain all the date and time related functions we use here. More on packages, imports and the standard library later.\n+- Most of the variables are declared inside a ``let`` block.\n+\n+  That's because the ``scenario do`` block expects scenario actions like ``submit`` or ``getParty``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action.\n+- None of the variables have annotations to say what type they are.\n+\n+  That's because DAML is very good at *inferring* types. The compiler knows that ``123`` is an ``Int``, so if you declare ``my_int = 123``, it can infer that ``my_int`` is also an ``Int``. This means you don't have to write the type annotation ``my_int : Int = 123``.\n+\n+   However, if the type is ambiguous so that the compiler can't infer it, you do have to add a type annotation. And you can always choose to add them to aid readability.\n+- The ``assert`` function is an action that takes a boolean value and succeeds with ``True`` and fails with ``False``.\n+\n+  Try putting ``assert False`` somewhere in a scenario and see what happens to the scenario result.\n+\n+With templates and these native types, it's already possible to write a schema akin to a table in a relational database. Below, ``Token`` is extended into a simple ``CashBalance``, administered by a party in the role of an accountant.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+Assembling types\n+----------------\n+\n+There's quite a lot of information on the ``CashBalance`` above and it would be nice to be able to give that data more structure. Fortunately, DAML's type system has a number of ways to assemble these native types into much more expressive structures.\n+\n+Tuples\n+~~~~~~\n+\n+A common task is to group values in a generic way. Take, for example, a key-value pair with a ``Text`` key and an ``Int`` value. In DAML, you could use a two-tuple of type ``(Text, Int)`` to do so. If you wanted to express a coordinate in three dimensions, you could group three ``Decimal`` values using a three-tuple ``(Decimal, Decimal, Decimal)``.\n+\n+.. literalinclude:: daml/daml-intro-3/Tuple.daml\n+  :language: daml\n+  :start-after: -- TUPLE_TEST_BEGIN\n+  :end-before: -- TUPLE_TEST_END\n+\n+You can access the data in the tuples using:\n+\n+- functions ``fst``, ``snd``, ``fst3``, ``snd3``, ``thd3``\n+- a dot-syntax with field names ``_1``, ``_2``, ``_3``, etc.\n+\n+DAML supports tuples with up to 20 elements, but accessor functions like ``fst`` are only included for 2- and 3-tuples.\n+\n+Lists\n+~~~~~\n+\n+Lists in DAML take a single type parameter defining the type of thing in the list. So you can have a list of integers ``[Int]`` or a list of strings ``[Text]``, but not a list mixing integers and strings.\n+\n+That's because DAML is statically and strongly typed. When you get an element out of a list, the compiler needs to know what type that element has.\n+\n+The below scenario instantiates a few lists of integers and demonstrates the most important list functions.\n+\n+.. literalinclude:: daml/daml-intro-3/List.daml\n+  :language: daml\n+  :start-after: -- LIST_TEST_BEGIN\n+  :end-before: -- LIST_TEST_END\n+\n+Note the type annotation on ``empty : [Int] = []``. It's necessary because ``[]`` is ambiguous. It could be a list of integers or of strings, but the compiler needs to know which it is.\n+\n+Records\n+~~~~~~~\n+\n+You can think of records as named tuples with named fields. Declare them using the ``data`` keyword: ``data T = C with``, where ``T`` is the type name and ``C`` is the data constructor. In practice, it's a good idea to always use the same name for type and data constructor.\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- RECORD_TEST_BEGIN\n+  :end-before: -- RECORD_TEST_END\n+\n+You'll notice that the syntax to declare records is very similar to the syntax used to declare templates. That's no accident because a template is really just a special record. When you write ``template Token with``, one of the things that happens in the background is that this becomes a ``data Token = Token with``.\n+\n+In the ``assert`` statements above, we always compared values of in-built types. If you wrote ``assert (my_record == my_record)`` in the scenario, you may be surprised to get an error message ``No instance for (Eq MyRecord) arising from a use of ‘==’``. Equality in DAML is always value equality and we haven't written a function to check value equality for ``MyRecord`` values. But don't worry, you don't have to implement this rather obvious function yourself. The compiler is smart enough to do it for you, if you use ``deriving (Eq)``:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- EQ_TEST_BEGIN\n+  :end-before: -- EQ_TEST_END\n+\n+``Eq`` is what is called a *type-class*. You can think of a type-class as being like an interface in other languages: it is the mechanism by which you can define a set of functions (for example, ``==`` and ``/=`` in the case of ``Eq``) to work on multiple types, with a specific implementation for each type they can apply to.\n+\n+There are some other type-classes that the compiler can derive automatically. Most prominently, ``Show`` to get access to the function ``show`` (equivalent to ``toString`` in many languages) and ``Ord``, which gives access to comparison operators ``<``, ``>``, ``<=``, ``>=``.\n+\n+It's a good idea to always derive ``Eq`` and ``Show`` using ``deriving (Eq, Show)``. The record types created using ``template T with`` do this automatically.\n+\n+Records can give the data on ``CashBalance`` a bit more structure:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+If you look at the resulting scenario view, you'll see that this still gives rise to one table. The records are expanded out into columns using dot notation.\n+\n+Variants"
  },
  {
    "id" : "c98a2982-f287-43ee-9652-ba3235999f4b",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "ae8406f2-88f7-4b70-ab2a-0f56f0e6329d",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n```",
        "createdAt" : "2019-06-17T13:29:12Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,241 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+3 Data types\n+============\n+\n+In :doc:`1_Token`, you learnt about contract templates, which specify the types of contracts that can be created on the ledger, and what data those contracts hold in their arguments.\n+\n+In :doc:`2_Scenario`, you learnt about the scenario view in DAML Studio, which displays the current ledger state. It shows one table per template, with one row per contract of that type and one column per field in the arguments.\n+\n+This actually provides a useful way of thinking about templates: like tables in databases. Templates specify a data schema for the ledger:\n+\n+- each template corresponds to a table\n+- each field in the ``with`` block of a template corresponds to a column in that table\n+- each contract instance of that type corresponds to a table row\n+\n+In this section, you'll learn how to create rich data schemas for your ledger. Specifically you'll learn about:\n+\n+- DAML's built-in and native data types\n+- Record types\n+- Derivation of standard properties\n+- Variants\n+- Manipulating immutable data\n+- Contract keys\n+\n+After this section, you should be able to use a DAML ledger as a simple database where individual parties can write, read and delete complex data.\n+\n+Native Types\n+------------\n+\n+You have already encountered a few native DAML types: ``Party`` in :doc:`1_Token`, and ``Text`` and ``ContractId`` in :doc:`2_Scenario`. Here are those native types and more:\n+\n+- ``Party``\n+  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions. In general, ``Party`` is Oblique.\n+- ``Text``\n+  Stores a unicode character string like ``\"Alice\"``.\n+- ``ContractId a``\n+  Stores a reference to a contract of type ``a``.\n+- ``Int``\n+  Stores signed 64-bit integers. For example, ``-123``.\n+- ``Decimal``\n+  Stores fixed-point number with 28 digits before and 10 digits after the decimal point. For example, ``0.0000000001`` or ``-9999999999999999999999999999.9999999999``.\n+- ``Bool``\n+  Stores ``True`` or ``False``.\n+- ``Date``\n+  Stores a date.\n+- ``Time``\n+  Stores absolute UTC time.\n+- ``RelTime``\n+  Stores a difference in time.\n+\n+The below scenario instantiates each one of these types, manipulates it where appropriate, and tests the result.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- NATIVE_TEST_BEGIN\n+  :end-before: -- NATIVE_TEST_END\n+\n+Despite its simplicity, there are quite a few things to note in this scenario:\n+\n+- The ``import`` statements at the top import two packages from the DAML Standard Library, which contain all the date and time related functions we use here. More on packages, imports and the standard library later.\n+- Most of the variables are declared inside a ``let`` block.\n+\n+  That's because the ``scenario do`` block expects scenario actions like ``submit`` or ``getParty``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action.\n+- None of the variables have annotations to say what type they are.\n+\n+  That's because DAML is very good at *inferring* types. The compiler knows that ``123`` is an ``Int``, so if you declare ``my_int = 123``, it can infer that ``my_int`` is also an ``Int``. This means you don't have to write the type annotation ``my_int : Int = 123``.\n+\n+   However, if the type is ambiguous so that the compiler can't infer it, you do have to add a type annotation. And you can always choose to add them to aid readability.\n+- The ``assert`` function is an action that takes a boolean value and succeeds with ``True`` and fails with ``False``.\n+\n+  Try putting ``assert False`` somewhere in a scenario and see what happens to the scenario result.\n+\n+With templates and these native types, it's already possible to write a schema akin to a table in a relational database. Below, ``Token`` is extended into a simple ``CashBalance``, administered by a party in the role of an accountant.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+Assembling types\n+----------------\n+\n+There's quite a lot of information on the ``CashBalance`` above and it would be nice to be able to give that data more structure. Fortunately, DAML's type system has a number of ways to assemble these native types into much more expressive structures.\n+\n+Tuples\n+~~~~~~\n+\n+A common task is to group values in a generic way. Take, for example, a key-value pair with a ``Text`` key and an ``Int`` value. In DAML, you could use a two-tuple of type ``(Text, Int)`` to do so. If you wanted to express a coordinate in three dimensions, you could group three ``Decimal`` values using a three-tuple ``(Decimal, Decimal, Decimal)``.\n+\n+.. literalinclude:: daml/daml-intro-3/Tuple.daml\n+  :language: daml\n+  :start-after: -- TUPLE_TEST_BEGIN\n+  :end-before: -- TUPLE_TEST_END\n+\n+You can access the data in the tuples using:\n+\n+- functions ``fst``, ``snd``, ``fst3``, ``snd3``, ``thd3``\n+- a dot-syntax with field names ``_1``, ``_2``, ``_3``, etc.\n+\n+DAML supports tuples with up to 20 elements, but accessor functions like ``fst`` are only included for 2- and 3-tuples.\n+\n+Lists\n+~~~~~\n+\n+Lists in DAML take a single type parameter defining the type of thing in the list. So you can have a list of integers ``[Int]`` or a list of strings ``[Text]``, but not a list mixing integers and strings.\n+\n+That's because DAML is statically and strongly typed. When you get an element out of a list, the compiler needs to know what type that element has.\n+\n+The below scenario instantiates a few lists of integers and demonstrates the most important list functions.\n+\n+.. literalinclude:: daml/daml-intro-3/List.daml\n+  :language: daml\n+  :start-after: -- LIST_TEST_BEGIN\n+  :end-before: -- LIST_TEST_END\n+\n+Note the type annotation on ``empty : [Int] = []``. It's necessary because ``[]`` is ambiguous. It could be a list of integers or of strings, but the compiler needs to know which it is.\n+\n+Records\n+~~~~~~~\n+\n+You can think of records as named tuples with named fields. Declare them using the ``data`` keyword: ``data T = C with``, where ``T`` is the type name and ``C`` is the data constructor. In practice, it's a good idea to always use the same name for type and data constructor.\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- RECORD_TEST_BEGIN\n+  :end-before: -- RECORD_TEST_END\n+\n+You'll notice that the syntax to declare records is very similar to the syntax used to declare templates. That's no accident because a template is really just a special record. When you write ``template Token with``, one of the things that happens in the background is that this becomes a ``data Token = Token with``.\n+\n+In the ``assert`` statements above, we always compared values of in-built types. If you wrote ``assert (my_record == my_record)`` in the scenario, you may be surprised to get an error message ``No instance for (Eq MyRecord) arising from a use of ‘==’``. Equality in DAML is always value equality and we haven't written a function to check value equality for ``MyRecord`` values. But don't worry, you don't have to implement this rather obvious function yourself. The compiler is smart enough to do it for you, if you use ``deriving (Eq)``:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- EQ_TEST_BEGIN\n+  :end-before: -- EQ_TEST_END\n+\n+``Eq`` is what is called a *type-class*. You can think of a type-class as being like an interface in other languages: it is the mechanism by which you can define a set of functions (for example, ``==`` and ``/=`` in the case of ``Eq``) to work on multiple types, with a specific implementation for each type they can apply to.\n+\n+There are some other type-classes that the compiler can derive automatically. Most prominently, ``Show`` to get access to the function ``show`` (equivalent to ``toString`` in many languages) and ``Ord``, which gives access to comparison operators ``<``, ``>``, ``<=``, ``>=``.\n+\n+It's a good idea to always derive ``Eq`` and ``Show`` using ``deriving (Eq, Show)``. The record types created using ``template T with`` do this automatically.\n+\n+Records can give the data on ``CashBalance`` a bit more structure:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+If you look at the resulting scenario view, you'll see that this still gives rise to one table. The records are expanded out into columns using dot notation.\n+\n+Variants\n+~~~~~~~~"
  },
  {
    "id" : "6a6973c7-1052-4362-bf43-4b170071eb26",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "0f65bcee-4cba-4ff8-a316-d89b6137d352",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "sentence case\r\n```suggestion\r\nManipulating data\r\n```",
        "createdAt" : "2019-06-17T13:29:29Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,241 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+3 Data types\n+============\n+\n+In :doc:`1_Token`, you learnt about contract templates, which specify the types of contracts that can be created on the ledger, and what data those contracts hold in their arguments.\n+\n+In :doc:`2_Scenario`, you learnt about the scenario view in DAML Studio, which displays the current ledger state. It shows one table per template, with one row per contract of that type and one column per field in the arguments.\n+\n+This actually provides a useful way of thinking about templates: like tables in databases. Templates specify a data schema for the ledger:\n+\n+- each template corresponds to a table\n+- each field in the ``with`` block of a template corresponds to a column in that table\n+- each contract instance of that type corresponds to a table row\n+\n+In this section, you'll learn how to create rich data schemas for your ledger. Specifically you'll learn about:\n+\n+- DAML's built-in and native data types\n+- Record types\n+- Derivation of standard properties\n+- Variants\n+- Manipulating immutable data\n+- Contract keys\n+\n+After this section, you should be able to use a DAML ledger as a simple database where individual parties can write, read and delete complex data.\n+\n+Native Types\n+------------\n+\n+You have already encountered a few native DAML types: ``Party`` in :doc:`1_Token`, and ``Text`` and ``ContractId`` in :doc:`2_Scenario`. Here are those native types and more:\n+\n+- ``Party``\n+  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions. In general, ``Party`` is Oblique.\n+- ``Text``\n+  Stores a unicode character string like ``\"Alice\"``.\n+- ``ContractId a``\n+  Stores a reference to a contract of type ``a``.\n+- ``Int``\n+  Stores signed 64-bit integers. For example, ``-123``.\n+- ``Decimal``\n+  Stores fixed-point number with 28 digits before and 10 digits after the decimal point. For example, ``0.0000000001`` or ``-9999999999999999999999999999.9999999999``.\n+- ``Bool``\n+  Stores ``True`` or ``False``.\n+- ``Date``\n+  Stores a date.\n+- ``Time``\n+  Stores absolute UTC time.\n+- ``RelTime``\n+  Stores a difference in time.\n+\n+The below scenario instantiates each one of these types, manipulates it where appropriate, and tests the result.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- NATIVE_TEST_BEGIN\n+  :end-before: -- NATIVE_TEST_END\n+\n+Despite its simplicity, there are quite a few things to note in this scenario:\n+\n+- The ``import`` statements at the top import two packages from the DAML Standard Library, which contain all the date and time related functions we use here. More on packages, imports and the standard library later.\n+- Most of the variables are declared inside a ``let`` block.\n+\n+  That's because the ``scenario do`` block expects scenario actions like ``submit`` or ``getParty``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action.\n+- None of the variables have annotations to say what type they are.\n+\n+  That's because DAML is very good at *inferring* types. The compiler knows that ``123`` is an ``Int``, so if you declare ``my_int = 123``, it can infer that ``my_int`` is also an ``Int``. This means you don't have to write the type annotation ``my_int : Int = 123``.\n+\n+   However, if the type is ambiguous so that the compiler can't infer it, you do have to add a type annotation. And you can always choose to add them to aid readability.\n+- The ``assert`` function is an action that takes a boolean value and succeeds with ``True`` and fails with ``False``.\n+\n+  Try putting ``assert False`` somewhere in a scenario and see what happens to the scenario result.\n+\n+With templates and these native types, it's already possible to write a schema akin to a table in a relational database. Below, ``Token`` is extended into a simple ``CashBalance``, administered by a party in the role of an accountant.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+Assembling types\n+----------------\n+\n+There's quite a lot of information on the ``CashBalance`` above and it would be nice to be able to give that data more structure. Fortunately, DAML's type system has a number of ways to assemble these native types into much more expressive structures.\n+\n+Tuples\n+~~~~~~\n+\n+A common task is to group values in a generic way. Take, for example, a key-value pair with a ``Text`` key and an ``Int`` value. In DAML, you could use a two-tuple of type ``(Text, Int)`` to do so. If you wanted to express a coordinate in three dimensions, you could group three ``Decimal`` values using a three-tuple ``(Decimal, Decimal, Decimal)``.\n+\n+.. literalinclude:: daml/daml-intro-3/Tuple.daml\n+  :language: daml\n+  :start-after: -- TUPLE_TEST_BEGIN\n+  :end-before: -- TUPLE_TEST_END\n+\n+You can access the data in the tuples using:\n+\n+- functions ``fst``, ``snd``, ``fst3``, ``snd3``, ``thd3``\n+- a dot-syntax with field names ``_1``, ``_2``, ``_3``, etc.\n+\n+DAML supports tuples with up to 20 elements, but accessor functions like ``fst`` are only included for 2- and 3-tuples.\n+\n+Lists\n+~~~~~\n+\n+Lists in DAML take a single type parameter defining the type of thing in the list. So you can have a list of integers ``[Int]`` or a list of strings ``[Text]``, but not a list mixing integers and strings.\n+\n+That's because DAML is statically and strongly typed. When you get an element out of a list, the compiler needs to know what type that element has.\n+\n+The below scenario instantiates a few lists of integers and demonstrates the most important list functions.\n+\n+.. literalinclude:: daml/daml-intro-3/List.daml\n+  :language: daml\n+  :start-after: -- LIST_TEST_BEGIN\n+  :end-before: -- LIST_TEST_END\n+\n+Note the type annotation on ``empty : [Int] = []``. It's necessary because ``[]`` is ambiguous. It could be a list of integers or of strings, but the compiler needs to know which it is.\n+\n+Records\n+~~~~~~~\n+\n+You can think of records as named tuples with named fields. Declare them using the ``data`` keyword: ``data T = C with``, where ``T`` is the type name and ``C`` is the data constructor. In practice, it's a good idea to always use the same name for type and data constructor.\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- RECORD_TEST_BEGIN\n+  :end-before: -- RECORD_TEST_END\n+\n+You'll notice that the syntax to declare records is very similar to the syntax used to declare templates. That's no accident because a template is really just a special record. When you write ``template Token with``, one of the things that happens in the background is that this becomes a ``data Token = Token with``.\n+\n+In the ``assert`` statements above, we always compared values of in-built types. If you wrote ``assert (my_record == my_record)`` in the scenario, you may be surprised to get an error message ``No instance for (Eq MyRecord) arising from a use of ‘==’``. Equality in DAML is always value equality and we haven't written a function to check value equality for ``MyRecord`` values. But don't worry, you don't have to implement this rather obvious function yourself. The compiler is smart enough to do it for you, if you use ``deriving (Eq)``:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- EQ_TEST_BEGIN\n+  :end-before: -- EQ_TEST_END\n+\n+``Eq`` is what is called a *type-class*. You can think of a type-class as being like an interface in other languages: it is the mechanism by which you can define a set of functions (for example, ``==`` and ``/=`` in the case of ``Eq``) to work on multiple types, with a specific implementation for each type they can apply to.\n+\n+There are some other type-classes that the compiler can derive automatically. Most prominently, ``Show`` to get access to the function ``show`` (equivalent to ``toString`` in many languages) and ``Ord``, which gives access to comparison operators ``<``, ``>``, ``<=``, ``>=``.\n+\n+It's a good idea to always derive ``Eq`` and ``Show`` using ``deriving (Eq, Show)``. The record types created using ``template T with`` do this automatically.\n+\n+Records can give the data on ``CashBalance`` a bit more structure:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+If you look at the resulting scenario view, you'll see that this still gives rise to one table. The records are expanded out into columns using dot notation.\n+\n+Variants\n+~~~~~~~~\n+\n+Suppose now that you also wanted to keep track of cash in hand. Cash in hand doesn't have a bank, but you can't just leave ``bank`` empty. DAML doesn't have an equivalent to ``null``. Variants can express that cash can either be in hand or at a bank.\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+The way to read the declaration of ``Location`` is \"*A Location either has value* ``InHand`` *OR has a value* ``InAccount a`` *where* ``a`` *is of type Account*\". This is quite an explicit way to say that there may or may not be an ``Account`` associated with a ``CashBalance`` and gives both cases suggestive names.\n+\n+Another option is to use the built-in ``Optional`` type. The ``None`` value of type ``Optional a`` is the closest DAML has to a ``null`` value:\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- OPTIONAL_BEGIN\n+  :end-before: -- OPTIONAL_END\n+\n+Variant types where none of the data constructors take a parameter are called enums:\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- ENUM_BEGIN\n+  :end-before: -- ENUM_END\n+\n+To access the data in variants, you need to distinguish the different possible cases. For example, you can no longer access the account number of a ``Location`` directly, because if it is ``InHand``, there may be no account number.\n+\n+To do this, you can use *pattern matching* and either throw errors or return compatible types for all cases:\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- VARIANT_ACCESS_BEGIN\n+  :end-before: -- VARIANT_ACCESS_END\n+\n+Manipulating Data"
  },
  {
    "id" : "4db64917-fa4e-4b46-b445-eb19e3485d89",
    "prId" : 1717,
    "comments" : [
      {
        "id" : "6d835cf1-605a-4b3f-9f99-0e7f911740bc",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "```suggestion\r\nNext up\r\n```",
        "createdAt" : "2019-06-17T13:29:42Z",
        "updatedAt" : "2019-06-18T09:05:02Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "64d0389f2c6ccd0a16f369739cc879b850f52d78",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,241 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+3 Data types\n+============\n+\n+In :doc:`1_Token`, you learnt about contract templates, which specify the types of contracts that can be created on the ledger, and what data those contracts hold in their arguments.\n+\n+In :doc:`2_Scenario`, you learnt about the scenario view in DAML Studio, which displays the current ledger state. It shows one table per template, with one row per contract of that type and one column per field in the arguments.\n+\n+This actually provides a useful way of thinking about templates: like tables in databases. Templates specify a data schema for the ledger:\n+\n+- each template corresponds to a table\n+- each field in the ``with`` block of a template corresponds to a column in that table\n+- each contract instance of that type corresponds to a table row\n+\n+In this section, you'll learn how to create rich data schemas for your ledger. Specifically you'll learn about:\n+\n+- DAML's built-in and native data types\n+- Record types\n+- Derivation of standard properties\n+- Variants\n+- Manipulating immutable data\n+- Contract keys\n+\n+After this section, you should be able to use a DAML ledger as a simple database where individual parties can write, read and delete complex data.\n+\n+Native Types\n+------------\n+\n+You have already encountered a few native DAML types: ``Party`` in :doc:`1_Token`, and ``Text`` and ``ContractId`` in :doc:`2_Scenario`. Here are those native types and more:\n+\n+- ``Party``\n+  Stores the identity of an entity that is able to act on the ledger, in the sense that they can sign contracts and submit transactions. In general, ``Party`` is Oblique.\n+- ``Text``\n+  Stores a unicode character string like ``\"Alice\"``.\n+- ``ContractId a``\n+  Stores a reference to a contract of type ``a``.\n+- ``Int``\n+  Stores signed 64-bit integers. For example, ``-123``.\n+- ``Decimal``\n+  Stores fixed-point number with 28 digits before and 10 digits after the decimal point. For example, ``0.0000000001`` or ``-9999999999999999999999999999.9999999999``.\n+- ``Bool``\n+  Stores ``True`` or ``False``.\n+- ``Date``\n+  Stores a date.\n+- ``Time``\n+  Stores absolute UTC time.\n+- ``RelTime``\n+  Stores a difference in time.\n+\n+The below scenario instantiates each one of these types, manipulates it where appropriate, and tests the result.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- NATIVE_TEST_BEGIN\n+  :end-before: -- NATIVE_TEST_END\n+\n+Despite its simplicity, there are quite a few things to note in this scenario:\n+\n+- The ``import`` statements at the top import two packages from the DAML Standard Library, which contain all the date and time related functions we use here. More on packages, imports and the standard library later.\n+- Most of the variables are declared inside a ``let`` block.\n+\n+  That's because the ``scenario do`` block expects scenario actions like ``submit`` or ``getParty``. An integer like ``123`` is not an action, it's a pure expression, something we can evaluate without any ledger. You can think of the ``let`` as turning variable declaration into an action.\n+- None of the variables have annotations to say what type they are.\n+\n+  That's because DAML is very good at *inferring* types. The compiler knows that ``123`` is an ``Int``, so if you declare ``my_int = 123``, it can infer that ``my_int`` is also an ``Int``. This means you don't have to write the type annotation ``my_int : Int = 123``.\n+\n+   However, if the type is ambiguous so that the compiler can't infer it, you do have to add a type annotation. And you can always choose to add them to aid readability.\n+- The ``assert`` function is an action that takes a boolean value and succeeds with ``True`` and fails with ``False``.\n+\n+  Try putting ``assert False`` somewhere in a scenario and see what happens to the scenario result.\n+\n+With templates and these native types, it's already possible to write a schema akin to a table in a relational database. Below, ``Token`` is extended into a simple ``CashBalance``, administered by a party in the role of an accountant.\n+\n+.. literalinclude:: daml/daml-intro-3/Native.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+Assembling types\n+----------------\n+\n+There's quite a lot of information on the ``CashBalance`` above and it would be nice to be able to give that data more structure. Fortunately, DAML's type system has a number of ways to assemble these native types into much more expressive structures.\n+\n+Tuples\n+~~~~~~\n+\n+A common task is to group values in a generic way. Take, for example, a key-value pair with a ``Text`` key and an ``Int`` value. In DAML, you could use a two-tuple of type ``(Text, Int)`` to do so. If you wanted to express a coordinate in three dimensions, you could group three ``Decimal`` values using a three-tuple ``(Decimal, Decimal, Decimal)``.\n+\n+.. literalinclude:: daml/daml-intro-3/Tuple.daml\n+  :language: daml\n+  :start-after: -- TUPLE_TEST_BEGIN\n+  :end-before: -- TUPLE_TEST_END\n+\n+You can access the data in the tuples using:\n+\n+- functions ``fst``, ``snd``, ``fst3``, ``snd3``, ``thd3``\n+- a dot-syntax with field names ``_1``, ``_2``, ``_3``, etc.\n+\n+DAML supports tuples with up to 20 elements, but accessor functions like ``fst`` are only included for 2- and 3-tuples.\n+\n+Lists\n+~~~~~\n+\n+Lists in DAML take a single type parameter defining the type of thing in the list. So you can have a list of integers ``[Int]`` or a list of strings ``[Text]``, but not a list mixing integers and strings.\n+\n+That's because DAML is statically and strongly typed. When you get an element out of a list, the compiler needs to know what type that element has.\n+\n+The below scenario instantiates a few lists of integers and demonstrates the most important list functions.\n+\n+.. literalinclude:: daml/daml-intro-3/List.daml\n+  :language: daml\n+  :start-after: -- LIST_TEST_BEGIN\n+  :end-before: -- LIST_TEST_END\n+\n+Note the type annotation on ``empty : [Int] = []``. It's necessary because ``[]`` is ambiguous. It could be a list of integers or of strings, but the compiler needs to know which it is.\n+\n+Records\n+~~~~~~~\n+\n+You can think of records as named tuples with named fields. Declare them using the ``data`` keyword: ``data T = C with``, where ``T`` is the type name and ``C`` is the data constructor. In practice, it's a good idea to always use the same name for type and data constructor.\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- RECORD_TEST_BEGIN\n+  :end-before: -- RECORD_TEST_END\n+\n+You'll notice that the syntax to declare records is very similar to the syntax used to declare templates. That's no accident because a template is really just a special record. When you write ``template Token with``, one of the things that happens in the background is that this becomes a ``data Token = Token with``.\n+\n+In the ``assert`` statements above, we always compared values of in-built types. If you wrote ``assert (my_record == my_record)`` in the scenario, you may be surprised to get an error message ``No instance for (Eq MyRecord) arising from a use of ‘==’``. Equality in DAML is always value equality and we haven't written a function to check value equality for ``MyRecord`` values. But don't worry, you don't have to implement this rather obvious function yourself. The compiler is smart enough to do it for you, if you use ``deriving (Eq)``:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- EQ_TEST_BEGIN\n+  :end-before: -- EQ_TEST_END\n+\n+``Eq`` is what is called a *type-class*. You can think of a type-class as being like an interface in other languages: it is the mechanism by which you can define a set of functions (for example, ``==`` and ``/=`` in the case of ``Eq``) to work on multiple types, with a specific implementation for each type they can apply to.\n+\n+There are some other type-classes that the compiler can derive automatically. Most prominently, ``Show`` to get access to the function ``show`` (equivalent to ``toString`` in many languages) and ``Ord``, which gives access to comparison operators ``<``, ``>``, ``<=``, ``>=``.\n+\n+It's a good idea to always derive ``Eq`` and ``Show`` using ``deriving (Eq, Show)``. The record types created using ``template T with`` do this automatically.\n+\n+Records can give the data on ``CashBalance`` a bit more structure:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+If you look at the resulting scenario view, you'll see that this still gives rise to one table. The records are expanded out into columns using dot notation.\n+\n+Variants\n+~~~~~~~~\n+\n+Suppose now that you also wanted to keep track of cash in hand. Cash in hand doesn't have a bank, but you can't just leave ``bank`` empty. DAML doesn't have an equivalent to ``null``. Variants can express that cash can either be in hand or at a bank.\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- CASH_BALANCE_BEGIN\n+  :end-before: -- CASH_BALANCE_END\n+\n+The way to read the declaration of ``Location`` is \"*A Location either has value* ``InHand`` *OR has a value* ``InAccount a`` *where* ``a`` *is of type Account*\". This is quite an explicit way to say that there may or may not be an ``Account`` associated with a ``CashBalance`` and gives both cases suggestive names.\n+\n+Another option is to use the built-in ``Optional`` type. The ``None`` value of type ``Optional a`` is the closest DAML has to a ``null`` value:\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- OPTIONAL_BEGIN\n+  :end-before: -- OPTIONAL_END\n+\n+Variant types where none of the data constructors take a parameter are called enums:\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- ENUM_BEGIN\n+  :end-before: -- ENUM_END\n+\n+To access the data in variants, you need to distinguish the different possible cases. For example, you can no longer access the account number of a ``Location`` directly, because if it is ``InHand``, there may be no account number.\n+\n+To do this, you can use *pattern matching* and either throw errors or return compatible types for all cases:\n+\n+.. literalinclude:: daml/daml-intro-3/Variants.daml\n+  :language: daml\n+  :start-after: -- VARIANT_ACCESS_BEGIN\n+  :end-before: -- VARIANT_ACCESS_END\n+\n+Manipulating Data\n+-----------------\n+\n+You've got all the ingredients to build rich types expressing the data you want to be able to write to the ledger, and you have seen how to create new values and read fields from values. But how do you manipulate values once created?\n+\n+All data in DAML is immutable, meaning once a value is created, it will never change. Rather than changing values, you create new values based on old ones with some changes applied:\n+\n+.. literalinclude:: daml/daml-intro-3/Record.daml\n+  :language: daml\n+  :start-after: -- MANIPULATION_BEGIN\n+  :end-before: -- MANIPULATION_END\n+\n+``changed_record`` and ``better_changed_record`` are each a copy of ``eq_record`` with the field ``my_int`` changed. ``better_changed_record`` shows the recommended way to change fields on a record. The syntax is almost the same as for a new record, but the record name is replaced with the old value: ``eq_record with`` instead of ``EqRecord with``. The ``with`` block no longer needs to give values to all fields of ``EqRecord``. Any missing fields are taken from ``eq_record``.\n+\n+Throughout the scenario, ``eq_record`` never changes. The expression ``\"Zero\" :: eq_record.my_list`` doesn't change the list in-place, but creates a new list, which is ``eq_record.my_list`` with an extra element in the beginning.\n+\n+.. _contract_keys:\n+\n+Contract keys\n+-------------\n+\n+DAML's type system lets you store richly structured data on DAML templates, but just like most database schemas have more than one table, DAML contract models often have multiple templates that reference each other. For example, you may not want to store your bank and account information on each individual cash balance contract, but instead store those on separate contracts.\n+\n+You have already met the type ``ContractId a``, which references a contract of type ``a``. The below shows a contract model where ``Account`` is split out into a separate template and referenced by ``ContractId``, but it also highlights a big problem with that kind of reference: just like data, contracts are immutable. They can only be created and archived, so if you want to change the data on a contract, you end up archiving the original contract and creating a new one with the changed data. That makes contract IDs very unstable, and can cause stale references.\n+\n+.. literalinclude:: daml/daml-intro-3/IDRef.daml\n+  :language: daml\n+  :start-after: -- ID_REF_TEST_BEGIN\n+  :end-before: -- ID_REF_TEST_END\n+\n+The scenario above uses the ``fetch`` function, which retrieves the arguments of an active contract using its contract ID.\n+\n+Note that, for the first time, the party submitting a transaction is doing more than one thing as part of that transaction. To create ``new_account``, the accountant fetches the arguments of the old account, archives the old account and creates a new account, all in one transaction. More on building transactions in :doc:`7_Composing`.\n+\n+You can define *stable* keys for contracts using the ``key`` and ``maintainer`` keywords. ``key`` defines the primary key of a template, with the ability to look up contracts by key, and a uniqueness constraint in the sense that only one contract of a given template and with a given key value can be active at a time.\n+\n+.. literalinclude:: daml/daml-intro-3/Keys.daml\n+  :language: daml\n+  :start-after: -- KEY_TEST_BEGIN\n+  :end-before: -- KEY_TEST_END\n+\n+Since DAML is designed to run on distributed systems, you have to assume that there is no global entity that can guarantee uniqueness, which is why each ``key`` expression must come with a ``maintainer`` expression. ``maintainer`` takes one or several parties, all of which have to be signatories of the contract and be part of the key. That way the index can be partitioned amongst sets of maintainers, and each set of maintainers can independently ensure the uniqueness constraint on their piece of the index. The constraint that maintainters are part of the key is ensured by only having the variable `key`\n+\n+Note how the ``fetch`` in the final ``submit`` block has become a ``fetchByKey @Account``. ``fetchByKey @Account`` takes a value of type ``AccountKey`` and returns a tuple ``(ContractId Account, Account)`` if the lookup was successful or fails the transaction otherwise.\n+\n+Since a single type could be used as the key for multiple templates, you need to tell the compiler what type of contract is being fetched by using the ``@Account`` notation.\n+\n+\n+Next Up"
  }
]