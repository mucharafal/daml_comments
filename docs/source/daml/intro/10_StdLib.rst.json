[
  {
    "id" : "72055cb5-0c64-40fd-970f-6a933408bcfb",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "ec7d9b3d-b750-4bbb-aa7c-f961a11ae122",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nIn chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with the DAML Standard Library which contains types, functions, and typeclasses that cover a large range of use-cases. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\r\n```",
        "createdAt" : "2020-09-29T13:54:29Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:"
  },
  {
    "id" : "8db5fbea-2222-4e61-9ee1-ad56e7bd3229",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "5b487fd5-b599-4d0e-a5bf-b080c51424f1",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\n- Important typeclasses like ``Functor``, ``Foldable``, and ``Traversable``\r\n```",
        "createdAt" : "2020-09-29T13:55:15Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``"
  },
  {
    "id" : "8627bf67-3d27-48c1-b28e-5be420e43b89",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "57586885-9011-41e9-830c-b93ad578f458",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nTo go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad`` in Haskell), and many more, are the bread and butter of Haskell programmers.\r\n```",
        "createdAt" : "2020-09-29T14:16:58Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers."
  },
  {
    "id" : "e4ae153d-2742-406b-90eb-4a812820bc59",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "ae4f3d96-ab13-439b-b6ba-901ecaa96d98",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nYou've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. In fact ``[1,2]`` is just syntactical sugar for ``1 :: 2 :: []``. \r\n```",
        "createdAt" : "2020-09-29T14:19:59Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. "
  },
  {
    "id" : "47dd0015-bb62-4a3c-9d7e-f8ef6a8fa321",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "05c04034-c2c8-4746-9b2e-82acf3f2c2e6",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "tuple -> tuples\r\n```suggestion\r\nIn addition to the 2-tuple you have already seen, the Prelude contains definitions for tuples of size up to 15.\r\nTuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions\r\nconsisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. \r\nAn example of a relatively wide Tuple can be found in the test modules of the chapter 8 project.\r\n``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple.\r\n``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\r\n```",
        "createdAt" : "2020-09-29T14:23:47Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching."
  },
  {
    "id" : "720b4a1f-db76-491e-8e11-1706bce2b839",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "32284f4d-0069-4faa-b453-f229db6d41ed",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Missed a \\`\r\n\r\n```suggestion\r\n``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional``, except that values with constructor ``Left`` have a text associated to them.\r\n```",
        "createdAt" : "2020-09-29T14:29:19Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them."
  },
  {
    "id" : "e3216e06-1669-4f3a-ba11-d59326d559fe",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "76730f21-3d69-48dd-bfde-30c913abb4dc",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\n  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own more explicit type instead. For example if you were returning ``South a`` vs ``North b`` using your own type over ``Either`` would make your code clearer.\r\n```",
        "createdAt" : "2020-09-29T14:42:11Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them.\n+\n+.. note::\n+\n+  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own type instead."
  },
  {
    "id" : "3eaffb8b-98f7-42be-8381-fa8655d519a0",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "a2c5a7be-2a05-4697-b4c1-7d699b321520",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nThe ``Ord`` typeclass allows values of a type to be compared for order. It makes available functions: ``<``, ``>``, ``<=``, and ``>=``. Most of the inbuilt data types have an instance of ``Ord``. Furthermore, types like ``List`` and ``Optional`` get an instance of ``Ord`` if the type they contain has one. You can let the compiler automatically derive instances of ``Ord`` for you using the ``deriving`` keyword.\r\n```",
        "createdAt" : "2020-09-29T14:52:18Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them.\n+\n+.. note::\n+\n+  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own type instead.\n+\n+Typeclasses\n+-----------\n+\n+You've seen typeclasses in use all the way from :doc:`3_Data`. It's now time to look under the hood.\n+\n+Typeclasses are declared using the ``class`` keyword:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CLASS_BEGIN\n+  :end-before: -- CLASS_END\n+\n+This is akin to an interface declaration of an interface with a getter and setter for a quantity. To *implement* this interface, you need to define instances of this typeclass:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INSTANCE_BEGIN\n+  :end-before: -- INSTANCE_END\n+\n+Typeclasses can have constraints like functions. For example: ``class Eq a => Ord a`` means \"everything that is orderable can also be compared for equality\". And that's almost all there's to it. \n+\n+Important Typeclasses from the Prelude\n+--------------------------------------\n+\n+Eq\n+...\n+\n+The ``Eq`` typeclass allows values of a type to be compared for (in)-equality. It makes available two function: ``==`` and ``/=``. Most data types from the Standard Library have an instance of ``Eq``. As you already learned in :doc:`3_Data`, you can let the compiler automatically derive instances of ``Eq`` for you using the ``deriving`` keyword.\n+\n+Templates always have an ``Eq`` instance, and all types stored on a template need to have one.\n+\n+Ord\n+...\n+\n+The ``Ord`` typeclass allows values of a type to be compared for order. It makes available functions: ``<``, ``>``, ``<=``, and ``>=``. Most of the inbuilt data types have an instance of ``Ord``. Furthermore, types like ``List`` and ``Optional`` get an instance of ``Ord`` if the type they contain has one. You can automatically derive instances of ``Ord`` for you using the ``deriving`` keyword."
  },
  {
    "id" : "ee556aac-018b-48fd-8497-8248fac28bf9",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "e2bfa149-bf10-4527-abd3-87f186fb5da2",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\n``Show`` indicates that a type can be serialized to ``Text``, ie \"shown\" in a shell. Its key function is ``show``, which takes a value and converts it to ``Text``. All inbuilt data types have an instance for ``Show`` and types like ``List`` and ``Optional`` get an instance if the type they contain has one. It also supports the ``deriving`` keyword.\r\n```",
        "createdAt" : "2020-09-29T14:53:37Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them.\n+\n+.. note::\n+\n+  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own type instead.\n+\n+Typeclasses\n+-----------\n+\n+You've seen typeclasses in use all the way from :doc:`3_Data`. It's now time to look under the hood.\n+\n+Typeclasses are declared using the ``class`` keyword:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CLASS_BEGIN\n+  :end-before: -- CLASS_END\n+\n+This is akin to an interface declaration of an interface with a getter and setter for a quantity. To *implement* this interface, you need to define instances of this typeclass:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INSTANCE_BEGIN\n+  :end-before: -- INSTANCE_END\n+\n+Typeclasses can have constraints like functions. For example: ``class Eq a => Ord a`` means \"everything that is orderable can also be compared for equality\". And that's almost all there's to it. \n+\n+Important Typeclasses from the Prelude\n+--------------------------------------\n+\n+Eq\n+...\n+\n+The ``Eq`` typeclass allows values of a type to be compared for (in)-equality. It makes available two function: ``==`` and ``/=``. Most data types from the Standard Library have an instance of ``Eq``. As you already learned in :doc:`3_Data`, you can let the compiler automatically derive instances of ``Eq`` for you using the ``deriving`` keyword.\n+\n+Templates always have an ``Eq`` instance, and all types stored on a template need to have one.\n+\n+Ord\n+...\n+\n+The ``Ord`` typeclass allows values of a type to be compared for order. It makes available functions: ``<``, ``>``, ``<=``, and ``>=``. Most of the inbuilt data types have an instance of ``Ord``. Furthermore, types like ``List`` and ``Optional`` get an instance of ``Ord`` if the type they contain has one. You can automatically derive instances of ``Ord`` for you using the ``deriving`` keyword.\n+\n+Show\n+....\n+\n+``Show`` indicates that a type can be serialized to ``Text``, ie \"shown\" in a shell. It's key function is ``show``, which takes a value and converts it to ``Text``. All inbuilt data types have an instance for ``Show`` and types like ``List`` and ``Optional`` get an instance if the type they contain has one. It also supports the ``deriving`` keyword."
  },
  {
    "id" : "a8375313-329d-426b-9564-d065c126b977",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "99950f32-3ac8-47d4-9ab9-ba22237dcd2a",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "This `ref` link isn't working.\r\n\r\n```suggestion\r\n:ref:`Functors <class-ghc-base-functor-73448>` are the closest thing to \"containers\" that DAML has. Whenever you see a type with a single type parameter, you are probably looking at a ``Functor``: ``[a]``, ``Optional a``, ``Either Text a``, ``Update a``. Functors are things that can be mapped over and as such, the key function of ``Functor`` is ``fmap``, which does generically what the ``map`` function does for lists.\r\n```",
        "createdAt" : "2020-09-29T14:57:27Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them.\n+\n+.. note::\n+\n+  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own type instead.\n+\n+Typeclasses\n+-----------\n+\n+You've seen typeclasses in use all the way from :doc:`3_Data`. It's now time to look under the hood.\n+\n+Typeclasses are declared using the ``class`` keyword:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CLASS_BEGIN\n+  :end-before: -- CLASS_END\n+\n+This is akin to an interface declaration of an interface with a getter and setter for a quantity. To *implement* this interface, you need to define instances of this typeclass:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INSTANCE_BEGIN\n+  :end-before: -- INSTANCE_END\n+\n+Typeclasses can have constraints like functions. For example: ``class Eq a => Ord a`` means \"everything that is orderable can also be compared for equality\". And that's almost all there's to it. \n+\n+Important Typeclasses from the Prelude\n+--------------------------------------\n+\n+Eq\n+...\n+\n+The ``Eq`` typeclass allows values of a type to be compared for (in)-equality. It makes available two function: ``==`` and ``/=``. Most data types from the Standard Library have an instance of ``Eq``. As you already learned in :doc:`3_Data`, you can let the compiler automatically derive instances of ``Eq`` for you using the ``deriving`` keyword.\n+\n+Templates always have an ``Eq`` instance, and all types stored on a template need to have one.\n+\n+Ord\n+...\n+\n+The ``Ord`` typeclass allows values of a type to be compared for order. It makes available functions: ``<``, ``>``, ``<=``, and ``>=``. Most of the inbuilt data types have an instance of ``Ord``. Furthermore, types like ``List`` and ``Optional`` get an instance of ``Ord`` if the type they contain has one. You can automatically derive instances of ``Ord`` for you using the ``deriving`` keyword.\n+\n+Show\n+....\n+\n+``Show`` indicates that a type can be serialized to ``Text``, ie \"shown\" in a shell. It's key function is ``show``, which takes a value and converts it to ``Text``. All inbuilt data types have an instance for ``Show`` and types like ``List`` and ``Optional`` get an instance if the type they contain has one. It also supports the ``deriving`` keyword.\n+\n+Functor\n+.......\n+\n+:ref:`Functors <class-ghc-base-functor-73448>` are the closest thing to \"containers\" DAML has. Whenever you see a type with a single type parameter, you are probably looking at a ``Functor``: ``[a]``, ``Optional a``, ``Either Text a``, ``Update a``. Functors are things that can be mapped over and as such, the key function of ``Functor`` is ``fmap``, which does generically what the ``map`` function does for lists."
  },
  {
    "id" : "d88fab27-2562-4c5a-9b61-e11588a073f2",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "21e1c664-d53b-4d46-99dd-42208b54c599",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\n:ref:`Applicative Functors <class-da-internal-prelude-applicative-43914>` are a bit like Actions, which you met in :doc:`5_Restrictions`, except that you can't use the result of one action as the input to another action. The only important Applicative Functor that isn't an action in DAML is the ``Commands`` type submitted in a ``submit`` block in DAML Script. That's why in order to use ``do`` notation in DAML Script, you have to enable the ``ApplicativeDo`` language extension.\r\n```",
        "createdAt" : "2020-09-29T16:18:43Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them.\n+\n+.. note::\n+\n+  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own type instead.\n+\n+Typeclasses\n+-----------\n+\n+You've seen typeclasses in use all the way from :doc:`3_Data`. It's now time to look under the hood.\n+\n+Typeclasses are declared using the ``class`` keyword:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CLASS_BEGIN\n+  :end-before: -- CLASS_END\n+\n+This is akin to an interface declaration of an interface with a getter and setter for a quantity. To *implement* this interface, you need to define instances of this typeclass:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INSTANCE_BEGIN\n+  :end-before: -- INSTANCE_END\n+\n+Typeclasses can have constraints like functions. For example: ``class Eq a => Ord a`` means \"everything that is orderable can also be compared for equality\". And that's almost all there's to it. \n+\n+Important Typeclasses from the Prelude\n+--------------------------------------\n+\n+Eq\n+...\n+\n+The ``Eq`` typeclass allows values of a type to be compared for (in)-equality. It makes available two function: ``==`` and ``/=``. Most data types from the Standard Library have an instance of ``Eq``. As you already learned in :doc:`3_Data`, you can let the compiler automatically derive instances of ``Eq`` for you using the ``deriving`` keyword.\n+\n+Templates always have an ``Eq`` instance, and all types stored on a template need to have one.\n+\n+Ord\n+...\n+\n+The ``Ord`` typeclass allows values of a type to be compared for order. It makes available functions: ``<``, ``>``, ``<=``, and ``>=``. Most of the inbuilt data types have an instance of ``Ord``. Furthermore, types like ``List`` and ``Optional`` get an instance of ``Ord`` if the type they contain has one. You can automatically derive instances of ``Ord`` for you using the ``deriving`` keyword.\n+\n+Show\n+....\n+\n+``Show`` indicates that a type can be serialized to ``Text``, ie \"shown\" in a shell. It's key function is ``show``, which takes a value and converts it to ``Text``. All inbuilt data types have an instance for ``Show`` and types like ``List`` and ``Optional`` get an instance if the type they contain has one. It also supports the ``deriving`` keyword.\n+\n+Functor\n+.......\n+\n+:ref:`Functors <class-ghc-base-functor-73448>` are the closest thing to \"containers\" DAML has. Whenever you see a type with a single type parameter, you are probably looking at a ``Functor``: ``[a]``, ``Optional a``, ``Either Text a``, ``Update a``. Functors are things that can be mapped over and as such, the key function of ``Functor`` is ``fmap``, which does generically what the ``map`` function does for lists.\n+\n+Other classic examples of Functors are Sets, Maps, Trees, etc.\n+\n+Applicative Functor\n+...................\n+\n+:ref:`Applicative Functors <class-da-internal-prelude-applicative-43914>` are a bit like Actions, which you met in :doc:`5_Restrictions`, except that you can't use the result of one action as the input to another action. The only important Applicative Functor that isn't an action in DAML is the ``Commands`` type submitted in ``submit`` block in DAML Script. That's why in order to use ``do`` notation in DAML Script, you have to enable the ``ApplicativeDo`` language extension."
  },
  {
    "id" : "88315f37-73bf-42b0-b3ef-c2750f157d80",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "775db258-c6b3-4d96-a0b7-27aa28ad1903",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : ") -> ,\r\n```suggestion\r\nOther than the typeclasses defined in Prelude, there are two modules generalizing concepts you've already learnt about, which are worth knowing about: ``Foldable`` and ``Traversable``. In :ref:`looping` you learned all about folds and their Action equivalents. All the examples there were based on lists, but there are many other possible iterators. This is expressed in two additional typeclasses: :doc:`/daml/stdlib/DA-Traversable`, and :doc:`/daml/stdlib/DA-Foldable`. For more detail on these concepts, please refer to the literature in :ref:`haskell-connection`, or `https://wiki.haskell.org/Foldable_and_Traversable <https://wiki.haskell.org/Foldable_and_Traversable>`__.\r\n```",
        "createdAt" : "2020-09-29T16:26:04Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them.\n+\n+.. note::\n+\n+  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own type instead.\n+\n+Typeclasses\n+-----------\n+\n+You've seen typeclasses in use all the way from :doc:`3_Data`. It's now time to look under the hood.\n+\n+Typeclasses are declared using the ``class`` keyword:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CLASS_BEGIN\n+  :end-before: -- CLASS_END\n+\n+This is akin to an interface declaration of an interface with a getter and setter for a quantity. To *implement* this interface, you need to define instances of this typeclass:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INSTANCE_BEGIN\n+  :end-before: -- INSTANCE_END\n+\n+Typeclasses can have constraints like functions. For example: ``class Eq a => Ord a`` means \"everything that is orderable can also be compared for equality\". And that's almost all there's to it. \n+\n+Important Typeclasses from the Prelude\n+--------------------------------------\n+\n+Eq\n+...\n+\n+The ``Eq`` typeclass allows values of a type to be compared for (in)-equality. It makes available two function: ``==`` and ``/=``. Most data types from the Standard Library have an instance of ``Eq``. As you already learned in :doc:`3_Data`, you can let the compiler automatically derive instances of ``Eq`` for you using the ``deriving`` keyword.\n+\n+Templates always have an ``Eq`` instance, and all types stored on a template need to have one.\n+\n+Ord\n+...\n+\n+The ``Ord`` typeclass allows values of a type to be compared for order. It makes available functions: ``<``, ``>``, ``<=``, and ``>=``. Most of the inbuilt data types have an instance of ``Ord``. Furthermore, types like ``List`` and ``Optional`` get an instance of ``Ord`` if the type they contain has one. You can automatically derive instances of ``Ord`` for you using the ``deriving`` keyword.\n+\n+Show\n+....\n+\n+``Show`` indicates that a type can be serialized to ``Text``, ie \"shown\" in a shell. It's key function is ``show``, which takes a value and converts it to ``Text``. All inbuilt data types have an instance for ``Show`` and types like ``List`` and ``Optional`` get an instance if the type they contain has one. It also supports the ``deriving`` keyword.\n+\n+Functor\n+.......\n+\n+:ref:`Functors <class-ghc-base-functor-73448>` are the closest thing to \"containers\" DAML has. Whenever you see a type with a single type parameter, you are probably looking at a ``Functor``: ``[a]``, ``Optional a``, ``Either Text a``, ``Update a``. Functors are things that can be mapped over and as such, the key function of ``Functor`` is ``fmap``, which does generically what the ``map`` function does for lists.\n+\n+Other classic examples of Functors are Sets, Maps, Trees, etc.\n+\n+Applicative Functor\n+...................\n+\n+:ref:`Applicative Functors <class-da-internal-prelude-applicative-43914>` are a bit like Actions, which you met in :doc:`5_Restrictions`, except that you can't use the result of one action as the input to another action. The only important Applicative Functor that isn't an action in DAML is the ``Commands`` type submitted in ``submit`` block in DAML Script. That's why in order to use ``do`` notation in DAML Script, you have to enable the ``ApplicativeDo`` language extension.\n+\n+Actions\n+.......\n+\n+:ref:`Actions <class-da-internal-prelude-action-24943>` were already covered in :doc:`5_Restrictions`. One way to think of them is as \"recipes\" for a value, which need to be \"executed to get at that value. Actions are always Functors (and Applicative Functors). The intuition for that is simply that ``fmap f x`` is the recipe in ``x`` with the extra instruction to apply the pure function ``f`` to the result.\n+\n+The really important Actions in DAML are ``Update`` and ``Script``, but there are many others, like ``[]``, ``Optional``, and ``Either a``.\n+\n+Semigroups and Monoids\n+......................\n+\n+:ref:`Semigroups and monoids <class-da-internal-prelude-semigroup-80733>` are about binary operations, but in practice, their important use is for ``Text`` and ``[]``, where they allow concatenation using the ``{<>}`` operator.\n+\n+Additive and Multiplicative\n+...........................\n+\n+:ref:`Additive and Multiplicative <class-ghc-num-additive-5364>` abstract out arithmetic operations, so that ``(+)``, ``(-)``, ``(*)``, and some other functions can be used uniformly between ``Decimal`` and ``Int``.\n+\n+Important Modules in the Standard Library\n+-----------------------------------------\n+\n+For almost all the types and typeclasses presented above, the Standard Library contains a module:\n+\n+- :doc:`/daml/stdlib/DA-List` for Lists\n+- :doc:`/daml/stdlib/DA-Optional` for ``Optional``\n+- :doc:`/daml/stdlib/DA-Tuple` for Tuples\n+- :doc:`/daml/stdlib/DA-Either` for ``Either``\n+- :doc:`/daml/stdlib/DA-Functor` for Functors\n+- :doc:`/daml/stdlib/DA-Action` for Actions\n+- :doc:`/daml/stdlib/DA-Monoid` and :doc:`/daml/stdlib/DA-Semigroup` for Monoids and Semigroups\n+- :doc:`/daml/stdlib/DA-Text` for working with ``Text``\n+- :doc:`/daml/stdlib/DA-Time` for working with ``Time``\n+- :doc:`/daml/stdlib/DA-Date` for working with ``Date``\n+\n+You get the idea, the names are fairly descriptive.\n+\n+Other than the typeclasses defined in Prelude, there are two modules generalizing concepts you've already learnt about, which are worth knowing about: ``Foldable`` and ``Traversable``. In :ref:`looping` you learned all about folds and their Action equivalents. All the examples there were based on lists, but there are many other possible iterators. This is expressed in two additional typeclasses: :doc:`/daml/stdlib/DA-Traversable`) and :doc:`/daml/stdlib/DA-Foldable`. For more detail on these concepts, please refer to the literature in :ref:`haskell-connection`, or `https://wiki.haskell.org/Foldable_and_Traversable <https://wiki.haskell.org/Foldable_and_Traversable>`__."
  },
  {
    "id" : "2e02f7fe-2b10-4d2e-ac03-4322fca0232c",
    "prId" : 7508,
    "comments" : [
      {
        "id" : "cf20416d-d466-4aa7-a0df-3fcaac822fad",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nDAML has it's own version of the `Hoogle <https://hoogle.haskell.org/>`__ search engine, which offers search both by name and by signature. It's fully integrated into the search bar on `https://docs.daml.com/ <https://docs.daml.com/>`__, but for those wanting a pure Standard Library search, it's also available on `<https://hoogle.daml.com>`__.\r\n```",
        "createdAt" : "2020-09-29T16:27:39Z",
        "updatedAt" : "2020-09-29T20:08:00Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d2eaa786ab449682b6328513101c79529ca4c48a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,235 @@\n+10 Intro to the DAML Standard Library\n+=====================================\n+\n+In chapters :doc:`3_Data` and :doc:`9_Functional101` you learnt how to define your own data types and functions. But of course you don't have to implement everything from scratch. DAML comes with a library of types, functions and typeclasses that cover a large range of use-cases, the DAML Standard Library. In this chapter, you'll get an overview of the essentials, but also learn how to browse and search this library to find functions. Being proficient with the Standard Library will make you considerably more efficient writing DAML code. Specifically, this chapter covers:\n+\n+- The Prelude\n+- Important types from the Standard Library, and associated functions and typeclasses\n+- Typeclasses\n+- Important typeclasses like ``Fuctor``, ``Foldable``, and ``Traversable``\n+- How to search the Standard Library\n+\n+To go in depth on some of these topics, the literature referenced in :ref:`haskell-connection` covers them in much greater detail. The Standard Library typeclasses like ``Applicative``, ``Foldable``, ``Traversable``, ``Action`` (called ``Monad``), and many more, are the bread and butter of Haskell programmers.\n+\n+.. note::\n+\n+  There is a project template ``daml-intro-10`` for this chapter, but it only contains a single source file with the code snippets embedded in this section.\n+\n+The Prelude\n+-----------\n+\n+You've already used a lot of functions, types, and typeclasses without importing anything. Functions like ``create``, ``exercise``, and ``(==)``, types like ``[]``, ``(,)``, ``Optional``, and typeclasses like ``Eq``, ``Show``, and ``Ord``. These all come from the :doc:`Prelude </daml/stdlib/Prelude>`. The Prelude is module that gets implicitly imported into every other DAML module and contains both DAML specific machinery as well as the essentials needed to work with the inbuilt types and typeclasses.\n+\n+Important Types from the Prelude\n+--------------------------------\n+\n+In addition to the :ref:`native-types`, the Prelude defines a number of common types:\n+\n+Lists\n+.....\n+\n+You've already met lists. Lists have two constructors ``[]`` and ``x :: xs``, the latter of which is \"prepend\" in the sense that ``1 :: [2] == [1, 2]``. That equality is deeper: ``[1,2,3]`` is just special syntax for ``1 :: 2 :: 3 :: []``. \n+\n+Tuples\n+......\n+\n+In addition to the 2-tuple you have already seen, the Prelude contains definitions for tuple of size up to 15. Tuples allow you to store mixed data in an ad-hoc fashion. Common use-cases are return values from functions consisting of several pieces or passing around data in folds, as you saw in :ref:`folds`. An example of a relatively wide Tuple can be found in the test modules of the chapter 8 project. ``Test.Intro.Asset.TradeSetup.tradeSetup`` returns the allocated parties and active contracts in a long tuple. ``Test.Intro.Asset.MultiTrade.testMultiTrade`` puts them back into scope using pattern matching.\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/TradeSetup.daml\n+  :language: daml\n+  :start-after: -- TUPLE_RETURN_BEGIN\n+  :end-before: -- TUPLE_RETURN_END\n+\n+.. literalinclude:: daml/daml-intro-8/daml/Test/Intro/Asset/MultiTrade.daml\n+  :language: daml\n+  :start-after: -- TUPLE_USE_BEGIN\n+  :end-before: -- TUPLE_USE_END\n+\n+Tuples, like lists have some syntactic magic. Both the types as well as the constructors for tuples are ``(,,,)`` where the number of commas determines the arity of the tuple. Type and data constructor can be applied with values inside the brackets, or outside, and partial application is possible:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- TUPLE_DEMO_BEGIN\n+  :end-before: -- TUPLE_DEMO_END\n+\n+.. note::\n+\n+    While tuples of great lengths are available, it is often advisable to define custom records with named fields for complex structures or long-lived values. Overuse of tuples can harm code readability.\n+\n+Optional\n+........\n+\n+The ``Optional`` type represents a value that may be missing. It's the closest thing DAML has to a \"nullable\" value. ``Optional`` has two constructors: ``Some``, which takes a value, and ``None``, which doesn't take a value. In many languages one would write code like this:\n+\n+.. code-block:: JavaScript\n+\n+  lookupResult = lookupByKey(k);\n+\n+  if( lookupResult == null) {\n+    // Do something\n+  } else {\n+    // Do something else\n+  }\n+\n+In DAML the same thing would be expressed as\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- OPT_BEGIN\n+  :end-before: -- OPT_END\n+\n+Either\n+......\n+\n+``Either`` is used in cases where a value should store one of two types. It has two constructors, ``Left`` and ``Right``, each of which take a value of one or the other of the two types. One typical use-case of ``Either`` is as an extended ``Optional`` where ``Right`` takes the role of ``Some`` and ``Left`` the role of ``None``, but with the ability to store an error value. ``Either Text``, for example behaves just like ``Optional`, except that values with constructor ``Left`` have a text associated to them.\n+\n+.. note::\n+\n+  As with tuples, it's easy to overuse ``Either`` and harm readability. Consider writing your own type instead.\n+\n+Typeclasses\n+-----------\n+\n+You've seen typeclasses in use all the way from :doc:`3_Data`. It's now time to look under the hood.\n+\n+Typeclasses are declared using the ``class`` keyword:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- CLASS_BEGIN\n+  :end-before: -- CLASS_END\n+\n+This is akin to an interface declaration of an interface with a getter and setter for a quantity. To *implement* this interface, you need to define instances of this typeclass:\n+\n+.. literalinclude:: daml/daml-intro-10/daml/Main.daml\n+  :language: daml\n+  :start-after: -- INSTANCE_BEGIN\n+  :end-before: -- INSTANCE_END\n+\n+Typeclasses can have constraints like functions. For example: ``class Eq a => Ord a`` means \"everything that is orderable can also be compared for equality\". And that's almost all there's to it. \n+\n+Important Typeclasses from the Prelude\n+--------------------------------------\n+\n+Eq\n+...\n+\n+The ``Eq`` typeclass allows values of a type to be compared for (in)-equality. It makes available two function: ``==`` and ``/=``. Most data types from the Standard Library have an instance of ``Eq``. As you already learned in :doc:`3_Data`, you can let the compiler automatically derive instances of ``Eq`` for you using the ``deriving`` keyword.\n+\n+Templates always have an ``Eq`` instance, and all types stored on a template need to have one.\n+\n+Ord\n+...\n+\n+The ``Ord`` typeclass allows values of a type to be compared for order. It makes available functions: ``<``, ``>``, ``<=``, and ``>=``. Most of the inbuilt data types have an instance of ``Ord``. Furthermore, types like ``List`` and ``Optional`` get an instance of ``Ord`` if the type they contain has one. You can automatically derive instances of ``Ord`` for you using the ``deriving`` keyword.\n+\n+Show\n+....\n+\n+``Show`` indicates that a type can be serialized to ``Text``, ie \"shown\" in a shell. It's key function is ``show``, which takes a value and converts it to ``Text``. All inbuilt data types have an instance for ``Show`` and types like ``List`` and ``Optional`` get an instance if the type they contain has one. It also supports the ``deriving`` keyword.\n+\n+Functor\n+.......\n+\n+:ref:`Functors <class-ghc-base-functor-73448>` are the closest thing to \"containers\" DAML has. Whenever you see a type with a single type parameter, you are probably looking at a ``Functor``: ``[a]``, ``Optional a``, ``Either Text a``, ``Update a``. Functors are things that can be mapped over and as such, the key function of ``Functor`` is ``fmap``, which does generically what the ``map`` function does for lists.\n+\n+Other classic examples of Functors are Sets, Maps, Trees, etc.\n+\n+Applicative Functor\n+...................\n+\n+:ref:`Applicative Functors <class-da-internal-prelude-applicative-43914>` are a bit like Actions, which you met in :doc:`5_Restrictions`, except that you can't use the result of one action as the input to another action. The only important Applicative Functor that isn't an action in DAML is the ``Commands`` type submitted in ``submit`` block in DAML Script. That's why in order to use ``do`` notation in DAML Script, you have to enable the ``ApplicativeDo`` language extension.\n+\n+Actions\n+.......\n+\n+:ref:`Actions <class-da-internal-prelude-action-24943>` were already covered in :doc:`5_Restrictions`. One way to think of them is as \"recipes\" for a value, which need to be \"executed to get at that value. Actions are always Functors (and Applicative Functors). The intuition for that is simply that ``fmap f x`` is the recipe in ``x`` with the extra instruction to apply the pure function ``f`` to the result.\n+\n+The really important Actions in DAML are ``Update`` and ``Script``, but there are many others, like ``[]``, ``Optional``, and ``Either a``.\n+\n+Semigroups and Monoids\n+......................\n+\n+:ref:`Semigroups and monoids <class-da-internal-prelude-semigroup-80733>` are about binary operations, but in practice, their important use is for ``Text`` and ``[]``, where they allow concatenation using the ``{<>}`` operator.\n+\n+Additive and Multiplicative\n+...........................\n+\n+:ref:`Additive and Multiplicative <class-ghc-num-additive-5364>` abstract out arithmetic operations, so that ``(+)``, ``(-)``, ``(*)``, and some other functions can be used uniformly between ``Decimal`` and ``Int``.\n+\n+Important Modules in the Standard Library\n+-----------------------------------------\n+\n+For almost all the types and typeclasses presented above, the Standard Library contains a module:\n+\n+- :doc:`/daml/stdlib/DA-List` for Lists\n+- :doc:`/daml/stdlib/DA-Optional` for ``Optional``\n+- :doc:`/daml/stdlib/DA-Tuple` for Tuples\n+- :doc:`/daml/stdlib/DA-Either` for ``Either``\n+- :doc:`/daml/stdlib/DA-Functor` for Functors\n+- :doc:`/daml/stdlib/DA-Action` for Actions\n+- :doc:`/daml/stdlib/DA-Monoid` and :doc:`/daml/stdlib/DA-Semigroup` for Monoids and Semigroups\n+- :doc:`/daml/stdlib/DA-Text` for working with ``Text``\n+- :doc:`/daml/stdlib/DA-Time` for working with ``Time``\n+- :doc:`/daml/stdlib/DA-Date` for working with ``Date``\n+\n+You get the idea, the names are fairly descriptive.\n+\n+Other than the typeclasses defined in Prelude, there are two modules generalizing concepts you've already learnt about, which are worth knowing about: ``Foldable`` and ``Traversable``. In :ref:`looping` you learned all about folds and their Action equivalents. All the examples there were based on lists, but there are many other possible iterators. This is expressed in two additional typeclasses: :doc:`/daml/stdlib/DA-Traversable`) and :doc:`/daml/stdlib/DA-Foldable`. For more detail on these concepts, please refer to the literature in :ref:`haskell-connection`, or `https://wiki.haskell.org/Foldable_and_Traversable <https://wiki.haskell.org/Foldable_and_Traversable>`__.\n+\n+Searching the Standard Library\n+------------------------------\n+\n+Being able to browse the Standard Library starting from :doc:`/daml/stdlib/index` is a start, and the module naming helps, but it's not an efficient process for finding out what a function you've encountered does, or even less so to find a function that does a thing you need to do.\n+\n+DAML has it's own version of the `Hoogle <https://hoogle.haskell.org/>`__ search engine, which offers search both by name and by signature. It's fully integrated into the search bar on `https://docs.daml.com/ <https://docs.daml.com/>`__, but for those wanting a pure Standard Library search, it's also available on `https://hoogle.daml.com.`."
  }
]