[
  {
    "id" : "8f6488ac-fd63-46b3-ac86-55f164bb8fb0",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "139e2010-9190-416c-bd78-5f1f94be104d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you just want to ask for 4 usecases, the list above is enough and we can remove this section. If you want more then I think users should really just read the daml script docs. Our docs should primarily be there to help our users not to answer certification questions.",
        "createdAt" : "2020-09-29T15:54:36Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing"
  },
  {
    "id" : "fa55be69-72a5-4c3b-b891-7fa0c2aacfea",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "faaf921c-fa90-4d5c-957d-ca8f49a98905",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nIn the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Script outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\r\n```",
        "createdAt" : "2020-09-29T15:54:53Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``."
  },
  {
    "id" : "7d51fcea-a59c-4023-9952-8afb30fddb89",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "a2a9d7ed-bc0b-45a7-a717-0ff16bd72270",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I do agree that this is a crucial feature. What I disagree with is that it needs to be mentioned here. The DAML Script docs are very approachable (and if they aren’t I’ll gladly accept PRs or suggestions to improve that). Replicating here just so you have only a single place that people need to read through for certification is making the overall structure of our docs worse.",
        "createdAt" : "2020-09-29T15:56:40Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs"
  },
  {
    "id" : "815b0cc1-f399-4009-84c6-863067b019d1",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "1e45e518-61c4-4e3b-b2e9-34b712e25428",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same thing here, the docs for DAML REPL should be pretty approachable. Why can’t we mention DAML REPL with a link to the docs for that instead of replicating half of the docs here?",
        "createdAt" : "2020-09-29T15:57:29Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL"
  },
  {
    "id" : "f7328978-1bab-4ce5-8319-f6f3519b1556",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "e0bdc631-6eab-427a-b778-60c9c14baf95",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "This chapter is mostly about testing when it talks about Script so made some changes.\r\n\r\n```suggestion\r\nThis chapter is all about testing and debugging the DAML contracts you've built using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about more ways to test with DAML Script and its other uses, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\r\n```",
        "createdAt" : "2020-09-29T16:37:27Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:"
  },
  {
    "id" : "cb58f877-73e3-41a5-a50f-1a7b71ee43aa",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "161b05c1-c14d-4244-9d7e-20bac38abadd",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nIn your :doc:`chapter 8 project <8_Dependencies>`, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\r\n```",
        "createdAt" : "2020-09-29T16:44:46Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures."
  },
  {
    "id" : "3afbeaf2-5a3e-4f68-bba7-aa0a4f579358",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "6b3e4f78-d836-4f0c-9f81-c4116bc91cc8",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Are `daml test` and `daml test-script` equivalent if you don't provide a ledger host and port to `daml test-script`?",
        "createdAt" : "2020-09-29T16:46:55Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against."
  },
  {
    "id" : "a845bbb1-00a6-44aa-b3a9-563dc4d4cb25",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "de1c3676-f9a5-4d7f-8ee3-44b9a644bf63",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nThe last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from :doc:`your chapter 7 model <7_Composing>`. Go to your :doc:`chapter 8 <8_Dependencies>` project folder.\r\n```",
        "createdAt" : "2020-09-29T16:49:46Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project."
  },
  {
    "id" : "08fdba5a-34fa-40e9-a401-a4e3dc42fed5",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "8ae68b96-1985-492e-bb3e-0bdb057f287f",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\n\r\n.. note::\r\n\r\n  You'll want to make sure you have chapters 7 and 8 completed and their respective project folders (ie. ``7Composing/`` and ``8Dependencies/``) in the same top level directory before continuing.\r\n\r\n```",
        "createdAt" : "2020-09-29T16:58:27Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+"
  },
  {
    "id" : "a4d94405-ae5f-4d0e-87d6-1a1e98faa1fb",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "685f259c-ac42-4585-9f86-b0fc016cf834",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nWe now want to establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\r\n```",
        "createdAt" : "2020-09-29T17:00:09Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work."
  },
  {
    "id" : "82ea5109-d944-4866-8080-80557e78fd49",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "1f542e44-6e26-4377-8cfa-0d3b23b0b1ae",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nYou can use ``:help`` to show the available meta-commands. Running ``:show imports`` will show you that the modules form the chapter 7 and 8 projects are already imported. That's the effect of the ``-i 8Dependencies -i 7Composing`` in the command above. You can load and unload other modules using the ``:module`` command:\r\n```",
        "createdAt" : "2020-09-29T17:23:48Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL\n+~~~~~~~~~\n+\n+If you want to do things interactively, :doc:`DAML REPL </daml-repl/index>` is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script. Run it using\n+\n+.. code-block:: none\n+\n+  daml repl --ledger-host localhost --ledger-port 6865 multi-trade.dar -i 8Dependencies -i 7Composing\n+\n+DAML REPL acts both as a language REPL (Read-Evaluate-Print Loop) as well as a shell to interact with a ledger. In other words, we can test pure expressions as well as sending commands and querying. As an example, you can use the ``length`` function from Prelude:\n+\n+.. code-block:: none\n+\n+  daml> length [1,3,2]\n+  3\n+\n+You can use ``:help`` to show the available meta-commands. Running ``:show imports`` will show you that the modules form the chapter 7 and 8 projects are already imported. That's the effect of the ``-i 8Dependencies -i 7Composing`` in the command above. You an load and unload other modules using the ``:module`` command:"
  },
  {
    "id" : "90777bca-26d0-4478-9abd-c8bef9d45823",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "69e91a7f-dd12-4106-8197-7f5e3cbe16f8",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Getting errors here. Tried running from within `8Dependencies/` and running from outside but referring to `8Dependencies/multi-trade.dar` both give me the same set of errors that look like the below.\r\n\r\nAlso tried doing `-i ../7Composing` but that's not allowed (I guess we're referring to libraries and not directories here?)\r\n\r\n```\r\nFile:     Line0.daml\r\nHidden:   no\r\nRange:    11:7-11:28\r\nSource:   not found\r\nSeverity: DsError\r\nMessage: \r\n  Could not load module ‘Test.Intro.Asset.Role’\r\n  It is a member of the hidden package ‘7Composing-1.0.0’.\r\n  You can run ‘:set -package 7Composing’ to expose it.\r\n  (Note: this unloads all the modules in the current scope.)\r\nFile:     Line0.daml\r\n```\r\n\r\nREPL also tells me that `:set` isn't a command:\r\n```\r\ndaml> :set -package 7Composing\r\nNo such command :set\r\n```\r\n\r\nThis is using DAML_SDK_HEAD=0.0.0 with the latest installed from `daml-sdk-head --skip-jars`",
        "createdAt" : "2020-09-29T17:46:58Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL\n+~~~~~~~~~\n+\n+If you want to do things interactively, :doc:`DAML REPL </daml-repl/index>` is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script. Run it using\n+\n+.. code-block:: none\n+\n+  daml repl --ledger-host localhost --ledger-port 6865 multi-trade.dar -i 8Dependencies -i 7Composing\n+\n+DAML REPL acts both as a language REPL (Read-Evaluate-Print Loop) as well as a shell to interact with a ledger. In other words, we can test pure expressions as well as sending commands and querying. As an example, you can use the ``length`` function from Prelude:\n+\n+.. code-block:: none\n+\n+  daml> length [1,3,2]"
  },
  {
    "id" : "bcce6611-f4ca-4f8f-9efb-7c65da1bfc6a",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "4d9f824e-a01a-4997-a0bb-2eab457fd806",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\nIf we look back at :ref:`execution_model` we'll see there are three places where ledger state is consumed:\r\n```",
        "createdAt" : "2020-09-29T18:56:38Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL\n+~~~~~~~~~\n+\n+If you want to do things interactively, :doc:`DAML REPL </daml-repl/index>` is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script. Run it using\n+\n+.. code-block:: none\n+\n+  daml repl --ledger-host localhost --ledger-port 6865 multi-trade.dar -i 8Dependencies -i 7Composing\n+\n+DAML REPL acts both as a language REPL (Read-Evaluate-Print Loop) as well as a shell to interact with a ledger. In other words, we can test pure expressions as well as sending commands and querying. As an example, you can use the ``length`` function from Prelude:\n+\n+.. code-block:: none\n+\n+  daml> length [1,3,2]\n+  3\n+\n+You can use ``:help`` to show the available meta-commands. Running ``:show imports`` will show you that the modules form the chapter 7 and 8 projects are already imported. That's the effect of the ``-i 8Dependencies -i 7Composing`` in the command above. You an load and unload other modules using the ``:module`` command:\n+\n+.. code-block:: none\n+\n+  daml> :module + DA.List\n+  daml> sort [1,3,2]\n+  [1,2,3]\n+\n+Now let's establish the next relationship interactively. We first need to get our hands on the Bob and CHF_Bank parties. For that, we use the ``listKnownParties`` action and filter according to display names:\n+\n+.. code-block:: none\n+\n+  daml> parties <- listKnownParties\n+  daml> parties\n+  [PartyDetails {party = 'party-3cca7cc5', displayName = Some \"Alice\", isLocal = True},PartyDetails {party = 'party-4b70184e', displayName = Some \"Bob\", isLocal = True},PartyDetails {party = 'party-6e5b60bf', displayName = Some \"USD_Bank\", isLocal = True},PartyDetails {party = 'party-3d836540', displayName = Some \"EUR_Bank\", isLocal = True}]\n+  daml> let bob = (parties!!1).party\n+  daml> let chfbank = (parties!!4).party\n+\n+Now we can run scripts from the REPL just like we would in Script:\n+\n+.. code-block:: none\n+\n+  daml> let rel = Relationship with issuer=chfbank; owner=bob\n+  daml> setupRelationship rel\n+  <contract-id>\n+\n+The last script returns a ``ContractId AssetHolder`` so the REPL prints the result of ``show`` on that, which always returns \"<contract-id>\".\n+\n+As you can see, DAML Repl is able to mix and match scripts and custom interactions seamlessly. \n+\n+Debug, Trace, and Stacktraces\n+-----------------------------\n+\n+The above demonstrates nicely how to test the happy path, but what if a function doesn't behave as you expected? DAML has two functions that allow you to do fine-grained printf debugging: ``debug`` and ``trace``. Both allow you to print something to StdOut if the code is reached. The difference between ``debug`` and ``trace`` is similar to the relationship between ``abort`` and ``error``:\n+\n+- ``debug : Text -> m ()`` maps a text to an Action that has the side-effect of printing to StdOut.\n+- ``trace : Text -> a -> a`` prints to StdOut when the expression is evaluated. \n+\n+.. code-block:: none\n+\n+  daml> let a : Script () = debug \"foo\"\n+  daml> let b : Script () = trace \"bar\" (debug \"baz\")\n+  [Daml.Script:378]: \"bar\"\n+  daml> a\n+  [DA.Internal.Prelude:540]: \"foo\"\n+  daml> b\n+  [DA.Internal.Prelude:540]: \"baz\"\n+  daml>\n+\n+If in doubt, use ``debug``. It's the easier of the two to interpret the results of.\n+\n+The thing in the square brackets is the last location. It'll tell you the DAML file and line number that triggered the printing, but often no more than that because full stacktraces could violate subtransaction privacy quite easily. If you want to enable stacktraces for some purely functional code in your modules, you can use the machinery in :doc:`/daml/stdlib/DA-Stack` to do so, but we won't cover that any further here.\n+\n+Diagnosing Contention Errors\n+----------------------------\n+\n+The above tools and functions allow you to diagnose most problems with DAML code, but they are all synchronous. The sequence of commands is determined by the sequence of inputs. That means one of the main pitfalls of distributed applications doesn't come into play: Contention.\n+\n+Contention refers to conflicts over access to contracts. DAML guarantees that there can only be one consuming choice exercised per contract so what if two parties simultaneously submit an exercise command on the same contract? Only one can succeed. Contention can also occur due to incomplete or stale knowledge. Maybe a contract was archived a little while ago, but due to latencies, a client hasn't found out yet, or maybe due to the privacy model, they never will. What all these cases have in common is that someone has incomplete knowledge of the state the ledger will be in at the time a transaction will be processed and/or committed.\n+\n+Look back that the :ref:`execution_model`. There are three places where ledger state is consumed:"
  },
  {
    "id" : "63f2b3e7-a607-47ae-b3cc-bd211edd96c5",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "cced4f4f-6cff-4e2a-a29c-158427d6a222",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "```suggestion\r\n1. A command is submitted by some client, probably looking at the state of the ledger to build that command. Maybe the command includes references to ContractIds that the client believes are active.\r\n```",
        "createdAt" : "2020-09-29T18:57:15Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL\n+~~~~~~~~~\n+\n+If you want to do things interactively, :doc:`DAML REPL </daml-repl/index>` is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script. Run it using\n+\n+.. code-block:: none\n+\n+  daml repl --ledger-host localhost --ledger-port 6865 multi-trade.dar -i 8Dependencies -i 7Composing\n+\n+DAML REPL acts both as a language REPL (Read-Evaluate-Print Loop) as well as a shell to interact with a ledger. In other words, we can test pure expressions as well as sending commands and querying. As an example, you can use the ``length`` function from Prelude:\n+\n+.. code-block:: none\n+\n+  daml> length [1,3,2]\n+  3\n+\n+You can use ``:help`` to show the available meta-commands. Running ``:show imports`` will show you that the modules form the chapter 7 and 8 projects are already imported. That's the effect of the ``-i 8Dependencies -i 7Composing`` in the command above. You an load and unload other modules using the ``:module`` command:\n+\n+.. code-block:: none\n+\n+  daml> :module + DA.List\n+  daml> sort [1,3,2]\n+  [1,2,3]\n+\n+Now let's establish the next relationship interactively. We first need to get our hands on the Bob and CHF_Bank parties. For that, we use the ``listKnownParties`` action and filter according to display names:\n+\n+.. code-block:: none\n+\n+  daml> parties <- listKnownParties\n+  daml> parties\n+  [PartyDetails {party = 'party-3cca7cc5', displayName = Some \"Alice\", isLocal = True},PartyDetails {party = 'party-4b70184e', displayName = Some \"Bob\", isLocal = True},PartyDetails {party = 'party-6e5b60bf', displayName = Some \"USD_Bank\", isLocal = True},PartyDetails {party = 'party-3d836540', displayName = Some \"EUR_Bank\", isLocal = True}]\n+  daml> let bob = (parties!!1).party\n+  daml> let chfbank = (parties!!4).party\n+\n+Now we can run scripts from the REPL just like we would in Script:\n+\n+.. code-block:: none\n+\n+  daml> let rel = Relationship with issuer=chfbank; owner=bob\n+  daml> setupRelationship rel\n+  <contract-id>\n+\n+The last script returns a ``ContractId AssetHolder`` so the REPL prints the result of ``show`` on that, which always returns \"<contract-id>\".\n+\n+As you can see, DAML Repl is able to mix and match scripts and custom interactions seamlessly. \n+\n+Debug, Trace, and Stacktraces\n+-----------------------------\n+\n+The above demonstrates nicely how to test the happy path, but what if a function doesn't behave as you expected? DAML has two functions that allow you to do fine-grained printf debugging: ``debug`` and ``trace``. Both allow you to print something to StdOut if the code is reached. The difference between ``debug`` and ``trace`` is similar to the relationship between ``abort`` and ``error``:\n+\n+- ``debug : Text -> m ()`` maps a text to an Action that has the side-effect of printing to StdOut.\n+- ``trace : Text -> a -> a`` prints to StdOut when the expression is evaluated. \n+\n+.. code-block:: none\n+\n+  daml> let a : Script () = debug \"foo\"\n+  daml> let b : Script () = trace \"bar\" (debug \"baz\")\n+  [Daml.Script:378]: \"bar\"\n+  daml> a\n+  [DA.Internal.Prelude:540]: \"foo\"\n+  daml> b\n+  [DA.Internal.Prelude:540]: \"baz\"\n+  daml>\n+\n+If in doubt, use ``debug``. It's the easier of the two to interpret the results of.\n+\n+The thing in the square brackets is the last location. It'll tell you the DAML file and line number that triggered the printing, but often no more than that because full stacktraces could violate subtransaction privacy quite easily. If you want to enable stacktraces for some purely functional code in your modules, you can use the machinery in :doc:`/daml/stdlib/DA-Stack` to do so, but we won't cover that any further here.\n+\n+Diagnosing Contention Errors\n+----------------------------\n+\n+The above tools and functions allow you to diagnose most problems with DAML code, but they are all synchronous. The sequence of commands is determined by the sequence of inputs. That means one of the main pitfalls of distributed applications doesn't come into play: Contention.\n+\n+Contention refers to conflicts over access to contracts. DAML guarantees that there can only be one consuming choice exercised per contract so what if two parties simultaneously submit an exercise command on the same contract? Only one can succeed. Contention can also occur due to incomplete or stale knowledge. Maybe a contract was archived a little while ago, but due to latencies, a client hasn't found out yet, or maybe due to the privacy model, they never will. What all these cases have in common is that someone has incomplete knowledge of the state the ledger will be in at the time a transaction will be processed and/or committed.\n+\n+Look back that the :ref:`execution_model`. There are three places where ledger state is consumed:\n+\n+1. A command is submitted by some client, probably looking at the state of the ledger to build that command. Maybe the command includes references to ContractIds that the client believes active."
  },
  {
    "id" : "d87d6048-ad23-49ad-a7d4-ff8407be47dd",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "a7ce66ad-4c37-4c94-9735-201d63fc3c37",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "What is the right way to do this one? Have the `User` contract refer to a `UserMessages` contract? Might be worth including a sentence on how to do this correctly.",
        "createdAt" : "2020-09-29T19:07:59Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL\n+~~~~~~~~~\n+\n+If you want to do things interactively, :doc:`DAML REPL </daml-repl/index>` is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script. Run it using\n+\n+.. code-block:: none\n+\n+  daml repl --ledger-host localhost --ledger-port 6865 multi-trade.dar -i 8Dependencies -i 7Composing\n+\n+DAML REPL acts both as a language REPL (Read-Evaluate-Print Loop) as well as a shell to interact with a ledger. In other words, we can test pure expressions as well as sending commands and querying. As an example, you can use the ``length`` function from Prelude:\n+\n+.. code-block:: none\n+\n+  daml> length [1,3,2]\n+  3\n+\n+You can use ``:help`` to show the available meta-commands. Running ``:show imports`` will show you that the modules form the chapter 7 and 8 projects are already imported. That's the effect of the ``-i 8Dependencies -i 7Composing`` in the command above. You an load and unload other modules using the ``:module`` command:\n+\n+.. code-block:: none\n+\n+  daml> :module + DA.List\n+  daml> sort [1,3,2]\n+  [1,2,3]\n+\n+Now let's establish the next relationship interactively. We first need to get our hands on the Bob and CHF_Bank parties. For that, we use the ``listKnownParties`` action and filter according to display names:\n+\n+.. code-block:: none\n+\n+  daml> parties <- listKnownParties\n+  daml> parties\n+  [PartyDetails {party = 'party-3cca7cc5', displayName = Some \"Alice\", isLocal = True},PartyDetails {party = 'party-4b70184e', displayName = Some \"Bob\", isLocal = True},PartyDetails {party = 'party-6e5b60bf', displayName = Some \"USD_Bank\", isLocal = True},PartyDetails {party = 'party-3d836540', displayName = Some \"EUR_Bank\", isLocal = True}]\n+  daml> let bob = (parties!!1).party\n+  daml> let chfbank = (parties!!4).party\n+\n+Now we can run scripts from the REPL just like we would in Script:\n+\n+.. code-block:: none\n+\n+  daml> let rel = Relationship with issuer=chfbank; owner=bob\n+  daml> setupRelationship rel\n+  <contract-id>\n+\n+The last script returns a ``ContractId AssetHolder`` so the REPL prints the result of ``show`` on that, which always returns \"<contract-id>\".\n+\n+As you can see, DAML Repl is able to mix and match scripts and custom interactions seamlessly. \n+\n+Debug, Trace, and Stacktraces\n+-----------------------------\n+\n+The above demonstrates nicely how to test the happy path, but what if a function doesn't behave as you expected? DAML has two functions that allow you to do fine-grained printf debugging: ``debug`` and ``trace``. Both allow you to print something to StdOut if the code is reached. The difference between ``debug`` and ``trace`` is similar to the relationship between ``abort`` and ``error``:\n+\n+- ``debug : Text -> m ()`` maps a text to an Action that has the side-effect of printing to StdOut.\n+- ``trace : Text -> a -> a`` prints to StdOut when the expression is evaluated. \n+\n+.. code-block:: none\n+\n+  daml> let a : Script () = debug \"foo\"\n+  daml> let b : Script () = trace \"bar\" (debug \"baz\")\n+  [Daml.Script:378]: \"bar\"\n+  daml> a\n+  [DA.Internal.Prelude:540]: \"foo\"\n+  daml> b\n+  [DA.Internal.Prelude:540]: \"baz\"\n+  daml>\n+\n+If in doubt, use ``debug``. It's the easier of the two to interpret the results of.\n+\n+The thing in the square brackets is the last location. It'll tell you the DAML file and line number that triggered the printing, but often no more than that because full stacktraces could violate subtransaction privacy quite easily. If you want to enable stacktraces for some purely functional code in your modules, you can use the machinery in :doc:`/daml/stdlib/DA-Stack` to do so, but we won't cover that any further here.\n+\n+Diagnosing Contention Errors\n+----------------------------\n+\n+The above tools and functions allow you to diagnose most problems with DAML code, but they are all synchronous. The sequence of commands is determined by the sequence of inputs. That means one of the main pitfalls of distributed applications doesn't come into play: Contention.\n+\n+Contention refers to conflicts over access to contracts. DAML guarantees that there can only be one consuming choice exercised per contract so what if two parties simultaneously submit an exercise command on the same contract? Only one can succeed. Contention can also occur due to incomplete or stale knowledge. Maybe a contract was archived a little while ago, but due to latencies, a client hasn't found out yet, or maybe due to the privacy model, they never will. What all these cases have in common is that someone has incomplete knowledge of the state the ledger will be in at the time a transaction will be processed and/or committed.\n+\n+Look back that the :ref:`execution_model`. There are three places where ledger state is consumed:\n+\n+1. A command is submitted by some client, probably looking at the state of the ledger to build that command. Maybe the command includes references to ContractIds that the client believes active.\n+2. During interpretation, ledger state is used to to look up active contracts.\n+3. During commit, ledger state is again used to look up contracts and validate the transaction by reinterpreting it.\n+\n+Collisions can occur both between 1 and 2 and between 2 and 3. Only during the commit phase is the complete relevant ledger state at the time of the transaction known, which means the ledger state at commit time is king. As a DAML contract developer, you need to understand the different causes of contention, be able to diagnose the root cause if errors of this type occur, and be able to avoid collisions by designing contracts appropriately. \n+\n+Common Errors\n+~~~~~~~~~~~~~\n+\n+The most common error messages you'll see are listed below. All of them can be due to one of three reasons.\n+\n+1. Race Conditions - knowledge of a state change is not yet known during command submission\n+2. Stale References - the state change is known, but contracts have stale references to keys or ContractIds\n+3. Ignorance - due to privacy or operational semantics, the requester doesn't know the current state\n+\n+Following the possible error messages, we'll discuss a few possible causes and remedies.\n+\n+ContractId Not Found During Interpretation\n+..........................................\n+\n+.. code-block:: none \n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find contract ContractId(004481eb78464f1ed3291b06504d5619db4f110df71cb5764717e1c4d3aa096b9f).\n+\n+ContractId Not Found During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find contract ContractId (00c06fa370f8858b20fd100423d928b1d200d8e3c9975600b9c038307ed6e25d6f).\n+\n+fetchByKey Error during Interpretation\n+......................................\n+\n+.. code-block:: none\n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d.\n+\n+fetchByKey Dispute During Validation\n+....................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d\n+\n+lookupByKey Distpute During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: recreated and original transaction mismatch VersionedTransaction(...) expected, but VersionedTransaction(...) is recreated.\n+\n+Avoiding Race Conditions and Stale References\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The first thing to avoid is write-write or write-read contention on contracts. In other words, one requester submitting a transaction with a consuming exercise on a contract while another requester submits another exercise or fetch on the same contract. This type of contention cannot be eliminated entirely, for there will always be some latency between a client submitting a command to a participant, and other clients learning of the committed transaction.\n+\n+Here are a few scenarios and measures you can take to reduce this type of collision:\n+\n+1. Shard data. Imagine you want to store a user directory on the Ledger. At the core, this is of type ``[(Text, Party)]``, where ``Text`` is a display name and `Party` the associated Party. If you store this entire list on a single contract, any two users wanting to update their display name at the same time will cause a collision. If you instead keep each ``(Text, Party)`` on a separate contract, these write operations become independent from each other.\n+   \n+   The Analogy to keep in mind when structuring your data is that a template defines a table, and a contract is a row in that table. Keeping large pieces of data on a contract is like storing big blobs in a database row. If these blobs can change through different actions, you get write conflicts.\n+2. Use nonconsuming choices if you can. Nonconsuming exercises have the same contention properties as fetches: they don't collide with each other.\n+   \n+   Contract keys can seem like a way out, but they are not. Contract keys are resolved to Contract IDs during the interpretation phase on the participant node. So it reduces latencies slightly by moving resolution from the client layer to the participant layer, but it doesn't remove the issue. Going back to the auction example above, if Alice sent a command ``exerciseByKey @Auction auctionKey Bid with amount = 100``, this would be resolved to an ``exercise cid Bid with amount = 100`` during interpretation, where ``cid`` is the participant's best guess what ContractId the key refers to.\n+3. Avoid workflows that encourage multiple parties to simultaneously try to exercise a consuming choice on the same contract. For example, imagine an ``Auction`` contract containing a field ``highestBid : (Party, Decimal)``. If Alice tries to bid $100 at the same time that Bob tries to bid $90, it doesn't matter that Alice's bid is higher. The second transaction to be sequenced will be rejected as it has a write collision with the first. It's better to record the bids in separate ``Bid`` contracts, which can be written to independently. Again, think about how you would structure this data in a relational database to avoid data loss due to race conditions.\n+4. Think carefully about storing ContractIds. Imagine you had created a sharded user directory according to 1. Each user has a ``User`` contract that store their display name and party. Now you write a chat application where each ``Message`` contract refers to the sender by ``ContractId User``. If the user changes their display name, that reference goes stale. You either have to modify all messages that user ever sent, or become unable to use the sender contract in DAML."
  },
  {
    "id" : "7e246ffa-9970-43c2-b2b0-eefb6b41297d",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "5064926a-e3f8-41da-928b-91e7bcfbdb0b",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "Stakeholder refers to signatory or observer?",
        "createdAt" : "2020-09-29T19:15:04Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "569f6480-6c22-40ab-96e1-159ae9c69ea7",
        "parentId" : "5064926a-e3f8-41da-928b-91e7bcfbdb0b",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "either",
        "createdAt" : "2020-09-29T19:46:15Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : 154,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL\n+~~~~~~~~~\n+\n+If you want to do things interactively, :doc:`DAML REPL </daml-repl/index>` is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script. Run it using\n+\n+.. code-block:: none\n+\n+  daml repl --ledger-host localhost --ledger-port 6865 multi-trade.dar -i 8Dependencies -i 7Composing\n+\n+DAML REPL acts both as a language REPL (Read-Evaluate-Print Loop) as well as a shell to interact with a ledger. In other words, we can test pure expressions as well as sending commands and querying. As an example, you can use the ``length`` function from Prelude:\n+\n+.. code-block:: none\n+\n+  daml> length [1,3,2]\n+  3\n+\n+You can use ``:help`` to show the available meta-commands. Running ``:show imports`` will show you that the modules form the chapter 7 and 8 projects are already imported. That's the effect of the ``-i 8Dependencies -i 7Composing`` in the command above. You an load and unload other modules using the ``:module`` command:\n+\n+.. code-block:: none\n+\n+  daml> :module + DA.List\n+  daml> sort [1,3,2]\n+  [1,2,3]\n+\n+Now let's establish the next relationship interactively. We first need to get our hands on the Bob and CHF_Bank parties. For that, we use the ``listKnownParties`` action and filter according to display names:\n+\n+.. code-block:: none\n+\n+  daml> parties <- listKnownParties\n+  daml> parties\n+  [PartyDetails {party = 'party-3cca7cc5', displayName = Some \"Alice\", isLocal = True},PartyDetails {party = 'party-4b70184e', displayName = Some \"Bob\", isLocal = True},PartyDetails {party = 'party-6e5b60bf', displayName = Some \"USD_Bank\", isLocal = True},PartyDetails {party = 'party-3d836540', displayName = Some \"EUR_Bank\", isLocal = True}]\n+  daml> let bob = (parties!!1).party\n+  daml> let chfbank = (parties!!4).party\n+\n+Now we can run scripts from the REPL just like we would in Script:\n+\n+.. code-block:: none\n+\n+  daml> let rel = Relationship with issuer=chfbank; owner=bob\n+  daml> setupRelationship rel\n+  <contract-id>\n+\n+The last script returns a ``ContractId AssetHolder`` so the REPL prints the result of ``show`` on that, which always returns \"<contract-id>\".\n+\n+As you can see, DAML Repl is able to mix and match scripts and custom interactions seamlessly. \n+\n+Debug, Trace, and Stacktraces\n+-----------------------------\n+\n+The above demonstrates nicely how to test the happy path, but what if a function doesn't behave as you expected? DAML has two functions that allow you to do fine-grained printf debugging: ``debug`` and ``trace``. Both allow you to print something to StdOut if the code is reached. The difference between ``debug`` and ``trace`` is similar to the relationship between ``abort`` and ``error``:\n+\n+- ``debug : Text -> m ()`` maps a text to an Action that has the side-effect of printing to StdOut.\n+- ``trace : Text -> a -> a`` prints to StdOut when the expression is evaluated. \n+\n+.. code-block:: none\n+\n+  daml> let a : Script () = debug \"foo\"\n+  daml> let b : Script () = trace \"bar\" (debug \"baz\")\n+  [Daml.Script:378]: \"bar\"\n+  daml> a\n+  [DA.Internal.Prelude:540]: \"foo\"\n+  daml> b\n+  [DA.Internal.Prelude:540]: \"baz\"\n+  daml>\n+\n+If in doubt, use ``debug``. It's the easier of the two to interpret the results of.\n+\n+The thing in the square brackets is the last location. It'll tell you the DAML file and line number that triggered the printing, but often no more than that because full stacktraces could violate subtransaction privacy quite easily. If you want to enable stacktraces for some purely functional code in your modules, you can use the machinery in :doc:`/daml/stdlib/DA-Stack` to do so, but we won't cover that any further here.\n+\n+Diagnosing Contention Errors\n+----------------------------\n+\n+The above tools and functions allow you to diagnose most problems with DAML code, but they are all synchronous. The sequence of commands is determined by the sequence of inputs. That means one of the main pitfalls of distributed applications doesn't come into play: Contention.\n+\n+Contention refers to conflicts over access to contracts. DAML guarantees that there can only be one consuming choice exercised per contract so what if two parties simultaneously submit an exercise command on the same contract? Only one can succeed. Contention can also occur due to incomplete or stale knowledge. Maybe a contract was archived a little while ago, but due to latencies, a client hasn't found out yet, or maybe due to the privacy model, they never will. What all these cases have in common is that someone has incomplete knowledge of the state the ledger will be in at the time a transaction will be processed and/or committed.\n+\n+Look back that the :ref:`execution_model`. There are three places where ledger state is consumed:\n+\n+1. A command is submitted by some client, probably looking at the state of the ledger to build that command. Maybe the command includes references to ContractIds that the client believes active.\n+2. During interpretation, ledger state is used to to look up active contracts.\n+3. During commit, ledger state is again used to look up contracts and validate the transaction by reinterpreting it.\n+\n+Collisions can occur both between 1 and 2 and between 2 and 3. Only during the commit phase is the complete relevant ledger state at the time of the transaction known, which means the ledger state at commit time is king. As a DAML contract developer, you need to understand the different causes of contention, be able to diagnose the root cause if errors of this type occur, and be able to avoid collisions by designing contracts appropriately. \n+\n+Common Errors\n+~~~~~~~~~~~~~\n+\n+The most common error messages you'll see are listed below. All of them can be due to one of three reasons.\n+\n+1. Race Conditions - knowledge of a state change is not yet known during command submission\n+2. Stale References - the state change is known, but contracts have stale references to keys or ContractIds\n+3. Ignorance - due to privacy or operational semantics, the requester doesn't know the current state\n+\n+Following the possible error messages, we'll discuss a few possible causes and remedies.\n+\n+ContractId Not Found During Interpretation\n+..........................................\n+\n+.. code-block:: none \n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find contract ContractId(004481eb78464f1ed3291b06504d5619db4f110df71cb5764717e1c4d3aa096b9f).\n+\n+ContractId Not Found During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find contract ContractId (00c06fa370f8858b20fd100423d928b1d200d8e3c9975600b9c038307ed6e25d6f).\n+\n+fetchByKey Error during Interpretation\n+......................................\n+\n+.. code-block:: none\n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d.\n+\n+fetchByKey Dispute During Validation\n+....................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d\n+\n+lookupByKey Distpute During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: recreated and original transaction mismatch VersionedTransaction(...) expected, but VersionedTransaction(...) is recreated.\n+\n+Avoiding Race Conditions and Stale References\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The first thing to avoid is write-write or write-read contention on contracts. In other words, one requester submitting a transaction with a consuming exercise on a contract while another requester submits another exercise or fetch on the same contract. This type of contention cannot be eliminated entirely, for there will always be some latency between a client submitting a command to a participant, and other clients learning of the committed transaction.\n+\n+Here are a few scenarios and measures you can take to reduce this type of collision:\n+\n+1. Shard data. Imagine you want to store a user directory on the Ledger. At the core, this is of type ``[(Text, Party)]``, where ``Text`` is a display name and `Party` the associated Party. If you store this entire list on a single contract, any two users wanting to update their display name at the same time will cause a collision. If you instead keep each ``(Text, Party)`` on a separate contract, these write operations become independent from each other.\n+   \n+   The Analogy to keep in mind when structuring your data is that a template defines a table, and a contract is a row in that table. Keeping large pieces of data on a contract is like storing big blobs in a database row. If these blobs can change through different actions, you get write conflicts.\n+2. Use nonconsuming choices if you can. Nonconsuming exercises have the same contention properties as fetches: they don't collide with each other.\n+   \n+   Contract keys can seem like a way out, but they are not. Contract keys are resolved to Contract IDs during the interpretation phase on the participant node. So it reduces latencies slightly by moving resolution from the client layer to the participant layer, but it doesn't remove the issue. Going back to the auction example above, if Alice sent a command ``exerciseByKey @Auction auctionKey Bid with amount = 100``, this would be resolved to an ``exercise cid Bid with amount = 100`` during interpretation, where ``cid`` is the participant's best guess what ContractId the key refers to.\n+3. Avoid workflows that encourage multiple parties to simultaneously try to exercise a consuming choice on the same contract. For example, imagine an ``Auction`` contract containing a field ``highestBid : (Party, Decimal)``. If Alice tries to bid $100 at the same time that Bob tries to bid $90, it doesn't matter that Alice's bid is higher. The second transaction to be sequenced will be rejected as it has a write collision with the first. It's better to record the bids in separate ``Bid`` contracts, which can be written to independently. Again, think about how you would structure this data in a relational database to avoid data loss due to race conditions.\n+4. Think carefully about storing ContractIds. Imagine you had created a sharded user directory according to 1. Each user has a ``User`` contract that store their display name and party. Now you write a chat application where each ``Message`` contract refers to the sender by ``ContractId User``. If the user changes their display name, that reference goes stale. You either have to modify all messages that user ever sent, or become unable to use the sender contract in DAML.\n+\n+Collisions due to Ignorance\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The :doc:`DAML Ledger Model </concepts/ledger-model/index>` specifies authorization rules, and privacy rules. Ie it specifies what makes a transaction conformant, and who gets to see which parts of a committed transaction. It does *not* specify how a command is translated to a transaction. This may seem strange at first since the commands - create, exercise, exerciseByKey, createAndExercise - correspond so closely to actions in the ledger model. But the subtlety comes in on the read side. What happens when the participant, during interpretation, encounters a ``fetch``, ``fetchByKey``, or ``lookupByKey``?\n+\n+To illustrate the problem, let's assume there is a template ``T`` with a contract key, and Alice has witnessed two ``Create`` nodes of a contract of type ``T`` with key ``k``, but no corresponding archive nodes. Alice may not be able to order these two nodes causally in the sense of \"one create came before the other\". See :doc:`/concepts/local-ledger` for an in-depth treatment of causality on DAML Ledgers.\n+\n+So what should happen now if Alice's participant encounters a ``fetchByKey @T k`` or ``lookupByKey @T k`` during interpretation? What if it encounters a ``fetch`` node? These decisions are part of the operational semantics, and the decision of what should happen is based on the consideration that the chance of a participant submitting an invalid transaction should be minimized.\n+\n+If a ``fetch`` or ``exercise`` is encountered, the participant resolves the contract as long as it has not witnessed an archive node for that contract - ie as long as it can't guarantee that the contract is no longer active. The rationale behind this is that ``fetch`` and ``exercise`` use ContractIds, which need to come from somewhere: Command arguments, Contract arguments, or key lookups. In all three cases, someone believes the ContractId to be active still so it's worth trying.\n+\n+If a ``fetchByKey`` or ``lookupByKey`` node is encountered, the contract is only resolved if the requester is a stakeholder on an active contract with the given key. If that's not the case, there is no reason to believe that the key still resolves to some contract that was witnessed earlier. Thus, when using contract keys, make sure you make the likely requesters of transactions observers on your contracts. If you don't, ``fetchByKey`` will always fail, and ``lookupBeyKey`` will always return ``None``.\n+\n+Let's illustrate how collisions and operational semantics and interleave:\n+\n+1. Bob creates ``T`` with key ``k``. Alice is not a stakeholder."
  },
  {
    "id" : "5d3282ce-4665-4142-af90-6c474139c598",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "e19306bf-26ac-4305-a874-f628c0fef360",
        "parentId" : null,
        "author" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "body" : "So 2 is valid but is still a `None`, correct?",
        "createdAt" : "2020-09-29T19:15:28Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "anthonylusardi-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/59614480?u=a1e38232a15470bcbf95f10bf7293011710be3e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a4b2130a-85bf-4d83-b89c-a278913bdeac",
        "parentId" : "e19306bf-26ac-4305-a874-f628c0fef360",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "yes",
        "createdAt" : "2020-09-29T19:46:29Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : 157,
    "diffHunk" : "@@ -0,0 +1,283 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts:\n+\n+- DAML Script\n+- DAML Navigator\n+- DAML REPL\n+\n+DAML Script\n+~~~~~~~~~~~\n+\n+:doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+1. Run on a special Script Service in the IDE, providing the Script Views.\n+2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+4. Run against any other already running Ledger.\n+\n+Let's quickly see 2-4 in action. \n+\n+Script Service CLI Testing\n+..........................\n+\n+In your chapter 8 project, run ``daml test``. This runs the same Scripts that are run in the IDE on the same in-memory Ledger called the Script Service. Instead of views of the resulting ledger, it outputs successes and failures.\n+\n+.. code-block:: none\n+\n+  daml/Test/Intro/Asset/TradeSetup.daml:setupRoles: ok, 2 active contracts, 4 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:test_issuance: ok, 3 active contracts, 5 transactions.\n+  daml/Test/Intro/Asset/TradeSetup.daml:tradeSetup: ok, 6 active contracts, 10 transactions.\n+  daml/Test/Intro/Asset/MultiTrade.daml:testMultiTrade: ok, 12 active contracts, 28 transactions.\n+\n+If you add the command line flag ``--junit``, ``daml test`` can write the results in jUnit format, which is useful for automated testing.\n+\n+Sandbox CLI Testing\n+...................\n+\n+The next step up in terms of how \"real\" the tests are is the command ``daml test-script``. Unlike ``daml test``, these tests are performed via a Ledger API against a real Ledger. If no ledger host and port are provided, a temporary Sandbox is started to run the tests against.\n+\n+In the same project, make sure you have compiled the contracts (``daml build -o multi-trade.dar``), then run ``daml test-script --dar multi-trade.dar``. You'll see a lot more output this time, starting with a Sandbox being started up, followed by DAML Scrpipt outputs. Each script should finish with a message of the type ``Test.Intro.Asset.MultiTrade.daml:testMultiTrade SUCCESS``.\n+\n+Script Against a Running Ledger\n+...............................\n+\n+The last thing we can do with DAML Script is to run against a live ledger through the Ledger API. To see this in action, we'll initialize a Sandbox Ledger with the trade initialization data from chapter 7 model. Go to your chapter 8 project.\n+\n+#. Start a sandbox with ``daml sandbox``.\n+#. Upload the DAR file form the chapter 8 project by running ``daml ledger upload-dar multi-trade.dar``.\n+#. Run the v1Setup Script with ``daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.TradeSetup:tradeSetup``\n+\n+By default, this doesn't log much so if it returns with code 0, you can assume it was successful. But how can we check?\n+\n+DAML Navigator\n+~~~~~~~~~~~~~~\n+\n+:doc:`/tools/navigator/index` is a UI that runs against a Ledger API and allows interaction with contracts. The easiest way to start it against an already running ledger is using ``daml ledger navigator``. If successful, it will tell you ``Frontend running at http://localhost:4000.``. Navigate to that URL and log in as Alice. You'll see the three contracts created by the setup script: One ``AssetHolder`` contract for each bank, and one ``Asset``. If so, the script was successful.\n+\n+We now want establish more relationships and issue assets. We could do that using Navigator, but it would be some work.\n+\n+DAML Script with Inputs\n+~~~~~~~~~~~~~~~~~~~~~~~\n+\n+You may be tempted to run the script ``Test.Intro.Asset.MultiAsset.testMultiTrade``, but beware! That script calls ``tradeSetup``, which allocates parties. If we ran that script, we would run an entirely new setup, and then multi-leg trade on the contracts resulting from the second ``tradeSetup``. Try it out if you want to see that in action.\n+\n+Fortunately, DAML Script can take inputs in JSON format, and all the ``setupRelationship`` and ``issueAsset`` scripts are set up for that by taking ``Relationship`` and ``Asset`` record value as input. In order to use that feature, we first have to get our hands on a new party. Run ``daml ledger allocate-party CHF_Bank`` to allocate the party. You can list all known parties using ``daml ledger list-parties``.\n+\n+.. code-block:: none\n+\n+  Listing parties at localhost:6865\n+  PartyDetails {party = 'party-27089832', displayName = \"Alice\", isLocal = True}\n+  PartyDetails {party = 'party-6ccc1f1e', displayName = \"Bob\", isLocal = True}\n+  PartyDetails {party = 'party-084d5d8e', displayName = \"USD_Bank\", isLocal = True}\n+  PartyDetails {party = 'party-cee70c7b', displayName = \"EUR_Bank\", isLocal = True}\n+  PartyDetails {party = 'CHF_Bank', displayName = \"CHF_Bank\", isLocal = True}\n+\n+Now we can establish a relationship between Alice and the new party. The JSON input for a ``Relationship`` looks as you might expect:\n+\n+.. code-block:: json\n+\n+  {\n+    \"issuer\" : \"CHF_Bank\",\n+    \"owner\" : \"party-27089832\"\n+  }\n+\n+To execute the DAML Script, run the below command, replacing the party IDs.\n+\n+.. code-block:: none\n+\n+  daml script --dar multi-trade.dar --ledger-host localhost --ledger-port 6865 --script-name Test.Intro.Asset.MultiTrade:setupRelationship --input-file <(echo '{\"issuer\" : \"CHF_Bank\", \"owner\" : \"party-27089832\"}')\n+\n+Note that the ``--input-file`` flag expects a file. The ``<(..)`` is a bit of unix shell magic to provide the file contents inline. If it doesn't work on your shell, put the JSON into a file ``relationship.json``, and supply that instead. For more information on this, please refer to the :doc:`DAML Script </daml-script/index>` and :doc:`JSON Format </json-api/lf-value-specification>` docs.\n+\n+If you still have the Navigator open, you'll see a new ``AssetHolder`` for Alice appear as you run the script. That worked, but it would be cumbersome if we wanted to step through the entire multi-leg trade script this way.\n+\n+DAML REPL\n+~~~~~~~~~\n+\n+If you want to do things interactively, :doc:`DAML REPL </daml-repl/index>` is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script. Run it using\n+\n+.. code-block:: none\n+\n+  daml repl --ledger-host localhost --ledger-port 6865 multi-trade.dar -i 8Dependencies -i 7Composing\n+\n+DAML REPL acts both as a language REPL (Read-Evaluate-Print Loop) as well as a shell to interact with a ledger. In other words, we can test pure expressions as well as sending commands and querying. As an example, you can use the ``length`` function from Prelude:\n+\n+.. code-block:: none\n+\n+  daml> length [1,3,2]\n+  3\n+\n+You can use ``:help`` to show the available meta-commands. Running ``:show imports`` will show you that the modules form the chapter 7 and 8 projects are already imported. That's the effect of the ``-i 8Dependencies -i 7Composing`` in the command above. You an load and unload other modules using the ``:module`` command:\n+\n+.. code-block:: none\n+\n+  daml> :module + DA.List\n+  daml> sort [1,3,2]\n+  [1,2,3]\n+\n+Now let's establish the next relationship interactively. We first need to get our hands on the Bob and CHF_Bank parties. For that, we use the ``listKnownParties`` action and filter according to display names:\n+\n+.. code-block:: none\n+\n+  daml> parties <- listKnownParties\n+  daml> parties\n+  [PartyDetails {party = 'party-3cca7cc5', displayName = Some \"Alice\", isLocal = True},PartyDetails {party = 'party-4b70184e', displayName = Some \"Bob\", isLocal = True},PartyDetails {party = 'party-6e5b60bf', displayName = Some \"USD_Bank\", isLocal = True},PartyDetails {party = 'party-3d836540', displayName = Some \"EUR_Bank\", isLocal = True}]\n+  daml> let bob = (parties!!1).party\n+  daml> let chfbank = (parties!!4).party\n+\n+Now we can run scripts from the REPL just like we would in Script:\n+\n+.. code-block:: none\n+\n+  daml> let rel = Relationship with issuer=chfbank; owner=bob\n+  daml> setupRelationship rel\n+  <contract-id>\n+\n+The last script returns a ``ContractId AssetHolder`` so the REPL prints the result of ``show`` on that, which always returns \"<contract-id>\".\n+\n+As you can see, DAML Repl is able to mix and match scripts and custom interactions seamlessly. \n+\n+Debug, Trace, and Stacktraces\n+-----------------------------\n+\n+The above demonstrates nicely how to test the happy path, but what if a function doesn't behave as you expected? DAML has two functions that allow you to do fine-grained printf debugging: ``debug`` and ``trace``. Both allow you to print something to StdOut if the code is reached. The difference between ``debug`` and ``trace`` is similar to the relationship between ``abort`` and ``error``:\n+\n+- ``debug : Text -> m ()`` maps a text to an Action that has the side-effect of printing to StdOut.\n+- ``trace : Text -> a -> a`` prints to StdOut when the expression is evaluated. \n+\n+.. code-block:: none\n+\n+  daml> let a : Script () = debug \"foo\"\n+  daml> let b : Script () = trace \"bar\" (debug \"baz\")\n+  [Daml.Script:378]: \"bar\"\n+  daml> a\n+  [DA.Internal.Prelude:540]: \"foo\"\n+  daml> b\n+  [DA.Internal.Prelude:540]: \"baz\"\n+  daml>\n+\n+If in doubt, use ``debug``. It's the easier of the two to interpret the results of.\n+\n+The thing in the square brackets is the last location. It'll tell you the DAML file and line number that triggered the printing, but often no more than that because full stacktraces could violate subtransaction privacy quite easily. If you want to enable stacktraces for some purely functional code in your modules, you can use the machinery in :doc:`/daml/stdlib/DA-Stack` to do so, but we won't cover that any further here.\n+\n+Diagnosing Contention Errors\n+----------------------------\n+\n+The above tools and functions allow you to diagnose most problems with DAML code, but they are all synchronous. The sequence of commands is determined by the sequence of inputs. That means one of the main pitfalls of distributed applications doesn't come into play: Contention.\n+\n+Contention refers to conflicts over access to contracts. DAML guarantees that there can only be one consuming choice exercised per contract so what if two parties simultaneously submit an exercise command on the same contract? Only one can succeed. Contention can also occur due to incomplete or stale knowledge. Maybe a contract was archived a little while ago, but due to latencies, a client hasn't found out yet, or maybe due to the privacy model, they never will. What all these cases have in common is that someone has incomplete knowledge of the state the ledger will be in at the time a transaction will be processed and/or committed.\n+\n+Look back that the :ref:`execution_model`. There are three places where ledger state is consumed:\n+\n+1. A command is submitted by some client, probably looking at the state of the ledger to build that command. Maybe the command includes references to ContractIds that the client believes active.\n+2. During interpretation, ledger state is used to to look up active contracts.\n+3. During commit, ledger state is again used to look up contracts and validate the transaction by reinterpreting it.\n+\n+Collisions can occur both between 1 and 2 and between 2 and 3. Only during the commit phase is the complete relevant ledger state at the time of the transaction known, which means the ledger state at commit time is king. As a DAML contract developer, you need to understand the different causes of contention, be able to diagnose the root cause if errors of this type occur, and be able to avoid collisions by designing contracts appropriately. \n+\n+Common Errors\n+~~~~~~~~~~~~~\n+\n+The most common error messages you'll see are listed below. All of them can be due to one of three reasons.\n+\n+1. Race Conditions - knowledge of a state change is not yet known during command submission\n+2. Stale References - the state change is known, but contracts have stale references to keys or ContractIds\n+3. Ignorance - due to privacy or operational semantics, the requester doesn't know the current state\n+\n+Following the possible error messages, we'll discuss a few possible causes and remedies.\n+\n+ContractId Not Found During Interpretation\n+..........................................\n+\n+.. code-block:: none \n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find contract ContractId(004481eb78464f1ed3291b06504d5619db4f110df71cb5764717e1c4d3aa096b9f).\n+\n+ContractId Not Found During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find contract ContractId (00c06fa370f8858b20fd100423d928b1d200d8e3c9975600b9c038307ed6e25d6f).\n+\n+fetchByKey Error during Interpretation\n+......................................\n+\n+.. code-block:: none\n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d.\n+\n+fetchByKey Dispute During Validation\n+....................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d\n+\n+lookupByKey Distpute During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: recreated and original transaction mismatch VersionedTransaction(...) expected, but VersionedTransaction(...) is recreated.\n+\n+Avoiding Race Conditions and Stale References\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The first thing to avoid is write-write or write-read contention on contracts. In other words, one requester submitting a transaction with a consuming exercise on a contract while another requester submits another exercise or fetch on the same contract. This type of contention cannot be eliminated entirely, for there will always be some latency between a client submitting a command to a participant, and other clients learning of the committed transaction.\n+\n+Here are a few scenarios and measures you can take to reduce this type of collision:\n+\n+1. Shard data. Imagine you want to store a user directory on the Ledger. At the core, this is of type ``[(Text, Party)]``, where ``Text`` is a display name and `Party` the associated Party. If you store this entire list on a single contract, any two users wanting to update their display name at the same time will cause a collision. If you instead keep each ``(Text, Party)`` on a separate contract, these write operations become independent from each other.\n+   \n+   The Analogy to keep in mind when structuring your data is that a template defines a table, and a contract is a row in that table. Keeping large pieces of data on a contract is like storing big blobs in a database row. If these blobs can change through different actions, you get write conflicts.\n+2. Use nonconsuming choices if you can. Nonconsuming exercises have the same contention properties as fetches: they don't collide with each other.\n+   \n+   Contract keys can seem like a way out, but they are not. Contract keys are resolved to Contract IDs during the interpretation phase on the participant node. So it reduces latencies slightly by moving resolution from the client layer to the participant layer, but it doesn't remove the issue. Going back to the auction example above, if Alice sent a command ``exerciseByKey @Auction auctionKey Bid with amount = 100``, this would be resolved to an ``exercise cid Bid with amount = 100`` during interpretation, where ``cid`` is the participant's best guess what ContractId the key refers to.\n+3. Avoid workflows that encourage multiple parties to simultaneously try to exercise a consuming choice on the same contract. For example, imagine an ``Auction`` contract containing a field ``highestBid : (Party, Decimal)``. If Alice tries to bid $100 at the same time that Bob tries to bid $90, it doesn't matter that Alice's bid is higher. The second transaction to be sequenced will be rejected as it has a write collision with the first. It's better to record the bids in separate ``Bid`` contracts, which can be written to independently. Again, think about how you would structure this data in a relational database to avoid data loss due to race conditions.\n+4. Think carefully about storing ContractIds. Imagine you had created a sharded user directory according to 1. Each user has a ``User`` contract that store their display name and party. Now you write a chat application where each ``Message`` contract refers to the sender by ``ContractId User``. If the user changes their display name, that reference goes stale. You either have to modify all messages that user ever sent, or become unable to use the sender contract in DAML.\n+\n+Collisions due to Ignorance\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The :doc:`DAML Ledger Model </concepts/ledger-model/index>` specifies authorization rules, and privacy rules. Ie it specifies what makes a transaction conformant, and who gets to see which parts of a committed transaction. It does *not* specify how a command is translated to a transaction. This may seem strange at first since the commands - create, exercise, exerciseByKey, createAndExercise - correspond so closely to actions in the ledger model. But the subtlety comes in on the read side. What happens when the participant, during interpretation, encounters a ``fetch``, ``fetchByKey``, or ``lookupByKey``?\n+\n+To illustrate the problem, let's assume there is a template ``T`` with a contract key, and Alice has witnessed two ``Create`` nodes of a contract of type ``T`` with key ``k``, but no corresponding archive nodes. Alice may not be able to order these two nodes causally in the sense of \"one create came before the other\". See :doc:`/concepts/local-ledger` for an in-depth treatment of causality on DAML Ledgers.\n+\n+So what should happen now if Alice's participant encounters a ``fetchByKey @T k`` or ``lookupByKey @T k`` during interpretation? What if it encounters a ``fetch`` node? These decisions are part of the operational semantics, and the decision of what should happen is based on the consideration that the chance of a participant submitting an invalid transaction should be minimized.\n+\n+If a ``fetch`` or ``exercise`` is encountered, the participant resolves the contract as long as it has not witnessed an archive node for that contract - ie as long as it can't guarantee that the contract is no longer active. The rationale behind this is that ``fetch`` and ``exercise`` use ContractIds, which need to come from somewhere: Command arguments, Contract arguments, or key lookups. In all three cases, someone believes the ContractId to be active still so it's worth trying.\n+\n+If a ``fetchByKey`` or ``lookupByKey`` node is encountered, the contract is only resolved if the requester is a stakeholder on an active contract with the given key. If that's not the case, there is no reason to believe that the key still resolves to some contract that was witnessed earlier. Thus, when using contract keys, make sure you make the likely requesters of transactions observers on your contracts. If you don't, ``fetchByKey`` will always fail, and ``lookupBeyKey`` will always return ``None``.\n+\n+Let's illustrate how collisions and operational semantics and interleave:\n+\n+1. Bob creates ``T`` with key ``k``. Alice is not a stakeholder.\n+2. Alice submits a command resulting in well-authorized ``lookupByKey @T k`` during interpretation. Even if Alice witnessed 1, this will resolve to a ``None`` as Alice is not a stakeholder. This transaction is invalid at the time of interpretation, but Alice doesn't know that.\n+3. Bob submits an ``exerciseByKey @T k Archive``.\n+4. Depending on which of the transactions from 2 and 3 gets sequenced first, either just 3, or both 2 and 3 get committed. If 3 is committed before 2, 2 becomes valid while in transit."
  },
  {
    "id" : "3354df22-4758-4cc8-b75f-e183092625ed",
    "prId" : 7509,
    "comments" : [
      {
        "id" : "cd186b7d-bff6-4f8c-b743-4c93f9afa7d7",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\n4. Think carefully about storing ContractIds. Imagine you had created a sharded user directory according to 1. Each user has a ``User`` contract that store their display name and party. Now you write a chat application where each ``Message`` contract refers to the sender by ``ContractId User``. If the user changes their display name, that reference goes stale. You either have to modify all messages that user ever sent, or become unable to use the sender contract in DAML. If you need to be able to make this link inside DAML, Contract Keys help here. If the only place you need to link ``Party`` to ``User`` is the UI, it might be best to not store contract references in DAML at all.\r\n```",
        "createdAt" : "2020-09-29T19:48:39Z",
        "updatedAt" : "2020-09-29T19:51:08Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7080adfdff37981aa82b636ac60f8530d795c439",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,164 @@\n+.. Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+11 Testing DAML Contracts\n+=========================\n+\n+This chapter is all about testing and debugging the DAML contracts you've build using the tools from chapters 1-10. You've already met DAML Script as a way of testing your code inside the IDE. In this chapter you'll learn about other uses of DAML Script, as well as other tools you can use for testing and debugging. You'll also learn about a few error cases that are most likely to crop up only in actual distributed testing, and which need some care to avoid. Specifically we will cover:\n+\n+- DAML Test tooling - Script, REPL, and Navigator\n+- The ``trace`` and ``debug`` functions\n+- Contention\n+\n+Note that this section only covers testing your DAML contracts. For more holistic application testing, please refer to :doc:`/getting-started/testing`.\n+\n+If you no longer have your projects set up, please follow the setup instructions in :doc:`8_Dependencies` to get hold of the code for this chapter. There is no code specific to this chapter.\n+\n+DAML Test Tooling\n+-----------------\n+\n+There are three primary tools available in the SDK to test and interact with DAML contracts. It is highly recommended to explore the respective docs. The chapter 8 model lends itself well to being tested using these tools.\n+\n+:doc:`DAML Script </daml-script/index>` \n+  \n+   :doc:`DAML Script </daml-script/index>` should be familiar by now. It's a way to script commands and queries from multiple parties against a DAML Ledger. Unless you've browsed other sections of the documentation already, you have probably used it mostly in the IDE. However, DAML Script can do much more than that. It has four different modes of operation:\n+\n+   1. Run on a special Script Service in the IDE, providing the Script Views.\n+   2. Run the Script Service via the CLI, which is useful for quick regression testing.\n+   3. Start a Sandbox and run against that for regression testing against an actual Ledger API.\n+   4. Run against any other already running Ledger.\n+\n+:doc:`DAML Navigator </tools/navigator/index>`\n+\n+  DAML Navigator is a UI that runs against a Ledger API and allows interaction with contracts.\n+\n+:doc:`DAML REPL </daml-repl/index>`\n+\n+  If you want to do things interactively, DAML REPL is the tool to use. The best way to think of DAML REPL is as an interactive version of DAML Script, but it doubles up as a language REPL (Read-Evaluate-Print Loop), allowing you to evaluate pure expressions and inspect the results.\n+\n+Debug, Trace, and Stacktraces\n+-----------------------------\n+\n+The above demonstrates nicely how to test the happy path, but what if a function doesn't behave as you expected? DAML has two functions that allow you to do fine-grained printf debugging: ``debug`` and ``trace``. Both allow you to print something to StdOut if the code is reached. The difference between ``debug`` and ``trace`` is similar to the relationship between ``abort`` and ``error``:\n+\n+- ``debug : Text -> m ()`` maps a text to an Action that has the side-effect of printing to StdOut.\n+- ``trace : Text -> a -> a`` prints to StdOut when the expression is evaluated. \n+\n+.. code-block:: none\n+\n+  daml> let a : Script () = debug \"foo\"\n+  daml> let b : Script () = trace \"bar\" (debug \"baz\")\n+  [Daml.Script:378]: \"bar\"\n+  daml> a\n+  [DA.Internal.Prelude:540]: \"foo\"\n+  daml> b\n+  [DA.Internal.Prelude:540]: \"baz\"\n+  daml>\n+\n+If in doubt, use ``debug``. It's the easier of the two to interpret the results of.\n+\n+The thing in the square brackets is the last location. It'll tell you the DAML file and line number that triggered the printing, but often no more than that because full stacktraces could violate subtransaction privacy quite easily. If you want to enable stacktraces for some purely functional code in your modules, you can use the machinery in :doc:`/daml/stdlib/DA-Stack` to do so, but we won't cover that any further here.\n+\n+Diagnosing Contention Errors\n+----------------------------\n+\n+The above tools and functions allow you to diagnose most problems with DAML code, but they are all synchronous. The sequence of commands is determined by the sequence of inputs. That means one of the main pitfalls of distributed applications doesn't come into play: Contention.\n+\n+Contention refers to conflicts over access to contracts. DAML guarantees that there can only be one consuming choice exercised per contract so what if two parties simultaneously submit an exercise command on the same contract? Only one can succeed. Contention can also occur due to incomplete or stale knowledge. Maybe a contract was archived a little while ago, but due to latencies, a client hasn't found out yet, or maybe due to the privacy model, they never will. What all these cases have in common is that someone has incomplete knowledge of the state the ledger will be in at the time a transaction will be processed and/or committed.\n+\n+Look back that the :ref:`execution_model`. There are three places where ledger state is consumed:\n+\n+1. A command is submitted by some client, probably looking at the state of the ledger to build that command. Maybe the command includes references to ContractIds that the client believes active.\n+2. During interpretation, ledger state is used to to look up active contracts.\n+3. During commit, ledger state is again used to look up contracts and validate the transaction by reinterpreting it.\n+\n+Collisions can occur both between 1 and 2 and between 2 and 3. Only during the commit phase is the complete relevant ledger state at the time of the transaction known, which means the ledger state at commit time is king. As a DAML contract developer, you need to understand the different causes of contention, be able to diagnose the root cause if errors of this type occur, and be able to avoid collisions by designing contracts appropriately. \n+\n+Common Errors\n+~~~~~~~~~~~~~\n+\n+The most common error messages you'll see are listed below. All of them can be due to one of three reasons.\n+\n+1. Race Conditions - knowledge of a state change is not yet known during command submission\n+2. Stale References - the state change is known, but contracts have stale references to keys or ContractIds\n+3. Ignorance - due to privacy or operational semantics, the requester doesn't know the current state\n+\n+Following the possible error messages, we'll discuss a few possible causes and remedies.\n+\n+ContractId Not Found During Interpretation\n+..........................................\n+\n+.. code-block:: none \n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find contract ContractId(004481eb78464f1ed3291b06504d5619db4f110df71cb5764717e1c4d3aa096b9f).\n+\n+ContractId Not Found During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find contract ContractId (00c06fa370f8858b20fd100423d928b1d200d8e3c9975600b9c038307ed6e25d6f).\n+\n+fetchByKey Error during Interpretation\n+......................................\n+\n+.. code-block:: none\n+\n+  Command interpretation error in LF-DAMLe: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d.\n+\n+fetchByKey Dispute During Validation\n+....................................\n+\n+.. code-block:: none\n+\n+  Disputed: dependency error: couldn't find key com.daml.lf.transaction.GlobalKey@11f4913d\n+\n+lookupByKey Distpute During Validation\n+......................................\n+\n+.. code-block:: none\n+\n+  Disputed: recreated and original transaction mismatch VersionedTransaction(...) expected, but VersionedTransaction(...) is recreated.\n+\n+Avoiding Race Conditions and Stale References\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The first thing to avoid is write-write or write-read contention on contracts. In other words, one requester submitting a transaction with a consuming exercise on a contract while another requester submits another exercise or fetch on the same contract. This type of contention cannot be eliminated entirely, for there will always be some latency between a client submitting a command to a participant, and other clients learning of the committed transaction.\n+\n+Here are a few scenarios and measures you can take to reduce this type of collision:\n+\n+1. Shard data. Imagine you want to store a user directory on the Ledger. At the core, this is of type ``[(Text, Party)]``, where ``Text`` is a display name and `Party` the associated Party. If you store this entire list on a single contract, any two users wanting to update their display name at the same time will cause a collision. If you instead keep each ``(Text, Party)`` on a separate contract, these write operations become independent from each other.\n+   \n+   The Analogy to keep in mind when structuring your data is that a template defines a table, and a contract is a row in that table. Keeping large pieces of data on a contract is like storing big blobs in a database row. If these blobs can change through different actions, you get write conflicts.\n+2. Use nonconsuming choices if you can. Nonconsuming exercises have the same contention properties as fetches: they don't collide with each other.\n+   \n+   Contract keys can seem like a way out, but they are not. Contract keys are resolved to Contract IDs during the interpretation phase on the participant node. So it reduces latencies slightly by moving resolution from the client layer to the participant layer, but it doesn't remove the issue. Going back to the auction example above, if Alice sent a command ``exerciseByKey @Auction auctionKey Bid with amount = 100``, this would be resolved to an ``exercise cid Bid with amount = 100`` during interpretation, where ``cid`` is the participant's best guess what ContractId the key refers to.\n+3. Avoid workflows that encourage multiple parties to simultaneously try to exercise a consuming choice on the same contract. For example, imagine an ``Auction`` contract containing a field ``highestBid : (Party, Decimal)``. If Alice tries to bid $100 at the same time that Bob tries to bid $90, it doesn't matter that Alice's bid is higher. The second transaction to be sequenced will be rejected as it has a write collision with the first. It's better to record the bids in separate ``Bid`` contracts, which can be written to independently. Again, think about how you would structure this data in a relational database to avoid data loss due to race conditions.\n+4. Think carefully about storing ContractIds. Imagine you had created a sharded user directory according to 1. Each user has a ``User`` contract that store their display name and party. Now you write a chat application where each ``Message`` contract refers to the sender by ``ContractId User``. If the user changes their display name, that reference goes stale. You either have to modify all messages that user ever sent, or become unable to use the sender contract in DAML."
  }
]