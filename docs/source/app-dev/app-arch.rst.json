[
  {
    "id" : "e9276ff1-57d7-41f3-b920-7538eaea3f49",
    "prId" : 7504,
    "comments" : [
      {
        "id" : "cdc297ae-60de-4eb2-b4ab-b30cbb364349",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n- *Ledger Time* is chosen (and validated) to respect Causal Monotonicity: The Create action on a contract *c* always precedes (or is equal to) all other actions on *c* in Ledger Time.\r\n```",
        "createdAt" : "2020-09-29T07:24:06Z",
        "updatedAt" : "2020-09-29T07:24:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "27b351db-f91e-40e0-bed7-337cd3d3f5e3",
        "parentId" : "cdc297ae-60de-4eb2-b4ab-b30cbb364349",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I'm not sure that clarifies things. Plus I'd argue that if \"all other actions\" is the empty set, the statement is true as well.",
        "createdAt" : "2020-09-29T07:27:18Z",
        "updatedAt" : "2020-09-29T07:27:18Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "55f9fca4-dc2f-407d-86c8-4ef45166b146",
        "parentId" : "cdc297ae-60de-4eb2-b4ab-b30cbb364349",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The statement before clearly had a `<=` relationship. `precedes` is somewhat ambiguous in whether you force strict inequality or not.",
        "createdAt" : "2020-09-29T07:29:18Z",
        "updatedAt" : "2020-09-29T07:29:18Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "dfae711588db2c0bc25f95ea9d9b5d054446702c",
    "line" : 16,
    "diffHunk" : "@@ -189,21 +189,22 @@ new endpoint, it will resume normal operation.\n Dealing with time\n *****************\n \n-The DAML language contains a function :ref:`getTime <daml-ref-gettime>` which returns the ‚Äúcurrent time‚Äù. The notion of time comes with a lot of problems in a distributed setting: different participants might run slightly different clocks, transactions would not be allowed to ‚Äúovertake‚Äù each other during DAML interpretation, i.e., a long-running command could block all other commands, and many more.\n+The DAML language contains a function :ref:`getTime <daml-ref-gettime>` which returns a rough estimate of ‚Äúcurrent time‚Äù called *Ledger Time*. The notion of time comes with a lot of problems in a distributed setting: different participants might run different clocks, there may be latencies due to calculation and network, clocks may drift against each other over time, etc.\n \n-To avoid such problems, DAML provides the following concept of *ledger time*:\n+In order to provide a useful notion of time in DAML without incurring severe performance or liveness penalties, DAML has two notions of time: *Ledger Time* and *Record Time*:\n \n-- As part of command interpretation, each transaction is automatically assigned a *ledger time* by the participant server.\n-- All calls to ``getTime`` within a transaction return the *ledger time* assigned to that transaction.\n-- *Ledger time* is reasonably close to real time. To avoid transactions being rejected because the assigned *ledger time* does not match the ledger's system time exactly, DAML Ledgers define a tolerance interval around its system time. The system time is part of the ledger synchronization/consensus protocol, but is not known by the participant node at interpretation time. Transactions with a *ledger time* outside this tolerance interval will be rejected.\n-- *Ledger time* respects causal monotonicity: if a transaction ``x`` uses a contract created in another transaction ``y``, transaction ``x``\\ s ledger time will be greater than or equal to the ledger time of the referenced transaction ``y``.\n+- As part of command interpretation, each transaction is automatically assigned a *Ledger Time* by the participant server.\n+- All calls to ``getTime`` within a transaction return the *Ledger Time* assigned to that transaction.\n+- *Ledger Time* is chosen (and validated) to respect Causal Monotonicity: The Create action on a contract *c* always precedes all other actions on *c* in Ledger Time."
  },
  {
    "id" : "1d744467-01e4-4426-b8d2-c79d5de65f49",
    "prId" : 7504,
    "comments" : [
      {
        "id" : "1c300030-e711-46d9-ae9e-13d1bf9c5477",
        "parentId" : null,
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Doesn't `and not completely monotonic` somewhat contradict the earlier `*Ledger Time* is chosen (and validated) to respect Causal Monotonicity: The Create action on a contract *c* always precedes all other actions on *c* in Ledger Time.`?\r\n\r\nI guess there's a technical distinction being made but I can't see what it is without some examples. Or maybe \"completely monotonic\" should be more spelled out?",
        "createdAt" : "2020-09-29T07:36:53Z",
        "updatedAt" : "2020-09-29T07:36:53Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "dfae711588db2c0bc25f95ea9d9b5d054446702c",
    "line" : 26,
    "diffHunk" : "@@ -189,21 +189,22 @@ new endpoint, it will resume normal operation.\n Dealing with time\n *****************\n \n-The DAML language contains a function :ref:`getTime <daml-ref-gettime>` which returns the ‚Äúcurrent time‚Äù. The notion of time comes with a lot of problems in a distributed setting: different participants might run slightly different clocks, transactions would not be allowed to ‚Äúovertake‚Äù each other during DAML interpretation, i.e., a long-running command could block all other commands, and many more.\n+The DAML language contains a function :ref:`getTime <daml-ref-gettime>` which returns a rough estimate of ‚Äúcurrent time‚Äù called *Ledger Time*. The notion of time comes with a lot of problems in a distributed setting: different participants might run different clocks, there may be latencies due to calculation and network, clocks may drift against each other over time, etc.\n \n-To avoid such problems, DAML provides the following concept of *ledger time*:\n+In order to provide a useful notion of time in DAML without incurring severe performance or liveness penalties, DAML has two notions of time: *Ledger Time* and *Record Time*:\n \n-- As part of command interpretation, each transaction is automatically assigned a *ledger time* by the participant server.\n-- All calls to ``getTime`` within a transaction return the *ledger time* assigned to that transaction.\n-- *Ledger time* is reasonably close to real time. To avoid transactions being rejected because the assigned *ledger time* does not match the ledger's system time exactly, DAML Ledgers define a tolerance interval around its system time. The system time is part of the ledger synchronization/consensus protocol, but is not known by the participant node at interpretation time. Transactions with a *ledger time* outside this tolerance interval will be rejected.\n-- *Ledger time* respects causal monotonicity: if a transaction ``x`` uses a contract created in another transaction ``y``, transaction ``x``\\ s ledger time will be greater than or equal to the ledger time of the referenced transaction ``y``.\n+- As part of command interpretation, each transaction is automatically assigned a *Ledger Time* by the participant server.\n+- All calls to ``getTime`` within a transaction return the *Ledger Time* assigned to that transaction.\n+- *Ledger Time* is chosen (and validated) to respect Causal Monotonicity: The Create action on a contract *c* always precedes all other actions on *c* in Ledger Time.\n+- As part of the commit/synchronization protocol of the underlying infrastructure, every transaction is assigned a *Record Time*, which can be thought of as the infrastructures \"system time\". It's the best available notion of \"real time\", but the only guarantees on it are the guarantees the underlying infrastructure can give. It is also not known at interpretation time.\n+- *Ledger Time* is kept close to \"real time\" by bounding it against *Record Time*. Transactions where *Ledger* and *Record Time* are too far apart are rejected.\n \n-Some commands might take a long time to process, and by the time the resulting transaction is about to be committed to the ledger, it might violate the condition that *ledger time* should  be reasonably close to real time (even when considering the ledger's tolerance interval). To avoid such problems, applications can set the optional parameters :ref:`min_ledger_time_abs <com.daml.ledger.api.v1.Commands.min_ledger_time_abs>` or :ref:`min_ledger_time_rel <com.daml.ledger.api.v1.Commands.min_ledger_time_rel>` command parameters that specify (in absolute or relative terms) the minimal *ledger time* for the transaction. The ledger will then process the command, but wait with committing the resulting transaction until *ledger time* fits within the ledger's tolerance interval.\n+Some commands might take a long time to process, and by the time the resulting transaction is about to be committed to the ledger, it might violate the condition that *Ledger Time* should  be reasonably close to *Record Time* (even when considering the ledger's tolerance interval). To avoid such problems, applications can set the optional parameters :ref:`min_ledger_time_abs <com.daml.ledger.api.v1.Commands.min_ledger_time_abs>` or :ref:`min_ledger_time_rel <com.daml.ledger.api.v1.Commands.min_ledger_time_rel>` that specify (in absolute or relative terms) the minimal *Ledger Time* for the transaction. The ledger will then process the command, but wait with committing the resulting transaction until *Ledger Time* fits within the ledger's tolerance interval.\n \n How is this used in practice?\n \n-- Be aware that ``getTime`` is only reasonably close to real time. Avoid DAML workflows that rely on very accurate time measurements or high frequency time changes.\n+- Be aware that ``getTime`` is only reasonably close to real time, and not completely monotonic. Avoid DAML workflows that rely on very accurate time measurements or high frequency time changes."
  },
  {
    "id" : "90c52b59-d2ef-44d1-b9e7-4bcbda0940d4",
    "prId" : 7088,
    "comments" : [
      {
        "id" : "ec9dce54-f7aa-4c64-9c2f-33da5f56b922",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Interesting! Are \"artifact\" and \"artefact\" just the American and British spelling of the same word or do they actually mean slightly different things? Also, why is the \"i\" in \"artifact\" not pronounced like the \"i\" in \"anti\"? Given how \"artifact\" is pronounced, shouldn't it be spelled \"artefact\"? (I think I'll nominate this pair of words for our next language team meeting's section \"Hard word of the week\" üòÑ)",
        "createdAt" : "2020-08-11T17:39:36Z",
        "updatedAt" : "2020-08-11T17:39:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9a9c242c-21f9-4976-a214-b9de47748fef",
        "parentId" : "ec9dce54-f7aa-4c64-9c2f-33da5f56b922",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "yes, it's just US vs UK spelling. We try to consistently use US spelling.",
        "createdAt" : "2020-08-12T07:20:29Z",
        "updatedAt" : "2020-08-12T07:20:29Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "19af40e5553df37b8800f6de2254ac750c240585",
    "line" : 5,
    "diffHunk" : "@@ -49,7 +49,7 @@ with a JSON API server by running\n \n in the root of the project. This is the most simple DAML ledger implementation. Once your\n application matures and becomes ready for production, the ``daml deploy`` command helps you deploy\n-your frontend and DAML artefacts of your project to a production ledger. See :ref:`Deploying to DAML\n+your frontend and DAML artifacts of your project to a production ledger. See :ref:`Deploying to DAML"
  },
  {
    "id" : "e8f8870d-1307-490b-a2bd-5ae3725bcc1a",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "18451836-fee7-42b5-8b2a-5d8c0ff262ac",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "suggestion: change the 'hosted by separate participant nodes' into its own sentence and make it an example.\r\n\r\n`Ledger API endpoints; e.g., by hosting separate participant nodes that expose the same view onto the ledger.`",
        "createdAt" : "2020-07-28T07:40:30Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,24 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints hosted by separate participant nodes."
  },
  {
    "id" : "44c21395-331c-4898-94f7-85b05b899fb6",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "965d1346-c707-43e4-83fa-412c82110187",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/participant node/Ledger API endpoint",
        "createdAt" : "2020-07-28T07:40:46Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f3f9e2b3-4db6-4d90-80af-ad7b1d81e7e1",
        "parentId" : "965d1346-c707-43e4-83fa-412c82110187",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "these terms are not interchangeable. A second Ledger API endpoint can be backed by the same index DB (participant) and therefore won't have \"eventual consistency\" problems.",
        "createdAt" : "2020-07-28T08:22:00Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ffafe476-7173-4f09-a7f5-35d7b29343c9",
        "parentId" : "965d1346-c707-43e4-83fa-412c82110187",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "@gerolf-da : yes they won't have these problems, but they will be eventually consistent. So they do satisfy the assumptions here.",
        "createdAt" : "2020-07-28T08:48:07Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,24 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints hosted by separate participant nodes.\n+\n+To support switching to a different participant node at run time,"
  },
  {
    "id" : "bd94fa8a-8eb0-48e8-9e45-d06162d5029d",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "dc7e65ea-0f0d-43e5-9caa-14ae8bf1b90f",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Let's change that into an assumption on the eventually consistent ledger api endpoints. Make it explicit that these do perform command-deduplication across each other.\r\n\r\nCanton and Corda for example would do it by hosting the IndexDB in a highly-available manner and ensuring that the deduplication info is replicated as well.",
        "createdAt" : "2020-07-28T07:42:31Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a52e1979-2ede-4d0c-ab41-3ec9b364e166",
        "parentId" : "dc7e65ea-0f0d-43e5-9caa-14ae8bf1b90f",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Last time I checked, there was no defined story for \"duplicate participants\" for Canton. I think making an assumption about a highly-available IndexDB is premature.",
        "createdAt" : "2020-07-28T08:25:43Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f4d9cb6a-c846-4b13-b279-4f32899a2288",
        "parentId" : "dc7e65ea-0f0d-43e5-9caa-14ae8bf1b90f",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Agreed. I wasn't proposing that we add any commentary on this here. I was highlighting though that Canton and Corda could expose such eventually consistent Ledger API endpoints, which is why I believe using such Ledger API endpoints as the precondition for having applications that handle fail-over is OK.",
        "createdAt" : "2020-07-28T08:29:47Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "759a51a9-3877-4dba-b05c-e1d4bd74d668",
        "parentId" : "dc7e65ea-0f0d-43e5-9caa-14ae8bf1b90f",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "@gerolf-da : resolving given our direct conversations. Please reopen if you disagree.",
        "createdAt" : "2020-07-28T11:44:08Z",
        "updatedAt" : "2020-07-28T13:24:36Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,24 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints hosted by separate participant nodes.\n+\n+To support switching to a different participant node at run time,\n+your application should keep track of the last ledger offset received from the :ref:`transaction service <transaction-service>`.\n+After switching to a new participant node, subscribe to the transaction stream using the last received offset.\n+If you receive the OUT_OF_RANGE error, it means the new participant node hasn't caught up with the state on the previous participant yet\n+and your application should retry subscribing to the transaction stream until successful.\n+\n+Note that command deduplication is not guaranteed to work across participants."
  },
  {
    "id" : "8b905e82-36a6-4bd7-a2c8-4c384dbaab98",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "f649f7cd-2b3d-4688-ab8b-745bd0c8add9",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "I'd suggest adding a sentence referencing the gRPC status code explanation and explaining that we use the OUT_OF_RANGE error to indicate a state that is not reached, but might be reached.",
        "createdAt" : "2020-07-28T07:43:42Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,24 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints hosted by separate participant nodes.\n+\n+To support switching to a different participant node at run time,\n+your application should keep track of the last ledger offset received from the :ref:`transaction service <transaction-service>`.\n+After switching to a new participant node, subscribe to the transaction stream using the last received offset.\n+If you receive the OUT_OF_RANGE error, it means the new participant node hasn't caught up with the state on the previous participant yet"
  },
  {
    "id" : "afe8e528-716c-47fa-ade9-f68eefe878fc",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "b6a507e8-848e-406d-8405-926b1615de4b",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/participant node/ledger api endpoint",
        "createdAt" : "2020-07-28T08:53:16Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,29 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints\n+where command deduplication works across the Ledger API endpoints,\n+e.g., by hosting separate participant nodes that expose the same view onto the ledger.\n+Contact your ledger operator to find out whether this applies to your ledger.\n+\n+On such ledgers, applications can easily switch between Ledger API endpoints to handle participant node failovers."
  },
  {
    "id" : "0210c59e-8872-4c0f-acf8-40bdfbca59c2",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "82acb74a-2b13-427e-a55b-2ddb527b90be",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "capitalization `ledger API` -> `Ledger API`",
        "createdAt" : "2020-07-28T08:54:06Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,29 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints\n+where command deduplication works across the Ledger API endpoints,\n+e.g., by hosting separate participant nodes that expose the same view onto the ledger.\n+Contact your ledger operator to find out whether this applies to your ledger.\n+\n+On such ledgers, applications can easily switch between Ledger API endpoints to handle participant node failovers.\n+To support switching to a different ledger API endpoint at run time,"
  },
  {
    "id" : "8fea8b87-a952-448c-bac5-ccb1072d7813",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "ac1edc4c-08fc-45d7-96cd-4b6d980c91f0",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/error code/status code\r\n\r\nand link to https://grpc.github.io/grpc/core/md_doc_statuscodes.html",
        "createdAt" : "2020-07-28T08:54:49Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,29 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints\n+where command deduplication works across the Ledger API endpoints,\n+e.g., by hosting separate participant nodes that expose the same view onto the ledger.\n+Contact your ledger operator to find out whether this applies to your ledger.\n+\n+On such ledgers, applications can easily switch between Ledger API endpoints to handle participant node failovers.\n+To support switching to a different ledger API endpoint at run time,\n+your application should keep track of the last ledger offset received from the :ref:`transaction service <transaction-service>`.\n+After switching to a new Ledger API endpoint, subscribe to the transaction stream using the last received offset.\n+\n+The subscription may return a OUT_OF_RANGE error.\n+As per the gRCP error code definition, this means the subscription was attempted past the valid range, and the problem may be fixed if the system state changes."
  },
  {
    "id" : "42d892fc-76ca-44fa-9f32-59cbef9b4909",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "a9561161-e4c4-4b4d-95c6-8afeab0fcf3a",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "- add example for message\r\n- add explanation that this is due to the eventual consistency. The new Ledger API endpoint might be behind the offset requested, but it will catch up eventually.",
        "createdAt" : "2020-07-28T08:56:44Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,29 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints\n+where command deduplication works across the Ledger API endpoints,\n+e.g., by hosting separate participant nodes that expose the same view onto the ledger.\n+Contact your ledger operator to find out whether this applies to your ledger.\n+\n+On such ledgers, applications can easily switch between Ledger API endpoints to handle participant node failovers.\n+To support switching to a different ledger API endpoint at run time,\n+your application should keep track of the last ledger offset received from the :ref:`transaction service <transaction-service>`.\n+After switching to a new Ledger API endpoint, subscribe to the transaction stream using the last received offset.\n+\n+The subscription may return a OUT_OF_RANGE error."
  },
  {
    "id" : "04a7b672-900b-4e43-8655-d63bedb62aa3",
    "prId" : 6875,
    "comments" : [
      {
        "id" : "bb287e50-ef1a-443b-bd58-a1be9e3554c7",
        "parentId" : null,
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "Please state explicitly that this applies to both the transaction and transaction tree streams. As I understand this works symmetrically.",
        "createdAt" : "2020-07-28T09:26:59Z",
        "updatedAt" : "2020-07-28T13:24:35Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f90ba80245f7d9a190d5fd4c1e374c53dcf8813",
    "line" : null,
    "diffHunk" : "@@ -148,6 +148,29 @@ To use command deduplication, you should:\n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n \n+\n+.. _handling-participant-node-failover:\n+\n+Handling participant node failover\n+**********************************\n+\n+Some DAML Ledgers support exposing multiple eventually consistent Ledger API endpoints\n+where command deduplication works across the Ledger API endpoints,\n+e.g., by hosting separate participant nodes that expose the same view onto the ledger.\n+Contact your ledger operator to find out whether this applies to your ledger.\n+\n+On such ledgers, applications can easily switch between Ledger API endpoints to handle participant node failovers.\n+To support switching to a different ledger API endpoint at run time,\n+your application should keep track of the last ledger offset received from the :ref:`transaction service <transaction-service>`.\n+After switching to a new Ledger API endpoint, subscribe to the transaction stream using the last received offset."
  },
  {
    "id" : "01523041-69d0-42ad-b202-3201e9f9956e",
    "prId" : 6858,
    "comments" : [
      {
        "id" : "ff04be24-c0de-4062-9802-047e2d4e3b5b",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nDAML ledgers support a unified interface for authorization of commands. Some DAML ledgers, like for\r\nexample https://projectdabl.com, offer integrated authentication and authorization, but you can also\r\n```",
        "createdAt" : "2020-07-27T06:33:42Z",
        "updatedAt" : "2020-07-27T09:08:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7c011d512e311c4c9dc1b8e1b343e794b1382b44",
    "line" : null,
    "diffHunk" : "@@ -92,18 +92,18 @@ If you choose a different JavaScript based frontend framework, the packages ``@d\n ``@daml/types`` and the generated ``daml.js`` libraries provide you with the necessary code to\n connect and issue commands against your ledger.\n \n-Authentication\n-~~~~~~~~~~~~~~\n+Authorization\n+~~~~~~~~~~~~~\n \n When you deploy your application to a production ledger, you need to authenticate the identities of\n your users.\n \n-DAML ledgers support a unified interface for authentication of commands. Some DAML ledgers like for\n-example https://projectdabl.com offer an integrated authentication service, but you can also use an\n-external service provider for authentication like https://auth0.com. The DAML react libraries\n-support interfacing with an authenticated DAML ledger. Simply initialize your ``DamlLedger`` object\n-with the token obtained by an authentication service. How authentication works and the form of the\n-required tokens is described in the :ref:`Authentication <authentication>` section.\n+DAML ledgers support a unified interface for authorization of commands. Some DAML ledgers like for\n+example https://projectdabl.com offer integrated authentication and authorization, but you can also"
  },
  {
    "id" : "01d12244-5c60-43ee-8aa6-2d13233f2344",
    "prId" : 6858,
    "comments" : [
      {
        "id" : "9c1c0095-7234-494e-94e1-ee2eba205f47",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n``DamlLedger`` object with the token obtained by the respective token issuer. How authorization works and the\r\n```",
        "createdAt" : "2020-07-27T06:34:44Z",
        "updatedAt" : "2020-07-27T09:08:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7c011d512e311c4c9dc1b8e1b343e794b1382b44",
    "line" : null,
    "diffHunk" : "@@ -92,18 +92,18 @@ If you choose a different JavaScript based frontend framework, the packages ``@d\n ``@daml/types`` and the generated ``daml.js`` libraries provide you with the necessary code to\n connect and issue commands against your ledger.\n \n-Authentication\n-~~~~~~~~~~~~~~\n+Authorization\n+~~~~~~~~~~~~~\n \n When you deploy your application to a production ledger, you need to authenticate the identities of\n your users.\n \n-DAML ledgers support a unified interface for authentication of commands. Some DAML ledgers like for\n-example https://projectdabl.com offer an integrated authentication service, but you can also use an\n-external service provider for authentication like https://auth0.com. The DAML react libraries\n-support interfacing with an authenticated DAML ledger. Simply initialize your ``DamlLedger`` object\n-with the token obtained by an authentication service. How authentication works and the form of the\n-required tokens is described in the :ref:`Authentication <authentication>` section.\n+DAML ledgers support a unified interface for authorization of commands. Some DAML ledgers like for\n+example https://projectdabl.com offer integrated authentication and authorization, but you can also\n+use an external service provider like https://auth0.com. The DAML react libraries support interfacing\n+with a DAML ledger that validates authorization of incoming requests. Simply initialize your\n+``DamlLedger`` object with the token obtained by the proper issuer. How authorization works and the"
  },
  {
    "id" : "8628c3b8-5d3d-4d1d-99f2-6e70c73a5385",
    "prId" : 5449,
    "comments" : [
      {
        "id" : "07489186-97fa-415f-af2f-f90d78eb004a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\ntypes and templates in the DALF and TypeScript typings them. In ``create-daml-app``, ``ui/package.json`` refers to these\r\n```",
        "createdAt" : "2020-04-06T12:54:56Z",
        "updatedAt" : "2020-04-06T13:00:31Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "09956089e03794d11e8dbb59422d2930569718c1",
    "line" : null,
    "diffHunk" : "@@ -76,17 +76,17 @@ You can install any of these libraries by running ``yarn add <library>`` in the\n your project, e.g. ``yarn add @daml/react``. Please explore the ``create-daml-app`` example project\n to see the usage of these libraries.\n \n-To make your life easy when interacting with the ledger, the DAML assistant can generate\n-corresponding JavaScript data definitions for the data types declared in the deployed DAR.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate JavaScript\n+libraries from the data types declared in the deployed DAR.\n \n .. code-block:: bash\n \n   daml codegen js .daml/dist/<your-project-name.dar> -o daml.js\n \n-This command will generate a JavaScript library for each DALF in you DAR.\n-In ``create-daml-app``, ``ui/package.json`` refers to these libraries via the\n-``\"create-daml-app\": \"file:../daml.js/create-daml-app-0.1.0\"`` entry in\n-the ``dependencies`` field.\n+This command will generate a JavaScript library for each DALF in you DAR, containing metadata about\n+types and templates in the DALF. In ``create-daml-app``, ``ui/package.json`` refers to these"
  },
  {
    "id" : "44e695cd-a8a4-449a-b1cd-33c2ce6fc88e",
    "prId" : 5449,
    "comments" : [
      {
        "id" : "21d9d92b-98c2-4326-938e-3d5e0e7930d5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nlibraries with TypeScript typings from the data types declared in the deployed DAR.\r\n```",
        "createdAt" : "2020-04-06T12:56:08Z",
        "updatedAt" : "2020-04-06T13:00:31Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "09956089e03794d11e8dbb59422d2930569718c1",
    "line" : null,
    "diffHunk" : "@@ -76,17 +76,17 @@ You can install any of these libraries by running ``yarn add <library>`` in the\n your project, e.g. ``yarn add @daml/react``. Please explore the ``create-daml-app`` example project\n to see the usage of these libraries.\n \n-To make your life easy when interacting with the ledger, the DAML assistant can generate\n-corresponding JavaScript data definitions for the data types declared in the deployed DAR.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate JavaScript\n+libraries from the data types declared in the deployed DAR."
  },
  {
    "id" : "42c8a186-459f-4d51-b5c4-a5351069e979",
    "prId" : 5421,
    "comments" : [
      {
        "id" : "6aac18d9-8bbc-4bd0-814c-83b0103464cd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The codegen does not only generate types but also JavaScript objects containing metadata about the types and templates in the DALF. We should mention that here.",
        "createdAt" : "2020-04-03T13:33:11Z",
        "updatedAt" : "2020-04-06T11:24:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "520d977d-791d-4d57-9263-60ed334dda1b",
        "parentId" : "6aac18d9-8bbc-4bd0-814c-83b0103464cd",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I'll update the description of daml2js in the next PR. This one is only about the typings.",
        "createdAt" : "2020-04-03T14:05:12Z",
        "updatedAt" : "2020-04-06T11:24:00Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aee4fc8b-e85f-4fe8-b2e7-de227a51e05a",
        "parentId" : "6aac18d9-8bbc-4bd0-814c-83b0103464cd",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I'm just working on the next PR, but I wouldn't mention the metadata here. This chapter was ment to be as simple an accesible as possible.",
        "createdAt" : "2020-04-03T14:26:56Z",
        "updatedAt" : "2020-04-06T11:24:00Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "301b85a5-5704-4f25-8cef-c4296f8c3c01",
        "parentId" : "6aac18d9-8bbc-4bd0-814c-83b0103464cd",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not sure there's a way around mentioning the metadata. The JavaScript part of the generated code doesn't contain anything bit metadata. You don't need to go into any sort of details, just say something like \"the generated JavaScript contains metadata about the types and templates in the DAML package\" and that's it.",
        "createdAt" : "2020-04-03T17:00:56Z",
        "updatedAt" : "2020-04-06T11:24:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6bce4cea4a01f4cbaf2fb5ad92268673b4507417",
    "line" : null,
    "diffHunk" : "@@ -81,13 +81,13 @@ your project, e.g. ``yarn add @daml/react``. Please explore the ``create-daml-ap\n to see the usage of these libraries.\n \n To make your life easy when interacting with the ledger, the DAML assistant can generate\n-corresponding typescript data definitions for the data types declared in the deployed DAR.\n+corresponding TypeScript data definitions for the data types declared in the deployed DAR."
  },
  {
    "id" : "505f6311-e87b-455b-bb35-aae39e9ac2d4",
    "prId" : 5421,
    "comments" : [
      {
        "id" : "16abc876-17e7-415a-8028-564c10cef79e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is generates a JavaScript library that also contains TypeScript typing for the generated JavaScript.",
        "createdAt" : "2020-04-03T13:33:56Z",
        "updatedAt" : "2020-04-06T11:24:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6bce4cea4a01f4cbaf2fb5ad92268673b4507417",
    "line" : null,
    "diffHunk" : "@@ -81,13 +81,13 @@ your project, e.g. ``yarn add @daml/react``. Please explore the ``create-daml-ap\n to see the usage of these libraries.\n \n To make your life easy when interacting with the ledger, the DAML assistant can generate\n-corresponding typescript data definitions for the data types declared in the deployed DAR.\n+corresponding TypeScript data definitions for the data types declared in the deployed DAR.\n \n .. code-block:: bash\n \n   daml codegen ts .daml/dist/<your-project-name.dar> -o daml.js\n \n-This command will generate a typescript library for each DALF in you DAR.\n+This command will generate a TypeScript library for each DALF in you DAR."
  },
  {
    "id" : "d8eaa909-ac41-41d4-bf00-31d7d024055f",
    "prId" : 5118,
    "comments" : [
      {
        "id" : "3d5e916c-016a-4f68-8d56-1b693596683c",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "The `()` in `getTime()` is odd. Looks like it's a Java(script) function. Is that meant to be there?",
        "createdAt" : "2020-03-23T20:08:12Z",
        "updatedAt" : "2020-03-25T11:56:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "05c612e0-b346-4916-9b47-c0e65ca86442",
        "parentId" : "3d5e916c-016a-4f68-8d56-1b693596683c",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "sorry, old habits die hard. Thanks.",
        "createdAt" : "2020-03-25T11:49:51Z",
        "updatedAt" : "2020-03-25T11:56:27Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eac19698c196cebd5cc1020a4ec9619a1eaae00a",
    "line" : null,
    "diffHunk" : "@@ -148,3 +148,28 @@ To use command deduplication, you should:\n \n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n+\n+.. _dealing-with-time:\n+\n+Dealing with time\n+*****************\n+\n+The DAML language contains a function :ref:`getTime() <daml-ref-gettime>` which returns the ‚Äúcurrent time‚Äù. The notion of time comes with a lot of problems in a distributed setting: different participants might run slightly different clocks, transactions would not be allowed to ‚Äúovertake‚Äù each other during DAML interpretation, i.e., a long-running command could block all other commands, and many more."
  },
  {
    "id" : "4f066536-e5de-4c11-a052-71cd797534f5",
    "prId" : 5118,
    "comments" : [
      {
        "id" : "187aec43-3c63-44d0-a750-9a3998130089",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I'd clarify here that \"system time\" is part of the synchonization/consensus protocol of ledgers. Ie it's something that's agreed on by everyone, but isn't known at interpretation time so can't be used for `getTime`.",
        "createdAt" : "2020-03-23T20:10:33Z",
        "updatedAt" : "2020-03-25T11:56:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eac19698c196cebd5cc1020a4ec9619a1eaae00a",
    "line" : null,
    "diffHunk" : "@@ -148,3 +148,28 @@ To use command deduplication, you should:\n \n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n+\n+.. _dealing-with-time:\n+\n+Dealing with time\n+*****************\n+\n+The DAML language contains a function :ref:`getTime() <daml-ref-gettime>` which returns the ‚Äúcurrent time‚Äù. The notion of time comes with a lot of problems in a distributed setting: different participants might run slightly different clocks, transactions would not be allowed to ‚Äúovertake‚Äù each other during DAML interpretation, i.e., a long-running command could block all other commands, and many more.\n+\n+To avoid such problems, DAML provides the following concept of *ledger time*:\n+\n+- As part of command interpretation, each transaction is automatically assigned a *ledger time* by the participant server.\n+- All calls to ``getTime()`` within a transaction return the *ledger time* assigned to that transaction.\n+- *Ledger time* is reasonably close to real time. To avoid transactions being rejected because the assigned *ledger time* does not match the ledger's system time exactly, DAML Ledgers define a tolerance interval around its system time. Transactions with a *ledger time* outside this tolerance interval will be rejected."
  },
  {
    "id" : "56a1d2e2-9c5b-4037-8e9f-353ada3d1664",
    "prId" : 5118,
    "comments" : [
      {
        "id" : "a1b303ff-3daf-4d00-b5e4-04ffe9944407",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\n- Set ``min_ledger_time_abs`` or ``min_ledger_time_rel`` if the duration of command interpretation and transmission is likely to take a long time relative to the tolerance interval set by the ledger.\r\n```",
        "createdAt" : "2020-03-23T20:11:56Z",
        "updatedAt" : "2020-03-25T11:56:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eac19698c196cebd5cc1020a4ec9619a1eaae00a",
    "line" : null,
    "diffHunk" : "@@ -148,3 +148,28 @@ To use command deduplication, you should:\n \n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n+\n+.. _dealing-with-time:\n+\n+Dealing with time\n+*****************\n+\n+The DAML language contains a function :ref:`getTime() <daml-ref-gettime>` which returns the ‚Äúcurrent time‚Äù. The notion of time comes with a lot of problems in a distributed setting: different participants might run slightly different clocks, transactions would not be allowed to ‚Äúovertake‚Äù each other during DAML interpretation, i.e., a long-running command could block all other commands, and many more.\n+\n+To avoid such problems, DAML provides the following concept of *ledger time*:\n+\n+- As part of command interpretation, each transaction is automatically assigned a *ledger time* by the participant server.\n+- All calls to ``getTime()`` within a transaction return the *ledger time* assigned to that transaction.\n+- *Ledger time* is reasonably close to real time. To avoid transactions being rejected because the assigned *ledger time* does not match the ledger's system time exactly, DAML Ledgers define a tolerance interval around its system time. Transactions with a *ledger time* outside this tolerance interval will be rejected.\n+- *Ledger time* respects causal monotonicity: if a transaction ``x`` uses a contract created in another transaction ``y``, transaction ``x``\\ s ledger time will be greater than or equal to the ledger time of the referenced transaction ``y``.\n+\n+Some commands might take a long time to process, and by the time the resulting transaction is about to be committed to the ledger, it might violate the condition that *ledger time* should  be reasonably close to real time (even when considering the ledger's tolerance interval). To avoid such problems, applications can set the optional parameters :ref:`min_ledger_time_abs <com.digitalasset.ledger.api.v1.Commands.min_ledger_time_abs>` or :ref:`min_ledger_time_rel <com.digitalasset.ledger.api.v1.Commands.min_ledger_time_rel>` command parameters that specify (in absolute or relative terms) the minimal *ledger time* for the transaction. The ledger will then process the command, but wait with committing the resulting transaction until *ledger time* fits within the ledger's tolerance interval.\n+\n+How is this used in practice?\n+\n+- Be aware that ``getTime()`` is only reasonably close to real time. Avoid DAML workflows that rely on very accurate time measurements or high frequency time changes.\n+- Set ``min_ledger_time_abs`` or ``min_ledger_time_rel`` if the duration of command interpretation and transmission is likely to take a long time."
  },
  {
    "id" : "c7124aae-2418-43a4-92ad-e548f0757072",
    "prId" : 5118,
    "comments" : [
      {
        "id" : "2cc9a800-e095-43b1-8119-d893620a0ede",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\n- In some corner cases, the participant node may be unable to determine a suitable ledger time by itself. If you get an error that no ledger time could be found, check whether you have contention on any contract referenced by your command or whether the referenced contracts are sensitive to small changes of ``getTime()``.\r\n```",
        "createdAt" : "2020-03-23T20:13:03Z",
        "updatedAt" : "2020-03-25T11:56:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eac19698c196cebd5cc1020a4ec9619a1eaae00a",
    "line" : null,
    "diffHunk" : "@@ -148,3 +148,28 @@ To use command deduplication, you should:\n \n \n For more details on command deduplication, see the :ref:`Ledger API Services <command-submission-service-deduplication>` documentation.\n+\n+.. _dealing-with-time:\n+\n+Dealing with time\n+*****************\n+\n+The DAML language contains a function :ref:`getTime() <daml-ref-gettime>` which returns the ‚Äúcurrent time‚Äù. The notion of time comes with a lot of problems in a distributed setting: different participants might run slightly different clocks, transactions would not be allowed to ‚Äúovertake‚Äù each other during DAML interpretation, i.e., a long-running command could block all other commands, and many more.\n+\n+To avoid such problems, DAML provides the following concept of *ledger time*:\n+\n+- As part of command interpretation, each transaction is automatically assigned a *ledger time* by the participant server.\n+- All calls to ``getTime()`` within a transaction return the *ledger time* assigned to that transaction.\n+- *Ledger time* is reasonably close to real time. To avoid transactions being rejected because the assigned *ledger time* does not match the ledger's system time exactly, DAML Ledgers define a tolerance interval around its system time. Transactions with a *ledger time* outside this tolerance interval will be rejected.\n+- *Ledger time* respects causal monotonicity: if a transaction ``x`` uses a contract created in another transaction ``y``, transaction ``x``\\ s ledger time will be greater than or equal to the ledger time of the referenced transaction ``y``.\n+\n+Some commands might take a long time to process, and by the time the resulting transaction is about to be committed to the ledger, it might violate the condition that *ledger time* should  be reasonably close to real time (even when considering the ledger's tolerance interval). To avoid such problems, applications can set the optional parameters :ref:`min_ledger_time_abs <com.digitalasset.ledger.api.v1.Commands.min_ledger_time_abs>` or :ref:`min_ledger_time_rel <com.digitalasset.ledger.api.v1.Commands.min_ledger_time_rel>` command parameters that specify (in absolute or relative terms) the minimal *ledger time* for the transaction. The ledger will then process the command, but wait with committing the resulting transaction until *ledger time* fits within the ledger's tolerance interval.\n+\n+How is this used in practice?\n+\n+- Be aware that ``getTime()`` is only reasonably close to real time. Avoid DAML workflows that rely on very accurate time measurements or high frequency time changes.\n+- Set ``min_ledger_time_abs`` or ``min_ledger_time_rel`` if the duration of command interpretation and transmission is likely to take a long time.\n+- If you get an error that no ledger time could be found, check whether you have contention on any contract referenced by your command or whether the referenced contracts are sensitive to small changes of ``getTime()``."
  },
  {
    "id" : "1c4d66b5-84fb-47d6-aa18-e2c70e5dc0cf",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "c009955e-0460-4793-aecf-78dccffe3c45",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "In the architecture image \"External Service Provider\" is crossed with an arrow. Would break the text so that it's not crossed\r\n",
        "createdAt" : "2020-03-04T15:18:26Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e8e304a7-daf7-47fb-b744-31f243b6c4da",
        "parentId" : "c009955e-0460-4793-aecf-78dccffe3c45",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "fixed by moving the arrow origin one layer outside.",
        "createdAt" : "2020-03-04T17:13:07Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : 15,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg"
  },
  {
    "id" : "1b8642f9-ab82-4d23-82f9-8d656f551e23",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "a61da740-dbdb-4b5e-8541-2db2310c6918",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\nThe above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\r\n<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\r\n```",
        "createdAt" : "2020-03-04T15:21:24Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API."
  },
  {
    "id" : "0999968f-887e-4dea-97d1-06ea8efd2c5f",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "f2a08d8d-1178-4bbe-ad7d-17a3c6c460c6",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\nTo get started quickly with the recommended application architecture clone the```",
        "createdAt" : "2020-03-04T15:22:26Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the"
  },
  {
    "id" : "5f394ef2-6d3e-4c57-8f54-bf38f1724ab1",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "15d80685-feb7-404e-b7e6-c52e3bb11596",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\n- DAML React libraries\r\n- quick iteration against against the :ref:`DAML Ledger Sandbox <sandbox-manual>`\r\n- authentication\r\n- deployment in the cloud or on `DABL <https://projectdabl.com>`_\r\n```\r\nHow is \"deployment in the cloud\" covered by the template? Do we provide scripts for automatically deploying to DABL and another cloud provider?",
        "createdAt" : "2020-03-04T15:25:06Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3ef95eca-1472-4442-823c-9d77e172b8a9",
        "parentId" : "15d80685-feb7-404e-b7e6-c52e3bb11596",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "it contains a docker file. we want to make the creation of the docker image a bit easier as a next step. also the part about deployment on DABL has yet to come.",
        "createdAt" : "2020-03-04T16:11:26Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "96c54a60-8b65-4d1a-8abc-8c20d7672fa3",
        "parentId" : "15d80685-feb7-404e-b7e6-c52e3bb11596",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Maybe then we should write something like this:\r\n\r\n\"DAR file that can be easily deployed to DABL as well as a Docker image that can be deployed to a cloud environment of your choice\"",
        "createdAt" : "2020-03-04T16:33:21Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6042c05d-931e-44cd-80a5-91da0598ae68",
        "parentId" : "15d80685-feb7-404e-b7e6-c52e3bb11596",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed it to `deploy your application in the cloud as a Docker container`. removed the part about dabl, let's wait until create-react-app actually contains instructions on how to deploy to dabl.",
        "createdAt" : "2020-03-04T17:05:37Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0a53ff95-f606-4547-9a70-62cf5096a6c1",
        "parentId" : "15d80685-feb7-404e-b7e6-c52e3bb11596",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "also added the reference to the sandbox.",
        "createdAt" : "2020-03-04T17:07:44Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication"
  },
  {
    "id" : "04c089e0-33c5-4999-94f8-73eafbc3d837",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "c6a2ae56-73af-4e1b-92b2-7dc46f83a2d5",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Can we please add examples how to use the library to the NPM for all mentioned packages? It would really make our documentation and developer experience much nicer than telling the user \"go ahead and figure it out on your own\". Our testers and internal members really complained when they had to \"chace\" it elsewhere",
        "createdAt" : "2020-03-04T15:28:24Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "673ea00e-a49c-4553-90fe-f43724e626fd",
        "parentId" : "c6a2ae56-73af-4e1b-92b2-7dc46f83a2d5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "do you want to have the doc on the npmjs.com packe or here? I thought I don't want to overload this section with details about those libraries here.",
        "createdAt" : "2020-03-04T16:13:33Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "81d48762-5461-4181-9705-774fcebc296b",
        "parentId" : "c6a2ae56-73af-4e1b-92b2-7dc46f83a2d5",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Not here üòÑnpmjs.com would be perfect",
        "createdAt" : "2020-03-04T16:34:00Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bacf44e1-70df-4ad0-8cbb-444d66b36014",
        "parentId" : "c6a2ae56-73af-4e1b-92b2-7dc46f83a2d5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "there is actually already a bit of docs there, at least for @daml/react which you should mainly use.",
        "createdAt" : "2020-03-04T16:40:01Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "02ed1361-1385-477e-8fa6-8a7e50dd29e8",
        "parentId" : "c6a2ae56-73af-4e1b-92b2-7dc46f83a2d5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "https://www.npmjs.com/package/@daml/react",
        "createdAt" : "2020-03-04T16:40:22Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f0d9ac0e-e845-455e-94b5-c3635ade8ba3",
        "parentId" : "c6a2ae56-73af-4e1b-92b2-7dc46f83a2d5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "@daml/ledger is definitely missing some docs there.",
        "createdAt" : "2020-03-04T16:40:47Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "627fa185-20b5-4a57-a5a7-6c29da215c88",
        "parentId" : "c6a2ae56-73af-4e1b-92b2-7dc46f83a2d5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I will generate docs for the typescript libraries within the packages and add a section to the building `applications chapter` as a next step, but outside this PR.",
        "createdAt" : "2020-03-06T11:17:06Z",
        "updatedAt" : "2020-03-09T10:44:35Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries."
  },
  {
    "id" : "db0f3431-7d40-45a1-abda-8442fc86d856",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "d5e5045b-6721-4a90-a528-4659e0569fb1",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Are the two (yarn install and daml-start.sh) options or I need to do both, i.e., do I need to do yarn install and daml-start.sh? If I can use only create-daml-app/daml-start.sh I would only describe that case. Ideally this would be all done in the background (typescript codegen) when the user uses daml-start.sh. ",
        "createdAt" : "2020-03-04T16:05:03Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "805b2950-b543-4b24-b2ea-301667055ba4",
        "parentId" : "d5e5045b-6721-4a90-a528-4659e0569fb1",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "you need to do both, the process is not that smooth at this point.",
        "createdAt" : "2020-03-04T16:19:48Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml2ts`` that you can install by changing directory\n+to ``daml2ts`` and running ``yarn install``. We recommend using the provided ``daml-start.sh``\n+script at the root of the project directory of ``create-daml-app``. This will take care of creating\n+and updating the ``daml2ts`` library whenever you change your DAML model automatically."
  },
  {
    "id" : "2d1c61a6-7e87-4002-9c4b-84c3a76fa63c",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "5776b867-bd39-4a08-bd8a-bfaaea75c7ef",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "If I run \"daml codegen --help\" it tells me that I can run it for scala, java, and ts. So I can't use it to generate\tvue.js code or express.js code (frontend frameworks). Would remove this part and would describe that daml2ts provides data types for other frontend frameworks/libraries that could be used instead of React, e.g., Angular. \r\n",
        "createdAt" : "2020-03-04T16:06:36Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "71d889c1-b2cd-4926-aa2e-9f05d9cea0e1",
        "parentId" : "5776b867-bd39-4a08-bd8a-bfaaea75c7ef",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed it, not mentioning the other codegen's anymore.",
        "createdAt" : "2020-03-04T16:29:59Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml2ts`` that you can install by changing directory\n+to ``daml2ts`` and running ``yarn install``. We recommend using the provided ``daml-start.sh``\n+script at the root of the project directory of ``create-daml-app``. This will take care of creating\n+and updating the ``daml2ts`` library whenever you change your DAML model automatically.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different frontend framework, the DAML assistant will also help you generate code\n+for a variety of other programming languages. Run ``daml codegen --help`` to find out more."
  },
  {
    "id" : "e4e3931d-dd72-4fea-98b4-a14e1b93ed96",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "a5ba0c87-2f8c-4ac1-9d50-23771f661580",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "We need to mention what's a dar file and reference the appropriate section in the docs, e.g., /concepts/glossary.html#dar-file-dalf-file",
        "createdAt" : "2020-03-04T16:07:58Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7c046dca-7acd-4578-9d3a-d0c470c4daa7",
        "parentId" : "a5ba0c87-2f8c-4ac1-9d50-23771f661580",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I think that's more of a detail that you don't necessarily need to know at this point. I think it's more confusing than enlightening if you just want to get started.",
        "createdAt" : "2020-03-04T16:37:23Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts"
  },
  {
    "id" : "8e11a40c-a57f-407a-9d55-2985af2dfac3",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "2567e932-dddf-4a20-be31-c988a7124da5",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "deploy-ref_overview might work instead of deploy-ref_index ",
        "createdAt" : "2020-03-04T16:10:21Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c14e0283-7440-4efc-86b3-477065460be4",
        "parentId" : "2567e932-dddf-4a20-be31-c988a7124da5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2020-03-04T16:33:41Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml2ts`` that you can install by changing directory\n+to ``daml2ts`` and running ``yarn install``. We recommend using the provided ``daml-start.sh``\n+script at the root of the project directory of ``create-daml-app``. This will take care of creating\n+and updating the ``daml2ts`` library whenever you change your DAML model automatically.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different frontend framework, the DAML assistant will also help you generate code\n+for a variety of other programming languages. Run ``daml codegen --help`` to find out more.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as\n+an interface. It is served by the HTTP JSON API server connected to the ledger API server. It\n+provides simple HTTP endpoints to interact with the ledger via GET/POST requests. If performance\n+does become a concern for you application, you can drop the HTTP JSON API server and use the\n+:ref:`gRPC API <grpc>` directly.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+When you use the ``create-daml-app`` template application you can start a local sandbox together\n+with a JSON API server by running\n \n-.. _event-driven-applications-1:\n+.. code-block:: bash\n \n-Structuring event-driven applications\n-=====================================\n+  ./daml-start.sh\n \n-Event-driven applications read a stream of transaction events from the ledger, and convert them to some other representation. This may be a record on a database, some update of a UI, or a differently formatted message that is sent to an upstream process. It may also be a command that transforms the ledger.\n+in the root of the project. This is the most simple DAML ledger implementation. Once your\n+application matures and becomes ready for production, the ``daml deploy`` command helps you deploy\n+your frontend and DAML artefacts of your project to a production ledger. See :ref:`Deploying to DAML\n+Ledgers <deploy-ref_index>` for an in depth manual for specific ledgers."
  },
  {
    "id" : "1899172e-3a12-45fc-b75a-288bfe1fe48b",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "8d34ded6-20dd-43fc-af18-15b1598ba97b",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Add a sentence why authentication is needed at the beginning of the section, e.g.,\r\n\r\nTo run your application against a :ref: `deployed ledger <deploy-ref_overview>`, you will need to add authentication.\r\n",
        "createdAt" : "2020-03-04T16:18:47Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a1849c3f-2dd4-4133-9758-b3dd3963db5d",
        "parentId" : "8d34ded6-20dd-43fc-af18-15b1598ba97b",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "done.",
        "createdAt" : "2020-03-04T16:58:51Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml2ts`` that you can install by changing directory\n+to ``daml2ts`` and running ``yarn install``. We recommend using the provided ``daml-start.sh``\n+script at the root of the project directory of ``create-daml-app``. This will take care of creating\n+and updating the ``daml2ts`` library whenever you change your DAML model automatically.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different frontend framework, the DAML assistant will also help you generate code\n+for a variety of other programming languages. Run ``daml codegen --help`` to find out more.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as\n+an interface. It is served by the HTTP JSON API server connected to the ledger API server. It\n+provides simple HTTP endpoints to interact with the ledger via GET/POST requests. If performance\n+does become a concern for you application, you can drop the HTTP JSON API server and use the\n+:ref:`gRPC API <grpc>` directly.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+When you use the ``create-daml-app`` template application you can start a local sandbox together\n+with a JSON API server by running\n \n-.. _event-driven-applications-1:\n+.. code-block:: bash\n \n-Structuring event-driven applications\n-=====================================\n+  ./daml-start.sh\n \n-Event-driven applications read a stream of transaction events from the ledger, and convert them to some other representation. This may be a record on a database, some update of a UI, or a differently formatted message that is sent to an upstream process. It may also be a command that transforms the ledger.\n+in the root of the project. This is the most simple DAML ledger implementation. Once your\n+application matures and becomes ready for production, the ``daml deploy`` command helps you deploy\n+your frontend and DAML artefacts of your project to a production ledger. See :ref:`Deploying to DAML\n+Ledgers <deploy-ref_index>` for an in depth manual for specific ledgers.\n \n-The critical thing here is that each event is processed in isolation - the application does not need to keep any application-related state between each event. It is this that differentiates it from a state-driven application.\n+Authentication\n+~~~~~~~~~~~~~~\n \n-To do this, the application should:\n+DAML ledgers support a unified interface for authentication of commands, a detailed description can"
  },
  {
    "id" : "9293260f-79a7-44a0-9b5a-06621724c1cf",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "abd70133-a2fb-4444-80d3-958c5277412a",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\n  #. Optionally test your DAML code and with scenarios (add reference to scenario testing in the docs)\r\n```",
        "createdAt" : "2020-03-04T16:22:02Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml2ts`` that you can install by changing directory\n+to ``daml2ts`` and running ``yarn install``. We recommend using the provided ``daml-start.sh``\n+script at the root of the project directory of ``create-daml-app``. This will take care of creating\n+and updating the ``daml2ts`` library whenever you change your DAML model automatically.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different frontend framework, the DAML assistant will also help you generate code\n+for a variety of other programming languages. Run ``daml codegen --help`` to find out more.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as\n+an interface. It is served by the HTTP JSON API server connected to the ledger API server. It\n+provides simple HTTP endpoints to interact with the ledger via GET/POST requests. If performance\n+does become a concern for you application, you can drop the HTTP JSON API server and use the\n+:ref:`gRPC API <grpc>` directly.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+When you use the ``create-daml-app`` template application you can start a local sandbox together\n+with a JSON API server by running\n \n-.. _event-driven-applications-1:\n+.. code-block:: bash\n \n-Structuring event-driven applications\n-=====================================\n+  ./daml-start.sh\n \n-Event-driven applications read a stream of transaction events from the ledger, and convert them to some other representation. This may be a record on a database, some update of a UI, or a differently formatted message that is sent to an upstream process. It may also be a command that transforms the ledger.\n+in the root of the project. This is the most simple DAML ledger implementation. Once your\n+application matures and becomes ready for production, the ``daml deploy`` command helps you deploy\n+your frontend and DAML artefacts of your project to a production ledger. See :ref:`Deploying to DAML\n+Ledgers <deploy-ref_index>` for an in depth manual for specific ledgers.\n \n-The critical thing here is that each event is processed in isolation - the application does not need to keep any application-related state between each event. It is this that differentiates it from a state-driven application.\n+Authentication\n+~~~~~~~~~~~~~~\n \n-To do this, the application should:\n+DAML ledgers support a unified interface for authentication of commands, a detailed description can\n+be found :ref:`here <authentication>`. Some DAML ledgers like for example https://projectdabl.com\n+offer an integrated authentication service, but you can also use an external service provider for\n+authentication like https://auth0.com. The DAML react libraries support interfacing with an\n+authenticated DAML ledger. Simply initialize your ``DamlLedger`` object with the token obtained by\n+an authentication service. How authentication works and the form of the required tokens is described\n+in the :ref:`Authentication <authentication>` section.\n \n-1. Create a connection to the Transaction Service, and instantiate a stream handler to handle the new event stream. By default, this will read events from the beginning of the ledger. This is usually not what is wanted, as it may replay already processed transactions. In this case, the application can request the stream from the current ledger end. This will, however, cause any events between the last read point and the current ledger end to be missed. If the application must start reading from the point it last stopped, it must record that point and explicitly restart the event stream from there.\n+Developer workflow\n+~~~~~~~~~~~~~~~~~~\n \n-2. Optionally, create a connection to the Command Submission Service to send any required commands back to the ledger.\n+The DAML SDK enables a local development environment with fast iteration cycles. If you run\n+``daml-start.sh`` of the ``create-daml-app``, a local DAML sandbox ledger is started that is updated\n+with your most recent DAML code on any change. Next, you can start your frontend in development mode\n+by changing to your ``ui`` directory and run ``yarn start``. This will reload your frontend whenever\n+you make changes to it. You can add unit tests for your DAML models by writing :ref:`DAML scenarios\n+<testing-using-scenarios>`. These will also be reevaluated on change.\n+A typical DAML developer workflow is to\n \n-3. Act on the content of events (type, content) to perform any action required by the application e.g. writing a database record or generating and submitting a command.\n+  #. Make a small change to your DAML data model\n+  #. Optionally add a scenario unit test to assert correctness"
  },
  {
    "id" : "f87c1a71-15ce-4d54-adbb-5ea26c2aca7b",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "ddf14f6f-e0f2-49ee-8b2e-92c8d8ba9d77",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\n  #. Edit your React components to be aligned with changes made in DAML code\r\n```\r\nNot sure if this applies here or in the line below. What changes need to be made?",
        "createdAt" : "2020-03-04T16:24:13Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5ecf5c4b-689b-40f5-9875-060416760b28",
        "parentId" : "ddf14f6f-e0f2-49ee-8b2e-92c8d8ba9d77",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "if you change your DAML code, your generated typescript datatypes will change and most likely your React code won't compile anymore.",
        "createdAt" : "2020-03-04T16:35:16Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml2ts`` that you can install by changing directory\n+to ``daml2ts`` and running ``yarn install``. We recommend using the provided ``daml-start.sh``\n+script at the root of the project directory of ``create-daml-app``. This will take care of creating\n+and updating the ``daml2ts`` library whenever you change your DAML model automatically.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different frontend framework, the DAML assistant will also help you generate code\n+for a variety of other programming languages. Run ``daml codegen --help`` to find out more.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as\n+an interface. It is served by the HTTP JSON API server connected to the ledger API server. It\n+provides simple HTTP endpoints to interact with the ledger via GET/POST requests. If performance\n+does become a concern for you application, you can drop the HTTP JSON API server and use the\n+:ref:`gRPC API <grpc>` directly.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+When you use the ``create-daml-app`` template application you can start a local sandbox together\n+with a JSON API server by running\n \n-.. _event-driven-applications-1:\n+.. code-block:: bash\n \n-Structuring event-driven applications\n-=====================================\n+  ./daml-start.sh\n \n-Event-driven applications read a stream of transaction events from the ledger, and convert them to some other representation. This may be a record on a database, some update of a UI, or a differently formatted message that is sent to an upstream process. It may also be a command that transforms the ledger.\n+in the root of the project. This is the most simple DAML ledger implementation. Once your\n+application matures and becomes ready for production, the ``daml deploy`` command helps you deploy\n+your frontend and DAML artefacts of your project to a production ledger. See :ref:`Deploying to DAML\n+Ledgers <deploy-ref_index>` for an in depth manual for specific ledgers.\n \n-The critical thing here is that each event is processed in isolation - the application does not need to keep any application-related state between each event. It is this that differentiates it from a state-driven application.\n+Authentication\n+~~~~~~~~~~~~~~\n \n-To do this, the application should:\n+DAML ledgers support a unified interface for authentication of commands, a detailed description can\n+be found :ref:`here <authentication>`. Some DAML ledgers like for example https://projectdabl.com\n+offer an integrated authentication service, but you can also use an external service provider for\n+authentication like https://auth0.com. The DAML react libraries support interfacing with an\n+authenticated DAML ledger. Simply initialize your ``DamlLedger`` object with the token obtained by\n+an authentication service. How authentication works and the form of the required tokens is described\n+in the :ref:`Authentication <authentication>` section.\n \n-1. Create a connection to the Transaction Service, and instantiate a stream handler to handle the new event stream. By default, this will read events from the beginning of the ledger. This is usually not what is wanted, as it may replay already processed transactions. In this case, the application can request the stream from the current ledger end. This will, however, cause any events between the last read point and the current ledger end to be missed. If the application must start reading from the point it last stopped, it must record that point and explicitly restart the event stream from there.\n+Developer workflow\n+~~~~~~~~~~~~~~~~~~\n \n-2. Optionally, create a connection to the Command Submission Service to send any required commands back to the ledger.\n+The DAML SDK enables a local development environment with fast iteration cycles. If you run\n+``daml-start.sh`` of the ``create-daml-app``, a local DAML sandbox ledger is started that is updated\n+with your most recent DAML code on any change. Next, you can start your frontend in development mode\n+by changing to your ``ui`` directory and run ``yarn start``. This will reload your frontend whenever\n+you make changes to it. You can add unit tests for your DAML models by writing :ref:`DAML scenarios\n+<testing-using-scenarios>`. These will also be reevaluated on change.\n+A typical DAML developer workflow is to\n \n-3. Act on the content of events (type, content) to perform any action required by the application e.g. writing a database record or generating and submitting a command.\n+  #. Make a small change to your DAML data model\n+  #. Optionally add a scenario unit test to assert correctness\n+  #. Adapt the UI such that the code compiles again against the new DAML code"
  },
  {
    "id" : "a05e4126-d892-430c-b3a0-4fa613cf53d9",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "24716cc4-7cbc-4c5d-b67c-a6c4cf6bfdcd",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\n  #. Make further changes either to your DAML and/or React code until you're happy with what you've developed\r\n```\r\nJust wanna write something so that it doesn't sound like users need to do something, this step is optional üòÑ\r\n",
        "createdAt" : "2020-03-04T16:28:47Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,120 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The presented architecture is by no means your only option, the DAML SDK provides support libraries\n+if you choose to develop your application in :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>`, or if you wish to develop directly against a :ref:`gRPC <grpc>` endpoint instead\n+of the JSON REST API.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get you started quickly with the recommended application architecture, clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against a sandbox backend\n+- deployment in the cloud or on `DABL <https://projectdabl.com>`_\n+- authentication\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml2ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml2ts`` that you can install by changing directory\n+to ``daml2ts`` and running ``yarn install``. We recommend using the provided ``daml-start.sh``\n+script at the root of the project directory of ``create-daml-app``. This will take care of creating\n+and updating the ``daml2ts`` library whenever you change your DAML model automatically.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different frontend framework, the DAML assistant will also help you generate code\n+for a variety of other programming languages. Run ``daml codegen --help`` to find out more.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as\n+an interface. It is served by the HTTP JSON API server connected to the ledger API server. It\n+provides simple HTTP endpoints to interact with the ledger via GET/POST requests. If performance\n+does become a concern for you application, you can drop the HTTP JSON API server and use the\n+:ref:`gRPC API <grpc>` directly.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+When you use the ``create-daml-app`` template application you can start a local sandbox together\n+with a JSON API server by running\n \n-.. _event-driven-applications-1:\n+.. code-block:: bash\n \n-Structuring event-driven applications\n-=====================================\n+  ./daml-start.sh\n \n-Event-driven applications read a stream of transaction events from the ledger, and convert them to some other representation. This may be a record on a database, some update of a UI, or a differently formatted message that is sent to an upstream process. It may also be a command that transforms the ledger.\n+in the root of the project. This is the most simple DAML ledger implementation. Once your\n+application matures and becomes ready for production, the ``daml deploy`` command helps you deploy\n+your frontend and DAML artefacts of your project to a production ledger. See :ref:`Deploying to DAML\n+Ledgers <deploy-ref_index>` for an in depth manual for specific ledgers.\n \n-The critical thing here is that each event is processed in isolation - the application does not need to keep any application-related state between each event. It is this that differentiates it from a state-driven application.\n+Authentication\n+~~~~~~~~~~~~~~\n \n-To do this, the application should:\n+DAML ledgers support a unified interface for authentication of commands, a detailed description can\n+be found :ref:`here <authentication>`. Some DAML ledgers like for example https://projectdabl.com\n+offer an integrated authentication service, but you can also use an external service provider for\n+authentication like https://auth0.com. The DAML react libraries support interfacing with an\n+authenticated DAML ledger. Simply initialize your ``DamlLedger`` object with the token obtained by\n+an authentication service. How authentication works and the form of the required tokens is described\n+in the :ref:`Authentication <authentication>` section.\n \n-1. Create a connection to the Transaction Service, and instantiate a stream handler to handle the new event stream. By default, this will read events from the beginning of the ledger. This is usually not what is wanted, as it may replay already processed transactions. In this case, the application can request the stream from the current ledger end. This will, however, cause any events between the last read point and the current ledger end to be missed. If the application must start reading from the point it last stopped, it must record that point and explicitly restart the event stream from there.\n+Developer workflow\n+~~~~~~~~~~~~~~~~~~\n \n-2. Optionally, create a connection to the Command Submission Service to send any required commands back to the ledger.\n+The DAML SDK enables a local development environment with fast iteration cycles. If you run\n+``daml-start.sh`` of the ``create-daml-app``, a local DAML sandbox ledger is started that is updated\n+with your most recent DAML code on any change. Next, you can start your frontend in development mode\n+by changing to your ``ui`` directory and run ``yarn start``. This will reload your frontend whenever\n+you make changes to it. You can add unit tests for your DAML models by writing :ref:`DAML scenarios\n+<testing-using-scenarios>`. These will also be reevaluated on change.\n+A typical DAML developer workflow is to\n \n-3. Act on the content of events (type, content) to perform any action required by the application e.g. writing a database record or generating and submitting a command.\n+  #. Make a small change to your DAML data model\n+  #. Optionally add a scenario unit test to assert correctness\n+  #. Adapt the UI such that the code compiles again against the new DAML code\n+  #. Extend the UI to make use of the newly introduced feature\n+  #. Restart with step 1"
  },
  {
    "id" : "37317947-588b-4bcd-adab-d0f3fe132334",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "779e90ac-1c96-4d7c-ba64-6eb1426932d0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think it‚Äôs worth mentioning here that the JSON API can be used from any language and given that basically every dev is familiar with making HTTP requests this is a much smaller step than trying to use the gRPC API.",
        "createdAt" : "2020-03-04T19:44:01Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4ea0db6a-1b1b-4f64-ab9e-8c0c9e0746b5",
        "parentId" : "779e90ac-1c96-4d7c-ba64-6eb1426932d0",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "agreed! I rearranged and added a sentence.",
        "createdAt" : "2020-03-05T16:39:49Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala"
  },
  {
    "id" : "8e8f7be4-f43f-48bb-9ac4-ad303c593a41",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "0e7eaae3-e597-4b06-b56d-3fa9361f5109",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe worth pointing out that it‚Äôs not just a demo application but also a template for building your own apps.\r\nEDIT: I see that you do this below but I would move it here to the beginning ,something like a ‚Äúsmall but fully functional demo application intended to be used as a starting point for your own applications‚Äù",
        "createdAt" : "2020-03-04T19:45:01Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1e1cac8d-f9b8-491e-ad79-b3bf16588b83",
        "parentId" : "0e7eaae3-e597-4b06-b56d-3fa9361f5109",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Some more options:\r\n- is a fully functional demo application that provides the necessary skeleton for your own project.\r\n- is a fully functional demo application that provides the necessary code base for your own project",
        "createdAt" : "2020-03-05T07:24:32Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "60599076-23a2-47cf-801c-b8e91822b5ef",
        "parentId" : "0e7eaae3-e597-4b06-b56d-3fa9361f5109",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "ok, I changed it in this spirit.",
        "createdAt" : "2020-03-05T15:08:33Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : 54,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended"
  },
  {
    "id" : "94a165c5-7737-4386-a584-0272bfdfc1a1",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "604b96c5-feac-41e9-932e-49aaf5a32cbe",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe ‚ÄúTypescript equivalents for DAML data types‚Äù or something like that would be clearer.",
        "createdAt" : "2020-03-04T19:48:16Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "79c978f6-6cf4-452e-9e1c-d9f837d038db",
        "parentId" : "604b96c5-feac-41e9-932e-49aaf5a32cbe",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Another option \"DAML data types represented in TypeScript\"",
        "createdAt" : "2020-03-05T07:37:01Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7bf46660-98ef-4e8a-8e07-4d1310b4842e",
        "parentId" : "604b96c5-feac-41e9-932e-49aaf5a32cbe",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Also update the description at npmjs.com to something like \"Library for generating DAML data types in TypeScript. If you are writing a full-stack DAML application you will need it in order to be able to communicate between your React components and DAML code\"\r\n\r\nWould be good to explain there why this is needed",
        "createdAt" : "2020-03-05T07:45:22Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2224abfd-68e4-454f-98b4-72ccd0d16ca9",
        "parentId" : "604b96c5-feac-41e9-932e-49aaf5a32cbe",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "@daml/types is not a library to generate data types in typescript, it's equivalents of core DAML types in typescript. Maybe it shouldn't be listed here at all because it's more of an implementation detail of the other two libraries. It would rather belong to a page describing our javascript bindings for people that want to use a different javascript frontend framework than react.",
        "createdAt" : "2020-03-05T14:59:04Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "728f11fe-4483-4146-8794-0125bd5c9715",
        "parentId" : "604b96c5-feac-41e9-932e-49aaf5a32cbe",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "If it's a detail and users don't used it then you're absolutely right: they don't need to know about it üòÑAs we mention it later\r\n\r\n\"If you choose a different Javascript based frontend framework, the packages ``@daml/ledger``, ``@daml/types`` and the generated ``@daml2ts`` package provide you with the necessary interface code to connect and issue commands against your ledger.\"\r\n\r\na short clarification at npmjs.com would be good enough. Or we just don't mention it in the referenced sentence üòÑ \r\n\r\n",
        "createdAt" : "2020-03-05T15:12:19Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fc535bd7-f5b0-4f12-b911-508c41deb5f8",
        "parentId" : "604b96c5-feac-41e9-932e-49aaf5a32cbe",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I removed it and will reintroduce it in a separate javascript bindings page.",
        "createdAt" : "2020-03-05T16:40:34Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploy your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |"
  },
  {
    "id" : "519e4a31-897a-42e9-ae7a-41ee50f703db",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "9620c7de-6c40-434e-8bc8-9c8e94fdf2bb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I would leave out the statement about performance here. I think we don‚Äôt really have the numbers to back up that the JSON API gives you a significant performance hit and it can even be an improvement due to caching and the fact that it handles queries smarter than you might handle them yourself.",
        "createdAt" : "2020-03-04T19:49:34Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploy your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml-ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml-ts`` that you can install by changing directory\n+to ``daml-ts`` and running ``yarn install`` and then in the root of your project ``yarn workspaces\n+run build``. To start the DAML sandbox, run the ``daml-start.sh`` script at the root of the project\n+directory of ``create-daml-app``.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different Javascript based frontend framework, the packages ``@daml/ledger``,\n+``@daml/types`` and the generated ``@daml2ts`` package provide you with the necessary interface code\n+to connect and issue commands against your ledger.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as"
  },
  {
    "id" : "8a0c4221-685d-4f41-a91c-d48772a5776a",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "1d95a0b3-54a9-4e0e-8040-c139e84d9666",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nWhen you use the ``create-daml-app`` template application, you can start a local sandbox together\r\n```",
        "createdAt" : "2020-03-04T19:49:45Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploy your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml-ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml-ts`` that you can install by changing directory\n+to ``daml-ts`` and running ``yarn install`` and then in the root of your project ``yarn workspaces\n+run build``. To start the DAML sandbox, run the ``daml-start.sh`` script at the root of the project\n+directory of ``create-daml-app``.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different Javascript based frontend framework, the packages ``@daml/ledger``,\n+``@daml/types`` and the generated ``@daml2ts`` package provide you with the necessary interface code\n+to connect and issue commands against your ledger.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as\n+an interface. It is served by the HTTP JSON API server connected to the ledger API server. It\n+provides simple HTTP endpoints to interact with the ledger via GET/POST requests. If performance\n+does become a concern for you application, you can drop the HTTP JSON API server and use the\n+:ref:`gRPC API <grpc>` directly.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+When you use the ``create-daml-app`` template application you can start a local sandbox together"
  },
  {
    "id" : "e2c10a43-89c7-46ff-9ad3-127661b7e0a0",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think the docs on event-driven applications and state-driven applications are still relevant and useful. They are mostly independent of your client stack (unless your client stack forces you into one). E.g., I‚Äôve had discussions around whether triggers should be state or event-based fairly frequently. Not quite sure where to integrate it but it would be a shame to drop it completely.",
        "createdAt" : "2020-03-04T19:52:22Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a79209da-0877-49ca-9c2a-0f1f29a749c7",
        "parentId" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I'm still quite undecided about the overall structure of the text, I think this part may survive, but maybe closer somewhere to the triggers?",
        "createdAt" : "2020-03-05T14:26:23Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3e2b9874-113b-482b-b739-b03185019581",
        "parentId" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The trigger API pretty much forces you to write state-based automation. It probably makes more sense to have something a bit more generic that talks about ledger clients in general.",
        "createdAt" : "2020-03-05T14:27:50Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "741b855a-bf6d-4f80-9e88-517d98b78ef1",
        "parentId" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "My 2 cents are that this page should be just about the recommended architecture, straightforward and simple. Stat vs. event driven application discussion should be placed somewhere else (with concrete examples, current text in the docs reads like theory more). ",
        "createdAt" : "2020-03-05T14:32:06Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1ffd00b7-89cd-4c4c-bfab-cc592dbe1af9",
        "parentId" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I also think this part needs to go somewhere else. It's way too scary for someone who just gets started.",
        "createdAt" : "2020-03-05T14:47:26Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0f2ab633-03de-4e67-b9b9-ed4ef4f8dca9",
        "parentId" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I fully agree! I just would like for it to not be completely lost.",
        "createdAt" : "2020-03-05T14:48:32Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9e937087-da2f-4717-a968-d272924b4d12",
        "parentId" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : " I'll move it to a .back file for now and we figure out what to do with it later. Ok?",
        "createdAt" : "2020-03-05T17:03:48Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9b1da5c3-0c3f-462e-8e1f-dea1adfbd431",
        "parentId" : "1b82a1a5-b2bf-42fc-ae50-fbf0d00fa684",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":+1:",
        "createdAt" : "2020-03-05T19:14:57Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : 139,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploy your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml-ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml-ts`` that you can install by changing directory\n+to ``daml-ts`` and running ``yarn install`` and then in the root of your project ``yarn workspaces\n+run build``. To start the DAML sandbox, run the ``daml-start.sh`` script at the root of the project\n+directory of ``create-daml-app``.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+If you choose a different Javascript based frontend framework, the packages ``@daml/ledger``,\n+``@daml/types`` and the generated ``@daml2ts`` package provide you with the necessary interface code\n+to connect and issue commands against your ledger.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n+Backend\n+~~~~~~~\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+The backend for your application can be any DAML ledger implementation. For applications where\n+performance is not of outmost importance, we recommend using the :ref:`DAML JSON API <json-api>` as\n+an interface. It is served by the HTTP JSON API server connected to the ledger API server. It\n+provides simple HTTP endpoints to interact with the ledger via GET/POST requests. If performance\n+does become a concern for you application, you can drop the HTTP JSON API server and use the\n+:ref:`gRPC API <grpc>` directly.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+When you use the ``create-daml-app`` template application you can start a local sandbox together\n+with a JSON API server by running\n \n-.. _event-driven-applications-1:\n+.. code-block:: bash\n \n-Structuring event-driven applications"
  },
  {
    "id" : "a52fe46e-6721-48de-9da6-b8fdf9f49586",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "500f3dfb-0b65-431c-8fe4-4ecb0f0a79d3",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\nTo get started quickly with the recommended application architecture clone the\r\n```",
        "createdAt" : "2020-03-05T07:21:57Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```"
  },
  {
    "id" : "a19188e6-e270-4ac3-a911-947d06fced5a",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "b1605b89-c80a-4cd2-ae8e-c5dba7056f61",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Maybe point to the \"Authentication\" section on this page? I think it would work better than pointing directly to the authentication page itself",
        "createdAt" : "2020-03-05T07:35:30Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2161feb6-d0ac-49dc-9dda-2ce68d323dee",
        "parentId" : "b1605b89-c80a-4cd2-ae8e-c5dba7056f61",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "not sure if I find a link just pointing to a paragraph within the same page too useful. I find it almost more annoying to read because I have to check where the link is going.",
        "createdAt" : "2020-03-05T15:21:53Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : 61,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication"
  },
  {
    "id" : "5b1efd32-01a7-4e6b-95f7-9756e94b463a",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "a40f8e65-4a22-457f-80ea-04da3c2612f0",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "I would need to run a separate command for each library, right? So yarn add @daml/react, yarn add @daml/ledger and yarn add @daml/types. If that's the case then maybe write something like\r\n\r\n\"You can install these libraries by running the following command in the ``ui``directory of your project ``yarn add @``and the name of the library (e.g., ``yarn add @daml/react`` for installing the  ``@daml/react``library)\"",
        "createdAt" : "2020-03-05T08:32:58Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "524d7ca7-8e2c-481c-8851-194540af9c1e",
        "parentId" : "a40f8e65-4a22-457f-80ea-04da3c2612f0",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2020-03-05T15:25:16Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploy your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory"
  },
  {
    "id" : "bb27e5fb-a719-43d2-a598-b16d4333caa1",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "ecedc266-f06b-46c3-9613-5b53d85fc363",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "This makes it sound like DAML is some sort of an interface or middleware language.  Why not move it to the backend side in the docs and explain everything there? If you run the sandbox it runs with your dar file. IMHO makes it easier to understand. \r\n\r\n",
        "createdAt" : "2020-03-05T08:42:47Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8f7c0053-10e4-4da1-8ec6-22e88c74643b",
        "parentId" : "ecedc266-f06b-46c3-9613-5b53d85fc363",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Hmm, I think it kind of is an interface language. It tells you how data is represented and how it can be changed and by whom. I don't want to move this to the backend, because otherwise I'd have to talk about the frontend in the backend section.",
        "createdAt" : "2020-03-05T16:12:03Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a1f12af4-3af3-490b-b756-04980636ba42",
        "parentId" : "ecedc266-f06b-46c3-9613-5b53d85fc363",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "@bame-da @hurryabit Can we have a consensus here on how we talk about DAML with respect to frontend and backend? At the moment in the recommended architecture it's represented as an interface language. If that's the way to go, fine. I just think it's underselling what it is and should reside on the backend side.",
        "createdAt" : "2020-03-06T07:56:51Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7b6ec13e-30d0-49be-a698-47c3409fec11",
        "parentId" : "ecedc266-f06b-46c3-9613-5b53d85fc363",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I have changed the diagram and this sentence so that hopefully everybody is happy.",
        "createdAt" : "2020-03-06T11:15:30Z",
        "updatedAt" : "2020-03-09T10:44:35Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "44067bb1-185d-4975-8abd-ab1759ad5607",
        "parentId" : "ecedc266-f06b-46c3-9613-5b53d85fc363",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "added final changes by @nemanja-da.",
        "createdAt" : "2020-03-06T18:51:57Z",
        "updatedAt" : "2020-03-09T10:44:35Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploy your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code."
  },
  {
    "id" : "8df0244a-1c6f-45a1-acbd-e5ffd68f7e06",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "f996fa75-faa4-41cf-aa7f-513c98de481a",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\nThe codegen will generate a typescript project in the ``daml-ts`` folder that needs to be connected with the rest of the architecture. To do so navigate to ``daml-ts`` and run ``yarn install`` and then ``yarn workspaces run build``.  We are currently working on making this step easier so that you don't have to do it manually.\r\n\r\nNext, to start the DAML sandbox just run the ``daml-start.sh`` script in the ``create-daml-app`` folder.\r\n```\r\n\r\nWould try to explain why all the yarn commands for daml-ts project are necessary.",
        "createdAt" : "2020-03-05T09:02:06Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "013f6388-79c4-48d5-8641-8fd440ea1532",
        "parentId" : "f996fa75-faa4-41cf-aa7f-513c98de481a",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "added this suggestion with slight modifications.",
        "createdAt" : "2020-03-05T15:37:35Z",
        "updatedAt" : "2020-03-09T10:44:34Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,121 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. If you are working with a different tech stack DAML SDK also supports :ref:`Java <java-bindings>` and :ref:`Scala\n+<scala-bindings>` bindings as well as a direct :ref:`gRPC <grpc>` endpoint (instead of JSON API)\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the```\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, including\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploy your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+It provides an excellent starting point to iterate on, so you can build your own application.\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+Frontend\n+~~~~~~~~\n \n-State-driven applications\n-=========================\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. We provide\n+several support libraries to build your React frontend for a DAML application.\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/types  <https://www.npmjs.com/package/@daml/types>`_  | DAML data types                                                          |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+You can install any of these libraries by running ``yarn add @daml/react`` in the ``ui`` directory\n+of your project. Please explore the ``create-daml-app`` example project to see the usage of these\n+libraries.\n \n-Which approach to take\n-======================\n+The interface between the frontend and the backend of your application is defined by your DAML code.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in DAML.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+.. code-block:: bash\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml-ts\n \n-Structuring an application\n-**************************\n+This will create a typescript project under ``daml-ts`` that you can install by changing directory\n+to ``daml-ts`` and running ``yarn install`` and then in the root of your project ``yarn workspaces\n+run build``. To start the DAML sandbox, run the ``daml-start.sh`` script at the root of the project\n+directory of ``create-daml-app``."
  },
  {
    "id" : "ac14ae82-85f6-4180-ac0f-d71e5f106591",
    "prId" : 4795,
    "comments" : [
      {
        "id" : "3f4d64da-279e-432a-ad06-26e63c0cb402",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "```suggestion\r\n  #. Optionally test your DAML code with scenarios \r\n```\r\nCan you add a reference for scenario testing pointing to the appropriate docs page? That should be the very last thing üòÑ ",
        "createdAt" : "2020-03-09T09:18:12Z",
        "updatedAt" : "2020-03-09T10:44:35Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cbfb0375-ba0d-44c9-8bf1-221ac0c31bd5",
        "parentId" : "3f4d64da-279e-432a-ad06-26e63c0cb402",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "yes, that's a good idea.",
        "createdAt" : "2020-03-09T10:40:37Z",
        "updatedAt" : "2020-03-09T10:44:35Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d527515d02a9fb59bb3a1652810deed56f9edf",
    "line" : null,
    "diffHunk" : "@@ -1,295 +1,124 @@\n .. Copyright (c) 2020 The DAML Authors. All rights reserved.\n .. SPDX-License-Identifier: Apache-2.0\n \n-Application architecture guide\n-#########################################\n+Application architecture\n+########################\n \n-This document is a guide to building applications that interact with a DA ledger deployment (the 'ledger'). It:\n+This section describes our recommended design of a full-stack DAML application.\n \n-- describes the characteristics of the ledger API, how this affects the way an application is built (the 'application architecture'), and why it is important to understand this when building applications\n-- describes the resources in the SDK to help with this task\n-- gives some guidelines to help you build correct, performant, and maintainable applications using all of the supported languages\n+.. image:: ./recommended_architecture.svg\n \n-Categories of application\n-*************************\n+The above image shows the recommended architecture. Of course there are many ways how you can change\n+the architecture and technology stack to fit your needs, which we'll mention in the corresponding\n+sections.\n \n-Applications that interact with the ledger normally fall into four categories:\n+To get started quickly with the recommended application architecture clone the\n+``create-daml-app`` application template:\n \n-.. list-table:: Categories of application\n-   :header-rows: 1\n+.. code-block:: bash\n \n-   * - Category\n-     - Receives transactions?\n-     - Sends commands?\n-     - Example\n-   * - Source\n-     - No\n-     - Yes\n-     - An injector that reads new contracts from a file and injects them into the system.\n-   * - Sink\n-     - Yes\n-     - No\n-     - A reader that pipes data from the ledger into an SQL database.\n-   * - Automation\n-     - Yes\n-     - Yes, responding to transactions\n-     - Automatic trade registration.\n-   * - Interactive\n-     - Yes (and displays to user)\n-     - Yes, based on user input\n-     - DA‚Äôs :doc:`Navigator </tools/navigator/index>`, which lets you see and interact with the ledger\n+  git clone https://github.com/digital-asset/create-daml-app\n \n-Additionally, applications can be written in two different styles:\n+``create-daml-app`` is a small, but fully functional demo application implementing the recommended\n+architecture, providing you with an excellent starting point for your own application. It showcases\n \n--  Event-driven - applications base their actions on individual ledger events only.\n--  State-driven - applications base their actions on some model of all contracts active on the ledger.\n+- using DAML React libraries\n+- quick iteration against the :ref:`DAML Ledger Sandbox <sandbox-manual>`.\n+- authentication\n+- deploying your application in the cloud as a Docker container\n \n-Event-driven applications\n-=========================\n+Backend\n+~~~~~~~\n \n-**Event-driven** applications react to events on the the ledger and generate commands and other outputs on a per-event basis. They do not require access to ledger state beyond the event they are reacting to.\n+The backend for your application can be any DAML ledger implementation running your DAR (:ref:`DAML\n+Archive <dar-file-dalf-file>`) file.\n \n-Examples are sink applications that read the ledger and dump events to an external store (e.g. an external (reporting) database).\n+We recommend using the :ref:`DAML JSON API <json-api>` as an interface to your frontend. It is\n+served by the HTTP JSON API server connected to the ledger API server. It provides simple HTTP\n+endpoints to interact with the ledger via GET/POST requests. However, if you prefer, you can also\n+use the :ref:`gRPC API <grpc>` directly.\n \n-State-driven applications\n-=========================\n+When you use the ``create-daml-app`` template application, you can start a local sandbox together\n+with a JSON API server by running\n \n-**State-driven** applications build up a real-time view of the ledger state by reading events and recording contract create and archive events. They then generate commands based on a given state, not just single events.\n+.. code-block:: bash\n \n-Examples of these are automation and interactive applications that let a user or code react to complex state on the ledger (e.g. the DA Navigator tool).\n+  ./daml-start.sh\n \n-Which approach to take\n-======================\n+in the root of the project. This is the most simple DAML ledger implementation. Once your\n+application matures and becomes ready for production, the ``daml deploy`` command helps you deploy\n+your frontend and DAML artefacts of your project to a production ledger. See :ref:`Deploying to DAML\n+Ledgers <deploy-ref_overview>` for an in depth manual for specific ledgers.\n \n-For all except the simplest applications, we generally recommend the state-driven approach. State-driven applications are easier to reason about when determining correctness, so this makes design and implementation easier.\n+Frontend\n+~~~~~~~~\n \n-In practice, most applications are actually a mixture of the two styles, with one predominating. It is easier to add some event handling to a state-driven application, so it is better to start with that style.\n+We recommended building your frontend with the `React <https://reactjs.org>`_ framework. However,\n+you can choose virtually any language for your frontend and interact with the ledger via :ref:`HTTP\n+JSON <json-api>` endpoints. In addition, we provide support libraries for :ref:`Java\n+<java-bindings>` and :ref:`Scala <scala-bindings>` and you can also interact with the :ref:`gRPC API\n+<grpc>` directly.\n \n-Structuring an application\n-**************************\n+.. TODO (drsk) add and point to javascript bindings.\n+.. If you choose a different Javascript based frontend framework, the packages ``@daml/ledger``,\n+.. ``@daml/types`` and the generated ``@daml2ts`` package provide you with the necessary interface code\n+.. to connect and issue commands against your ledger.\n \n-Although applications that communicate with the ledger have many purposes, they generally have some common features, usually related to their style: event-driven or state-driven. This section describes these commonalities, and the major functions of each of these styles.\n+We provide two libraries to build your React frontend for a DAML application.\n \n-In particular, all applications need to handle the asynchronous nature of the ledger API. The most important consequence of this is that applications must be multi-threaded. This is because of the asynchronous, separate streams of commands, transaction and completion events.\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| Name                                                         | Summary                                                                  |\n++==============================================================+==========================================================================+\n+| `@daml/react <https://www.npmjs.com/package/@daml/react>`_   | React hooks to query/create/exercise DAML contracts                      |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n+| `@daml/ledger <https://www.npmjs.com/package/@daml/ledger>`_ | DAML ledger object to connect and directly submit commands to the ledger |\n++--------------------------------------------------------------+--------------------------------------------------------------------------+\n \n-Although you can choose to do this in several ways, from bare threads (such as a Java Thread) through thread libraries, generally the most effective way of handling this is by adopting a reactive architecture, often using a library such as `RxJava <https://github.com/ReactiveX/RxJava>`__.\n+You can install any of these libraries by running ``yarn add <library>`` in the ``ui`` directory of\n+your project, e.g. ``yarn add @daml/react``. Please explore the ``create-daml-app`` example project\n+to see the usage of these libraries.\n \n-All the language bindings support this reactive pattern as a fundamental requirement.\n+To make your life easy when interacting with the ledger, the DAML assistant can generate\n+corresponding typescript data definitions for the data types declared in the deployed DAR.\n \n-.. _event-driven-applications-1:\n+.. code-block:: bash\n \n-Structuring event-driven applications\n-=====================================\n+  daml codegen ts .daml/dist/<your-project-name.dar> -o daml-ts\n \n-Event-driven applications read a stream of transaction events from the ledger, and convert them to some other representation. This may be a record on a database, some update of a UI, or a differently formatted message that is sent to an upstream process. It may also be a command that transforms the ledger.\n+This command will generate a typescript project in the ``daml-ts`` folder that needs to be connected\n+with your frontend code in ``ui``. To do so, navigate to ``daml-ts`` and run ``yarn install`` and\n+then ``yarn workspaces run build``.\n \n-The critical thing here is that each event is processed in isolation - the application does not need to keep any application-related state between each event. It is this that differentiates it from a state-driven application.\n+.. TODO (drsk) this process is changing right now, make sure it is documented up to date here.\n \n-To do this, the application should:\n+Authentication\n+~~~~~~~~~~~~~~\n \n-1. Create a connection to the Transaction Service, and instantiate a stream handler to handle the new event stream. By default, this will read events from the beginning of the ledger. This is usually not what is wanted, as it may replay already processed transactions. In this case, the application can request the stream from the current ledger end. This will, however, cause any events between the last read point and the current ledger end to be missed. If the application must start reading from the point it last stopped, it must record that point and explicitly restart the event stream from there.\n+When you deploy your application to a production ledger, you need to authenticate the identities of\n+your users.\n \n-2. Optionally, create a connection to the Command Submission Service to send any required commands back to the ledger.\n+DAML ledgers support a unified interface for authentication of commands. Some DAML ledgers like for\n+example https://projectdabl.com offer an integrated authentication service, but you can also use an\n+external service provider for authentication like https://auth0.com. The DAML react libraries\n+support interfacing with an authenticated DAML ledger. Simply initialize your ``DamlLedger`` object\n+with the token obtained by an authentication service. How authentication works and the form of the\n+required tokens is described in the :ref:`Authentication <authentication>` section.\n \n-3. Act on the content of events (type, content) to perform any action required by the application e.g. writing a database record or generating and submitting a command.\n+Developer workflow\n+~~~~~~~~~~~~~~~~~~\n \n-.. _state-driven-applications-1:\n+The DAML SDK enables a local development environment with fast iteration cycles. If you run\n+``daml-reload-on-change.sh`` of the ``create-daml-app``, a local DAML sandbox ledger is started that\n+is updated with your most recent DAML code on any change. Next, you can start your frontend in\n+development mode by changing to your ``ui`` directory and run ``yarn start``. This will reload your\n+frontend whenever you make changes to it. You can add unit tests for your DAML models by writing\n+:ref:`DAML scenarios <testing-using-scenarios>`. These will also be reevaluated on change.  A\n+typical DAML developer workflow is to\n \n-Structuring state-driven applications\n-=====================================\n+  #. Make a small change to your DAML data model\n+  #. Optionally test your DAML code and with scenarios (add reference to scenario testing in the docs)"
  },
  {
    "id" : "c7922e32-2a42-40b3-b4e6-600f3b13e42d",
    "prId" : 4693,
    "comments" : [
      {
        "id" : "8505072e-acd4-4115-b9d6-d6fc31138715",
        "parentId" : null,
        "author" : {
          "login" : "daravep",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/14316769?u=ecf84cb9190107a561ee4bec759072fdefd73269&v=4"
        },
        "body" : "I would say \"time to live (TTL) to each command-ID, not the command. Otherwise, people might get confused and think that we are talking here about MRT. Or you might not even want to talk about \"time-to-live\" but rather than command-id expiration time or so. ",
        "createdAt" : "2020-03-02T10:49:09Z",
        "updatedAt" : "2020-03-09T11:53:08Z",
        "lastEditedBy" : {
          "login" : "daravep",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/14316769?u=ecf84cb9190107a561ee4bec759072fdefd73269&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0f1ac049-b10a-47f3-886b-3a9652a0c51e",
        "parentId" : "8505072e-acd4-4115-b9d6-d6fc31138715",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Fair point. I will change that.",
        "createdAt" : "2020-03-04T08:41:28Z",
        "updatedAt" : "2020-03-09T11:53:08Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a9121fcfd12a70094e22694eaed833e2cf308682",
    "line" : null,
    "diffHunk" : "@@ -293,3 +293,25 @@ As a last resort for these cases, your tests can use the reset service, which le\n The reset service has a single ``reset`` method that will cause all the accumulated state to be dropped, including all active contracts, the entire history of transactions and all allocated users. Only the DAML packages loaded in the ledger are preserved, thereby saving the time needed for reloading them as opposed to simply spinning up a new ledger.\n \n The reset service momentarily shuts down the gRPC channel it communicates over, so your testing infrastructure must take this into account and, when the ``reset`` is invoked, must ensure that tests are temporarily suspended as attempts to reconnect with the rebooted ledger are performed. There is no guarantee as to how long the reset will take, so this should also be taken into account when attempting to reconnect.\n+\n+.. _handling-submission-failures:\n+\n+Handle failures when submitting commands\n+****************************************\n+\n+The interaction of a DAML application with the ledger is inherently asynchronous: applications send commands to the ledger, and some time later they see the effect of that command on the ledger.\n+\n+There are several things that can fail during this time window: the application can crash, the participant node can crash, messages can be lost on the network, or the ledger may be just slow to respond due to a high load. \n+\n+If you want to make sure no command is executed twice (especially important with non-consuming choices), your application needs to robustly handle all the various failure scenarios.\n+DAML ledgers provide **command deduplication** to solve this problem:\n+Applications can assign a ‚Äútime to live‚Äù (TTL) to each command,"
  },
  {
    "id" : "a54336d1-94e3-4408-ab1c-f81df265aad4",
    "prId" : 4693,
    "comments" : [
      {
        "id" : "0854ee79-0420-415f-b830-e417d70c96ca",
        "parentId" : null,
        "author" : {
          "login" : "daravep",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/14316769?u=ecf84cb9190107a561ee4bec759072fdefd73269&v=4"
        },
        "body" : "The explanation here makes IMHO less sense. The TTL should be chosen large enough such that the user is sure that the application will not try to resend the command ever again. \r\nThe purpose of the command-id deduplication is that you don't have to explicitly track commands but can just re-submit them without worrying about a previous one. ",
        "createdAt" : "2020-03-02T10:51:36Z",
        "updatedAt" : "2020-03-09T11:53:08Z",
        "lastEditedBy" : {
          "login" : "daravep",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/14316769?u=ecf84cb9190107a561ee4bec759072fdefd73269&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c8617342-531d-4e3f-8066-47ba003f50e6",
        "parentId" : "0854ee79-0420-415f-b830-e417d70c96ca",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "The application will resend commands if:\r\n\r\n1. The application crashes and recovers, and does not know whether a given command was already sent.\r\n2. There is no observable effect (no completion event, no change in the ACS) after a long time. The application will have to assume the command was lost by the ledger and retry.\r\n\r\n\r\nTo handle the second case, you need to have a finite duration of the deduplication time window.",
        "createdAt" : "2020-03-02T16:28:31Z",
        "updatedAt" : "2020-03-09T11:53:08Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a9121fcfd12a70094e22694eaed833e2cf308682",
    "line" : null,
    "diffHunk" : "@@ -293,3 +293,25 @@ As a last resort for these cases, your tests can use the reset service, which le\n The reset service has a single ``reset`` method that will cause all the accumulated state to be dropped, including all active contracts, the entire history of transactions and all allocated users. Only the DAML packages loaded in the ledger are preserved, thereby saving the time needed for reloading them as opposed to simply spinning up a new ledger.\n \n The reset service momentarily shuts down the gRPC channel it communicates over, so your testing infrastructure must take this into account and, when the ``reset`` is invoked, must ensure that tests are temporarily suspended as attempts to reconnect with the rebooted ledger are performed. There is no guarantee as to how long the reset will take, so this should also be taken into account when attempting to reconnect.\n+\n+.. _handling-submission-failures:\n+\n+Handle failures when submitting commands\n+****************************************\n+\n+The interaction of a DAML application with the ledger is inherently asynchronous: applications send commands to the ledger, and some time later they see the effect of that command on the ledger.\n+\n+There are several things that can fail during this time window: the application can crash, the participant node can crash, messages can be lost on the network, or the ledger may be just slow to respond due to a high load. \n+\n+If you want to make sure no command is executed twice (especially important with non-consuming choices), your application needs to robustly handle all the various failure scenarios.\n+DAML ledgers provide **command deduplication** to solve this problem:\n+Applications can assign a ‚Äútime to live‚Äù (TTL) to each command,\n+and the ledger will guarantee that duplicate commands (using the same submitter and command ID) will be ignored within this time window.\n+\n+To use command deduplication, you should:\n+\n+- Use generous values for the TTL. It should be large enough such that you can assume the command was permanently lost if the TTL has passed and you still don‚Äôt observe any effect of the command on the ledger."
  },
  {
    "id" : "0e335743-7803-4293-94df-01e87b16888f",
    "prId" : 4693,
    "comments" : [
      {
        "id" : "967679bc-e1bd-41cc-a9dd-4f48325bff9e",
        "parentId" : null,
        "author" : {
          "login" : "daravep",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/14316769?u=ecf84cb9190107a561ee4bec759072fdefd73269&v=4"
        },
        "body" : "Same as above, I don't think that the last sentence is right. ",
        "createdAt" : "2020-03-02T10:52:32Z",
        "updatedAt" : "2020-03-09T11:53:08Z",
        "lastEditedBy" : {
          "login" : "daravep",
          "name" : null,
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/14316769?u=ecf84cb9190107a561ee4bec759072fdefd73269&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a9121fcfd12a70094e22694eaed833e2cf308682",
    "line" : null,
    "diffHunk" : "@@ -293,3 +293,25 @@ As a last resort for these cases, your tests can use the reset service, which le\n The reset service has a single ``reset`` method that will cause all the accumulated state to be dropped, including all active contracts, the entire history of transactions and all allocated users. Only the DAML packages loaded in the ledger are preserved, thereby saving the time needed for reloading them as opposed to simply spinning up a new ledger.\n \n The reset service momentarily shuts down the gRPC channel it communicates over, so your testing infrastructure must take this into account and, when the ``reset`` is invoked, must ensure that tests are temporarily suspended as attempts to reconnect with the rebooted ledger are performed. There is no guarantee as to how long the reset will take, so this should also be taken into account when attempting to reconnect.\n+\n+.. _handling-submission-failures:\n+\n+Handle failures when submitting commands\n+****************************************\n+\n+The interaction of a DAML application with the ledger is inherently asynchronous: applications send commands to the ledger, and some time later they see the effect of that command on the ledger.\n+\n+There are several things that can fail during this time window: the application can crash, the participant node can crash, messages can be lost on the network, or the ledger may be just slow to respond due to a high load. \n+\n+If you want to make sure no command is executed twice (especially important with non-consuming choices), your application needs to robustly handle all the various failure scenarios.\n+DAML ledgers provide **command deduplication** to solve this problem:\n+Applications can assign a ‚Äútime to live‚Äù (TTL) to each command,\n+and the ledger will guarantee that duplicate commands (using the same submitter and command ID) will be ignored within this time window.\n+\n+To use command deduplication, you should:\n+\n+- Use generous values for the TTL. It should be large enough such that you can assume the command was permanently lost if the TTL has passed and you still don‚Äôt observe any effect of the command on the ledger.\n+- Make sure you set command IDs deterministically - the \"same\" command must use the same command ID.\n+- If you are not sure whether a command was submitted successfully, just resubmit it. If the new command was submitted within the TTL window, the duplicate submission will safely be ignored. If the TTL window has passed, you can assume the command was lost or rejected and a new submission is justified."
  },
  {
    "id" : "af751735-4071-48b6-b183-912ab5995f5d",
    "prId" : 4693,
    "comments" : [
      {
        "id" : "6d29519c-2652-4df4-a406-0d4a5e12d2be",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi M√§ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "we should probably mention that the chosen ttl must fit within the ledger's configured bounds (which we should also have documented somewhere)",
        "createdAt" : "2020-03-02T16:12:10Z",
        "updatedAt" : "2020-03-09T11:53:08Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi M√§ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a9121fcfd12a70094e22694eaed833e2cf308682",
    "line" : null,
    "diffHunk" : "@@ -293,3 +293,25 @@ As a last resort for these cases, your tests can use the reset service, which le\n The reset service has a single ``reset`` method that will cause all the accumulated state to be dropped, including all active contracts, the entire history of transactions and all allocated users. Only the DAML packages loaded in the ledger are preserved, thereby saving the time needed for reloading them as opposed to simply spinning up a new ledger.\n \n The reset service momentarily shuts down the gRPC channel it communicates over, so your testing infrastructure must take this into account and, when the ``reset`` is invoked, must ensure that tests are temporarily suspended as attempts to reconnect with the rebooted ledger are performed. There is no guarantee as to how long the reset will take, so this should also be taken into account when attempting to reconnect.\n+\n+.. _handling-submission-failures:\n+\n+Handle failures when submitting commands\n+****************************************\n+\n+The interaction of a DAML application with the ledger is inherently asynchronous: applications send commands to the ledger, and some time later they see the effect of that command on the ledger.\n+\n+There are several things that can fail during this time window: the application can crash, the participant node can crash, messages can be lost on the network, or the ledger may be just slow to respond due to a high load. \n+\n+If you want to make sure no command is executed twice (especially important with non-consuming choices), your application needs to robustly handle all the various failure scenarios.\n+DAML ledgers provide **command deduplication** to solve this problem:\n+Applications can assign a ‚Äútime to live‚Äù (TTL) to each command,\n+and the ledger will guarantee that duplicate commands (using the same submitter and command ID) will be ignored within this time window.\n+\n+To use command deduplication, you should:\n+\n+- Use generous values for the TTL. It should be large enough such that you can assume the command was permanently lost if the TTL has passed and you still don‚Äôt observe any effect of the command on the ledger."
  },
  {
    "id" : "209be2a3-3ad1-4ed8-9852-8c8414a6d311",
    "prId" : 4693,
    "comments" : [
      {
        "id" : "ed1c253d-5624-4bd0-8d74-a97c02c86129",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\n- Make sure you set command IDs deterministically, that is to say: the \"same\" command must use the same command ID. This is useful for the recovery procedure after an application crash/restart, in which the application inspects the state of the ledger (e.g. via the :ref:`Active contracts service <active-contract-service>`) and sends commands to the ledger. When using deterministic command IDs, any commands that had been sent before the application restart will be discarded by the ledger to avoid duplicate submissions.\r\n```",
        "createdAt" : "2020-03-09T11:43:56Z",
        "updatedAt" : "2020-03-09T11:53:08Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a9121fcfd12a70094e22694eaed833e2cf308682",
    "line" : null,
    "diffHunk" : "@@ -122,3 +122,27 @@ typical DAML developer workflow is to\n   #. Make further changes either to your DAML and/or React code until you're happy with what you've developed\n \n .. image:: ./developer_workflow.svg\n+\n+.. _handling-submission-failures:\n+\n+Handle failures when submitting commands\n+****************************************\n+\n+The interaction of a DAML application with the ledger is inherently asynchronous: applications send commands to the ledger, and some time later they see the effect of that command on the ledger.\n+\n+There are several things that can fail during this time window: the application can crash, the participant node can crash, messages can be lost on the network, or the ledger may be just slow to respond due to a high load.\n+\n+If you want to make sure that a command is not executed twice, your application needs to robustly handle all the various failure scenarios.\n+DAML ledgers provide a mechanism for :ref:`command deduplication <command-submission-service-deduplication>` to help deal this problem.\n+\n+For each command applications provide a command ID and an optional parameter that specifies the deduplication time. If the latter parameter is not specified in the command submission itself, the ledger will fall back to using the configured maximum deduplication time.\n+The ledger will then guarantee that commands for the same submitting party and command ID will be ignored within the deduplication time window.\n+\n+To use command deduplication, you should:\n+\n+- Use generous values for the deduplication time. It should be large enough such that you can assume the command was permanently lost if the deduplication time has passed and you still don‚Äôt observe any effect of the command on the ledger (i.e. you don't see a transaction with the command ID via the :ref:`transaction service <transaction-service>`).\n+- Make sure you set deterministic command IDs deterministically, that is to say: the \"same\" command must use the same command ID. This is useful for the recovery procedure after an application crash/restart, in which the application inspects the state of the ledger (e.g. via the :ref:`Active contracts service <active-contract-service>`) and sends commands to the ledger. When using deterministic command IDs, any commands that had been sent before the applciation restart will be discarded by the ledger to avoid duplicate submissions."
  },
  {
    "id" : "74eb9974-023f-423f-8c19-24fd94c4cb5a",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "a4122b25-52e2-49af-b510-4a9a21b85b9d",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Not sure in understand `favor maintainability`. Favor it over what?",
        "createdAt" : "2019-08-13T09:54:30Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e7793644-7446-4899-9409-a20bed729359",
        "parentId" : "a4122b25-52e2-49af-b510-4a9a21b85b9d",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "[False friend](https://translate.google.com/?um=1&ie=UTF-8&hl=en&client=tw-ob#view=home&op=translate&sl=it&tl=en&text=favorire), I believe the term I was looking for was \"improve\".",
        "createdAt" : "2019-08-13T11:31:01Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "72ec9fba-ecf8-449c-afc6-d47a975da358",
        "parentId" : "a4122b25-52e2-49af-b510-4a9a21b85b9d",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2505/commits/3de40913e0eee3e2a83009dc541a455643647ae3",
        "createdAt" : "2019-08-13T11:40:09Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : null,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability."
  },
  {
    "id" : "419db033-2457-42f3-a8ed-070ae7c159e4",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "3d4f4ccd-86fd-4f37-82ac-b59339594ec5",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Maybe `workflows` instead of `protocols`?",
        "createdAt" : "2019-08-13T09:55:56Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7b422bf7-42c2-473f-a141-08b7b84feb83",
        "parentId" : "3d4f4ccd-86fd-4f37-82ac-b59339594ec5",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Yes, thanks.",
        "createdAt" : "2019-08-13T11:31:34Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e9ab9323-9446-4764-a0a3-af6166e66c2d",
        "parentId" : "3d4f4ccd-86fd-4f37-82ac-b59339594ec5",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2505/commits/b43a821c448733c899f2e565e3654e0c63b37bca",
        "createdAt" : "2019-08-13T11:40:25Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : null,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability.\n+\n+Testing is usually divided in different categories according to its scope and aim:\n+\n+- unit testing verifies single properties of individual components\n+- integration testing verifies that an aggregation of components behaves as expected\n+- acceptance testing checks that the overall behavior of a whole system satisfies certain criteria\n+\n+Both tests in the small scale (unit testing) and large (acceptance testing) tend to be specific to the given component or system under test.\n+\n+This chapter focuses on providing portable approaches and techniques to perform integration testing between your components and an actual running ledger.\n+\n+Test the business logic with a ledger\n+*************************************\n+\n+In production, your application is going to interact with a DAML model deployed on an actual ledger.\n+\n+Each model is usually specific to a business need and describes specific protocols."
  },
  {
    "id" : "9f239d20-a269-487e-931c-fdd4ab8c6ae7",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "b133e4cb-5104-4732-bf58-c06568cb9397",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\nThe reset service has a single ``reset`` method that will cause all the accumulated state to be dropped, including all active contracts, the entire history of transactions and all allocated users. Only the DAML packges loaded in the ledger is preserved, possibly saving on the time needed to be loaded as opposed to simply spinning up a new ledger.\r\n```",
        "createdAt" : "2019-08-13T09:59:54Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : null,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability.\n+\n+Testing is usually divided in different categories according to its scope and aim:\n+\n+- unit testing verifies single properties of individual components\n+- integration testing verifies that an aggregation of components behaves as expected\n+- acceptance testing checks that the overall behavior of a whole system satisfies certain criteria\n+\n+Both tests in the small scale (unit testing) and large (acceptance testing) tend to be specific to the given component or system under test.\n+\n+This chapter focuses on providing portable approaches and techniques to perform integration testing between your components and an actual running ledger.\n+\n+Test the business logic with a ledger\n+*************************************\n+\n+In production, your application is going to interact with a DAML model deployed on an actual ledger.\n+\n+Each model is usually specific to a business need and describes specific protocols.\n+\n+Mocking a ledger response is usually not desirable to test the business logic, because so much of it is encapsulated in the DAML model.\n+\n+This makes integration testing with an actual running ledger fundamental to evaluating the correctness of an application.\n+\n+This is usually achieved by running a ledger as part of the test process and run several tests against it, possibly coordinated by a test framework.\n+\n+Since the in-memory sandbox shipped as part of the SDK is a full-fledged implementation of a DAML ledger, it's usually the tool of choice for these tests.\n+\n+Please note that this does not replace acceptance tests with the actual ledger implementation that your application aims to use in production.\n+\n+Whatever your choice is, sharing a single ledger to run several tests is a suggested best practice.\n+\n+Share the ledger\n+****************\n+\n+Booting a ledger and loading DAML code into it takes time. The shorter your tests, the more this overhead is going to impact the running time of the tests.\n+\n+Given the fundamental need of working against a running ledger to verify the business logic, it's quite common to have integration test that, in appearance, resemble unit tests, in that they check an individual property of a component you wrote, although in an integration test setting.\n+\n+This means it's quite common to write short tests, which aim, just like unit tests, to give quick feedback to the developer.\n+\n+In order for this to happen, saving on the need to boot a ledger multiple times can dramatically decrease the time necessary to run a suite of tests.\n+\n+Since your tests are going to share the same ledger, they must be designed to not interfere with each other.\n+\n+Design your tests to share the ledger\n+*************************************\n+\n+Both the transaction and the active contract service offer the possibility of filtering by party. Parties can thus be used as a way to isolate tests.\n+\n+You can use the party management service to allocate new parties and use them to test your application. You can also limit the number of transactions read from the ledger by reading the current offset of the ledger end before the test starts, since no transactions can possibly appear for the newly allocated parties before this time.\n+\n+In summary:\n+\n+1. retrieve the current offset of the ledger end before the test starts\n+1. use the party management service to allocate the parties needed by the test\n+1. whenever you issue a command, issue it as one of the parties allocated for this test\n+1. whenever you need to get the set of active contracts or a stream of transactions, always filter by one or more of the parties allocated for this test\n+\n+This isolation between instances of tests also means that different tests can be run completely in parallel with respect to each other, possibly improving on the overall running time of your test suite.\n+\n+Reset if you need to\n+********************\n+\n+It may be the case that you are running a very high number of tests, verifying the ins and outs of a very complex application interacting with an equally complex DAML model.\n+\n+If that's the case, the leak of resources caused by the approach to test isolation mentioned above can become counterproductive, causing slow-downs or even crashes as the ledger backing your test suite has to keep track of more parties and more transactions that are actually no longer relevant after the test itself finishes.\n+\n+As a last resort for these cases, your tests can use a service that ledger implementations can optionally expose, designed exclusively for testing environments: the reset service.\n+\n+The reset service has a single ``reset`` method that will cause all the accumulated state to be dropped, including all active contract, the entire history of transactions and all allocated users. Only the code loaded in the ledger is preserved, possibly saving on the time needed to be loaded as opposed to simply spinning up a new ledger."
  },
  {
    "id" : "a0c7b316-9a05-4832-aefa-1615cb509799",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "4b40f315-1777-49d5-bc3e-17b562a4fa2a",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\nTesting is usually divided into different categories according to its scope and aim:\r\n```",
        "createdAt" : "2019-08-13T11:00:03Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : null,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability.\n+\n+Testing is usually divided in different categories according to its scope and aim:"
  },
  {
    "id" : "21e1755f-1135-49c5-bd6e-b68550025142",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "157cca5c-38e1-4394-b7c2-a7c91d59b91c",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I don't think you need a new paragraph for each sentence in this section. I'd structure it in three paragraphs:\r\n\r\n1. DAML Contracts + DAML Ledger Model encapsulate the bulk of your business logic\r\n2. Mocking the Ledger API pretty much requires you to reimplement a full DAML Ledger so don't.\r\n3. The Sandbox is your friend. \r\n\r\nIn 3. you could explain options for getting the ledger into a desired state:\r\n  - Write a scenario\r\n  - Write a special ledger initialisation workflow and automation\r\n  - Use a Postgres sandbox with initial state taken from a backed up database.",
        "createdAt" : "2019-08-13T11:07:26Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d96d6e79-9b7a-48ce-9026-f40823e9c13b",
        "parentId" : "157cca5c-38e1-4394-b7c2-a7c91d59b91c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I would strongly discourage writing a scenario because of the [limitations of using scenarios with the suggested approach](https://github.com/digital-asset/daml/pull/2505/files/fe13e50529b6718a11b35d913703b2df7fb60959#r313346380).",
        "createdAt" : "2019-08-13T11:36:08Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "da6dae4d-4b22-421c-8449-d99b8fbac0a5",
        "parentId" : "157cca5c-38e1-4394-b7c2-a7c91d59b91c",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Where does the Postgres backup idea come from? It's creative but I would not recommend it unless there are some established good practices around it. If there are, please share them with me so that I can add them.",
        "createdAt" : "2019-08-13T11:42:19Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d4535c3b-f46a-471c-be60-7f8687b000d0",
        "parentId" : "157cca5c-38e1-4394-b7c2-a7c91d59b91c",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Just from general brainstorming around testing. Defining, and loading the desired ledger state is one of the more cumbersome parts currently so it's on my radar as something to offer solutions for. \r\n\r\nAdmittedly, I've never actually tried it. ",
        "createdAt" : "2019-08-13T11:54:05Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : 38,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability.\n+\n+Testing is usually divided in different categories according to its scope and aim:\n+\n+- unit testing verifies single properties of individual components\n+- integration testing verifies that an aggregation of components behaves as expected\n+- acceptance testing checks that the overall behavior of a whole system satisfies certain criteria\n+\n+Both tests in the small scale (unit testing) and large (acceptance testing) tend to be specific to the given component or system under test.\n+\n+This chapter focuses on providing portable approaches and techniques to perform integration testing between your components and an actual running ledger.\n+\n+Test the business logic with a ledger"
  },
  {
    "id" : "843b51e8-08fa-4778-9019-db6f22d35efc",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "25be6e15-39fa-45e5-a6d6-58bc549383e6",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "This is too much text for the point you are making. Maybe combine with the next section and just add a single paragraph there to motivate sharing the ledger.",
        "createdAt" : "2019-08-13T11:11:46Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9cab924e-0c8e-4cb1-94f6-f8545d17063e",
        "parentId" : "25be6e15-39fa-45e5-a6d6-58bc549383e6",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/2505/commits/319dad7e7f104cce9f6556e5c93247d4656a7556",
        "createdAt" : "2019-08-14T11:54:16Z",
        "updatedAt" : "2019-08-14T11:54:17Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : 47,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability.\n+\n+Testing is usually divided in different categories according to its scope and aim:\n+\n+- unit testing verifies single properties of individual components\n+- integration testing verifies that an aggregation of components behaves as expected\n+- acceptance testing checks that the overall behavior of a whole system satisfies certain criteria\n+\n+Both tests in the small scale (unit testing) and large (acceptance testing) tend to be specific to the given component or system under test.\n+\n+This chapter focuses on providing portable approaches and techniques to perform integration testing between your components and an actual running ledger.\n+\n+Test the business logic with a ledger\n+*************************************\n+\n+In production, your application is going to interact with a DAML model deployed on an actual ledger.\n+\n+Each model is usually specific to a business need and describes specific protocols.\n+\n+Mocking a ledger response is usually not desirable to test the business logic, because so much of it is encapsulated in the DAML model.\n+\n+This makes integration testing with an actual running ledger fundamental to evaluating the correctness of an application.\n+\n+This is usually achieved by running a ledger as part of the test process and run several tests against it, possibly coordinated by a test framework.\n+\n+Since the in-memory sandbox shipped as part of the SDK is a full-fledged implementation of a DAML ledger, it's usually the tool of choice for these tests.\n+\n+Please note that this does not replace acceptance tests with the actual ledger implementation that your application aims to use in production.\n+\n+Whatever your choice is, sharing a single ledger to run several tests is a suggested best practice.\n+\n+Share the ledger"
  },
  {
    "id" : "36f86a72-0df9-4daf-ac87-b62aad5b15ad",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "49c63377-47b2-45a6-98c2-4ccfca22a97e",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "I think using disjoint sets of parties for each test is exactly the right approach, that's how Truffle does it.\r\nHowever, your description here relies on starting with no active contracts. Getting the ledger into a desired state using automation is quite cumbersome. I often use scenarios. I think it'd be good to give some advice on ledger initialization.",
        "createdAt" : "2019-08-13T11:15:13Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3d489d3e-d413-4811-a970-2d42c8952651",
        "parentId" : "49c63377-47b2-45a6-98c2-4ccfca22a97e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Scenarios can run only on a clean ledger, which would require to either disqualify the whole idea of sharing a ledger or need to run with a scenario that ~loads all possible events~ prepares the testing environment for all tests, which could become difficult to manage. Furthermore, this approach is incompatible with the suggested approach of allocating new parties for each test. Rather, one thing I left out and that greatly improves setting up the desired state is leveraging codegen where possible, which I could add as a suggestion.",
        "createdAt" : "2019-08-13T11:27:58Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ad7ca652-0b4a-4bdb-a899-a353c530e26d",
        "parentId" : "49c63377-47b2-45a6-98c2-4ccfca22a97e",
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Yeah, with scenarios you'd have to define your disjoint sets of parties in each scenario. Scenarios are composable so you can just write a container-scenario that runs the setup for each test .",
        "createdAt" : "2019-08-13T11:56:15Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ca733fdd-cfb5-4a73-9348-daf46aa3120a",
        "parentId" : "49c63377-47b2-45a6-98c2-4ccfca22a97e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "The problem in using this approach is having to manually keep synchronized an ever-growing list of users that have to carefully be created on ~both sides~ one side and referred to on the other for this to work. I would favor using the `PartyManagementService` along with good helpers and possibly codegen to make the setup as lightweight as possible. This approach has been taken when developing the new integration tests and setting up a test scenario is very much not cumbersome ([example](https://github.com/digital-asset/daml/blob/master/ledger/ledger-api-test-tool/src/main/scala/com/daml/ledger/api/testtool/tests/Divulgence.scala#L18-L22)). I can include your suggestion but it's important to highlight the possible maintenance burden for large test suites.",
        "createdAt" : "2019-08-13T13:53:36Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4ca3a90d-8f51-4c58-9ad5-7312f5668504",
        "parentId" : "49c63377-47b2-45a6-98c2-4ccfca22a97e",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "After a bit of thought and interesting input from @gerolf-da, it's probably the case to reinforce the idea of having expressive bindings and possibly code generation do the heavy lifting for you of coming to a state.",
        "createdAt" : "2019-08-14T11:21:44Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : null,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability.\n+\n+Testing is usually divided in different categories according to its scope and aim:\n+\n+- unit testing verifies single properties of individual components\n+- integration testing verifies that an aggregation of components behaves as expected\n+- acceptance testing checks that the overall behavior of a whole system satisfies certain criteria\n+\n+Both tests in the small scale (unit testing) and large (acceptance testing) tend to be specific to the given component or system under test.\n+\n+This chapter focuses on providing portable approaches and techniques to perform integration testing between your components and an actual running ledger.\n+\n+Test the business logic with a ledger\n+*************************************\n+\n+In production, your application is going to interact with a DAML model deployed on an actual ledger.\n+\n+Each model is usually specific to a business need and describes specific protocols.\n+\n+Mocking a ledger response is usually not desirable to test the business logic, because so much of it is encapsulated in the DAML model.\n+\n+This makes integration testing with an actual running ledger fundamental to evaluating the correctness of an application.\n+\n+This is usually achieved by running a ledger as part of the test process and run several tests against it, possibly coordinated by a test framework.\n+\n+Since the in-memory sandbox shipped as part of the SDK is a full-fledged implementation of a DAML ledger, it's usually the tool of choice for these tests.\n+\n+Please note that this does not replace acceptance tests with the actual ledger implementation that your application aims to use in production.\n+\n+Whatever your choice is, sharing a single ledger to run several tests is a suggested best practice.\n+\n+Share the ledger\n+****************\n+\n+Booting a ledger and loading DAML code into it takes time. The shorter your tests, the more this overhead is going to impact the running time of the tests.\n+\n+Given the fundamental need of working against a running ledger to verify the business logic, it's quite common to have integration test that, in appearance, resemble unit tests, in that they check an individual property of a component you wrote, although in an integration test setting.\n+\n+This means it's quite common to write short tests, which aim, just like unit tests, to give quick feedback to the developer.\n+\n+In order for this to happen, saving on the need to boot a ledger multiple times can dramatically decrease the time necessary to run a suite of tests.\n+\n+Since your tests are going to share the same ledger, they must be designed to not interfere with each other.\n+\n+Design your tests to share the ledger\n+*************************************\n+\n+Both the transaction and the active contract service offer the possibility of filtering by party. Parties can thus be used as a way to isolate tests."
  },
  {
    "id" : "b9a27d3e-9781-4665-8839-cb10363b2c0f",
    "prId" : 2505,
    "comments" : [
      {
        "id" : "a82d4c2d-db80-4a71-b784-3dfe328d03a4",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\nAs a last resort for these cases, your tests can use the reset service, which ledger implementations can optionally expose for testing.\r\n```",
        "createdAt" : "2019-08-13T11:16:41Z",
        "updatedAt" : "2019-08-14T11:53:27Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "319dad7e7f104cce9f6556e5c93247d4656a7556",
    "line" : null,
    "diffHunk" : "@@ -246,3 +235,79 @@ There are some other identifiers that are determined by your client code. These\n .. |image0| image:: images/BotFlow.png\n    :width: 6.5in\n    :height: 3.69444in\n+\n+Testing\n+=======\n+\n+Testing is fundamental to ensure correctness and favor maintainability.\n+\n+Testing is usually divided in different categories according to its scope and aim:\n+\n+- unit testing verifies single properties of individual components\n+- integration testing verifies that an aggregation of components behaves as expected\n+- acceptance testing checks that the overall behavior of a whole system satisfies certain criteria\n+\n+Both tests in the small scale (unit testing) and large (acceptance testing) tend to be specific to the given component or system under test.\n+\n+This chapter focuses on providing portable approaches and techniques to perform integration testing between your components and an actual running ledger.\n+\n+Test the business logic with a ledger\n+*************************************\n+\n+In production, your application is going to interact with a DAML model deployed on an actual ledger.\n+\n+Each model is usually specific to a business need and describes specific protocols.\n+\n+Mocking a ledger response is usually not desirable to test the business logic, because so much of it is encapsulated in the DAML model.\n+\n+This makes integration testing with an actual running ledger fundamental to evaluating the correctness of an application.\n+\n+This is usually achieved by running a ledger as part of the test process and run several tests against it, possibly coordinated by a test framework.\n+\n+Since the in-memory sandbox shipped as part of the SDK is a full-fledged implementation of a DAML ledger, it's usually the tool of choice for these tests.\n+\n+Please note that this does not replace acceptance tests with the actual ledger implementation that your application aims to use in production.\n+\n+Whatever your choice is, sharing a single ledger to run several tests is a suggested best practice.\n+\n+Share the ledger\n+****************\n+\n+Booting a ledger and loading DAML code into it takes time. The shorter your tests, the more this overhead is going to impact the running time of the tests.\n+\n+Given the fundamental need of working against a running ledger to verify the business logic, it's quite common to have integration test that, in appearance, resemble unit tests, in that they check an individual property of a component you wrote, although in an integration test setting.\n+\n+This means it's quite common to write short tests, which aim, just like unit tests, to give quick feedback to the developer.\n+\n+In order for this to happen, saving on the need to boot a ledger multiple times can dramatically decrease the time necessary to run a suite of tests.\n+\n+Since your tests are going to share the same ledger, they must be designed to not interfere with each other.\n+\n+Design your tests to share the ledger\n+*************************************\n+\n+Both the transaction and the active contract service offer the possibility of filtering by party. Parties can thus be used as a way to isolate tests.\n+\n+You can use the party management service to allocate new parties and use them to test your application. You can also limit the number of transactions read from the ledger by reading the current offset of the ledger end before the test starts, since no transactions can possibly appear for the newly allocated parties before this time.\n+\n+In summary:\n+\n+1. retrieve the current offset of the ledger end before the test starts\n+1. use the party management service to allocate the parties needed by the test\n+1. whenever you issue a command, issue it as one of the parties allocated for this test\n+1. whenever you need to get the set of active contracts or a stream of transactions, always filter by one or more of the parties allocated for this test\n+\n+This isolation between instances of tests also means that different tests can be run completely in parallel with respect to each other, possibly improving on the overall running time of your test suite.\n+\n+Reset if you need to\n+********************\n+\n+It may be the case that you are running a very high number of tests, verifying the ins and outs of a very complex application interacting with an equally complex DAML model.\n+\n+If that's the case, the leak of resources caused by the approach to test isolation mentioned above can become counterproductive, causing slow-downs or even crashes as the ledger backing your test suite has to keep track of more parties and more transactions that are actually no longer relevant after the test itself finishes.\n+\n+As a last resort for these cases, your tests can use a service that ledger implementations can optionally expose, designed exclusively for testing environments: the reset service."
  }
]