[
  {
    "id" : "88151640-37f9-41c8-b151-951eb55d3278",
    "prId" : 5420,
    "comments" : [
      {
        "id" : "7a4dcb4a-20ce-4734-a04f-d828c4e0603c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nTo install Puppeteer and some other testing utilities we are going to use,\r\n```",
        "createdAt" : "2020-04-03T12:01:53Z",
        "updatedAt" : "2020-04-03T12:09:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d074e84904820218cc7dffe8e2f63bdab41605cd",
    "line" : null,
    "diffHunk" : "@@ -15,12 +15,23 @@ Of course there are more to choose from, but this is one combination that works.\n     - `Jest <https://jestjs.io/>`_ is a general-purpose testing framework for JavaScript that's well integrated with both TypeScript and React. Jest helps you structure your tests and express expectations of the app's behaviour.\n     - `Puppeteer <https://pptr.dev/>`_ is a library for controlling a Chrome browser from JavaScript/TypeScript. Puppeteer allows you to simulate interactions with the app in place of a real user.\n \n+To install Puppetter and some other testing utilities we are going to use,"
  },
  {
    "id" : "7aef15e6-9357-44da-8e63-8b41cd130b97",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "440423d3-4277-4422-8ab0-f824045e831a",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Would be good to write what tests are covered in a list (just naming them), so the user knows what he can see in there. This primes him for what s/he's getting into (lower cognitive load).",
        "createdAt" : "2020-03-23T09:08:07Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 23,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``."
  },
  {
    "id" : "82c18517-3b91-41b1-bb67-54ce2d7c8c35",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "d8815fb7-9121-49a0-8a9b-4047664e6db3",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Are the two tools \"blended\" in use, i.e., they are used in a single test? So I write the expected behavior in Jest and I perform the actions with Puppeteer, right?",
        "createdAt" : "2020-03-23T09:10:04Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0028d226-d980-4de9-839a-29d9d5468719",
        "parentId" : "d8815fb7-9121-49a0-8a9b-4047664e6db3",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "That's right. Well I suppose Jest is the \"framework\" encompassing your tests and expectations, and Puppeteer is a library that you use during those tests to perform the necessary actions. Do you think this should be made clearer, or can the reader wait until we show an example?",
        "createdAt" : "2020-03-23T14:33:56Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c90fe460-fee0-40b6-81f7-df46e9c468d6",
        "parentId" : "d8815fb7-9121-49a0-8a9b-4047664e6db3",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "I would spell it out really, as I wasn't 100% sure if this is how the two work together (lookup Steve Krug's \"Don't make me think!\", some excerpts can be found [here](https://docs.google.com/document/d/18dZb4jR-nMpl5Ah5SELkcNBCkmiJABnQ-CGWi6J5X3A/edit?ts=5e4a6779#heading=h.8tudxn1xifo1) ). Had to read back and forth. ",
        "createdAt" : "2020-03-23T14:39:27Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 22,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app."
  },
  {
    "id" : "328b17be-1005-42a7-9925-a7e172470670",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "c0505267-e7ee-4be3-b0c1-41c07c1f3f76",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Would be great to have a new subsection here \"Initialising tests\" or something like that. In general adding more structure.",
        "createdAt" : "2020-03-23T09:11:33Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 36,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+We first have some global state that we will use throughout our tests.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new pages in each.\n+"
  },
  {
    "id" : "54466ec6-a647-4d9b-a07a-44dd45f75783",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "590e3141-9a8f-4394-a052-9df620d63519",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Would write with more clarity and would avoid ambiguous terms like \"somewhat mysterious\", \"some sort of a handle\". ",
        "createdAt" : "2020-03-23T09:13:42Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+We first have some global state that we will use throughout our tests.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new pages in each.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+\n+Now let's get to the tests!\n+The idea is to control the browser in the same way we would expect a user to in each scenario we want to test.\n+This means we use Puppeteer to type text into input forms, click buttons and search for particular elements on the page.\n+In order to find those elements, we do need to make some adjustments in our React components, which we'll show later.\n+Let's start at a higher level with a ``test``.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_TEST\n+  :end-before: // END_LOGIN_TEST\n+\n+We'll walk though this step by step.\n+\n+    - The ``test`` syntax is provided by Jest to indicate a new test running the function given as an argument (along with a description and time limit).\n+    - ``getParty()`` gives us a new party name. Right now it is just a string unique to this set of tests, but in the future we will use the Party Management Service to allocate parties.\n+    - ``newUiPage()`` is a helper function that uses the Puppeteer browser to open a new page (we use one page per party in these tests), navigate to the app URL and return a ``Page`` object.\n+    - Next we ``login()`` using the new page and party name. This should take the user to the main screen. We'll show how the ``login()`` function does this shortly.\n+    - We use the ``@daml/ledger`` library to check the ledger state. In this case, we want to ensure there is a single ``User`` contract created for the new party. Hence we create a new connection to the ``Ledger``, ``query()`` it and state what we ``expect`` of the result. When we run the tests, Jest will check these expectations and report any failures for us to fix.\n+    - The test also simulates the new user logging out and then logging back in. We again check the state of the ledger and see that it's the same as before.\n+    - Finally we must ``close()`` the browser page, which was opened in ``newUiPage()``, to avoid runaway Puppeteer processes after the tests finish.\n+\n+Selecting and interacting with UI elements\n+==========================================\n+\n+We showed how to write a simple test at a high level, but haven't shown how to make individual actions in the app using Puppeteer.\n+This was hidden in the ``login()`` and ``logout()`` functions.\n+Let's see how ``login()`` is implemented.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_FUNCTION\n+  :end-before: // END_LOGIN_FUNCTION\n+\n+This looks somewhat mysterious at first.\n+We first get some sort of handle to the username input element, and then use it to click into it and type the party name."
  },
  {
    "id" : "9b0f80cf-3e03-427b-93c9-4e837e573161",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "98b9c09c-a1bb-45f5-a282-15a9c34275e0",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "New subsection \"Writing a simple login test\", \"Staging a simple login test\", or something like that.",
        "createdAt" : "2020-03-23T09:15:02Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 41,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+We first have some global state that we will use throughout our tests.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new pages in each.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+"
  },
  {
    "id" : "b696ac97-2e6e-4f27-8084-6fa905cbc97b",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "28c618e1-0712-477b-8aaf-0d99804f3f81",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "These are the basics for any test, right?",
        "createdAt" : "2020-03-23T10:00:40Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "958f10eb-0f1e-4047-b51c-a00ab9590dc7",
        "parentId" : "28c618e1-0712-477b-8aaf-0d99804f3f81",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "That's right, I'll try to mention that.",
        "createdAt" : "2020-03-23T15:01:19Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 61,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+We first have some global state that we will use throughout our tests.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new pages in each.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+\n+Now let's get to the tests!\n+The idea is to control the browser in the same way we would expect a user to in each scenario we want to test.\n+This means we use Puppeteer to type text into input forms, click buttons and search for particular elements on the page.\n+In order to find those elements, we do need to make some adjustments in our React components, which we'll show later.\n+Let's start at a higher level with a ``test``.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_TEST\n+  :end-before: // END_LOGIN_TEST\n+\n+We'll walk though this step by step.\n+\n+    - The ``test`` syntax is provided by Jest to indicate a new test running the function given as an argument (along with a description and time limit).\n+    - ``getParty()`` gives us a new party name. Right now it is just a string unique to this set of tests, but in the future we will use the Party Management Service to allocate parties.\n+    - ``newUiPage()`` is a helper function that uses the Puppeteer browser to open a new page (we use one page per party in these tests), navigate to the app URL and return a ``Page`` object."
  },
  {
    "id" : "58bc6f38-bf39-40f3-bcd9-aee5202c13ef",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "af2a5610-4fdf-423f-92a1-ef29a87a0d6e",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "This one as well is part of the basics, right? Would be great to provide an overview of what commands are needed for every test (at least in the GSG).",
        "createdAt" : "2020-03-23T10:01:24Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 65,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+We first have some global state that we will use throughout our tests.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new pages in each.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+\n+Now let's get to the tests!\n+The idea is to control the browser in the same way we would expect a user to in each scenario we want to test.\n+This means we use Puppeteer to type text into input forms, click buttons and search for particular elements on the page.\n+In order to find those elements, we do need to make some adjustments in our React components, which we'll show later.\n+Let's start at a higher level with a ``test``.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_TEST\n+  :end-before: // END_LOGIN_TEST\n+\n+We'll walk though this step by step.\n+\n+    - The ``test`` syntax is provided by Jest to indicate a new test running the function given as an argument (along with a description and time limit).\n+    - ``getParty()`` gives us a new party name. Right now it is just a string unique to this set of tests, but in the future we will use the Party Management Service to allocate parties.\n+    - ``newUiPage()`` is a helper function that uses the Puppeteer browser to open a new page (we use one page per party in these tests), navigate to the app URL and return a ``Page`` object.\n+    - Next we ``login()`` using the new page and party name. This should take the user to the main screen. We'll show how the ``login()`` function does this shortly.\n+    - We use the ``@daml/ledger`` library to check the ledger state. In this case, we want to ensure there is a single ``User`` contract created for the new party. Hence we create a new connection to the ``Ledger``, ``query()`` it and state what we ``expect`` of the result. When we run the tests, Jest will check these expectations and report any failures for us to fix.\n+    - The test also simulates the new user logging out and then logging back in. We again check the state of the ledger and see that it's the same as before.\n+    - Finally we must ``close()`` the browser page, which was opened in ``newUiPage()``, to avoid runaway Puppeteer processes after the tests finish."
  },
  {
    "id" : "c350d504-2793-42c5-adc9-37efd2f0d09f",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "19f223da-57da-4169-a672-7d68ef6210b4",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Subsection, e.g., \"Writing CSS selectors\"",
        "createdAt" : "2020-03-23T10:13:50Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 109,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+We first have some global state that we will use throughout our tests.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new pages in each.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+\n+Now let's get to the tests!\n+The idea is to control the browser in the same way we would expect a user to in each scenario we want to test.\n+This means we use Puppeteer to type text into input forms, click buttons and search for particular elements on the page.\n+In order to find those elements, we do need to make some adjustments in our React components, which we'll show later.\n+Let's start at a higher level with a ``test``.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_TEST\n+  :end-before: // END_LOGIN_TEST\n+\n+We'll walk though this step by step.\n+\n+    - The ``test`` syntax is provided by Jest to indicate a new test running the function given as an argument (along with a description and time limit).\n+    - ``getParty()`` gives us a new party name. Right now it is just a string unique to this set of tests, but in the future we will use the Party Management Service to allocate parties.\n+    - ``newUiPage()`` is a helper function that uses the Puppeteer browser to open a new page (we use one page per party in these tests), navigate to the app URL and return a ``Page`` object.\n+    - Next we ``login()`` using the new page and party name. This should take the user to the main screen. We'll show how the ``login()`` function does this shortly.\n+    - We use the ``@daml/ledger`` library to check the ledger state. In this case, we want to ensure there is a single ``User`` contract created for the new party. Hence we create a new connection to the ``Ledger``, ``query()`` it and state what we ``expect`` of the result. When we run the tests, Jest will check these expectations and report any failures for us to fix.\n+    - The test also simulates the new user logging out and then logging back in. We again check the state of the ledger and see that it's the same as before.\n+    - Finally we must ``close()`` the browser page, which was opened in ``newUiPage()``, to avoid runaway Puppeteer processes after the tests finish.\n+\n+Selecting and interacting with UI elements\n+==========================================\n+\n+We showed how to write a simple test at a high level, but haven't shown how to make individual actions in the app using Puppeteer.\n+This was hidden in the ``login()`` and ``logout()`` functions.\n+Let's see how ``login()`` is implemented.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_FUNCTION\n+  :end-before: // END_LOGIN_FUNCTION\n+\n+This looks somewhat mysterious at first.\n+We first get some sort of handle to the username input element, and then use it to click into it and type the party name.\n+Then we directly click the login button.\n+Finally, we wait until we find we've reached the menu on the main page.\n+\n+The strings used to find UI elements, e.g. ``'.test-select-username-field'`` and ``'.test-select-login-button'``, are `CSS Selectors <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors>`_.\n+You may have seen them before if you've done CSS styling of web pages.\n+In this case we use *class selectors*, which look for CSS classes we've given to elements in our React components.\n+\n+Here is a snippet of the ``LoginScreen`` React component, showing the ``Form`` elements that have the added classes.\n+\n+.. literalinclude:: code/ui-before/LoginScreen.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_FORM\n+  :end-before: // END_FORM\n+\n+You can see the ``className`` attributes in the ``Input`` and ``Button`` which we select in the ``login()`` function.\n+Note that you can use other features of the elements to select, such as their types and attributes.\n+We just show simple class selectors here.\n+\n+When writing CSS selectors for your tests, you will likely need to check the structure of the rendered HTML in your app by running it manually and inspecting elements using your browser's developer tools."
  },
  {
    "id" : "c06f2c9e-f116-4eed-ab98-ba2732596aed",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "8c4b1ce1-0189-42d1-8a48-4c347c9d9755",
        "parentId" : null,
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Add an image showing what the nested div looks like. Easier to understand.",
        "createdAt" : "2020-03-23T10:15:15Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d6e02f64-0a25-46a7-96c6-216050709fe3",
        "parentId" : "8c4b1ce1-0189-42d1-8a48-4c347c9d9755",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "It is shown in the screenshot, though a little hard to read. Added a sentence pointing out it's there.",
        "createdAt" : "2020-03-23T15:38:44Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 116,
    "diffHunk" : "@@ -0,0 +1,105 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from but we will show you one path here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a NodeJS program.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+We first have some global state that we will use throughout our tests.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new pages in each.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+\n+Now let's get to the tests!\n+The idea is to control the browser in the same way we would expect a user to in each scenario we want to test.\n+This means we use Puppeteer to type text into input forms, click buttons and search for particular elements on the page.\n+In order to find those elements, we do need to make some adjustments in our React components, which we'll show later.\n+Let's start at a higher level with a ``test``.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_TEST\n+  :end-before: // END_LOGIN_TEST\n+\n+We'll walk though this step by step.\n+\n+    - The ``test`` syntax is provided by Jest to indicate a new test running the function given as an argument (along with a description and time limit).\n+    - ``getParty()`` gives us a new party name. Right now it is just a string unique to this set of tests, but in the future we will use the Party Management Service to allocate parties.\n+    - ``newUiPage()`` is a helper function that uses the Puppeteer browser to open a new page (we use one page per party in these tests), navigate to the app URL and return a ``Page`` object.\n+    - Next we ``login()`` using the new page and party name. This should take the user to the main screen. We'll show how the ``login()`` function does this shortly.\n+    - We use the ``@daml/ledger`` library to check the ledger state. In this case, we want to ensure there is a single ``User`` contract created for the new party. Hence we create a new connection to the ``Ledger``, ``query()`` it and state what we ``expect`` of the result. When we run the tests, Jest will check these expectations and report any failures for us to fix.\n+    - The test also simulates the new user logging out and then logging back in. We again check the state of the ledger and see that it's the same as before.\n+    - Finally we must ``close()`` the browser page, which was opened in ``newUiPage()``, to avoid runaway Puppeteer processes after the tests finish.\n+\n+Selecting and interacting with UI elements\n+==========================================\n+\n+We showed how to write a simple test at a high level, but haven't shown how to make individual actions in the app using Puppeteer.\n+This was hidden in the ``login()`` and ``logout()`` functions.\n+Let's see how ``login()`` is implemented.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_FUNCTION\n+  :end-before: // END_LOGIN_FUNCTION\n+\n+This looks somewhat mysterious at first.\n+We first get some sort of handle to the username input element, and then use it to click into it and type the party name.\n+Then we directly click the login button.\n+Finally, we wait until we find we've reached the menu on the main page.\n+\n+The strings used to find UI elements, e.g. ``'.test-select-username-field'`` and ``'.test-select-login-button'``, are `CSS Selectors <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors>`_.\n+You may have seen them before if you've done CSS styling of web pages.\n+In this case we use *class selectors*, which look for CSS classes we've given to elements in our React components.\n+\n+Here is a snippet of the ``LoginScreen`` React component, showing the ``Form`` elements that have the added classes.\n+\n+.. literalinclude:: code/ui-before/LoginScreen.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_FORM\n+  :end-before: // END_FORM\n+\n+You can see the ``className`` attributes in the ``Input`` and ``Button`` which we select in the ``login()`` function.\n+Note that you can use other features of the elements to select, such as their types and attributes.\n+We just show simple class selectors here.\n+\n+When writing CSS selectors for your tests, you will likely need to check the structure of the rendered HTML in your app by running it manually and inspecting elements using your browser's developer tools.\n+For example, the image below is from inspecting the username field using Google Chrome's developer tools.\n+\n+   .. figure:: images/inspect-element.png\n+\n+There is a subtlety to explain here due to the `Semantic UI <https://semantic-ui.com/>`_ framework we use for our app.\n+Semantic UI provides a convenient set of UI elements which get translated to HTML.\n+In the example of the username field above, the original Semantic UI ``Input`` is translated to nested ``div`` nodes with the ``input`` inside."
  },
  {
    "id" : "6fd8d530-dfdc-4971-b42e-a3fb8eb13fee",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "dd7d767c-9b8a-452f-b4d0-030abf9b4fd9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't think the last two sentences are necessary here. We don't want to tell people _why_ they should test but rather _how_ to do it.",
        "createdAt" : "2020-03-23T16:13:51Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,134 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows."
  },
  {
    "id" : "3280f686-f7e9-491c-b22c-1b6a7582ebec",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "4ca665ba-3c1e-4206-97d9-60c96defd0a6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should use the phrase \"end-to-end tests\" here. And maybe something like \"all the way from the UI to the ledger and back\".",
        "createdAt" : "2020-03-23T16:14:46Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,134 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI."
  },
  {
    "id" : "6a8d4cb0-6fad-49f7-8a32-0ce5ce5b5be0",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "492ada01-56c4-4cc6-9fda-a732871df049",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think we should write this under that assumption that the reader is already familiar with testing. After all, we don't want to teach them about testing in general but only about testing full-stack DAML applications. Thus I would heavily shorten this to:\r\n```suggestion\r\nWe've made the opinionated choice to use the following two tools the end-to-end test of our app:\r\nOf course there are more to choose from, but we show you one combination here.\r\nThe first tool is a general JavaScript testing framework called\r\n- `Jest <https://jestjs.io/>`_ is a general-purpose testing framework for JavaScript that works well with both React and TypeScript.\r\n- `Puppeteer <https://pptr.dev/>`_ is a library that allows for scripting interaction with a Chrome browser in JavaScript.\r\n```",
        "createdAt" : "2020-03-23T16:25:49Z",
        "updatedAt" : "2020-03-23T19:34:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,134 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test certain workflows through the UI.\n+In particular, you'll want to make sure that changes such as new features do not break existing functionality by mistake.\n+It may be fine to do this testing manually at first, but it quickly becomes more tiresome and error prone as the app grows.\n+\n+In this section we will show you one approach to automatically testing workflows in your UI.\n+This will allow you to iterate on your app faster and with more confidence that you aren't breaking it!\n+\n+Testing with Jest and Puppeteer\n+===============================\n+\n+There are two tools that we choose to write end to end tests for our app.\n+Of course there are more to choose from, but we show you one combination here.\n+The first tool is a general JavaScript testing framework called\n+`Jest <https://jestjs.io/>`_.\n+Jest allows you to write test cases containing expectations about behaviour should occur.\n+If the expectations for a test are not met, then you should see helpful messages about what went wrong.\n+You can also write setup and cleanup procedures that run before and after each test.\n+This will be very useful for us to manage services like the DAML sandbox and JSON API server.\n+\n+The second tool we use heavily is a library called\n+`Puppeteer <https://pptr.dev/>`_.\n+Puppeteer allows you to control a Chrome browser from a JavaScript (or TypeScript) program running on `Node.js <https://nodejs.org/en/about/>`_.\n+In our case we use it to perform actions like logging in, following friends and sending messages.\n+We can also control multiple browser pages at once and test the interactions between different users.\n+As a bonus, if something goes wrong you can take a screenshot and see what state your test browser got into!\n+To summarize, Jest is the framework encompassing your tests and expectations, and Puppeteer is a library that you use during those tests to perform actions in place of a real user."
  },
  {
    "id" : "98847c13-7655-43c1-a220-4f653abd3d51",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "9173b448-51cf-4c19-aeab-1900a76df673",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we please have a ticket in the GSG milestone for this.",
        "createdAt" : "2020-03-25T08:24:31Z",
        "updatedAt" : "2020-03-25T09:14:57Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fc36af75-215a-4d4b-a412-45c454356244",
        "parentId" : "9173b448-51cf-4c19-aeab-1900a76df673",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "It's not actionable right now as I understand, but it's here https://github.com/digital-asset/daml/issues/5185 so we don't forget.",
        "createdAt" : "2020-03-25T14:14:10Z",
        "updatedAt" : "2020-03-25T14:14:11Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 60,
    "diffHunk" : "@@ -0,0 +1,118 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test that user flows work from end to end.\n+This means that actions performed in the web UI trigger updates to the ledger and give the desired results on the page.\n+In this section we show how you can do such testing automatically in TypeScript (equally JavaScript).\n+This will allow you to iterate on your app faster and with more confidence!\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from, but this is one combination that works.\n+\n+    - `Jest <https://jestjs.io/>`_ is a general-purpose testing framework for JavaScript that's well integrated with both TypeScript and React. Jest helps you structure your tests and express expectations of the app's behaviour.\n+    - `Puppeteer <https://pptr.dev/>`_ is a library for controlling a Chrome browser from JavaScript/TypeScript. Puppeteer allows you to simulate interactions with the app in place of a real user.\n+\n+\n+Setting up our tests\n+====================\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+The actual tests are the clauses beginning with ``test``.\n+You can scroll down to the important ones with the following descriptions (the first argument to each ``test``):\n+\n+    - 'log in as a new user, log out and log back in'\n+    - 'log in as three different users and start following each other'\n+    - 'error when following self'\n+    - 'error when adding a user that you are already following'\n+\n+Before this, we need to set up the environment in which the tests run.\n+At the top of the file we have some global state that we use throughout.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new browser pages for each one.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+\n+\n+Example: Logging in and out\n+===========================\n+\n+Now let's get to a test!\n+The idea is to control the browser in the same way we would expect a user to in each scenario we want to test.\n+This means we use Puppeteer to type text into input forms, click buttons and search for particular elements on the page.\n+In order to find those elements, we do need to make some adjustments in our React components, which we'll show later.\n+Let's start at a higher level with a ``test``.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_TEST\n+  :end-before: // END_LOGIN_TEST\n+\n+We'll walk though this step by step.\n+\n+    - The ``test`` syntax is provided by Jest to indicate a new test running the function given as an argument (along with a description and time limit).\n+    - ``getParty()`` gives us a new party name. Right now it is just a string unique to this set of tests, but in the future we will use the Party Management Service to allocate parties."
  },
  {
    "id" : "c40a72e3-1975-4d61-81e2-2cd1848115bb",
    "prId" : 5119,
    "comments" : [
      {
        "id" : "5f4dda5d-886a-4c0a-8e37-dad01fe0a638",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not convinced this section adds more value than confusion. I think the issues we're facing here are pretty universal for any React UI framework. Since we're not trying to teach web development but rather want to focus on the issues related to DAML application, I'd prefer to entirely remove this section, particularly since there's no actual issue but only an anticipated potential one.",
        "createdAt" : "2020-03-25T09:14:45Z",
        "updatedAt" : "2020-03-25T09:14:57Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3252b7d6-c18b-439c-bc70-0156e4d4dd09",
        "parentId" : "5f4dda5d-886a-4c0a-8e37-dad01fe0a638",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "I'm not sure. Agree we're not trying to teach web dev in its entirety, but we're also not assuming the reader is familiar with these concepts. I don't think it's fair to expect the reader to automatically understand the fact that we are using Semantic UI (we actually don't mention that anywhere) which translates into HTML, and we are selecting the resulting HTML elements. This was an actual issue for me when I was writing selectors, until I realised this point. I take your point that it's in the weeds, but it might still be helpful.",
        "createdAt" : "2020-03-25T14:23:39Z",
        "updatedAt" : "2020-03-25T14:23:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e3de7451-03bf-4e30-95de-d0054771d8f7",
        "parentId" : "5f4dda5d-886a-4c0a-8e37-dad01fe0a638",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Don't think this section hurts. It's short and points out a specific thing for Semantic UI when testing DAML applications built with create-daml-app (that uses the Semantic UI).",
        "createdAt" : "2020-03-26T07:35:56Z",
        "updatedAt" : "2020-03-26T07:35:57Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d9624f640640d63b8c5a5d434999c8368347dd",
    "line" : 106,
    "diffHunk" : "@@ -0,0 +1,118 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Testing Your App\n+****************\n+\n+When developing your application, you will want to test that user flows work from end to end.\n+This means that actions performed in the web UI trigger updates to the ledger and give the desired results on the page.\n+In this section we show how you can do such testing automatically in TypeScript (equally JavaScript).\n+This will allow you to iterate on your app faster and with more confidence!\n+\n+There are two tools that we chose to write end to end tests for our app.\n+Of course there are more to choose from, but this is one combination that works.\n+\n+    - `Jest <https://jestjs.io/>`_ is a general-purpose testing framework for JavaScript that's well integrated with both TypeScript and React. Jest helps you structure your tests and express expectations of the app's behaviour.\n+    - `Puppeteer <https://pptr.dev/>`_ is a library for controlling a Chrome browser from JavaScript/TypeScript. Puppeteer allows you to simulate interactions with the app in place of a real user.\n+\n+\n+Setting up our tests\n+====================\n+\n+Let's see how to use these tools to write some tests for our social network app.\n+You can see the full suite in the file ``index.test.tsx``.\n+The actual tests are the clauses beginning with ``test``.\n+You can scroll down to the important ones with the following descriptions (the first argument to each ``test``):\n+\n+    - 'log in as a new user, log out and log back in'\n+    - 'log in as three different users and start following each other'\n+    - 'error when following self'\n+    - 'error when adding a user that you are already following'\n+\n+Before this, we need to set up the environment in which the tests run.\n+At the top of the file we have some global state that we use throughout.\n+Specifically, we have child processes for the ``daml start`` and ``yarn start`` commands, which run for the duration of our tests.\n+We also have a single Puppeteer browser that we share among tests, opening new browser pages for each one.\n+\n+The ``beforeAll()`` section is a function run once before any of the tests run.\n+We use it to spawn the ``daml start`` and ``yarn start`` processes and launch the browser.\n+On the other hand the ``afterAll()`` section is used to shut down these processes and close the browser.\n+This step is important to prevent child processes persisting in the background after our program has finished.\n+\n+\n+Example: Logging in and out\n+===========================\n+\n+Now let's get to a test!\n+The idea is to control the browser in the same way we would expect a user to in each scenario we want to test.\n+This means we use Puppeteer to type text into input forms, click buttons and search for particular elements on the page.\n+In order to find those elements, we do need to make some adjustments in our React components, which we'll show later.\n+Let's start at a higher level with a ``test``.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_TEST\n+  :end-before: // END_LOGIN_TEST\n+\n+We'll walk though this step by step.\n+\n+    - The ``test`` syntax is provided by Jest to indicate a new test running the function given as an argument (along with a description and time limit).\n+    - ``getParty()`` gives us a new party name. Right now it is just a string unique to this set of tests, but in the future we will use the Party Management Service to allocate parties.\n+    - ``newUiPage()`` is a helper function that uses the Puppeteer browser to open a new page (we use one page per party in these tests), navigate to the app URL and return a ``Page`` object.\n+    - Next we ``login()`` using the new page and party name. This should take the user to the main screen. We'll show how the ``login()`` function does this shortly.\n+    - We use the ``@daml/ledger`` library to check the ledger state. In this case, we want to ensure there is a single ``User`` contract created for the new party. Hence we create a new connection to the ``Ledger``, ``query()`` it and state what we ``expect`` of the result. When we run the tests, Jest will check these expectations and report any failures for us to fix.\n+    - The test also simulates the new user logging out and then logging back in. We again check the state of the ledger and see that it's the same as before.\n+    - Finally we must ``close()`` the browser page, which was opened in ``newUiPage()``, to avoid runaway Puppeteer processes after the tests finish.\n+\n+You will likely use ``test``, ``getParty()``, ``newUiPage()`` and ``Browser.close()`` for all your tests.\n+In this case we use the ``@daml/ledger`` library to inspect the state of the ledger, but usually we just check the contents of the web page match our expectations.\n+\n+\n+Accessing UI elements\n+=====================\n+\n+We showed how to write a simple test at a high level, but haven't shown how to make individual actions in the app using Puppeteer.\n+This was hidden in the ``login()`` and ``logout()`` functions.\n+Let's see how ``login()`` is implemented.\n+\n+.. literalinclude:: code/ui-before/index.test.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_LOGIN_FUNCTION\n+  :end-before: // END_LOGIN_FUNCTION\n+\n+We first wait to receive a handle to the username input element.\n+This is important to ensure the page and relevant elements are loaded by the time we try to act on them.\n+We then use the element handle to click into the input and type the party name.\n+Next we click the login button (this time assuming the button has loaded along with the rest of the page).\n+Finally, we wait until we find we've reached the menu on the main page.\n+\n+The strings used to find UI elements, e.g. ``'.test-select-username-field'`` and ``'.test-select-login-button'``, are `CSS Selectors <https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors>`_.\n+You may have seen them before in CSS styling of web pages.\n+In this case we use *class selectors*, which look for CSS classes we've given to elements in our React components.\n+\n+This means we must manually add classes to the components we want to test.\n+For example, here is a snippet of the ``LoginScreen`` React component with classes added to the ``Form`` elements.\n+\n+.. literalinclude:: code/ui-before/LoginScreen.tsx\n+  :language: tsx\n+  :start-after: // BEGIN_FORM\n+  :end-before: // END_FORM\n+\n+You can see the ``className`` attributes in the ``Input`` and ``Button``, which we select in the ``login()`` function.\n+Note that you can use other features of an element in your selector, such as its type and attributes.\n+We've only used class selectors in these tests.\n+\n+\n+Writing CSS Selectors"
  }
]