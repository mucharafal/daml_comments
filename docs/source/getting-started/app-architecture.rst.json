[
  {
    "id" : "04ff0b43-21fb-43d6-8e7e-582acc5cc768",
    "prId" : 5396,
    "comments" : [
      {
        "id" : "2d287a9b-d4f9-4fdd-83c1-a2a5e460cc99",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why has this changed?",
        "createdAt" : "2020-04-03T09:12:11Z",
        "updatedAt" : "2020-04-03T09:14:54Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "68ef8c2c-b871-4ddc-b13d-e630ae51a8fb",
        "parentId" : "2d287a9b-d4f9-4fdd-83c1-a2a5e460cc99",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "The `//` style of comment doesn't work within a JSX block. This code wasn't being compiled before so it didn't matter, now it's a proper comment in the JSX.",
        "createdAt" : "2020-04-03T14:56:34Z",
        "updatedAt" : "2020-04-03T14:56:34Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e3244314-71ab-4c4d-9aab-2af0dd6bf930",
        "parentId" : "2d287a9b-d4f9-4fdd-83c1-a2a5e460cc99",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That makes a lot of sense. Thanks for the explanation.",
        "createdAt" : "2020-04-03T17:03:39Z",
        "updatedAt" : "2020-04-03T17:03:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1d936fa3ccd08b7a6f57540b05fd2b7f15140c03",
    "line" : 54,
    "diffHunk" : "@@ -156,14 +156,14 @@ The wrapper function ``follow`` is then passed to the subcomponents of ``MainVie\n For example, ``follow`` is passed to the ``UserList`` component as an argument (a `prop <https://reactjs.org/docs/components-and-props.html>`_ in React terms).\n This gets triggered when you click the icon next to a user's name in the *Network* panel.\n \n-.. literalinclude:: code/ui-before/MainView.tsx\n+.. literalinclude:: code/templates-tarball/create-daml-app/ui/src/components/MainView.tsx\n   :language: tsx\n-  :start-after: // USERLIST_BEGIN\n-  :end-before: // USERLIST_END\n+  :start-after: {/* USERLIST_BEGIN */}"
  },
  {
    "id" : "56229d73-af1a-4abf-9f37-b8a06be6869e",
    "prId" : 5067,
    "comments" : [
      {
        "id" : "35158abe-e916-4ed6-a786-3e9b35009f8a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nA user Alice can see another user Bob in the network only when Bob is following Alice (only if Alice is the ``following`` list in his user contract).\r\n```",
        "createdAt" : "2020-03-18T16:04:04Z",
        "updatedAt" : "2020-03-19T09:04:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6732d9740491dd03a47de76737706eadfdcffcf8",
    "line" : null,
    "diffHunk" : "@@ -40,40 +40,40 @@ Let's look at the data portion first.\n There are two important aspects here:\n \n 1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n-In this case it is an identifier for the user and their current list of friends.\n+In this case it is an identifier for the user and the list of users they are following.\n Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n \n 2. The signatories and observers of the contract.\n The signatories are the parties whose authorization is required to create or archive instances of the contract template, in this case the user herself.\n The observers are the parties who are able to view the contract on the ledger.\n-In this case all friends of a user are able to see the user contract.\n+In this case all users that a particular user is following are able to see the user contract.\n \n Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n-A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n-For this to be true, Bob must have previously added Alice as a friend, as he is the sole signatory on his user contract.\n+A user Alice can see another user Bob in the network only when Alice is in the list of users that Bob is following (only if Alice is the ``following`` list in his user contract)."
  },
  {
    "id" : "da52ab9a-de62-43e0-b366-a47370e254e9",
    "prId" : 5067,
    "comments" : [
      {
        "id" : "2126ea68-9ca5-430e-9ec4-def5025a29d2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nFor this to be true, Bob must have previously started to follow Alice, as he is the sole signatory on his user contract.\r\n```",
        "createdAt" : "2020-03-18T16:04:14Z",
        "updatedAt" : "2020-03-19T09:04:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6732d9740491dd03a47de76737706eadfdcffcf8",
    "line" : null,
    "diffHunk" : "@@ -40,40 +40,40 @@ Let's look at the data portion first.\n There are two important aspects here:\n \n 1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n-In this case it is an identifier for the user and their current list of friends.\n+In this case it is an identifier for the user and the list of users they are following.\n Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n \n 2. The signatories and observers of the contract.\n The signatories are the parties whose authorization is required to create or archive instances of the contract template, in this case the user herself.\n The observers are the parties who are able to view the contract on the ledger.\n-In this case all friends of a user are able to see the user contract.\n+In this case all users that a particular user is following are able to see the user contract.\n \n Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n-A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n-For this to be true, Bob must have previously added Alice as a friend, as he is the sole signatory on his user contract.\n+A user Alice can see another user Bob in the network only when Alice is in the list of users that Bob is following (only if Alice is the ``following`` list in his user contract).\n+For this to be true, Bob must have previously strated to follow Alice, as he is the sole signatory on his user contract."
  },
  {
    "id" : "3ad5810b-2040-480b-9144-a7b6bb25e73e",
    "prId" : 5067,
    "comments" : [
      {
        "id" : "3f86c299-2126-42dc-890d-2aaeaf194a79",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I always misspell \"paramteres\" the same way. üòÉ\r\n```suggestion\r\n    - After that we declare choice parameters using the ``with`` keyword. Here this is the user we want to start following.\r\n```",
        "createdAt" : "2020-03-18T16:05:22Z",
        "updatedAt" : "2020-03-19T09:04:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6732d9740491dd03a47de76737706eadfdcffcf8",
    "line" : 41,
    "diffHunk" : "@@ -40,40 +40,40 @@ Let's look at the data portion first.\n There are two important aspects here:\n \n 1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n-In this case it is an identifier for the user and their current list of friends.\n+In this case it is an identifier for the user and the list of users they are following.\n Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n \n 2. The signatories and observers of the contract.\n The signatories are the parties whose authorization is required to create or archive instances of the contract template, in this case the user herself.\n The observers are the parties who are able to view the contract on the ledger.\n-In this case all friends of a user are able to see the user contract.\n+In this case all users that a particular user is following are able to see the user contract.\n \n Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n-A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n-For this to be true, Bob must have previously added Alice as a friend, as he is the sole signatory on his user contract.\n+A user Alice can see another user Bob in the network only when Alice is in the list of users that Bob is following (only if Alice is the ``following`` list in his user contract).\n+For this to be true, Bob must have previously strated to follow Alice, as he is the sole signatory on his user contract.\n If not, Bob will be invisible to Alice.\n \n Here we see two concepts that are central to DAML: *authorization* and *privacy*.\n Authorization is about who can *do* what, and privacy is about who can *see* what.\n In DAML we must answer these questions upfront, as they fundamentally change the design of an application.\n \n-The last part of the DAML model is the operation to add friends, called a *choice* in DAML.\n+The last part of the DAML model is the operation to follow users, called a *choice* in DAML.\n \n .. literalinclude:: code/daml/User.daml\n   :language: daml\n   :start-after: -- ADDFRIEND_BEGIN\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n+That is what the ``Follow`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the new user to follow added to the list. Here is a quick explanation of the code: \n \n-    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name ``AddFriend``.\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name ``Follow``.\n     - The return type of a choice is defined next. In this case it is ``ContractId User``.\n-    - After that we pass arguments for the choice with ``with`` keyword. Here this is the friend we are trying to add.\n+    - After that we declare choice paramteres with ``with`` keyword. Here this is the user we want to start following."
  },
  {
    "id" : "663e889a-a717-4371-bb1c-f21e1a3ebc27",
    "prId" : 4987,
    "comments" : [
      {
        "id" : "693176c4-11a3-4ef0-beea-5a431f06a408",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name ``AddFriend``.\r\n```",
        "createdAt" : "2020-03-13T13:58:18Z",
        "updatedAt" : "2020-03-13T14:24:54Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8a5bbe74c4566807ce543c422f2e13b5223b4607",
    "line" : null,
    "diffHunk" : "@@ -59,14 +59,17 @@ The last part of the DAML model is the operation to add friends, called a *choic\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n \n-There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name, which is in this case ``AddFriend``."
  },
  {
    "id" : "6cdc51ef-fd68-4983-a458-3b8bc84c9873",
    "prId" : 4987,
    "comments" : [
      {
        "id" : "51f32b06-c8b1-41bf-8f6e-b60f22b542b6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    - After that we pass arguments for the choice with ``with`` keyword. Here this is the friend we are trying to add.\r\n```",
        "createdAt" : "2020-03-13T13:58:55Z",
        "updatedAt" : "2020-03-13T14:24:54Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8a5bbe74c4566807ce543c422f2e13b5223b4607",
    "line" : null,
    "diffHunk" : "@@ -59,14 +59,17 @@ The last part of the DAML model is the operation to add friends, called a *choic\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n \n-There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name, which is in this case ``AddFriend``.\n+    - The return type of a choice is defined next. In this case it is ``ContractId User``.\n+    - After that we pass arguments for the choice with ``with`` keyword and for ``AddFriend`` this is  ``friend: Party``."
  },
  {
    "id" : "c0ccf667-1c74-40b7-b1e6-4eee965c4d2a",
    "prId" : 4987,
    "comments" : [
      {
        "id" : "06946bf2-a334-4989-8002-72d5b4280021",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    - The keyword ``controller`` defines the ``Party`` that is allowed to execute the choice. In this case, it is the ``username`` party associated with the ``User`` contract.\r\n```",
        "createdAt" : "2020-03-13T14:00:03Z",
        "updatedAt" : "2020-03-13T14:24:54Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8a5bbe74c4566807ce543c422f2e13b5223b4607",
    "line" : null,
    "diffHunk" : "@@ -59,14 +59,17 @@ The last part of the DAML model is the operation to add friends, called a *choic\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n \n-There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name, which is in this case ``AddFriend``.\n+    - The return type of a choice is defined next. In this case it is ``ContractId User``.\n+    - After that we pass arguments for the choice with ``with`` keyword and for ``AddFriend`` this is  ``friend: Party``.\n+    - The keyword ``controller`` defines the ``Party`` that is allowed to execute the choice. In this case it would be the logged in user with the defined ``username``.  "
  },
  {
    "id" : "59cdbeb6-ccd9-46ca-b196-4e340c489590",
    "prId" : 4987,
    "comments" : [
      {
        "id" : "b92caf26-504b-4e10-821d-0fdd2bd29c5a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if it would make sense to point out that it doesn‚Äôt matter if the checks come before or after archiving `self` or maybe move the archive to the first line. Currently users might get the mistaken impression that doing the checks afterwards would be dangerous since the contract might get archived even if the checks fail. Since the choice is transactional this is not the case. Probably not super important for the getting started guide.",
        "createdAt" : "2020-03-13T14:04:10Z",
        "updatedAt" : "2020-03-13T14:24:54Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b2f185a6-177f-42d3-9ec8-545e042e8e94",
        "parentId" : "b92caf26-504b-4e10-821d-0fdd2bd29c5a",
        "author" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "body" : "Will write your comment down and leave it as is (just because it's the GSG). The explanation now follows what's in the code. ",
        "createdAt" : "2020-03-13T14:27:42Z",
        "updatedAt" : "2020-03-13T14:27:42Z",
        "lastEditedBy" : {
          "login" : "nemanja-da",
          "name" : "Nemanja",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/56260209?u=23eb68502e88fcc2fb3821623951562c3bea45e8&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "07146402-3559-4c5e-9e70-133fd26c41db",
        "parentId" : "b92caf26-504b-4e10-821d-0fdd2bd29c5a",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think it's good practice to have the checks at the top of the choice so they are easy to find. I'm actually in favor of archiving `self` in the line before creating the new contract. This makes it more obvious that we're \"updating\" the contract.\r\n\r\nThis line should also end with a period.",
        "createdAt" : "2020-03-16T11:38:58Z",
        "updatedAt" : "2020-03-16T11:39:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8a5bbe74c4566807ce543c422f2e13b5223b4607",
    "line" : 13,
    "diffHunk" : "@@ -59,14 +59,17 @@ The last part of the DAML model is the operation to add friends, called a *choic\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n \n-There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name, which is in this case ``AddFriend``.\n+    - The return type of a choice is defined next. In this case it is ``ContractId User``.\n+    - After that we pass arguments for the choice with ``with`` keyword and for ``AddFriend`` this is  ``friend: Party``.\n+    - The keyword ``controller`` defines the ``Party`` that is allowed to execute the choice. In this case it would be the logged in user with the defined ``username``.  \n+    - The ``do`` keyword marks the start of the choice's body where its functionality will be written.\n+    - After passing some checks current contract is archived with ``archive self`` "
  },
  {
    "id" : "ab7db38d-6300-44da-a369-788d11dabad6",
    "prId" : 4987,
    "comments" : [
      {
        "id" : "e54d5f45-6a21-402c-8fbc-7bb5b8f31f94",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    - A new ``User`` contract with the added friend is created.\r\n```",
        "createdAt" : "2020-03-13T14:04:55Z",
        "updatedAt" : "2020-03-13T14:24:54Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8a5bbe74c4566807ce543c422f2e13b5223b4607",
    "line" : null,
    "diffHunk" : "@@ -59,14 +59,17 @@ The last part of the DAML model is the operation to add friends, called a *choic\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n \n-There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name, which is in this case ``AddFriend``.\n+    - The return type of a choice is defined next. In this case it is ``ContractId User``.\n+    - After that we pass arguments for the choice with ``with`` keyword and for ``AddFriend`` this is  ``friend: Party``.\n+    - The keyword ``controller`` defines the ``Party`` that is allowed to execute the choice. In this case it would be the logged in user with the defined ``username``.  \n+    - The ``do`` keyword marks the start of the choice's body where its functionality will be written.\n+    - After passing some checks current contract is archived with ``archive self`` \n+    - New contract containig the new friend added to the list is creted with ``create this with friends = friend :: friends``"
  },
  {
    "id" : "aee91112-f691-4566-98f2-17a0f6e2461b",
    "prId" : 4987,
    "comments" : [
      {
        "id" : "8cf3ff8a-5980-4b10-b56b-fbfcefa44d25",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We don't pass arguments here, we rather declare arguments (or to be more precise, (formal) parameters).",
        "createdAt" : "2020-03-16T11:36:32Z",
        "updatedAt" : "2020-03-16T11:39:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8a5bbe74c4566807ce543c422f2e13b5223b4607",
    "line" : 10,
    "diffHunk" : "@@ -59,14 +59,17 @@ The last part of the DAML model is the operation to add friends, called a *choic\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n \n-There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name ``AddFriend``.\n+    - The return type of a choice is defined next. In this case it is ``ContractId User``.\n+    - After that we pass arguments for the choice with ``with`` keyword. Here this is the friend we are trying to add."
  },
  {
    "id" : "f406fd3b-c446-4e4f-ad31-e2e99a6ad9fa",
    "prId" : 4987,
    "comments" : [
      {
        "id" : "5ea55809-40ab-4d7d-9785-0dd4e9552fab",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I _think_ we usually use the term \"choice body\" with the genitive.",
        "createdAt" : "2020-03-16T11:36:57Z",
        "updatedAt" : "2020-03-16T11:39:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8a5bbe74c4566807ce543c422f2e13b5223b4607",
    "line" : 12,
    "diffHunk" : "@@ -59,14 +59,17 @@ The last part of the DAML model is the operation to add friends, called a *choic\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new one with the extra friend added to the list. Here is a quick explanation of the code: \n \n-There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n+    - The choice starts with the ``nonconsuming choice`` keyword followed by the choice name ``AddFriend``.\n+    - The return type of a choice is defined next. In this case it is ``ContractId User``.\n+    - After that we pass arguments for the choice with ``with`` keyword. Here this is the friend we are trying to add.\n+    - The keyword ``controller`` defines the ``Party`` that is allowed to execute the choice. In this case, it is the ``username`` party associated with the ``User`` contract.\n+    - The ``do`` keyword marks the start of the choice's body where its functionality will be written."
  },
  {
    "id" : "928a1822-8f1e-45f4-b44d-82bc3553157a",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "12f5c0ad-c037-4a1a-9ef1-77d1d35a6422",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This might just be showing my ignorance of react but I thought that the thing that avoids having to thread it through are contexts not hooks.",
        "createdAt" : "2020-02-26T07:24:27Z",
        "updatedAt" : "2020-02-26T11:02:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e883c02e-73fe-4e4b-b60d-d7c8a251dc24",
        "parentId" : "12f5c0ad-c037-4a1a-9ef1-77d1d35a6422",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There's a hook called `useContext` which gets the value from the context.",
        "createdAt" : "2020-02-26T08:32:07Z",
        "updatedAt" : "2020-02-26T11:02:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : 17,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually."
  },
  {
    "id" : "542ef628-fe83-4a51-871b-1ed2fd2f9ad8",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "a8122f37-ce98-413b-9e77-adbc16c95853",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n(``User`` is a TypeScript object generated from the DAML code by ``daml codegen ts``.)\r\n```",
        "createdAt" : "2020-02-26T07:25:14Z",
        "updatedAt" : "2020-02-26T11:02:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : null,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger.\n+\n+Let's move on to more advanced uses of our DAML React library.\n+The ``MainScreen`` is a simple frame around the ``MainView`` component, which houses the main functionality of our app.\n+It uses DAML React hooks to query and update ledger state.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n   :language: typescript\n   :start-after: // USERS_BEGIN\n   :end-before: // USERS_END\n \n-For instance, ``allUsers`` uses the query hook to get the ``User`` contracts on the ledger.\n-Note however that the query preserves privacy: only users that have added the party currently logged in are shown.\n-This is because the observers of a ``User`` contract are exactly the user's friends.\n+The ``useParty`` hook simply returns the current user as stored in the ``DamlLedger`` context.\n+A more interesting example is the ``allUsers`` line.\n+This uses the ``useStreamQuery`` hook to get all ``User`` contracts on the ledger.\n+(``User`` is a TypeScript object generated from the DAML code by ``daml codegen``.)"
  },
  {
    "id" : "002b1a94-7d05-4280-b22e-4a6830f260dc",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "f4517263-dbb1-4332-a93c-1eac4685ae04",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "TypeScript object or TypeScript type?",
        "createdAt" : "2020-02-26T07:25:31Z",
        "updatedAt" : "2020-02-26T11:02:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "01ed0773-0176-4d44-b9d3-515292b6a82f",
        "parentId" : "f4517263-dbb1-4332-a93c-1eac4685ae04",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It's an object. There's also a type of the same name. TypeScript uses the companion object pattern too. Ultimately, we'll be talking about a JavaScript object here. Thus, there's not much value in adding something talking about the type now.",
        "createdAt" : "2020-02-26T08:43:51Z",
        "updatedAt" : "2020-02-26T11:02:04Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : null,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger.\n+\n+Let's move on to more advanced uses of our DAML React library.\n+The ``MainScreen`` is a simple frame around the ``MainView`` component, which houses the main functionality of our app.\n+It uses DAML React hooks to query and update ledger state.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n   :language: typescript\n   :start-after: // USERS_BEGIN\n   :end-before: // USERS_END\n \n-For instance, ``allUsers`` uses the query hook to get the ``User`` contracts on the ledger.\n-Note however that the query preserves privacy: only users that have added the party currently logged in are shown.\n-This is because the observers of a ``User`` contract are exactly the user's friends.\n+The ``useParty`` hook simply returns the current user as stored in the ``DamlLedger`` context.\n+A more interesting example is the ``allUsers`` line.\n+This uses the ``useStreamQuery`` hook to get all ``User`` contracts on the ledger.\n+(``User`` is a TypeScript object generated from the DAML code by ``daml codegen``.)"
  },
  {
    "id" : "a8bc0677-c703-43e4-9ae7-686ba1c5ab94",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "3797b3c7-ec1d-4346-b76a-c56103cf4d20",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "‚Äútheir contracts‚Äù is a bit unclear. Maybe something like ‚Äúonly the `User` contracts of users that have added the current user will be returned‚Äù.",
        "createdAt" : "2020-02-26T07:26:41Z",
        "updatedAt" : "2020-02-26T11:02:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : 47,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger.\n+\n+Let's move on to more advanced uses of our DAML React library.\n+The ``MainScreen`` is a simple frame around the ``MainView`` component, which houses the main functionality of our app.\n+It uses DAML React hooks to query and update ledger state.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n   :language: typescript\n   :start-after: // USERS_BEGIN\n   :end-before: // USERS_END\n \n-For instance, ``allUsers`` uses the query hook to get the ``User`` contracts on the ledger.\n-Note however that the query preserves privacy: only users that have added the party currently logged in are shown.\n-This is because the observers of a ``User`` contract are exactly the user's friends.\n+The ``useParty`` hook simply returns the current user as stored in the ``DamlLedger`` context.\n+A more interesting example is the ``allUsers`` line.\n+This uses the ``useStreamQuery`` hook to get all ``User`` contracts on the ledger.\n+(``User`` is a TypeScript object generated from the DAML code by ``daml codegen``.)\n+Note however that this query preserves privacy: only users that have added the current user have their contracts revealed."
  },
  {
    "id" : "506c02bb-4a8d-4429-ad52-7315705a1d36",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "56dd44e5-0a3c-4b08-a72c-3b61c85b6a21",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nThis is wrapped in the ``DamlLedger`` component, a `React context <https://reactjs.org/docs/context.html>`_ with a handle to the ledger.\r\n```",
        "createdAt" : "2020-02-26T08:34:29Z",
        "updatedAt" : "2020-02-26T11:02:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : null,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger."
  },
  {
    "id" : "cb1ecf1e-912f-467a-a887-0c572f854c54",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "766c9b69-5ae2-4871-8120-8b4cbfee48c8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we make one of these two components disappear by either inlining it into the other or into `App`?",
        "createdAt" : "2020-02-26T08:40:32Z",
        "updatedAt" : "2020-02-26T11:02:04Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "252e84a5-2758-438d-89bd-5a05fd7c5087",
        "parentId" : "766c9b69-5ae2-4871-8120-8b4cbfee48c8",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "We could, though I kind of like being able to ignore the ``MainScreen`` code, and showing ``App`` and ``MainView`` in the guide.",
        "createdAt" : "2020-02-26T10:44:48Z",
        "updatedAt" : "2020-02-26T11:02:04Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : 32,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger.\n+\n+Let's move on to more advanced uses of our DAML React library.\n+The ``MainScreen`` is a simple frame around the ``MainView`` component, which houses the main functionality of our app."
  },
  {
    "id" : "12621e63-5972-461f-8189-2290779e9a23",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "5c3f868d-477a-4f69-ac7e-14caa9664918",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n(``User`` is an object generated from the DAML code by ``daml codegen ts``. It stores metadata about the ``User`` template defined in ``User.daml``.)\r\n```",
        "createdAt" : "2020-02-26T08:44:32Z",
        "updatedAt" : "2020-02-26T11:02:04Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : null,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger.\n+\n+Let's move on to more advanced uses of our DAML React library.\n+The ``MainScreen`` is a simple frame around the ``MainView`` component, which houses the main functionality of our app.\n+It uses DAML React hooks to query and update ledger state.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n   :language: typescript\n   :start-after: // USERS_BEGIN\n   :end-before: // USERS_END\n \n-For instance, ``allUsers`` uses the query hook to get the ``User`` contracts on the ledger.\n-Note however that the query preserves privacy: only users that have added the party currently logged in are shown.\n-This is because the observers of a ``User`` contract are exactly the user's friends.\n+The ``useParty`` hook simply returns the current user as stored in the ``DamlLedger`` context.\n+A more interesting example is the ``allUsers`` line.\n+This uses the ``useStreamQuery`` hook to get all ``User`` contracts on the ledger.\n+(``User`` is a TypeScript object generated from the DAML code by ``daml codegen``.)"
  },
  {
    "id" : "7b140789-0d8a-4754-b81f-c8beebbb760f",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "41ffc018-3e2e-4be5-ac4a-f5edc45ea7f1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not sure this sentence helps. When we describe the architecture of the app, we should say that all communication with the ledger goes through the JSON API. Mentioning this specifically should then be unneeded.",
        "createdAt" : "2020-02-26T08:47:27Z",
        "updatedAt" : "2020-02-26T11:02:04Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : null,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger.\n+\n+Let's move on to more advanced uses of our DAML React library.\n+The ``MainScreen`` is a simple frame around the ``MainView`` component, which houses the main functionality of our app.\n+It uses DAML React hooks to query and update ledger state.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n   :language: typescript\n   :start-after: // USERS_BEGIN\n   :end-before: // USERS_END\n \n-For instance, ``allUsers`` uses the query hook to get the ``User`` contracts on the ledger.\n-Note however that the query preserves privacy: only users that have added the party currently logged in are shown.\n-This is because the observers of a ``User`` contract are exactly the user's friends.\n+The ``useParty`` hook simply returns the current user as stored in the ``DamlLedger`` context.\n+A more interesting example is the ``allUsers`` line.\n+This uses the ``useStreamQuery`` hook to get all ``User`` contracts on the ledger.\n+(``User`` is a TypeScript object generated from the DAML code by ``daml codegen``.)\n+Note however that this query preserves privacy: only users that have added the current user have their contracts revealed.\n+This behaviour is due to the observers on the ``User`` contract being exactly the user's friends.\n+\n+A final point on this is the *streaming* aspect of the query.\n+This means that results are updated as they come in - there is no need for periodic or manual reloading to see updates.\n+This functionality comes from a streaming endpoint in the :doc:`HTTP JSON API </json-api/index>`."
  },
  {
    "id" : "8ac16f34-1268-4d7d-9080-91db50e21b96",
    "prId" : 4700,
    "comments" : [
      {
        "id" : "2e4e78f8-ad29-419f-9577-87df2d00e9b7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nThe ``useExerciseByKey`` hook returns the ``exerciseAddFriend`` function.\r\n```\r\nI'll make a PR to remove that stupid boolean return value from the `@daml/react` library immediately.",
        "createdAt" : "2020-02-26T09:07:10Z",
        "updatedAt" : "2020-02-26T11:02:04Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5e1d4245-9962-4cdc-8038-f7727e89b49c",
        "parentId" : "2e4e78f8-ad29-419f-9577-87df2d00e9b7",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The PR is at https://github.com/digital-asset/daml/pull/4708.",
        "createdAt" : "2020-02-26T09:22:18Z",
        "updatedAt" : "2020-02-26T11:02:04Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f2c0fb9dc7ad9176d66635641bcff4bf3042ddb9",
    "line" : null,
    "diffHunk" : "@@ -82,43 +82,66 @@ The UI\n On top of TypeScript, we use the UI framework `React <https://reactjs.org/>`_.\n React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - with careful use of global state.\n \n-The latter is especially interesting as it's how we handle ledger state in our application.\n-We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n+Let's see an example of a React component.\n+All components are in the ``ui/src/components`` folder.\n+You can navigate there within Visual Studio Code using the file *Explorer* on the left sidebar.\n+We'll first look at ``App.tsx``, which is the entry point to our application.\n+\n+.. literalinclude:: code/ui-before/App.tsx\n+  :start-after: // APP_BEGIN\n+  :end-before: // APP_END\n+\n+An important tool in the design of our components is a React feature called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+Hooks allow you to share and update state across components, avoiding having to thread it through manually.\n+We take advantage of hooks in particular to share ledger state across components.\n+We use custom *DAML React hooks* to query the ledger for contracts, create new contracts, and exercise choices.\n \n .. TODO Link to DAML react hooks API\n \n-We can see examples of this in the ``MainView`` component.\n-This is the React component that enables the main functionality of the app.\n+The ``useState`` hook (not specific to DAML) here keeps track of the user's credentials.\n+If they are not set, we render the ``LoginScreen`` with a callback to ``setCredentials``.\n+If they are set, then we render the ``MainScreen`` of the app.\n+This is wrapped in the ``DamlLedger`` component, a React `context <https://reactjs.org/docs/context.html>`_ with the current view of the ledger.\n+\n+Let's move on to more advanced uses of our DAML React library.\n+The ``MainScreen`` is a simple frame around the ``MainView`` component, which houses the main functionality of our app.\n+It uses DAML React hooks to query and update ledger state.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n   :language: typescript\n   :start-after: // USERS_BEGIN\n   :end-before: // USERS_END\n \n-For instance, ``allUsers`` uses the query hook to get the ``User`` contracts on the ledger.\n-Note however that the query preserves privacy: only users that have added the party currently logged in are shown.\n-This is because the observers of a ``User`` contract are exactly the user's friends.\n+The ``useParty`` hook simply returns the current user as stored in the ``DamlLedger`` context.\n+A more interesting example is the ``allUsers`` line.\n+This uses the ``useStreamQuery`` hook to get all ``User`` contracts on the ledger.\n+(``User`` is a TypeScript object generated from the DAML code by ``daml codegen``.)\n+Note however that this query preserves privacy: only users that have added the current user have their contracts revealed.\n+This behaviour is due to the observers on the ``User`` contract being exactly the user's friends.\n+\n+A final point on this is the *streaming* aspect of the query.\n+This means that results are updated as they come in - there is no need for periodic or manual reloading to see updates.\n+This functionality comes from a streaming endpoint in the :doc:`HTTP JSON API </json-api/index>`.\n \n .. TODO Explain why you see friends of friends.\n \n-Another example is how we exercise the ``AddFriend`` choice of the ``User`` template.\n+Another example, showing how to *update* ledger state, is how we exercise the ``AddFriend`` choice of the ``User`` template.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n   :language: typescript\n   :start-after: // ADDFRIEND_BEGIN\n   :end-before: // ADDFRIEND_END\n \n-We use the ``useExerciseByKey`` hook to gain access to the ``exerciseAddFriend`` function.\n+The ``useExerciseByKey`` hook returns the ``exerciseAddFriend`` function (the ``[]`` around it is simply for ignoring other return values)."
  },
  {
    "id" : "95fd043f-5582-4d46-a2b8-93855a651cd1",
    "prId" : 4699,
    "comments" : [
      {
        "id" : "e7accfc8-10b4-4e6e-b3e8-950d29682863",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This sounds a bit confusing. Maybe something like ‚ÄúTo make things explicit, we mark all choices in this guide as `nonconsuming` and call `archive` when we want to consume a contract‚Äù.",
        "createdAt" : "2020-02-26T07:11:00Z",
        "updatedAt" : "2020-02-26T09:45:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7e6456cd967ba04af198b1a1255a1ae677a10df8",
    "line" : null,
    "diffHunk" : "@@ -50,12 +57,16 @@ The last thing we'll point out about the DAML model for now is the operation to\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n-The ``choice`` syntax automatically includes the archival of the current instance.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new instance with the new friend added to the list.\n+\n+There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n \n-.. TODO Update depending on consuming/nonconsuming choice.\n+    - The choice is ``nonconsuming`` as we ``archive`` the contract explicitly."
  },
  {
    "id" : "96d76612-115a-46df-a768-91e9fe772af8",
    "prId" : 4699,
    "comments" : [
      {
        "id" : "9f1904e8-6a83-44c8-a7ae-ff34af02e897",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    - The return type is ``ContractId User``, a reference to the new contract for the calling code.\r\n```\r\nA contract is already an instance of a template.",
        "createdAt" : "2020-02-26T07:11:32Z",
        "updatedAt" : "2020-02-26T09:45:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7e6456cd967ba04af198b1a1255a1ae677a10df8",
    "line" : null,
    "diffHunk" : "@@ -50,12 +57,16 @@ The last thing we'll point out about the DAML model for now is the operation to\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n-The ``choice`` syntax automatically includes the archival of the current instance.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new instance with the new friend added to the list.\n+\n+There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n \n-.. TODO Update depending on consuming/nonconsuming choice.\n+    - The choice is ``nonconsuming`` as we ``archive`` the contract explicitly.\n+    - The return type is ``ContractId User``, a reference to the new contract instance for the calling code."
  },
  {
    "id" : "be6f1ce9-28d0-4175-b8dc-06b43ec70442",
    "prId" : 4699,
    "comments" : [
      {
        "id" : "ba8e4111-30ed-48aa-ba11-63c0d9b624ca",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This also mixes up `contract` and `instance`. I think it would be easier to understand if you just use `contract` everywhere and at the beginning mention that a contract is an instance of a template.",
        "createdAt" : "2020-02-26T07:13:57Z",
        "updatedAt" : "2020-02-26T09:45:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a5e1b04f-1c9d-4163-b944-921ef7d817e8",
        "parentId" : "ba8e4111-30ed-48aa-ba11-63c0d9b624ca",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Agreed.",
        "createdAt" : "2020-02-26T08:24:44Z",
        "updatedAt" : "2020-02-26T09:45:58Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7e6456cd967ba04af198b1a1255a1ae677a10df8",
    "line" : null,
    "diffHunk" : "@@ -50,12 +57,16 @@ The last thing we'll point out about the DAML model for now is the operation to\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n-The ``choice`` syntax automatically includes the archival of the current instance.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new instance with the new friend added to the list."
  },
  {
    "id" : "c3924315-3c4a-41de-a0ff-7e890b6a2c73",
    "prId" : 4699,
    "comments" : [
      {
        "id" : "726ebc0f-6a59-4ff2-a0dd-da052c4c2542",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "You want to run `daml studio` in the directory where `daml.yaml` lives, i.e., in `create-daml-app/`.",
        "createdAt" : "2020-02-26T08:23:14Z",
        "updatedAt" : "2020-02-26T09:45:58Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7e6456cd967ba04af198b1a1255a1ae677a10df8",
    "line" : null,
    "diffHunk" : "@@ -7,14 +7,21 @@ App Architecture\n In this section we'll look at the different components of our social network app.\n The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n \n-There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n-Let's start by looking at the DAML model, as this sets the core logic of the application.\n+There are two main components: the DAML model and the React/TypeScript frontend.\n+We generate TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, which defines the core logic of the application.\n \n The DAML Model\n ==============\n \n-Using the Visual Studio Code editor, navigate to the ``daml`` subdirectory.\n-There is a single DAML file called ``User.daml`` with the model for app users.\n+Using your terminal, navigate to the ``create-daml-app/daml`` directory and run::"
  },
  {
    "id" : "87c7078d-3819-4f7b-8e41-b190938a93bb",
    "prId" : 4699,
    "comments" : [
      {
        "id" : "45c19609-8432-4fbd-a288-fecddf59a903",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    - The ``controller``, the party able to exercise the choice, is the party named on the ``User`` contract.\r\n```",
        "createdAt" : "2020-02-26T08:25:36Z",
        "updatedAt" : "2020-02-26T09:45:58Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7e6456cd967ba04af198b1a1255a1ae677a10df8",
    "line" : null,
    "diffHunk" : "@@ -50,12 +57,16 @@ The last thing we'll point out about the DAML model for now is the operation to\n   :end-before: -- ADDFRIEND_END\n \n DAML contracts are *immutable* (can not be changed in place), so the only way to \"update\" one is to archive it and create a new instance.\n-That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n-The ``choice`` syntax automatically includes the archival of the current instance.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it archives the current user contract and creates a new instance with the new friend added to the list.\n+\n+There is some boilerplate to set up the choice (full details in the :doc:`DAML reference </daml/reference/choices>`):\n \n-.. TODO Update depending on consuming/nonconsuming choice.\n+    - The choice is ``nonconsuming`` as we ``archive`` the contract explicitly.\n+    - The return type is ``ContractId User``, a reference to the new contract instance for the calling code.\n+    - The new ``friend: Party`` is passed as an argument to the choice.\n+    - The ``controller``, the party able to execute the choice, is the party named on the ``User`` contract."
  },
  {
    "id" : "6969606f-1c45-46f9-8f3d-e5b8baad2667",
    "prId" : 4639,
    "comments" : [
      {
        "id" : "983158b1-77f8-469d-b19b-466453dca59a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Something is missing here. `as For example` looks weird.",
        "createdAt" : "2020-02-20T18:18:07Z",
        "updatedAt" : "2020-02-20T18:20:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "11bd6d8badab788e42fb840029b1da2e05c24ffa",
    "line" : 42,
    "diffHunk" : "@@ -84,23 +84,38 @@ React helps us write modular UI components using a functional style - a componen\n \n The latter is especially interesting as it's how we handle ledger state in our application.\n We use a state management feature of React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n-You can see the capabilities of the DAML React hooks in ``create-daml-app/ui/src/daml-react-hooks/hooks.ts``.\n-For example, we can query the ledger for all contracts visible to the logged-in user, create new contracts, and exercise choices.\n+We use custom DAML React hooks to query the ledger for contracts, create new contracts, and exercise choices.\n \n-.. TODO Update location to view DAML react hooks API\n+.. TODO Link to DAML react hooks API\n \n-Let's see some examples of DAML React hooks.\n+We can see examples of this in the ``MainView`` component.\n+This is the React component that enables the main functionality of the app.\n \n .. literalinclude:: code/ui-before/MainView.tsx\n-  :start-after: // HOOKS_BEGIN\n-  :end-before: // HOOKS_END\n+  :start-after: // USERS_BEGIN\n+  :end-before: // USERS_END\n \n-This is the start of the component which provides data from the current state of the ledger to the main screen of our app.\n-The declarations within ``MainView`` all use DAML hooks to get information from the ledger.\n-For instance, ``allUsers`` uses a query to get the ``User`` contracts on the ledger.\n-However, the query respects the privacy guarantees of a DAML ledger: the contracts returned are only those visible to the currently logged in party.\n-This explains why you cannot see *all* users in the network on the main screen, only those who have added you as a friend (making you an observer of their ``User`` contract).\n+For instance, ``allUsers`` uses the query hook to get the ``User`` contracts on the ledger.\n+Note however that the query preserves privacy: only users that have added the party currently logged in are shown.\n+This is because the observers of a ``User`` contract are exactly the user's friends.\n \n .. TODO Explain why you see friends of friends.\n \n-In the next section, we'll guide you through building :doc:`your first feature <first-feature>` for this social network.\n+Another example is how we exercise the ``AddFriend`` choice of the ``User`` template.\n+\n+.. literalinclude:: code/ui-before/MainView.tsx\n+  :start-after: // ADDFRIEND_BEGIN\n+  :end-before: // ADDFRIEND_END\n+\n+We use the ``useExerciseByKey`` hook to gain access to the ``exerciseAddFriend`` function.\n+The *key* in this case is the username of the current user, used to look up the corresponding ``User`` contract.\n+The wrapper function ``addFriend`` is then passed to subcomponents, as\n+For example, ``addFriend`` is passed to the ``UserList`` component as an argument (called a *prop* in React terms)."
  },
  {
    "id" : "7bf215c9-336a-4ed6-9c32-d753e4a2a70a",
    "prId" : 4560,
    "comments" : [
      {
        "id" : "cb25e4ee-5d9b-45fb-b4b6-6123617a2c47",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we actually teach how to start VS Code using `daml studio`? If not, we should do so somewhere close to the beginning.",
        "createdAt" : "2020-02-18T12:06:37Z",
        "updatedAt" : "2020-02-18T12:07:23Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "38aa33ed292b17a3a16f2629fa6db6e89aadebca",
    "line" : 7,
    "diffHunk" : "@@ -13,9 +13,8 @@ Let's start by looking at the DAML model, as this sets the core logic of the app\n The DAML Model\n ==============\n \n-Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n-There is a single DAML file called ``User.daml`` with the model for users of the app.\n-\n+Using the Visual Studio Code editor, navigate to the ``daml`` subdirectory."
  },
  {
    "id" : "d60e2872-7af1-4712-98c6-6a9b5df1cc43",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "bf426b6c-fa1f-495b-96c2-cdfcf4cdcbf5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We want people to have a pleasant UX. Currently, this only works with VS Code. Let's not suggest to use a different editor in the main text for now. We could add a footnote but I'm not sure we need to.",
        "createdAt" : "2020-02-17T16:16:43Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 16,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory."
  },
  {
    "id" : "766cfa44-21ed-4f40-aa18-e1ae5525e4fc",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "1810f26a-6e7f-4be5-82c8-c4afc9c0bd60",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "\"model for users of the app\" is slightly ambiguous. We need something better but I have currently no idea what.",
        "createdAt" : "2020-02-17T16:17:35Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 17,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app."
  },
  {
    "id" : "7dffb9a7-6d5c-428f-8f13-b7c80cfc3737",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "598050bc-65a7-4a8c-928a-6083e0c2ebbf",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The signatories are not authorized to do something but rather need to authorize the creating of new instances of this template.",
        "createdAt" : "2020-02-17T16:48:55Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 33,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract."
  },
  {
    "id" : "14189771-573a-4c98-8aa0-6cfaba0f4d91",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "134dcd89-4d92-45f4-b136-c777b2561334",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It is an obligation to authorize not a right.",
        "createdAt" : "2020-02-17T16:49:26Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 34,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights."
  },
  {
    "id" : "6cb0b272-5f1e-43c4-80ad-9b9ee4e79b6d",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "86c23758-90bd-4d1b-a50c-b457cec7f98a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think the word \"updated\" gives people a wrong sense of how DAML works. I would just remove the parentheses.",
        "createdAt" : "2020-02-17T16:51:23Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 40,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract."
  },
  {
    "id" : "c6172863-ebf9-4c37-8e73-f07abd5b4c73",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "3d996921-7c4d-41e9-8e07-70fc9e3151a7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Given that we explained signatories before observers, we should probably write\r\n```suggestion\r\nWe can see some concepts here that are central to DAML, namely *authorization* and *authorization*.\r\n```",
        "createdAt" : "2020-02-17T16:52:16Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 43,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*."
  },
  {
    "id" : "77d8ba4b-68c2-4f8e-a59f-06df434f1033",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "d3b8950d-ca48-48d9-a5ac-ba48115550b8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That's a very catchy explanation. I like it a lot!",
        "createdAt" : "2020-02-17T16:52:41Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 44,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*.\n+Privacy is about who can *see* what, and authorization is about who can *do* what."
  },
  {
    "id" : "8434221a-3a10-4cc4-a200-558bf126e911",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "ac7d6d2f-9a62-4d94-9f36-58af617e6f06",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nDAML contracts are *immutable* (can not be changed in place), so the only way to \"change\" them is to archive the current instance and create a new one.\r\n```",
        "createdAt" : "2020-02-17T16:53:49Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 54,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*.\n+Privacy is about who can *see* what, and authorization is about who can *do* what.\n+In DAML we must answer these questions upfront, as they fundamentally change the design of an application.\n+\n+The last thing we'll point out about the DAML model for now is the operation to add friends, called a *choice* in DAML.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- ADDFRIEND_BEGIN\n+  :end-before: -- ADDFRIEND_END\n+\n+DAML contracts are *immutable* (can not be changed in place), so they must be updated by archiving the current instance and creating a new one."
  },
  {
    "id" : "49458f4a-62f2-44aa-95f1-d45114ceb414",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "44de964c-ff21-42aa-ba5c-9baf71a7d63f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nThe user interface for our app is written in a superset of Javascript called TypeScript.\r\n```",
        "createdAt" : "2020-02-17T16:55:09Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*.\n+Privacy is about who can *see* what, and authorization is about who can *do* what.\n+In DAML we must answer these questions upfront, as they fundamentally change the design of an application.\n+\n+The last thing we'll point out about the DAML model for now is the operation to add friends, called a *choice* in DAML.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- ADDFRIEND_BEGIN\n+  :end-before: -- ADDFRIEND_END\n+\n+DAML contracts are *immutable* (can not be changed in place), so they must be updated by archiving the current instance and creating a new one.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n+The ``choice`` syntax automatically includes the archival of the current instance.\n+\n+.. TODO Update depending on consuming/nonconsuming choice.\n+\n+Next we'll see how our DAML code is reflected and used on the UI side.\n+\n+TypeScript Code Generation\n+==========================\n+\n+The user interface for our app is written in a variant of Javascript called TypeScript."
  },
  {
    "id" : "ff91e947-a6b0-4b15-b9ba-8b8572925ca8",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "d87abe68-c1d7-44f7-b29c-da003ff4cbf9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nOf course, we need a way to refer to our DAML model (templates and choices) in our TypeScript code.\r\n```",
        "createdAt" : "2020-02-17T16:55:42Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*.\n+Privacy is about who can *see* what, and authorization is about who can *do* what.\n+In DAML we must answer these questions upfront, as they fundamentally change the design of an application.\n+\n+The last thing we'll point out about the DAML model for now is the operation to add friends, called a *choice* in DAML.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- ADDFRIEND_BEGIN\n+  :end-before: -- ADDFRIEND_END\n+\n+DAML contracts are *immutable* (can not be changed in place), so they must be updated by archiving the current instance and creating a new one.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n+The ``choice`` syntax automatically includes the archival of the current instance.\n+\n+.. TODO Update depending on consuming/nonconsuming choice.\n+\n+Next we'll see how our DAML code is reflected and used on the UI side.\n+\n+TypeScript Code Generation\n+==========================\n+\n+The user interface for our app is written in a variant of Javascript called TypeScript.\n+The main feature of TypeScript is a rich type system which gives us more support through type checking during development.\n+\n+Of course, we need a way to refer to our DAML model (template and choices) in our TypeScript code."
  },
  {
    "id" : "88fee009-168c-48b3-b8bb-f929fa885277",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "100c3cee-fdcd-4b8f-a9d3-f0be21b8fa2e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nThe commands to run code generation (or \"codegen\") are::\r\n```",
        "createdAt" : "2020-02-17T16:56:05Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*.\n+Privacy is about who can *see* what, and authorization is about who can *do* what.\n+In DAML we must answer these questions upfront, as they fundamentally change the design of an application.\n+\n+The last thing we'll point out about the DAML model for now is the operation to add friends, called a *choice* in DAML.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- ADDFRIEND_BEGIN\n+  :end-before: -- ADDFRIEND_END\n+\n+DAML contracts are *immutable* (can not be changed in place), so they must be updated by archiving the current instance and creating a new one.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n+The ``choice`` syntax automatically includes the archival of the current instance.\n+\n+.. TODO Update depending on consuming/nonconsuming choice.\n+\n+Next we'll see how our DAML code is reflected and used on the UI side.\n+\n+TypeScript Code Generation\n+==========================\n+\n+The user interface for our app is written in a variant of Javascript called TypeScript.\n+The main feature of TypeScript is a rich type system which gives us more support through type checking during development.\n+\n+Of course, we need a way to refer to our DAML model (template and choices) in our TypeScript code.\n+This is where we have a code generation tool come in to play.\n+\n+The command ``daml codegen ts`` takes as argument a DAR file (a compiled form of our DAML model) and produces a number of corresponding TypeScript types and objects.\n+This is a crucial bridge to programming the UI around our DAML.\n+\n+The commands to run code generation (or \"codegen\") is::"
  },
  {
    "id" : "96266854-02f0-46e8-854f-e0b4be088241",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "b7b38687-cfe6-462a-941c-ed25caa5dc31",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nFor example, we can query the ledger for all contracts that are visible to the logged-in user, create contracts and exercise choices on contracts.\r\n```",
        "createdAt" : "2020-02-17T16:58:17Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 89,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*.\n+Privacy is about who can *see* what, and authorization is about who can *do* what.\n+In DAML we must answer these questions upfront, as they fundamentally change the design of an application.\n+\n+The last thing we'll point out about the DAML model for now is the operation to add friends, called a *choice* in DAML.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- ADDFRIEND_BEGIN\n+  :end-before: -- ADDFRIEND_END\n+\n+DAML contracts are *immutable* (can not be changed in place), so they must be updated by archiving the current instance and creating a new one.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n+The ``choice`` syntax automatically includes the archival of the current instance.\n+\n+.. TODO Update depending on consuming/nonconsuming choice.\n+\n+Next we'll see how our DAML code is reflected and used on the UI side.\n+\n+TypeScript Code Generation\n+==========================\n+\n+The user interface for our app is written in a variant of Javascript called TypeScript.\n+The main feature of TypeScript is a rich type system which gives us more support through type checking during development.\n+\n+Of course, we need a way to refer to our DAML model (template and choices) in our TypeScript code.\n+This is where we have a code generation tool come in to play.\n+\n+The command ``daml codegen ts`` takes as argument a DAR file (a compiled form of our DAML model) and produces a number of corresponding TypeScript types and objects.\n+This is a crucial bridge to programming the UI around our DAML.\n+\n+The commands to run code generation (or \"codegen\") is::\n+\n+    daml build\n+    daml codegen ts .daml/dist/create-daml-app-0.1.0.dar -o daml-ts/src\n+\n+The first command builds the ``create-daml-app-0.1.0.dar`` DAR file.\n+The ``codegen`` command translates the DAML into a series of TypeScript files in the ``daml-ts/src`` directory.\n+These definitions can then be used in the UI code, as we'll see next.\n+\n+The UI\n+======\n+\n+Our UI is written using `React <https://reactjs.org/>`_ and `TypeScript <https://www.typescriptlang.org/>`_.\n+React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - combined with a judicious use of global state.\n+\n+We can see the latter in the way we handle ledger state throughout the application code.\n+For this we use a state management feature in React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+You can see the capabilities of the DAML React hooks in ``create-daml-app/ui/src/daml-react-hooks/hooks.ts``.\n+For example, we can query the ledger for all visible contracts (relative to a particular user), create contracts and exercise choices on contracts."
  },
  {
    "id" : "8e53bbcd-460f-4f88-9085-728241750d13",
    "prId" : 4548,
    "comments" : [
      {
        "id" : "edf386aa-e479-4fe6-a263-2000cc118f0d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We don't know about more restricted queries yet.\r\n```suggestion\r\nFor instance, ``allUsers`` uses a query to get the ``User`` contracts on the ledger.\r\n```",
        "createdAt" : "2020-02-17T16:59:24Z",
        "updatedAt" : "2020-02-17T17:03:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bb92a345c4400124c999fca0333ed607b44eac61",
    "line" : 101,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+App Architecture\n+****************\n+\n+In this section we'll look at the different components of our social network app.\n+The goal is to familiarise you enough to feel comfortable extending the code with a new feature in the next section.\n+\n+There are two main components in the code - the DAML model and the React/TypeScript frontend - with generated TypeScript code to bridge the two.\n+Let's start by looking at the DAML model, as this sets the core logic of the application.\n+\n+The DAML Model\n+==============\n+\n+Using VSCode (or a code editor of your choice), navigate to the ``daml`` subdirectory.\n+There is a single DAML file called ``User.daml`` with the model for users of the app.\n+\n+The core data is at the start of the ``User`` contract template.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- MAIN_TEMPLATE_BEGIN\n+  :end-before: -- MAIN_TEMPLATE_END\n+\n+There are two important aspects here:\n+\n+1. The data definition (a *schema* in database terms), describing the data stored with each user contract.\n+In this case it is an identifier for the user and their current list of friends.\n+Both fields use the built-in ``Party`` type which lets us use them in the following clauses.\n+\n+2. The signatories and observers of the contract.\n+The signatories are the parties authorized to create new versions of the contract or archive the contract.\n+In this case only the user has those rights.\n+The observers are the parties who are able to view the contract on the ledger.\n+In this case all friends of a user are able to see the user contract.\n+\n+Let's say what the ``signatory`` and ``observer`` clauses mean in our app more concretely.\n+A user Alice can see another user Bob in the network only when Alice is a friend in Bob's user contract.\n+For this to be true, Bob must have previously added Alice as a friend (i.e. updated his user contract), as he is the sole signatory on his user contract.\n+If not, Bob will be invisible to Alice.\n+\n+We can see some concepts here that are central to DAML, namely *privacy* and *authorization*.\n+Privacy is about who can *see* what, and authorization is about who can *do* what.\n+In DAML we must answer these questions upfront, as they fundamentally change the design of an application.\n+\n+The last thing we'll point out about the DAML model for now is the operation to add friends, called a *choice* in DAML.\n+\n+.. literalinclude:: code/daml/User.daml\n+  :language: daml\n+  :start-after: -- ADDFRIEND_BEGIN\n+  :end-before: -- ADDFRIEND_END\n+\n+DAML contracts are *immutable* (can not be changed in place), so they must be updated by archiving the current instance and creating a new one.\n+That is what the ``AddFriend`` choice does: after checking some preconditions, it creates a new user contract with the new friend added to the list.\n+The ``choice`` syntax automatically includes the archival of the current instance.\n+\n+.. TODO Update depending on consuming/nonconsuming choice.\n+\n+Next we'll see how our DAML code is reflected and used on the UI side.\n+\n+TypeScript Code Generation\n+==========================\n+\n+The user interface for our app is written in a variant of Javascript called TypeScript.\n+The main feature of TypeScript is a rich type system which gives us more support through type checking during development.\n+\n+Of course, we need a way to refer to our DAML model (template and choices) in our TypeScript code.\n+This is where we have a code generation tool come in to play.\n+\n+The command ``daml codegen ts`` takes as argument a DAR file (a compiled form of our DAML model) and produces a number of corresponding TypeScript types and objects.\n+This is a crucial bridge to programming the UI around our DAML.\n+\n+The commands to run code generation (or \"codegen\") is::\n+\n+    daml build\n+    daml codegen ts .daml/dist/create-daml-app-0.1.0.dar -o daml-ts/src\n+\n+The first command builds the ``create-daml-app-0.1.0.dar`` DAR file.\n+The ``codegen`` command translates the DAML into a series of TypeScript files in the ``daml-ts/src`` directory.\n+These definitions can then be used in the UI code, as we'll see next.\n+\n+The UI\n+======\n+\n+Our UI is written using `React <https://reactjs.org/>`_ and `TypeScript <https://www.typescriptlang.org/>`_.\n+React helps us write modular UI components using a functional style - a component is rerendered whenever one of its inputs changes - combined with a judicious use of global state.\n+\n+We can see the latter in the way we handle ledger state throughout the application code.\n+For this we use a state management feature in React called `Hooks <https://reactjs.org/docs/hooks-intro.html>`_.\n+You can see the capabilities of the DAML React hooks in ``create-daml-app/ui/src/daml-react-hooks/hooks.ts``.\n+For example, we can query the ledger for all visible contracts (relative to a particular user), create contracts and exercise choices on contracts.\n+\n+.. TODO Update location to view DAML react hooks API\n+\n+Let's see some examples of DAML React hooks.\n+\n+.. literalinclude:: code/ui-before/MainView.tsx\n+  :start-after: -- HOOKS_BEGIN\n+  :end-before: -- HOOKS_END\n+\n+This is the start of the component which provides data from the current state of the ledger to the main screen of our app.\n+The three declarations within ``MainView`` all use DAML hooks to get information from the ledger.\n+For instance, ``allUsers`` uses a catch-all query to get the ``User`` contracts on the ledger."
  }
]