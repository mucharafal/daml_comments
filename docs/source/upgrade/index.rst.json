[
  {
    "id" : "74221a4c-b759-402c-bec3-2cd145882178",
    "prId" : 4921,
    "comments" : [
      {
        "id" : "acbe1364-e9dc-4bb7-821d-ded46bb29df3",
        "parentId" : null,
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "fix small existing typo. It should be \"live on the ledger\"",
        "createdAt" : "2020-03-10T14:27:11Z",
        "updatedAt" : "2020-03-10T14:57:49Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0637eb2b-5005-411e-9c60-20364be7ab69",
        "parentId" : "acbe1364-e9dc-4bb7-821d-ded46bb29df3",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, fixed! Thank you!",
        "createdAt" : "2020-03-10T14:58:00Z",
        "updatedAt" : "2020-03-10T14:58:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "45205836e1a2cd900b147faf4678ed2511f47b42",
    "line" : null,
    "diffHunk" : "@@ -145,47 +145,70 @@ We point a browser to http://localhost:4000, and follow the steps:\n     #. Exercise the *CoinProposal_Accept* choice on both proposal contracts.\n \n \n-Building and deploying version-2\n-================================\n+Building and deploying coin-2.0.0\n+=================================\n \n-Now we setup the project for the improved coins containing the *amount* field. This project contains the templates for ``CoinWithAmount``, ``UpgradeCoinProposal`` and ``UpgradeCoinAgreement``.\n+Now we setup the project for the improved coins containing the *amount* field. This project contains only the ``CoinWithAmount`` template. The upgrade templates are in a third ``coin-upgrade`` package. While it would be possible to include the upgrade templates in the same package, this means that the package containing the new ``CoinWithAmount`` template depends on the previous version. With the approach taken here of keeping the upgrade templates in a separate package, the ``coin-1.0.0`` package is no longer needed once we have upgraded all coins.\n \n-It's worth stressing here that we must setup a new project for version-2. We cannot just add the new definitions to the original project, rebuild and re-deploy. This is because the cryptographically computed package-id would change, and would not match the package-id of version-1 coin-contracts which are live of the ledger.\n+It's worth stressing here that extensions always need to go into separate packages. We cannot just add the new definitions to the original project, rebuild and re-deploy. This is because the cryptographically computed package identifier would change, and would not match the package identifier of the original ``Coin`` contracts from ``coin-1.0.0`` which are live of the ledger."
  },
  {
    "id" : "06e4cad1-6704-4591-9a02-a4603d40d8c5",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "e8538a5c-3cbc-4bef-97b6-73a29e20953a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why not use the default port here?",
        "createdAt" : "2020-03-03T13:02:03Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "734b6343-219e-4845-9cd5-00552a63360a",
        "parentId" : "e8538a5c-3cbc-4bef-97b6-73a29e20953a",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I prefer the explicitness. I think magic default port numbers are a pretty bad idea.",
        "createdAt" : "2020-03-03T14:04:21Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f55bc268-ba44-429d-9f3f-9bba9e1565e6",
        "parentId" : "e8538a5c-3cbc-4bef-97b6-73a29e20953a",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That’s reasonable but can we explicitly specify the default then, i.e., `--port 6865`?",
        "createdAt" : "2020-03-03T14:05:39Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,103 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001"
  },
  {
    "id" : "875bbf68-c9fd-4b69-9558-b4349b5dd1d0",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "285cd316-ffa3-403d-9408-fffef3b955f1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Instead of specifying the ledger API parameters on every command, why not put them in the `daml.yaml` and then use `daml ledger navigator`?",
        "createdAt" : "2020-03-03T13:03:21Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a778cd77-6d88-4ab1-8eda-1ca7d878411e",
        "parentId" : "285cd316-ffa3-403d-9408-fffef3b955f1",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Are you only changing the directory here to pick up `parties` from the `daml.yaml`? It seems a bit odd to start `sandbox` in the root but `navigator` in a subdirectory. If that’s the only reason, maybe add a `daml.yaml` containing only the `sdk-version` and the `parties` in the root.",
        "createdAt" : "2020-03-03T13:17:08Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3c7433c8-bbe5-4af8-bb78-5b5a34e543e7",
        "parentId" : "285cd316-ffa3-403d-9408-fffef3b955f1",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Yes. to pick up the parties.\r\nThe reason for starting the sandbox at the root is precisely because it spans both versions.",
        "createdAt" : "2020-03-03T14:05:48Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,103 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Create some version-1 coins\n+================================\n+\n+Let's create some coins. We'll use the navigator to connect to the ledger, and create two coins issued by Alice, and owned by Bob.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml navigator server localhost 7001"
  },
  {
    "id" : "5a4ea226-1a2b-48ef-bb72-2392ba59e9a5",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "e901eb2f-278c-4676-a76e-f3155111fc77",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nWe point a browser to http://localhost:4000, and follow the steps:\r\n```\r\n\r\nSphinx automatically detects links so this will be clickable.",
        "createdAt" : "2020-03-03T13:03:40Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,103 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Create some version-1 coins\n+================================\n+\n+Let's create some coins. We'll use the navigator to connect to the ledger, and create two coins issued by Alice, and owned by Bob.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml navigator server localhost 7001\n+\n+We point a browser to ``localhost:4000``, and follow the steps:"
  },
  {
    "id" : "40e67cf5-92b5-4c8a-8a0b-17357eb616e5",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "f95dc626-a50b-484d-8c81-e69acf02b2d6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The text here does not quite match the code. I would have expected something like a `CoinProposal` signed by the issuer and then the `owner` can accept it. Instead you have an extra step: First, the issuer has to create a self-issues `Coin`, then they have to create a `TransferProposal` which then has to be accepted by the owner.\r\n\r\nGiven that this is not the focus of this tutorial I would keep it as simple as possible and not include transfers. The fact that the upgraded coin is no longer transferable is also a bit confusing and while that’s fixable it only adds more complexity.",
        "createdAt" : "2020-03-03T13:13:19Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9b33398e-6513-48f5-b607-b720709703bc",
        "parentId" : "f95dc626-a50b-484d-8c81-e69acf02b2d6",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I agree.\r\nI don't really want to present the Transfer. But I do want to use it in the example steps.\r\nSo it will have to exist in the example\r\n",
        "createdAt" : "2020-03-03T14:10:45Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,109 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example."
  },
  {
    "id" : "ec8720b9-a497-4daf-865c-483fc759be37",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "fec7a439-5bf9-49d7-a695-ac0dff511668",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Afaik `daml deploy` is `daml build + daml ledger upload-dar` so you can either skip the `build` step or use `ledger upload-dar`.",
        "createdAt" : "2020-03-03T13:15:32Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ca4ff0c-06f9-480e-b805-60597189f2a0",
        "parentId" : "fec7a439-5bf9-49d7-a695-ac0dff511668",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Just off the top of my head, I think having the `build` step discrete is a good idea if this at some point goes in the tangent direction of ts generation, scripts and triggers.",
        "createdAt" : "2020-03-03T14:08:48Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e2d9f146-a654-4445-acd4-d54f0ad8de5a",
        "parentId" : "fec7a439-5bf9-49d7-a695-ac0dff511668",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I prefer keeping the build and deploy steps explicit. I don't think the example is clarified by taking advantage of the implicit `build` initiated by `deploy`.",
        "createdAt" : "2020-03-03T14:09:06Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "35dc30e8-c172-4af1-a166-4cbd596406e6",
        "parentId" : "fec7a439-5bf9-49d7-a695-ac0dff511668",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe just switch to `daml ledger upload-dar` then? IIRC `daml deploy` also does party allocation in a somewhat sketchy way so I think it actually does more harm than good in most cases.",
        "createdAt" : "2020-03-03T14:14:46Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,109 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001"
  },
  {
    "id" : "2c7eb695-e5aa-4734-b06a-bc04080c0a4c",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "098f5916-aaca-4b04-aa09-a34728cbad4b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We might want to turn this into a DAML script (in a separate PR). That has the advantage that it’s easier to reproduce without including screenshots of navigator and we can test it.",
        "createdAt" : "2020-03-03T13:18:23Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : 93,
    "diffHunk" : "@@ -82,13 +83,109 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Create some version-1 coins\n+================================\n+\n+Let's create some coins. We'll use the navigator to connect to the ledger, and create two coins issued by Alice, and owned by Bob.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml navigator server localhost 7001\n+\n+We point a browser to ``localhost:4000``, and follow the steps:\n+\n+#. Login as Alice:"
  },
  {
    "id" : "552584ca-5f14-45f3-b4a8-579faa20871e",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "5592f961-f907-4219-bef3-c049b67d49e0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think somewhere in here we should mention why it’s crucial to do this in a separate package and why simply adding a module to the existing package and recompiling is not going to work (because it would change the package id).",
        "createdAt" : "2020-03-03T13:19:54Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,109 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Create some version-1 coins\n+================================\n+\n+Let's create some coins. We'll use the navigator to connect to the ledger, and create two coins issued by Alice, and owned by Bob.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml navigator server localhost 7001\n+\n+We point a browser to ``localhost:4000``, and follow the steps:\n+\n+#. Login as Alice:\n+    #. Create a coin with Alice as both issuer and owner.\n+    #. Exercise the coin's *Transfer* choice, naming Bob as the new owner.\n+    #. Create and transfer a 2nd coin in the same way.\n+#. Login as Bob:\n+    #. Exercise the *Accept* choice on both transfer contracts.\n+\n+\n+Building and deploying version-2\n+================================\n+\n+Now we setup the project for the improved coins containing the *amount* field. The new project is named ``coinV21`` and contains the templates for ``CoinWithAmount``, ``UpgradeCoinProposal`` and ``UpgradeCoinAgreement``. The project setup is:"
  },
  {
    "id" : "82be6724-f8ed-4e78-935d-1ab5a3b00bb8",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "2fc48279-d68d-4b7f-bedc-e8165ea7246d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think somewhere in here we should mention why it’s crucial to do this in a separate package and why simply adding a module to the existing package and recompiling is not going to work (because it would change the package id).",
        "createdAt" : "2020-03-03T13:20:20Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,109 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Create some version-1 coins\n+================================\n+\n+Let's create some coins. We'll use the navigator to connect to the ledger, and create two coins issued by Alice, and owned by Bob.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml navigator server localhost 7001\n+\n+We point a browser to ``localhost:4000``, and follow the steps:\n+\n+#. Login as Alice:\n+    #. Create a coin with Alice as both issuer and owner.\n+    #. Exercise the coin's *Transfer* choice, naming Bob as the new owner.\n+    #. Create and transfer a 2nd coin in the same way.\n+#. Login as Bob:\n+    #. Exercise the *Accept* choice on both transfer contracts.\n+\n+\n+Building and deploying version-2\n+================================\n+\n+Now we setup the project for the improved coins containing the *amount* field. The new project is named ``coinV21`` and contains the templates for ``CoinWithAmount``, ``UpgradeCoinProposal`` and ``UpgradeCoinAgreement``. The project setup is:\n+\n+.. literalinclude:: example/coinV2/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+The interesting thing about the project setup for ``coinV2`` is that ``coinV1-0.0.1.dar`` is listed as a dependency. This allows the upgrade templates to make reference to the ``Coin`` template from the ``CoinV1`` module, even though that module is part of original package already deployed to the ledger."
  },
  {
    "id" : "4d2eda70-ef5d-4936-bf7a-4df783a6c164",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "2838b37d-0bed-4267-99c0-865f345c1f9f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n==================================================\r\n```\r\nRST is great.",
        "createdAt" : "2020-03-03T13:22:00Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a71b858-9abe-4ac3-b2ad-68d3b09bdc4d",
        "parentId" : "2838b37d-0bed-4267-99c0-865f345c1f9f",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Oh man. This is what caused my CI build to fail.. that's crazy!\r\nHow come I didn't get a local failure?",
        "createdAt" : "2020-03-03T14:11:49Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2f6d5762-91e6-4f6f-a66f-64e9f18b6ed7",
        "parentId" : "2838b37d-0bed-4267-99c0-865f345c1f9f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The previous script does not treat warnings as fatal whereas the Bazel target does. If you run `bazel build //docs:docs` it will fail localyl as well. Rst is great :woman_facepalming: ",
        "createdAt" : "2020-03-03T14:12:56Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,109 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Create some version-1 coins\n+================================\n+\n+Let's create some coins. We'll use the navigator to connect to the ledger, and create two coins issued by Alice, and owned by Bob.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml navigator server localhost 7001\n+\n+We point a browser to ``localhost:4000``, and follow the steps:\n+\n+#. Login as Alice:\n+    #. Create a coin with Alice as both issuer and owner.\n+    #. Exercise the coin's *Transfer* choice, naming Bob as the new owner.\n+    #. Create and transfer a 2nd coin in the same way.\n+#. Login as Bob:\n+    #. Exercise the *Accept* choice on both transfer contracts.\n+\n+\n+Building and deploying version-2\n+================================\n+\n+Now we setup the project for the improved coins containing the *amount* field. The new project is named ``coinV21`` and contains the templates for ``CoinWithAmount``, ``UpgradeCoinProposal`` and ``UpgradeCoinAgreement``. The project setup is:\n+\n+.. literalinclude:: example/coinV2/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+The interesting thing about the project setup for ``coinV2`` is that ``coinV1-0.0.1.dar`` is listed as a dependency. This allows the upgrade templates to make reference to the ``Coin`` template from the ``CoinV1`` module, even though that module is part of original package already deployed to the ledger.\n+\n+The DAML for the upgrade contacts imports the modules for both the new and old coin versions.\n+\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_MODULE_BEGIN\n+  :end-before: -- UPGRADE_MODULE_END\n+\n+Now we can build and deploy version-2 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV2\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Upgrade existing coins from version-1 to version-2\n+================================"
  },
  {
    "id" : "7da23a05-5846-4f0a-b4a0-5eeb7748d28f",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "c5e7534e-c411-4902-a3d6-d5cc24d06c70",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here, we probably want to change this to a DAML script (in a separate PR).\r\n\r\nIt would also be nice to explain the trigger-based flow that DAVL uses where you have the following steps:\r\n1. Deploy the upgrade.\r\n2. The issuer runs a script to create `UpgradeProposal`s for all of their coins.\r\n3. The issuer runs a trigger that will upgrade each `Coin` for which there is an `UpgradeCoinAgreement`.\r\n4. The owner interactively (here probably via DAML script (or `daml repl` :slightly_smiling_face:), in a “real” application via some UI) accepts a proposal.\r\n\r\nAlthough it probably makes sense to put this into a separate section and first explain how to do things without a trigger.",
        "createdAt" : "2020-03-03T13:25:20Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b2556eaf-cf22-4b76-b1c6-bbfe244ff3c9",
        "parentId" : "c5e7534e-c411-4902-a3d6-d5cc24d06c70",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "^ Seconded although doesn't all have to happen in this PR of course - future directions.",
        "createdAt" : "2020-03-03T14:10:35Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f0c1cbb0-6d11-4e22-8101-b7a90be9bd68",
        "parentId" : "c5e7534e-c411-4902-a3d6-d5cc24d06c70",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Yes. This would be great to do.\r\nI've not actually used DAML script yet, so it would be a good chance to learn.\r\nHappy to leave this to a following PR.",
        "createdAt" : "2020-03-03T14:13:34Z",
        "updatedAt" : "2020-03-04T14:53:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1d251721-f1c9-4168-8028-fc57cd2dcdb5",
        "parentId" : "c5e7534e-c411-4902-a3d6-d5cc24d06c70",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Having thought a bit about this, I don’t want to use DAML script in those docs for now (at least not as a navigator replacement for the part we currently have, it might still make sense to explain the full DAML script/trigger-based automation used in DAVL). The reason for this is that doing this properly wtr to packaging (which is a crucial part of upgrading so I think this is something that we do need to do properly here) would mean putting the DAML script code into separate packages so we end up with 5 or 6 packages in total which is just too confusing. In principle `daml repl` would be a great navigator replacement for this and avoids the issue (since the code you typo into the repl is never written to a proper package) but `daml repl` is still experimental (for good reasons) and we cannot use an experimental feature in docs for something non-experimental. Therefore, I think for now it makes more sense to add 2 or 3 navigator screenshots.",
        "createdAt" : "2020-03-11T08:19:40Z",
        "updatedAt" : "2020-03-11T08:19:41Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : null,
    "diffHunk" : "@@ -82,13 +83,109 @@ has one *nonconsuming* choice that accepts a *Coin* contract, archives\n this *Coin* contract and creates a *CoinWithAmount* contract with\n *amount* set to 1.\n \n-.. literalinclude:: daml/Upgrade.daml\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n   :language: daml\n   :start-after: -- UPGRADE_AGREEMENT_BEGIN\n   :end-before: -- UPGRADE_AGREEMENT_END\n \n-.. TODO Turn this into a full example project with multiple packages\n-.. and explain builds and deployment.\n \n-.. Building and deploying\n-.. ======================\n+Building and deploying version-1\n+================================\n+\n+Let's see everything in action by following the steps to build and deploy version-1 of our coin. After this we'll see how to deploy and upgrade to version-2.\n+\n+First we'll need a sandbox ledger to which we can deploy.\n+\n+.. code-block:: none\n+\n+   $ daml sandbox --port 7001\n+\n+The version-1 project is named ``coinV1``. It contains just the original *Coin* definition template ``Coin``. Here is the ``daml.yaml`` setup\n+\n+.. literalinclude:: example/coinV1/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+To make the example complete, we need a way to create some coins which have different parties for the issuer and owner. We take the standard approach of adding a :ref:`Propose-Accept workflow <intro propose accept>` to our example.\n+\n+.. literalinclude:: example/coinV1/daml/CoinV1.daml\n+  :language: daml\n+  :start-after: -- COIN_TRANSFER_BEGIN\n+  :end-before: -- COIN_TRANSFER_END\n+\n+Now we can build and deploy version-1 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Create some version-1 coins\n+================================\n+\n+Let's create some coins. We'll use the navigator to connect to the ledger, and create two coins issued by Alice, and owned by Bob.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV1\n+   $ daml navigator server localhost 7001\n+\n+We point a browser to ``localhost:4000``, and follow the steps:\n+\n+#. Login as Alice:\n+    #. Create a coin with Alice as both issuer and owner.\n+    #. Exercise the coin's *Transfer* choice, naming Bob as the new owner.\n+    #. Create and transfer a 2nd coin in the same way.\n+#. Login as Bob:\n+    #. Exercise the *Accept* choice on both transfer contracts.\n+\n+\n+Building and deploying version-2\n+================================\n+\n+Now we setup the project for the improved coins containing the *amount* field. The new project is named ``coinV21`` and contains the templates for ``CoinWithAmount``, ``UpgradeCoinProposal`` and ``UpgradeCoinAgreement``. The project setup is:\n+\n+.. literalinclude:: example/coinV2/daml.yaml\n+  :language: yaml\n+  :start-after: # BEGIN\n+  :end-before: # END\n+\n+The interesting thing about the project setup for ``coinV2`` is that ``coinV1-0.0.1.dar`` is listed as a dependency. This allows the upgrade templates to make reference to the ``Coin`` template from the ``CoinV1`` module, even though that module is part of original package already deployed to the ledger.\n+\n+The DAML for the upgrade contacts imports the modules for both the new and old coin versions.\n+\n+.. literalinclude:: example/coinV2/daml/UpgradeFromCoinV1.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_MODULE_BEGIN\n+  :end-before: -- UPGRADE_MODULE_END\n+\n+Now we can build and deploy version-2 of our Coin.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV2\n+   $ daml build\n+   $ daml deploy --port 7001\n+\n+\n+Upgrade existing coins from version-1 to version-2\n+================================\n+\n+We start the navigator again.\n+\n+.. code-block:: none\n+\n+   $ cd example/coinV2\n+   $ daml navigator server localhost 7001\n+\n+Finally, we point a browser to ``localhost:4000`` and can effect the coin upgrades:"
  },
  {
    "id" : "87a95f0d-4a71-4ea0-b9c0-f6ceade9d40b",
    "prId" : 4794,
    "comments" : [
      {
        "id" : "faea8507-21e3-4cfe-be53-b584233e0286",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not sure I'm a big fan of this. Some of our users will get it wrong. Since we have the mechanisms to rename modules when importing packages, we should teach how to do this instead.",
        "createdAt" : "2020-03-04T15:59:09Z",
        "updatedAt" : "2020-03-04T17:03:33Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f863aa57-2add-43f1-82ab-a51b36f271e9",
        "parentId" : "faea8507-21e3-4cfe-be53-b584233e0286",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Yeah, we discussed this a bit. We do plan to move the example in this direction. As you say, we may as well show our users an example how to do this!",
        "createdAt" : "2020-03-04T17:29:28Z",
        "updatedAt" : "2020-03-04T17:29:28Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "610b2570-9bb3-4d25-b888-f40a79defde3",
        "parentId" : "faea8507-21e3-4cfe-be53-b584233e0286",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think splitting it up into separate packages makes sense, I don’t really want to explain how to handle colliding module names here and e.g. danban uses the scheme used here. My idea was to leave this to a fairly simple but sensible (as in, I’m comfortable using this in production) example and then link to the packaging docs which will have all the details around data-dependencies, colliding module names, ….",
        "createdAt" : "2020-03-04T17:48:02Z",
        "updatedAt" : "2020-03-04T17:48:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d3187735-ff16-4c17-9b33-55c3f4182899",
        "parentId" : "faea8507-21e3-4cfe-be53-b584233e0286",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "A link to an explanation of how to handle module name clashes does the job as well. Thanks.",
        "createdAt" : "2020-03-04T17:58:37Z",
        "updatedAt" : "2020-03-04T17:58:37Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ffa1da113ccd87d742c17bdafd8fe4ca866ce0ff",
    "line" : 5,
    "diffHunk" : "@@ -37,8 +37,10 @@ Structuring upgrade contracts\n Upgrade contracts are specific to the templates that are being\n upgraded. However, there are common patterns between most of them. We\n use the example of a simple *Coin* template as an example here.\n+We have some prescience that there will be future versions of *Coin*,\n+and so place the definition of ``Coin`` in a module named ``CoinV1``"
  },
  {
    "id" : "95aad6b7-4caf-494a-8081-769819aab130",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "191ae874-35b8-4358-98d2-44d5932daeca",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not 100% sure but that feels better to me:\r\n```suggestion\r\nthat template would completely break the authorization guarantees provided\r\n ```",
        "createdAt" : "2020-03-04T13:56:40Z",
        "updatedAt" : "2020-03-04T14:05:16Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 15,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided"
  },
  {
    "id" : "a7177d27-e39a-40ee-a53d-7a7f9d1e3108",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "d9f3eff3-845f-4f06-b09c-916b338422a3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nand module names for the sake of simplicity.\r\n```",
        "createdAt" : "2020-03-04T13:59:32Z",
        "updatedAt" : "2020-03-04T14:05:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 54,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided\n+by DAML.\n+\n+Therefore, DAML takes a different approach to upgrades and\n+extensions. Rather than having a separate concept of data migration\n+that sidesteps the fundamental guarantees provided by DAML, *upgrades\n+are expressed as DAML contracts*. This means that the same guarantees\n+and rules that apply to other DAML contracts also apply to upgrades.\n+\n+In a DAML application, it therefore makes sense to think of upgrades\n+as an *extension of an existing application* instead of an operation\n+that replaces exiting contracts with a newer version of those\n+contracts. The existing templates stay on the ledger and can still be\n+used. Contracts of existing templates are not automatically replaced\n+by newer versions. However, the application is extended with new\n+templates and if all signatories of a contract agree, a choice can\n+archive the old version of a contract and create a new contract\n+instead.\n+\n+Structuring upgrade contracts\n+=============================\n+\n+Upgrade contracts are specific to the templates that are being\n+upgraded. However, there are common patterns between most of them. We\n+use the example of a simple *Coin* template as an example here.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A *Coin* has an issuer and an owner and both are signatories.  Our\n+goal is to extend this *Coin* template with a field that represents\n+the number of coins to avoid needing 1000 contracts to represent 1000\n+coins. (In a real application, you would also want choices for merging\n+and splitting such a *Coin*. For presentational purposes, we omit\n+those here.) We use a different name for the new template here. This\n+is not required as templates are identified by the triple\n+``(PackageId, ModuleName, TemplateName)`` but here we omit package ids\n+and module names for presentational purposes."
  },
  {
    "id" : "320765ef-b34a-452d-b4ef-0743d1767bd0",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "ae8bf165-b317-4d45-a461-63db5ed1a28d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nNext, we need to provide a way for\r\n```",
        "createdAt" : "2020-03-04T14:00:23Z",
        "updatedAt" : "2020-03-04T14:05:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 61,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided\n+by DAML.\n+\n+Therefore, DAML takes a different approach to upgrades and\n+extensions. Rather than having a separate concept of data migration\n+that sidesteps the fundamental guarantees provided by DAML, *upgrades\n+are expressed as DAML contracts*. This means that the same guarantees\n+and rules that apply to other DAML contracts also apply to upgrades.\n+\n+In a DAML application, it therefore makes sense to think of upgrades\n+as an *extension of an existing application* instead of an operation\n+that replaces exiting contracts with a newer version of those\n+contracts. The existing templates stay on the ledger and can still be\n+used. Contracts of existing templates are not automatically replaced\n+by newer versions. However, the application is extended with new\n+templates and if all signatories of a contract agree, a choice can\n+archive the old version of a contract and create a new contract\n+instead.\n+\n+Structuring upgrade contracts\n+=============================\n+\n+Upgrade contracts are specific to the templates that are being\n+upgraded. However, there are common patterns between most of them. We\n+use the example of a simple *Coin* template as an example here.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A *Coin* has an issuer and an owner and both are signatories.  Our\n+goal is to extend this *Coin* template with a field that represents\n+the number of coins to avoid needing 1000 contracts to represent 1000\n+coins. (In a real application, you would also want choices for merging\n+and splitting such a *Coin*. For presentational purposes, we omit\n+those here.) We use a different name for the new template here. This\n+is not required as templates are identified by the triple\n+``(PackageId, ModuleName, TemplateName)`` but here we omit package ids\n+and module names for presentational purposes.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_AMOUNT_BEGIN\n+  :end-before: -- COIN_AMOUNT_END\n+\n+Now, that we defined our new template, we need to provide a way for"
  },
  {
    "id" : "0a497784-9c53-45f2-aa52-5f4b7009777d",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "5e960b10-792c-496a-a5e8-2c3454e33266",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nthe signatories, issuer and owner, to agree to a contract being\r\n```",
        "createdAt" : "2020-03-04T14:00:54Z",
        "updatedAt" : "2020-03-04T14:05:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 62,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided\n+by DAML.\n+\n+Therefore, DAML takes a different approach to upgrades and\n+extensions. Rather than having a separate concept of data migration\n+that sidesteps the fundamental guarantees provided by DAML, *upgrades\n+are expressed as DAML contracts*. This means that the same guarantees\n+and rules that apply to other DAML contracts also apply to upgrades.\n+\n+In a DAML application, it therefore makes sense to think of upgrades\n+as an *extension of an existing application* instead of an operation\n+that replaces exiting contracts with a newer version of those\n+contracts. The existing templates stay on the ledger and can still be\n+used. Contracts of existing templates are not automatically replaced\n+by newer versions. However, the application is extended with new\n+templates and if all signatories of a contract agree, a choice can\n+archive the old version of a contract and create a new contract\n+instead.\n+\n+Structuring upgrade contracts\n+=============================\n+\n+Upgrade contracts are specific to the templates that are being\n+upgraded. However, there are common patterns between most of them. We\n+use the example of a simple *Coin* template as an example here.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A *Coin* has an issuer and an owner and both are signatories.  Our\n+goal is to extend this *Coin* template with a field that represents\n+the number of coins to avoid needing 1000 contracts to represent 1000\n+coins. (In a real application, you would also want choices for merging\n+and splitting such a *Coin*. For presentational purposes, we omit\n+those here.) We use a different name for the new template here. This\n+is not required as templates are identified by the triple\n+``(PackageId, ModuleName, TemplateName)`` but here we omit package ids\n+and module names for presentational purposes.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_AMOUNT_BEGIN\n+  :end-before: -- COIN_AMOUNT_END\n+\n+Now, that we defined our new template, we need to provide a way for\n+the signatories issuer and owner to agree to a contract being"
  },
  {
    "id" : "cde87949-1af1-4dc4-b271-f227d4584e25",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "50769666-721c-473a-b6f0-4c59b4fa4ce9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nowner have to agree to an upgrade for each individual *Coin* contract\r\n```",
        "createdAt" : "2020-03-04T14:01:46Z",
        "updatedAt" : "2020-03-04T14:05:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 64,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided\n+by DAML.\n+\n+Therefore, DAML takes a different approach to upgrades and\n+extensions. Rather than having a separate concept of data migration\n+that sidesteps the fundamental guarantees provided by DAML, *upgrades\n+are expressed as DAML contracts*. This means that the same guarantees\n+and rules that apply to other DAML contracts also apply to upgrades.\n+\n+In a DAML application, it therefore makes sense to think of upgrades\n+as an *extension of an existing application* instead of an operation\n+that replaces exiting contracts with a newer version of those\n+contracts. The existing templates stay on the ledger and can still be\n+used. Contracts of existing templates are not automatically replaced\n+by newer versions. However, the application is extended with new\n+templates and if all signatories of a contract agree, a choice can\n+archive the old version of a contract and create a new contract\n+instead.\n+\n+Structuring upgrade contracts\n+=============================\n+\n+Upgrade contracts are specific to the templates that are being\n+upgraded. However, there are common patterns between most of them. We\n+use the example of a simple *Coin* template as an example here.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A *Coin* has an issuer and an owner and both are signatories.  Our\n+goal is to extend this *Coin* template with a field that represents\n+the number of coins to avoid needing 1000 contracts to represent 1000\n+coins. (In a real application, you would also want choices for merging\n+and splitting such a *Coin*. For presentational purposes, we omit\n+those here.) We use a different name for the new template here. This\n+is not required as templates are identified by the triple\n+``(PackageId, ModuleName, TemplateName)`` but here we omit package ids\n+and module names for presentational purposes.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_AMOUNT_BEGIN\n+  :end-before: -- COIN_AMOUNT_END\n+\n+Now, that we defined our new template, we need to provide a way for\n+the signatories issuer and owner to agree to a contract being\n+upgraded. It would be possible to structure this such that issuer and\n+owner have to agree to an upgrade for each *Coin* contract"
  },
  {
    "id" : "37b6ae7d-255c-4b44-ad71-b6efb1e3d3e3",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "d15e52a8-c741-407f-9607-d5dabc1f4d0d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nseparately. However, since the template definition for all of them is\r\n```",
        "createdAt" : "2020-03-04T14:02:22Z",
        "updatedAt" : "2020-03-04T14:05:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 65,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided\n+by DAML.\n+\n+Therefore, DAML takes a different approach to upgrades and\n+extensions. Rather than having a separate concept of data migration\n+that sidesteps the fundamental guarantees provided by DAML, *upgrades\n+are expressed as DAML contracts*. This means that the same guarantees\n+and rules that apply to other DAML contracts also apply to upgrades.\n+\n+In a DAML application, it therefore makes sense to think of upgrades\n+as an *extension of an existing application* instead of an operation\n+that replaces exiting contracts with a newer version of those\n+contracts. The existing templates stay on the ledger and can still be\n+used. Contracts of existing templates are not automatically replaced\n+by newer versions. However, the application is extended with new\n+templates and if all signatories of a contract agree, a choice can\n+archive the old version of a contract and create a new contract\n+instead.\n+\n+Structuring upgrade contracts\n+=============================\n+\n+Upgrade contracts are specific to the templates that are being\n+upgraded. However, there are common patterns between most of them. We\n+use the example of a simple *Coin* template as an example here.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A *Coin* has an issuer and an owner and both are signatories.  Our\n+goal is to extend this *Coin* template with a field that represents\n+the number of coins to avoid needing 1000 contracts to represent 1000\n+coins. (In a real application, you would also want choices for merging\n+and splitting such a *Coin*. For presentational purposes, we omit\n+those here.) We use a different name for the new template here. This\n+is not required as templates are identified by the triple\n+``(PackageId, ModuleName, TemplateName)`` but here we omit package ids\n+and module names for presentational purposes.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_AMOUNT_BEGIN\n+  :end-before: -- COIN_AMOUNT_END\n+\n+Now, that we defined our new template, we need to provide a way for\n+the signatories issuer and owner to agree to a contract being\n+upgraded. It would be possible to structure this such that issuer and\n+owner have to agree to an upgrade for each *Coin* contract\n+separately. However, since the template definition for those is all"
  },
  {
    "id" : "02e2776e-da84-4544-84c7-2d11965dce35",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "468fb19f-37cd-417d-a642-1a5d11fe2280",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The word \"accept\" is a bit overloaded here. We also need to make it clear that we pass the contract by reference not by value.\r\n```suggestion\r\nhas one *nonconsuming* choice that takes the contract ID of a *Coin* contract, archives\r\n```",
        "createdAt" : "2020-03-04T14:03:40Z",
        "updatedAt" : "2020-03-04T14:05:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 81,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided\n+by DAML.\n+\n+Therefore, DAML takes a different approach to upgrades and\n+extensions. Rather than having a separate concept of data migration\n+that sidesteps the fundamental guarantees provided by DAML, *upgrades\n+are expressed as DAML contracts*. This means that the same guarantees\n+and rules that apply to other DAML contracts also apply to upgrades.\n+\n+In a DAML application, it therefore makes sense to think of upgrades\n+as an *extension of an existing application* instead of an operation\n+that replaces exiting contracts with a newer version of those\n+contracts. The existing templates stay on the ledger and can still be\n+used. Contracts of existing templates are not automatically replaced\n+by newer versions. However, the application is extended with new\n+templates and if all signatories of a contract agree, a choice can\n+archive the old version of a contract and create a new contract\n+instead.\n+\n+Structuring upgrade contracts\n+=============================\n+\n+Upgrade contracts are specific to the templates that are being\n+upgraded. However, there are common patterns between most of them. We\n+use the example of a simple *Coin* template as an example here.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A *Coin* has an issuer and an owner and both are signatories.  Our\n+goal is to extend this *Coin* template with a field that represents\n+the number of coins to avoid needing 1000 contracts to represent 1000\n+coins. (In a real application, you would also want choices for merging\n+and splitting such a *Coin*. For presentational purposes, we omit\n+those here.) We use a different name for the new template here. This\n+is not required as templates are identified by the triple\n+``(PackageId, ModuleName, TemplateName)`` but here we omit package ids\n+and module names for presentational purposes.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_AMOUNT_BEGIN\n+  :end-before: -- COIN_AMOUNT_END\n+\n+Now, that we defined our new template, we need to provide a way for\n+the signatories issuer and owner to agree to a contract being\n+upgraded. It would be possible to structure this such that issuer and\n+owner have to agree to an upgrade for each *Coin* contract\n+separately. However, since the template definition for those is all\n+the same, this is usually not necessary for most\n+applications. Instead, we collect agreement from the signatories only\n+once and use that to upgrade all coins. Since there are multiple\n+signatories involved here, we use a :ref:`Propose-Accept workflow\n+<intro propose accept>`. First, we define an *UpgradeCoinProposal*\n+template that will be created by the issuer. This template has an\n+*Accept* choice that the *owner* can exercise which will then create\n+an *UpgradeCoinAgreement*.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_PROPOSAL_BEGIN\n+  :end-before: -- UPGRADE_PROPOSAL_END\n+\n+Now we can define the *UpgradeCoinAgreement* template. This template\n+has one *nonconsuming* choice that accepts a *Coin* contract, archives"
  },
  {
    "id" : "0066ffd6-c8a7-4c55-b54f-87f018a5eceb",
    "prId" : 4750,
    "comments" : [
      {
        "id" : "06a31e90-784e-466e-b4bf-d1eed29b4d99",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nthe same issuer and owner and the *amount* set to 1.\r\n```",
        "createdAt" : "2020-03-04T14:05:05Z",
        "updatedAt" : "2020-03-04T14:05:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "640b866ae4363332d8f87196545558db2d66a968",
    "line" : 83,
    "diffHunk" : "@@ -0,0 +1,94 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Upgrading and extending DAML applications\n+#########################################\n+\n+In applications backed by a centralized database controlled by a\n+single operator, it is possible to upgrade an application in a single\n+step that migrates all existing data to a new data model.\n+\n+However, in a DAML application running on a distributed ledger, the\n+signatories of a contract have agreed to one specific version of a\n+template. Changing the definition of a template, e.g., by extending it\n+with a new choice without agreement from signatories of contracts of\n+that template would completely break the authority guarantees provided\n+by DAML.\n+\n+Therefore, DAML takes a different approach to upgrades and\n+extensions. Rather than having a separate concept of data migration\n+that sidesteps the fundamental guarantees provided by DAML, *upgrades\n+are expressed as DAML contracts*. This means that the same guarantees\n+and rules that apply to other DAML contracts also apply to upgrades.\n+\n+In a DAML application, it therefore makes sense to think of upgrades\n+as an *extension of an existing application* instead of an operation\n+that replaces exiting contracts with a newer version of those\n+contracts. The existing templates stay on the ledger and can still be\n+used. Contracts of existing templates are not automatically replaced\n+by newer versions. However, the application is extended with new\n+templates and if all signatories of a contract agree, a choice can\n+archive the old version of a contract and create a new contract\n+instead.\n+\n+Structuring upgrade contracts\n+=============================\n+\n+Upgrade contracts are specific to the templates that are being\n+upgraded. However, there are common patterns between most of them. We\n+use the example of a simple *Coin* template as an example here.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_BEGIN\n+  :end-before: -- COIN_END\n+\n+A *Coin* has an issuer and an owner and both are signatories.  Our\n+goal is to extend this *Coin* template with a field that represents\n+the number of coins to avoid needing 1000 contracts to represent 1000\n+coins. (In a real application, you would also want choices for merging\n+and splitting such a *Coin*. For presentational purposes, we omit\n+those here.) We use a different name for the new template here. This\n+is not required as templates are identified by the triple\n+``(PackageId, ModuleName, TemplateName)`` but here we omit package ids\n+and module names for presentational purposes.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- COIN_AMOUNT_BEGIN\n+  :end-before: -- COIN_AMOUNT_END\n+\n+Now, that we defined our new template, we need to provide a way for\n+the signatories issuer and owner to agree to a contract being\n+upgraded. It would be possible to structure this such that issuer and\n+owner have to agree to an upgrade for each *Coin* contract\n+separately. However, since the template definition for those is all\n+the same, this is usually not necessary for most\n+applications. Instead, we collect agreement from the signatories only\n+once and use that to upgrade all coins. Since there are multiple\n+signatories involved here, we use a :ref:`Propose-Accept workflow\n+<intro propose accept>`. First, we define an *UpgradeCoinProposal*\n+template that will be created by the issuer. This template has an\n+*Accept* choice that the *owner* can exercise which will then create\n+an *UpgradeCoinAgreement*.\n+\n+.. literalinclude:: daml/Upgrade.daml\n+  :language: daml\n+  :start-after: -- UPGRADE_PROPOSAL_BEGIN\n+  :end-before: -- UPGRADE_PROPOSAL_END\n+\n+Now we can define the *UpgradeCoinAgreement* template. This template\n+has one *nonconsuming* choice that accepts a *Coin* contract, archives\n+this *Coin* contract and creates a *CoinWithAmount* contract with\n+*amount* set to 1."
  }
]