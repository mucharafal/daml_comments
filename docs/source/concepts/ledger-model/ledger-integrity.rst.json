[
  {
    "id" : "12fee638-3117-4595-ae15-e01475b9622b",
    "prId" : 3509,
    "comments" : [
      {
        "id" : "001be7a0-59d7-4398-8c35-0d65df4ba237",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "\"Ways\" was correct.\r\n\r\n```suggestion\r\neither of the following ways:\r\n```",
        "createdAt" : "2019-11-19T17:05:20Z",
        "updatedAt" : "2019-11-20T09:42:42Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2c1e450b-a673-4517-83a4-e850f727cd4e",
        "parentId" : "001be7a0-59d7-4398-8c35-0d65df4ba237",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Thank you for your input -- changed accordingly.",
        "createdAt" : "2019-11-20T09:43:15Z",
        "updatedAt" : "2019-11-20T09:43:15Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "04a187679d9dc48783dc4667ae0234f9ac48f725",
    "line" : null,
    "diffHunk" : "@@ -410,7 +410,7 @@ agree to this obligation. In other words, the painter did not *authorize*\n the creation of the obligation.\n \n In a DA ledger, a party can **authorize** a subaction of a commit in\n-one of the two ways:\n+either of the following way:"
  },
  {
    "id" : "c6d2ba7f-8767-45ab-a292-40343ab21394",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "c69b0fa4-bc34-4385-a0fa-d6fe61d9713e",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Should this be updated (or the heading it refers to) to \"Ledger Consistency\", so as not to get confused with \"Key Consistency\"?",
        "createdAt" : "2019-07-16T08:20:42Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a342a343-aa73-4602-80ea-3bc70a157280",
        "parentId" : "c69b0fa4-bc34-4385-a0fa-d6fe61d9713e",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Folded the two consistency conditions into one section.",
        "createdAt" : "2019-07-17T11:57:29Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : 3,
    "diffHunk" : "@@ -17,19 +17,22 @@ Valid Ledgers\n At the core is the concept of a *valid ledger*; changes\n are permissible if adding the corresponding commit to the\n ledger results in a valid ledger. **Valid ledgers** are\n-those that fulfill three conditions:\n+those that fulfill four conditions:\n \n :ref:`da-model-consistency`"
  },
  {
    "id" : "cfece211-84b3-4aab-8913-44e297636a97",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "f103ff83-4efd-4db3-90e4-881e46f03fe9",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Is it worth explaining what a maintainer is in terms of what the ledger model expects from them?",
        "createdAt" : "2019-07-16T08:21:54Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a77beef1-4fe7-44b6-bf96-638679e88ba6",
        "parentId" : "f103ff83-4efd-4db3-90e4-881e46f03fe9",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I don't think we should introduce maintainers here. I'd introduce them either:\r\n1. when we first define keys, adding structure to the key type\r\n2. when they first become neeed, which is in the authorization section\r\n\r\nFor signatories and observers, I went with option 2 as it's less of a cognitive overload for the reader, I believe.",
        "createdAt" : "2019-07-16T12:13:40Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7c8c1939-5867-4630-96e4-f209d02bdcf3",
        "parentId" : "f103ff83-4efd-4db3-90e4-881e46f03fe9",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Moved to the authorization section along with an explanation.",
        "createdAt" : "2019-07-17T12:15:56Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key."
  },
  {
    "id" : "a3cf3c11-2321-4999-b470-b4013d040dd7",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "9e8270d6-7301-4cd5-be74-ff2484891b86",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Is it worth mentioning which parties can make key assertions?",
        "createdAt" : "2019-07-16T08:48:09Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract."
  },
  {
    "id" : "6ab0e590-1e80-4241-9aed-63de3800cae4",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "e809546b-042e-4c18-89d5-5c73d6c2da78",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "I don't understand - how can key uniqueness be violated?",
        "createdAt" : "2019-07-16T08:49:33Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f9bedf26-73b3-4222-8de4-2b3bd6f17743",
        "parentId" : "e809546b-042e-4c18-89d5-5c73d6c2da78",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I also don't think you should discuss such violations in the ledger model. We also don't discuss \"regular\" consistency violations in the ledger model. Also, above you're saying that you're \"preserving key uniqueness\". If we need additional concepts in Canton, we can introduce them there.",
        "createdAt" : "2019-07-16T11:53:42Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2da3fe7c-bf3a-4c0a-9884-cdc7dd62e8c1",
        "parentId" : "e809546b-042e-4c18-89d5-5c73d6c2da78",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Removed.",
        "createdAt" : "2019-07-17T12:16:05Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied.\n+Like for internal consistency and input contracts, internal key consistency takes care of transaction-internal conditions and the input key map summarizes the key inexistence constraints at the start of the transaction.\n+\n+Definition »internal key consistency«\n+  A transaction is **internally key consistent** for a key `k` if the following holds:\n+  \n+  - For every **Create** `c` action with key `k`, if there is another **Create** `c'` action with key `k` that precedes the **Create** `c` action,\n+    then there is a consuming **Exercise** action on `c'` between the two **Create** actions.\n+\n+  - For every **NoKey** `k` assertion, if there is a **Create** `c` action with key `k` that precedes the key asssertion,\n+    then there is a consuming **Exercise** action on `c` between the **Create** `c` action and the key assertion.\n+\n+  A transaction is **internally key consistent** if it is internally key consistent for all keys.\n+\n+The input key map associates keys with a set of contracts.\n+The input key map for an internally key consistent transaction encodes a precondition on the ledger under which adding the transaction to the ledger preserves key uniqueness.\n+More precisely, this is the weakest precondition such that the following holds for all subactions of the transaction:\n+\n+ - **Create** actions for a key `k` do not cause a key uniqueness violation for `k`.\n+ - **NoKey** `k` assertions are satisfied.\n+\n+An input key map encodes the following precondition:\n+Every active contract with a key `k` in the domain must be in the set associated with `k`.\n+\n+.. note::\n+  If the ledger satisfies key uniqueness, then there can be at most one contract active for any key.\n+  However, if key uniqueness is violated for a key, then there may be multiple active contracts with the given key."
  },
  {
    "id" : "7da6bca4-255a-469c-8544-4e0169ae7925",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "2160a37c-2325-495b-a1f5-4262749dd160",
        "parentId" : null,
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "I'm sorry, I don't understand this section at all, but it might just be me being dense. I don't get what the consequences of this are for users.\r\n\r\nI'm not quite sure how to suggest to improve it - maybe it's worth getting someone else to read it and see if they understand?",
        "createdAt" : "2019-07-16T08:51:04Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0d5b1835-7eff-4b7b-b74d-170649a87f2d",
        "parentId" : "2160a37c-2325-495b-a1f5-4262749dd160",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Completely rewritten.",
        "createdAt" : "2019-07-17T12:16:15Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied.\n+Like for internal consistency and input contracts, internal key consistency takes care of transaction-internal conditions and the input key map summarizes the key inexistence constraints at the start of the transaction.\n+\n+Definition »internal key consistency«\n+  A transaction is **internally key consistent** for a key `k` if the following holds:\n+  \n+  - For every **Create** `c` action with key `k`, if there is another **Create** `c'` action with key `k` that precedes the **Create** `c` action,\n+    then there is a consuming **Exercise** action on `c'` between the two **Create** actions.\n+\n+  - For every **NoKey** `k` assertion, if there is a **Create** `c` action with key `k` that precedes the key asssertion,\n+    then there is a consuming **Exercise** action on `c` between the **Create** `c` action and the key assertion.\n+\n+  A transaction is **internally key consistent** if it is internally key consistent for all keys.\n+\n+The input key map associates keys with a set of contracts.\n+The input key map for an internally key consistent transaction encodes a precondition on the ledger under which adding the transaction to the ledger preserves key uniqueness.\n+More precisely, this is the weakest precondition such that the following holds for all subactions of the transaction:\n+\n+ - **Create** actions for a key `k` do not cause a key uniqueness violation for `k`.\n+ - **NoKey** `k` assertions are satisfied.\n+\n+An input key map encodes the following precondition:\n+Every active contract with a key `k` in the domain must be in the set associated with `k`.\n+\n+.. note::\n+  If the ledger satisfies key uniqueness, then there can be at most one contract active for any key.\n+  However, if key uniqueness is violated for a key, then there may be multiple active contracts with the given key.\n+  Associating a set of contracts to a key takes care of this corner case.\n+\n+Definition »input key map«"
  },
  {
    "id" : "ca5753f4-d47a-4901-ac5f-480ab0c3c197",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "e64f4d78-14be-437f-8e51-c7049922589d",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I don't understand why you chose to make this a separate condition - I'd just add key consistency as another part of the ledger consistency definition, as the key consistency definition requires the same ordering on actions as the \"regular\" consistency does, and also constrains where a `Create` can appear.",
        "createdAt" : "2019-07-16T09:53:33Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8f50ac0f-ca96-4bf4-a09e-3bfed4a489ab",
        "parentId" : "e64f4d78-14be-437f-8e51-c7049922589d",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "+1",
        "createdAt" : "2019-07-17T07:13:39Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9680a968-5274-421c-b586-f542c88a0079",
        "parentId" : "e64f4d78-14be-437f-8e51-c7049922589d",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Merged the two sections.",
        "createdAt" : "2019-07-17T12:16:27Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -17,19 +17,22 @@ Valid Ledgers\n At the core is the concept of a *valid ledger*; changes\n are permissible if adding the corresponding commit to the\n ledger results in a valid ledger. **Valid ledgers** are\n-those that fulfill three conditions:\n+those that fulfill four conditions:\n \n :ref:`da-model-consistency`\n-   Exercises on inactive contracts are not allowed, i.e.\n+   Exercises and fetches on inactive contracts are not allowed, i.e.\n    contracts that have not yet been created or have already been\n    consumed by an exercise.\n :ref:`da-model-conformance`\n    Only a restricted set of actions is allowed on a given contract.\n+:ref:`da-model-key-consistency`"
  },
  {
    "id" : "c1860bef-7a59-456a-80ad-250b43ed2b9f",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "ef6e43aa-7d94-45eb-8e9d-1181f1755124",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "This example reads odd in isolation, because you now have `NoKey` instead of `LookupByKey` - I don't think that the link to `NoKey` is clear any more. You could use something like a phone operator ensuring that it's handing out a unique phone number or somesuch.",
        "createdAt" : "2019-07-16T11:39:29Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "28a01766-3e10-46aa-8098-690522219f38",
        "parentId" : "ef6e43aa-7d94-45eb-8e9d-1181f1755124",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "The problem with \"handing out anything unique\", be it accounts or phone numbers, is that those typically entail the creation of a contract with the unique thing as the key. But then, you don't need a `NoKey` assertions because that's baked into the `Create`.",
        "createdAt" : "2019-07-16T16:09:33Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bbccf018-87f3-47e8-b386-2319d04d5a0a",
        "parentId" : "ef6e43aa-7d94-45eb-8e9d-1181f1755124",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "As discussed, changed to blacklisted customers.",
        "createdAt" : "2019-07-17T12:16:48Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger."
  },
  {
    "id" : "db295f9a-f0ba-4d41-b4d2-cb501f5736e6",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "e7c5f0d3-2090-4069-943f-4c663a854be6",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Nitpick: `k` is not the key of the action, but the key of the contract.",
        "createdAt" : "2019-07-16T11:41:55Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8f69b00e-426e-432c-8eee-f44ae90344c2",
        "parentId" : "e7c5f0d3-2090-4069-943f-4c663a854be6",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Rephrased.",
        "createdAt" : "2019-07-17T07:24:33Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied.\n+Like for internal consistency and input contracts, internal key consistency takes care of transaction-internal conditions and the input key map summarizes the key inexistence constraints at the start of the transaction.\n+\n+Definition »internal key consistency«\n+  A transaction is **internally key consistent** for a key `k` if the following holds:\n+  \n+  - For every **Create** `c` action with key `k`, if there is another **Create** `c'` action with key `k` that precedes the **Create** `c` action,"
  },
  {
    "id" : "90f938e1-a27a-4ce3-a692-7a98477af8c9",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "85faa4b3-ebea-4cde-979c-6964f338a756",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "For uniformity, we could extend the input contract set (for contracts with no keys) with an analogous concept that also captures inexistence constraints. Though this is not that useful in Canton etc, because the protocol ensures that the contracts in a newly added transaction all get fresh IDs.",
        "createdAt" : "2019-07-16T11:49:26Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "132fb0e8-a0fd-4f96-a7e4-c5615d6b3400",
        "parentId" : "85faa4b3-ebea-4cde-979c-6964f338a756",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I wouldn't do that. We essentially treat contract IDs as bound names that can be alpha-renamed. So a create always picks a fresh id. But for keys, it's different; they intentionally cannot be alpha-renamed.",
        "createdAt" : "2019-07-17T07:25:46Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied."
  },
  {
    "id" : "c46b2bfc-8a73-499a-aa6a-f19dfcc98a44",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "4e4f2deb-59f3-4732-a145-1f62aace0dbf",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "The map's domain is actually a `Maybe Contract`; alternatively, restrict it to sets that are empty or singletons. Actually I think my favorite would be to just split the map into a set of contract IDs and a set of keys instead.",
        "createdAt" : "2019-07-16T11:51:04Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied.\n+Like for internal consistency and input contracts, internal key consistency takes care of transaction-internal conditions and the input key map summarizes the key inexistence constraints at the start of the transaction.\n+\n+Definition »internal key consistency«\n+  A transaction is **internally key consistent** for a key `k` if the following holds:\n+  \n+  - For every **Create** `c` action with key `k`, if there is another **Create** `c'` action with key `k` that precedes the **Create** `c` action,\n+    then there is a consuming **Exercise** action on `c'` between the two **Create** actions.\n+\n+  - For every **NoKey** `k` assertion, if there is a **Create** `c` action with key `k` that precedes the key asssertion,\n+    then there is a consuming **Exercise** action on `c` between the **Create** `c` action and the key assertion.\n+\n+  A transaction is **internally key consistent** if it is internally key consistent for all keys.\n+\n+The input key map associates keys with a set of contracts."
  },
  {
    "id" : "17b73758-9444-4e3b-b5e9-7a5be5e07132",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "f6234aba-2d7b-4dfe-9a67-5112b3f22996",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "The following don't seem to be outlawed by this definition, but I think they should be: \r\n1. a`NoKey k` immediately followed by an `Exercise` on a contract `c` whose key is `k`.\r\n2. two `Exercise` actions on two different contracts with the same key.",
        "createdAt" : "2019-07-16T12:01:17Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied.\n+Like for internal consistency and input contracts, internal key consistency takes care of transaction-internal conditions and the input key map summarizes the key inexistence constraints at the start of the transaction.\n+\n+Definition »internal key consistency«\n+  A transaction is **internally key consistent** for a key `k` if the following holds:"
  },
  {
    "id" : "2f375bf7-0019-4b4a-8b0c-cef3baf9578b",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "4abe5616-8865-4c7b-a298-5a4f95dc12d0",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I don't think that such recovery procedures should go into the ledger model.",
        "createdAt" : "2019-07-16T12:06:11Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "db5afeca-42d5-4c42-9f52-07bfb7f58375",
        "parentId" : "4abe5616-8865-4c7b-a298-5a4f95dc12d0",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Removed.",
        "createdAt" : "2019-07-17T12:17:14Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied.\n+Like for internal consistency and input contracts, internal key consistency takes care of transaction-internal conditions and the input key map summarizes the key inexistence constraints at the start of the transaction.\n+\n+Definition »internal key consistency«\n+  A transaction is **internally key consistent** for a key `k` if the following holds:\n+  \n+  - For every **Create** `c` action with key `k`, if there is another **Create** `c'` action with key `k` that precedes the **Create** `c` action,\n+    then there is a consuming **Exercise** action on `c'` between the two **Create** actions.\n+\n+  - For every **NoKey** `k` assertion, if there is a **Create** `c` action with key `k` that precedes the key asssertion,\n+    then there is a consuming **Exercise** action on `c` between the **Create** `c` action and the key assertion.\n+\n+  A transaction is **internally key consistent** if it is internally key consistent for all keys.\n+\n+The input key map associates keys with a set of contracts.\n+The input key map for an internally key consistent transaction encodes a precondition on the ledger under which adding the transaction to the ledger preserves key uniqueness.\n+More precisely, this is the weakest precondition such that the following holds for all subactions of the transaction:\n+\n+ - **Create** actions for a key `k` do not cause a key uniqueness violation for `k`.\n+ - **NoKey** `k` assertions are satisfied.\n+\n+An input key map encodes the following precondition:\n+Every active contract with a key `k` in the domain must be in the set associated with `k`.\n+\n+.. note::\n+  If the ledger satisfies key uniqueness, then there can be at most one contract active for any key.\n+  However, if key uniqueness is violated for a key, then there may be multiple active contracts with the given key.\n+  Associating a set of contracts to a key takes care of this corner case.\n+\n+Definition »input key map«\n+  The **input key map** of an internally consistent transaction maps a key `k` to a set of contracts as follows:\n+\n+  - The domain of the input key map consists of all keys for which the transaction contains a **Create** `c` action with key `k` or a **NoKey** `k` assertion.\n+    \n+  - A contract `c` is in the set that the input key map associates with `k` in its domain if all of the following hold:\n+    \n+    - The contract `c` has the key `k`.\n+    - The transaction contains a consuming **Exercise** action on `c` before all **Create** actions with key `k` and before all **NoKey** `k` assertions.\n+    - The transaction does not contain a **Create** `c` action.\n+\n+The input key map is defined only for transactions that are internally consistent.\n+All contracts in the range of the input key map are input contracts.\n+\n+If key uniqueness holds for a key, transactions where the input key map associates several contracts with the key cannot be accepted:"
  },
  {
    "id" : "227a1a4c-bf61-4c2c-9d48-e23b4c0041e6",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "cc17142b-103e-49d0-ab6d-af0d0f366a6d",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "The \"before all `NoKey` assertion\" part should be handled by internal consistency. In fact, I'd just derive the input key map from the input contracts.",
        "createdAt" : "2019-07-16T12:15:16Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -226,7 +229,103 @@ becomes apparent.\n `A`'s commit is not conformant to the contract model, as the model does\n not contain the top-level action she is trying to commit.\n \n-.. _`da-model-authorization`:\n+.. _da-model-key-consistency:\n+\n+Key Consistency\n++++++++++++++++\n+\n+Contract keys introduce two validity constraints for ledgers: :ref:`key uniqueness <def-key-uniqueness>` and :ref:`key assertion validity <def-key-assertion-validity>`.\n+To capture these notions, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+Additionally, the model must provide the function `maintainers` that takes a key and returns the non-empty set of maintainers of the key.\n+\n+Key uniqueness ensures that every contract key refers to at most one contract.\n+It ensures that a contract with an associated key can only be created if there is no active contract with the same key.\n+\n+.. _def-key-uniqueness:\n+\n+Definition »key uniqueness«\n+    A ledger is said to satisfy **key uniqueness** for a key `k` if every **Create** action on a contract with associated key `k` happens only when there is no active contract with associated key `k`.\n+\n+    The ledger satisfies **key uniqueness** if it satisfies key uniqueness for all keys.\n+\n+For example, suppose that the painter `P` has made a paint offer to `A` with reference number `P123`, but `A` has not yet accepted it.\n+When `P` tries to create another paint offer to `David` with the same reference number `P123`,\n+then this creation action would violate key uniqueness.\n+The following ledger violates key uniqueness.\n+\n+.. figure:: ./images/double-key-creation-highlighted.svg\n+   :align: center\n+   :name: double-key-creation\n+\n+.. _def-key-assertion-validity:\n+\n+Definition »key assertion validity«\n+  A ledger is said to satisfy **key assertion validity** for a key `k` if and only if at every key assertion **NoKey** `k`, there is no active contract with key `k`.\n+  \n+  The ledger satisfies **key assertion validity** if it satisfies key assertion validity for all keys.\n+\n+Key assertions can be used in workflows to evidence the inexistence of a certain kind of contract.\n+For example, consider a subscription service that operates a support hotline on the ledger.\n+The hotline is free of charge for customers with an active subscription; other customers will be charged via the ledger.\n+The business workflow model requires that every support request is accompanied with a key lookup on the subscription contract;\n+this way, customers can be sure that their support requests will incur fees only if they do not have an active subscription contract.\n+Conversely, the subscription service can be sure that it will charge a fee as soon as a customer cancels his subscription.\n+\n+We also introduce the notions of internal key consistency and input key map.\n+They summarize the inexistence constraints on contracts for a given key such that ensure that **Create** actions do not violate key uniqueness and **NoKey** assertions are satisfied.\n+Like for internal consistency and input contracts, internal key consistency takes care of transaction-internal conditions and the input key map summarizes the key inexistence constraints at the start of the transaction.\n+\n+Definition »internal key consistency«\n+  A transaction is **internally key consistent** for a key `k` if the following holds:\n+  \n+  - For every **Create** `c` action with key `k`, if there is another **Create** `c'` action with key `k` that precedes the **Create** `c` action,\n+    then there is a consuming **Exercise** action on `c'` between the two **Create** actions.\n+\n+  - For every **NoKey** `k` assertion, if there is a **Create** `c` action with key `k` that precedes the key asssertion,\n+    then there is a consuming **Exercise** action on `c` between the **Create** `c` action and the key assertion.\n+\n+  A transaction is **internally key consistent** if it is internally key consistent for all keys.\n+\n+The input key map associates keys with a set of contracts.\n+The input key map for an internally key consistent transaction encodes a precondition on the ledger under which adding the transaction to the ledger preserves key uniqueness.\n+More precisely, this is the weakest precondition such that the following holds for all subactions of the transaction:\n+\n+ - **Create** actions for a key `k` do not cause a key uniqueness violation for `k`.\n+ - **NoKey** `k` assertions are satisfied.\n+\n+An input key map encodes the following precondition:\n+Every active contract with a key `k` in the domain must be in the set associated with `k`.\n+\n+.. note::\n+  If the ledger satisfies key uniqueness, then there can be at most one contract active for any key.\n+  However, if key uniqueness is violated for a key, then there may be multiple active contracts with the given key.\n+  Associating a set of contracts to a key takes care of this corner case.\n+\n+Definition »input key map«\n+  The **input key map** of an internally consistent transaction maps a key `k` to a set of contracts as follows:\n+\n+  - The domain of the input key map consists of all keys for which the transaction contains a **Create** `c` action with key `k` or a **NoKey** `k` assertion.\n+    \n+  - A contract `c` is in the set that the input key map associates with `k` in its domain if all of the following hold:\n+    \n+    - The contract `c` has the key `k`.\n+    - The transaction contains a consuming **Exercise** action on `c` before all **Create** actions with key `k` and before all **NoKey** `k` assertions."
  },
  {
    "id" : "d554bd00-6d82-41b6-9d77-ab0cf4689c72",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "2c30c5c9-b3df-4862-a12f-0b6f56ddbbaa",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "If you first define the maintainers here, you don't need to introduce another definition; you can just build it into the definition of a model. Even if you don't, I'd avoid reusing the term \"consistent\".",
        "createdAt" : "2019-07-16T12:16:34Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "75b99430-e170-4b9d-948f-6706c8966d8a",
        "parentId" : "2c30c5c9-b3df-4862-a12f-0b6f56ddbbaa",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-07-17T12:17:27Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -268,23 +367,33 @@ In the example, the contract model specifies that\n    and the `owner` as signatories, with an agreement text requiring\n    the obligor to pay the owner a certain amount, off the ledger.\n \n-#. a `PaintOffer houseOwner painter obligor` contract has only the\n+#. a `PaintOffer houseOwner painter obligor refNo` contract has only the\n    painter as the signatory, with no agreement text.\n \n-#. a `PaintAgree houseOwner painter` contract has both the\n+#. a `PaintAgree houseOwner painter refNo` contract has both the\n    house owner and the painter as signatories, with an agreement\n    text requiring the painter to paint the house.\n \n+The contract model must meet the following property:\n+\n+Definition »maintainer-signatory consistency«"
  },
  {
    "id" : "8a4492cb-5353-4e90-aa10-8c554b4a3063",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "38f9de32-0f81-46c7-ae4b-b013cc13c340",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "You can simplify the example if you remove the key value in the paint agreement (i.e., you turn the key into `(P, A)`). Then you don't need the story about guesses, and the competitor can learn something directly from the ledger, so you don't have to talk about the implementation.",
        "createdAt" : "2019-07-16T12:24:27Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1afcd671-bfca-41a1-bf0d-ceaa733e84d3",
        "parentId" : "38f9de32-0f81-46c7-ae4b-b013cc13c340",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Also, note that we don't have such a rationale here for the authorization rules for `Fetch` actions. ",
        "createdAt" : "2019-07-16T12:31:41Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ffeb177-23a8-4242-9c1b-43a4e4a58fb2",
        "parentId" : "38f9de32-0f81-46c7-ae4b-b013cc13c340",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Regarding `Fetch`: I think it would make sense to have one here. Otherwise the definitions are somewhat arbitrary.",
        "createdAt" : "2019-07-17T07:27:42Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "05e4c206-49a0-403c-b17e-a627b4519914",
        "parentId" : "38f9de32-0f81-46c7-ae4b-b013cc13c340",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "If we set the key to `(P, A)`, then there can always only be a single paint agreement between `P` and `A`. So if Alice has a house and a fence, she can get either the house or the fence painted. I think it's more realistic to have the reference number in the contract.",
        "createdAt" : "2019-07-17T07:28:54Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -396,6 +507,26 @@ to him. However, the actor of this exercise is Alice, who has not\n authorized the exercise. Thus, this ledger is not\n well-authorized.\n \n+Setting the maintainers as required authorizers for a **NoKey** assertion ensures\n+that parties cannot learn about the existence of a contract without having a right to know about their existence.\n+So we use authorization to impose *access controls* that ensure confidentiality about the existence of contracts.\n+For example, suppose now that for a `PaintAgreement` contract, both signatories are key maintainers, not only the painter.\n+That is, we consider `PaintAgreement @A @P &P123` instead of `PaintAgreement $A @P &P123`.\n+Then, when the painter's competitor `Q` passes by `A`'s house and sees that the house desperately needs painting,\n+`Q` would like to know whether there is any point in spending marketing efforts and making a paint offer to `A`.\n+Without key authorization, `Q` could test whether a ledger implementation accepts the action **NoKey** `(A, P, refNo)` for different guesses of the reference number `refNo`."
  },
  {
    "id" : "c367551e-9cd1-4ad0-800e-5cde1c2f3351",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "675b568b-8799-4b6e-9073-558fe997cf96",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "What does \"without a contract\" mean here? Left over from `LookupByKey`?",
        "createdAt" : "2019-07-16T12:28:06Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1efdfeaf-2cf9-4c57-862f-6d2c327e1bfd",
        "parentId" : "675b568b-8799-4b6e-9073-558fe997cf96",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Good catch. That's a left over. Deleted.",
        "createdAt" : "2019-07-17T07:29:40Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -396,6 +507,26 @@ to him. However, the actor of this exercise is Alice, who has not\n authorized the exercise. Thus, this ledger is not\n well-authorized.\n \n+Setting the maintainers as required authorizers for a **NoKey** assertion ensures\n+that parties cannot learn about the existence of a contract without having a right to know about their existence.\n+So we use authorization to impose *access controls* that ensure confidentiality about the existence of contracts.\n+For example, suppose now that for a `PaintAgreement` contract, both signatories are key maintainers, not only the painter.\n+That is, we consider `PaintAgreement @A @P &P123` instead of `PaintAgreement $A @P &P123`.\n+Then, when the painter's competitor `Q` passes by `A`'s house and sees that the house desperately needs painting,\n+`Q` would like to know whether there is any point in spending marketing efforts and making a paint offer to `A`.\n+Without key authorization, `Q` could test whether a ledger implementation accepts the action **NoKey** `(A, P, refNo)` for different guesses of the reference number `refNo`.\n+In particular, if the ledger does not accept the transaction for some `refNo`, then `Q` knows that `P` has some business with `A` and his chances of `A` accepting his offer are lower.\n+Key authorization prevents this flow of information because the ledger always rejects `Q`\\ 's action for violating the authorization rules.\n+\n+For these access controls, it suffices if one maintainer authorizes a **NoKey** assertion.\n+However, we demand that *all* maintainers must authorize it.\n+This is to prevent a denial of service attack vector.\n+If only one maintainer sufficed to authorize a key assertion,\n+then a malicious party `p` could submit a command resulting in a key assertion **NoKey** `k` without a contract as the only action."
  },
  {
    "id" : "8ae3cdd5-9c18-45ab-bd08-2c853a4c52fb",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "9eeb3ed4-5365-40f9-96aa-25f9ae842208",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I don't think this description helps someone reading the document; there's nothing about validation, denial of service etc. anywhere else in the document. In a centralized ledger, it's also not true that single parties would be under attack during validation.\r\n\r\nDisregarding that, I also don't really follow the argument. From what I remember, the problem that you raised was that you can just submit `NoKey (PaintAgreement Andreas Trump)` and Trump has to validate it even though he has no clue who you are. I can't really make the connection to the description here.\r\n\r\nOne idea how to resolve these problems: don't discuss the motivation for the `NoKey` authorization rules here, but  discuss them in the privacy/projections section (maybe just make a remark that they help protect privacy). Then you can say how they:\r\n1. help protect privacy, by requiring authorization on both positive and negative statements about contract existence\r\n2. help keep the parties' projections free from spam (thanks to the \"all maintainers must authorize\" rule). There reason for the asymmetry between `Fetch` and `NoKey` should then become clear, and it should also become clear that there is less to process.",
        "createdAt" : "2019-07-16T12:52:44Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4e56ef31-7de5-4517-96a4-a51712a49183",
        "parentId" : "9eeb3ed4-5365-40f9-96aa-25f9ae842208",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Rephrased.",
        "createdAt" : "2019-07-17T12:17:49Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -396,6 +507,26 @@ to him. However, the actor of this exercise is Alice, who has not\n authorized the exercise. Thus, this ledger is not\n well-authorized.\n \n+Setting the maintainers as required authorizers for a **NoKey** assertion ensures\n+that parties cannot learn about the existence of a contract without having a right to know about their existence.\n+So we use authorization to impose *access controls* that ensure confidentiality about the existence of contracts.\n+For example, suppose now that for a `PaintAgreement` contract, both signatories are key maintainers, not only the painter.\n+That is, we consider `PaintAgreement @A @P &P123` instead of `PaintAgreement $A @P &P123`.\n+Then, when the painter's competitor `Q` passes by `A`'s house and sees that the house desperately needs painting,\n+`Q` would like to know whether there is any point in spending marketing efforts and making a paint offer to `A`.\n+Without key authorization, `Q` could test whether a ledger implementation accepts the action **NoKey** `(A, P, refNo)` for different guesses of the reference number `refNo`.\n+In particular, if the ledger does not accept the transaction for some `refNo`, then `Q` knows that `P` has some business with `A` and his chances of `A` accepting his offer are lower.\n+Key authorization prevents this flow of information because the ledger always rejects `Q`\\ 's action for violating the authorization rules.\n+\n+For these access controls, it suffices if one maintainer authorizes a **NoKey** assertion.\n+However, we demand that *all* maintainers must authorize it.\n+This is to prevent a denial of service attack vector.\n+If only one maintainer sufficed to authorize a key assertion,\n+then a malicious party `p` could submit a command resulting in a key assertion **NoKey** `k` without a contract as the only action.\n+The set `maintainers(k)` includes, in addition to `p` itself, the parties under attack.\n+If the parties in `maintainers(k)` want to comply to the Ledger Model, then they must validate that there indeed is no such contract, which may require a non-trivial effort."
  },
  {
    "id" : "e73b4f1b-71ca-4cdd-99cd-e3ada09f7876",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "0f3ccedd-4e75-48f9-a795-dac1fd4797cc",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Internal is undefined at this point; also, \"activeness consistency\" is not defined anywhere (it appears also lower in the text)",
        "createdAt" : "2019-07-17T15:25:56Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "33170981-b950-40d1-8495-f28bf8b1c916",
        "parentId" : "0f3ccedd-4e75-48f9-a795-dac1fd4797cc",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Good catch. Removed \"internal\" and \"activeness\".",
        "createdAt" : "2019-07-18T06:50:30Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : null,
    "diffHunk" : "@@ -55,26 +61,148 @@ below depicts the resulting order on the paint offer example:\n In the image, an action `act` happens before action `act'` if there is\n a (non-empty) path from `act` to `act'`.\n Then, `act'` happens after `act`.\n-A ledger is **consistent for a contract c** if all of the following holds for all actions `act` on `c`:\n \n-#. either `act` is itself **Create c** or a **Create c** happens before `act`\n-#. `act` does not happen before any **Create c** action\n-#. `act` does not happen after any exercise consuming `c`.\n+.. _da-model-contract-consistency:\n+\n+Contract consistency\n+````````````````````\n+\n+Contract consistency ensures that contracts are used after they have been created and before they are consumed.\n+\n+.. _def-contract-consistency:\n+\n+Definition »contract consistency«\n+  A ledger is **consistent for a contract c** if all of the following holds for all actions `act` on `c`:\n+\n+  #. either `act` is itself **Create c** or a **Create c** happens before `act`\n+  #. `act` does not happen before any **Create c** action\n+  #. `act` does not happen after any exercise consuming `c`.\n \n-A ledger is **consistent** if it is consistent for all contracts.\n \n The consistency condition rules out the double spend example.\n As the red path below indicates, the second exercise in the example happens after a consuming exercise on the same\n-contract, violating the consistency criteria.\n+contract, violating the contract consistency criteria.\n \n .. https://www.lucidchart.com/documents/edit/c6113536-70f4-42a4-920d-3c9497f8f7c4\n .. image:: ./images/consistency-banning-double-spends.svg\n    :align: center\n    :width: 100%\n \n+\n+.. _def-contract-state:\n+\n+In addition to the consistency notions, the before-after relation on actions can also be used to define the notion of\n+**contract state** at any point in a given transaction.\n+The contract state is changed by creating the contract and by exercising it consumingly.\n+At any point in a transaction, we can then define the latest state change in the obvious way.\n+Then, given a point in a transaction, the contract state of `c` is:\n+\n+#. **active**, if the latest state change of `c` was a create;\n+\n+#. **archived**, if the latest state change of `c` was a consuming exercise;\n+\n+#. **inexistent**, if `c` never changed state.\n+\n+A ledger is consistent for `c` exactly if **Exercise** and **Fetch** actions on `c` happen only when `c` is active,\n+and **Create** actions only when `c` is inexistent.\n+The figures below visualize the state of different contracts at all points in the example ledger.\n+\n+.. https://www.lucidchart.com/documents/edit/19226d95-e8ba-423a-8546-e5bae6bd3ab7\n+.. figure:: ./images/consistency-paint-offer-activeness.svg\n+   :align: center\n+   :width: 100%\n+\n+   Activeness of the `PaintOffer` contract\n+\n+.. https://www.lucidchart.com/documents/edit/19226d95-e8ba-423a-8546-e5bae6bd3ab7\n+.. figure:: ./images/consistency-alice-iou-activeness.svg\n+   :align: center\n+   :width: 100%\n+\n+   Activeness of the `Iou Bank A` contract\n+\n+The notion of order can be defined on all the different ledger structures: actions, transactions, lists of transactions,\n+and ledgers.\n+Thus, the notions of (internal) activeness consistency, inputs and outputs, and contract state can also all be defined on all these"
  },
  {
    "id" : "4c563f06-30ee-4460-b5eb-8413729c99c2",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "08836118-132b-4ef1-afc8-3dc14307e0dd",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Please make a note that this definition can be also be defined on actions, transactions and lists of transactions.",
        "createdAt" : "2019-07-17T15:29:01Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7739726d-b877-4305-8451-533675f31b0e",
        "parentId" : "08836118-132b-4ef1-afc8-3dc14307e0dd",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Added a sentence at the end of the subsection.",
        "createdAt" : "2019-07-18T06:52:49Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : 147,
    "diffHunk" : "@@ -55,26 +61,148 @@ below depicts the resulting order on the paint offer example:\n In the image, an action `act` happens before action `act'` if there is\n a (non-empty) path from `act` to `act'`.\n Then, `act'` happens after `act`.\n-A ledger is **consistent for a contract c** if all of the following holds for all actions `act` on `c`:\n \n-#. either `act` is itself **Create c** or a **Create c** happens before `act`\n-#. `act` does not happen before any **Create c** action\n-#. `act` does not happen after any exercise consuming `c`.\n+.. _da-model-contract-consistency:\n+\n+Contract consistency\n+````````````````````\n+\n+Contract consistency ensures that contracts are used after they have been created and before they are consumed.\n+\n+.. _def-contract-consistency:\n+\n+Definition »contract consistency«\n+  A ledger is **consistent for a contract c** if all of the following holds for all actions `act` on `c`:\n+\n+  #. either `act` is itself **Create c** or a **Create c** happens before `act`\n+  #. `act` does not happen before any **Create c** action\n+  #. `act` does not happen after any exercise consuming `c`.\n \n-A ledger is **consistent** if it is consistent for all contracts.\n \n The consistency condition rules out the double spend example.\n As the red path below indicates, the second exercise in the example happens after a consuming exercise on the same\n-contract, violating the consistency criteria.\n+contract, violating the contract consistency criteria.\n \n .. https://www.lucidchart.com/documents/edit/c6113536-70f4-42a4-920d-3c9497f8f7c4\n .. image:: ./images/consistency-banning-double-spends.svg\n    :align: center\n    :width: 100%\n \n+\n+.. _def-contract-state:\n+\n+In addition to the consistency notions, the before-after relation on actions can also be used to define the notion of\n+**contract state** at any point in a given transaction.\n+The contract state is changed by creating the contract and by exercising it consumingly.\n+At any point in a transaction, we can then define the latest state change in the obvious way.\n+Then, given a point in a transaction, the contract state of `c` is:\n+\n+#. **active**, if the latest state change of `c` was a create;\n+\n+#. **archived**, if the latest state change of `c` was a consuming exercise;\n+\n+#. **inexistent**, if `c` never changed state.\n+\n+A ledger is consistent for `c` exactly if **Exercise** and **Fetch** actions on `c` happen only when `c` is active,\n+and **Create** actions only when `c` is inexistent.\n+The figures below visualize the state of different contracts at all points in the example ledger.\n+\n+.. https://www.lucidchart.com/documents/edit/19226d95-e8ba-423a-8546-e5bae6bd3ab7\n+.. figure:: ./images/consistency-paint-offer-activeness.svg\n+   :align: center\n+   :width: 100%\n+\n+   Activeness of the `PaintOffer` contract\n+\n+.. https://www.lucidchart.com/documents/edit/19226d95-e8ba-423a-8546-e5bae6bd3ab7\n+.. figure:: ./images/consistency-alice-iou-activeness.svg\n+   :align: center\n+   :width: 100%\n+\n+   Activeness of the `Iou Bank A` contract\n+\n+The notion of order can be defined on all the different ledger structures: actions, transactions, lists of transactions,\n+and ledgers.\n+Thus, the notions of (internal) activeness consistency, inputs and outputs, and contract state can also all be defined on all these\n+structures.\n+The **active contract set** of a ledger is the set of all contracts\n+that are active on the ledger. For the example above, it consists\n+of contracts `Iou Bank P` and `PaintAgree P A`.\n+\n+.. _da-model-key-consistency:\n+\n+Key consistency\n+```````````````\n+\n+Contract keys introduce a key uniqueness constraint for the ledger.\n+To capture this notion, the contract model must specify for every contract in the system whether the contract has a key and, if so, the key.\n+Every contract can have at most one key.\n+\n+Like contracts, every key has a state.\n+An action `act` is an **action on a key** `k` if \n+\n+- `act` is a **Create**, **Exercise**, or a **Fetch** action on a contract `c` with key `k`, or\n+- `act` is the key assertion **NoSuchKey** `k`.\n+\n+.. _def-key-state:\n+  \n+Definition »key state«\n+  The **key state** of a key on a ledger is determined by the last action `act` on the key:\n+\n+  - If `act` is a **Create**, non-consuming **Exercise**, or **Fetch** action on a contract `c`,\n+    then the key state is **assigned** to `c`.\n+\n+  - If `act` is a consuming **Exercise** action or a **NoSuchKey** assertion,\n+    then the key state is **free**.\n+\n+  - If there is no such action `act`, then the key state is **unknown**.\n+\n+Key consistency ensures that there is at most one active contract for each key and that all key assertions are satisfies.\n+\n+.. _def-key-consistency:\n+\n+Definition »key consistency«"
  },
  {
    "id" : "809fba4c-968a-4768-a838-a36bc8cc0594",
    "prId" : 2144,
    "comments" : [
      {
        "id" : "bf7f8602-8bd3-46f5-a89d-30476c9e82b1",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "They can also be unknown",
        "createdAt" : "2019-07-17T15:33:08Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b94c37ae-0cae-4544-856b-85c7e5951c95",
        "parentId" : "bf7f8602-8bd3-46f5-a89d-30476c9e82b1",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "That's precisely what I meant with unassigned (=free or unknown). Added a definition.",
        "createdAt" : "2019-07-18T06:54:54Z",
        "updatedAt" : "2019-07-18T11:17:48Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e90b0e8f28fd617f20f5dbb53ae00f5106fdf862",
    "line" : 236,
    "diffHunk" : "@@ -122,51 +249,18 @@ and inconsistent transactions.\n    :align: center\n    :width: 100%\n \n-   The first two transactions violate the conditions of internally consistency.\n+   The first two transactions violate the conditions of internal activeness consistency.\n    The first transaction creates the `Iou` after exercising it consumingly, violating both conditions.\n    The second transaction contains a (non-consuming) exercise on the `Iou` after a consuming one, violating the second condition.\n    The last transaction is internally consistent.\n \n-.. _def-contract-state:\n-\n-In addition to the consistency notions, the before-after relation on actions can also be used to define the notion of\n-**contract state** at any point in a given transaction.\n-The contract state is changed by creating the contract and by exercising it consumingly.\n-At any point in a transaction, we can then define the latest state change in the obvious way.\n-Then, given a point in a transaction, the contract state of `c` is:\n-\n-#. **active**, if the latest state change of `c` was a create;\n-\n-#. **archived**, if the latest state change of `c` was a consuming exercise was;\n-\n-#. **inexistent**, if `c` never changed state.\n-\n-A ledger is consistent for `c` exactly if **Exercise** and **Fetch** actions on `c` happen only when `c` is active, and **Create**\n-actions only when `c` is inexistent.\n-The figures below visualize the state of different contracts at all points in the example ledger.\n-\n-.. https://www.lucidchart.com/documents/edit/19226d95-e8ba-423a-8546-e5bae6bd3ab7\n-.. figure:: ./images/consistency-paint-offer-activeness.svg\n-   :align: center\n-   :width: 100%\n+Similar to input contracts, we define the input keys as the set that must be unassigned at the beginning of a transaction."
  }
]