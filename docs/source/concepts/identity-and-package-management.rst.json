[
  {
    "id" : "2f6e7c06-bcb2-4e08-8ff1-9cdf63756325",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "3fbbae54-96b8-4f71-819e-889eef535d2f",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Don't think you need to introduce DAML at this point.",
        "createdAt" : "2019-08-15T09:30:23Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47277717-dc26-41b8-a485-76e03ec74e2a",
        "parentId" : "3fbbae54-96b8-4f71-819e-889eef535d2f",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "True - just needed an overture for why we need identity and package management. Rephrased",
        "createdAt" : "2019-08-16T10:26:52Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code."
  },
  {
    "id" : "5de95f49-0bc9-4c27-bdc9-38964de66f0a",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "2e90fc7d-41a4-41c9-87b9-8c10e43d0a00",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Is this true in a Canton world?\r\nIf I have two parties with the same identifier in two un-connected Canon domains, this would suggest they are different parties. However, as soon as these domains somehow get connected, even if through several domain-hops, they are the same? Or do you consider all Canton domains in the world to be part of one partitioned leder?",
        "createdAt" : "2019-08-15T09:41:14Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e89d11bd-3412-4ea9-9c70-7068b43a730d",
        "parentId" : "2e90fc7d-41a4-41c9-87b9-8c10e43d0a00",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I consider Canton the latter (we call it the \"virtual global ledger\"). I weakened the statement to \"not necessarily\", though, as what I wrote was not true in general.",
        "createdAt" : "2019-08-16T10:58:17Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party."
  },
  {
    "id" : "7cf409c9-9820-42d9-91cc-ae7c35cd9ea7",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "3d285e0e-2947-4543-8578-36dc14159577",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Are \"display names\" defined at ledger-level, domain-level or participant-level?",
        "createdAt" : "2019-08-15T09:43:25Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "859821de-9f72-4057-8b5e-f5e38c29bdb6",
        "parentId" : "3d285e0e-2947-4543-8578-36dc14159577",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "AFAIK, participant level - added.",
        "createdAt" : "2019-08-16T10:58:45Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : 49,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party."
  },
  {
    "id" : "eda738f7-ff52-458d-a43c-b2ebf7f25695",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "55a2aead-7021-40ae-a12f-194559bee5a9",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\nThe ``AllocateParty`` call can take the desired identifier and display name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\r\n```",
        "createdAt" : "2019-08-15T09:44:24Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and displayed name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them."
  },
  {
    "id" : "16850ac0-99fc-4cd2-b94a-002fb0825dd8",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "958eafff-5a74-45fe-a08f-7a8445a7b3b1",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Again, this doesn't make sense to me in a Canton world where ledgers can merge and split.",
        "createdAt" : "2019-08-15T09:46:20Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "261f3c63-536d-4a08-b36b-075bad31a494",
        "parentId" : "958eafff-5a74-45fe-a08f-7a8445a7b3b1",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I'm not sure what issue you're raising here: is the statement too weak, or too strong? \r\n\r\nI don't see any stronger statements we could make: we can only guarantee that the returned identifier is unique within \"the ledger\". I can easily have two Sandbox instances who return the same identifiers when ``AllocateParty`` is called. \r\n\r\nI don't think it's too weak either; I believe it should hold for all ledgers with central operators, and also for Canton. Even when Canton is viewed as a single virtual global ledger, ``AllocateParty`` will never return the same identifier, even when initiated at two participants who are cut off from each other (at least with the current Canton identity management system).",
        "createdAt" : "2019-08-16T12:08:21Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c970522f-a04f-438d-84f8-ea54962d5b3a",
        "parentId" : "958eafff-5a74-45fe-a08f-7a8445a7b3b1",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "After discussing with Bernhard: it's too strong; in Canton we can have two participants that share the same private key, and thus allocate the same party identifiers. I'll rephrase to something weaker.",
        "createdAt" : "2019-08-16T14:05:00Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and displayed name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier."
  },
  {
    "id" : "a4f6bb54-f22e-4ba9-9b32-602b47ad48cf",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "de5e9381-0671-4c75-acf0-1f613fa06e56",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "This seems rather bizarre. We are saying that the deployable unit of code is a `dalf` file with a unique identifier, but to actually deploy it, you must wrap it in an otherwise function-less container.\r\nPlus, both Sandbox and Canton do allow deployment of `dalf` files, don't they?",
        "createdAt" : "2019-08-15T09:52:55Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4ad749bf-7b47-45ff-b0d5-8c138594e253",
        "parentId" : "de5e9381-0671-4c75-acf0-1f613fa06e56",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "They do, but the official API only takes `.dar` files. I added an explanation as to why `.dar`s are still useful.",
        "createdAt" : "2019-08-16T12:09:50Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and displayed name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not.\n+\n+.. _identifiers-and-authentication:\n+\n+Identifiers and Ledger Authentication\n+=====================================\n+\n+To issue commands or receive transactions on behalf of a newly provisioned party, an application must authenticate itself to the party's hosting participant as someone authorized to represent the party.\n+Currently, the Ledger API provides no authentication mechanisms.\n+However, it will soon support authentication through JSON Web Tokens.\n+Before the newly provisioned party can be used, the application will have to obtain a token for this party.\n+The issuance of tokens is specific to each ledger and independent of the Ledger API.\n+The same is true for the policy which the participants use to decide whether to accept a token.\n+\n+.. _identifiers-and-real-world:\n+\n+Identifiers and the Real World\n+==============================\n+\n+The \"substrate\" on which DAML workflows are built are the real-world obligations of the parties in the workflow.\n+To give value to these obligations, they must be connected to parties in the real world.\n+However, the process of linking party identifiers to real-world entities is left to the ledger implementation.\n+\n+A :ref:`global state topology <global-state-topologies>` might simplify the process by trusting the operator of the writer node(s) with providing the link to the real world.\n+For example, if the operator is a stock exchange, it might guarantee that a real-world exchange participant whose legal name is \"Bank Inc.\" is represented by a ledger party with the identifier \"Bank Inc.\".\n+Alternatively, it might use a random identifier, but guarantee that the display name is \"Bank Inc.\".\n+Ledgers with :ref:`partitioned topologies <partitioned-topologies>` in general might not have such a single store of identities.\n+The solutions for linking the identifiers to real-world identities could rely on certificate chains, `verifiable credentials <https://www.w3.org/TR/vc-data-model/>`__, or other mechanisms.\n+\n+Package Management\n+******************\n+\n+All DAML Ledgers implement endpoints that allow for provisioning new DAML code to the ledger.\n+The vetting process for this code, however, depends on the particular ledger implementation and its configuration.\n+The remainder of this section describes the endpoints and general principles behind the vetting process.\n+The details of the process are ledger-dependent.\n+\n+Package Formats and Identifiers\n+===============================\n+\n+Any code -- i.e., DAML templates -- to be uploaded must compiled down to the :ref:`DAML-LF <daml-lf>` language.\n+The unit of packaging for DAML-LF is the :ref:`.dalf <dar-file-dalf-file>` file.\n+Each ``.dalf`` file is uniquely identified by its **package identifier**, which is the hash of its contents.\n+A :ref:`.dar <dar-file-dalf-file>` file is a simple archive containing multiple ``.dalf`` files, and has no identifier of its own.\n+DAML ledgers support uploading only ``.dar`` files."
  },
  {
    "id" : "a96c394c-4036-4463-9538-d48818456005",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "042d9850-ea4f-48e4-9b2d-2b655ce97711",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "Sure, that's possible, but I wouldn't suggest this in our docs.",
        "createdAt" : "2019-08-15T09:55:43Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0b6404d4-214e-43df-8da2-5448029094cf",
        "parentId" : "042d9850-ea4f-48e4-9b2d-2b655ce97711",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Removed",
        "createdAt" : "2019-08-16T12:09:58Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and displayed name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not.\n+\n+.. _identifiers-and-authentication:\n+\n+Identifiers and Ledger Authentication\n+=====================================\n+\n+To issue commands or receive transactions on behalf of a newly provisioned party, an application must authenticate itself to the party's hosting participant as someone authorized to represent the party.\n+Currently, the Ledger API provides no authentication mechanisms.\n+However, it will soon support authentication through JSON Web Tokens.\n+Before the newly provisioned party can be used, the application will have to obtain a token for this party.\n+The issuance of tokens is specific to each ledger and independent of the Ledger API.\n+The same is true for the policy which the participants use to decide whether to accept a token.\n+\n+.. _identifiers-and-real-world:\n+\n+Identifiers and the Real World\n+==============================\n+\n+The \"substrate\" on which DAML workflows are built are the real-world obligations of the parties in the workflow.\n+To give value to these obligations, they must be connected to parties in the real world.\n+However, the process of linking party identifiers to real-world entities is left to the ledger implementation.\n+\n+A :ref:`global state topology <global-state-topologies>` might simplify the process by trusting the operator of the writer node(s) with providing the link to the real world.\n+For example, if the operator is a stock exchange, it might guarantee that a real-world exchange participant whose legal name is \"Bank Inc.\" is represented by a ledger party with the identifier \"Bank Inc.\".\n+Alternatively, it might use a random identifier, but guarantee that the display name is \"Bank Inc.\".\n+Ledgers with :ref:`partitioned topologies <partitioned-topologies>` in general might not have such a single store of identities.\n+The solutions for linking the identifiers to real-world identities could rely on certificate chains, `verifiable credentials <https://www.w3.org/TR/vc-data-model/>`__, or other mechanisms.\n+\n+Package Management\n+******************\n+\n+All DAML Ledgers implement endpoints that allow for provisioning new DAML code to the ledger.\n+The vetting process for this code, however, depends on the particular ledger implementation and its configuration.\n+The remainder of this section describes the endpoints and general principles behind the vetting process.\n+The details of the process are ledger-dependent.\n+\n+Package Formats and Identifiers\n+===============================\n+\n+Any code -- i.e., DAML templates -- to be uploaded must compiled down to the :ref:`DAML-LF <daml-lf>` language.\n+The unit of packaging for DAML-LF is the :ref:`.dalf <dar-file-dalf-file>` file.\n+Each ``.dalf`` file is uniquely identified by its **package identifier**, which is the hash of its contents.\n+A :ref:`.dar <dar-file-dalf-file>` file is a simple archive containing multiple ``.dalf`` files, and has no identifier of its own.\n+DAML ledgers support uploading only ``.dar`` files.\n+\n+Package Management API\n+======================\n+\n+The package management API supports two methods:\n+\n+- ``UploadDarFile`` for uploading ``.dar`` files.\n+  The ledger implementation is, however, free to reject any and all packages and return an error.\n+  Furthermore, even if the method call succeeds, the ledger's vetting process might restrict the usability of the template.\n+  For example, assume that Alice successfully uploads a ``.dar`` file to her participant containing a ``NewTemplate`` template.\n+  It may happen that she can now issue commands that create ``NewTemplate`` instances with Bob as a stakeholder, but that all commands that create ``NewTemplate`` instances with Charlie as a stakeholder fail.\n+\n+- ``ListKnownPackages`` that lists the ``.dalf`` package vetted for usage at the participant node.\n+  Like with the previous method, the usability of the listed templates depends on the ledger's vetting process.\n+\n+\n+Package Vetting\n+===============\n+\n+Using a DAML package entails running its DAML code.\n+The DAML interpreter ensures that the DAML code cannot interact with the environment of the system on which it is executing.\n+However, the operators of the ledger infrastructure nodes may still wish to review and vet any DAML code before allowing it to execute.\n+One reason for this is that the DAML interpreter currently lacks a notion of reproducible resource limits.\n+Thus, executing a DAML contract might result in high memory or CPU usage.\n+Furthermore, security bugs in the DAML interpreter or JVM might enable malicious code to break out of the sandbox."
  },
  {
    "id" : "92a273a1-0610-4643-bba0-dcb6292676d6",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "41880863-1b94-4507-b2fd-42d0f6df9fb1",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\nFor example, in the :ref:`DAML Sandbox <sandbox-manual>`, the vetting is implicit: uploading a package through the Ledger API already vets the package, since it's assumed that only the system administrator has access to these API facilities.\r\n```",
        "createdAt" : "2019-08-15T09:56:42Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and displayed name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not.\n+\n+.. _identifiers-and-authentication:\n+\n+Identifiers and Ledger Authentication\n+=====================================\n+\n+To issue commands or receive transactions on behalf of a newly provisioned party, an application must authenticate itself to the party's hosting participant as someone authorized to represent the party.\n+Currently, the Ledger API provides no authentication mechanisms.\n+However, it will soon support authentication through JSON Web Tokens.\n+Before the newly provisioned party can be used, the application will have to obtain a token for this party.\n+The issuance of tokens is specific to each ledger and independent of the Ledger API.\n+The same is true for the policy which the participants use to decide whether to accept a token.\n+\n+.. _identifiers-and-real-world:\n+\n+Identifiers and the Real World\n+==============================\n+\n+The \"substrate\" on which DAML workflows are built are the real-world obligations of the parties in the workflow.\n+To give value to these obligations, they must be connected to parties in the real world.\n+However, the process of linking party identifiers to real-world entities is left to the ledger implementation.\n+\n+A :ref:`global state topology <global-state-topologies>` might simplify the process by trusting the operator of the writer node(s) with providing the link to the real world.\n+For example, if the operator is a stock exchange, it might guarantee that a real-world exchange participant whose legal name is \"Bank Inc.\" is represented by a ledger party with the identifier \"Bank Inc.\".\n+Alternatively, it might use a random identifier, but guarantee that the display name is \"Bank Inc.\".\n+Ledgers with :ref:`partitioned topologies <partitioned-topologies>` in general might not have such a single store of identities.\n+The solutions for linking the identifiers to real-world identities could rely on certificate chains, `verifiable credentials <https://www.w3.org/TR/vc-data-model/>`__, or other mechanisms.\n+\n+Package Management\n+******************\n+\n+All DAML Ledgers implement endpoints that allow for provisioning new DAML code to the ledger.\n+The vetting process for this code, however, depends on the particular ledger implementation and its configuration.\n+The remainder of this section describes the endpoints and general principles behind the vetting process.\n+The details of the process are ledger-dependent.\n+\n+Package Formats and Identifiers\n+===============================\n+\n+Any code -- i.e., DAML templates -- to be uploaded must compiled down to the :ref:`DAML-LF <daml-lf>` language.\n+The unit of packaging for DAML-LF is the :ref:`.dalf <dar-file-dalf-file>` file.\n+Each ``.dalf`` file is uniquely identified by its **package identifier**, which is the hash of its contents.\n+A :ref:`.dar <dar-file-dalf-file>` file is a simple archive containing multiple ``.dalf`` files, and has no identifier of its own.\n+DAML ledgers support uploading only ``.dar`` files.\n+\n+Package Management API\n+======================\n+\n+The package management API supports two methods:\n+\n+- ``UploadDarFile`` for uploading ``.dar`` files.\n+  The ledger implementation is, however, free to reject any and all packages and return an error.\n+  Furthermore, even if the method call succeeds, the ledger's vetting process might restrict the usability of the template.\n+  For example, assume that Alice successfully uploads a ``.dar`` file to her participant containing a ``NewTemplate`` template.\n+  It may happen that she can now issue commands that create ``NewTemplate`` instances with Bob as a stakeholder, but that all commands that create ``NewTemplate`` instances with Charlie as a stakeholder fail.\n+\n+- ``ListKnownPackages`` that lists the ``.dalf`` package vetted for usage at the participant node.\n+  Like with the previous method, the usability of the listed templates depends on the ledger's vetting process.\n+\n+\n+Package Vetting\n+===============\n+\n+Using a DAML package entails running its DAML code.\n+The DAML interpreter ensures that the DAML code cannot interact with the environment of the system on which it is executing.\n+However, the operators of the ledger infrastructure nodes may still wish to review and vet any DAML code before allowing it to execute.\n+One reason for this is that the DAML interpreter currently lacks a notion of reproducible resource limits.\n+Thus, executing a DAML contract might result in high memory or CPU usage.\n+Furthermore, security bugs in the DAML interpreter or JVM might enable malicious code to break out of the sandbox.\n+\n+Thus, DAML Ledgers generally allow some form of vetting a package before running its code on a node.\n+Not all nodes in a DAML Ledger must vet all packages, as it is possible that some of them will not execute the code.\n+For example, in :ref:`global state topologies <global-state-topologies>`, every :ref:`trust domain <trust-domain>` that controls how commits are appended to the shared ledger must execute DAML code.\n+Thus, the operators of these trust domains will in general be allowed to vet the code before they execute it.\n+The exact vetting mechanism is ledger-dependent.\n+For example, in the :ref:`DAML Sandbox <sandbox-manual>`, the vetting is implicit: uploading a package through the Ledger API already vets the package, since its assumed that only the system administrator has access to these API facilities."
  },
  {
    "id" : "2bd9c4a2-ec64-40a2-97da-00f300ee9356",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "3dc3dde3-299b-4c9e-b35a-7b7a3aaab103",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\nIn `Canton <https://canton.io>`__, participant nodes also only need to vet code for the contracts of the parties they host.\r\n```",
        "createdAt" : "2019-08-15T09:58:02Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and displayed name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not.\n+\n+.. _identifiers-and-authentication:\n+\n+Identifiers and Ledger Authentication\n+=====================================\n+\n+To issue commands or receive transactions on behalf of a newly provisioned party, an application must authenticate itself to the party's hosting participant as someone authorized to represent the party.\n+Currently, the Ledger API provides no authentication mechanisms.\n+However, it will soon support authentication through JSON Web Tokens.\n+Before the newly provisioned party can be used, the application will have to obtain a token for this party.\n+The issuance of tokens is specific to each ledger and independent of the Ledger API.\n+The same is true for the policy which the participants use to decide whether to accept a token.\n+\n+.. _identifiers-and-real-world:\n+\n+Identifiers and the Real World\n+==============================\n+\n+The \"substrate\" on which DAML workflows are built are the real-world obligations of the parties in the workflow.\n+To give value to these obligations, they must be connected to parties in the real world.\n+However, the process of linking party identifiers to real-world entities is left to the ledger implementation.\n+\n+A :ref:`global state topology <global-state-topologies>` might simplify the process by trusting the operator of the writer node(s) with providing the link to the real world.\n+For example, if the operator is a stock exchange, it might guarantee that a real-world exchange participant whose legal name is \"Bank Inc.\" is represented by a ledger party with the identifier \"Bank Inc.\".\n+Alternatively, it might use a random identifier, but guarantee that the display name is \"Bank Inc.\".\n+Ledgers with :ref:`partitioned topologies <partitioned-topologies>` in general might not have such a single store of identities.\n+The solutions for linking the identifiers to real-world identities could rely on certificate chains, `verifiable credentials <https://www.w3.org/TR/vc-data-model/>`__, or other mechanisms.\n+\n+Package Management\n+******************\n+\n+All DAML Ledgers implement endpoints that allow for provisioning new DAML code to the ledger.\n+The vetting process for this code, however, depends on the particular ledger implementation and its configuration.\n+The remainder of this section describes the endpoints and general principles behind the vetting process.\n+The details of the process are ledger-dependent.\n+\n+Package Formats and Identifiers\n+===============================\n+\n+Any code -- i.e., DAML templates -- to be uploaded must compiled down to the :ref:`DAML-LF <daml-lf>` language.\n+The unit of packaging for DAML-LF is the :ref:`.dalf <dar-file-dalf-file>` file.\n+Each ``.dalf`` file is uniquely identified by its **package identifier**, which is the hash of its contents.\n+A :ref:`.dar <dar-file-dalf-file>` file is a simple archive containing multiple ``.dalf`` files, and has no identifier of its own.\n+DAML ledgers support uploading only ``.dar`` files.\n+\n+Package Management API\n+======================\n+\n+The package management API supports two methods:\n+\n+- ``UploadDarFile`` for uploading ``.dar`` files.\n+  The ledger implementation is, however, free to reject any and all packages and return an error.\n+  Furthermore, even if the method call succeeds, the ledger's vetting process might restrict the usability of the template.\n+  For example, assume that Alice successfully uploads a ``.dar`` file to her participant containing a ``NewTemplate`` template.\n+  It may happen that she can now issue commands that create ``NewTemplate`` instances with Bob as a stakeholder, but that all commands that create ``NewTemplate`` instances with Charlie as a stakeholder fail.\n+\n+- ``ListKnownPackages`` that lists the ``.dalf`` package vetted for usage at the participant node.\n+  Like with the previous method, the usability of the listed templates depends on the ledger's vetting process.\n+\n+\n+Package Vetting\n+===============\n+\n+Using a DAML package entails running its DAML code.\n+The DAML interpreter ensures that the DAML code cannot interact with the environment of the system on which it is executing.\n+However, the operators of the ledger infrastructure nodes may still wish to review and vet any DAML code before allowing it to execute.\n+One reason for this is that the DAML interpreter currently lacks a notion of reproducible resource limits.\n+Thus, executing a DAML contract might result in high memory or CPU usage.\n+Furthermore, security bugs in the DAML interpreter or JVM might enable malicious code to break out of the sandbox.\n+\n+Thus, DAML Ledgers generally allow some form of vetting a package before running its code on a node.\n+Not all nodes in a DAML Ledger must vet all packages, as it is possible that some of them will not execute the code.\n+For example, in :ref:`global state topologies <global-state-topologies>`, every :ref:`trust domain <trust-domain>` that controls how commits are appended to the shared ledger must execute DAML code.\n+Thus, the operators of these trust domains will in general be allowed to vet the code before they execute it.\n+The exact vetting mechanism is ledger-dependent.\n+For example, in the :ref:`DAML Sandbox <sandbox-manual>`, the vetting is implicit: uploading a package through the Ledger API already vets the package, since its assumed that only the system administrator has access to these API facilities.\n+In a replicated ledger, the vetting might require consent from all or a quorum of replicas.\n+The vetting process can be manual, where an administrator inspects each package, or it can be automated, for example, by accepting only packages with a digital signature from a trusted package issuer.\n+\n+In :ref:`partitioned topologies <partitioned-topologies>`, individual trust domains store only parts of the ledger.\n+Thus, they only need to approve packages whose templates are used in the ledger part visible to them.\n+For example, in DAML on `R3 Corda <https://www.corda.net>`__, participants only need to approve code for the contracts in their parties' projections.\n+If non-validating Corda notaries are used, they do not need to vet code.\n+If validating Corda notaries are used, they can also choose which code to vet.\n+In `Canton <https://canton.io>`, participant nodes also only need to vet code for the contracts of the parties they host."
  },
  {
    "id" : "acf4ad7e-ac65-4a02-b92b-f901bd3230b7",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "1606a99b-ccbf-47fa-84f0-f97cb3eb7ae2",
        "parentId" : null,
        "author" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "body" : "```suggestion\r\nIn that case, if Alice is hosted at ``P1``, she can create ``NewTemplate`` instances with stakeholder Bob who is hosted at ``P2``, but not with stakeholder Charlie if he's hosted at ``P3``.\r\n```",
        "createdAt" : "2019-08-15T09:58:42Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "bame-da",
          "name" : "Bernhard Elsner",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/40762178?u=28b5edbfe9271d5db3fcfa3b80d30f93cce4321f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,170 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+A DAML Ledger is a software system that enables parties to automate the management of their rights and obligations through smart contract code.\n+The :ref:`DA Ledger Model <da-ledgers>` defines the permissible changes to the contracts (the integrity model), as well as the visibility that the different parties should have into such changes (the privacy model).\n+This document addresses two additional topics:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two parties with identical identifiers in two different ledgers are not the same party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and displayed name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not.\n+\n+.. _identifiers-and-authentication:\n+\n+Identifiers and Ledger Authentication\n+=====================================\n+\n+To issue commands or receive transactions on behalf of a newly provisioned party, an application must authenticate itself to the party's hosting participant as someone authorized to represent the party.\n+Currently, the Ledger API provides no authentication mechanisms.\n+However, it will soon support authentication through JSON Web Tokens.\n+Before the newly provisioned party can be used, the application will have to obtain a token for this party.\n+The issuance of tokens is specific to each ledger and independent of the Ledger API.\n+The same is true for the policy which the participants use to decide whether to accept a token.\n+\n+.. _identifiers-and-real-world:\n+\n+Identifiers and the Real World\n+==============================\n+\n+The \"substrate\" on which DAML workflows are built are the real-world obligations of the parties in the workflow.\n+To give value to these obligations, they must be connected to parties in the real world.\n+However, the process of linking party identifiers to real-world entities is left to the ledger implementation.\n+\n+A :ref:`global state topology <global-state-topologies>` might simplify the process by trusting the operator of the writer node(s) with providing the link to the real world.\n+For example, if the operator is a stock exchange, it might guarantee that a real-world exchange participant whose legal name is \"Bank Inc.\" is represented by a ledger party with the identifier \"Bank Inc.\".\n+Alternatively, it might use a random identifier, but guarantee that the display name is \"Bank Inc.\".\n+Ledgers with :ref:`partitioned topologies <partitioned-topologies>` in general might not have such a single store of identities.\n+The solutions for linking the identifiers to real-world identities could rely on certificate chains, `verifiable credentials <https://www.w3.org/TR/vc-data-model/>`__, or other mechanisms.\n+\n+Package Management\n+******************\n+\n+All DAML Ledgers implement endpoints that allow for provisioning new DAML code to the ledger.\n+The vetting process for this code, however, depends on the particular ledger implementation and its configuration.\n+The remainder of this section describes the endpoints and general principles behind the vetting process.\n+The details of the process are ledger-dependent.\n+\n+Package Formats and Identifiers\n+===============================\n+\n+Any code -- i.e., DAML templates -- to be uploaded must compiled down to the :ref:`DAML-LF <daml-lf>` language.\n+The unit of packaging for DAML-LF is the :ref:`.dalf <dar-file-dalf-file>` file.\n+Each ``.dalf`` file is uniquely identified by its **package identifier**, which is the hash of its contents.\n+A :ref:`.dar <dar-file-dalf-file>` file is a simple archive containing multiple ``.dalf`` files, and has no identifier of its own.\n+DAML ledgers support uploading only ``.dar`` files.\n+\n+Package Management API\n+======================\n+\n+The package management API supports two methods:\n+\n+- ``UploadDarFile`` for uploading ``.dar`` files.\n+  The ledger implementation is, however, free to reject any and all packages and return an error.\n+  Furthermore, even if the method call succeeds, the ledger's vetting process might restrict the usability of the template.\n+  For example, assume that Alice successfully uploads a ``.dar`` file to her participant containing a ``NewTemplate`` template.\n+  It may happen that she can now issue commands that create ``NewTemplate`` instances with Bob as a stakeholder, but that all commands that create ``NewTemplate`` instances with Charlie as a stakeholder fail.\n+\n+- ``ListKnownPackages`` that lists the ``.dalf`` package vetted for usage at the participant node.\n+  Like with the previous method, the usability of the listed templates depends on the ledger's vetting process.\n+\n+\n+Package Vetting\n+===============\n+\n+Using a DAML package entails running its DAML code.\n+The DAML interpreter ensures that the DAML code cannot interact with the environment of the system on which it is executing.\n+However, the operators of the ledger infrastructure nodes may still wish to review and vet any DAML code before allowing it to execute.\n+One reason for this is that the DAML interpreter currently lacks a notion of reproducible resource limits.\n+Thus, executing a DAML contract might result in high memory or CPU usage.\n+Furthermore, security bugs in the DAML interpreter or JVM might enable malicious code to break out of the sandbox.\n+\n+Thus, DAML Ledgers generally allow some form of vetting a package before running its code on a node.\n+Not all nodes in a DAML Ledger must vet all packages, as it is possible that some of them will not execute the code.\n+For example, in :ref:`global state topologies <global-state-topologies>`, every :ref:`trust domain <trust-domain>` that controls how commits are appended to the shared ledger must execute DAML code.\n+Thus, the operators of these trust domains will in general be allowed to vet the code before they execute it.\n+The exact vetting mechanism is ledger-dependent.\n+For example, in the :ref:`DAML Sandbox <sandbox-manual>`, the vetting is implicit: uploading a package through the Ledger API already vets the package, since its assumed that only the system administrator has access to these API facilities.\n+In a replicated ledger, the vetting might require consent from all or a quorum of replicas.\n+The vetting process can be manual, where an administrator inspects each package, or it can be automated, for example, by accepting only packages with a digital signature from a trusted package issuer.\n+\n+In :ref:`partitioned topologies <partitioned-topologies>`, individual trust domains store only parts of the ledger.\n+Thus, they only need to approve packages whose templates are used in the ledger part visible to them.\n+For example, in DAML on `R3 Corda <https://www.corda.net>`__, participants only need to approve code for the contracts in their parties' projections.\n+If non-validating Corda notaries are used, they do not need to vet code.\n+If validating Corda notaries are used, they can also choose which code to vet.\n+In `Canton <https://canton.io>`, participant nodes also only need to vet code for the contracts of the parties they host.\n+As only participants execute contract code, only they need to vet it.\n+The vetting results may also differ at different participants.\n+For example, participants ``P1`` and ``P2`` might vet a package containing a ``NewTemplate`` template, whereas ``P3`` might reject it.\n+In that case, if Alice is hosted at ``P1``, she can create ``NewTemplate`` instances with stakeholder Bob who is hosted at ``P3``, but not with stakeholder Charlie if he's hosted at ``P3``."
  },
  {
    "id" : "a6857fca-9477-41ca-9c52-21ef3dbb7a39",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "dafaa6e2-9f39-46b7-8d12-c576ef0070f0",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "It would be good if this section clarified\r\n1. who the audience of the document is\r\n2. what questions the seciton will answer.\r\n\r\nMy take is that the audience is ledger implementors and ledger operators. There seem to be multiple questions:\r\n1. How should I implement party and package managment?\r\n2. Which ledger should I select provided my requirements on party and package management?",
        "createdAt" : "2019-08-16T15:44:05Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,169 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+Since DAML Ledgers enable parties to automate the management of their rights and obligations through smart contract code, they also have to provide party and code management functions.\n+Hence, this document addresses:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior."
  },
  {
    "id" : "0b3d5cf3-62b8-4981-bd76-c1a480a41684",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "fa1b62bc-8e89-496c-a68b-a604c20d0334",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/will presents/presents",
        "createdAt" : "2019-08-19T07:47:55Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,169 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+Since DAML Ledgers enable parties to automate the management of their rights and obligations through smart contract code, they also have to provide party and code management functions.\n+Hence, this document addresses:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:"
  },
  {
    "id" : "b8db2e8c-f3ba-42c5-881b-2c17d667571f",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "8d04d8fc-9bdb-465d-9f44-f57050ddcf4b",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Good section! Thanks @oggy- !",
        "createdAt" : "2019-08-19T07:54:42Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : 80,
    "diffHunk" : "@@ -0,0 +1,169 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+Since DAML Ledgers enable parties to automate the management of their rights and obligations through smart contract code, they also have to provide party and code management functions.\n+Hence, this document addresses:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two identical identifiers in two different ledgers do not necessarily identify the same real-world party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique, and two different participant nodes might return different display names for the same party identifier.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and display name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not."
  },
  {
    "id" : "05dc0710-a14c-4bf7-9003-928cca1d0958",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "0f6cedfc-886a-45ad-a78d-035bb13e4db8",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Consider adding a sentence like\r\n```\r\nAn additional option is to use for a DAML-based application to include a Know-Your-Customer workflow in DAML to establish the link from a party to a real world identity.\r\n```",
        "createdAt" : "2019-08-19T08:17:38Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "51848731-bd57-4729-8b87-a24089f3ba6e",
        "parentId" : "0f6cedfc-886a-45ad-a78d-035bb13e4db8",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Added",
        "createdAt" : "2019-08-19T15:16:36Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : 107,
    "diffHunk" : "@@ -0,0 +1,169 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+Since DAML Ledgers enable parties to automate the management of their rights and obligations through smart contract code, they also have to provide party and code management functions.\n+Hence, this document addresses:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two identical identifiers in two different ledgers do not necessarily identify the same real-world party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique, and two different participant nodes might return different display names for the same party identifier.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and display name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not.\n+\n+.. _identifiers-and-authentication:\n+\n+Identifiers and Ledger Authentication\n+=====================================\n+\n+To issue commands or receive transactions on behalf of a newly provisioned party, an application must authenticate itself to the party's hosting participant as someone authorized to represent the party.\n+Currently, the Ledger API provides no authentication mechanisms.\n+However, it will soon support authentication through JSON Web Tokens.\n+Before the newly provisioned party can be used, the application will have to obtain a token for this party.\n+The issuance of tokens is specific to each ledger and independent of the Ledger API.\n+The same is true for the policy which the participants use to decide whether to accept a token.\n+\n+.. _identifiers-and-real-world:\n+\n+Identifiers and the Real World\n+==============================\n+\n+The \"substrate\" on which DAML workflows are built are the real-world obligations of the parties in the workflow.\n+To give value to these obligations, they must be connected to parties in the real world.\n+However, the process of linking party identifiers to real-world entities is left to the ledger implementation.\n+\n+A :ref:`global state topology <global-state-topologies>` might simplify the process by trusting the operator of the writer node(s) with providing the link to the real world.\n+For example, if the operator is a stock exchange, it might guarantee that a real-world exchange participant whose legal name is \"Bank Inc.\" is represented by a ledger party with the identifier \"Bank Inc.\".\n+Alternatively, it might use a random identifier, but guarantee that the display name is \"Bank Inc.\".\n+Ledgers with :ref:`partitioned topologies <partitioned-topologies>` in general might not have such a single store of identities.\n+The solutions for linking the identifiers to real-world identities could rely on certificate chains, `verifiable credentials <https://www.w3.org/TR/vc-data-model/>`__, or other mechanisms."
  },
  {
    "id" : "cbeeac85-33fb-4062-8bb1-6d7142f2c658",
    "prId" : 2532,
    "comments" : [
      {
        "id" : "70ecb64b-6c65-46e6-80b2-66695970edb4",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Add: However storage of data on-ledger typically happens using `.dalf` files, as only they have globally unique identifiers.",
        "createdAt" : "2019-08-19T08:19:12Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5ae911cc-03be-4b36-9a14-401c8005453a",
        "parentId" : "70ecb64b-6c65-46e6-80b2-66695970edb4",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Added",
        "createdAt" : "2019-08-19T15:16:41Z",
        "updatedAt" : "2019-08-19T16:16:24Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4eb2b5576ac4e4d575bb69337a36b944a8aaef8a",
    "line" : 131,
    "diffHunk" : "@@ -0,0 +1,169 @@\n+.. Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Identity and Package Management\n+###############################\n+\n+Since DAML Ledgers enable parties to automate the management of their rights and obligations through smart contract code, they also have to provide party and code management functions.\n+Hence, this document addresses:\n+\n+1. Management of parties' digital identifiers in a DAML Ledger.\n+\n+2. Distribution of smart contract code between the parties connected to the same DAML Ledger.\n+\n+The Ledger API provides both a :ref:`party management service <com.digitalasset.ledger.api.v1.PartyService>` and a :ref:`package service <com.digitalasset.ledger.api.v1.PackageService>`.\n+The access to these services is usually more restricted compared to the other Ledger API services, as they are part of the administrative API.\n+Any implementation of the services is guaranteed to accept inputs and provide outputs of the format specified by these services.\n+However, the services' *behavior* -- the relationship between the inputs and outputs that the various parties observe -- is largely implementation dependent.\n+The remainder of the document will presents both:\n+\n+#. the minimal behavioral guarantees for identity and package services across all ledger implementations, and\n+\n+#. guidelines to understand how the :ref:`ledger's topology <daml-ledger-topologies>` influences the unspecified part of the behavior.\n+\n+Identity Management\n+*******************\n+\n+A DAML Ledger may freely define its own format of party and :ref:`participant node <participant-node-def>` identifiers, with some minor constraints on the identifiers' serialized form.\n+For example, a ledger may use human-readable strings as identifiers, such as \"Alice\" or \"Alice's Bank\".\n+A different ledger might use public keys as identifiers, or the keys' fingerprints.\n+The applications should thus not rely on the format of the identifier -- even a software upgrade of a DAML Ledger may introduce a new format.\n+\n+By definition, identifiers identify parties, and are thus unique for a ledger.\n+They do not, however, have to be unique across different ledgers.\n+That is, two identical identifiers in two different ledgers do not necessarily identify the same real-world party.\n+Moreover, a real-world entity can have multiple identifiers (and thus parties) within the same ledger.\n+\n+Since the identifiers might be difficult to interpret and manage for humans, the ledger may also accompany each identifier with a user-friendly **display name**.\n+Unlike the identifier, the display name is not guaranteed to be unique, and two different participant nodes might return different display names for the same party identifier.\n+Furthermore, a display name is in general not guaranteed to have any link to real world identities.\n+For example, a party with a display name \"Attorney of Nigerian Prince\" might well be controlled by a real-world entity without a bar exam.\n+However, particular ledger deployments might make stronger guarantees about this link.\n+Finally, the association of identifiers to display names may change over time.\n+For example, a party might change its display name from \"Bruce\" to \"Caitlyn\" -- as long as the identifier remains the same, so does the party.\n+\n+.. _provisioning-ledger-identifiers:\n+\n+Provisioning Identifiers\n+========================\n+\n+The set of parties of any DAML Ledger is dynamic: new parties may always be added to the system.\n+The first step in adding a new party to the ledger is to provision a new identifier for the party.\n+The Ledger API provides an ``AllocateParty`` method for this purpose.\n+The method, if successful, returns an new party identifier.\n+The ``AllocateParty`` call can take the desired identifier and display name as optional parameters, but these are merely hints and the ledger implementation may completely ignore them.\n+\n+If the call returns a new identifier, the :ref:`participant node <participant-node-def>` serving this call is ready to host the party with this identifier.\n+The returned identifier is guaranteed to be **unique** in the ledger; namely, no other call of the ``AllocateParty`` method at this or any other ledger participant may return the same identifier.\n+If the ledger has a :ref:`global state topology <global-state-topologies>`, the new identifier will generally be allocated and vetted by the operator of the writer node(s).\n+For example, in the `replicated committer topology <replicated-committer-topology>`__, the committers can jointly decide on whether to approve the provisioning, and which identifier to return.\n+If they refuse to provision the identifier, the method call fails.\n+\n+After an identifier is returned, the ledger is set up in such a way that the participant node serving the call is allowed to issue commands and receive transactions on behalf of the party.\n+However, the newly provisioned identifier need not be visible to the other participant nodes.\n+For example, consider the setup with two participants ``P1`` and ``P2``, where the party ``Alice_123`` is hosted on ``P1``.\n+Assume that a new party ``Bob_456`` is next successfully allocated on ``P2``.\n+This does not yet guarantee that ``Alice_123`` can now submit a command creating a new contract with ``Bob_456`` as an observer.\n+In general, ``Alice_123`` will be able to do this in a ledger with a :ref:`global state topology <global-state-topologies>`.\n+In such ledgers, the nodes holding the physical shared ledger typically also maintain a central directory of all parties in the system.\n+However, such a directory may not exist for a ledger with a :ref:`partitioned topology <partitioned-topologies>`.\n+In fact, in such a ledger, the participants ``P1`` and ``P2`` might not have a way to communicate to each other, or might not even be aware of each other's existence.\n+\n+For diagnostics, the ledger also provides a ``ListKnownParties`` method which lists parties known to the participant node.\n+The parties can be local (i.e., hosted by the participant) or not.\n+\n+.. _identifiers-and-authentication:\n+\n+Identifiers and Ledger Authentication\n+=====================================\n+\n+To issue commands or receive transactions on behalf of a newly provisioned party, an application must authenticate itself to the party's hosting participant as someone authorized to represent the party.\n+Currently, the Ledger API provides no authentication mechanisms.\n+However, it will soon support authentication through JSON Web Tokens.\n+Before the newly provisioned party can be used, the application will have to obtain a token for this party.\n+The issuance of tokens is specific to each ledger and independent of the Ledger API.\n+The same is true for the policy which the participants use to decide whether to accept a token.\n+\n+.. _identifiers-and-real-world:\n+\n+Identifiers and the Real World\n+==============================\n+\n+The \"substrate\" on which DAML workflows are built are the real-world obligations of the parties in the workflow.\n+To give value to these obligations, they must be connected to parties in the real world.\n+However, the process of linking party identifiers to real-world entities is left to the ledger implementation.\n+\n+A :ref:`global state topology <global-state-topologies>` might simplify the process by trusting the operator of the writer node(s) with providing the link to the real world.\n+For example, if the operator is a stock exchange, it might guarantee that a real-world exchange participant whose legal name is \"Bank Inc.\" is represented by a ledger party with the identifier \"Bank Inc.\".\n+Alternatively, it might use a random identifier, but guarantee that the display name is \"Bank Inc.\".\n+Ledgers with :ref:`partitioned topologies <partitioned-topologies>` in general might not have such a single store of identities.\n+The solutions for linking the identifiers to real-world identities could rely on certificate chains, `verifiable credentials <https://www.w3.org/TR/vc-data-model/>`__, or other mechanisms.\n+\n+Package Management\n+******************\n+\n+All DAML Ledgers implement endpoints that allow for provisioning new DAML code to the ledger.\n+The vetting process for this code, however, depends on the particular ledger implementation and its configuration.\n+The remainder of this section describes the endpoints and general principles behind the vetting process.\n+The details of the process are ledger-dependent.\n+\n+Package Formats and Identifiers\n+===============================\n+\n+Any code -- i.e., DAML templates -- to be uploaded must compiled down to the :ref:`DAML-LF <daml-lf>` language.\n+The unit of packaging for DAML-LF is the :ref:`.dalf <dar-file-dalf-file>` file.\n+Each ``.dalf`` file is uniquely identified by its **package identifier**, which is the hash of its contents.\n+Templates in a ``.dalf`` file can references templates from other ``.dalf`` files, i.e., ``.dalf`` files can depend on other ``.dalf`` files.\n+A :ref:`.dar <dar-file-dalf-file>` file is a simple archive containing multiple ``.dalf`` files, and has no identifier of its own.\n+The archive provides a convenient way to package ``.dalf`` files together with their dependencies.\n+The Ledger API supports only ``.dar`` file uploads."
  }
]