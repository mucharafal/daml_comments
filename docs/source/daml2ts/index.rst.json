[
  {
    "id" : "19c105aa-dd3a-4517-aa21-ee6895a494bc",
    "prId" : 5171,
    "comments" : [
      {
        "id" : "e83e9a93-b419-4efc-94ab-ef94e7bac2a3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There is no more `PACKAGE` parameter and we're finally writing JavaScript + typing. We should embrace that:\r\n```suggestion\r\nIn outline, the command to generate JavaScript and TypeScript typings from DAML is ``daml codegen ts DAR -o OUTDIR`` where ``DAR`` is the path to a DAR file (generated via ``daml build``) and ``OUTDIR`` is a directory where you want the JavaScript to be written.\r\n```\r\nCan you please check there are no more references to `PACKAGE` elsewhere.",
        "createdAt" : "2020-03-25T17:28:40Z",
        "updatedAt" : "2020-03-25T17:50:50Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8c80a5c9-19ce-4981-8dbf-06a5bc451607",
        "parentId" : "e83e9a93-b419-4efc-94ab-ef94e7bac2a3",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "(1) Fixed.\r\n(2) Done.",
        "createdAt" : "2020-03-25T18:30:57Z",
        "updatedAt" : "2020-03-25T18:30:57Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ede39c0bc7b73401d689c75f3f46feb6f2c5843f",
    "line" : 5,
    "diffHunk" : "@@ -21,7 +21,7 @@ Usage\n \n ``daml2ts`` is invoked via the DAML SDK assistant.\n \n-In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR –main-package-name=PACKAGE`` where ``DAR`` is the path to a DAR file (generated via ``daml build``), ``OUTDIR`` is a directory where you want the TypeScript to be written and ``PACKAGE`` is a desired TypeScript package name.\n+In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR`` where ``DAR`` is the path to a DAR file (generated via ``daml build``), ``OUTDIR`` is a directory where you want the TypeScript to be written and ``PACKAGE`` is a desired TypeScript package name."
  },
  {
    "id" : "78ddee3c-7b52-4987-9ad6-26fe08689018",
    "prId" : 5171,
    "comments" : [
      {
        "id" : "d9f04a6e-ea3a-4c1e-93c2-ce0c3ba67035",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Isn't there a `src` somewhere in the path to `Main.ts` as well?",
        "createdAt" : "2020-03-25T17:31:18Z",
        "updatedAt" : "2020-03-25T17:50:50Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "245395ed-4a2f-4261-82e7-f9f4759c4738",
        "parentId" : "d9f04a6e-ea3a-4c1e-93c2-ce0c3ba67035",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yes. Fixed.",
        "createdAt" : "2020-03-25T18:31:43Z",
        "updatedAt" : "2020-03-25T18:31:43Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ede39c0bc7b73401d689c75f3f46feb6f2c5843f",
    "line" : 25,
    "diffHunk" : "@@ -31,15 +31,15 @@ Here's a complete example that generates TypeScript from a project produced from\n    daml new my-proj skeleton # Create a new project based off the skeleton template\n    cd my-proj # Enter the newly created project directory\n    daml build  # Compile the project's DAML files into a DAR\n-   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o generated/ts --main-package-name=my-proj # Generate Typescript from the DAR\n+   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o daml2ts # Generate script bindings from the DAR\n \n - On execution of these commands:\n \n-  - The directory ``my-proj/generated/ts`` contains the generated TypeScript source files;\n+  - The directory ``my-proj/daml2ts`` contains generated TypeScript and Javascript artifacts;\n   - The files are arranged into directories;\n-  - One of those directories will be named as per the ``PACKAGE`` argument and will contain the TypeScript definitions corresponding to the DAML files in the project;\n-  - For example, ``generated/ts/my-proj/Main.ts`` contains the TypeScript definitions for ``daml/Main.daml``;\n-  - The remaining directories contain supporting TypeScript corresponding to modules of the DAML standard library;\n+  - One of those directories will be named as per the ``PACKAGE`` argument and will contain the definitions corresponding to the DAML files in the project;\n+  - For example, ``generated/ts/my-proj/Main.ts`` contains the definitions for ``daml/Main.daml``;"
  },
  {
    "id" : "4bca2a6e-a945-4dc1-a23f-91482e11eecd",
    "prId" : 5044,
    "comments" : [
      {
        "id" : "b02e93fe-0407-4d7b-b723-c1436dd81ff5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n   type Color = 'Red' | 'Blue' | 'Yellow'\r\n```\r\nThat's easier on the eye if you put it all in one line, which makes a lot of sense here.",
        "createdAt" : "2020-03-17T15:59:42Z",
        "updatedAt" : "2020-03-17T16:05:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d1b6e7a6eae69d71ee3d027b631fe0d4f73908c4",
    "line" : null,
    "diffHunk" : "@@ -203,10 +203,11 @@ the generated TypeScript will consist of a type declaration and the definition o\n \n    type Color = | 'Red' | 'Blue' | 'Yellow'"
  },
  {
    "id" : "ea7c872a-d09d-48b3-beeb-02b92c9d6b5e",
    "prId" : 4975,
    "comments" : [
      {
        "id" : "aed6fc6a-030c-4c2c-8bfa-fbc094c7e094",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think documenting this type just adds complexity that doesn't help with anything.\r\n```suggestion\r\n   const Color = {\r\n```",
        "createdAt" : "2020-03-16T09:38:01Z",
        "updatedAt" : "2020-03-16T09:54:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d59c59ff-6876-47f6-86c5-345095f7b7ee",
        "parentId" : "aed6fc6a-030c-4c2c-8bfa-fbc094c7e094",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/5044",
        "createdAt" : "2020-03-17T16:36:23Z",
        "updatedAt" : "2020-03-17T16:36:23Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3f6f10a59e79f234fa88ceca81c572c611a97f7d",
    "line" : 25,
    "diffHunk" : "@@ -189,23 +189,25 @@ The thing to note is how the definition of the ``Add`` case has given rise to a\n Enums\n ~~~~~\n \n-DAML enumerations map naturally to TypeScript.\n+Given a DAML enumeration like this,\n \n .. code-block:: daml\n    :linenos:\n \n    data Color = Red | Blue | Yellow\n \n-The companion TypeScript type is the following.\n+the generated TypeScript will consist of a type declaration and the definition of an associated companion object.\n \n .. code-block:: typescript\n    :linenos:\n \n-   enum Color {\n-     Red = 'Red',\n-     Blue = 'Blue',\n-     Yellow = 'Yellow',\n-   }\n+   type Color = | 'Red' | 'Blue' | 'Yellow'\n+\n+   const Color : {readonly Red: Color; readonly Blue: Color; readonly Yellow: Color} = {"
  },
  {
    "id" : "609ea6df-499f-4ede-bc5e-90336bb4e53a",
    "prId" : 4261,
    "comments" : [
      {
        "id" : "9c011de8-1b71-49e8-97f9-dcd0f990d3f9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The directory name is  the hash of the DAML-LF package.",
        "createdAt" : "2020-01-30T13:53:42Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bdc2274e-de7b-43cd-8461-dda72d519919",
        "parentId" : "9c011de8-1b71-49e8-97f9-dcd0f990d3f9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ \r\n",
        "createdAt" : "2020-01-30T14:11:10Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a76046d79ab88f984b34a7709ce11c23e2a9fd43",
    "line" : null,
    "diffHunk" : "@@ -14,62 +14,87 @@ Introduction\n \n ``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n \n-The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+The code ``daml2ts`` generates uses the library `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n \n-Primitives: @daml/types\n------------------------\n+Usage\n+-----\n \n-To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+``daml2ts`` is invoked via the DAML SDK assistant.\n \n-**Interfaces**:\n+In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR`` where ``DAR`` is the path to a DAR file (generated via ``daml build``) and ``OUTDIR`` is a directory where you want the TypeScript to be written.\n+\n+Here's a complete example that generates TypeScript from a project produced from the standard \"skeleton\" template.\n+\n+.. code-block:: bash\n+   :linenos:\n+\n+   daml new my-proj skeleton # Create a new project based off the skeleton template\n+   cd my-proj # Enter the newly created project directory\n+   daml build  # Compile the project's DAML files into a DAR\n+   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o generated/ts # Generate Typescript from the DAR\n \n-- ``Serializable<T>``\n-- ``Template<T extends object, K = unknown>``\n-- ``Choice<T extends object, C, R, K = unknown>``\n+- On execution of these commands:\n \n-  ..\n-        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n-        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n-        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+  - The directory ``my-proj/generated/ts`` contains the generated TypeScript source files;\n+  - The files are arranged into directories - each directory having a numeric name;"
  },
  {
    "id" : "d2954955-749a-49df-b1a1-70362b783832",
    "prId" : 4261,
    "comments" : [
      {
        "id" : "1168c778-d7c1-463c-ab40-87a074964e78",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What is the \"primary directory\"? How do you identify it?",
        "createdAt" : "2020-01-30T13:54:17Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8247b78b-d3b2-46f0-a51b-29b1d71202b8",
        "parentId" : "1168c778-d7c1-463c-ab40-87a074964e78",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Rephrased.",
        "createdAt" : "2020-01-30T14:11:18Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a76046d79ab88f984b34a7709ce11c23e2a9fd43",
    "line" : null,
    "diffHunk" : "@@ -14,62 +14,87 @@ Introduction\n \n ``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n \n-The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+The code ``daml2ts`` generates uses the library `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n \n-Primitives: @daml/types\n------------------------\n+Usage\n+-----\n \n-To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+``daml2ts`` is invoked via the DAML SDK assistant.\n \n-**Interfaces**:\n+In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR`` where ``DAR`` is the path to a DAR file (generated via ``daml build``) and ``OUTDIR`` is a directory where you want the TypeScript to be written.\n+\n+Here's a complete example that generates TypeScript from a project produced from the standard \"skeleton\" template.\n+\n+.. code-block:: bash\n+   :linenos:\n+\n+   daml new my-proj skeleton # Create a new project based off the skeleton template\n+   cd my-proj # Enter the newly created project directory\n+   daml build  # Compile the project's DAML files into a DAR\n+   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o generated/ts # Generate Typescript from the DAR\n \n-- ``Serializable<T>``\n-- ``Template<T extends object, K = unknown>``\n-- ``Choice<T extends object, C, R, K = unknown>``\n+- On execution of these commands:\n \n-  ..\n-        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n-        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n-        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+  - The directory ``my-proj/generated/ts`` contains the generated TypeScript source files;\n+  - The files are arranged into directories - each directory having a numeric name;\n+  - The primary directory contains the TypeScript corresponding to the DAML files in ``my-proj/daml``, the remaining directories contain supporting TypeScript corresponding to modules of the DAML standard library;"
  },
  {
    "id" : "a520ccde-10ee-4b88-9c2a-04380c8d68dc",
    "prId" : 4261,
    "comments" : [
      {
        "id" : "45542ddb-cd20-4526-a419-77dca96d1484",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should use `T` and `K` here because they are variables in the object languages, i.e., type variables in TypeScript.",
        "createdAt" : "2020-01-30T13:55:31Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8407c5ff-8224-4c6e-98de-96c2941aba67",
        "parentId" : "45542ddb-cd20-4526-a419-77dca96d1484",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-30T14:04:07Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a76046d79ab88f984b34a7709ce11c23e2a9fd43",
    "line" : null,
    "diffHunk" : "@@ -14,62 +14,87 @@ Introduction\n \n ``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n \n-The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+The code ``daml2ts`` generates uses the library `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n \n-Primitives: @daml/types\n------------------------\n+Usage\n+-----\n \n-To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+``daml2ts`` is invoked via the DAML SDK assistant.\n \n-**Interfaces**:\n+In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR`` where ``DAR`` is the path to a DAR file (generated via ``daml build``) and ``OUTDIR`` is a directory where you want the TypeScript to be written.\n+\n+Here's a complete example that generates TypeScript from a project produced from the standard \"skeleton\" template.\n+\n+.. code-block:: bash\n+   :linenos:\n+\n+   daml new my-proj skeleton # Create a new project based off the skeleton template\n+   cd my-proj # Enter the newly created project directory\n+   daml build  # Compile the project's DAML files into a DAR\n+   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o generated/ts # Generate Typescript from the DAR\n \n-- ``Serializable<T>``\n-- ``Template<T extends object, K = unknown>``\n-- ``Choice<T extends object, C, R, K = unknown>``\n+- On execution of these commands:\n \n-  ..\n-        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n-        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n-        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+  - The directory ``my-proj/generated/ts`` contains the generated TypeScript source files;\n+  - The files are arranged into directories - each directory having a numeric name;\n+  - The primary directory contains the TypeScript corresponding to the DAML files in ``my-proj/daml``, the remaining directories contain supporting TypeScript corresponding to modules of the DAML standard library;\n+  - For example, ``generated/ts/03d1a767741153b5910ad849b0f7af96d205416b3e0ec4c23cbc75a0177776f4/Main.ts`` contains the TypeScript definitions for ``daml/Main.daml``.\n+\n+To get a quickstart idea of how to use what has been generated, you may wish to jump to the `Templates and choices`_ section and return to the reference material that follows as needed.\n+\n+Primitive DAML types: @daml/types\n+---------------------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the TypeScript equivalents of the primitive DAML types provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Template<τ extends object, κ = unknown>``"
  },
  {
    "id" : "863e5ab9-f02e-483a-a77b-15f704f4b11d",
    "prId" : 4261,
    "comments" : [
      {
        "id" : "b55533c8-6b3f-484d-bd8e-124872bc2b99",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should somehow make it clear that the types mentioned in the \"TypeScript\" column are defined in `@daml/types`.",
        "createdAt" : "2020-01-30T13:56:46Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a1790c35-a071-4320-a4d9-da0db08da81e",
        "parentId" : "b55533c8-6b3f-484d-bd8e-124872bc2b99",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-30T14:05:23Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a76046d79ab88f984b34a7709ce11c23e2a9fd43",
    "line" : null,
    "diffHunk" : "@@ -14,62 +14,87 @@ Introduction\n \n ``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n \n-The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+The code ``daml2ts`` generates uses the library `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n \n-Primitives: @daml/types\n------------------------\n+Usage\n+-----\n \n-To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+``daml2ts`` is invoked via the DAML SDK assistant.\n \n-**Interfaces**:\n+In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR`` where ``DAR`` is the path to a DAR file (generated via ``daml build``) and ``OUTDIR`` is a directory where you want the TypeScript to be written.\n+\n+Here's a complete example that generates TypeScript from a project produced from the standard \"skeleton\" template.\n+\n+.. code-block:: bash\n+   :linenos:\n+\n+   daml new my-proj skeleton # Create a new project based off the skeleton template\n+   cd my-proj # Enter the newly created project directory\n+   daml build  # Compile the project's DAML files into a DAR\n+   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o generated/ts # Generate Typescript from the DAR\n \n-- ``Serializable<T>``\n-- ``Template<T extends object, K = unknown>``\n-- ``Choice<T extends object, C, R, K = unknown>``\n+- On execution of these commands:\n \n-  ..\n-        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n-        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n-        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+  - The directory ``my-proj/generated/ts`` contains the generated TypeScript source files;\n+  - The files are arranged into directories - each directory having a numeric name;\n+  - The primary directory contains the TypeScript corresponding to the DAML files in ``my-proj/daml``, the remaining directories contain supporting TypeScript corresponding to modules of the DAML standard library;\n+  - For example, ``generated/ts/03d1a767741153b5910ad849b0f7af96d205416b3e0ec4c23cbc75a0177776f4/Main.ts`` contains the TypeScript definitions for ``daml/Main.daml``.\n+\n+To get a quickstart idea of how to use what has been generated, you may wish to jump to the `Templates and choices`_ section and return to the reference material that follows as needed.\n+\n+Primitive DAML types: @daml/types\n+---------------------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the TypeScript equivalents of the primitive DAML types provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Template<τ extends object, κ = unknown>``\n+- ``Choice<τ extends object, ɣ, ρ, κ = unknown>``\n \n **Types**:\n \n-+-------------------+------------------+----------------------------------+\n-| TypeScript        | DAML equiv.      | TypeScript definition            |\n-+===================+==================+==================================+\n-| ``Unit``          | ``()``           | ``{}``                           |\n-+-------------------+------------------+----------------------------------+\n-| ``Bool``          | ``Bool``         | ``boolean``                      |\n-+-------------------+------------------+----------------------------------+\n-| ``Int``           | ``Int``          | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Decimal``       | ``Decimal``      | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Numeric``       | ``Numeric n``    | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Text``          | ``Text``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Time``          | ``Time``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Party``         | ``Party``        | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``List<T>``       | ``[t]``          | ``T[]``                          |\n-+-------------------+------------------+----------------------------------+\n-| ``Date``          | ``Date``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n-|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n-+-------------------+------------------+----------------------------------+\n-| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n-+-------------------+------------------+----------------------------------+\n++-------------------+--------------------+----------------------------------+\n+| DAML              | TypeScript        | TypeScript definition            |"
  },
  {
    "id" : "ae5b88fd-763b-4c3a-aa3c-b2ce8ea5328e",
    "prId" : 4261,
    "comments" : [
      {
        "id" : "c89c0788-3670-4746-8cea-21d1c4faa14a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n| ``(τ₁, τ₂)``      | ``Tuple₂<τ₁, τ₂>`` | ``{ _1: τ₁; _2: τ₂ }``             |\r\n```",
        "createdAt" : "2020-01-30T13:57:02Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "befb664d-7ec3-480b-975e-846b1256d6ad",
        "parentId" : "c89c0788-3670-4746-8cea-21d1c4faa14a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-30T14:05:40Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a76046d79ab88f984b34a7709ce11c23e2a9fd43",
    "line" : null,
    "diffHunk" : "@@ -14,62 +14,87 @@ Introduction\n \n ``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n \n-The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+The code ``daml2ts`` generates uses the library `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n \n-Primitives: @daml/types\n------------------------\n+Usage\n+-----\n \n-To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+``daml2ts`` is invoked via the DAML SDK assistant.\n \n-**Interfaces**:\n+In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR`` where ``DAR`` is the path to a DAR file (generated via ``daml build``) and ``OUTDIR`` is a directory where you want the TypeScript to be written.\n+\n+Here's a complete example that generates TypeScript from a project produced from the standard \"skeleton\" template.\n+\n+.. code-block:: bash\n+   :linenos:\n+\n+   daml new my-proj skeleton # Create a new project based off the skeleton template\n+   cd my-proj # Enter the newly created project directory\n+   daml build  # Compile the project's DAML files into a DAR\n+   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o generated/ts # Generate Typescript from the DAR\n \n-- ``Serializable<T>``\n-- ``Template<T extends object, K = unknown>``\n-- ``Choice<T extends object, C, R, K = unknown>``\n+- On execution of these commands:\n \n-  ..\n-        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n-        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n-        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+  - The directory ``my-proj/generated/ts`` contains the generated TypeScript source files;\n+  - The files are arranged into directories - each directory having a numeric name;\n+  - The primary directory contains the TypeScript corresponding to the DAML files in ``my-proj/daml``, the remaining directories contain supporting TypeScript corresponding to modules of the DAML standard library;\n+  - For example, ``generated/ts/03d1a767741153b5910ad849b0f7af96d205416b3e0ec4c23cbc75a0177776f4/Main.ts`` contains the TypeScript definitions for ``daml/Main.daml``.\n+\n+To get a quickstart idea of how to use what has been generated, you may wish to jump to the `Templates and choices`_ section and return to the reference material that follows as needed.\n+\n+Primitive DAML types: @daml/types\n+---------------------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the TypeScript equivalents of the primitive DAML types provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Template<τ extends object, κ = unknown>``\n+- ``Choice<τ extends object, ɣ, ρ, κ = unknown>``\n \n **Types**:\n \n-+-------------------+------------------+----------------------------------+\n-| TypeScript        | DAML equiv.      | TypeScript definition            |\n-+===================+==================+==================================+\n-| ``Unit``          | ``()``           | ``{}``                           |\n-+-------------------+------------------+----------------------------------+\n-| ``Bool``          | ``Bool``         | ``boolean``                      |\n-+-------------------+------------------+----------------------------------+\n-| ``Int``           | ``Int``          | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Decimal``       | ``Decimal``      | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Numeric``       | ``Numeric n``    | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Text``          | ``Text``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Time``          | ``Time``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Party``         | ``Party``        | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``List<T>``       | ``[t]``          | ``T[]``                          |\n-+-------------------+------------------+----------------------------------+\n-| ``Date``          | ``Date``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n-|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n-+-------------------+------------------+----------------------------------+\n-| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n-+-------------------+------------------+----------------------------------+\n++-------------------+--------------------+----------------------------------+\n+| DAML              | TypeScript        | TypeScript definition            |\n++===================+====================+==================================+\n+| ``()``            | ``Unit``           | ``{}``                           |\n++-------------------+--------------------+----------------------------------+\n+| ``Bool``          | ``Bool``           | ``boolean``                      |\n++-------------------+--------------------+----------------------------------+\n+| ``Int``           | ``Int``            | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``        | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``Numeric ν``     | ``Numeric``        | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``Text``          | ``Text``           | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``Time``          | ``Time``           | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``Party``         | ``Party``          | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``[τ]``           | ``List<τ>``        | ``τ[]``                          |\n++-------------------+--------------------+----------------------------------+\n+| ``Date``          | ``Date``           | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``ContractId τ``  | ``ContractId<τ>``  | ``string``                       |\n++-------------------+--------------------+----------------------------------+\n+| ``Optional τ``    | ``Optional<τ>``    | ``null | (null extends τ ?``     |\n+|                   |                    | ``[] | [Exclude<τ, null>] : τ)`` |\n++-------------------+--------------------+----------------------------------+\n+| ``TextMap τ``     | ``TextMap<τ>``     | ``{ [key: string]: τ }``         |\n++-------------------+--------------------+----------------------------------+\n+| ``(τ₁, τ₂)``      | ``Tuple₂<τ₁, τ₂>`` | ``{_1: τ₁, _2: τ₂}``             |"
  },
  {
    "id" : "b9a2ff7b-ce27-4f95-b4a5-7797e7a220e8",
    "prId" : 4261,
    "comments" : [
      {
        "id" : "1f52b7bb-ac97-423f-b5da-012c2ee9c730",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't think that's valid TypeScript. We should have something like `import * as Iou from ...`.",
        "createdAt" : "2020-01-30T13:58:28Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7060d1c5-7829-4d84-b486-56f3cbcc0ce5",
        "parentId" : "1f52b7bb-ac97-423f-b5da-012c2ee9c730",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-30T14:09:09Z",
        "updatedAt" : "2020-01-30T15:34:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a76046d79ab88f984b34a7709ce11c23e2a9fd43",
    "line" : null,
    "diffHunk" : "@@ -267,6 +263,8 @@ What **is** important is the use of the companion objects when creating contract\n    :linenos:\n \n    import Ledger from  '@daml/ledger';\n+   import * as '03d1a767741153b5910ad849b0f7af96d205416b3e0ec4c23cbc75a0177776f4/Iou';"
  },
  {
    "id" : "c688b232-0a2d-48c1-9bd5-793f501cd6dc",
    "prId" : 4261,
    "comments" : [
      {
        "id" : "596ef8f0-e855-4435-aabd-eb1b9bd7c508",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Really? Why is `Int` mapped to a Typescript `string`?",
        "createdAt" : "2020-01-30T16:55:19Z",
        "updatedAt" : "2020-01-30T16:56:17Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a76046d79ab88f984b34a7709ce11c23e2a9fd43",
    "line" : 104,
    "diffHunk" : "@@ -14,62 +14,92 @@ Introduction\n \n ``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n \n-The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+The code ``daml2ts`` generates uses the library `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n \n-Primitives: @daml/types\n------------------------\n+Usage\n+-----\n \n-To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+``daml2ts`` is invoked via the DAML SDK assistant.\n+\n+In outline, the command to generate TypeScript from DAML is ``daml codegen ts DAR -o OUTDIR –main-package-name=PACKAGE`` where ``DAR`` is the path to a DAR file (generated via ``daml build``), ``OUTDIR`` is a directory where you want the TypeScript to be written and ``PACKAGE`` is a desired TypeScript package name.\n+\n+Here's a complete example that generates TypeScript from a project produced from the standard \"skeleton\" template.\n+\n+.. code-block:: bash\n+   :linenos:\n+\n+   daml new my-proj skeleton # Create a new project based off the skeleton template\n+   cd my-proj # Enter the newly created project directory\n+   daml build  # Compile the project's DAML files into a DAR\n+   daml codegen ts .daml/dist/my-proj-0.0.1.dar -o generated/ts --main-package-name=my-proj # Generate Typescript from the DAR\n+\n+- On execution of these commands:\n+\n+  - The directory ``my-proj/generated/ts`` contains the generated TypeScript source files;\n+  - The files are arranged into directories;\n+  - One of those directories will be named as per the ``PACKAGE`` argument and will contain the TypeScript definitions corresponding to the DAML files in the project;\n+  - For example, ``generated/ts/my-proj/Main.ts`` contains the TypeScript definitions for ``daml/Main.daml``;\n+  - The remaining directories contain supporting TypeScript corresponding to modules of the DAML standard library;\n+  - Those directories have numeric names (the names are hashes of the DAML-LF package they are derived from).\n+\n+To get a quickstart idea of how to use what has been generated, you may wish to jump to the `Templates and choices`_ section and return to the reference material that follows as needed.\n+\n+Primitive DAML types: @daml/types\n+---------------------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the TypeScript equivalents of the primitive DAML types provided by @daml/types.\n \n **Interfaces**:\n \n-- ``Serializable<T>``\n - ``Template<T extends object, K = unknown>``\n - ``Choice<T extends object, C, R, K = unknown>``\n \n-  ..\n-        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n-        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n-        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n-\n **Types**:\n \n-+-------------------+------------------+----------------------------------+\n-| TypeScript        | DAML equiv.      | TypeScript definition            |\n-+===================+==================+==================================+\n-| ``Unit``          | ``()``           | ``{}``                           |\n-+-------------------+------------------+----------------------------------+\n-| ``Bool``          | ``Bool``         | ``boolean``                      |\n-+-------------------+------------------+----------------------------------+\n-| ``Int``           | ``Int``          | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Decimal``       | ``Decimal``      | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Numeric``       | ``Numeric n``    | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Text``          | ``Text``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Time``          | ``Time``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Party``         | ``Party``        | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``List<T>``       | ``[t]``          | ``T[]``                          |\n-+-------------------+------------------+----------------------------------+\n-| ``Date``          | ``Date``         | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n-+-------------------+------------------+----------------------------------+\n-| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n-|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n-+-------------------+------------------+----------------------------------+\n-| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n-+-------------------+------------------+----------------------------------+\n++-------------------+--------------------+----------------------------------+\n+| DAML              | TypeScript         | TypeScript definition            |\n++===================+====================+==================================+\n+| ``()``            | ``Unit``           | ``{}``                           |\n++-------------------+--------------------+----------------------------------+\n+| ``Bool``          | ``Bool``           | ``boolean``                      |\n++-------------------+--------------------+----------------------------------+\n+| ``Int``           | ``Int``            | ``string``                       |"
  },
  {
    "id" : "563cd7db-9928-44ba-9a18-a37343b03aaf",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "b540dc85-c6c6-4da7-af97-36bfc4fb4b50",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nThe code that ``daml2ts`` generates is expressed in terms of the packages `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\r\n```\r\nThis package has been renamed on master",
        "createdAt" : "2020-01-24T08:33:40Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2dd7e3bb-8f96-4645-a261-b974caa0b9ba",
        "parentId" : "b540dc85-c6c6-4da7-af97-36bfc4fb4b50",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't think it's important to mention the `json-type-validation` library. In fact, I consider this an implementation detail and hence mentioning it might be harmful.",
        "createdAt" : "2020-01-24T08:35:09Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "404d007f-812a-4352-bb17-f14b7ae060a6",
        "parentId" : "b540dc85-c6c6-4da7-af97-36bfc4fb4b50",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-24T16:21:26Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet."
  },
  {
    "id" : "87d6bc0c-1840-4d29-99e2-073f94b39449",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "d55f58fd-e83e-41ed-8ff0-d58ba736f499",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't think showing this preamble is very helpful. The lint warnings are not relevant to the user, `json-type-validation` is an implementation detail and the import of `@daml/types` follows from what's written above.",
        "createdAt" : "2020-01-24T08:37:00Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "76bc992d-6a49-4b43-82bb-bea6f3395ed3",
        "parentId" : "d55f58fd-e83e-41ed-8ff0-d58ba736f499",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-24T16:21:48Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';"
  },
  {
    "id" : "890256e3-8034-4787-9e99-fac71fd7034d",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "aa874f0b-f10b-4807-88ca-0bb52b4dbd2a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would say how `Serializable<T>` actually looks like is another implementation detail. But we should mention it. I would consider as something called a \"marker trait\" in Rust. It marks that a type is serializable. We should also mention that it corresponds to the notion of serializable types in DAML.",
        "createdAt" : "2020-01-24T08:39:20Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f0d21691-c372-492e-8c6e-1b88511a37a4",
        "parentId" : "aa874f0b-f10b-4807-88ca-0bb52b4dbd2a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Didn't get to it yet but noted.",
        "createdAt" : "2020-01-24T16:22:07Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``."
  },
  {
    "id" : "e786bd77-ffaa-41d9-9392-cb046d7c5481",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "cf77a7f7-ea80-4ff7-884f-e5f731354874",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Again, I don't think the actual structure of `Template` is important but rather it's purpose: It's an interface for companion objects that correspond to templates in DAML. Similar for `Choice`.",
        "createdAt" : "2020-01-24T08:40:31Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7d5a9f20-4c15-4006-a962-a276391e9803",
        "parentId" : "cf77a7f7-ea80-4ff7-884f-e5f731354874",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-24T16:22:20Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``"
  },
  {
    "id" : "72694254-5c9c-4f80-8349-7b795b18f2ae",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "239a094b-1808-47c0-9932-ffedfeeaefa0",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Same comment as above regarding implementation details.",
        "createdAt" : "2020-01-24T08:41:33Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "39a36091-e4d8-4d2d-82e7-8ef1b7d9cd59",
        "parentId" : "239a094b-1808-47c0-9932-ffedfeeaefa0",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-24T16:22:29Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({"
  },
  {
    "id" : "4e7c0303-652a-482a-b3d7-cc9bd1c2c7c4",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "ba4c80fc-e695-4698-b3ac-4d8b6103a724",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n``daml2ts`` generates TypeScript code for interacting with a DAML model via the `json-api <../json-api/index.html>`_ . It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\r\n```",
        "createdAt" : "2020-01-24T12:56:34Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d31d23b1-d58f-4b87-9d62-7803b6dfbf92",
        "parentId" : "ba4c80fc-e695-4698-b3ac-4d8b6103a724",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Accepted. Thanks!",
        "createdAt" : "2020-01-24T14:49:38Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds."
  },
  {
    "id" : "3dbdaeae-82f0-4414-9a36-83491a7496d4",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "079bf791-ed14-46e6-84aa-b50b1400a76f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n     Person with\r\n```",
        "createdAt" : "2020-01-24T13:02:11Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person"
  },
  {
    "id" : "2f446dcc-78f7-4dc3-9fda-12a945293477",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "0bc00f63-4ff7-4fd8-ab9f-3e2d5818ffca",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nDAML to TypeScript mappings\r\n```\r\nThat’s how typescript is capitalized on the official web page https://www.typescriptlang.org/ so we should follow that. There are quite a few occurences here but I’ll refrain from marking all of them since it’s just a search and replace anyway to fix all of them.",
        "createdAt" : "2020-01-24T13:07:55Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2c273e0d-edb3-4cae-b0a8-eb030eac3365",
        "parentId" : "0bc00f63-4ff7-4fd8-ab9f-3e2d5818ffca",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Thank-you. Will fix!",
        "createdAt" : "2020-01-24T14:49:55Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings"
  },
  {
    "id" : "82ae108f-575a-4a55-b684-8793a1b67e59",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "10072fb9-0bf6-491c-aa0b-4e45b7e4ee9d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think this could use an explanation that `40…f7` is the package id. I would also recommend to import it as `pkg_…` to make it clear that `pkg` is just a prefix (presumably that prefix is needed since the identifier cannot start with a number?",
        "createdAt" : "2020-01-24T13:11:57Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f6e3cc85-fd5c-4058-bd29-dbb9fc382312",
        "parentId" : "10072fb9-0bf6-491c-aa0b-4e45b7e4ee9d",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "This is going to go away. After consultation with Martin we have decided to gloss over some detail of which this will be one.",
        "createdAt" : "2020-01-24T14:51:27Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person\n+       name : Text\n+       party : Party\n+       age : a\n+\n+In this case, the generated Typescript would read like the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Person<a> = {\n+     name: string;\n+     party: daml.Party;\n+     age: a;\n+   }\n+\n+   export const Person = <a>(a: daml.Serializable<a>): daml.Serializable<Person<a>> => ({\n+     decoder: () => jtv.object({\n+       name: daml.Text.decoder(),\n+       party: daml.Party.decoder(),\n+       age: a.decoder(),\n+     }),\n+   })\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In Typescript, the above definition renders as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';"
  },
  {
    "id" : "d90dccbd-0f49-4741-bd07-8d293c7af08c",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "d63f9ddb-6796-4a40-b70a-bb7695e573e9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It’s a bit unclear from this paragraph that this is not something that is specific to the typescript codegen but rather that this is just how the types are represented in DAML-LF.",
        "createdAt" : "2020-01-24T13:14:06Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1333e135-d335-46fc-981e-253dc91c3ff2",
        "parentId" : "d63f9ddb-6796-4a40-b70a-bb7695e573e9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "This is another detail that is going to get removed. We are just going to inline `{ _1: a, _2: b }` and do away with these technical details in this documentation altogether (except perhaps for a note explaining that we have omitted them).",
        "createdAt" : "2020-01-24T14:55:32Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person\n+       name : Text\n+       party : Party\n+       age : a\n+\n+In this case, the generated Typescript would read like the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Person<a> = {\n+     name: string;\n+     party: daml.Party;\n+     age: a;\n+   }\n+\n+   export const Person = <a>(a: daml.Serializable<a>): daml.Serializable<Person<a>> => ({\n+     decoder: () => jtv.object({\n+       name: daml.Text.decoder(),\n+       party: daml.Party.decoder(),\n+       age: a.decoder(),\n+     }),\n+   })\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In Typescript, the above definition renders as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Pair<a, b> =\n+     |  { tag: 'Pair'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<a, b> }\n+\n+   export const Pair = <a, b>(a: daml.Serializable<a>, b: daml.Serializable<b>): daml.Serializable<Pair<a, b>> => ({\n+     decoder: () => jtv.oneOf<Pair<a, b>>(\n+       jtv.object({tag: jtv.constant('Pair'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(a, b).decoder())}),\n+     ),\n+   });\n+\n+What we are interested in here is the treatment of the tuple type ``(a, b)``. As the above shows, its presence has been captured by a type ``Tuple2<a, b>`` from a package generated from the DAML standard library. Here is the definition."
  },
  {
    "id" : "51c55741-ead1-453c-9384-94a075150666",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "ef18eae1-3be1-4df1-8faa-af71492e70c2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You call them `discriminated union`s here only to start with a section called `Variants` below. I think it would make sense to be consistent.",
        "createdAt" : "2020-01-24T13:15:17Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8691b842-6c74-438f-a682-3f033a9b1b11",
        "parentId" : "ef18eae1-3be1-4df1-8faa-af71492e70c2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ha. The mismatch is that TS terminology is discriminated union types and the sections are named for DAML types.  I'll work something out 😃 ",
        "createdAt" : "2020-01-24T14:52:33Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person\n+       name : Text\n+       party : Party\n+       age : a\n+\n+In this case, the generated Typescript would read like the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Person<a> = {\n+     name: string;\n+     party: daml.Party;\n+     age: a;\n+   }\n+\n+   export const Person = <a>(a: daml.Serializable<a>): daml.Serializable<Person<a>> => ({\n+     decoder: () => jtv.object({\n+       name: daml.Text.decoder(),\n+       party: daml.Party.decoder(),\n+       age: a.decoder(),\n+     }),\n+   })\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In Typescript, the above definition renders as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Pair<a, b> =\n+     |  { tag: 'Pair'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<a, b> }\n+\n+   export const Pair = <a, b>(a: daml.Serializable<a>, b: daml.Serializable<b>): daml.Serializable<Pair<a, b>> => ({\n+     decoder: () => jtv.oneOf<Pair<a, b>>(\n+       jtv.object({tag: jtv.constant('Pair'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(a, b).decoder())}),\n+     ),\n+   });\n+\n+What we are interested in here is the treatment of the tuple type ``(a, b)``. As the above shows, its presence has been captured by a type ``Tuple2<a, b>`` from a package generated from the DAML standard library. Here is the definition.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Tuple2<t1, t2> = {\n+     _1: t1;\n+     _2: t2;\n+   }\n+   export const Tuple2 = <t1, t2>(t1: daml.Serializable<t1>, t2: daml.Serializable<t2>): daml.Serializable<Tuple2<t1, t2>> => ({\n+     decoder: () => jtv.object({\n+       _1: t1.decoder(),\n+       _2: t2.decoder(),\n+     }),\n+   })\n+\n+The DAML type that the above is generated from is exactly this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Tuple2 a b =\n+       Tuple2 with\n+         _1 : a\n+         _2 : b\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in Typescript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled in Typescript as a discriminated union with a single case. We'll see more discriminated unions in the next section."
  },
  {
    "id" : "d3c3a6bc-47eb-409b-811a-26bfef060143",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "2a97a918-5ea2-4ed6-ba8a-7a36adf9c06b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You’ve already shown an example of polymorphism above. Does this one provide anything new to the reader?",
        "createdAt" : "2020-01-24T13:16:24Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5c6f9a31-f014-43b5-8327-5c808f7db228",
        "parentId" : "2a97a918-5ea2-4ed6-ba8a-7a36adf9c06b",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "In the next iteration there will be no separate sub-sections for mono vs. polymorphic types (they only result in meaningful differences in the generated serialization code which will not be covered by this guide anymore).",
        "createdAt" : "2020-01-24T14:56:54Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person\n+       name : Text\n+       party : Party\n+       age : a\n+\n+In this case, the generated Typescript would read like the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Person<a> = {\n+     name: string;\n+     party: daml.Party;\n+     age: a;\n+   }\n+\n+   export const Person = <a>(a: daml.Serializable<a>): daml.Serializable<Person<a>> => ({\n+     decoder: () => jtv.object({\n+       name: daml.Text.decoder(),\n+       party: daml.Party.decoder(),\n+       age: a.decoder(),\n+     }),\n+   })\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In Typescript, the above definition renders as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Pair<a, b> =\n+     |  { tag: 'Pair'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<a, b> }\n+\n+   export const Pair = <a, b>(a: daml.Serializable<a>, b: daml.Serializable<b>): daml.Serializable<Pair<a, b>> => ({\n+     decoder: () => jtv.oneOf<Pair<a, b>>(\n+       jtv.object({tag: jtv.constant('Pair'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(a, b).decoder())}),\n+     ),\n+   });\n+\n+What we are interested in here is the treatment of the tuple type ``(a, b)``. As the above shows, its presence has been captured by a type ``Tuple2<a, b>`` from a package generated from the DAML standard library. Here is the definition.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Tuple2<t1, t2> = {\n+     _1: t1;\n+     _2: t2;\n+   }\n+   export const Tuple2 = <t1, t2>(t1: daml.Serializable<t1>, t2: daml.Serializable<t2>): daml.Serializable<Tuple2<t1, t2>> => ({\n+     decoder: () => jtv.object({\n+       _1: t1.decoder(),\n+       _2: t2.decoder(),\n+     }),\n+   })\n+\n+The DAML type that the above is generated from is exactly this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Tuple2 a b =\n+       Tuple2 with\n+         _1 : a\n+         _2 : b\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in Typescript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled in Typescript as a discriminated union with a single case. We'll see more discriminated unions in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+Basic\n+*****\n+\n+This DAML example defines a type for the language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr =\n+       Lit Int\n+     | Var Text\n+     | Add (Expr, Expr)\n+\n+In Typescript, the type is represented as a discriminated union. The ``Add`` branch of the type utilizes a 2-element tuple.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Expr =\n+     |  { tag: 'Lit'; value: daml.Int }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<Expr, Expr> }\n+\n+   export const Expr:\n+     daml.Serializable<Expr> & {\n+     } = ({\n+     decoder: () => jtv.oneOf<Expr>(\n+       jtv.object({tag: jtv.constant('L'), value: jtv.lazy(() => daml.Int.decoder())}),\n+       jtv.object({tag: jtv.constant('V'), value: jtv.lazy(() => daml.Text.decoder())}),\n+       jtv.object({tag: jtv.constant('A'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(Expr, Expr).decoder())}),\n+     ),\n+   });\n+\n+Generic\n+*******\n+\n+Suppose we tweak the above expression type so that it is polymorphic in the type of literals."
  },
  {
    "id" : "a1266868-4e30-4ff0-9aa7-3c8a7085cfc2",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "08b864f6-85fe-4ee8-883a-a358be10bf49",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is missing the most important part for me as a user. How do I invoke it and include the generated code in my project?",
        "createdAt" : "2020-01-24T13:17:34Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d0b49ed4-15f9-4929-b266-0f6a497353e3",
        "parentId" : "08b864f6-85fe-4ee8-883a-a358be10bf49",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "It's coming. Documenting how to invoke `daml2ts` is a pending task - first we have to get it behind the assistant. For now, the focus here is on just explaining what it generates.",
        "createdAt" : "2020-01-24T14:53:56Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person\n+       name : Text\n+       party : Party\n+       age : a\n+\n+In this case, the generated Typescript would read like the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Person<a> = {\n+     name: string;\n+     party: daml.Party;\n+     age: a;\n+   }\n+\n+   export const Person = <a>(a: daml.Serializable<a>): daml.Serializable<Person<a>> => ({\n+     decoder: () => jtv.object({\n+       name: daml.Text.decoder(),\n+       party: daml.Party.decoder(),\n+       age: a.decoder(),\n+     }),\n+   })\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In Typescript, the above definition renders as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Pair<a, b> =\n+     |  { tag: 'Pair'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<a, b> }\n+\n+   export const Pair = <a, b>(a: daml.Serializable<a>, b: daml.Serializable<b>): daml.Serializable<Pair<a, b>> => ({\n+     decoder: () => jtv.oneOf<Pair<a, b>>(\n+       jtv.object({tag: jtv.constant('Pair'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(a, b).decoder())}),\n+     ),\n+   });\n+\n+What we are interested in here is the treatment of the tuple type ``(a, b)``. As the above shows, its presence has been captured by a type ``Tuple2<a, b>`` from a package generated from the DAML standard library. Here is the definition.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Tuple2<t1, t2> = {\n+     _1: t1;\n+     _2: t2;\n+   }\n+   export const Tuple2 = <t1, t2>(t1: daml.Serializable<t1>, t2: daml.Serializable<t2>): daml.Serializable<Tuple2<t1, t2>> => ({\n+     decoder: () => jtv.object({\n+       _1: t1.decoder(),\n+       _2: t2.decoder(),\n+     }),\n+   })\n+\n+The DAML type that the above is generated from is exactly this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Tuple2 a b =\n+       Tuple2 with\n+         _1 : a\n+         _2 : b\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in Typescript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled in Typescript as a discriminated union with a single case. We'll see more discriminated unions in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+Basic\n+*****\n+\n+This DAML example defines a type for the language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr =\n+       Lit Int\n+     | Var Text\n+     | Add (Expr, Expr)\n+\n+In Typescript, the type is represented as a discriminated union. The ``Add`` branch of the type utilizes a 2-element tuple.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Expr =\n+     |  { tag: 'Lit'; value: daml.Int }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<Expr, Expr> }\n+\n+   export const Expr:\n+     daml.Serializable<Expr> & {\n+     } = ({\n+     decoder: () => jtv.oneOf<Expr>(\n+       jtv.object({tag: jtv.constant('L'), value: jtv.lazy(() => daml.Int.decoder())}),\n+       jtv.object({tag: jtv.constant('V'), value: jtv.lazy(() => daml.Text.decoder())}),\n+       jtv.object({tag: jtv.constant('A'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(Expr, Expr).decoder())}),\n+     ),\n+   });\n+\n+Generic\n+*******\n+\n+Suppose we tweak the above expression type so that it is polymorphic in the type of literals.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+The resulting Typescript will then generalize to this.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<Expr<a>, Expr<a>> }\n+\n+   export const Expr = <a>(a: daml.Serializable<a>): daml.Serializable<Expr<a>> => ({\n+     decoder: () => jtv.oneOf<Expr<a>>(\n+       jtv.object({tag: jtv.constant('Lit'), value: jtv.lazy(() => a.decoder())}),\n+       jtv.object({tag: jtv.constant('Var'), value: jtv.lazy(() => daml.Text.decoder())}),\n+       jtv.object({tag: jtv.constant('Add'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(Expr(a), Expr(a)).decoder())}),\n+     ),\n+   });\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+Foo.\n+\n+Basic\n+*****\n+Bar.\n+\n+Generic\n+*******\n+Baz.\n+\n+Enums\n+~~~~~\n+Foo, bar, baz.\n+\n+Templates and choices\n+~~~~~~~~~~~~~~~~~~~~~\n+Foo, bar, baz."
  },
  {
    "id" : "d8f8a45d-4921-485a-87f3-a447993838b0",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "f8fa8252-741a-4a65-ae82-076041b8442a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You already have a section called `Generic` above.",
        "createdAt" : "2020-01-24T13:17:57Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person\n+       name : Text\n+       party : Party\n+       age : a\n+\n+In this case, the generated Typescript would read like the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Person<a> = {\n+     name: string;\n+     party: daml.Party;\n+     age: a;\n+   }\n+\n+   export const Person = <a>(a: daml.Serializable<a>): daml.Serializable<Person<a>> => ({\n+     decoder: () => jtv.object({\n+       name: daml.Text.decoder(),\n+       party: daml.Party.decoder(),\n+       age: a.decoder(),\n+     }),\n+   })\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In Typescript, the above definition renders as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Pair<a, b> =\n+     |  { tag: 'Pair'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<a, b> }\n+\n+   export const Pair = <a, b>(a: daml.Serializable<a>, b: daml.Serializable<b>): daml.Serializable<Pair<a, b>> => ({\n+     decoder: () => jtv.oneOf<Pair<a, b>>(\n+       jtv.object({tag: jtv.constant('Pair'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(a, b).decoder())}),\n+     ),\n+   });\n+\n+What we are interested in here is the treatment of the tuple type ``(a, b)``. As the above shows, its presence has been captured by a type ``Tuple2<a, b>`` from a package generated from the DAML standard library. Here is the definition.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Tuple2<t1, t2> = {\n+     _1: t1;\n+     _2: t2;\n+   }\n+   export const Tuple2 = <t1, t2>(t1: daml.Serializable<t1>, t2: daml.Serializable<t2>): daml.Serializable<Tuple2<t1, t2>> => ({\n+     decoder: () => jtv.object({\n+       _1: t1.decoder(),\n+       _2: t2.decoder(),\n+     }),\n+   })\n+\n+The DAML type that the above is generated from is exactly this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Tuple2 a b =\n+       Tuple2 with\n+         _1 : a\n+         _2 : b\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in Typescript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled in Typescript as a discriminated union with a single case. We'll see more discriminated unions in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+Basic\n+*****\n+\n+This DAML example defines a type for the language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr =\n+       Lit Int\n+     | Var Text\n+     | Add (Expr, Expr)\n+\n+In Typescript, the type is represented as a discriminated union. The ``Add`` branch of the type utilizes a 2-element tuple.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Expr =\n+     |  { tag: 'Lit'; value: daml.Int }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<Expr, Expr> }\n+\n+   export const Expr:\n+     daml.Serializable<Expr> & {\n+     } = ({\n+     decoder: () => jtv.oneOf<Expr>(\n+       jtv.object({tag: jtv.constant('L'), value: jtv.lazy(() => daml.Int.decoder())}),\n+       jtv.object({tag: jtv.constant('V'), value: jtv.lazy(() => daml.Text.decoder())}),\n+       jtv.object({tag: jtv.constant('A'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(Expr, Expr).decoder())}),\n+     ),\n+   });\n+\n+Generic\n+*******\n+\n+Suppose we tweak the above expression type so that it is polymorphic in the type of literals.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+The resulting Typescript will then generalize to this.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<Expr<a>, Expr<a>> }\n+\n+   export const Expr = <a>(a: daml.Serializable<a>): daml.Serializable<Expr<a>> => ({\n+     decoder: () => jtv.oneOf<Expr<a>>(\n+       jtv.object({tag: jtv.constant('Lit'), value: jtv.lazy(() => a.decoder())}),\n+       jtv.object({tag: jtv.constant('Var'), value: jtv.lazy(() => daml.Text.decoder())}),\n+       jtv.object({tag: jtv.constant('Add'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(Expr(a), Expr(a)).decoder())}),\n+     ),\n+   });\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+Foo.\n+\n+Basic\n+*****\n+Bar.\n+\n+Generic"
  },
  {
    "id" : "3c5054fb-68ee-46b3-8d25-537d6003e415",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "a95be99a-641b-4007-a332-beef825ae7c9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You already haev a section called `Basic` above.",
        "createdAt" : "2020-01-24T13:18:12Z",
        "updatedAt" : "2020-01-24T22:36:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,291 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+Typescript!\n+###########\n+\n+daml2ts : Typescript of DAML\n+============================\n+\n+Introduction\n+------------\n+``daml2ts`` generates `json-api <../json-api/index.html>`_ compatible Typescript code. It accepts compiled DAML modules as input. The Typescript source files it produces contain type, value and function definitions that model the DAML entities it finds.\n+\n+The code that ``daml2ts`` generates is expressed in terms of the packages `@digital-asset/daml-types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_ and `@mojotech/json-type-validation <https://github.com/mojotech/json-type-validation>`_ packages. Accordingly, every Typescript file generated begins with the following snippet.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   /* eslint-disable @typescript-eslint/camelcase */\n+   /* eslint-disable @typescript-eslint/no-use-before-define */\n+   import * as jtv from '@mojotech/json-type-validation';\n+   import * as daml from '@digitalasset/daml-types';\n+\n+@digitalasset/daml-types primitives\n+------------------------------------\n+\n+To understand the Typescript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @digitalasset/daml-types.\n+\n+**Interfaces**:\n+\n+``Serializable<T>``\n+  An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+``Template<T extends object, K = unknown>``\n+  An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+``Choice<T extends object, C, R, K = unknown>``\n+  An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| Typescript        | DAML equiv.      | Typescript definition            | Companion object or function                                        |\n++===================+==================+==================================+=====================================================================+\n+| ``Unit``          | ``()``           | ``{}``                           | ``Unit: Serializable<Unit>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      | ``Bool: Serializable<Bool>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       | ``Int: Serializable<Int>``                                          |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       | ``Decimal: Serializable<Decimal>``                                  |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       | ``Numeric: (n: number) => Serializable<Numeric>``                   |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       | ``Text: Serializable<Text>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       | ``Time: Serializable<Time>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       | ``Party: Serializable<Party>``                                      |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          | ``List: (t: Serializable<T>) => Serializable<List<T>>``             |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       | ``Date: Serializable<Date>``                                        |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       | ``ContractId: (t: Serializable<T>) => Serializable<ContractId<T>>`` |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     | ``Optional: (t: Serializable<T>) => Serializable<Optional<T>>``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |                                                                     |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         | ``TextMap: (t: Serializable<T>) => Serializable<TextMap<T>>``       |\n++-------------------+------------------+----------------------------------+---------------------------------------------------------------------+\n+\n+DAML to Typescript mappings\n+---------------------------\n+\n+The mappings from DAML to Typescript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+Basic\n+*****\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person\n+       name : Text\n+       party : Party\n+       age : Int\n+\n+Given the above definition, the generated Typescript code will be as follows.\n+\n+   .. code-block:: typescript\n+      :linenos:\n+\n+      export type Person = {\n+        name: string;\n+        party: daml.Party;\n+        age: daml.Int;\n+      }\n+\n+      export const Person: daml.Serializable<Person> = ({\n+        decoder: () => jtv.object({\n+          name: daml.Text.decoder(),\n+          party: daml.Party.decoder(),\n+          aage: daml.Int.decoder(),\n+        }),\n+      })\n+\n+Generic\n+*******\n+\n+In the above case, ``Person`` is a monomorphic type. If we change it slightly so that it is polymorphic in the type of ``age``, it would look like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person a =\n+     Person\n+       name : Text\n+       party : Party\n+       age : a\n+\n+In this case, the generated Typescript would read like the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Person<a> = {\n+     name: string;\n+     party: daml.Party;\n+     age: a;\n+   }\n+\n+   export const Person = <a>(a: daml.Serializable<a>): daml.Serializable<Person<a>> => ({\n+     decoder: () => jtv.object({\n+       name: daml.Text.decoder(),\n+       party: daml.Party.decoder(),\n+       age: a.decoder(),\n+     }),\n+   })\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In Typescript, the above definition renders as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Pair<a, b> =\n+     |  { tag: 'Pair'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<a, b> }\n+\n+   export const Pair = <a, b>(a: daml.Serializable<a>, b: daml.Serializable<b>): daml.Serializable<Pair<a, b>> => ({\n+     decoder: () => jtv.oneOf<Pair<a, b>>(\n+       jtv.object({tag: jtv.constant('Pair'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(a, b).decoder())}),\n+     ),\n+   });\n+\n+What we are interested in here is the treatment of the tuple type ``(a, b)``. As the above shows, its presence has been captured by a type ``Tuple2<a, b>`` from a package generated from the DAML standard library. Here is the definition.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   export type Tuple2<t1, t2> = {\n+     _1: t1;\n+     _2: t2;\n+   }\n+   export const Tuple2 = <t1, t2>(t1: daml.Serializable<t1>, t2: daml.Serializable<t2>): daml.Serializable<Tuple2<t1, t2>> => ({\n+     decoder: () => jtv.object({\n+       _1: t1.decoder(),\n+       _2: t2.decoder(),\n+     }),\n+   })\n+\n+The DAML type that the above is generated from is exactly this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Tuple2 a b =\n+       Tuple2 with\n+         _1 : a\n+         _2 : b\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in Typescript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled in Typescript as a discriminated union with a single case. We'll see more discriminated unions in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+Basic\n+*****\n+\n+This DAML example defines a type for the language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr =\n+       Lit Int\n+     | Var Text\n+     | Add (Expr, Expr)\n+\n+In Typescript, the type is represented as a discriminated union. The ``Add`` branch of the type utilizes a 2-element tuple.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Expr =\n+     |  { tag: 'Lit'; value: daml.Int }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<Expr, Expr> }\n+\n+   export const Expr:\n+     daml.Serializable<Expr> & {\n+     } = ({\n+     decoder: () => jtv.oneOf<Expr>(\n+       jtv.object({tag: jtv.constant('L'), value: jtv.lazy(() => daml.Int.decoder())}),\n+       jtv.object({tag: jtv.constant('V'), value: jtv.lazy(() => daml.Text.decoder())}),\n+       jtv.object({tag: jtv.constant('A'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(Expr, Expr).decoder())}),\n+     ),\n+   });\n+\n+Generic\n+*******\n+\n+Suppose we tweak the above expression type so that it is polymorphic in the type of literals.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+The resulting Typescript will then generalize to this.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   import * as pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types from './../40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7/DA/Types';\n+\n+   export type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2<Expr<a>, Expr<a>> }\n+\n+   export const Expr = <a>(a: daml.Serializable<a>): daml.Serializable<Expr<a>> => ({\n+     decoder: () => jtv.oneOf<Expr<a>>(\n+       jtv.object({tag: jtv.constant('Lit'), value: jtv.lazy(() => a.decoder())}),\n+       jtv.object({tag: jtv.constant('Var'), value: jtv.lazy(() => daml.Text.decoder())}),\n+       jtv.object({tag: jtv.constant('Add'), value: jtv.lazy(() => pkg40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7_DA_Types.Tuple2(Expr(a), Expr(a)).decoder())}),\n+     ),\n+   });\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+Foo.\n+\n+Basic"
  },
  {
    "id" : "5b381baf-679c-4a65-9434-785abbbbab9f",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "4d375f2f-ab0b-44eb-be08-104e1a3647bc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I understand you're excited but I'm not sure that makes a lot of sense to our users. I suggest something like\r\n> `daml2ts` - A TypeScript codegen for DAML",
        "createdAt" : "2020-01-28T09:31:34Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 4,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!"
  },
  {
    "id" : "7afb527e-688a-4dc6-891c-0261c3971304",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "2172463a-cb4b-45c1-97df-d699ec3c93f0",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The code `daml2ts` generates uses the library...",
        "createdAt" : "2020-01-28T09:32:23Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6c3adea1-9079-4c50-96b3-3f6582c7dfbf",
        "parentId" : "2172463a-cb4b-45c1-97df-d699ec3c93f0",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-29T13:57:54Z",
        "updatedAt" : "2020-01-29T13:57:54Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 17,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_."
  },
  {
    "id" : "5a36439c-370c-489e-add1-8110f7504f01",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "36b2bb84-3e9c-4943-b42e-15e75a99d992",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's not tell our users about this one. It's an implementation detail and doesn't make too much sense when you don't also talk about the companion objects, which I would like to avoid.",
        "createdAt" : "2020-01-28T09:34:03Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 26,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``"
  },
  {
    "id" : "7d461980-7ee2-447e-94a2-caf606f568dd",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "508ee36b-f688-4508-ab84-780e0ad74567",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's remove the decoder stuff from here. It's an implementation detail and nobody knows what `jtv` refers to anyway. An object \"implements\" an interface rather than \"extends\" it. I would say something like\r\n\r\n> An object that implements the `Template<T, K>` interface provides metadata for a template of type `T` with a potential contract key of type `K`, where the absence of contract key is marked by `K = undefined`. Such metadata includes the name of the template, the module and package where it is defined, and a description of the types `T` and `K`.\r\n\r\nSimilarly for choices.",
        "createdAt" : "2020-01-28T09:42:17Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5810d8c0-8b72-4bb2-b638-b73fcb6b9f04",
        "parentId" : "508ee36b-f688-4508-ab84-780e0ad74567",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Oops. Sorry not obvious (since you're reviewing the ReST), that section you are commenting on is a comment 😄 .",
        "createdAt" : "2020-01-28T10:40:58Z",
        "updatedAt" : "2020-01-28T10:40:59Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f5caab90-c576-44fe-94e6-22589b5e6cc3",
        "parentId" : "508ee36b-f688-4508-ab84-780e0ad74567",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ \r\n",
        "createdAt" : "2020-01-29T13:54:37Z",
        "updatedAt" : "2020-01-29T13:54:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 33,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``."
  },
  {
    "id" : "21088633-0867-4446-8cb2-e4322ff39f24",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "5da7acb4-2a93-4a9e-92a4-f7cef6a02404",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The first column should be the DAML type. That's what we get as input and users want to know how it gets converted into TS. Maybe this whole section should make this clear by having some like `Primitive DAML types` as its heading and then explaining that `@daml/types` contains TS equivalents of these types.",
        "createdAt" : "2020-01-28T09:44:47Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f8456dc0-b5bf-4270-b76f-82d10fe1eba4",
        "parentId" : "5da7acb4-2a93-4a9e-92a4-f7cef6a02404",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I will alter the table to lead with the DAML type and change the heading.",
        "createdAt" : "2020-01-29T14:06:11Z",
        "updatedAt" : "2020-01-29T14:06:11Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8425f41b-7050-42a8-b5b1-053793c69b24",
        "parentId" : "5da7acb4-2a93-4a9e-92a4-f7cef6a02404",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-29T14:20:52Z",
        "updatedAt" : "2020-01-29T14:20:52Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 38,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |"
  },
  {
    "id" : "ac19fca6-1474-4171-988c-71ae0e6c79d6",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "86fdc0ee-31d7-4c4d-8375-8957e3c4952e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Nice!",
        "createdAt" : "2020-01-28T09:45:20Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 72,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**)."
  },
  {
    "id" : "8f02af63-4e1d-4e44-97fa-8156ec9a9020",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "e708c552-c2d6-4139-9bd5-ee093d56228d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would move this on the line before. Then the DAML and the TS look a bit closer.",
        "createdAt" : "2020-01-28T09:46:16Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8c632631-fa1d-41e2-8660-7178c65a1f6b",
        "parentId" : "e708c552-c2d6-4139-9bd5-ee093d56228d",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-29T14:00:11Z",
        "updatedAt" : "2020-01-29T14:00:11Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 88,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with"
  },
  {
    "id" : "ebc51f19-36b3-439e-bbbd-296253fe8551",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "33d158b4-afbb-4fbe-b9c2-9e20e6631e80",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should move tuples up into the big table. This section is more about variants that about tuples.",
        "createdAt" : "2020-01-28T09:48:25Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d51971bf-9ea3-4552-9239-67d5498d50de",
        "parentId" : "33d158b4-afbb-4fbe-b9c2-9e20e6631e80",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I'm not clear on how to do that. I thought I did a pretty good job on this (slightly challenging) section. Do you feel strongly about this?",
        "createdAt" : "2020-01-29T14:02:22Z",
        "updatedAt" : "2020-01-29T14:02:22Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d444ae2f-a21f-4c13-99a4-74ffe4eee274",
        "parentId" : "33d158b4-afbb-4fbe-b9c2-9e20e6631e80",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "To me, it feels like we're in a section about data type definitions here. That's why tuples don't fit well. You can't define them yourself but they are defined in the stdlib. I guess that's what made this section challenging.\r\n\r\nI suggest we add rows to the big table above:\r\n```\r\n+-----------+-------------------------+\r\n| DAML      | TypeScript              |\r\n+-----------+-------------------------+\r\n| (a, b)    | { _1: a; _2: b }        |\r\n| (a, b, c) | { _1: a; _2: b; _3: c } |\r\n+-----------+-------------------------+\r\n```\r\n And also add a remark that `n`-tuples for `n > 3` work analogously.",
        "createdAt" : "2020-01-29T14:24:34Z",
        "updatedAt" : "2020-01-29T14:24:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "26ba9402-dd3f-4a91-bc04-2097d1818f93",
        "parentId" : "33d158b4-afbb-4fbe-b9c2-9e20e6631e80",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Got it. Moving to the big table!",
        "createdAt" : "2020-01-30T13:30:47Z",
        "updatedAt" : "2020-01-30T13:30:48Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 104,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with\n+       name: Text\n+       party: Party\n+       age: Int\n+\n+Given the above definition, the generated TypeScript code will be as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Person = {\n+     name: string;\n+     party: daml.Party;\n+     age: daml.Int;\n+   }\n+\n+Tuples"
  },
  {
    "id" : "eec3c0a8-dc27-4c14-85bf-4c00b2745256",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "226d9b7f-aed9-4dc9-bba3-23e2b88f70e3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It might make sense to put a link to the \"Discriminated Unions\" section in the TS handbook under the phrase \"discriminated union\".\r\nhttps://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions",
        "createdAt" : "2020-01-28T09:50:23Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5b5115dc-8ac9-450f-b240-54412e4d0869",
        "parentId" : "226d9b7f-aed9-4dc9-bba3-23e2b88f70e3",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-29T14:03:03Z",
        "updatedAt" : "2020-01-29T14:03:04Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 143,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with\n+       name: Text\n+       party: Party\n+       age: Int\n+\n+Given the above definition, the generated TypeScript code will be as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Person = {\n+     name: string;\n+     party: daml.Party;\n+     age: daml.Int;\n+   }\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In TypeScript, the above definition renders as below [1]_.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Pair<a, b> =\n+     |  { tag: 'Pair'; value: {_1: a, _2: b} }\n+\n+\n+.. [1] This is a simplification but it is not wrong to think of it this way.\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in TypeScript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled as a TypeScript discriminated union (with a single case). In general, all DAML variants are translated so as we will see in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+This is a DAML type for a language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+In TypeScript, it is represented as a discriminated union."
  },
  {
    "id" : "a4371510-cb89-4d7b-bfff-78d07259ad23",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "6d734504-2c37-4eb7-9a8e-c64b03a5319e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What's wrong with the dot here? Some weird unicode symbol?",
        "createdAt" : "2020-01-28T09:50:46Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8cff4de3-b8ab-438c-8da7-787e89ca8f99",
        "parentId" : "6d734504-2c37-4eb7-9a8e-c64b03a5319e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Dunno 😕 .\r\n",
        "createdAt" : "2020-01-29T13:56:53Z",
        "updatedAt" : "2020-01-29T13:56:53Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 156,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with\n+       name: Text\n+       party: Party\n+       age: Int\n+\n+Given the above definition, the generated TypeScript code will be as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Person = {\n+     name: string;\n+     party: daml.Party;\n+     age: daml.Int;\n+   }\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In TypeScript, the above definition renders as below [1]_.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Pair<a, b> =\n+     |  { tag: 'Pair'; value: {_1: a, _2: b} }\n+\n+\n+.. [1] This is a simplification but it is not wrong to think of it this way.\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in TypeScript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled as a TypeScript discriminated union (with a single case). In general, all DAML variants are translated so as we will see in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+This is a DAML type for a language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+In TypeScript, it is represented as a discriminated union.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: {_1: Expr<a>, _2: Expr<a>} }\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+\n+Let's slightly modify the ``Expr a`` type of the last section into the following."
  },
  {
    "id" : "96f6cfe5-950f-452b-8c50-2bdf47d6795e",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "aa493d94-f564-456f-bc19-2b0fbc405e60",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's not document the companion object for the `Transfer` type.",
        "createdAt" : "2020-01-28T09:53:10Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a103bba8-cbe9-404a-b679-6612b33c1ddc",
        "parentId" : "aa493d94-f564-456f-bc19-2b0fbc405e60",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-29T13:55:10Z",
        "updatedAt" : "2020-01-29T13:55:11Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 250,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with\n+       name: Text\n+       party: Party\n+       age: Int\n+\n+Given the above definition, the generated TypeScript code will be as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Person = {\n+     name: string;\n+     party: daml.Party;\n+     age: daml.Int;\n+   }\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In TypeScript, the above definition renders as below [1]_.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Pair<a, b> =\n+     |  { tag: 'Pair'; value: {_1: a, _2: b} }\n+\n+\n+.. [1] This is a simplification but it is not wrong to think of it this way.\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in TypeScript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled as a TypeScript discriminated union (with a single case). In general, all DAML variants are translated so as we will see in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+This is a DAML type for a language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+In TypeScript, it is represented as a discriminated union.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: {_1: Expr<a>, _2: Expr<a>} }\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+\n+Let's slightly modify the ``Expr a`` type of the last section into the following.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add {lhs: Expr a, rhs: Expr a}\n+\n+Compared to the earlier definition, the ``Add`` case is now in terms of a record with fields ``lhs`` and ``rhs``. This renders in TypeScript like so.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit2'; value: a }\n+     |  { tag: 'Var2'; value: string }\n+     |  { tag: 'Add'; value: Expr.Add<a> }\n+\n+   namespace Expr {\n+     type Add<a> = {\n+       lhs: Expr<a>;\n+       rhs: Expr<a>;\n+     }\n+   }\n+\n+The thing to note is how the definition of the ``Add`` case has given rise to a record type definition ``Expr.Add``.\n+\n+Enums\n+~~~~~\n+\n+DAML enumerations map naturally to TypeScript.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Color = Red | Blue | Yellow\n+\n+The companion TypeScript type is the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   enum Color {\n+     Red = 'Red',\n+     Blue = 'Blue',\n+     Yellow = 'Yellow',\n+   }\n+\n+Templates and choices\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+Here is a DAML template of a basic 'IOU' contract.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   template Iou\n+     with\n+       issuer: Party\n+       owner: Party\n+       currency: Text\n+       amount: Decimal\n+     where\n+       signatory issuer\n+       choice Transfer: ContractId Iou\n+         with\n+           newOwner: Party\n+         controller owner\n+         do\n+           create this with owner = newOwner\n+\n+``daml2ts`` generates types for each of the choices defined on the template as well as the template itself.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Transfer = {\n+     newOwner: daml.Party;\n+   }\n+\n+   type Iou = {\n+     issuer: daml.Party;\n+     owner: daml.Party;\n+     currency: string;\n+     amount: daml.Numeric;\n+   }\n+\n+Each template and each template choice also results in the generation of a companion object corresponding to the choice or template type. Here, is a schematic of the ones generated from the ``Iou`` template.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   const Transfer: daml.Serializable<Transfer> = ({"
  },
  {
    "id" : "358b266f-2391-48ca-9f2e-7e543448c80f",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "6dd16a12-3150-4c69-92c4-85d037cd2d8a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should very briefly mention that the `undefined` captures the fact that `Iou` has no contract key.",
        "createdAt" : "2020-01-28T09:54:15Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "806e51e6-0908-460f-9b93-28667f23e578",
        "parentId" : "6dd16a12-3150-4c69-92c4-85d037cd2d8a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-29T14:04:41Z",
        "updatedAt" : "2020-01-29T14:04:41Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 255,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with\n+       name: Text\n+       party: Party\n+       age: Int\n+\n+Given the above definition, the generated TypeScript code will be as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Person = {\n+     name: string;\n+     party: daml.Party;\n+     age: daml.Int;\n+   }\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In TypeScript, the above definition renders as below [1]_.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Pair<a, b> =\n+     |  { tag: 'Pair'; value: {_1: a, _2: b} }\n+\n+\n+.. [1] This is a simplification but it is not wrong to think of it this way.\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in TypeScript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled as a TypeScript discriminated union (with a single case). In general, all DAML variants are translated so as we will see in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+This is a DAML type for a language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+In TypeScript, it is represented as a discriminated union.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: {_1: Expr<a>, _2: Expr<a>} }\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+\n+Let's slightly modify the ``Expr a`` type of the last section into the following.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add {lhs: Expr a, rhs: Expr a}\n+\n+Compared to the earlier definition, the ``Add`` case is now in terms of a record with fields ``lhs`` and ``rhs``. This renders in TypeScript like so.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit2'; value: a }\n+     |  { tag: 'Var2'; value: string }\n+     |  { tag: 'Add'; value: Expr.Add<a> }\n+\n+   namespace Expr {\n+     type Add<a> = {\n+       lhs: Expr<a>;\n+       rhs: Expr<a>;\n+     }\n+   }\n+\n+The thing to note is how the definition of the ``Add`` case has given rise to a record type definition ``Expr.Add``.\n+\n+Enums\n+~~~~~\n+\n+DAML enumerations map naturally to TypeScript.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Color = Red | Blue | Yellow\n+\n+The companion TypeScript type is the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   enum Color {\n+     Red = 'Red',\n+     Blue = 'Blue',\n+     Yellow = 'Yellow',\n+   }\n+\n+Templates and choices\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+Here is a DAML template of a basic 'IOU' contract.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   template Iou\n+     with\n+       issuer: Party\n+       owner: Party\n+       currency: Text\n+       amount: Decimal\n+     where\n+       signatory issuer\n+       choice Transfer: ContractId Iou\n+         with\n+           newOwner: Party\n+         controller owner\n+         do\n+           create this with owner = newOwner\n+\n+``daml2ts`` generates types for each of the choices defined on the template as well as the template itself.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Transfer = {\n+     newOwner: daml.Party;\n+   }\n+\n+   type Iou = {\n+     issuer: daml.Party;\n+     owner: daml.Party;\n+     currency: string;\n+     amount: daml.Numeric;\n+   }\n+\n+Each template and each template choice also results in the generation of a companion object corresponding to the choice or template type. Here, is a schematic of the ones generated from the ``Iou`` template.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   const Transfer: daml.Serializable<Transfer> = ({\n+     /* ... */\n+     }),\n+   })\n+\n+   const Iou: daml.Template<Iou, undefined> & {"
  },
  {
    "id" : "50c4d9f2-3140-4faf-a9dd-add263ca44e7",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "734a18ad-960b-4ba9-922e-3d365643cf43",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Each template results in a companion object...",
        "createdAt" : "2020-01-28T09:56:03Z",
        "updatedAt" : "2020-01-28T09:57:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ea0f1b87-d447-456d-8098-143effa121d1",
        "parentId" : "734a18ad-960b-4ba9-922e-3d365643cf43",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-29T13:55:51Z",
        "updatedAt" : "2020-01-29T13:55:51Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 245,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with\n+       name: Text\n+       party: Party\n+       age: Int\n+\n+Given the above definition, the generated TypeScript code will be as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Person = {\n+     name: string;\n+     party: daml.Party;\n+     age: daml.Int;\n+   }\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In TypeScript, the above definition renders as below [1]_.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Pair<a, b> =\n+     |  { tag: 'Pair'; value: {_1: a, _2: b} }\n+\n+\n+.. [1] This is a simplification but it is not wrong to think of it this way.\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in TypeScript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled as a TypeScript discriminated union (with a single case). In general, all DAML variants are translated so as we will see in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+This is a DAML type for a language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+In TypeScript, it is represented as a discriminated union.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: {_1: Expr<a>, _2: Expr<a>} }\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+\n+Let's slightly modify the ``Expr a`` type of the last section into the following.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add {lhs: Expr a, rhs: Expr a}\n+\n+Compared to the earlier definition, the ``Add`` case is now in terms of a record with fields ``lhs`` and ``rhs``. This renders in TypeScript like so.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit2'; value: a }\n+     |  { tag: 'Var2'; value: string }\n+     |  { tag: 'Add'; value: Expr.Add<a> }\n+\n+   namespace Expr {\n+     type Add<a> = {\n+       lhs: Expr<a>;\n+       rhs: Expr<a>;\n+     }\n+   }\n+\n+The thing to note is how the definition of the ``Add`` case has given rise to a record type definition ``Expr.Add``.\n+\n+Enums\n+~~~~~\n+\n+DAML enumerations map naturally to TypeScript.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Color = Red | Blue | Yellow\n+\n+The companion TypeScript type is the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   enum Color {\n+     Red = 'Red',\n+     Blue = 'Blue',\n+     Yellow = 'Yellow',\n+   }\n+\n+Templates and choices\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+Here is a DAML template of a basic 'IOU' contract.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   template Iou\n+     with\n+       issuer: Party\n+       owner: Party\n+       currency: Text\n+       amount: Decimal\n+     where\n+       signatory issuer\n+       choice Transfer: ContractId Iou\n+         with\n+           newOwner: Party\n+         controller owner\n+         do\n+           create this with owner = newOwner\n+\n+``daml2ts`` generates types for each of the choices defined on the template as well as the template itself.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Transfer = {\n+     newOwner: daml.Party;\n+   }\n+\n+   type Iou = {\n+     issuer: daml.Party;\n+     owner: daml.Party;\n+     currency: string;\n+     amount: daml.Numeric;\n+   }\n+\n+Each template and each template choice also results in the generation of a companion object corresponding to the choice or template type. Here, is a schematic of the ones generated from the ``Iou`` template."
  },
  {
    "id" : "189e10d3-459a-491b-bb23-938576d97464",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "b75a9b83-cb67-4195-b397-a80026f967b7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Very nice.",
        "createdAt" : "2020-01-28T09:56:19Z",
        "updatedAt" : "2020-01-28T09:57:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 266,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |\n++-------------------+------------------+----------------------------------+\n+| ``Date``          | ``Date``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``ContractId<T>`` | ``ContractId t`` | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Optional<T>``   | ``Optional t``   | ``null | (null extends T ?``     |\n+|                   |                  | ``[] | [Exclude<T, null>] : T)`` |\n++-------------------+------------------+----------------------------------+\n+| ``TextMap<T>``    | ``TextMap t``    | ``{ [key: string]: T }``         |\n++-------------------+------------------+----------------------------------+\n+\n+.. note::\n+   The TypeScript types ``Time``, ``Decimal``, ``Numeric`` and ``Int`` all alias to ``string``. These choices relate to the avoidance of precision loss under serialization over the `json-api <../json-api/index.html>`_.\n+\n+.. note::\n+   The Typescript definition of type ``Optional<T>`` in the above table might look complicated. It accounts for differences in the encoding of optional values when nested versus when they are not (i.e. \"top-level\"). For example, ``null`` and ``\"foo\"`` are two possible values of ``Optional<Text>`` whereas, ``[]`` and ``[\"foo\"]`` are two possible values of type ``Optional<Optional<Text>>`` (``null`` is another possible value, ``[null]`` is **not**).\n+\n+DAML to TypeScript mappings\n+---------------------------\n+\n+The mappings from DAML to TypeScript are best explained by example.\n+\n+Records\n+~~~~~~~\n+\n+In DAML, we might model a person like this.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Person =\n+     Person with\n+       name: Text\n+       party: Party\n+       age: Int\n+\n+Given the above definition, the generated TypeScript code will be as follows.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Person = {\n+     name: string;\n+     party: daml.Party;\n+     age: daml.Int;\n+   }\n+\n+Tuples\n+~~~~~~\n+\n+Suppose the following DAML definition.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Pair a b = Pair (a, b)\n+\n+In TypeScript, the above definition renders as below [1]_.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Pair<a, b> =\n+     |  { tag: 'Pair'; value: {_1: a, _2: b} }\n+\n+\n+.. [1] This is a simplification but it is not wrong to think of it this way.\n+\n+.. note::\n+   The general rule is that DAML tuples are represented in TypeScript as simple objects with fields labeled ``_1``, ``_2`` and so on.\n+\n+The DAML type ``Pair a b`` has been modeled as a TypeScript discriminated union (with a single case). In general, all DAML variants are translated so as we will see in the next section.\n+\n+Variants\n+~~~~~~~~\n+\n+This is a DAML type for a language of additive expressions.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add (Expr a, Expr a)\n+\n+In TypeScript, it is represented as a discriminated union.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit'; value: a }\n+     |  { tag: 'Var'; value: string }\n+     |  { tag: 'Add'; value: {_1: Expr<a>, _2: Expr<a>} }\n+\n+Sum-of-products\n+~~~~~~~~~~~~~~~~\n+\n+Let's slightly modify the ``Expr a`` type of the last section into the following.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Expr a =\n+       Lit a\n+     | Var Text\n+     | Add {lhs: Expr a, rhs: Expr a}\n+\n+Compared to the earlier definition, the ``Add`` case is now in terms of a record with fields ``lhs`` and ``rhs``. This renders in TypeScript like so.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Expr<a> =\n+     |  { tag: 'Lit2'; value: a }\n+     |  { tag: 'Var2'; value: string }\n+     |  { tag: 'Add'; value: Expr.Add<a> }\n+\n+   namespace Expr {\n+     type Add<a> = {\n+       lhs: Expr<a>;\n+       rhs: Expr<a>;\n+     }\n+   }\n+\n+The thing to note is how the definition of the ``Add`` case has given rise to a record type definition ``Expr.Add``.\n+\n+Enums\n+~~~~~\n+\n+DAML enumerations map naturally to TypeScript.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   data Color = Red | Blue | Yellow\n+\n+The companion TypeScript type is the following.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   enum Color {\n+     Red = 'Red',\n+     Blue = 'Blue',\n+     Yellow = 'Yellow',\n+   }\n+\n+Templates and choices\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+Here is a DAML template of a basic 'IOU' contract.\n+\n+.. code-block:: daml\n+   :linenos:\n+\n+   template Iou\n+     with\n+       issuer: Party\n+       owner: Party\n+       currency: Text\n+       amount: Decimal\n+     where\n+       signatory issuer\n+       choice Transfer: ContractId Iou\n+         with\n+           newOwner: Party\n+         controller owner\n+         do\n+           create this with owner = newOwner\n+\n+``daml2ts`` generates types for each of the choices defined on the template as well as the template itself.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   type Transfer = {\n+     newOwner: daml.Party;\n+   }\n+\n+   type Iou = {\n+     issuer: daml.Party;\n+     owner: daml.Party;\n+     currency: string;\n+     amount: daml.Numeric;\n+   }\n+\n+Each template and each template choice also results in the generation of a companion object corresponding to the choice or template type. Here, is a schematic of the ones generated from the ``Iou`` template.\n+\n+.. code-block:: typescript\n+   :linenos:\n+\n+   const Transfer: daml.Serializable<Transfer> = ({\n+     /* ... */\n+     }),\n+   })\n+\n+   const Iou: daml.Template<Iou, undefined> & {\n+     Archive: daml.Choice<Iou, DA_Internal_Template.Archive, {}, undefined>;\n+     Transfer: daml.Choice<Iou, Transfer, daml.ContractId<Iou>, undefined>;\n+   } = {\n+     /* ... */\n+   }\n+\n+The exact details of these companion objects are not important - think of them as representing \"metadata\".\n+\n+What **is** important is the use of the companion objects when creating contracts and exercising choices using the `@daml/ledger <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-ledger>`_ package. The following code snippet demonstrates their usage.\n+\n+.. code-block:: typescript"
  },
  {
    "id" : "0980f7cf-118b-4d69-b94b-156a1c62654c",
    "prId" : 4196,
    "comments" : [
      {
        "id" : "2bd74b3a-3a8d-4fc8-ba69-e815f838bc22",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I just realized we're using small `t` in DAML and capital `T` in TypeScript. Let's use the same. Since it is meant to be a metavariable, we can use capital `T` in DAML too. We could also switch to Greek tau if that makes you feel more comfortable. Or alpha, beta.",
        "createdAt" : "2020-01-29T14:28:52Z",
        "updatedAt" : "2020-01-29T14:28:56Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9b34bc32-28c7-4fcc-80f1-b8cda8f072df",
        "parentId" : "2bd74b3a-3a8d-4fc8-ba69-e815f838bc22",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Switching to τ and η",
        "createdAt" : "2020-01-29T14:37:33Z",
        "updatedAt" : "2020-01-29T14:37:33Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ee7fd589c7e34883bbaedb4edf624607e808634",
    "line" : 56,
    "diffHunk" : "@@ -0,0 +1,290 @@\n+.. Copyright (c) 2020 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+TypeScript!\n+###########\n+\n+daml2ts : TypeScript of DAML\n+============================\n+\n+Introduction\n+------------\n+\n+``daml2ts`` generates TypeScript for interacting with DAML via the `json-api <../json-api/index.html>`_ .\n+\n+``daml2ts`` inputs are compiled DAML modules. ``daml2ts`` outputs are TypeScript source files containing definitions modeling the DAML entities found.\n+\n+The code ``daml2ts`` generates is in terms of the package `@daml/types <https://github.com/digital-asset/daml/tree/master/language-support/ts/daml-types>`_.\n+\n+Primitives: @daml/types\n+-----------------------\n+\n+To understand the TypeScript code generated by ``daml2ts``, it is helpful to keep in mind this quick review of the primitives provided by @daml/types.\n+\n+**Interfaces**:\n+\n+- ``Serializable<T>``\n+- ``Template<T extends object, K = unknown>``\n+- ``Choice<T extends object, C, R, K = unknown>``\n+\n+  ..\n+        An object that extends the ``Serializable<T>`` interface has a field ``decoder: () => jtv.Decoder<T>``.\n+        An object that extends the ``Template<T, K>`` interface has fields ``templateId: string``, ``keyDecoder: ()=> jtv.Decoder<K>``, ``Archive: Choice<T, {}, {}>`` and extends ``Serializable<T>``.\n+        An object that extends the ``Choice<T, C, R, K>`` interface has fields ``template: () => Template<T, K>``, ``argumentDecoder: () => jtv.Decoder<C>``, ``resultDecoder: () => jtv.Decoder<R>`` and ``choiceName: string``.\n+\n+**Types**:\n+\n++-------------------+------------------+----------------------------------+\n+| TypeScript        | DAML equiv.      | TypeScript definition            |\n++===================+==================+==================================+\n+| ``Unit``          | ``()``           | ``{}``                           |\n++-------------------+------------------+----------------------------------+\n+| ``Bool``          | ``Bool``         | ``boolean``                      |\n++-------------------+------------------+----------------------------------+\n+| ``Int``           | ``Int``          | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Decimal``       | ``Decimal``      | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Numeric``       | ``Numeric n``    | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Text``          | ``Text``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Time``          | ``Time``         | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``Party``         | ``Party``        | ``string``                       |\n++-------------------+------------------+----------------------------------+\n+| ``List<T>``       | ``[t]``          | ``T[]``                          |"
  }
]