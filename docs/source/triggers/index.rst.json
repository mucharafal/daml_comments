[
  {
    "id" : "54b1f0f1-4288-4d5d-a238-73129f525afc",
    "prId" : 3280,
    "comments" : [
      {
        "id" : "9c095259-faad-449b-a5a5-6dc96bf4a0e5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nwhich only sends the commands that are not already in flight.\r\n```",
        "createdAt" : "2019-10-29T15:08:45Z",
        "updatedAt" : "2019-10-29T17:34:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2380c747a523c3e61e1e2aec368a88050dd77d10",
    "line" : 25,
    "diffHunk" : "@@ -207,26 +207,8 @@ created using ``exerciseCmd`` and ``createCmd``.\n \n Finally, we also need to create copies that do not already exists. We\n want to avoid creating copies for which there is already a command in\n-flight. To find these, we first need a helper function that given a\n-``Command`` returns ``Some copy`` if the ``Command`` corresponds to\n-the creation of ``copy`` or ``None`` otherwise. For that, we pattern\n-match on the ``Command`` and if it was a ``CreateCommand``, we call\n-the ``fromAnyTemplate`` function which will return ``Some tpl`` if the\n-template is of the given type (``Copy`` in this example) and ``None``\n-otherwise.\n-\n-.. literalinclude:: ./template-root/src/CopyTrigger.daml\n-   :language: daml\n-   :start-after: -- TO_CREATE_COPY_BEGIN\n-   :end-before: -- TO_CREATE_COPY_END\n-\n-Equipped with ``toCreateCopy``, we can define the set of\n-``pendingCopies`` by filtering the commands in flight and the set of\n-``eventualCopies``, i.e., either pending copies or copies that already\n-exist.  The copies that we need to create are then the set of\n-``neeedCopies`` that are not already in ``pendingCopies``. Similar to\n-archiving, we use ``emitCommands`` to actually create them, this time\n-with ``createCmd`` instead of ``exerciseCmd``.\n+flight. The DAML Trigger API provides a ``dedupCreate`` helper for this\n+which only sends the commands if it is not already in flight."
  },
  {
    "id" : "aa9bb557-69f4-4e7a-9807-76b6fbd2b841",
    "prId" : 3181,
    "comments" : [
      {
        "id" : "b7a0489e-b7b1-4323-9eeb-3fee3d607d1c",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\ndefines which commands need to be sent to the ledger based on the\r\n```",
        "createdAt" : "2019-10-15T12:39:47Z",
        "updatedAt" : "2019-10-15T13:45:19Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7dd12f24ae175548547c4248c103ad1ac53cd2b5",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML Triggers - Off-Ledger Automation in DAML\n+#############################################\n+\n+**WARNING:** DAML Triggers are an experimental feature that is actively\n+being designed and is *subject to breaking changes*.\n+We welcome feedback about DAML triggers on\n+`our issue tracker <https://github.com/digital-asset/daml/issues/new?milestone=HTTP+JSON+API+Maintenance>`_\n+or `on Slack <https://damldriven.slack.com/>`_.\n+\n+In addition to the actual DAML logic which is uploaded to the Ledger\n+and the UI, DAML applications often need to automate certain\n+interactions with the ledger. This is commonly done in the form of a\n+ledger client that listens to the transaction stream of the ledger and\n+when certain conditions are met, e.g., when a template of a given type\n+has been created, the client sends commands to the ledger, e.g., it\n+creates a template of another type.\n+\n+It is possible to write these clients in a language of your choice,\n+e.g., JavaScript, using the HTTP JSON API. However, that introduces an\n+additional layer of friction: You now need to translate between the\n+template and choice types in DAML and a representation of those DAML\n+types in the language you are using for your client. DAML triggers\n+address this problem by allowing you to write certain kinds of\n+automation directly in DAML reusing all the DAML types and logic that\n+you have already defined. Note that while the logic for DAML triggers\n+is written in DAML, they act like any other ledger client: They are\n+executed separately from the ledger, they do not need to be uploaded\n+to the ledger and they do not allow you to do anything that any other\n+ledger client could not do.\n+\n+Usage\n+=====\n+\n+Our example for this tutorial consists of 3 templates.\n+\n+First, we have a template called ``Original``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ORIGINAL_TEMPLATE_BEGIN\n+   :end-before: -- ORIGINAL_TEMPLATE_END\n+\n+This template has an ``owner``, a ``name`` that identifies it and some\n+``textdata`` that we just represent as ``Text`` to keep things simple.  We\n+have also added a contract key to ensure that each owner can only have\n+one ``Original`` with a given ``name``.\n+\n+Second, we have a template called ``Subscriber``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- SUBSCRIBER_TEMPLATE_BEGIN\n+   :end-before: -- SUBSCRIBER_TEMPLATE_END\n+\n+This template allows the ``subscriber`` to subscribe to ``Original`` s where ``subscribedTo`` is the ``owner``.\n+For each of these ``Original`` s, our DAML trigger should then automatically create an instance of\n+third template called ``Copy``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- COPY_TEMPLATE_BEGIN\n+   :end-before: -- COPY_TEMPLATE_END\n+\n+Our trigger should also ensure that the ``Copy`` contracts stay in sync with changes on the ledger. That means\n+that we need to archive ``Copy`` contracts if there is more than one for the same ``Original``, we need to archive\n+``Copy`` contracts if the corresponding ``Original`` has been archived and we need to archive\n+all ``Copy`` s for a given subscriber if the corresponding ``Subscriber`` contract has been archived.\n+\n+Implementing a DAML Trigger\n+---------------------------\n+\n+Having defined what our DAML trigger is supposed to do, we can now\n+move on to its implementation. A DAML trigger is a regular DAML\n+project that you can build using ``daml build``. To get access to the\n+API used to build a trigger, you need to add the ``daml-triggers``\n+library to the ``dependencies`` field in ``daml.yaml``.\n+\n+.. literalinclude:: ./template-root/daml.yaml.template\n+   :start-after: # trigger-dependencies-begin\n+   :end-before: # trigger-dependencies-end\n+\n+In addition to that you also need to import the ``Daml.Trigger``\n+module.\n+\n+DAML triggers automatically track the active contract set and the\n+commands in flight for you. In addition to that, they allow you to\n+have user-defined state that is updated based on new transactions and\n+command completions. For our copy trigger, the ACS is sufficient, so\n+we will simply use ``()`` as the type of the user defined state.\n+\n+To create a trigger you need to define a value of type ``Trigger s`` where ``s`` is the type of your user-defined state:\n+\n+.. code-block:: daml\n+\n+    data Trigger s = Trigger\n+      { initialize : ACS -> s\n+      , updateState : ACS -> Message -> s -> s\n+      , rule : Party -> ACS -> Map CommandId [Command] -> s -> TriggerA ()\n+      }\n+\n+The ``initialize`` function is called on startup and allows you to\n+initialize your user-defined state based on the active contract set.\n+\n+The ``updateState`` function is called on new transactions and command\n+completions and can be used to update your user-defined state based on\n+the ACS and the transaction or completion. Since our DAML trigger does\n+not have any interesting user-defined state, we will not go into\n+details here.\n+\n+Finally, the ``rule`` function is the core of a DAML trigger. It\n+defines which commands need to be send to the ledger based on the"
  },
  {
    "id" : "12d45d0e-63d9-435e-9427-431291fd897d",
    "prId" : 3181,
    "comments" : [
      {
        "id" : "0c0a083e-f248-4591-b6eb-bc8eed16debe",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "I find this sentence hard to parse. Maybe something like\r\n\r\nNote that DAML triggers are expected to be robust against missing entries in the commands in flight. In particular they are not repopulated after a crash or restart. So, this is an optimization and should not be required for a trigger to function correctly.",
        "createdAt" : "2019-10-15T12:46:19Z",
        "updatedAt" : "2019-10-15T13:45:19Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "580cfb02-f36a-47fa-93d7-49a1e07a4751",
        "parentId" : "0c0a083e-f248-4591-b6eb-bc8eed16debe",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This changed after I merged @hurryabit’s suggestions. Does the new formulation help?",
        "createdAt" : "2019-10-15T13:02:28Z",
        "updatedAt" : "2019-10-15T13:45:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bc513114-bf88-4eea-9fc6-1cb82dabd4a1",
        "parentId" : "0c0a083e-f248-4591-b6eb-bc8eed16debe",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Yes, I think it's easier to read in https://github.com/digital-asset/daml/pull/3183.",
        "createdAt" : "2019-10-15T13:58:51Z",
        "updatedAt" : "2019-10-15T13:58:51Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7dd12f24ae175548547c4248c103ad1ac53cd2b5",
    "line" : 148,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML Triggers - Off-Ledger Automation in DAML\n+#############################################\n+\n+**WARNING:** DAML Triggers are an experimental feature that is actively\n+being designed and is *subject to breaking changes*.\n+We welcome feedback about DAML triggers on\n+`our issue tracker <https://github.com/digital-asset/daml/issues/new?milestone=HTTP+JSON+API+Maintenance>`_\n+or `on Slack <https://damldriven.slack.com/>`_.\n+\n+In addition to the actual DAML logic which is uploaded to the Ledger\n+and the UI, DAML applications often need to automate certain\n+interactions with the ledger. This is commonly done in the form of a\n+ledger client that listens to the transaction stream of the ledger and\n+when certain conditions are met, e.g., when a template of a given type\n+has been created, the client sends commands to the ledger, e.g., it\n+creates a template of another type.\n+\n+It is possible to write these clients in a language of your choice,\n+e.g., JavaScript, using the HTTP JSON API. However, that introduces an\n+additional layer of friction: You now need to translate between the\n+template and choice types in DAML and a representation of those DAML\n+types in the language you are using for your client. DAML triggers\n+address this problem by allowing you to write certain kinds of\n+automation directly in DAML reusing all the DAML types and logic that\n+you have already defined. Note that while the logic for DAML triggers\n+is written in DAML, they act like any other ledger client: They are\n+executed separately from the ledger, they do not need to be uploaded\n+to the ledger and they do not allow you to do anything that any other\n+ledger client could not do.\n+\n+Usage\n+=====\n+\n+Our example for this tutorial consists of 3 templates.\n+\n+First, we have a template called ``Original``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ORIGINAL_TEMPLATE_BEGIN\n+   :end-before: -- ORIGINAL_TEMPLATE_END\n+\n+This template has an ``owner``, a ``name`` that identifies it and some\n+``textdata`` that we just represent as ``Text`` to keep things simple.  We\n+have also added a contract key to ensure that each owner can only have\n+one ``Original`` with a given ``name``.\n+\n+Second, we have a template called ``Subscriber``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- SUBSCRIBER_TEMPLATE_BEGIN\n+   :end-before: -- SUBSCRIBER_TEMPLATE_END\n+\n+This template allows the ``subscriber`` to subscribe to ``Original`` s where ``subscribedTo`` is the ``owner``.\n+For each of these ``Original`` s, our DAML trigger should then automatically create an instance of\n+third template called ``Copy``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- COPY_TEMPLATE_BEGIN\n+   :end-before: -- COPY_TEMPLATE_END\n+\n+Our trigger should also ensure that the ``Copy`` contracts stay in sync with changes on the ledger. That means\n+that we need to archive ``Copy`` contracts if there is more than one for the same ``Original``, we need to archive\n+``Copy`` contracts if the corresponding ``Original`` has been archived and we need to archive\n+all ``Copy`` s for a given subscriber if the corresponding ``Subscriber`` contract has been archived.\n+\n+Implementing a DAML Trigger\n+---------------------------\n+\n+Having defined what our DAML trigger is supposed to do, we can now\n+move on to its implementation. A DAML trigger is a regular DAML\n+project that you can build using ``daml build``. To get access to the\n+API used to build a trigger, you need to add the ``daml-triggers``\n+library to the ``dependencies`` field in ``daml.yaml``.\n+\n+.. literalinclude:: ./template-root/daml.yaml.template\n+   :start-after: # trigger-dependencies-begin\n+   :end-before: # trigger-dependencies-end\n+\n+In addition to that you also need to import the ``Daml.Trigger``\n+module.\n+\n+DAML triggers automatically track the active contract set and the\n+commands in flight for you. In addition to that, they allow you to\n+have user-defined state that is updated based on new transactions and\n+command completions. For our copy trigger, the ACS is sufficient, so\n+we will simply use ``()`` as the type of the user defined state.\n+\n+To create a trigger you need to define a value of type ``Trigger s`` where ``s`` is the type of your user-defined state:\n+\n+.. code-block:: daml\n+\n+    data Trigger s = Trigger\n+      { initialize : ACS -> s\n+      , updateState : ACS -> Message -> s -> s\n+      , rule : Party -> ACS -> Map CommandId [Command] -> s -> TriggerA ()\n+      }\n+\n+The ``initialize`` function is called on startup and allows you to\n+initialize your user-defined state based on the active contract set.\n+\n+The ``updateState`` function is called on new transactions and command\n+completions and can be used to update your user-defined state based on\n+the ACS and the transaction or completion. Since our DAML trigger does\n+not have any interesting user-defined state, we will not go into\n+details here.\n+\n+Finally, the ``rule`` function is the core of a DAML trigger. It\n+defines which commands need to be send to the ledger based on the\n+party the trigger is executed at, the current state of the ACS, the\n+commands in flight and the user defined state. The type ``TriggerA``\n+allows you to emit commands that are then sent to the ledger. Like\n+``Scenario`` or ``Update``, you can use ``do`` notation with\n+``TriggerA``.\n+\n+Once you have defined the trigger, you have to pass it to ``runTrigger``. For our DAML trigger,\n+this looks as follows:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- TRIGGER_BEGIN\n+   :end-before: -- TRIGGER_END\n+\n+Now we can move on to the most complex part of our DAML trigger, the implementation of ``copyRule``.\n+First let’s take a look at the signature:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- RULE_SIGNATURE_BEGIN\n+   :end-before: -- RULE_SIGNATURE_END\n+\n+We will need the party and the ACS to get the ``Original`` contracts\n+where we are the owner, the ``Subscriber`` contracts where we are in\n+the ``subscribedTo`` field and the ``Copy`` contracts where we are the\n+``owner`` of the corresponding ``Original``.\n+\n+The commands in flight will be useful to avoid sending the same\n+command multiple times if ``copyRule`` is run multiple times before we\n+get the corresponding transaction. Note that DAML triggers are\n+expected to be designed such that they can cope with this, e.g., after\n+a restart or a crash where the commands in flight do not contain\n+commands in flight from before the restart, so this is an optimization\n+rather than something required for them to function correctly."
  },
  {
    "id" : "c3c74593-8b2c-4a67-9bf4-52232fe16d39",
    "prId" : 3181,
    "comments" : [
      {
        "id" : "c7319c96-1cbf-46f0-ad64-cf75abdcd535",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\nTo send the corresponding archive commands to the ledger, we iterate\r\n```",
        "createdAt" : "2019-10-15T12:47:10Z",
        "updatedAt" : "2019-10-15T13:45:19Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7dd12f24ae175548547c4248c103ad1ac53cd2b5",
    "line" : 193,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML Triggers - Off-Ledger Automation in DAML\n+#############################################\n+\n+**WARNING:** DAML Triggers are an experimental feature that is actively\n+being designed and is *subject to breaking changes*.\n+We welcome feedback about DAML triggers on\n+`our issue tracker <https://github.com/digital-asset/daml/issues/new?milestone=HTTP+JSON+API+Maintenance>`_\n+or `on Slack <https://damldriven.slack.com/>`_.\n+\n+In addition to the actual DAML logic which is uploaded to the Ledger\n+and the UI, DAML applications often need to automate certain\n+interactions with the ledger. This is commonly done in the form of a\n+ledger client that listens to the transaction stream of the ledger and\n+when certain conditions are met, e.g., when a template of a given type\n+has been created, the client sends commands to the ledger, e.g., it\n+creates a template of another type.\n+\n+It is possible to write these clients in a language of your choice,\n+e.g., JavaScript, using the HTTP JSON API. However, that introduces an\n+additional layer of friction: You now need to translate between the\n+template and choice types in DAML and a representation of those DAML\n+types in the language you are using for your client. DAML triggers\n+address this problem by allowing you to write certain kinds of\n+automation directly in DAML reusing all the DAML types and logic that\n+you have already defined. Note that while the logic for DAML triggers\n+is written in DAML, they act like any other ledger client: They are\n+executed separately from the ledger, they do not need to be uploaded\n+to the ledger and they do not allow you to do anything that any other\n+ledger client could not do.\n+\n+Usage\n+=====\n+\n+Our example for this tutorial consists of 3 templates.\n+\n+First, we have a template called ``Original``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ORIGINAL_TEMPLATE_BEGIN\n+   :end-before: -- ORIGINAL_TEMPLATE_END\n+\n+This template has an ``owner``, a ``name`` that identifies it and some\n+``textdata`` that we just represent as ``Text`` to keep things simple.  We\n+have also added a contract key to ensure that each owner can only have\n+one ``Original`` with a given ``name``.\n+\n+Second, we have a template called ``Subscriber``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- SUBSCRIBER_TEMPLATE_BEGIN\n+   :end-before: -- SUBSCRIBER_TEMPLATE_END\n+\n+This template allows the ``subscriber`` to subscribe to ``Original`` s where ``subscribedTo`` is the ``owner``.\n+For each of these ``Original`` s, our DAML trigger should then automatically create an instance of\n+third template called ``Copy``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- COPY_TEMPLATE_BEGIN\n+   :end-before: -- COPY_TEMPLATE_END\n+\n+Our trigger should also ensure that the ``Copy`` contracts stay in sync with changes on the ledger. That means\n+that we need to archive ``Copy`` contracts if there is more than one for the same ``Original``, we need to archive\n+``Copy`` contracts if the corresponding ``Original`` has been archived and we need to archive\n+all ``Copy`` s for a given subscriber if the corresponding ``Subscriber`` contract has been archived.\n+\n+Implementing a DAML Trigger\n+---------------------------\n+\n+Having defined what our DAML trigger is supposed to do, we can now\n+move on to its implementation. A DAML trigger is a regular DAML\n+project that you can build using ``daml build``. To get access to the\n+API used to build a trigger, you need to add the ``daml-triggers``\n+library to the ``dependencies`` field in ``daml.yaml``.\n+\n+.. literalinclude:: ./template-root/daml.yaml.template\n+   :start-after: # trigger-dependencies-begin\n+   :end-before: # trigger-dependencies-end\n+\n+In addition to that you also need to import the ``Daml.Trigger``\n+module.\n+\n+DAML triggers automatically track the active contract set and the\n+commands in flight for you. In addition to that, they allow you to\n+have user-defined state that is updated based on new transactions and\n+command completions. For our copy trigger, the ACS is sufficient, so\n+we will simply use ``()`` as the type of the user defined state.\n+\n+To create a trigger you need to define a value of type ``Trigger s`` where ``s`` is the type of your user-defined state:\n+\n+.. code-block:: daml\n+\n+    data Trigger s = Trigger\n+      { initialize : ACS -> s\n+      , updateState : ACS -> Message -> s -> s\n+      , rule : Party -> ACS -> Map CommandId [Command] -> s -> TriggerA ()\n+      }\n+\n+The ``initialize`` function is called on startup and allows you to\n+initialize your user-defined state based on the active contract set.\n+\n+The ``updateState`` function is called on new transactions and command\n+completions and can be used to update your user-defined state based on\n+the ACS and the transaction or completion. Since our DAML trigger does\n+not have any interesting user-defined state, we will not go into\n+details here.\n+\n+Finally, the ``rule`` function is the core of a DAML trigger. It\n+defines which commands need to be send to the ledger based on the\n+party the trigger is executed at, the current state of the ACS, the\n+commands in flight and the user defined state. The type ``TriggerA``\n+allows you to emit commands that are then sent to the ledger. Like\n+``Scenario`` or ``Update``, you can use ``do`` notation with\n+``TriggerA``.\n+\n+Once you have defined the trigger, you have to pass it to ``runTrigger``. For our DAML trigger,\n+this looks as follows:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- TRIGGER_BEGIN\n+   :end-before: -- TRIGGER_END\n+\n+Now we can move on to the most complex part of our DAML trigger, the implementation of ``copyRule``.\n+First let’s take a look at the signature:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- RULE_SIGNATURE_BEGIN\n+   :end-before: -- RULE_SIGNATURE_END\n+\n+We will need the party and the ACS to get the ``Original`` contracts\n+where we are the owner, the ``Subscriber`` contracts where we are in\n+the ``subscribedTo`` field and the ``Copy`` contracts where we are the\n+``owner`` of the corresponding ``Original``.\n+\n+The commands in flight will be useful to avoid sending the same\n+command multiple times if ``copyRule`` is run multiple times before we\n+get the corresponding transaction. Note that DAML triggers are\n+expected to be designed such that they can cope with this, e.g., after\n+a restart or a crash where the commands in flight do not contain\n+commands in flight from before the restart, so this is an optimization\n+rather than something required for them to function correctly.\n+\n+First, we get all ``Subscriber``, ``Original`` and ``Copy`` contracts\n+from the ACS. For that, the DAML trigger API provides a\n+``getTemplates`` function that given the ACS will return a list of all\n+contracts of a given type.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ACS_QUERY_BEGIN\n+   :end-before: -- ACS_QUERY_END\n+\n+Now, we can filter those contracts to the ones where we are the\n+``owner`` as described before.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ACS_FILTER_BEGIN\n+   :end-before: -- ACS_FILTER_END\n+\n+We also need a list of all parties that have subscribed to us.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- SUBSCRIBING_PARTIES_BEGIN\n+   :end-before: -- SUBSCRIBING_PARTIES_END\n+\n+As we have mentioned before, we only want to keep one ``Copy`` per\n+``Original`` and ``Subscriber`` and archive all others. Therefore, we\n+group identical ``Copy`` contracts and keep the first of each group\n+while archiving the others.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- GROUP_COPIES_BEGIN\n+   :end-before: -- GROUP_COPIES_END\n+\n+In addition to duplicate copies, we also need to archive copies where\n+the corresponding ``Original`` or ``Subscriber`` no longer exists.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ARCHIVE_COPIES_BEGIN\n+   :end-before: -- ARCHIVE_COPIES_END\n+\n+To send the corresponding archve commands to the ledger, we iterate"
  },
  {
    "id" : "c5eebddf-f444-4155-b65d-78bfc1ed4e1e",
    "prId" : 3181,
    "comments" : [
      {
        "id" : "7fc56186-1a97-487d-bd6c-14997ccea3b8",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\n``neededCopies`` that are not already in ``pendingCopies``. Similar to\r\n```",
        "createdAt" : "2019-10-15T12:49:16Z",
        "updatedAt" : "2019-10-15T13:45:19Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7dd12f24ae175548547c4248c103ad1ac53cd2b5",
    "line" : 223,
    "diffHunk" : "@@ -0,0 +1,271 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML Triggers - Off-Ledger Automation in DAML\n+#############################################\n+\n+**WARNING:** DAML Triggers are an experimental feature that is actively\n+being designed and is *subject to breaking changes*.\n+We welcome feedback about DAML triggers on\n+`our issue tracker <https://github.com/digital-asset/daml/issues/new?milestone=HTTP+JSON+API+Maintenance>`_\n+or `on Slack <https://damldriven.slack.com/>`_.\n+\n+In addition to the actual DAML logic which is uploaded to the Ledger\n+and the UI, DAML applications often need to automate certain\n+interactions with the ledger. This is commonly done in the form of a\n+ledger client that listens to the transaction stream of the ledger and\n+when certain conditions are met, e.g., when a template of a given type\n+has been created, the client sends commands to the ledger, e.g., it\n+creates a template of another type.\n+\n+It is possible to write these clients in a language of your choice,\n+e.g., JavaScript, using the HTTP JSON API. However, that introduces an\n+additional layer of friction: You now need to translate between the\n+template and choice types in DAML and a representation of those DAML\n+types in the language you are using for your client. DAML triggers\n+address this problem by allowing you to write certain kinds of\n+automation directly in DAML reusing all the DAML types and logic that\n+you have already defined. Note that while the logic for DAML triggers\n+is written in DAML, they act like any other ledger client: They are\n+executed separately from the ledger, they do not need to be uploaded\n+to the ledger and they do not allow you to do anything that any other\n+ledger client could not do.\n+\n+Usage\n+=====\n+\n+Our example for this tutorial consists of 3 templates.\n+\n+First, we have a template called ``Original``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ORIGINAL_TEMPLATE_BEGIN\n+   :end-before: -- ORIGINAL_TEMPLATE_END\n+\n+This template has an ``owner``, a ``name`` that identifies it and some\n+``textdata`` that we just represent as ``Text`` to keep things simple.  We\n+have also added a contract key to ensure that each owner can only have\n+one ``Original`` with a given ``name``.\n+\n+Second, we have a template called ``Subscriber``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- SUBSCRIBER_TEMPLATE_BEGIN\n+   :end-before: -- SUBSCRIBER_TEMPLATE_END\n+\n+This template allows the ``subscriber`` to subscribe to ``Original`` s where ``subscribedTo`` is the ``owner``.\n+For each of these ``Original`` s, our DAML trigger should then automatically create an instance of\n+third template called ``Copy``:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- COPY_TEMPLATE_BEGIN\n+   :end-before: -- COPY_TEMPLATE_END\n+\n+Our trigger should also ensure that the ``Copy`` contracts stay in sync with changes on the ledger. That means\n+that we need to archive ``Copy`` contracts if there is more than one for the same ``Original``, we need to archive\n+``Copy`` contracts if the corresponding ``Original`` has been archived and we need to archive\n+all ``Copy`` s for a given subscriber if the corresponding ``Subscriber`` contract has been archived.\n+\n+Implementing a DAML Trigger\n+---------------------------\n+\n+Having defined what our DAML trigger is supposed to do, we can now\n+move on to its implementation. A DAML trigger is a regular DAML\n+project that you can build using ``daml build``. To get access to the\n+API used to build a trigger, you need to add the ``daml-triggers``\n+library to the ``dependencies`` field in ``daml.yaml``.\n+\n+.. literalinclude:: ./template-root/daml.yaml.template\n+   :start-after: # trigger-dependencies-begin\n+   :end-before: # trigger-dependencies-end\n+\n+In addition to that you also need to import the ``Daml.Trigger``\n+module.\n+\n+DAML triggers automatically track the active contract set and the\n+commands in flight for you. In addition to that, they allow you to\n+have user-defined state that is updated based on new transactions and\n+command completions. For our copy trigger, the ACS is sufficient, so\n+we will simply use ``()`` as the type of the user defined state.\n+\n+To create a trigger you need to define a value of type ``Trigger s`` where ``s`` is the type of your user-defined state:\n+\n+.. code-block:: daml\n+\n+    data Trigger s = Trigger\n+      { initialize : ACS -> s\n+      , updateState : ACS -> Message -> s -> s\n+      , rule : Party -> ACS -> Map CommandId [Command] -> s -> TriggerA ()\n+      }\n+\n+The ``initialize`` function is called on startup and allows you to\n+initialize your user-defined state based on the active contract set.\n+\n+The ``updateState`` function is called on new transactions and command\n+completions and can be used to update your user-defined state based on\n+the ACS and the transaction or completion. Since our DAML trigger does\n+not have any interesting user-defined state, we will not go into\n+details here.\n+\n+Finally, the ``rule`` function is the core of a DAML trigger. It\n+defines which commands need to be send to the ledger based on the\n+party the trigger is executed at, the current state of the ACS, the\n+commands in flight and the user defined state. The type ``TriggerA``\n+allows you to emit commands that are then sent to the ledger. Like\n+``Scenario`` or ``Update``, you can use ``do`` notation with\n+``TriggerA``.\n+\n+Once you have defined the trigger, you have to pass it to ``runTrigger``. For our DAML trigger,\n+this looks as follows:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- TRIGGER_BEGIN\n+   :end-before: -- TRIGGER_END\n+\n+Now we can move on to the most complex part of our DAML trigger, the implementation of ``copyRule``.\n+First let’s take a look at the signature:\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- RULE_SIGNATURE_BEGIN\n+   :end-before: -- RULE_SIGNATURE_END\n+\n+We will need the party and the ACS to get the ``Original`` contracts\n+where we are the owner, the ``Subscriber`` contracts where we are in\n+the ``subscribedTo`` field and the ``Copy`` contracts where we are the\n+``owner`` of the corresponding ``Original``.\n+\n+The commands in flight will be useful to avoid sending the same\n+command multiple times if ``copyRule`` is run multiple times before we\n+get the corresponding transaction. Note that DAML triggers are\n+expected to be designed such that they can cope with this, e.g., after\n+a restart or a crash where the commands in flight do not contain\n+commands in flight from before the restart, so this is an optimization\n+rather than something required for them to function correctly.\n+\n+First, we get all ``Subscriber``, ``Original`` and ``Copy`` contracts\n+from the ACS. For that, the DAML trigger API provides a\n+``getTemplates`` function that given the ACS will return a list of all\n+contracts of a given type.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ACS_QUERY_BEGIN\n+   :end-before: -- ACS_QUERY_END\n+\n+Now, we can filter those contracts to the ones where we are the\n+``owner`` as described before.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ACS_FILTER_BEGIN\n+   :end-before: -- ACS_FILTER_END\n+\n+We also need a list of all parties that have subscribed to us.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- SUBSCRIBING_PARTIES_BEGIN\n+   :end-before: -- SUBSCRIBING_PARTIES_END\n+\n+As we have mentioned before, we only want to keep one ``Copy`` per\n+``Original`` and ``Subscriber`` and archive all others. Therefore, we\n+group identical ``Copy`` contracts and keep the first of each group\n+while archiving the others.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- GROUP_COPIES_BEGIN\n+   :end-before: -- GROUP_COPIES_END\n+\n+In addition to duplicate copies, we also need to archive copies where\n+the corresponding ``Original`` or ``Subscriber`` no longer exists.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ARCHIVE_COPIES_BEGIN\n+   :end-before: -- ARCHIVE_COPIES_END\n+\n+To send the corresponding archve commands to the ledger, we iterate\n+over ``archiveCopies`` using ``forA`` and call the ``emitCommands``\n+function. Each call to ``emitCommands`` takes a list of commands which\n+will be submitted as a single transaction. The actual commands can be\n+created using ``exerciseCmd`` and ``createCmd``.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- ARCHIVE_COMMAND_BEGIN\n+   :end-before: -- ARCHIVE_COMMAND_END\n+\n+Finally, we also need to create copies that do not already exists. We\n+want to avoid creating copies for which there is already a command in\n+flight. To find these, we first need a helper function that given a\n+``Command`` returns ``Some copy`` if the ``Command`` corresponds to\n+the creation of ``copy`` or ``None`` otherwise. For that, we pattern\n+match on the ``Command`` and if it was a ``CreateCommand``, we call\n+the ``fromAnyTemplate`` function which will return ``Some tpl`` if the\n+template is of the given type (``Copy`` in this example) and ``None``\n+otherwise.\n+\n+.. literalinclude:: ./template-root/src/CopyTrigger.daml\n+   :language: daml\n+   :start-after: -- TO_CREATE_COPY_BEGIN\n+   :end-before: -- TO_CREATE_COPY_END\n+\n+Equipped with ``toCreateCopy``, we can define the set of\n+``pendingCopies`` by filtering the commands in flight and the set of\n+``eventualCopies``, i.e., either pending copies or copies that already\n+exist.  The copies that we need to create are then the set of\n+``neeedCopies`` that are not already in ``pendingCopies``. Similar to"
  }
]