[
  {
    "id" : "66a66fa7-b9bd-438d-b7fe-dc2fe4e2ee65",
    "prId" : 3455,
    "comments" : [
      {
        "id" : "07e615a3-60f2-4eb5-83cd-eebdbbbf9a90",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Should the exception we might throw below contain that we expected 2 fields in the record too? Same above.",
        "createdAt" : "2019-11-13T18:49:00Z",
        "updatedAt" : "2019-11-13T19:04:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "981dc07e-3c57-4da8-9ede-5008c2b4964c",
        "parentId" : "07e615a3-60f2-4eb5-83cd-eebdbbbf9a90",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, fixed.",
        "createdAt" : "2019-11-13T19:17:49Z",
        "updatedAt" : "2019-11-13T19:17:50Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8190a156393f3a2e2fbc3d25ea4a2cdfc7dd2ab0",
    "line" : 234,
    "diffHunk" : "@@ -311,8 +215,7 @@ class Runner(dar: Dar[(PackageId, Package)], applicationId: ApplicationId) exten\n             }\n             case SVariant(_, \"AllocParty\", v) => {\n               v match {\n-                case SRecord(_, _, vals) => {\n-                  assert(vals.size == 2)\n+                case SRecord(_, _, vals) if vals.size == 2 => {"
  },
  {
    "id" : "009cd341-8033-4819-aec5-02639e51bf37",
    "prId" : 3428,
    "comments" : [
      {
        "id" : "9644708f-b985-42f5-9eb1-f9b35a6f4957",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "`DottedName.assertFromString(\"DA.Internal.LF\")` can be a constant.",
        "createdAt" : "2019-11-12T16:00:09Z",
        "updatedAt" : "2019-11-12T16:30:05Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e607d4d5daa377415ce47b2303aec1cef06e892e",
    "line" : 63,
    "diffHunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.script\n+\n+import akka.stream.ActorMaterializer\n+import akka.stream.scaladsl.Sink\n+import com.typesafe.scalalogging.StrictLogging\n+import java.time.Instant\n+import java.util\n+import java.util.UUID\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+import scalaz.syntax.tag._\n+\n+import com.digitalasset.api.util.TimestampConversion.fromInstant\n+import com.digitalasset.daml.lf.PureCompiledPackages\n+import com.digitalasset.daml.lf.archive.Dar\n+import com.digitalasset.daml.lf.data.FrontStack\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.language.Ast._\n+import com.digitalasset.daml.lf.speedy.{Compiler, Pretty, SExpr, Speedy, SValue}\n+import com.digitalasset.daml.lf.speedy.SBuiltin._\n+import com.digitalasset.daml.lf.speedy.SExpr._\n+import com.digitalasset.daml.lf.speedy.SResult._\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, RelativeContractId}\n+import com.digitalasset.ledger.api.domain.LedgerId\n+import com.digitalasset.ledger.api.refinements.ApiTypes.ApplicationId\n+import com.digitalasset.ledger.api.v1.command_service.SubmitAndWaitRequest\n+import com.digitalasset.ledger.api.v1.commands._\n+import com.digitalasset.ledger.api.v1.event.{CreatedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.TreeEvent\n+import com.digitalasset.ledger.api.v1.transaction_filter.{\n+  Filters,\n+  TransactionFilter,\n+  InclusiveFilters\n+}\n+import com.digitalasset.ledger.api.v1.value.{Identifier => ApiIdentifier}\n+import com.digitalasset.ledger.api.validation.ValueValidator\n+import com.digitalasset.ledger.client.LedgerClient\n+import com.digitalasset.platform.participant.util.LfEngineToApi.{\n+  toApiIdentifier,\n+  lfValueToApiRecord,\n+  lfValueToApiValue\n+}\n+\n+class Runner(dar: Dar[(PackageId, Package)], applicationId: ApplicationId) extends StrictLogging {\n+\n+  val darMap: Map[PackageId, Package] = dar.all.toMap\n+  val compiler = Compiler(darMap)\n+  val scriptModuleName = DottedName.assertFromString(\"Daml.Script\")\n+  val scriptPackageId: PackageId = dar.all\n+    .find {\n+      case (pkgId, pkg) => pkg.modules.contains(scriptModuleName)\n+    }\n+    .get\n+    ._1\n+  val stdlibPackageId =\n+    dar.all\n+      .find {\n+        case (pkgId, pkg) =>\n+          pkg.modules.contains(DottedName.assertFromString(\"DA.Internal.LF\"))"
  },
  {
    "id" : "ee4dcccc-2748-40cf-8914-bd8b0344b08d",
    "prId" : 3428,
    "comments" : [
      {
        "id" : "02e44deb-33bf-4715-a39a-239d56c42e91",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "you should use match here, something like this:\r\n```\r\nmachine.toSValue match {\r\n  case STuple(_, (a0: SVariant) :: (a1: SVariant) :: _) => (a0, a1)\r\n  case => sys.error(\"something unexpected\")\r\n}\r\n```\r\nor  if you know that it is a tuple 2\r\n```\r\nmachine.toSValue match {\r\n  case STuple(_, (a0: SVariant) :: (a1: SVariant) :: Nil) => (a0, a1)\r\n  case => sys.error(\"something unexpected\")\r\n}\r\n```\r\nin any case using `match` is more idiomatic Scala, you should never use `asInstanceOf`.\r\n",
        "createdAt" : "2019-11-12T16:29:40Z",
        "updatedAt" : "2019-11-12T16:33:50Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7d1a0bfb-78b9-41e3-9c3c-fbd36ffaf91b",
        "parentId" : "02e44deb-33bf-4715-a39a-239d56c42e91",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "oops it is `java.util.ArrayList` you cannot match it like this, so you might want to convert it to Scala first. But in any case using `asInstanceOf` is discouraged unless you are hardcore Java programmer :)",
        "createdAt" : "2019-11-12T16:32:47Z",
        "updatedAt" : "2019-11-12T16:32:48Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fb334ad5-f388-4e82-a1b6-fed8cd901c01",
        "parentId" : "02e44deb-33bf-4715-a39a-239d56c42e91",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yeah I’ll kill all the `asInstanceOf` stuff in a follow-up PR. That was just for prototyping.",
        "createdAt" : "2019-11-12T16:48:52Z",
        "updatedAt" : "2019-11-12T16:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e607d4d5daa377415ce47b2303aec1cef06e892e",
    "line" : 119,
    "diffHunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.script\n+\n+import akka.stream.ActorMaterializer\n+import akka.stream.scaladsl.Sink\n+import com.typesafe.scalalogging.StrictLogging\n+import java.time.Instant\n+import java.util\n+import java.util.UUID\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+import scalaz.syntax.tag._\n+\n+import com.digitalasset.api.util.TimestampConversion.fromInstant\n+import com.digitalasset.daml.lf.PureCompiledPackages\n+import com.digitalasset.daml.lf.archive.Dar\n+import com.digitalasset.daml.lf.data.FrontStack\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.language.Ast._\n+import com.digitalasset.daml.lf.speedy.{Compiler, Pretty, SExpr, Speedy, SValue}\n+import com.digitalasset.daml.lf.speedy.SBuiltin._\n+import com.digitalasset.daml.lf.speedy.SExpr._\n+import com.digitalasset.daml.lf.speedy.SResult._\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, RelativeContractId}\n+import com.digitalasset.ledger.api.domain.LedgerId\n+import com.digitalasset.ledger.api.refinements.ApiTypes.ApplicationId\n+import com.digitalasset.ledger.api.v1.command_service.SubmitAndWaitRequest\n+import com.digitalasset.ledger.api.v1.commands._\n+import com.digitalasset.ledger.api.v1.event.{CreatedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.TreeEvent\n+import com.digitalasset.ledger.api.v1.transaction_filter.{\n+  Filters,\n+  TransactionFilter,\n+  InclusiveFilters\n+}\n+import com.digitalasset.ledger.api.v1.value.{Identifier => ApiIdentifier}\n+import com.digitalasset.ledger.api.validation.ValueValidator\n+import com.digitalasset.ledger.client.LedgerClient\n+import com.digitalasset.platform.participant.util.LfEngineToApi.{\n+  toApiIdentifier,\n+  lfValueToApiRecord,\n+  lfValueToApiValue\n+}\n+\n+class Runner(dar: Dar[(PackageId, Package)], applicationId: ApplicationId) extends StrictLogging {\n+\n+  val darMap: Map[PackageId, Package] = dar.all.toMap\n+  val compiler = Compiler(darMap)\n+  val scriptModuleName = DottedName.assertFromString(\"Daml.Script\")\n+  val scriptPackageId: PackageId = dar.all\n+    .find {\n+      case (pkgId, pkg) => pkg.modules.contains(scriptModuleName)\n+    }\n+    .get\n+    ._1\n+  val stdlibPackageId =\n+    dar.all\n+      .find {\n+        case (pkgId, pkg) =>\n+          pkg.modules.contains(DottedName.assertFromString(\"DA.Internal.LF\"))\n+      }\n+      .get\n+      ._1\n+\n+  // We overwrite the definition of toLedgerValue with an identity function.\n+  // This is a type error but Speedy doesn’t care about the types and the only thing we do\n+  // with the result is convert it to ledger values/record so this is safe.\n+  val definitionMap =\n+    compiler.compilePackages(darMap.keys) +\n+      (LfDefRef(\n+        Identifier(\n+          scriptPackageId,\n+          QualifiedName(scriptModuleName, DottedName.assertFromString(\"fromLedgerValue\")))) ->\n+        SEMakeClo(Array(), 1, SEVar(1)))\n+  val compiledPackages = PureCompiledPackages(darMap, definitionMap).right.get\n+\n+  def toLedgerRecord(v: SValue) = {\n+    lfValueToApiRecord(\n+      true,\n+      v.toValue.mapContractId {\n+        case rcoid: RelativeContractId =>\n+          throw new RuntimeException(s\"Unexpected contract id $rcoid\")\n+        case acoid: AbsoluteContractId => acoid\n+      }\n+    )\n+  }\n+\n+  def toLedgerValue(v: SValue) = {\n+    lfValueToApiValue(\n+      true,\n+      v.toValue.mapContractId {\n+        case rcoid: RelativeContractId =>\n+          throw new RuntimeException(s\"Unexpected contract id $rcoid\")\n+        case acoid: AbsoluteContractId => acoid\n+      }\n+    )\n+  }\n+\n+  def getApFields(fun: SValue): (SVariant, SVariant) = {\n+    val extractTuple = SEMakeClo(\n+      Array(),\n+      2,\n+      SEApp(\n+        SEBuiltin(SBTupleCon(Name.Array(Name.assertFromString(\"a\"), Name.assertFromString(\"b\")))),\n+        Array(SEVar(2), SEVar(1))))\n+    val machine =\n+      Speedy.Machine.fromSExpr(SEApp(SEValue(fun), Array(extractTuple)), false, compiledPackages)\n+    while (!machine.isFinal) {\n+      machine.step() match {\n+        case SResultContinue => ()\n+        case res => {\n+          throw new RuntimeException(s\"Unexpected speedy result $res\")\n+        }\n+      }\n+    }\n+    val tuple = machine.toSValue.asInstanceOf[STuple]"
  },
  {
    "id" : "589fd61b-4c7c-47e7-a43e-0190cc50ea64",
    "prId" : 3428,
    "comments" : [
      {
        "id" : "0e5ed90a-cc6d-4a4d-b4e2-78f9090e5c06",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Could some of this be shared between triggers and daml-script?",
        "createdAt" : "2019-11-13T08:26:06Z",
        "updatedAt" : "2019-11-13T08:28:28Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "10dd7665-a72a-41e1-9a70-c61816d16718",
        "parentId" : "0e5ed90a-cc6d-4a4d-b4e2-78f9090e5c06",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We could probably share a bit, e.g., the logic for converting `AnyTemplate` but most of the conversion are specific to the types used in the trigger/script library so the shared code isn’t as large as one might hope. I’ll first cleanup the conversion logic here and then see what we can factor out.",
        "createdAt" : "2019-11-13T08:31:11Z",
        "updatedAt" : "2019-11-13T08:31:11Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e607d4d5daa377415ce47b2303aec1cef06e892e",
    "line" : 80,
    "diffHunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.script\n+\n+import akka.stream.ActorMaterializer\n+import akka.stream.scaladsl.Sink\n+import com.typesafe.scalalogging.StrictLogging\n+import java.time.Instant\n+import java.util\n+import java.util.UUID\n+import scala.collection.JavaConverters._\n+import scala.concurrent.{ExecutionContext, Future}\n+import scalaz.syntax.tag._\n+\n+import com.digitalasset.api.util.TimestampConversion.fromInstant\n+import com.digitalasset.daml.lf.PureCompiledPackages\n+import com.digitalasset.daml.lf.archive.Dar\n+import com.digitalasset.daml.lf.data.FrontStack\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.language.Ast._\n+import com.digitalasset.daml.lf.speedy.{Compiler, Pretty, SExpr, Speedy, SValue}\n+import com.digitalasset.daml.lf.speedy.SBuiltin._\n+import com.digitalasset.daml.lf.speedy.SExpr._\n+import com.digitalasset.daml.lf.speedy.SResult._\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.{AbsoluteContractId, RelativeContractId}\n+import com.digitalasset.ledger.api.domain.LedgerId\n+import com.digitalasset.ledger.api.refinements.ApiTypes.ApplicationId\n+import com.digitalasset.ledger.api.v1.command_service.SubmitAndWaitRequest\n+import com.digitalasset.ledger.api.v1.commands._\n+import com.digitalasset.ledger.api.v1.event.{CreatedEvent}\n+import com.digitalasset.ledger.api.v1.transaction.TreeEvent\n+import com.digitalasset.ledger.api.v1.transaction_filter.{\n+  Filters,\n+  TransactionFilter,\n+  InclusiveFilters\n+}\n+import com.digitalasset.ledger.api.v1.value.{Identifier => ApiIdentifier}\n+import com.digitalasset.ledger.api.validation.ValueValidator\n+import com.digitalasset.ledger.client.LedgerClient\n+import com.digitalasset.platform.participant.util.LfEngineToApi.{\n+  toApiIdentifier,\n+  lfValueToApiRecord,\n+  lfValueToApiValue\n+}\n+\n+class Runner(dar: Dar[(PackageId, Package)], applicationId: ApplicationId) extends StrictLogging {\n+\n+  val darMap: Map[PackageId, Package] = dar.all.toMap\n+  val compiler = Compiler(darMap)\n+  val scriptModuleName = DottedName.assertFromString(\"Daml.Script\")\n+  val scriptPackageId: PackageId = dar.all\n+    .find {\n+      case (pkgId, pkg) => pkg.modules.contains(scriptModuleName)\n+    }\n+    .get\n+    ._1\n+  val stdlibPackageId =\n+    dar.all\n+      .find {\n+        case (pkgId, pkg) =>\n+          pkg.modules.contains(DottedName.assertFromString(\"DA.Internal.LF\"))\n+      }\n+      .get\n+      ._1\n+\n+  // We overwrite the definition of toLedgerValue with an identity function.\n+  // This is a type error but Speedy doesn’t care about the types and the only thing we do\n+  // with the result is convert it to ledger values/record so this is safe.\n+  val definitionMap =\n+    compiler.compilePackages(darMap.keys) +\n+      (LfDefRef(\n+        Identifier(\n+          scriptPackageId,\n+          QualifiedName(scriptModuleName, DottedName.assertFromString(\"fromLedgerValue\")))) ->\n+        SEMakeClo(Array(), 1, SEVar(1)))\n+  val compiledPackages = PureCompiledPackages(darMap, definitionMap).right.get\n+\n+  def toLedgerRecord(v: SValue) = {"
  }
]