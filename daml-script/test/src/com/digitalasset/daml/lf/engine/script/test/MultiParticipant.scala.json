[
  {
    "id" : "d6ac25f6-399f-4a74-a19f-f3eea0045d70",
    "prId" : 3605,
    "comments" : [
      {
        "id" : "806f658f-a68b-4f24-8b07-58fa338837d4",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Shouldn't this be `extraParticipantPort`?",
        "createdAt" : "2019-11-25T10:56:41Z",
        "updatedAt" : "2019-11-25T11:03:31Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bb1b4b4c-6749-49b5-9137-f0db810c370d",
        "parentId" : "806f658f-a68b-4f24-8b07-58fa338837d4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, fixed!",
        "createdAt" : "2019-11-25T11:03:34Z",
        "updatedAt" : "2019-11-25T11:03:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "74efff4194fa02b41d6c85a921cb77b96310f3fb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,86 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.engine.script.test\n+\n+import java.io.File\n+import scalaz.syntax.traverse._\n+\n+import com.digitalasset.daml.lf.archive.Dar\n+import com.digitalasset.daml.lf.archive.DarReader\n+import com.digitalasset.daml.lf.archive.Decode\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.language.Ast._\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml_lf_dev.DamlLf\n+import com.digitalasset.ledger.api.refinements.ApiTypes.{ApplicationId}\n+\n+import com.digitalasset.daml.lf.engine.script._\n+\n+case class MultiParticipantConfig(\n+    ledgerPort: Int,\n+    extraParticipantPort: Int,\n+    darPath: File,\n+    wallclockTime: Boolean)\n+\n+case class MultiTest(dar: Dar[(PackageId, Package)], runner: TestRunner) {\n+  val scriptId = Identifier(dar.main._1, QualifiedName.assertFromString(\"MultiTest:multiTest\"))\n+  def runTests() = {\n+    runner.genericTest(\n+      \"multiTest\",\n+      scriptId,\n+      None,\n+      result => TestRunner.assertEqual(result, SInt64(42), \"Accept return value\"))\n+  }\n+}\n+\n+object MultiParticipant {\n+\n+  private val configParser = new scopt.OptionParser[MultiParticipantConfig](\"daml_script_test\") {\n+    head(\"daml_script_test\")\n+\n+    opt[Int](\"target-port\")\n+      .required()\n+      .action((p, c) => c.copy(ledgerPort = p))\n+\n+    opt[Int](\"extra-participant-port\")\n+      .required()\n+      .action((p, c) => c.copy(extraParticipantPort = p))\n+\n+    arg[File](\"<dar>\")\n+      .required()\n+      .action((d, c) => c.copy(darPath = d))\n+\n+    opt[Unit]('w', \"wall-clock-time\")\n+      .action { (t, c) =>\n+        c.copy(wallclockTime = true)\n+      }\n+      .text(\"Use wall clock time (UTC). When not provided, static time is used.\")\n+  }\n+\n+  private val applicationId = ApplicationId(\"DAML Script Tests\")\n+\n+  def main(args: Array[String]): Unit = {\n+    configParser.parse(args, MultiParticipantConfig(0, 0, null, false)) match {\n+      case None =>\n+        sys.exit(1)\n+      case Some(config) =>\n+        val encodedDar: Dar[(PackageId, DamlLf.ArchivePayload)] =\n+          DarReader().readArchiveFromFile(config.darPath).get\n+        val dar: Dar[(PackageId, Package)] = encodedDar.map {\n+          case (pkgId, pkgArchive) => Decode.readArchivePayload(pkgId, pkgArchive)\n+        }\n+\n+        val participantParams = Participants(\n+          None,\n+          Seq(\n+            (Participant(\"one\"), ApiParameters(\"localhost\", config.ledgerPort)),\n+            (Participant(\"two\"), ApiParameters(\"localhost\", config.ledgerPort))).toMap,"
  }
]