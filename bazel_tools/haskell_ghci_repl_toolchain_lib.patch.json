[
  {
    "id" : "4b620393-98e3-47c4-bd72-7b75d4dd4f9a",
    "prId" : 1712,
    "comments" : [
      {
        "id" : "699edd78-50a8-4435-9a0f-3c8f9cbff9e6",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I don't understand this bit?",
        "createdAt" : "2019-06-17T12:12:04Z",
        "updatedAt" : "2019-06-17T12:18:31Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e8e8781a-61a7-4e0f-b853-8589ca5c38a5",
        "parentId" : "699edd78-50a8-4435-9a0f-3c8f9cbff9e6",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Some toolchain libraries don't have a `deps` attribute, because they don't depend on anything. This is a way of only iterating through `ctx.rule.attr.deps` if that attribute exists. If it doesn't exist, then `getattr(ctx.rule.attr, \"deps\", None)` will return `None`, and `if deps` will not pass.",
        "createdAt" : "2019-06-17T12:18:11Z",
        "updatedAt" : "2019-06-17T12:18:31Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7faedd08ff162113b860c1235e0ba1ba760f5760",
    "line" : 61,
    "diffHunk" : "@@ -0,0 +1,65 @@\n+diff --git a/haskell/private/haskell_impl.bzl b/haskell/private/haskell_impl.bzl\n+index 42f9f0f..af58c03 100644\n+--- a/haskell/private/haskell_impl.bzl\n++++ b/haskell/private/haskell_impl.bzl\n+@@ -689,10 +689,14 @@ def haskell_import_impl(ctx):\n+         # XXX Empty set of conf and cache files only works for global db.\n+         package_databases = set.empty(),\n+         version_macros = version_macros,\n++        source_files = set.empty(),\n++        import_dirs = depset(),\n++        extra_source_files = depset(),\n+         static_libraries = [],\n+         static_libraries_prof = [],\n+         dynamic_libraries = set.empty(),\n+         interface_dirs = set.empty(),\n++        compile_flags = [],\n+         prebuilt_dependencies = set.empty(),\n+         direct_prebuilt_deps = set.empty(),\n+         cc_dependencies = empty_HaskellCcInfo(),\n+diff --git a/haskell/repl.bzl b/haskell/repl.bzl\n+index 4746d3c..fa57cf8 100644\n+--- a/haskell/repl.bzl\n++++ b/haskell/repl.bzl\n+@@ -1,5 +1,6 @@\n+ \"\"\"Multi target Haskell REPL.\"\"\"\n+ \n++load(\"@bazel_skylib//lib:dicts.bzl\", \"dicts\")\n+ load(\"@bazel_skylib//lib:paths.bzl\", \"paths\")\n+ load(\"@bazel_skylib//lib:shell.bzl\", \"shell\")\n+ load(\"@io_tweag_rules_haskell//haskell:private/context.bzl\", \"haskell_context\", \"render_env\")\n+@@ -250,6 +251,7 @@ def _create_repl(hs, ctx, repl_info, output):\n+         repl_info.transitive_cc_dependencies,\n+         path_prefix = \"$RULES_HASKELL_EXEC_ROOT\",\n+     )\n++    ghc_env = dicts.add(hs.env, ghc_env)\n+     library_path = [paths.dirname(lib.path) for lib in library_deps]\n+     ld_library_path = [paths.dirname(lib.path) for lib in ld_library_deps]\n+ \n+@@ -319,6 +321,8 @@ def _create_repl(hs, ctx, repl_info, output):\n+     extra_inputs.extend(set.to_list(repl_info.dep_info.package_databases))\n+     extra_inputs.extend(library_deps)\n+     extra_inputs.extend(ld_library_deps)\n++    if hs.toolchain.locale_archive:\n++        extra_inputs.append(hs.toolchain.locale_archive)\n+     return [DefaultInfo(\n+         executable = output,\n+         runfiles = ctx.runfiles(\n+@@ -328,13 +332,15 @@ def _create_repl(hs, ctx, repl_info, output):\n+     )]\n+ \n+ def _haskell_repl_aspect_impl(target, ctx):\n+-    if HaskellInfo not in target or HaskellPrebuiltPackageInfo in target:\n++    if HaskellInfo not in target:\n+         return []\n+ \n+     target_info = _create_HaskellReplCollectInfo(target, ctx)\n+     deps_infos = [\n+         dep[HaskellReplCollectInfo]\n+-        for dep in ctx.rule.attr.deps\n++        for deps in [getattr(ctx.rule.attr, \"deps\", None)]\n++        if deps"
  }
]