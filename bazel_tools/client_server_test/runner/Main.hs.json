[
  {
    "id" : "3aeac81f-40ce-4fb7-80ce-ea4c60fdfa6c",
    "prId" : 1958,
    "comments" : [
      {
        "id" : "7fd493f7-1591-452e-8901-420f9e99333e",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I don't think this line does what you want it to do because it does nothing. Did you mean `waitForProcess proh`?",
        "createdAt" : "2019-07-01T14:07:59Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "18f11edd-d490-41af-bfc4-cf30d93c7e58",
        "parentId" : "7fd493f7-1591-452e-8901-420f9e99333e",
        "author" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "body" : "ooouups :) Thanks!",
        "createdAt" : "2019-07-01T14:23:13Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7a465264f4a9700efa569404e13dceef9c6af9f",
    "line" : null,
    "diffHunk" : "@@ -42,33 +37,31 @@ readPortFile n file =\n       readPortFile (n-1) file\n     Just p -> pure p\n \n-runCheckedProc :: T.Text -> CreateProcess -> IO () -> IO ()\n-runCheckedProc desc proc resume =\n-  withCheckedProcessCleanup proc $ \\(_ :: Handle) stdoutSrc stderrSrc ->\n-  withAsync (runConduit (stderrSrc .| splitOutput .| C.awaitForever printStderr)) $ \\_ ->\n-  withAsync (runConduit (stdoutSrc .| splitOutput .| C.awaitForever printStdout)) $\n-  const resume\n-\n-  where\n-    printStdout line =\n-      liftIO $ do\n-        T.hPutStrLn stdout $ desc <> \": \" <> line\n-        hFlush stdout\n-    printStderr line =\n-      liftIO $ T.hPutStrLn stderr $ desc <> \": \" <> line\n-    splitOutput = C.T.decode C.T.utf8 .| C.T.lines\n-\n main :: IO ()\n main = do\n   [clientExe, clientArgs, serverExe, serverArgs] <- getArgs\n   tempFile <- emptySystemTempFile \"client-server-test-runner-port\"\n   let splitArgs = filter (/= \"\") . splitOn \" \"\n \n-  let serverProc =\n-        proc serverExe ([\"--port-file\", tempFile] <> splitArgs serverArgs)\n-  runCheckedProc \"SERVER\" serverProc $ do\n+  -- `create_group` is needed on Windows to pass CTRL_BREAK_EVENT to the server process using `interruptProcessGroupOf`\n+  let serverProc = (proc serverExe ([\"--port-file\", tempFile] <> splitArgs serverArgs)) { create_group = True }\n+  withProcess serverProc $ \\_ -> do\n     port <- readPortFile maxRetries tempFile\n     removeFile tempFile\n-    callProcess clientExe\n-      ([\"--target-port\", show port] <> splitArgs clientArgs)\n-    exitSuccess\n+    --  If the command run by `callProcess` returns a non-zero exit code, an exception is raised.\n+    callProcess clientExe ([\"--target-port\", show port] <> splitArgs clientArgs)\n+    return ()\n+\n+withProcess :: CreateProcess -> ((Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> IO a) -> IO a\n+withProcess cp f =\n+    bracket (createProcess cp)\n+    shutdownProcess\n+    f\n+\n+shutdownProcess :: (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> IO ()\n+shutdownProcess (_, _, _, proh) = do\n+    pidOpt <- getPid proh\n+    putStrLn $ \"Sending INT to process: \" <> show pidOpt\n+    interruptProcessGroupOf proh\n+    let _ = waitForProcess"
  },
  {
    "id" : "9ff86812-941a-42b8-aec9-28292ef2e012",
    "prId" : 1958,
    "comments" : [
      {
        "id" : "bb5a5607-7253-441e-afa0-b34fa37bd566",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Are you reinventing withCreateProcess?",
        "createdAt" : "2019-07-01T14:08:26Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b4c0f60-1347-4fbb-b7a8-2eebc05e8e12",
        "parentId" : "bb5a5607-7253-441e-afa0-b34fa37bd566",
        "author" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "body" : "It seems so. I'll double check if it will terminate the JVM without an interrupt sent in the case of an exception in the callback and adapt accordingly.",
        "createdAt" : "2019-07-01T14:44:06Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7a465264f4a9700efa569404e13dceef9c6af9f",
    "line" : null,
    "diffHunk" : "@@ -42,33 +37,31 @@ readPortFile n file =\n       readPortFile (n-1) file\n     Just p -> pure p\n \n-runCheckedProc :: T.Text -> CreateProcess -> IO () -> IO ()\n-runCheckedProc desc proc resume =\n-  withCheckedProcessCleanup proc $ \\(_ :: Handle) stdoutSrc stderrSrc ->\n-  withAsync (runConduit (stderrSrc .| splitOutput .| C.awaitForever printStderr)) $ \\_ ->\n-  withAsync (runConduit (stdoutSrc .| splitOutput .| C.awaitForever printStdout)) $\n-  const resume\n-\n-  where\n-    printStdout line =\n-      liftIO $ do\n-        T.hPutStrLn stdout $ desc <> \": \" <> line\n-        hFlush stdout\n-    printStderr line =\n-      liftIO $ T.hPutStrLn stderr $ desc <> \": \" <> line\n-    splitOutput = C.T.decode C.T.utf8 .| C.T.lines\n-\n main :: IO ()\n main = do\n   [clientExe, clientArgs, serverExe, serverArgs] <- getArgs\n   tempFile <- emptySystemTempFile \"client-server-test-runner-port\"\n   let splitArgs = filter (/= \"\") . splitOn \" \"\n \n-  let serverProc =\n-        proc serverExe ([\"--port-file\", tempFile] <> splitArgs serverArgs)\n-  runCheckedProc \"SERVER\" serverProc $ do\n+  -- `create_group` is needed on Windows to pass CTRL_BREAK_EVENT to the server process using `interruptProcessGroupOf`\n+  let serverProc = (proc serverExe ([\"--port-file\", tempFile] <> splitArgs serverArgs)) { create_group = True }\n+  withProcess serverProc $ \\_ -> do\n     port <- readPortFile maxRetries tempFile\n     removeFile tempFile\n-    callProcess clientExe\n-      ([\"--target-port\", show port] <> splitArgs clientArgs)\n-    exitSuccess\n+    --  If the command run by `callProcess` returns a non-zero exit code, an exception is raised.\n+    callProcess clientExe ([\"--target-port\", show port] <> splitArgs clientArgs)\n+    return ()\n+\n+withProcess :: CreateProcess -> ((Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> IO a) -> IO a\n+withProcess cp f =\n+    bracket (createProcess cp)"
  },
  {
    "id" : "0d4b3a2f-7a56-49ea-999b-f482ed86fb09",
    "prId" : 1958,
    "comments" : [
      {
        "id" : "503d6199-b84f-4e7d-8ed1-4a4d6c435663",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we . just use `withTempFile` from Extra and avoid doing our own cleanup.",
        "createdAt" : "2019-07-01T14:09:02Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "20bf7ede-30a9-40af-b7d4-97c9ad264b9c",
        "parentId" : "503d6199-b84f-4e7d-8ed1-4a4d6c435663",
        "author" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "body" : "it's cleaner now, thanks",
        "createdAt" : "2019-07-02T12:56:04Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7a465264f4a9700efa569404e13dceef9c6af9f",
    "line" : null,
    "diffHunk" : "@@ -42,33 +37,31 @@ readPortFile n file =\n       readPortFile (n-1) file\n     Just p -> pure p\n \n-runCheckedProc :: T.Text -> CreateProcess -> IO () -> IO ()\n-runCheckedProc desc proc resume =\n-  withCheckedProcessCleanup proc $ \\(_ :: Handle) stdoutSrc stderrSrc ->\n-  withAsync (runConduit (stderrSrc .| splitOutput .| C.awaitForever printStderr)) $ \\_ ->\n-  withAsync (runConduit (stdoutSrc .| splitOutput .| C.awaitForever printStdout)) $\n-  const resume\n-\n-  where\n-    printStdout line =\n-      liftIO $ do\n-        T.hPutStrLn stdout $ desc <> \": \" <> line\n-        hFlush stdout\n-    printStderr line =\n-      liftIO $ T.hPutStrLn stderr $ desc <> \": \" <> line\n-    splitOutput = C.T.decode C.T.utf8 .| C.T.lines\n-\n main :: IO ()\n main = do\n   [clientExe, clientArgs, serverExe, serverArgs] <- getArgs\n   tempFile <- emptySystemTempFile \"client-server-test-runner-port\""
  },
  {
    "id" : "a7a70669-5192-46dd-8472-e57d0ac106f7",
    "prId" : 1958,
    "comments" : [
      {
        "id" : "8e72ac1f-93e1-4abb-a1f1-b15436d879ef",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "No need to put a return after callProcess, since callProcess has type `IO ()`.",
        "createdAt" : "2019-07-01T14:09:39Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7a465264f4a9700efa569404e13dceef9c6af9f",
    "line" : null,
    "diffHunk" : "@@ -42,33 +37,31 @@ readPortFile n file =\n       readPortFile (n-1) file\n     Just p -> pure p\n \n-runCheckedProc :: T.Text -> CreateProcess -> IO () -> IO ()\n-runCheckedProc desc proc resume =\n-  withCheckedProcessCleanup proc $ \\(_ :: Handle) stdoutSrc stderrSrc ->\n-  withAsync (runConduit (stderrSrc .| splitOutput .| C.awaitForever printStderr)) $ \\_ ->\n-  withAsync (runConduit (stdoutSrc .| splitOutput .| C.awaitForever printStdout)) $\n-  const resume\n-\n-  where\n-    printStdout line =\n-      liftIO $ do\n-        T.hPutStrLn stdout $ desc <> \": \" <> line\n-        hFlush stdout\n-    printStderr line =\n-      liftIO $ T.hPutStrLn stderr $ desc <> \": \" <> line\n-    splitOutput = C.T.decode C.T.utf8 .| C.T.lines\n-\n main :: IO ()\n main = do\n   [clientExe, clientArgs, serverExe, serverArgs] <- getArgs\n   tempFile <- emptySystemTempFile \"client-server-test-runner-port\"\n   let splitArgs = filter (/= \"\") . splitOn \" \"\n \n-  let serverProc =\n-        proc serverExe ([\"--port-file\", tempFile] <> splitArgs serverArgs)\n-  runCheckedProc \"SERVER\" serverProc $ do\n+  -- `create_group` is needed on Windows to pass CTRL_BREAK_EVENT to the server process using `interruptProcessGroupOf`\n+  let serverProc = (proc serverExe ([\"--port-file\", tempFile] <> splitArgs serverArgs)) { create_group = True }\n+  withProcess serverProc $ \\_ -> do\n     port <- readPortFile maxRetries tempFile\n     removeFile tempFile\n-    callProcess clientExe\n-      ([\"--target-port\", show port] <> splitArgs clientArgs)\n-    exitSuccess\n+    --  If the command run by `callProcess` returns a non-zero exit code, an exception is raised.\n+    callProcess clientExe ([\"--target-port\", show port] <> splitArgs clientArgs)\n+    return ()"
  },
  {
    "id" : "ce42cc64-4143-45e0-a263-5c1a8adea0b2",
    "prId" : 1958,
    "comments" : [
      {
        "id" : "4aaff641-f9b8-42d8-8ad2-fa854a481ea6",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "What was the purpose of this code before? Deleting it seems reasonable, but do you understand why someone did it this way in the first place? Was it from the days we sniffed the port on stdout?",
        "createdAt" : "2019-07-01T14:11:05Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d3fff2ae-ceb5-46a8-a9fa-8f019cab59ba",
        "parentId" : "4aaff641-f9b8-42d8-8ad2-fa854a481ea6",
        "author" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "body" : "It seems to be in such form from the day 1. The main difference from `withCreateProcess` I can see is that server logs are prefixed with `SERVER: ` making the test output a bit easier to read as it can be distinguished from client process' stdout/stderr.",
        "createdAt" : "2019-07-01T14:59:44Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a595599a-afa6-49b0-82f1-a84e0c03febc",
        "parentId" : "4aaff641-f9b8-42d8-8ad2-fa854a481ea6",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "It seems hard to justify that level of additional complexity for a test.",
        "createdAt" : "2019-07-01T15:01:41Z",
        "updatedAt" : "2019-07-02T13:01:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9910945b-1101-4cf1-8b52-81123cd6d4f7",
        "parentId" : "4aaff641-f9b8-42d8-8ad2-fa854a481ea6",
        "author" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "body" : "Actually this part was problematic on Windows as conduits copying stdout/stderr where not getting killed, blocking the runner https://github.com/digital-asset/daml/blob/536b1ea87fe763c278a6dc1caf435de09db77c8c/bazel_tools/client_server_test/runner/Main.hs#L48",
        "createdAt" : "2019-07-02T13:03:07Z",
        "updatedAt" : "2019-07-02T13:03:07Z",
        "lastEditedBy" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7143ec2e-e5be-42d7-8da0-96def7db8584",
        "parentId" : "4aaff641-f9b8-42d8-8ad2-fa854a481ea6",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "In the integration tests, we address this by calling `terminateProcess` at the end https://github.com/digital-asset/daml/blob/c66211d0345250f5bbac8fdf2f171a27f96cd4c3/daml-assistant/integration-tests/src/Main.hs#L287",
        "createdAt" : "2019-07-02T13:09:12Z",
        "updatedAt" : "2019-07-02T13:09:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8a741755-7dbd-4441-b8a6-67afcee93042",
        "parentId" : "4aaff641-f9b8-42d8-8ad2-fa854a481ea6",
        "author" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "body" : "Thanks @cocreature . It doesn't seem to be needed in this case though after removal of `withAsync` bit.",
        "createdAt" : "2019-07-02T14:55:09Z",
        "updatedAt" : "2019-07-02T14:55:09Z",
        "lastEditedBy" : {
          "login" : "majcherm-da",
          "name" : "Michał Majcherski",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/43614029?u=8320ef35eb6289112c9c95df3e483f322c9aa60e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e7a465264f4a9700efa569404e13dceef9c6af9f",
    "line" : 39,
    "diffHunk" : "@@ -42,33 +37,31 @@ readPortFile n file =\n       readPortFile (n-1) file\n     Just p -> pure p\n \n-runCheckedProc :: T.Text -> CreateProcess -> IO () -> IO ()"
  },
  {
    "id" : "43859c7e-fc18-43a8-85d2-70a8650370fb",
    "prId" : 424,
    "comments" : [
      {
        "id" : "60b78d4d-9f9a-4b6d-9e4d-2053c0e15f74",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "s/not avoid/avoid",
        "createdAt" : "2019-04-15T09:16:12Z",
        "updatedAt" : "2019-04-16T17:27:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0c5ac148-2b27-4aac-93d7-72fea594f58e",
        "parentId" : "60b78d4d-9f9a-4b6d-9e4d-2053c0e15f74",
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Also how is the 600 related to 60s? Not clear from the comment.",
        "createdAt" : "2019-04-15T09:16:43Z",
        "updatedAt" : "2019-04-16T17:27:35Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3d38961dc15c7f1453400960e2f30869590d2412",
    "line" : null,
    "diffHunk" : "@@ -21,12 +21,14 @@ import System.Exit\n import Safe\n import Data.List.Split (splitOn)\n \n-maxRetries :: Int\n-maxRetries = 50 -- == wait 5s\n-\n retryInterval :: Int\n retryInterval = 100*1000 -- 100ms\n \n+-- wait maximum of 60s. we use a high timeout to not avoid flakyness in case of"
  }
]