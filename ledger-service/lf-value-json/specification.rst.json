[
  {
    "id" : "b1fbe1de-7276-4fbc-8385-b3076cea377c",
    "prId" : 2519,
    "comments" : [
      {
        "id" : "e36fcd03-2a85-40c8-b069-f3bba4708749",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "why `false`? with `false` data loss might occur.\r\nPlus we currently set both flags to `true`:\r\nhttps://github.com/digital-asset/daml/blob/b4c00727b4ddbaf2da2b015bfda75b762d4e6f6e/ledger-service/lf-value-json/src/main/scala/com/digitalasset/daml/lf/value/json/ApiCodecCompressed.scala#L312-L313",
        "createdAt" : "2019-08-13T20:19:27Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2788bfa7-9a1c-4b6b-ad98-1aae5ad2e777",
        "parentId" : "e36fcd03-2a85-40c8-b069-f3bba4708749",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "> why `false`? with `false` data loss might occur.\r\n\r\nLike I wrote elsewhere, this is un`false`ifiable 🙂 \r\n\r\nThis is just a copy of the original doc, and unless you're interacting with a peer written in a particular programming language, numeric numbers are the better choice. Our own defaults are because of our likelihood of interacting with that particular programming language.",
        "createdAt" : "2019-08-13T20:22:50Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "02937ee3-eb43-43b4-8f64-2134c6c9d5b4",
        "parentId" : "e36fcd03-2a85-40c8-b069-f3bba4708749",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "In this case I would add a line or two explaining the implications of the recommended settings. You talk about this below, but it is not clear that to avoid data loss in JavaScript client you need to encode DAML numbers as JsStrings, which assumes that both flags set to `true`.",
        "createdAt" : "2019-08-13T20:32:18Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04e9b08d-7d1e-4d64-9d32-4ab624a6a214",
        "parentId" : "e36fcd03-2a85-40c8-b069-f3bba4708749",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Sure. 2f993a9014",
        "createdAt" : "2019-08-13T20:37:41Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "70cc02900954a1f1f691b8c55656b187ea98b10b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,433 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-LF JSON Encoding\n+=====================\n+\n+We describe how to decode and encode DAML-LF values as JSON. For each\n+DAML-LF type we explain what JSON inputs we accept (decoding), and what\n+JSON output we produce (encoding).\n+\n+The output format is parameterized by two flags::\n+\n+    encodeDecimalAsString: boolean\n+    encodeInt64AsString: boolean\n+\n+The suggested defaults for both of these flags is false."
  },
  {
    "id" : "7bb0a751-27d3-45a0-88e7-98eaba1bdef5",
    "prId" : 2519,
    "comments" : [
      {
        "id" : "4b8b3dad-f133-4464-ba57-b180a3ade27f",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "should not it be:\r\n```\r\n-42 --> -42\r\n\"-42\" --> -42\r\n```",
        "createdAt" : "2019-08-13T20:23:56Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "07b41489-cdd0-4bfd-af3e-ca0d1cc9cf92",
        "parentId" : "4b8b3dad-f133-4464-ba57-b180a3ade27f",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Yep. dce84202ed",
        "createdAt" : "2019-08-13T20:26:05Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "70cc02900954a1f1f691b8c55656b187ea98b10b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,433 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-LF JSON Encoding\n+=====================\n+\n+We describe how to decode and encode DAML-LF values as JSON. For each\n+DAML-LF type we explain what JSON inputs we accept (decoding), and what\n+JSON output we produce (encoding).\n+\n+The output format is parameterized by two flags::\n+\n+    encodeDecimalAsString: boolean\n+    encodeInt64AsString: boolean\n+\n+The suggested defaults for both of these flags is false.\n+\n+Note that throughout the document the decoding is type-directed. In\n+other words, the same JSON value can correspond to many DAML-LF values,\n+and the expected DAML-LF type is needed to decide which one.\n+\n+ContractId\n+----------\n+\n+Contract ids are expressed as their string representation::\n+\n+    \"123\"\n+    \"XYZ\"\n+    \"foo:bar#baz\"\n+\n+Decimal\n+-------\n+\n+Input\n+~~~~~\n+\n+Decimals can be expressed as JSON numbers or as JSON strings. JSON\n+strings are accepted using the same format that JSON accepts, and\n+treated them as the equivalent JSON number::\n+\n+    -?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\n+\n+Note that JSON numbers would be enough to represent all\n+Decimals. However, we also accept strings because in many languages\n+(most notably JavaScript) use IEEE Doubles to express JSON numbers, and\n+IEEE Doubles cannot express DAML-LF Decimals correctly. Therefore, we\n+also accept strings so that JavaScript users can use them to specify\n+Decimals that do not fit in IEEE Doubles.\n+\n+Numbers must be within the bounds of Decimal, [–(10³⁸–1)÷10¹⁰,\n+(10³⁸–1)÷10¹⁰]. Numbers outside those bounds will be rejected. Numbers\n+inside the bounds will always be accepted, using banker's rounding to\n+fit them within the precision supported by Decimal.\n+\n+A few valid examples::\n+\n+    42 --> 42\n+    42.0 --> 42\n+    \"42\" --> 42\n+    9999999999999999999999999999.9999999999 -->\n+        9999999999999999999999999999.9999999999\n+    -42 --> 42"
  },
  {
    "id" : "ff5dcc8a-82d9-4db0-83d6-f464c803260c",
    "prId" : 2519,
    "comments" : [
      {
        "id" : "6b6668d6-5653-4010-82d6-5456c4d1c318",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "I would say:\r\nRepresented as empty JSON object: ``{}``.",
        "createdAt" : "2019-08-13T20:38:03Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "75e4f252-bfd8-4886-b750-3318e4ea0a0e",
        "parentId" : "6b6668d6-5653-4010-82d6-5456c4d1c318",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Sure. 0f8f2e9c6e",
        "createdAt" : "2019-08-13T20:48:40Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "70cc02900954a1f1f691b8c55656b187ea98b10b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,434 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-LF JSON Encoding\n+=====================\n+\n+We describe how to decode and encode DAML-LF values as JSON. For each\n+DAML-LF type we explain what JSON inputs we accept (decoding), and what\n+JSON output we produce (encoding).\n+\n+The output format is parameterized by two flags::\n+\n+    encodeDecimalAsString: boolean\n+    encodeInt64AsString: boolean\n+\n+The suggested defaults for both of these flags is false.\n+\n+Note that throughout the document the decoding is type-directed. In\n+other words, the same JSON value can correspond to many DAML-LF values,\n+and the expected DAML-LF type is needed to decide which one.\n+\n+ContractId\n+----------\n+\n+Contract ids are expressed as their string representation::\n+\n+    \"123\"\n+    \"XYZ\"\n+    \"foo:bar#baz\"\n+\n+Decimal\n+-------\n+\n+Input\n+~~~~~\n+\n+Decimals can be expressed as JSON numbers or as JSON strings. JSON\n+strings are accepted using the same format that JSON accepts, and\n+treated them as the equivalent JSON number::\n+\n+    -?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\n+\n+Note that JSON numbers would be enough to represent all\n+Decimals. However, we also accept strings because in many languages\n+(most notably JavaScript) use IEEE Doubles to express JSON numbers, and\n+IEEE Doubles cannot express DAML-LF Decimals correctly. Therefore, we\n+also accept strings so that JavaScript users can use them to specify\n+Decimals that do not fit in IEEE Doubles.\n+\n+Numbers must be within the bounds of Decimal, [–(10³⁸–1)÷10¹⁰,\n+(10³⁸–1)÷10¹⁰]. Numbers outside those bounds will be rejected. Numbers\n+inside the bounds will always be accepted, using banker's rounding to\n+fit them within the precision supported by Decimal.\n+\n+A few valid examples::\n+\n+    42 --> 42\n+    42.0 --> 42\n+    \"42\" --> 42\n+    9999999999999999999999999999.9999999999 -->\n+        9999999999999999999999999999.9999999999\n+    -42 --> -42\n+    \"-42\" --> -42\n+    0 --> 0\n+    -0 --> 0\n+    0.30000000000000004 --> 0.3\n+    2e3 --> 2000\n+\n+A few invalid examples::\n+\n+    \"  42  \"\n+    \"blah\"\n+    99999999999999999999999999990\n+    +42\n+\n+Output\n+~~~~~~\n+\n+If encodeDecimalAsString is set, decimals are encoded as strings, using\n+the format ``-?[0-9]{1,28}(\\.[0-9]{1,10})?``. If encodeDecimalAsString\n+is not set, they are encoded as JSON numbers, also using the format\n+``-?[0-9]{1,28}(\\.[0-9]{1,10})?``.\n+ \n+Note that the flag encodeDecimalAsString is useful because it lets\n+JavaScript consumers consume Decimals safely with the standard\n+JSON.parse.\n+\n+Int64\n+-----\n+\n+Input\n+~~~~~\n+\n+Int64, much like Decimal, can be represented as JSON numbers and as\n+strings, with the string representation being ``[+-]?[0-9]+``. The\n+numbers must fall within [-9223372036854775808,\n+9223372036854775807]. Moreover, if represented as JSON numbers, they\n+must have no fractional part.\n+\n+A few valid examples::\n+\n+    42\n+    \"+42\"\n+    -42\n+    0\n+    -0\n+    9223372036854775807\n+    \"9223372036854775807\"\n+    -9223372036854775808\n+    \"-9223372036854775808\"\n+\n+A few invalid examples::\n+\n+    42.3\n+    +42\n+    9223372036854775808\n+    -9223372036854775809\n+    \"garbage\"\n+    \"   42 \"\n+\n+Output\n+~~~~~~\n+\n+If encodeInt64AsString is set, Int64s are encoded as strings, using the\n+format ``-?[0-9]+``. If encodeInt64AsString is not set, they are encoded as\n+JSON numbers, also using the format ``-?[0-9]+``.\n+ \n+Note that the flag encodeInt64AsString is useful because it lets\n+JavaScript consumers consume Int64s safely with the standard\n+``JSON.parse``.\n+\n+Timestamp\n+---------\n+\n+Input\n+~~~~~\n+\n+Timestamps are represented as ISO 8601 strings, rendered using the\n+format ``yyyy-mm-ddThh:mm:ss[.ssssss]Z``::\n+\n+    1990-11-09T04:30:23.1234569Z\n+    1990-11-09T04:30:23Z\n+    1990-11-09T04:30:23.123Z\n+    0001-01-01T00:00:00Z\n+    9999-12-31T23:59:59.999999Z\n+\n+It's OK to omit the microsecond part partially or entirely. Sub-second\n+data beyond microseconds will be dropped. The UTC timezone designator\n+must be included. The rationale behind the inclusion of the timezone\n+designator is minimizing the risk that users pass in local times.\n+\n+The timestamp must be between the bounds specified by DAML-LF and ISO\n+8601, [0001-01-01T00:00:00Z, 9999-12-31T23:59:59.999999Z].\n+\n+JavaScript\n+\n+::\n+\n+    > new Date().toISOString()\n+    '2019-06-18T08:59:34.191Z'\n+\n+Python\n+\n+::\n+\n+    >>> datetime.datetime.utcnow().isoformat() + 'Z'\n+    '2019-06-18T08:59:08.392764Z'\n+\n+Java\n+\n+::\n+\n+    import java.time.Instant;\n+    class Main {\n+        public static void main(String[] args) {\n+            Instant instant = Instant.now();\n+            // prints 2019-06-18T09:02:16.652Z\n+            System.out.println(instant.toString());\n+        }\n+    }\n+\n+Output\n+~~~~~~\n+\n+Timestamps are encoded as ISO 8601 strings, rendered using the format\n+``yyyy-mm-ddThh:mm:ss[.ssssss]Z``.\n+\n+The sub-second part will be formatted as follows:\n+\n+- If no sub-second part is present in the timestamp (i.e. the timestamp\n+  represents whole seconds), the sub-second part will be omitted\n+  entirely;\n+- If the sub-second part does not go beyond milliseconds, the sub-second\n+  part will be up to milliseconds, padding with trailing 0s if\n+  necessary;\n+- Otherwise, the sub-second part will be up to microseconds, padding\n+  with trailing 0s if necessary.\n+\n+In other words, the encoded timestamp will either have no sub-second\n+part, a sub-second part of length 3, or a sub-second part of length 6.\n+\n+Party\n+-----\n+\n+Represented using their string representation, without any additional\n+quotes::\n+\n+    \"Alice\"\n+    \"Bob\"\n+\n+Unit\n+----\n+\n+Represented as ``{}``. Note that ``{} !== {}``, however, ``null`` would"
  },
  {
    "id" : "de9ebdc1-5a9f-4d8e-98d8-e47789617a4c",
    "prId" : 2519,
    "comments" : [
      {
        "id" : "487e6cca-064e-43d3-8974-b3827cf21a98",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "if it is up to me, I would always encode DAML Optional as `JsArray`: [], just for consistency.\r\n```\r\n[]      --> None\r\n[42]     --> Some 42\r\n[[42]]   --> Some (Some 42)\r\n```\r\n",
        "createdAt" : "2019-08-13T20:42:45Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e8ca2aa8-8819-4213-afb7-ce5825018c3d",
        "parentId" : "487e6cca-064e-43d3-8974-b3827cf21a98",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "but at the same time this would require specifying empty `JsArray` for every optional field in the JSON command. Which is a bit too much, I guess. So, scratch the above.",
        "createdAt" : "2019-08-13T20:44:57Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "70cc02900954a1f1f691b8c55656b187ea98b10b",
    "line" : 309,
    "diffHunk" : "@@ -0,0 +1,434 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-LF JSON Encoding\n+=====================\n+\n+We describe how to decode and encode DAML-LF values as JSON. For each\n+DAML-LF type we explain what JSON inputs we accept (decoding), and what\n+JSON output we produce (encoding).\n+\n+The output format is parameterized by two flags::\n+\n+    encodeDecimalAsString: boolean\n+    encodeInt64AsString: boolean\n+\n+The suggested defaults for both of these flags is false.\n+\n+Note that throughout the document the decoding is type-directed. In\n+other words, the same JSON value can correspond to many DAML-LF values,\n+and the expected DAML-LF type is needed to decide which one.\n+\n+ContractId\n+----------\n+\n+Contract ids are expressed as their string representation::\n+\n+    \"123\"\n+    \"XYZ\"\n+    \"foo:bar#baz\"\n+\n+Decimal\n+-------\n+\n+Input\n+~~~~~\n+\n+Decimals can be expressed as JSON numbers or as JSON strings. JSON\n+strings are accepted using the same format that JSON accepts, and\n+treated them as the equivalent JSON number::\n+\n+    -?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\n+\n+Note that JSON numbers would be enough to represent all\n+Decimals. However, we also accept strings because in many languages\n+(most notably JavaScript) use IEEE Doubles to express JSON numbers, and\n+IEEE Doubles cannot express DAML-LF Decimals correctly. Therefore, we\n+also accept strings so that JavaScript users can use them to specify\n+Decimals that do not fit in IEEE Doubles.\n+\n+Numbers must be within the bounds of Decimal, [–(10³⁸–1)÷10¹⁰,\n+(10³⁸–1)÷10¹⁰]. Numbers outside those bounds will be rejected. Numbers\n+inside the bounds will always be accepted, using banker's rounding to\n+fit them within the precision supported by Decimal.\n+\n+A few valid examples::\n+\n+    42 --> 42\n+    42.0 --> 42\n+    \"42\" --> 42\n+    9999999999999999999999999999.9999999999 -->\n+        9999999999999999999999999999.9999999999\n+    -42 --> -42\n+    \"-42\" --> -42\n+    0 --> 0\n+    -0 --> 0\n+    0.30000000000000004 --> 0.3\n+    2e3 --> 2000\n+\n+A few invalid examples::\n+\n+    \"  42  \"\n+    \"blah\"\n+    99999999999999999999999999990\n+    +42\n+\n+Output\n+~~~~~~\n+\n+If encodeDecimalAsString is set, decimals are encoded as strings, using\n+the format ``-?[0-9]{1,28}(\\.[0-9]{1,10})?``. If encodeDecimalAsString\n+is not set, they are encoded as JSON numbers, also using the format\n+``-?[0-9]{1,28}(\\.[0-9]{1,10})?``.\n+ \n+Note that the flag encodeDecimalAsString is useful because it lets\n+JavaScript consumers consume Decimals safely with the standard\n+JSON.parse.\n+\n+Int64\n+-----\n+\n+Input\n+~~~~~\n+\n+Int64, much like Decimal, can be represented as JSON numbers and as\n+strings, with the string representation being ``[+-]?[0-9]+``. The\n+numbers must fall within [-9223372036854775808,\n+9223372036854775807]. Moreover, if represented as JSON numbers, they\n+must have no fractional part.\n+\n+A few valid examples::\n+\n+    42\n+    \"+42\"\n+    -42\n+    0\n+    -0\n+    9223372036854775807\n+    \"9223372036854775807\"\n+    -9223372036854775808\n+    \"-9223372036854775808\"\n+\n+A few invalid examples::\n+\n+    42.3\n+    +42\n+    9223372036854775808\n+    -9223372036854775809\n+    \"garbage\"\n+    \"   42 \"\n+\n+Output\n+~~~~~~\n+\n+If encodeInt64AsString is set, Int64s are encoded as strings, using the\n+format ``-?[0-9]+``. If encodeInt64AsString is not set, they are encoded as\n+JSON numbers, also using the format ``-?[0-9]+``.\n+ \n+Note that the flag encodeInt64AsString is useful because it lets\n+JavaScript consumers consume Int64s safely with the standard\n+``JSON.parse``.\n+\n+Timestamp\n+---------\n+\n+Input\n+~~~~~\n+\n+Timestamps are represented as ISO 8601 strings, rendered using the\n+format ``yyyy-mm-ddThh:mm:ss[.ssssss]Z``::\n+\n+    1990-11-09T04:30:23.1234569Z\n+    1990-11-09T04:30:23Z\n+    1990-11-09T04:30:23.123Z\n+    0001-01-01T00:00:00Z\n+    9999-12-31T23:59:59.999999Z\n+\n+It's OK to omit the microsecond part partially or entirely. Sub-second\n+data beyond microseconds will be dropped. The UTC timezone designator\n+must be included. The rationale behind the inclusion of the timezone\n+designator is minimizing the risk that users pass in local times.\n+\n+The timestamp must be between the bounds specified by DAML-LF and ISO\n+8601, [0001-01-01T00:00:00Z, 9999-12-31T23:59:59.999999Z].\n+\n+JavaScript\n+\n+::\n+\n+    > new Date().toISOString()\n+    '2019-06-18T08:59:34.191Z'\n+\n+Python\n+\n+::\n+\n+    >>> datetime.datetime.utcnow().isoformat() + 'Z'\n+    '2019-06-18T08:59:08.392764Z'\n+\n+Java\n+\n+::\n+\n+    import java.time.Instant;\n+    class Main {\n+        public static void main(String[] args) {\n+            Instant instant = Instant.now();\n+            // prints 2019-06-18T09:02:16.652Z\n+            System.out.println(instant.toString());\n+        }\n+    }\n+\n+Output\n+~~~~~~\n+\n+Timestamps are encoded as ISO 8601 strings, rendered using the format\n+``yyyy-mm-ddThh:mm:ss[.ssssss]Z``.\n+\n+The sub-second part will be formatted as follows:\n+\n+- If no sub-second part is present in the timestamp (i.e. the timestamp\n+  represents whole seconds), the sub-second part will be omitted\n+  entirely;\n+- If the sub-second part does not go beyond milliseconds, the sub-second\n+  part will be up to milliseconds, padding with trailing 0s if\n+  necessary;\n+- Otherwise, the sub-second part will be up to microseconds, padding\n+  with trailing 0s if necessary.\n+\n+In other words, the encoded timestamp will either have no sub-second\n+part, a sub-second part of length 3, or a sub-second part of length 6.\n+\n+Party\n+-----\n+\n+Represented using their string representation, without any additional\n+quotes::\n+\n+    \"Alice\"\n+    \"Bob\"\n+\n+Unit\n+----\n+\n+Represented as ``{}``. Note that ``{} !== {}``, however, ``null`` would\n+be ambiguous; for the type ``Optional Unit``, ``null`` decodes to\n+``None``, but ``{}`` decodes to ``Some ()``.\n+\n+Additionally, we think that this is the least confusing encoding for\n+Unit since unit is conceptually an empty record.  We do not want to\n+imply that Unit is used similarly to null in JavaScript or None in\n+Python.\n+\n+Date\n+----\n+\n+Represented as an ISO 8601 date rendered using the format\n+``yyyy-mm-dd``::\n+\n+    2019-06-18\n+    9999-12-31\n+    0001-01-01\n+\n+The dates must be between the bounds specified by DAML-LF and ISO 8601,\n+[0001-01-01, 9999-99-99].\n+\n+Text\n+----\n+\n+Represented as JSON strings.\n+\n+Bool\n+----\n+\n+Represented as JSON booleans.\n+\n+Record\n+------\n+\n+Input\n+~~~~~\n+\n+Records can be represented in two ways. As JSON objects::\n+\n+    { f₁: v₁, ..., fₙ: vₙ }\n+\n+And as arrays::\n+\n+    [ v₁, ..., vₙ ]\n+\n+Note that DAML-LF record fields are ordered. So if we have\n+\n+::\n+\n+    record Foo = {f1: Int64, f2: Bool}\n+\n+when representing the record as an array the user must specify the\n+fields in order::\n+\n+    [42, true]\n+\n+The motivation for the array format for records is to allow specifying\n+tuple types closer to what it looks like in DAML. Note that a DAML\n+tuple, i.e. (42, True), will be compiled to a DAML-LF record ``Tuple2 {\n+_1 = 42, _2 = True }``.\n+\n+Output\n+~~~~~~\n+\n+Records are always encoded as JSON objects.\n+\n+List\n+----\n+\n+Lists are represented as\n+\n+::\n+\n+    [v₁, ..., vₙ]\n+\n+Map\n+---\n+\n+Maps are represented as JSON objects:\n+\n+::\n+\n+    { k₁: v₁, ..., kₙ: vₙ }\n+\n+Optional\n+--------\n+\n+Input\n+~~~~~\n+\n+Optionals are encoded using ``null`` if the value is None, and with the"
  },
  {
    "id" : "262db366-939b-4735-9817-5565d193a8f0",
    "prId" : 2519,
    "comments" : [
      {
        "id" : "b6c18dde-5be5-4383-9016-9d40b251b472",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Enums are represented as JSON strings.",
        "createdAt" : "2019-08-13T20:47:17Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c36483da-620f-4eeb-bcd7-8bb8f3eeafa3",
        "parentId" : "b6c18dde-5be5-4383-9016-9d40b251b472",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Is that not clear?",
        "createdAt" : "2019-08-13T20:48:17Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a777accf-ec81-4eaa-86cb-a1ef2c9621e5",
        "parentId" : "b6c18dde-5be5-4383-9016-9d40b251b472",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "you are saying above that records represented as JSON objects.... so for consistency, I would say as JSON strings here too.",
        "createdAt" : "2019-08-13T20:49:44Z",
        "updatedAt" : "2019-08-13T21:22:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b235a51c-ab12-44f7-ad98-ae57a0034878",
        "parentId" : "b6c18dde-5be5-4383-9016-9d40b251b472",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I'll delete the JSON prefix from objects. 70cc029009",
        "createdAt" : "2019-08-13T21:19:22Z",
        "updatedAt" : "2019-08-13T21:22:39Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "70cc02900954a1f1f691b8c55656b187ea98b10b",
    "line" : 432,
    "diffHunk" : "@@ -0,0 +1,434 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+DAML-LF JSON Encoding\n+=====================\n+\n+We describe how to decode and encode DAML-LF values as JSON. For each\n+DAML-LF type we explain what JSON inputs we accept (decoding), and what\n+JSON output we produce (encoding).\n+\n+The output format is parameterized by two flags::\n+\n+    encodeDecimalAsString: boolean\n+    encodeInt64AsString: boolean\n+\n+The suggested defaults for both of these flags is false.\n+\n+Note that throughout the document the decoding is type-directed. In\n+other words, the same JSON value can correspond to many DAML-LF values,\n+and the expected DAML-LF type is needed to decide which one.\n+\n+ContractId\n+----------\n+\n+Contract ids are expressed as their string representation::\n+\n+    \"123\"\n+    \"XYZ\"\n+    \"foo:bar#baz\"\n+\n+Decimal\n+-------\n+\n+Input\n+~~~~~\n+\n+Decimals can be expressed as JSON numbers or as JSON strings. JSON\n+strings are accepted using the same format that JSON accepts, and\n+treated them as the equivalent JSON number::\n+\n+    -?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\n+\n+Note that JSON numbers would be enough to represent all\n+Decimals. However, we also accept strings because in many languages\n+(most notably JavaScript) use IEEE Doubles to express JSON numbers, and\n+IEEE Doubles cannot express DAML-LF Decimals correctly. Therefore, we\n+also accept strings so that JavaScript users can use them to specify\n+Decimals that do not fit in IEEE Doubles.\n+\n+Numbers must be within the bounds of Decimal, [–(10³⁸–1)÷10¹⁰,\n+(10³⁸–1)÷10¹⁰]. Numbers outside those bounds will be rejected. Numbers\n+inside the bounds will always be accepted, using banker's rounding to\n+fit them within the precision supported by Decimal.\n+\n+A few valid examples::\n+\n+    42 --> 42\n+    42.0 --> 42\n+    \"42\" --> 42\n+    9999999999999999999999999999.9999999999 -->\n+        9999999999999999999999999999.9999999999\n+    -42 --> -42\n+    \"-42\" --> -42\n+    0 --> 0\n+    -0 --> 0\n+    0.30000000000000004 --> 0.3\n+    2e3 --> 2000\n+\n+A few invalid examples::\n+\n+    \"  42  \"\n+    \"blah\"\n+    99999999999999999999999999990\n+    +42\n+\n+Output\n+~~~~~~\n+\n+If encodeDecimalAsString is set, decimals are encoded as strings, using\n+the format ``-?[0-9]{1,28}(\\.[0-9]{1,10})?``. If encodeDecimalAsString\n+is not set, they are encoded as JSON numbers, also using the format\n+``-?[0-9]{1,28}(\\.[0-9]{1,10})?``.\n+ \n+Note that the flag encodeDecimalAsString is useful because it lets\n+JavaScript consumers consume Decimals safely with the standard\n+JSON.parse.\n+\n+Int64\n+-----\n+\n+Input\n+~~~~~\n+\n+Int64, much like Decimal, can be represented as JSON numbers and as\n+strings, with the string representation being ``[+-]?[0-9]+``. The\n+numbers must fall within [-9223372036854775808,\n+9223372036854775807]. Moreover, if represented as JSON numbers, they\n+must have no fractional part.\n+\n+A few valid examples::\n+\n+    42\n+    \"+42\"\n+    -42\n+    0\n+    -0\n+    9223372036854775807\n+    \"9223372036854775807\"\n+    -9223372036854775808\n+    \"-9223372036854775808\"\n+\n+A few invalid examples::\n+\n+    42.3\n+    +42\n+    9223372036854775808\n+    -9223372036854775809\n+    \"garbage\"\n+    \"   42 \"\n+\n+Output\n+~~~~~~\n+\n+If encodeInt64AsString is set, Int64s are encoded as strings, using the\n+format ``-?[0-9]+``. If encodeInt64AsString is not set, they are encoded as\n+JSON numbers, also using the format ``-?[0-9]+``.\n+ \n+Note that the flag encodeInt64AsString is useful because it lets\n+JavaScript consumers consume Int64s safely with the standard\n+``JSON.parse``.\n+\n+Timestamp\n+---------\n+\n+Input\n+~~~~~\n+\n+Timestamps are represented as ISO 8601 strings, rendered using the\n+format ``yyyy-mm-ddThh:mm:ss[.ssssss]Z``::\n+\n+    1990-11-09T04:30:23.1234569Z\n+    1990-11-09T04:30:23Z\n+    1990-11-09T04:30:23.123Z\n+    0001-01-01T00:00:00Z\n+    9999-12-31T23:59:59.999999Z\n+\n+It's OK to omit the microsecond part partially or entirely. Sub-second\n+data beyond microseconds will be dropped. The UTC timezone designator\n+must be included. The rationale behind the inclusion of the timezone\n+designator is minimizing the risk that users pass in local times.\n+\n+The timestamp must be between the bounds specified by DAML-LF and ISO\n+8601, [0001-01-01T00:00:00Z, 9999-12-31T23:59:59.999999Z].\n+\n+JavaScript\n+\n+::\n+\n+    > new Date().toISOString()\n+    '2019-06-18T08:59:34.191Z'\n+\n+Python\n+\n+::\n+\n+    >>> datetime.datetime.utcnow().isoformat() + 'Z'\n+    '2019-06-18T08:59:08.392764Z'\n+\n+Java\n+\n+::\n+\n+    import java.time.Instant;\n+    class Main {\n+        public static void main(String[] args) {\n+            Instant instant = Instant.now();\n+            // prints 2019-06-18T09:02:16.652Z\n+            System.out.println(instant.toString());\n+        }\n+    }\n+\n+Output\n+~~~~~~\n+\n+Timestamps are encoded as ISO 8601 strings, rendered using the format\n+``yyyy-mm-ddThh:mm:ss[.ssssss]Z``.\n+\n+The sub-second part will be formatted as follows:\n+\n+- If no sub-second part is present in the timestamp (i.e. the timestamp\n+  represents whole seconds), the sub-second part will be omitted\n+  entirely;\n+- If the sub-second part does not go beyond milliseconds, the sub-second\n+  part will be up to milliseconds, padding with trailing 0s if\n+  necessary;\n+- Otherwise, the sub-second part will be up to microseconds, padding\n+  with trailing 0s if necessary.\n+\n+In other words, the encoded timestamp will either have no sub-second\n+part, a sub-second part of length 3, or a sub-second part of length 6.\n+\n+Party\n+-----\n+\n+Represented using their string representation, without any additional\n+quotes::\n+\n+    \"Alice\"\n+    \"Bob\"\n+\n+Unit\n+----\n+\n+Represented as ``{}``. Note that ``{} !== {}``, however, ``null`` would\n+be ambiguous; for the type ``Optional Unit``, ``null`` decodes to\n+``None``, but ``{}`` decodes to ``Some ()``.\n+\n+Additionally, we think that this is the least confusing encoding for\n+Unit since unit is conceptually an empty record.  We do not want to\n+imply that Unit is used similarly to null in JavaScript or None in\n+Python.\n+\n+Date\n+----\n+\n+Represented as an ISO 8601 date rendered using the format\n+``yyyy-mm-dd``::\n+\n+    2019-06-18\n+    9999-12-31\n+    0001-01-01\n+\n+The dates must be between the bounds specified by DAML-LF and ISO 8601,\n+[0001-01-01, 9999-99-99].\n+\n+Text\n+----\n+\n+Represented as JSON strings.\n+\n+Bool\n+----\n+\n+Represented as JSON booleans.\n+\n+Record\n+------\n+\n+Input\n+~~~~~\n+\n+Records can be represented in two ways. As JSON objects::\n+\n+    { f₁: v₁, ..., fₙ: vₙ }\n+\n+And as arrays::\n+\n+    [ v₁, ..., vₙ ]\n+\n+Note that DAML-LF record fields are ordered. So if we have\n+\n+::\n+\n+    record Foo = {f1: Int64, f2: Bool}\n+\n+when representing the record as an array the user must specify the\n+fields in order::\n+\n+    [42, true]\n+\n+The motivation for the array format for records is to allow specifying\n+tuple types closer to what it looks like in DAML. Note that a DAML\n+tuple, i.e. (42, True), will be compiled to a DAML-LF record ``Tuple2 {\n+_1 = 42, _2 = True }``.\n+\n+Output\n+~~~~~~\n+\n+Records are always encoded as JSON objects.\n+\n+List\n+----\n+\n+Lists are represented as\n+\n+::\n+\n+    [v₁, ..., vₙ]\n+\n+Map\n+---\n+\n+Maps are represented as JSON objects:\n+\n+::\n+\n+    { k₁: v₁, ..., kₙ: vₙ }\n+\n+Optional\n+--------\n+\n+Input\n+~~~~~\n+\n+Optionals are encoded using ``null`` if the value is None, and with the\n+value itself if it's Some. However, this alone does not let us encode\n+nested optionals unambiguously. Therefore, nested Optionals are encoded\n+using an empty list for None, and a list with one element for Some. Note\n+that after the top-level Optional, all the nested ones must be\n+represented using the list notation.\n+\n+A few examples, using the form\n+\n+::\n+\n+    JSON  -->  DAML-LF  :  Expected DAML-LF type\n+\n+to make clear what the target DAML-LF type is::\n+\n+    null    -->  None                  : Optional Int64\n+    null    -->  None                  : Optional (Optional Int64)\n+    42      -->  Some 42               : Optional Int64\n+    []      -->  Some None             : Optional (Optional Int64)\n+    [42]    -->  Some (Some 42)        : Optional (Optional Int64)\n+    [[]]    -->  Some (Some None)      : Optional (Optional (Optional Int64))\n+    [[42]]  -->  Some (Some (Some 42)) : Optional (Optional (Optional Int64))\n+    ...\n+\n+Finally, if Optional values appear in records, they can be omitted to\n+represent None. Given DAML-LF types\n+\n+::\n+\n+    record Depth1 = { foo: Optional Int64 }\n+    record Depth2 = { foo: Optional (Optional Int64) }\n+\n+We have\n+\n+::\n+\n+    { }              -->  Depth1 { foo: None }            :  Depth1\n+    { }              -->  Depth2 { foo: None }            :  Depth2\n+    { foo: 42 }      -->  Depth1 { foo: Some 42 }         :  Depth1\n+    { foo: [42] }    -->  Depth2 { foo: Some (Some 42) }  :  Depth2\n+    { foo: null }    -->  Depth1 { foo: None }            :  Depth1\n+    { foo: null }    -->  Depth2 { foo: None }            :  Depth2\n+    { foo: [] }      -->  Depth2 { foo: Some None }       :  Depth2\n+\n+Note that the shortcut for records and Optional fields does not apply to\n+Map (which are also represented as JSON objects), since Map relies on\n+absence of key to determine what keys are present in the Map to begin\n+with.  Nor does it apply to the ``[f₁, ..., fₙ]`` record form; ``Depth1\n+None`` in the array notation must be written as ``[null]``.\n+\n+Type variables may appear in the DAML-LF language, but are always\n+resolved before deciding on a JSON encoding.  So, for example, even\n+though ``Oa`` doesn't appear to contain a nested ``Optional``, it may\n+contain a nested ``Optional`` by virtue of substituting the type\n+variable ``a``::\n+\n+    record Oa a = { foo: Optional a }\n+\n+    { foo: 42 }     -->  Oa { foo: Some 42 }        : Oa Int\n+    { }             -->  Oa { foo: None }           : Oa Int\n+    { foo: [] }     -->  Oa { foo: Some None }      : Oa (Optional Int)\n+    { foo: [42] }   -->  Oa { foo: Some (Some 42) } : Oa (Optional Int)\n+\n+In other words, the correct JSON encoding for any LF value is the one\n+you get when you have eliminated all type variables.\n+\n+Output\n+~~~~~~\n+\n+Encoded as described above, always applying the shortcut for None record\n+fields.\n+\n+Variant\n+-------\n+\n+Variants are expressed as\n+\n+::\n+\n+    { constructor: argument }\n+\n+For example, if we have\n+\n+::\n+\n+    variant Foo = Bar Int64 | Baz Unit | Quux (Optional Int64)\n+\n+These are all valid JSON encodings for values of type Foo::\n+\n+    {\"Bar\": 42}\n+    {\"Baz\": {}}\n+    {\"Quux\": null}\n+    {\"Quux\": 42}\n+\n+Note that DAML data types with named fields are compiled by factoring\n+out the record. So for example if we have\n+\n+::\n+\n+    data Foo = Bar {f1: Int64, f2: Bool} | Baz\n+\n+We'll get in DAML-LF\n+\n+::\n+\n+    record Foo.Bar = {f1: Int64, f2: Bool}\n+    variant Foo = Bar Foo.Bar | Baz Unit\n+\n+and then, from JSON\n+\n+::\n+\n+    {\"Bar\": {\"f1\": 42, \"f2\": true}}\n+    {\"Baz\": {}}\n+\n+This can be encoded and used in TypeScript, including exhaustiveness\n+checking; see `a keyed example`_.\n+\n+.. _a keyed example: https://www.typescriptlang.org/play/#src=type%20Foo%20%3D%0D%0A%20%20%20%20%7B%20Bar%3A%20%7B%20f1%3A%20number%2C%20f2%3A%20boolean%20%7D%20%7D%0D%0A%20%20%7C%20%7B%20Baz%3A%20%7B%20f3%3A%20string%20%7D%20%7D%3B%0D%0A%0D%0Afunction%20test(v%3A%20Foo)%20%7B%0D%0A%20%20if%20(%22Bar%22%20in%20v)%20%7B%0D%0A%20%20%20%20console.log(v.Bar.f1%2C%20v.Bar.f2)%3B%0D%0A%20%20%7D%20else%20if%20(%22Baz%22%20in%20v)%20%7B%0D%0A%20%20%20%20console.log(v.Baz.f3)%3B%0D%0A%20%20%7D%20else%20%7B%0D%0A%20%20%20%20const%20_%3A%20never%20%3D%20v%3B%0D%0A%20%20%7D%0D%0A%7D%20%0D%0A\n+\n+Enum\n+----\n+\n+Enums are represented as strings. So if we have"
  }
]