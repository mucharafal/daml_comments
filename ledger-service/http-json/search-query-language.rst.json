[
  {
    "id" : "da67628b-3e05-4b75-855d-52ddcd3c3287",
    "prId" : 2826,
    "comments" : [
      {
        "id" : "c6f47de2-90f6-4d8b-b158-70d89a383156",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Just thinking about this... Maybe `%templates` should NOT be an `Array`? In this case if typecheck fails, it will be clear what `Template` it failed for. I bet we can improve the error reporting and maybe it already provides all required information, but it just looks strange to me that we may return totally unrelated types in one result set.",
        "createdAt" : "2019-09-20T13:31:48Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4b643cd9-dfc5-4a4e-8b97-6ceaeaa20181",
        "parentId" : "c6f47de2-90f6-4d8b-b158-70d89a383156",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "If it helps, you can think of the result type as a list of values of variant type, where the variant data constructor is a template ID rather than a string or int. If it does not help, well, we can reconsider elsewhere.",
        "createdAt" : "2019-09-20T18:06:24Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "078ec69a5240afdc0f2e7a5ee0646566cc902378",
    "line" : 87,
    "diffHunk" : "@@ -0,0 +1,99 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+/contracts/search query language\n+================================\n+\n+The body of ``POST /contracts/search`` looks like so::\n+\n+  {\"%templates\": [...template IDs...],\n+   ...other query elements...}\n+\n+The elements of that query are defined here.\n+\n+Fallback rule\n+-------------\n+\n+Unless otherwise required by one of the other rules below or to follow,\n+values are interpreted according to the `LF values' JSON format\n+<../lf-value-json/specification.rst>`_, and compared for equality.\n+\n+Simple equality\n+---------------\n+\n+Match documents having at least all the (potentially nested) keys\n+expressed in the query. The result document may contain additional\n+properties.\n+\n+Example: ``{ person: { name: \"Bob\" }, city: \"London\" }``\n+\n+- Match: ``{ person: { name: \"Bob\", dob: \"1956-06-21\" }, city: \"London\",\n+  createdAt: \"2019-04-30T12:34:12Z\" }``\n+- No match: ``{ person: { name: \"Bob\" }, city: \"Zurich\" }``\n+- Typecheck failure: ``{ person: { name: [\"Bob\", \"Sue\"] }, city:\n+  \"London\" }``\n+\n+Example: ``{ favorites: [\"vanilla\", \"chocolate\"] }``\n+\n+- Match: ``{ favorites: [\"vanilla\", \"chocolate\"] }``\n+- No match: ``{ favorites: [\"chocolate\", \"vanilla\"] }``\n+- No match: ``{ favorites: [\"vanilla\", \"strawberry\"] }``\n+- No match: ``{ favorites: [\"vanilla\", \"chocolate\", \"strawberry\"] }``\n+\n+A JSON object, when considered with a record type, is always interpreted\n+as a field equality query. Its type context is thus mutually exclusive\n+with `the forthcoming comparison queries\n+<https://github.com/digital-asset/daml/issues/2780>`_.\n+\n+Appendix: Type-aware queries\n+----------------------------\n+\n+**This section is non-normative.**\n+\n+This is not a *JSON* query language, it is a *DAML-LF* query\n+language. So, while we could theoretically treat queries (where not\n+otherwise interpreted by the \"may contain additional properties\" rule\n+above) without concern for what LF type (i.e. template) we're\n+considering, we *will not* do so.\n+\n+Consider the subquery ``{\"foo\": \"bar\"}``. This query conforms to types,\n+among an unbounded number of others::\n+\n+  record A ↦ { foo : Text }\n+  record B ↦ { foo : Optional Text }\n+  variant C ↦ foo : Party | bar : Unit\n+\n+  // NB: LF does not require any particular case for VariantCon or Field;\n+  // these are perfectly legal types in DAML-LF packages\n+\n+In the cases of ``A`` and ``B``, ``\"foo\"`` is part of the query\n+language, and only ``\"bar\"`` is treated as an LF value; in the case of\n+``C``, the whole query is treated as an LF value. The wide variety of\n+ambiguous interpretations about what elements are interpreted, and what\n+elements treated as literal, and *how* those elements are interpreted or\n+compared, would preclude many techniques for efficient query compilation\n+and LF value representation that we might otherwise consider.\n+\n+Additionally, it would be extremely easy to overlook unintended meanings\n+of queries when writing them, and impossible in many cases to suppress\n+those unintended meanings within the query language. For example, there\n+is no way that the above query could be written to match ``A`` but never\n+``C``.\n+\n+For these reasons, as with LF value input via JSON, queries written in\n+JSON are also always interpreted with respect to some specified LF types\n+(e.g. template IDs). As #2777 implies, for example::\n+\n+  {\"%templates\": [{\"moduleName\": \"Foo\", \"entityName\": \"A\"},"
  },
  {
    "id" : "40e7b6cc-cf1c-46ec-9fe8-542b42bb4ba0",
    "prId" : 2826,
    "comments" : [
      {
        "id" : "9e6d12ff-f539-4ddb-9332-dcae6338d17d",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Can you add an example here?",
        "createdAt" : "2019-09-20T13:35:19Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ba379ea9-2752-4797-ae94-9ea7389c6077",
        "parentId" : "9e6d12ff-f539-4ddb-9332-dcae6338d17d",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "No, because\r\n\r\n1. this is a statement that _no example of x exists_, and\r\n2. to exemplify indirectly (e.g. by saying \"this is always left, and this is always right\", though I am skeptical of the value of such an inclusion) would require the full definition of comparison queries as meaningful context, which does not belong in this document until #2780.",
        "createdAt" : "2019-09-20T18:08:37Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "078ec69a5240afdc0f2e7a5ee0646566cc902378",
    "line" : 45,
    "diffHunk" : "@@ -0,0 +1,99 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+/contracts/search query language\n+================================\n+\n+The body of ``POST /contracts/search`` looks like so::\n+\n+  {\"%templates\": [...template IDs...],\n+   ...other query elements...}\n+\n+The elements of that query are defined here.\n+\n+Fallback rule\n+-------------\n+\n+Unless otherwise required by one of the other rules below or to follow,\n+values are interpreted according to the `LF values' JSON format\n+<../lf-value-json/specification.rst>`_, and compared for equality.\n+\n+Simple equality\n+---------------\n+\n+Match documents having at least all the (potentially nested) keys\n+expressed in the query. The result document may contain additional\n+properties.\n+\n+Example: ``{ person: { name: \"Bob\" }, city: \"London\" }``\n+\n+- Match: ``{ person: { name: \"Bob\", dob: \"1956-06-21\" }, city: \"London\",\n+  createdAt: \"2019-04-30T12:34:12Z\" }``\n+- No match: ``{ person: { name: \"Bob\" }, city: \"Zurich\" }``\n+- Typecheck failure: ``{ person: { name: [\"Bob\", \"Sue\"] }, city:\n+  \"London\" }``\n+\n+Example: ``{ favorites: [\"vanilla\", \"chocolate\"] }``\n+\n+- Match: ``{ favorites: [\"vanilla\", \"chocolate\"] }``\n+- No match: ``{ favorites: [\"chocolate\", \"vanilla\"] }``\n+- No match: ``{ favorites: [\"vanilla\", \"strawberry\"] }``\n+- No match: ``{ favorites: [\"vanilla\", \"chocolate\", \"strawberry\"] }``\n+\n+A JSON object, when considered with a record type, is always interpreted\n+as a field equality query. Its type context is thus mutually exclusive\n+with `the forthcoming comparison queries"
  },
  {
    "id" : "b0ce561c-266c-4acc-bbb7-f61b96620fae",
    "prId" : 2826,
    "comments" : [
      {
        "id" : "9944a3e3-a647-416e-93b9-cbac2e8d5dba",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I'm curious why this paragraph talks about `documents` and not about `contracts` and/or values specifically?",
        "createdAt" : "2019-09-23T15:06:44Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b27938cb-3dee-4ff2-acf5-80002ed1dc9d",
        "parentId" : "9944a3e3-a647-416e-93b9-cbac2e8d5dba",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Copypasta :) b99d5f0e2a",
        "createdAt" : "2019-09-23T19:08:36Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "078ec69a5240afdc0f2e7a5ee0646566cc902378",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,99 @@\n+.. Copyright (c) 2019 The DAML Authors. All rights reserved.\n+.. SPDX-License-Identifier: Apache-2.0\n+\n+/contracts/search query language\n+================================\n+\n+The body of ``POST /contracts/search`` looks like so::\n+\n+  {\"%templates\": [...template IDs...],\n+   ...other query elements...}\n+\n+The elements of that query are defined here.\n+\n+Fallback rule\n+-------------\n+\n+Unless otherwise required by one of the other rules below or to follow,\n+values are interpreted according to the `LF values' JSON format\n+<../lf-value-json/specification.rst>`_, and compared for equality.\n+\n+Simple equality\n+---------------\n+\n+Match documents having at least all the (potentially nested) keys"
  }
]