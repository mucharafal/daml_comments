[
  {
    "id" : "92b65b08-7440-4550-8db0-b57b633480db",
    "prId" : 5879,
    "comments" : [
      {
        "id" : "2b364b9e-66db-45d9-851f-e7a6373d0462",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I considered whether `Free` was really appropriate here, and it ultimately came down to things like this. Interpreting these scripts must pause when reaching a `readOne` (`Listen` here). However, a naive interpretation will interpret a `flatMap`\r\n\r\n```scala\r\n  [e] (first: Consume[T, e], next: e => Consume[T, V]) => ...\r\n```\r\n\r\nby recursive descent into `first`. However, should it encounter `Listen` on this recursive descent, what then? Assuming it's the second listen encountered, it must immediately stop, returning it _and all the remaining actions_, including the ones unpacked as we recur.\r\n\r\nBy contrast, in this code, `f: T => Free[Consume[T, ?], V]`, where the function result represents the complete remainder of the sequence, _regardless of how arbitrarily nested within `first`s this `Listen` was_. That is the result of `resume`; in other words, the key feature we needed was turning every left-associated bind `(fx >>= k) >>= t` into a right-associated bind `fx >>= (\\x -> k x >>= t)`, exactly what `Free` and `resume` are designed for, thus permitting scripts to be factored in a natural way.",
        "createdAt" : "2020-05-13T12:05:20Z",
        "updatedAt" : "2020-05-13T17:47:31Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4e9a6d756e4e1c4e1ad2c49edf0b9b35b7203a4f",
    "line" : 66,
    "diffHunk" : "@@ -0,0 +1,119 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.http\n+\n+import akka.stream.scaladsl.Sink\n+import org.scalactic.source\n+import scalaz.{~>, Functor}\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+/** This example script reads two elements unconditionally, checking whether\n+  * the first element is \"good\" and that the second element has `true` as its\n+  * first member, then performs a future, then drains any remaining elements\n+  * from the stream, yielding a result that uses elements of all three reads.\n+  *\n+  * {{{\n+  *   val mySyntax = Consume.syntax[Foo] // Foo = stream element type\n+  *   import mySyntax._\n+  *\n+  *   val sink: Sink[Foo, Future[Bar]] = Consume.interpret(for {\n+  *     a <- readOne\n+  *     if aGoodFoo(a) // abort if false\n+  *\n+  *     Foo(true, b) <- readOne // abort if pattern doesn't match\n+  *     _ <- liftF(Future { q(a, b) /* complete this future before continuing */ })\n+  *\n+  *     rest <- drain // Seq[Foo] of remainder; use only if you expect more elements\n+  *   } yield Bar(a, b, rest)\n+  * }}}\n+  */\n+sealed abstract class Consume[-T, +V]\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+object Consume {\n+  import scalaz.Free\n+  import scalaz.std.scalaFuture._\n+\n+  type FCC[T, V] = Free[Consume[T, ?], V]\n+  type Description = source.Position\n+  final case class Listen[-T, +V](f: T => V, desc: Description) extends Consume[T, V]\n+  final case class Drain[S, -T, +V](init: S, next: (S, T) => S, out: S => V) extends Consume[T, V]\n+  final case class Emit[+V](run: Future[V]) extends Consume[Any, V]\n+\n+  /** Strictly speaking, this function really returns the following, these\n+    * are just passed to `Sink.foldAsync` for convenience:\n+    *\n+    * {{{\n+    *   {\n+    *     type O\n+    *     val init: O\n+    *     val step: (O, T) => Future[O]\n+    *     val out: O => Future[V]\n+    *   }\n+    * }}}\n+    */\n+  def interpret[T, V](steps: FCC[T, V])(implicit ec: ExecutionContext): Sink[T, Future[V]] =\n+    Sink\n+      .foldAsync(steps) { (steps, t: T) =>\n+        // step through steps until performing exactly one listen,\n+        // then step through any further steps until encountering\n+        // either the end or the next listen\n+        def go(steps: FCC[T, V], listened: Boolean): Future[FCC[T, V]] =\n+          steps.resume fold ({\n+            case listen @ Listen(f, _) =>\n+              if (listened) Future successful (Free roll listen) else go(f(t), true)"
  }
]