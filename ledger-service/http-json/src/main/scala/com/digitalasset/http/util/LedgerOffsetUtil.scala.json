[
  {
    "id" : "c90998fe-2642-4421-9dee-56637545b47d",
    "prId" : 4283,
    "comments" : [
      {
        "id" : "df3c6d0c-1297-4297-b901-18798fc212cf",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n  private def parseOffset(a: LedgerOffset.Value.Absolute): Long \\/ (Long, Long) = {\r\n```\r\n\r\nwith success in the `case Array(n) =>` case. Then you can do away with the `isCompositeOffsetFormat` and derive the order from the order of `Long \\/ (Long, Long)`.",
        "createdAt" : "2020-01-30T17:40:52Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "351fcf30-8a99-4277-889d-0f1478daa4ee",
        "parentId" : "df3c6d0c-1297-4297-b901-18798fc212cf",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "I don't like this... this assumes that we are comparing Numeric and Composite offsets, which should never happen, if happens this is an error! Which means that offsets are coming from two different ledgers.",
        "createdAt" : "2020-01-30T17:56:10Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cc620e00-43d1-42ea-9435-210ba5685d07",
        "parentId" : "df3c6d0c-1297-4297-b901-18798fc212cf",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Principle of explosion: if something happens that should never happen, then anything is fine, right? (In this case you'll just get either the error from the server about start > end, or empty stream.)",
        "createdAt" : "2020-01-30T18:02:31Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "50f5f7d3-8eab-4b53-8cfa-793aa9672609",
        "parentId" : "df3c6d0c-1297-4297-b901-18798fc212cf",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "To put it another way: when you compare two `Long`s that should never be negative, you tend not to assert there that they are `>= 0` at that location in the code, you just assume it (and there happens to be total behavior in the negative case anyway).",
        "createdAt" : "2020-01-30T19:02:16Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "138dcd50-1c8e-4000-aa9b-fa1a43d9ba69",
        "parentId" : "df3c6d0c-1297-4297-b901-18798fc212cf",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "To be honest, I should add that the main goal was to eliminate the blind boolean implied by pairing a boolean test with a function that presumes the boolean test succeeded; making the comparison total was just to simplify the code (and testing thereof) further.",
        "createdAt" : "2020-01-30T19:10:42Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b94141eec4dcfe9e2f4dbaf31b18c8e8c82e409b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,36 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http.util\n+\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset.Value\n+\n+object LedgerOffsetUtil {\n+  implicit val AbsoluteOffsetOrdering: Ordering[LedgerOffset.Value.Absolute] =\n+    new Ordering[LedgerOffset.Value.Absolute] {\n+      override def compare(x: Value.Absolute, y: Value.Absolute): Int =\n+        if (isCompositeOffsetFormat(x)) CompositeAbsoluteOffsetIntOrdering.compare(x, y)\n+        else IntAbsoluteOffsetOrdering.compare(x, y)\n+    }\n+\n+  private val IntAbsoluteOffsetOrdering: Ordering[LedgerOffset.Value.Absolute] =\n+    Ordering.by[LedgerOffset.Value.Absolute, Long](_.value.toLong)\n+\n+  private val CompositeAbsoluteOffsetIntOrdering: Ordering[LedgerOffset.Value.Absolute] =\n+    Ordering.by[LedgerOffset.Value.Absolute, (Long, Long)](parseCompositeOffset)\n+\n+  private def isCompositeOffsetFormat(a: LedgerOffset.Value.Absolute): Boolean =\n+    a.value.contains('-')\n+\n+  private def parseCompositeOffset(a: LedgerOffset.Value.Absolute): (Long, Long) = {"
  },
  {
    "id" : "f6d2ec96-d902-4112-826f-53cd7e7a691e",
    "prId" : 4283,
    "comments" : [
      {
        "id" : "f5d12b95-5e39-48d5-aed6-2672b5a4b6f0",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "scalaz's Order will give properly disjoint results here:\r\n\r\n```suggestion\r\n    import scalaz.std.anyVal._\r\n    Order[Long \\/ (Long, Long)].toScalaOrdering\r\n```",
        "createdAt" : "2020-01-30T19:08:33Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b94141eec4dcfe9e2f4dbaf31b18c8e8c82e409b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,34 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http.util\n+\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import scalaz.{-\\/, \\/, \\/-}\n+\n+object LedgerOffsetUtil {\n+\n+  private val LongEitherLongLongOrdering: Ordering[Long \\/ (Long, Long)] =\n+    Ordering.by[Long \\/ (Long, Long), (Long, Long)] {"
  },
  {
    "id" : "01320b0f-f996-4372-b226-c6e680812e80",
    "prId" : 4283,
    "comments" : [
      {
        "id" : "76ba562a-e385-4e0f-a8d4-d4907a63e819",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    val O = scalaz.Order[Long \\/ (Long, Long)]\r\n```\r\n\r\nExplicit implicit resolutions of scalaz typeclasses should always use the apply method, avoiding `implicitly`.",
        "createdAt" : "2020-01-30T20:01:01Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a2ed5d8a-f145-42d0-8b1a-8d1e99ae8246",
        "parentId" : "76ba562a-e385-4e0f-a8d4-d4907a63e819",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "it compiles... don't really care any more.",
        "createdAt" : "2020-01-30T20:02:39Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e1a2809a-7385-4b68-8854-c86ee1025a0c",
        "parentId" : "76ba562a-e385-4e0f-a8d4-d4907a63e819",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "but yeah the change makes sense... did not know that there is a `scalaz.Order` object available, was implicitly resolving the trait :), but it happened that could actually get the instance directly",
        "createdAt" : "2020-01-30T20:07:55Z",
        "updatedAt" : "2020-01-30T20:09:04Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b94141eec4dcfe9e2f4dbaf31b18c8e8c82e409b",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,35 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http.util\n+\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import scalaz.{-\\/, \\/, \\/-}\n+\n+object LedgerOffsetUtil {\n+\n+  private val LongEitherLongLongOrdering: Ordering[Long \\/ (Long, Long)] = {\n+    import scalaz.std.tuple._\n+    import scalaz.std.anyVal._\n+    val O = implicitly[scalaz.Order[Long \\/ (Long, Long)]]"
  }
]