[
  {
    "id" : "7355f377-fa16-47d0-9e71-5ba1fe66001e",
    "prId" : 5027,
    "comments" : [
      {
        "id" : "d4086377-bf19-4db3-b7ef-33ca69767ede",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Why not just `requested.toSet`? Seems to be available as part of the `OneAnd.oneAndTraverse` implicit.",
        "createdAt" : "2020-03-16T15:57:10Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2c787f80-7b4f-4f3e-b88a-ef7c066cb3bf",
        "parentId" : "d4086377-bf19-4db3-b7ef-33ca69767ede",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@SamirTalwar I actually tried it:\r\n```\r\n    import OneAnd._\r\n    val requestedIds: Set[domain.Party] = requested.toSet\r\n```\r\ngot:\r\n```\r\nledger-service/http-json/src/main/scala/com/digitalasset/http/PartiesService.scala:80: error: value toSet is not a member of scalaz.OneAnd[Set,com.digitalasset.http.domain.Party]\r\n    val requestedIds: Set[domain.Party] = requested.toSet\r\n```\r\nI think it is because there is no `Traversable` type class instance for `Set`. So `Traversable` can't be derived for `OneAnd[Set, X]`.",
        "createdAt" : "2020-03-16T16:06:55Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e1ce8259-4ff5-43d2-9476-e9ea23de22c8",
        "parentId" : "d4086377-bf19-4db3-b7ef-33ca69767ede",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "`Traverse` can't be derived, but `Foldable` can, which is the true source of `toSet`. You can get `Set`'s `Foldable` from `scalaz.std.iterable`, which should only be locally imported, never globally, due to its...counterintuitive behavior for some cases. Anyway, that would enable the inductive `Foldable` for `OneAnd`.\r\n\r\nHowever, I think there's little harm in the `tail + head` here, especially as `toSet` seems to suggest that more is going on than really is.",
        "createdAt" : "2020-03-16T16:58:25Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a37898d131259eede23b4eb7294eb643e0806282",
    "line" : null,
    "diffHunk" : "@@ -74,18 +74,27 @@ class PartiesService(\n \n   private def findUnknownParties(\n       found: Set[domain.PartyDetails],\n-      requested: Set[domain.Party]\n-  ): Set[domain.Party] =\n-    if (found.size == requested.size) Set.empty[domain.Party]\n-    else requested -- found.map(_.identifier)\n+      requested: OneAnd[Set, domain.Party]\n+  ): Set[domain.Party] = {\n+    val requestedIds: Set[domain.Party] = requested.tail + requested.head"
  },
  {
    "id" : "33a43481-1852-4ad1-a6bb-159b9383b432",
    "prId" : 5027,
    "comments" : [
      {
        "id" : "ea1e3f79-e7a5-448e-b156-f84d33e60df9",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@S11001001 Is there a better way to traverse `OneAnd[Set, X]`???",
        "createdAt" : "2020-03-16T15:57:33Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e94f7d9e-6ff6-47d9-83ac-086bc4fe4d63",
        "parentId" : "ea1e3f79-e7a5-448e-b156-f84d33e60df9",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Suggestion in another comment; you can choose any functor you want, vector, immarray, whatever, but you have the essence of the mechanics right, you have to choose something other than Set.",
        "createdAt" : "2020-03-16T17:06:37Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a37898d131259eede23b4eb7294eb643e0806282",
    "line" : null,
    "diffHunk" : "@@ -74,18 +74,27 @@ class PartiesService(\n \n   private def findUnknownParties(\n       found: Set[domain.PartyDetails],\n-      requested: Set[domain.Party]\n-  ): Set[domain.Party] =\n-    if (found.size == requested.size) Set.empty[domain.Party]\n-    else requested -- found.map(_.identifier)\n+      requested: OneAnd[Set, domain.Party]\n+  ): Set[domain.Party] = {\n+    val requestedIds: Set[domain.Party] = requested.tail + requested.head\n \n+    if (found.size == requestedIds.size) Set.empty\n+    else requestedIds -- found.map(_.identifier)\n+  }\n }\n \n object PartiesService {\n   import com.digitalasset.http.util.ErrorOps._\n \n   private type ET[A] = EitherT[Future, Error, A]\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  def toLedgerApi(ps: OneAnd[Set, domain.Party]): InvalidUserInput \\/ OneAnd[Set, Ref.Party] = {"
  },
  {
    "id" : "e2c41031-21e7-4107-a414-7466ad01aace",
    "prId" : 5027,
    "comments" : [
      {
        "id" : "79086528-760f-4802-b750-42f0440164fe",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "The conversion to `List[Party]` and then back to `OneAnd[Set[Party]]` seems unnecessary. Perhaps just make another function, `toLedgerApi(ps: Set[domain.Party])`, and delegate to that one?",
        "createdAt" : "2020-03-16T15:59:26Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1de182fc-6cc5-4098-90b6-972a88d003d4",
        "parentId" : "79086528-760f-4802-b750-42f0440164fe",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "`Set` is not traversable, so I need to convert it to a List or a Vector, traverse and convert back to a Set.",
        "createdAt" : "2020-03-16T16:10:40Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "773a71da-7a29-40ee-9769-106ff3afaea0",
        "parentId" : "79086528-760f-4802-b750-42f0440164fe",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Set does not guarantee an order, and this is required by Traversable laws. That is why there is no Traversable type class instance for Set in scalaz. In our case we don't really care about the order.",
        "createdAt" : "2020-03-16T16:11:58Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7c615535-288b-4e02-8d63-51dde6f81118",
        "parentId" : "79086528-760f-4802-b750-42f0440164fe",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Then convert to a list and traverse that? 🙂 ",
        "createdAt" : "2020-03-16T16:44:24Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0da82e34-fd1c-4715-91ea-b8a98f7ee475",
        "parentId" : "79086528-760f-4802-b750-42f0440164fe",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    val psl = ps copy (tail = ps.tail.toList) traverse toLedgerApi\r\n    psl copy (tail = psl.tail.toSet)\r\n```\r\n\r\nI can't believe I'm the one suggesting you add a variable where you don't have one 😆 feel free to add `mapTail` syntax if you want.",
        "createdAt" : "2020-03-16T17:05:50Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2cfc9d93-5311-455e-babc-340d9db9a5a1",
        "parentId" : "79086528-760f-4802-b750-42f0440164fe",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Nice spot on the `map`, I forgot about that, you could get rid of all the variables that way. Or, you know, not, you do you.",
        "createdAt" : "2020-03-16T19:14:33Z",
        "updatedAt" : "2020-03-16T19:32:04Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a37898d131259eede23b4eb7294eb643e0806282",
    "line" : null,
    "diffHunk" : "@@ -74,18 +74,27 @@ class PartiesService(\n \n   private def findUnknownParties(\n       found: Set[domain.PartyDetails],\n-      requested: Set[domain.Party]\n-  ): Set[domain.Party] =\n-    if (found.size == requested.size) Set.empty[domain.Party]\n-    else requested -- found.map(_.identifier)\n+      requested: OneAnd[Set, domain.Party]\n+  ): Set[domain.Party] = {\n+    val requestedIds: Set[domain.Party] = requested.tail + requested.head\n \n+    if (found.size == requestedIds.size) Set.empty\n+    else requestedIds -- found.map(_.identifier)\n+  }\n }\n \n object PartiesService {\n   import com.digitalasset.http.util.ErrorOps._\n \n   private type ET[A] = EitherT[Future, Error, A]\n \n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  def toLedgerApi(ps: OneAnd[Set, domain.Party]): InvalidUserInput \\/ OneAnd[Set, Ref.Party] = {\n+    import scalaz.std.list._\n+    import scalaz.syntax.apply._\n+    ^(toLedgerApi(ps.head), ps.tail.toList.traverse(toLedgerApi))((h, t) => OneAnd(h, t.toSet))"
  }
]