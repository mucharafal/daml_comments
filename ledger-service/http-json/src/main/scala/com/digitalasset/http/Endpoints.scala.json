[
  {
    "id" : "dd0679d2-597c-4e58-ac78-37157847551d",
    "prId" : 5660,
    "comments" : [
      {
        "id" : "444ed819-1e4d-4e9c-8184-1b261efffe68",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "This is pretty quick and dirty \"parsing\"; should we parse [rfc 7239 forwarded-elements](https://tools.ietf.org/html/rfc7239#section-4) instead? @leo-da ",
        "createdAt" : "2020-04-21T22:38:01Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "12c23fde-0599-48a8-b1ba-63bb1700885e",
        "parentId" : "444ed819-1e4d-4e9c-8184-1b261efffe68",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "I need to read on this first... but I expect Akka HTTP provides some utilities for this.",
        "createdAt" : "2020-04-21T23:20:12Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0659b8a3-098d-401a-9ecb-3c28ebf84103",
        "parentId" : "444ed819-1e4d-4e9c-8184-1b261efffe68",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "> but I expect Akka HTTP provides some utilities for this\r\n\r\nNot really. The closest they come is [`Connection`'s parser](https://github.com/akka/akka-http/blob/v10.1.11/akka-http-core/src/main/scala/akka/http/impl/model/parser/SimpleHeaders.scala#L77-L80), but that syntax is sufficiently incompatible to just crash on a Forwarded header. We can reuse [some of the parser components](https://github.com/akka/akka-http/blob/v10.1.11/akka-http-core/src/main/scala/akka/http/impl/model/parser/CommonRules.scala#L18-L63), though they are package-private and thus [not part of the stable API](https://doc.akka.io/docs/akka-http/10.1.11/common/http-model.html#parsing-rendering)\r\n\r\n> Parsing and rendering of HTTP data structures is heavily optimized and for most types thereâ€™s currently no public API provided to parse (or render to) Strings or byte arrays.\r\n\r\nBut that _still_ does not include a forwarded-element parser anyway, so even odds we might as well define a new parser.\r\n\r\nIf what we want is a parser. That question thus reduces to whether avoiding the obvious edge cases in the quick and dirty approach is worth dealing with the above.",
        "createdAt" : "2020-04-21T23:30:14Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a24c0bb3-fbc4-4649-b4f4-a6e481633665",
        "parentId" : "444ed819-1e4d-4e9c-8184-1b261efffe68",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "I think this is fine. It's clearly possible to craft a Forwarded value that thwarts it, but if you're at the point of crafting the header you can already set it to whatever you want anyway.\r\n\r\nThe goal of this filter is not to be absolutely unbreakable, but to avoid accidental security holes.",
        "createdAt" : "2020-04-22T10:22:01Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "359263e1-4439-46b2-b82b-6fcb59099d96",
        "parentId" : "444ed819-1e4d-4e9c-8184-1b261efffe68",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "@garyverhaegen-da Makes sense to me, thanks.",
        "createdAt" : "2020-04-22T14:57:25Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6ab4717c-ec00-4d62-9d12-00b82a880b0e",
        "parentId" : "444ed819-1e4d-4e9c-8184-1b261efffe68",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "> We can reuse some of the parser components, though they are package-private and thus not part of the stable API\r\n\r\nNah... I thought it would be available. In any case I agree with @garyverhaegen-da it does not have to be bulletproof, it is just a fat finger check, a security advise to developers/operations to run JSON API behind a reverse proxy with HTTPs. If developer is crafting the header they supposed to understand the implications.",
        "createdAt" : "2020-04-22T16:56:45Z",
        "updatedAt" : "2020-04-27T20:37:42Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "185ea518a2b61c43eb373b611650bcf599b2e5ee",
    "line" : 94,
    "diffHunk" : "@@ -397,4 +411,18 @@ object Endpoints {\n   private def toJsValue[A: JsonWriter](a: A): Error \\/ JsValue = {\n     SprayJson.encode(a).liftErr(ServerError)\n   }\n+\n+  private[http] final case class Forwarded(value: String) extends ModeledCustomHeader[Forwarded] {\n+    override def companion = Forwarded\n+    override def renderInRequests = true\n+    override def renderInResponses = false\n+    def proto: Option[String] =\n+      Forwarded.re findFirstMatchIn value map (_.group(1).toLowerCase)\n+  }\n+\n+  private[http] object Forwarded extends ModeledCustomHeaderCompanion[Forwarded] {\n+    override val name = \"Forwarded\"\n+    override def parse(value: String) = Try(new Forwarded(value))\n+    private val re = raw\"\"\"(?i)proto\\s*=\\s*\"?(https?)\"\"\".r"
  },
  {
    "id" : "c44884ef-c5b1-4325-b205-6614dae2a368",
    "prId" : 3625,
    "comments" : [
      {
        "id" : "c987ad8c-b39b-4ed2-a369-30784e763353",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n  private def handleSourceFailure[A]: Flow[A, ServerError \\/ A, NotUsed] =\r\n```\r\n\r\nOne benefit is that you can delegate worrying about the materialization to the caller, where it belongs.",
        "createdAt" : "2019-11-25T22:33:40Z",
        "updatedAt" : "2019-11-27T21:08:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72c61b6ab18acd715e0035a6e7fa5ec50a7dd08b",
    "line" : null,
    "diffHunk" : "@@ -114,6 +118,13 @@ class Endpoints(\n         -\\/(ServerError(e.getMessage))\n     }\n \n+  private def handleSourceFailure[A, M](soure: Source[A, M]): Source[ServerError \\/ A, M] ="
  },
  {
    "id" : "9ef56598-29ff-4ec6-a94f-0e06778aac66",
    "prId" : 3625,
    "comments" : [
      {
        "id" : "d4e4fcb7-7cd0-4902-8860-47c6906674de",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n          jsValueSource = acsSource.via(handleSourceFailure)\r\n```",
        "createdAt" : "2019-11-25T22:34:53Z",
        "updatedAt" : "2019-11-27T21:08:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72c61b6ab18acd715e0035a6e7fa5ec50a7dd08b",
    "line" : null,
    "diffHunk" : "@@ -149,58 +160,57 @@ class Endpoints(\n       httpResponse(et)\n \n     case req @ HttpRequest(GET, Uri.Path(\"/contracts/search\"), _, _, _) =>\n-      val et: ET[JsValue] = for {\n-        input <- FutureUtil.eitherT(input(req)): ET[(Jwt, JwtPayload, String)]\n-\n-        (jwt, jwtPayload, _) = input\n+      val sourceF: Future[Error \\/ Source[JsValue, NotUsed]] = input(req).map { inputOrError =>\n+        for {\n+          x <- inputOrError: Unauthorized \\/ (Jwt, JwtPayload, String)\n+          (jwt, jwtPayload, _) = x\n \n-        as <- eitherT(\n-          handleFutureFailure(contractsService\n-            .search(jwt, jwtPayload, emptyGetActiveContractsRequest))): ET[contractsService.Result]\n-\n-        jsVal <- either(\n-          as._1.toList\n-            .traverse(a => encoder.encodeV(a))\n+          x <- contractsService\n+            .search(jwt, jwtPayload, emptyGetActiveContractsRequest)\n             .leftMap(e => ServerError(e.shows))\n-            .flatMap(js => encodeList(js))\n-        ): ET[JsValue]\n-\n-      } yield jsVal\n+          (acsSource, _) = x\n+\n+          jsValueSource = handleSourceFailure(acsSource)"
  },
  {
    "id" : "56b100ee-74da-4be5-b70c-163a93b82145",
    "prId" : 3625,
    "comments" : [
      {
        "id" : "6bdaade5-b507-42f9-b5e0-a257f638c8e5",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Likewise.",
        "createdAt" : "2019-11-25T23:18:32Z",
        "updatedAt" : "2019-11-27T21:08:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72c61b6ab18acd715e0035a6e7fa5ec50a7dd08b",
    "line" : null,
    "diffHunk" : "@@ -149,58 +160,57 @@ class Endpoints(\n       httpResponse(et)\n \n     case req @ HttpRequest(GET, Uri.Path(\"/contracts/search\"), _, _, _) =>\n-      val et: ET[JsValue] = for {\n-        input <- FutureUtil.eitherT(input(req)): ET[(Jwt, JwtPayload, String)]\n-\n-        (jwt, jwtPayload, _) = input\n+      val sourceF: Future[Error \\/ Source[JsValue, NotUsed]] = input(req).map { inputOrError =>\n+        for {\n+          x <- inputOrError: Unauthorized \\/ (Jwt, JwtPayload, String)\n+          (jwt, jwtPayload, _) = x\n \n-        as <- eitherT(\n-          handleFutureFailure(contractsService\n-            .search(jwt, jwtPayload, emptyGetActiveContractsRequest))): ET[contractsService.Result]\n-\n-        jsVal <- either(\n-          as._1.toList\n-            .traverse(a => encoder.encodeV(a))\n+          x <- contractsService\n+            .search(jwt, jwtPayload, emptyGetActiveContractsRequest)\n             .leftMap(e => ServerError(e.shows))\n-            .flatMap(js => encodeList(js))\n-        ): ET[JsValue]\n-\n-      } yield jsVal\n+          (acsSource, _) = x\n+\n+          jsValueSource = handleSourceFailure(acsSource)\n+            .map {\n+              _.flatMap { a =>\n+                encoder\n+                  .encodeV[domain.ActiveContract](a)\n+                  .leftMap(e => ServerError(e.shows)): Error \\/ JsValue\n+              }.fold(errorToJsValue, identity): JsValue\n+            }\n+        } yield jsValueSource\n+      }\n \n-      httpResponse(et)\n+      httpResponse(sourceF)\n \n     case req @ HttpRequest(POST, Uri.Path(\"/contracts/search\"), _, _, _) =>\n-      val et: ET[JsValue] = for {\n-        input <- FutureUtil.eitherT(input(req)): ET[(Jwt, JwtPayload, String)]\n-\n-        (jwt, jwtPayload, reqBody) = input\n+      val sourceF: Future[Error \\/ Source[JsValue, NotUsed]] = input(req).map { inputOrError =>\n+        for {\n+          x <- inputOrError: Unauthorized \\/ (Jwt, JwtPayload, String)\n+          (jwt, jwtPayload, reqBody) = x\n \n-        cmd <- either(\n-          SprayJson\n+          cmd <- SprayJson\n             .decode[domain.GetActiveContractsRequest](reqBody)\n             .leftMap(e => InvalidUserInput(e.shows))\n-        ): ET[domain.GetActiveContractsRequest]\n-\n-        as <- eitherT(\n-          handleFutureFailure(contractsService.search(jwt, jwtPayload, cmd))\n-        ): ET[contractsService.Result]\n \n-        xs <- either(\n-          as._1.toList.traverse(_.traverse(v => apValueToLfValue(v)))\n-        ): ET[List[domain.ActiveContract[LfValue]]]\n+          x <- contractsService\n+            .search(jwt, jwtPayload, cmd)\n+            .leftMap(e => ServerError(e.shows)): ServerError \\/ (\n+              Source[domain.ActiveContract[ApiValue], NotUsed],\n+              contractsService.CompiledPredicates)\n+          (acsSource, predicate) = x\n \n-        ys = contractsService\n-          .filterSearch(as._2, xs): Seq[domain.ActiveContract[LfValue]]\n+          funPredicates = predicate transform ((_, vp) => vp.toFunPredicate)\n \n-        js <- either(\n-          ys.toList.traverse(_.traverse(v => lfValueToJsValue(v)))\n-        ): ET[Seq[domain.ActiveContract[JsValue]]]\n+          jsValueSource = handleSourceFailure(acsSource)"
  },
  {
    "id" : "3fcd7359-16d9-4c50-bb4f-bcdd54b12e1f",
    "prId" : 3625,
    "comments" : [
      {
        "id" : "879c1317-7ed9-4d84-a570-f6b4f2a50357",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      .fromFunction((_: E \\/ A).leftMap(e => ServerError(e.shows)))\r\n```",
        "createdAt" : "2019-11-27T20:16:11Z",
        "updatedAt" : "2019-11-27T21:08:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72c61b6ab18acd715e0035a6e7fa5ec50a7dd08b",
    "line" : null,
    "diffHunk" : "@@ -114,6 +118,15 @@ class Endpoints(\n         -\\/(ServerError(e.getMessage))\n     }\n \n+  private def handleSourceFailure[E: Show, A]: Flow[E \\/ A, ServerError \\/ A, NotUsed] =\n+    Flow\n+      .fromFunction[E \\/ A, ServerError \\/ A](x => x.leftMap(e => ServerError(e.shows)))"
  }
]