[
  {
    "id" : "aa7b00aa-fd49-4faf-8642-c547065c89e9",
    "prId" : 6569,
    "comments" : [
      {
        "id" : "104f7304-b8fa-4ca8-99e3-55870f41c95d",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Why not `case tc @ iface.TypeCon(iface.TypeConName(id), _)`?",
        "createdAt" : "2020-07-02T13:51:03Z",
        "updatedAt" : "2020-07-02T13:51:03Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "04a7c57999f34bb73958b71a0030ed1b70eddf7b",
    "line" : 5,
    "diffHunk" : "@@ -321,7 +321,7 @@ object ValuePredicate {\n     }\n \n     (typ match {\n-      case tc @ iface.TypeCon(iface.TypeConName(id), typArgs) =>\n+      case tc @ iface.TypeCon(iface.TypeConName(id), typArgs @ _) =>"
  },
  {
    "id" : "54f0067a-e475-4903-9a78-1f64e30537c0",
    "prId" : 5099,
    "comments" : [
      {
        "id" : "be4b684c-218a-4325-a93e-ae5ebd82065b",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "the `FIXME` is not valid anymore. Does not make much sense to support `GenMap` queries when we are dropping `TextMap` query support.",
        "createdAt" : "2020-03-20T15:52:46Z",
        "updatedAt" : "2020-03-20T16:50:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "82350d7a-20e0-46ec-b6b6-77b32bbb75cb",
        "parentId" : "be4b684c-218a-4325-a93e-ae5ebd82065b",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Combined in 4061ffc",
        "createdAt" : "2020-03-20T16:51:23Z",
        "updatedAt" : "2020-03-20T16:51:24Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e7434d7afd90f5b354a3f83c635e3d6a268d0272",
    "line" : null,
    "diffHunk" : "@@ -369,11 +316,8 @@ object ValuePredicate {\n             val elemTy = soleTypeArg(\"Optional\")\n             fromOptional(q, elemTy)\n         }\n-        case TextMap => {\n-          case JsObject(q) =>\n-            val elemTy = soleTypeArg(\"Map\")\n-            MapMatch(SortedLookupList(q) mapValue (fromValue(_, elemTy)))\n-        }\n+        case List | TextMap =>\n+          predicateParseError(s\"${typ.typ} not supported\")\n         case GenMap =>\n           // FIXME https://github.com/digital-asset/daml/issues/2256"
  },
  {
    "id" : "e2b4e3ce-379e-4a69-ac5e-74f47409d8c0",
    "prId" : 3882,
    "comments" : [
      {
        "id" : "c70f6e30-9055-4a5f-9230-b674a2b622ad",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Do not include any error handling here; this partial function should only match the successful case, `JsonVariant`.",
        "createdAt" : "2019-12-24T17:27:41Z",
        "updatedAt" : "2019-12-24T20:19:28Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "41030735c34f5ee15171e782aa55742d40e5f99b",
    "line" : null,
    "diffHunk" : "@@ -273,8 +276,11 @@ object ValuePredicate {\n             fromRecord(fields, id, rec)\n         }\n         case iface.Variant(fieldTyps) => {\n-          case JsObject(fields) =>\n-            fromVariant(fields, id, fieldTyps)\n+          case JsonVariant(tag, nestedValue) =>\n+            fromVariant(tag, nestedValue, id, fieldTyps)\n+          case invalidJsVal @ _ =>\n+            predicateParseError(\n+              s\"Variant must be encoded as JsObject with 'tag' and 'value' fields, got: $invalidJsVal, id: $id\")"
  },
  {
    "id" : "ec33452b-26df-4081-bd93-d51dc79e833d",
    "prId" : 3882,
    "comments" : [
      {
        "id" : "45f7f4c3-a8e7-4d27-b294-fdcc7010222a",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n           // have exactly two keys\r\n```",
        "createdAt" : "2019-12-24T18:23:12Z",
        "updatedAt" : "2019-12-24T20:19:28Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "41030735c34f5ee15171e782aa55742d40e5f99b",
    "line" : null,
    "diffHunk" : "@@ -143,7 +142,11 @@ sealed abstract class ValuePredicate extends Product with Serializable {\n           val Rec(vraw, v_==, v_@>) = go(path ++ sql\"->${dc: String}\", q)\n           // @> is safe because in a variant-typed context, all JsObjects\n           // have exactly one key"
  },
  {
    "id" : "82087d8a-9703-4ec2-aacf-73d615459309",
    "prId" : 3882,
    "comments" : [
      {
        "id" : "ebd916d8-f574-429d-b89e-0e48769e8135",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      val field: Option[(Ref.Name, Ty)] = fieldTyps.find { case (name, _) => tag == (name: String) }\r\n```\r\n\r\nand delete `val name`.",
        "createdAt" : "2019-12-24T18:27:35Z",
        "updatedAt" : "2019-12-24T20:19:28Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ba16553d-3d09-43c2-909c-11ddb9231d92",
        "parentId" : "ebd916d8-f574-429d-b89e-0e48769e8135",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "The following `map` also fuses with that `collect`, so `val field` should also be deleted.",
        "createdAt" : "2019-12-24T19:49:46Z",
        "updatedAt" : "2019-12-24T20:19:28Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "41030735c34f5ee15171e782aa55742d40e5f99b",
    "line" : null,
    "diffHunk" : "@@ -296,21 +302,19 @@ object ValuePredicate {\n     }\n \n     def fromVariant(\n-        fields: Map[String, JsValue],\n+        tag: String,\n+        nestedValue: JsValue,\n         id: Ref.Identifier,\n-        fieldTyps: ImmArraySeq[(Ref.Name, Ty)]): Result = fields.toSeq match {\n-      case Seq((k, v)) =>\n-        val name = Ref.Name.assertFromString(k)\n-        val field: Option[(Ref.Name, Ty)] = fieldTyps.find(_._1 == name)\n-        val fieldP: Option[(Ref.Name, ValuePredicate)] = field.map {\n-          case (n, t) => (n, fromValue(v, t))\n-        }\n-        fieldP.fold(\n-          predicateParseError(\n-            s\"Cannot locate Variant's (datacon, type) field, id: $id, name: $name\")\n-        )(VariantMatch)\n+        fieldTyps: ImmArraySeq[(Ref.Name, Ty)]): Result = {\n \n-      case _ => predicateParseError(s\"Variant must have exactly 1 field, got: $fields, id: $id\")\n+      val name = Ref.Name.assertFromString(tag)\n+      val field: Option[(Ref.Name, Ty)] = fieldTyps.find(_._1 == name)"
  },
  {
    "id" : "96c48668-131b-4722-973a-c8bc702daa75",
    "prId" : 3882,
    "comments" : [
      {
        "id" : "81764f0b-8350-4c3b-afbe-b49930353a50",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n            v_@> map (JsonVariant(dc, _))\r\n```\r\n\r\nand likewise on `v_==`.",
        "createdAt" : "2019-12-24T18:30:56Z",
        "updatedAt" : "2019-12-24T20:19:28Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "41030735c34f5ee15171e782aa55742d40e5f99b",
    "line" : null,
    "diffHunk" : "@@ -143,7 +142,11 @@ sealed abstract class ValuePredicate extends Product with Serializable {\n           val Rec(vraw, v_==, v_@>) = go(path ++ sql\"->${dc: String}\", q)\n           // @> is safe because in a variant-typed context, all JsObjects\n           // have exactly one key\n-          Rec(vraw, v_== map (jv => JsObject((dc, jv))), v_@> map (jv => JsObject((dc, jv))))\n+          Rec(\n+            vraw,\n+            v_== map (jv => JsObject(\"tag\" -> JsString(dc), \"value\" -> jv)),\n+            v_@> map (jv => JsObject(\"tag\" -> JsString(dc), \"value\" -> jv))"
  },
  {
    "id" : "092dba39-b1bf-4eda-a5e3-739c12b308d8",
    "prId" : 3599,
    "comments" : [
      {
        "id" : "145905b6-e7de-49f7-b8c4-7bc784a4726a",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "why `Path` for argument, but `Fragment` for return value? For self-documenting purposes? `Path` means something like  `person.name`?",
        "createdAt" : "2019-12-03T18:20:38Z",
        "updatedAt" : "2019-12-04T20:59:12Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "86ca7561-e5ae-4a50-a4f3-dbade0972015",
        "parentId" : "145905b6-e7de-49f7-b8c4-7bc784a4726a",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Yes, only for self-documenting purposes. Yes.",
        "createdAt" : "2019-12-04T18:02:31Z",
        "updatedAt" : "2019-12-04T20:59:12Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1e431d26e5ede26373af748ecaaa57c13a41b1d3",
    "line" : 48,
    "diffHunk" : "@@ -83,20 +92,156 @@ sealed abstract class ValuePredicate extends Product with Serializable {\n     }\n     go(this)\n   }\n+\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  def toSqlWhereClause: Fragment = {\n+    import dbbackend.Queries.Implicits._ // JsValue support\n+    type Path = Fragment\n+\n+    final case class Rec(\n+        raw: SqlWhereClause,\n+        safe_== : Option[JsValue],\n+        safe_@> : Option[JsValue]) {\n+      def flush_@>(path: Path): Option[Fragment] ="
  },
  {
    "id" : "0185b245-0a81-46b7-8367-5619eb5f7f6b",
    "prId" : 2826,
    "comments" : [
      {
        "id" : "d4d9dbdb-4ca0-4782-ade4-d16d8feecbe7",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Variants can only have a single direct field, which in turn can be of a record type with many fields. What do you think about \"inline\" the fields of the child record as a shortcut? Especially considering that the name of the variant field is not directly \"visible\" in the DAML code. What field name should users use?",
        "createdAt" : "2019-09-23T15:33:10Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ce196b4d-b1e8-4459-b32a-a0e003d31028",
        "parentId" : "d4d9dbdb-4ca0-4782-ade4-d16d8feecbe7",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "You cannot really inline the record, you need the parent field, which is a (`DataCon`, `Record`) pair.\r\nwhere `DataCon` is data constructor, the name of the variant and `Record` is a nested record. If you inline the record, where are you going to put the data constructor string? And we need it for serialization/deserialization. We can change the ADT but this will break backward-compatibility (many modules will be affected).",
        "createdAt" : "2019-09-23T18:24:23Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "eb6a5350-fc2e-4ab9-a51a-0e972977d653",
        "parentId" : "d4d9dbdb-4ca0-4782-ade4-d16d8feecbe7",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "> What do you think about \"inline\" the fields of the child record as a shortcut?\r\n\r\nWith the caveat that users would have to be aware of exceptions, exceptions to those exceptions, and exceptions to those exceptions to those exceptions (I stopped thinking of examples at that point).\r\n\r\n> Especially considering that the name of the variant field is not directly \"visible\" in the DAML code. What field name should users use?\r\n\r\nThe name is visible in DAML code; it's the data constructor.",
        "createdAt" : "2019-09-23T18:58:24Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8b9a4799-36c7-43b6-a239-1ab862efdbe4",
        "parentId" : "d4d9dbdb-4ca0-4782-ade4-d16d8feecbe7",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Okay, thanks.",
        "createdAt" : "2019-09-24T07:13:56Z",
        "updatedAt" : "2019-09-24T07:13:56Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "078ec69a5240afdc0f2e7a5ee0646566cc902378",
    "line" : 162,
    "diffHunk" : "@@ -0,0 +1,250 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http\n+package query\n+\n+import util.IdentifierConverters.lfIdentifier\n+\n+import com.digitalasset.daml.lf.data.{ImmArray, Numeric, Ref, SortedLookupList, Time}\n+import ImmArray.ImmArraySeq\n+import com.digitalasset.daml.lf.data.ScalazEqual._\n+import com.digitalasset.daml.lf.iface\n+import com.digitalasset.daml.lf.value.{Value => V}\n+import iface.{Type => Ty}\n+import scalaz.\\&/\n+import scalaz.syntax.std.option._\n+import scalaz.syntax.std.string._\n+import spray.json._\n+\n+sealed abstract class ValuePredicate extends Product with Serializable {\n+  import ValuePredicate._\n+  def toFunPredicate: LfV => Boolean = {\n+    def go(self: ValuePredicate): LfV => Boolean = self match {\n+      case Literal(p) => p.isDefinedAt\n+\n+      case RecordSubset(q) =>\n+        val cq = q map (_ map { case (_, vp) => go(vp) });\n+        {\n+          case V.ValueRecord(_, fields) =>\n+            cq zip fields.toSeq forall {\n+              case (None, _) => true\n+              case (Some(fp), (_, lfv)) => fp(lfv)\n+            }\n+          case _ => false\n+        }\n+\n+      case MapMatch(q) =>\n+        val cq = (q mapValue go).toImmArray;\n+        {\n+          case V.ValueMap(v) if cq.length == v.toImmArray.length =>\n+            // the sort-by-key is the same for cq and v, so if equal, the keys\n+            // are at equal indices\n+            cq.iterator zip v.toImmArray.iterator forall {\n+              case ((qk, qp), (vk, vv)) => qk == vk && qp(vv)\n+            }\n+          case _ => false\n+        }\n+\n+      case ListMatch(qs) =>\n+        val cqs = qs map go;\n+        {\n+          case V.ValueList(vs) if cqs.length == vs.length =>\n+            cqs.iterator zip vs.iterator forall {\n+              case (q, v) => q(v)\n+            }\n+          case _ => false\n+        }\n+\n+      case VariantMatch((n1, p)) =>\n+        val cp = go(p);\n+        {\n+          case V.ValueVariant(_, n2, v) if n1 == n2 => cp(v)\n+          case _ => false\n+        }\n+\n+      case OptionalMatch(oq) =>\n+        oq map go cata (csq => { case V.ValueOptional(Some(v)) => csq(v); case _ => false },\n+        { case V.ValueOptional(None) => true; case _ => false })\n+\n+      case Range(_, _) => predicateParseError(\"range not supported yet\")\n+    }\n+    go(this)\n+  }\n+}\n+\n+object ValuePredicate {\n+  type TypeLookup = Ref.Identifier => Option[iface.DefDataType.FWT]\n+  type LfV = V[V.AbsoluteContractId]\n+\n+  final case class Literal(p: LfV PartialFunction Unit) extends ValuePredicate\n+  final case class RecordSubset(fields: ImmArraySeq[Option[(Ref.Name, ValuePredicate)]])\n+      extends ValuePredicate\n+  final case class MapMatch(elems: SortedLookupList[ValuePredicate]) extends ValuePredicate\n+  final case class ListMatch(elems: Vector[ValuePredicate]) extends ValuePredicate\n+  final case class VariantMatch(elem: (Ref.Name, ValuePredicate)) extends ValuePredicate\n+  final case class OptionalMatch(elem: Option[ValuePredicate]) extends ValuePredicate\n+  // boolean is whether inclusive (lte vs lt)\n+  final case class Range(ltgt: (Boolean, LfV) \\&/ (Boolean, LfV), typ: Ty) extends ValuePredicate\n+\n+  private[http] def fromTemplateJsObject(\n+      it: Map[String, JsValue],\n+      typ: domain.TemplateId.RequiredPkg,\n+      defs: TypeLookup): ValuePredicate =\n+    fromJsObject(it, iface.TypeCon(iface.TypeConName(lfIdentifier(typ)), ImmArraySeq.empty), defs)\n+\n+  def fromJsObject(it: Map[String, JsValue], typ: iface.Type, defs: TypeLookup): ValuePredicate = {\n+    type Result = ValuePredicate\n+\n+    def fromValue(it: JsValue, typ: iface.Type): Result =\n+      (typ, it).match2 {\n+        case p @ iface.TypePrim(_, _) => { case _ => fromPrim(it, p) }\n+        case tc @ iface.TypeCon(iface.TypeConName(id), _) => {\n+          case _ =>\n+            val ddt = defs(id).getOrElse(predicateParseError(s\"Type $id not found\"))\n+            fromCon(it, id, tc instantiate ddt)\n+        }\n+        case iface.TypeNumeric(scale) => {\n+          case JsString(q) =>\n+            val nq = Numeric checkWithinBoundsAndRound (scale, BigDecimal(q)) fold (predicateParseError, identity)\n+            Literal { case V.ValueNumeric(v) if nq == (v setScale scale) => }\n+          case JsNumber(q) =>\n+            val nq = Numeric checkWithinBoundsAndRound (scale, q) fold (predicateParseError, identity)\n+            Literal { case V.ValueNumeric(v) if nq == (v setScale scale) => }\n+        }\n+        case iface.TypeVar(_) => predicateParseError(\"no vars allowed!\")\n+      }(fallback = illTypedQuery(it, typ))\n+\n+    def fromCon(it: JsValue, id: Ref.Identifier, typ: iface.DataType.FWT): Result =\n+      (typ, it).match2 {\n+        case rec @ iface.Record(_) => {\n+          case JsObject(fields) =>\n+            fromRecord(fields, id, rec)\n+        }\n+        case iface.Variant(fieldTyps) => {\n+          case JsObject(fields) =>\n+            fromVariant(fields, id, fieldTyps)\n+        }\n+        case e @ iface.Enum(_) => {\n+          case JsString(s) => fromEnum(s, id, e)\n+        }\n+      }(fallback = ???)\n+\n+    def fromRecord(\n+        fields: Map[String, JsValue],\n+        id: Ref.Identifier,\n+        typ: iface.Record.FWT): Result = {\n+      val iface.Record(fieldTyps) = typ\n+      val invalidKeys = fields.keySet diff fieldTyps.iterator.map(_._1).toSet\n+      if (invalidKeys.nonEmpty)\n+        predicateParseError(s\"$id does not have fields $invalidKeys\")\n+      RecordSubset(fieldTyps map {\n+        case (fName, fTy) =>\n+          fields get fName map (fSpec => (fName, fromValue(fSpec, fTy)))\n+      })\n+    }\n+\n+    def fromVariant(\n+        fields: Map[String, JsValue],\n+        id: Ref.Identifier,\n+        fieldTyps: ImmArraySeq[(Ref.Name, Ty)]): Result = fields.toSeq match {\n+      case Seq((k, v)) =>\n+        val name = Ref.Name.assertFromString(k)\n+        val field: Option[(Ref.Name, Ty)] = fieldTyps.find(_._1 == name)\n+        val fieldP: Option[(Ref.Name, ValuePredicate)] = field.map {\n+          case (n, t) => (n, fromValue(v, t))\n+        }\n+        fieldP.fold(\n+          predicateParseError(\n+            s\"Cannot locate Variant's (datacon, type) field, id: $id, name: $name\")\n+        )(VariantMatch)\n+\n+      case _ => predicateParseError(s\"Variant must have exactly 1 field, got: $fields, id: $id\")"
  },
  {
    "id" : "fafc7fd1-dd33-4501-884e-09e3ddebd69b",
    "prId" : 2826,
    "comments" : [
      {
        "id" : "813686db-954d-4dab-8af3-00bb20d5e878",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Better error message?",
        "createdAt" : "2019-09-23T15:34:59Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e2544954-b152-4814-99b9-a840b8d82dac",
        "parentId" : "813686db-954d-4dab-8af3-00bb20d5e878",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Ah, just missed that one, thanks. afcf1de595",
        "createdAt" : "2019-09-23T19:08:41Z",
        "updatedAt" : "2019-09-23T19:38:21Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "078ec69a5240afdc0f2e7a5ee0646566cc902378",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,250 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http\n+package query\n+\n+import util.IdentifierConverters.lfIdentifier\n+\n+import com.digitalasset.daml.lf.data.{ImmArray, Numeric, Ref, SortedLookupList, Time}\n+import ImmArray.ImmArraySeq\n+import com.digitalasset.daml.lf.data.ScalazEqual._\n+import com.digitalasset.daml.lf.iface\n+import com.digitalasset.daml.lf.value.{Value => V}\n+import iface.{Type => Ty}\n+import scalaz.\\&/\n+import scalaz.syntax.std.option._\n+import scalaz.syntax.std.string._\n+import spray.json._\n+\n+sealed abstract class ValuePredicate extends Product with Serializable {\n+  import ValuePredicate._\n+  def toFunPredicate: LfV => Boolean = {\n+    def go(self: ValuePredicate): LfV => Boolean = self match {\n+      case Literal(p) => p.isDefinedAt\n+\n+      case RecordSubset(q) =>\n+        val cq = q map (_ map { case (_, vp) => go(vp) });\n+        {\n+          case V.ValueRecord(_, fields) =>\n+            cq zip fields.toSeq forall {\n+              case (None, _) => true\n+              case (Some(fp), (_, lfv)) => fp(lfv)\n+            }\n+          case _ => false\n+        }\n+\n+      case MapMatch(q) =>\n+        val cq = (q mapValue go).toImmArray;\n+        {\n+          case V.ValueMap(v) if cq.length == v.toImmArray.length =>\n+            // the sort-by-key is the same for cq and v, so if equal, the keys\n+            // are at equal indices\n+            cq.iterator zip v.toImmArray.iterator forall {\n+              case ((qk, qp), (vk, vv)) => qk == vk && qp(vv)\n+            }\n+          case _ => false\n+        }\n+\n+      case ListMatch(qs) =>\n+        val cqs = qs map go;\n+        {\n+          case V.ValueList(vs) if cqs.length == vs.length =>\n+            cqs.iterator zip vs.iterator forall {\n+              case (q, v) => q(v)\n+            }\n+          case _ => false\n+        }\n+\n+      case VariantMatch((n1, p)) =>\n+        val cp = go(p);\n+        {\n+          case V.ValueVariant(_, n2, v) if n1 == n2 => cp(v)\n+          case _ => false\n+        }\n+\n+      case OptionalMatch(oq) =>\n+        oq map go cata (csq => { case V.ValueOptional(Some(v)) => csq(v); case _ => false },\n+        { case V.ValueOptional(None) => true; case _ => false })\n+\n+      case Range(_, _) => predicateParseError(\"range not supported yet\")\n+    }\n+    go(this)\n+  }\n+}\n+\n+object ValuePredicate {\n+  type TypeLookup = Ref.Identifier => Option[iface.DefDataType.FWT]\n+  type LfV = V[V.AbsoluteContractId]\n+\n+  final case class Literal(p: LfV PartialFunction Unit) extends ValuePredicate\n+  final case class RecordSubset(fields: ImmArraySeq[Option[(Ref.Name, ValuePredicate)]])\n+      extends ValuePredicate\n+  final case class MapMatch(elems: SortedLookupList[ValuePredicate]) extends ValuePredicate\n+  final case class ListMatch(elems: Vector[ValuePredicate]) extends ValuePredicate\n+  final case class VariantMatch(elem: (Ref.Name, ValuePredicate)) extends ValuePredicate\n+  final case class OptionalMatch(elem: Option[ValuePredicate]) extends ValuePredicate\n+  // boolean is whether inclusive (lte vs lt)\n+  final case class Range(ltgt: (Boolean, LfV) \\&/ (Boolean, LfV), typ: Ty) extends ValuePredicate\n+\n+  private[http] def fromTemplateJsObject(\n+      it: Map[String, JsValue],\n+      typ: domain.TemplateId.RequiredPkg,\n+      defs: TypeLookup): ValuePredicate =\n+    fromJsObject(it, iface.TypeCon(iface.TypeConName(lfIdentifier(typ)), ImmArraySeq.empty), defs)\n+\n+  def fromJsObject(it: Map[String, JsValue], typ: iface.Type, defs: TypeLookup): ValuePredicate = {\n+    type Result = ValuePredicate\n+\n+    def fromValue(it: JsValue, typ: iface.Type): Result =\n+      (typ, it).match2 {\n+        case p @ iface.TypePrim(_, _) => { case _ => fromPrim(it, p) }\n+        case tc @ iface.TypeCon(iface.TypeConName(id), _) => {\n+          case _ =>\n+            val ddt = defs(id).getOrElse(predicateParseError(s\"Type $id not found\"))\n+            fromCon(it, id, tc instantiate ddt)\n+        }\n+        case iface.TypeNumeric(scale) => {\n+          case JsString(q) =>\n+            val nq = Numeric checkWithinBoundsAndRound (scale, BigDecimal(q)) fold (predicateParseError, identity)\n+            Literal { case V.ValueNumeric(v) if nq == (v setScale scale) => }\n+          case JsNumber(q) =>\n+            val nq = Numeric checkWithinBoundsAndRound (scale, q) fold (predicateParseError, identity)\n+            Literal { case V.ValueNumeric(v) if nq == (v setScale scale) => }\n+        }\n+        case iface.TypeVar(_) => predicateParseError(\"no vars allowed!\")\n+      }(fallback = illTypedQuery(it, typ))\n+\n+    def fromCon(it: JsValue, id: Ref.Identifier, typ: iface.DataType.FWT): Result =\n+      (typ, it).match2 {\n+        case rec @ iface.Record(_) => {\n+          case JsObject(fields) =>\n+            fromRecord(fields, id, rec)\n+        }\n+        case iface.Variant(fieldTyps) => {\n+          case JsObject(fields) =>\n+            fromVariant(fields, id, fieldTyps)\n+        }\n+        case e @ iface.Enum(_) => {\n+          case JsString(s) => fromEnum(s, id, e)\n+        }\n+      }(fallback = ???)"
  }
]