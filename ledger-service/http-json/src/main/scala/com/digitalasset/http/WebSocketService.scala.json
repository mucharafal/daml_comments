[
  {
    "id" : "df4a7453-880c-4431-a8ed-389aea3990e0",
    "prId" : 7244,
    "comments" : [
      {
        "id" : "28f98775-0d78-4223-9527-ac88e170c948",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        resolvedWithKey.foldLeft(Map.empty[domain.TemplateId.RequiredPkg, HashSet[LfV]])((acc, el) =>\r\n```\r\nSame bikeshedding as on the other PR. I find that a bit easier to read.",
        "createdAt" : "2020-08-26T17:27:47Z",
        "updatedAt" : "2020-08-26T18:39:33Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "85e5f6e7-a692-4501-a28c-e87bd358d9e3",
        "parentId" : "28f98775-0d78-4223-9527-ac88e170c948",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2020-08-26T18:15:17Z",
        "updatedAt" : "2020-08-26T18:39:33Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffdc23647326944307ebd81ee45f6acbaf83a0be",
    "line" : null,
    "diffHunk" : "@@ -257,11 +258,17 @@ object WebSocketService {\n             .toLeftDisjunction(x.ekey.templateId)\n         }\n \n-      val q: Map[domain.TemplateId.RequiredPkg, LfV] = resolvedWithKey.toMap\n+      val q: Map[domain.TemplateId.RequiredPkg, HashSet[LfV]] =\n+        resolvedWithKey.foldLeft(Map[domain.TemplateId.RequiredPkg, HashSet[LfV]]())((acc, el) =>"
  },
  {
    "id" : "7d5d6b3d-d03f-417c-a80b-26798532b2cb",
    "prId" : 7244,
    "comments" : [
      {
        "id" : "571c47f9-1296-4bb7-9472-7ac18b924df0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "As far as I can tell you are still appending instead of prepending which is quadratic. Can we prepend instead?",
        "createdAt" : "2020-08-26T17:28:37Z",
        "updatedAt" : "2020-08-26T18:39:33Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eedbabbf-06b2-4d91-b655-c4b381726f23",
        "parentId" : "571c47f9-1296-4bb7-9472-7ac18b924df0",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "This is a `HashSet` now so this is pretty much `O(1)`.",
        "createdAt" : "2020-08-26T17:31:43Z",
        "updatedAt" : "2020-08-26T18:39:33Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5367dff6-c1b6-4eea-b9b9-c7a30270b4d5",
        "parentId" : "571c47f9-1296-4bb7-9472-7ac18b924df0",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Also note that this is a one-time construction at the point of establishing the stream. The one-time cost has changed from quadratic to linear, and the per-event cost (which matters more imo) is now \"effectively constant\" (i.e. logarithmic with a very large base), as per the documentation, rather than linear.",
        "createdAt" : "2020-08-26T17:33:54Z",
        "updatedAt" : "2020-08-26T18:39:33Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fbf46bfa-fd50-46bb-b288-09ed4cc8fdb1",
        "parentId" : "571c47f9-1296-4bb7-9472-7ac18b924df0",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh I missed that this is a HashSet now, makes sense then :+1: ",
        "createdAt" : "2020-08-26T17:36:39Z",
        "updatedAt" : "2020-08-26T18:39:33Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ffdc23647326944307ebd81ee45f6acbaf83a0be",
    "line" : null,
    "diffHunk" : "@@ -257,11 +258,17 @@ object WebSocketService {\n             .toLeftDisjunction(x.ekey.templateId)\n         }\n \n-      val q: Map[domain.TemplateId.RequiredPkg, LfV] = resolvedWithKey.toMap\n+      val q: Map[domain.TemplateId.RequiredPkg, HashSet[LfV]] =\n+        resolvedWithKey.foldLeft(Map[domain.TemplateId.RequiredPkg, HashSet[LfV]]())((acc, el) =>\n+          acc.get(el._1) match {\n+            case Some(v) => acc.updated(el._1, v += el._2)"
  },
  {
    "id" : "1c94c053-8800-4b19-aed5-19e08d1a6e5c",
    "prId" : 7109,
    "comments" : [
      {
        "id" : "c2d52b0c-a771-495b-90a2-e141240a8cdd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is probably just me being unfamiliar with the code but why do we need to update the state in the case of `LedgerBegin` but not in the case of `AbsoluteBookmark`? As far as I can tell, the only thing that updating the state does here is reset the errors since the step is unchanged anyway.",
        "createdAt" : "2020-08-12T18:31:02Z",
        "updatedAt" : "2020-08-12T22:30:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb68a8b7-4154-405f-85b8-e469454f35ea",
        "parentId" : "c2d52b0c-a771-495b-90a2-e141240a8cdd",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "you do NOT want to update it for the incoming TickTrigger message, you would loose the captured offset, you actually don't have an offset in the TickTrigger. It is just in case of ledgerBegin you have a zero state, it does not matter if you override it or not... but I like the above idea of capturing only offset instead of the step with corresponding offset. I am going to make this change.",
        "createdAt" : "2020-08-12T20:29:46Z",
        "updatedAt" : "2020-08-12T22:32:33Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "073b6313a6a76aa9d1e126f727c4446e885d05a4",
    "line" : null,
    "diffHunk" : "@@ -403,31 +407,30 @@ class WebSocketService(\n   private def emitOffsetTicksAndFilterOutEmptySteps[Pos](startFrom: Option[domain.StartingOffset])\n     : Flow[StepAndErrors[Pos, JsValue], StepAndErrors[Pos, JsValue], NotUsed] = {\n \n-    type TickTriggerOrStep = Unit \\/ StepAndErrors[Pos, JsValue]\n-\n-    val tickTrigger: TickTriggerOrStep = -\\/(())\n-    val zeroState: StepAndErrors[Pos, JsValue] = startFrom.cata(\n+    val zeroStep: StepAndErrors[Pos, JsValue] = startFrom.cata(\n       x => StepAndErrors(Seq(), LiveBegin(AbsoluteBookmark(x.offset))),\n       StepAndErrors(Seq(), LiveBegin(LedgerBegin))\n     )\n     Flow[StepAndErrors[Pos, JsValue]]\n-      .map(a => \\/-(a): TickTriggerOrStep)\n-      .keepAlive(config.heartBeatPer, () => tickTrigger)\n-      .scan((zeroState, tickTrigger)) {\n-        case ((state, _), -\\/(())) =>\n-          // convert tick trigger into a tick message, get the last seen offset from the state\n+      .map(a => Step(a))\n+      .keepAlive(config.heartBeatPer, () => TickTrigger)\n+      .scan((zeroStep, TickTrigger: TickTriggerOrStep[Pos])) {\n+        case ((_, TickTrigger), TickTrigger) =>\n+          // skip all TickTriggers preceding the initial ACS retrieval\n+          (zeroStep, TickTrigger)\n+        case ((state, _), TickTrigger) =>\n+          // convert TickTrigger into a Step, get the last seen offset from the state\n           state.step match {\n-            case Acs(_) => (ledgerBeginTick, \\/-(ledgerBeginTick))\n-            case LiveBegin(LedgerBegin) => (ledgerBeginTick, \\/-(ledgerBeginTick))\n-            case LiveBegin(AbsoluteBookmark(offset)) => (state, \\/-(offsetTick(offset)))\n-            case Txn(_, offset) => (state, \\/-(offsetTick(offset)))\n+            case Acs(_) => (state, TickTrigger) // we don't know the offset yet\n+            case LiveBegin(LedgerBegin) => (ledgerBeginTick, Step(ledgerBeginTick))\n+            case LiveBegin(AbsoluteBookmark(offset)) => (state, Step(offsetTick(offset)))"
  },
  {
    "id" : "2bd5d275-f96e-48cd-8678-680f723acdbb",
    "prId" : 7109,
    "comments" : [
      {
        "id" : "da076526-3d40-4387-8072-6554dad65a4a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Could we just replace `state` by `Option[domain.StartingOffset]`? I can’t find any case where we use more info than is provided by this and it seems to make the code much clearer: None means you haven’t seen the offset, `Some` means you have seen it (we still need the second element of the pair).",
        "createdAt" : "2020-08-12T18:42:45Z",
        "updatedAt" : "2020-08-12T22:30:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8f880a9d-f05d-4942-8862-29f1f8f1b408",
        "parentId" : "da076526-3d40-4387-8072-6554dad65a4a",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "good idea! Thanks!",
        "createdAt" : "2020-08-12T20:24:50Z",
        "updatedAt" : "2020-08-12T22:30:03Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c45b8ec7-2649-4013-9276-0a80b90e1c41",
        "parentId" : "da076526-3d40-4387-8072-6554dad65a4a",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "looks like it is a bit harder to make that change than I originally thought, too many offsets of unrelated types.",
        "createdAt" : "2020-08-12T20:38:11Z",
        "updatedAt" : "2020-08-12T22:30:03Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "528731e6-10e2-4295-88e9-858cd099a577",
        "parentId" : "da076526-3d40-4387-8072-6554dad65a4a",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "but I think it reads better now.",
        "createdAt" : "2020-08-12T22:37:52Z",
        "updatedAt" : "2020-08-12T22:37:53Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "073b6313a6a76aa9d1e126f727c4446e885d05a4",
    "line" : null,
    "diffHunk" : "@@ -403,31 +407,30 @@ class WebSocketService(\n   private def emitOffsetTicksAndFilterOutEmptySteps[Pos](startFrom: Option[domain.StartingOffset])\n     : Flow[StepAndErrors[Pos, JsValue], StepAndErrors[Pos, JsValue], NotUsed] = {\n \n-    type TickTriggerOrStep = Unit \\/ StepAndErrors[Pos, JsValue]\n-\n-    val tickTrigger: TickTriggerOrStep = -\\/(())\n-    val zeroState: StepAndErrors[Pos, JsValue] = startFrom.cata(\n+    val zeroStep: StepAndErrors[Pos, JsValue] = startFrom.cata(\n       x => StepAndErrors(Seq(), LiveBegin(AbsoluteBookmark(x.offset))),\n       StepAndErrors(Seq(), LiveBegin(LedgerBegin))\n     )\n     Flow[StepAndErrors[Pos, JsValue]]\n-      .map(a => \\/-(a): TickTriggerOrStep)\n-      .keepAlive(config.heartBeatPer, () => tickTrigger)\n-      .scan((zeroState, tickTrigger)) {\n-        case ((state, _), -\\/(())) =>\n-          // convert tick trigger into a tick message, get the last seen offset from the state\n+      .map(a => Step(a))\n+      .keepAlive(config.heartBeatPer, () => TickTrigger)\n+      .scan((zeroStep, TickTrigger: TickTriggerOrStep[Pos])) {\n+        case ((_, TickTrigger), TickTrigger) =>\n+          // skip all TickTriggers preceding the initial ACS retrieval\n+          (zeroStep, TickTrigger)\n+        case ((state, _), TickTrigger) =>"
  },
  {
    "id" : "7cf92ff6-022d-46cf-8ff2-920eec012e53",
    "prId" : 7109,
    "comments" : [
      {
        "id" : "345355fc-1324-4880-a051-5457a454651d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thank you for making the change! Much easier to follow now for me!",
        "createdAt" : "2020-08-13T06:58:45Z",
        "updatedAt" : "2020-08-13T06:59:55Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "073b6313a6a76aa9d1e126f727c4446e885d05a4",
    "line" : 76,
    "diffHunk" : "@@ -400,41 +404,32 @@ class WebSocketService(\n     }\n   }\n \n-  private def emitOffsetTicksAndFilterOutEmptySteps[Pos](startFrom: Option[domain.StartingOffset])\n+  private def emitOffsetTicksAndFilterOutEmptySteps[Pos]\n     : Flow[StepAndErrors[Pos, JsValue], StepAndErrors[Pos, JsValue], NotUsed] = {\n \n-    type TickTriggerOrStep = Unit \\/ StepAndErrors[Pos, JsValue]\n+    val zero = (Option.empty[BeginBookmark[domain.Offset]], TickTrigger: TickTriggerOrStep[Pos])\n \n-    val tickTrigger: TickTriggerOrStep = -\\/(())\n-    val zeroState: StepAndErrors[Pos, JsValue] = startFrom.cata(\n-      x => StepAndErrors(Seq(), LiveBegin(AbsoluteBookmark(x.offset))),\n-      StepAndErrors(Seq(), LiveBegin(LedgerBegin))\n-    )\n     Flow[StepAndErrors[Pos, JsValue]]\n-      .map(a => \\/-(a): TickTriggerOrStep)\n-      .keepAlive(config.heartBeatPer, () => tickTrigger)\n-      .scan((zeroState, tickTrigger)) {\n-        case ((state, _), -\\/(())) =>\n-          // convert tick trigger into a tick message, get the last seen offset from the state\n-          state.step match {\n-            case Acs(_) => (ledgerBeginTick, \\/-(ledgerBeginTick))\n-            case LiveBegin(LedgerBegin) => (ledgerBeginTick, \\/-(ledgerBeginTick))\n-            case LiveBegin(AbsoluteBookmark(offset)) => (state, \\/-(offsetTick(offset)))\n-            case Txn(_, offset) => (state, \\/-(offsetTick(offset)))\n-          }\n-        case ((_, _), x @ \\/-(step)) =>\n-          // filter out empty steps, capture the current step, so we keep the last seen offset for the next tick\n-          val nonEmptyStep: TickTriggerOrStep = if (step.nonEmpty) x else tickTrigger\n-          (step, nonEmptyStep)\n+      .map(a => Step(a))\n+      .keepAlive(config.heartBeatPer, () => TickTrigger)\n+      .scan(zero) {\n+        case ((None, _), TickTrigger) =>"
  },
  {
    "id" : "79391c7a-2dd2-4e00-aa57-c0eb787caf1b",
    "prId" : 7066,
    "comments" : [
      {
        "id" : "ec314b76-7013-4e15-8189-741aa1ea96d3",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I prefer spinning out bugfixes into separate PRs in general to ease reviews and make sure things are tested on their own. I’m fine with keeping it for now but we should test this via the JSON API test suite as part of a separate PR.",
        "createdAt" : "2020-08-26T06:48:09Z",
        "updatedAt" : "2020-09-08T14:23:47Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8246eec3-0732-4bc0-adfe-98ba37e35228",
        "parentId" : "ec314b76-7013-4e15-8189-741aa1ea96d3",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Spun out as #7244.",
        "createdAt" : "2020-09-02T15:10:58Z",
        "updatedAt" : "2020-09-08T14:23:47Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef0422dc9dbfe8749fff1b56b9a06706cecc569",
    "line" : null,
    "diffHunk" : "@@ -257,9 +257,14 @@ object WebSocketService {\n             .toLeftDisjunction(x.ekey.templateId)\n         }\n \n-      val q: Map[domain.TemplateId.RequiredPkg, LfV] = resolvedWithKey.toMap\n+      val q: Map[domain.TemplateId.RequiredPkg, Seq[LfV]] ="
  },
  {
    "id" : "8043cdc9-a5e3-442c-8b0a-f753b03410f6",
    "prId" : 7066,
    "comments" : [
      {
        "id" : "cf341ac5-f127-4a64-96ea-af7a93ae411b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        resolvedWithKey.groupBy(_.1).mapValues(foldLeft(Map[domain.TemplateId.RequiredPkg, Seq[LfV]].empty)((acc, el) =>\r\n          acc.get(el._1) match {\r\n            case Some(v) => acc.updated(el._1, el._2 :: v)\r\n            case None => acc.updated(el._1, Seq(el._2))\r\n        })\r\n```\r\nAs far as I can tell you don’t care about the order and repeatedly appending to `List` is quadratic (at least I think so, in Haskell it definitely is).\r\n\r\nSide note: I really wish we were on Scala 2.13 and could just use `groupMap` here or at least `updatedWith`.",
        "createdAt" : "2020-08-26T07:20:23Z",
        "updatedAt" : "2020-09-08T14:23:47Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dd6fa874-851e-4837-9b46-7056136d5802",
        "parentId" : "cf341ac5-f127-4a64-96ea-af7a93ae411b",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Performance issue addressed in #7244 by using a set instead of a list. Also makes lookups faster.",
        "createdAt" : "2020-09-02T15:11:39Z",
        "updatedAt" : "2020-09-08T14:23:47Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef0422dc9dbfe8749fff1b56b9a06706cecc569",
    "line" : null,
    "diffHunk" : "@@ -257,9 +257,14 @@ object WebSocketService {\n             .toLeftDisjunction(x.ekey.templateId)\n         }\n \n-      val q: Map[domain.TemplateId.RequiredPkg, LfV] = resolvedWithKey.toMap\n+      val q: Map[domain.TemplateId.RequiredPkg, Seq[LfV]] =\n+        resolvedWithKey.foldLeft(Map[domain.TemplateId.RequiredPkg, Seq[LfV]]())((acc, el) =>\n+          acc.get(el._1) match {\n+            case Some(v) => acc.updated(el._1, v ++ Seq(el._2))\n+            case None => acc.updated(el._1, Seq(el._2))\n+        })"
  },
  {
    "id" : "0238e3eb-fa71-4e07-b73e-7c4580aa2d00",
    "prId" : 7066,
    "comments" : [
      {
        "id" : "10464ae0-a4af-436d-bca9-b04553e8ab68",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Great work tracking this down!",
        "createdAt" : "2020-08-26T07:20:33Z",
        "updatedAt" : "2020-09-08T14:23:47Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef0422dc9dbfe8749fff1b56b9a06706cecc569",
    "line" : null,
    "diffHunk" : "@@ -257,9 +257,14 @@ object WebSocketService {\n             .toLeftDisjunction(x.ekey.templateId)\n         }\n \n-      val q: Map[domain.TemplateId.RequiredPkg, LfV] = resolvedWithKey.toMap\n+      val q: Map[domain.TemplateId.RequiredPkg, Seq[LfV]] ="
  },
  {
    "id" : "c89964f8-ab0b-446c-b7ad-38b17112aba1",
    "prId" : 5318,
    "comments" : [
      {
        "id" : "d712e9b1-7e43-4f40-98e4-194f14634bda",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n        }.valueOr(e => Source.single(-\\/(e))): Source[Error \\/ Message, NotUsed]\r\n```",
        "createdAt" : "2020-03-31T17:34:31Z",
        "updatedAt" : "2020-03-31T17:58:45Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8f0bd1e6c6633281ac328abbfbfb725b280a3b63",
    "line" : null,
    "diffHunk" : "@@ -358,14 +358,12 @@ class WebSocketService(\n       .via(allowOnlyFirstInput(\n         InvalidUserInput(\"Multiple requests over the same WebSocket connection are not allowed.\")))\n       .flatMapMerge(\n-        2,\n-        x =>\n-          x.flatMap {\n-              case (offPrefix, qq: Q.Query[q]) =>\n-                implicit val SQ: StreamQuery[q] = qq.alg\n-                getTransactionSourceForParty[q](jwt, jwtPayload.party, offPrefix, qq.q: q)\n-            }\n-            .fold(e => Source.single(-\\/(e)), s => s.map(\\/-(_))): Source[Error \\/ Message, NotUsed]\n+        2, // 2 streams max, the 2nd is to be able to send an error back\n+        _.map {\n+          case (offPrefix, qq: Q.Query[q]) =>\n+            implicit val SQ: StreamQuery[q] = qq.alg\n+            getTransactionSourceForParty[q](jwt, jwtPayload.party, offPrefix, qq.q: q)\n+        }.fold(e => Source.single(-\\/(e)), identity): Source[Error \\/ Message, NotUsed]"
  },
  {
    "id" : "52943620-ec27-4cc8-86f8-1af5ab622a72",
    "prId" : 5109,
    "comments" : [
      {
        "id" : "9d58c7c0-d6db-4021-b645-19670fdf3875",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I believe the logback config in the SDK is set to info level so this will be shown by default to users. Is that really what you intended?",
        "createdAt" : "2020-03-20T15:12:58Z",
        "updatedAt" : "2020-03-20T16:24:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6c44af53-770c-4a40-bd19-9ef91feb859e",
        "parentId" : "9d58c7c0-d6db-4021-b645-19670fdf3875",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "yep, I wanted to capture the queries in case something fails.",
        "createdAt" : "2020-03-20T15:58:34Z",
        "updatedAt" : "2020-03-20T16:24:45Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "afb4dcec4229e4b29f4fd07708db6be37d6033d9",
    "line" : null,
    "diffHunk" : "@@ -318,6 +318,7 @@ class WebSocketService(\n       .mapAsync(1) {\n         case msg: TextMessage =>\n           msg.toStrict(config.maxDuration).map { m =>\n+            logger.info(s\"request: ${m.text}\")"
  },
  {
    "id" : "7ab3637b-d121-4737-82b9-29e37682c13a",
    "prId" : 5109,
    "comments" : [
      {
        "id" : "1fbf95e4-f726-4145-acd9-5d017587f07b",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Is this safe to log from a security/privacy standpoint?",
        "createdAt" : "2020-03-20T15:13:36Z",
        "updatedAt" : "2020-03-20T16:24:45Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "71e37931-7c6f-4b7f-ad9d-424fa7ef7fe9",
        "parentId" : "1fbf95e4-f726-4145-acd9-5d017587f07b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "um... I don't actually know.\r\nHowever if you get access to the disk that contains the log, means you have ssh access to the box, means you can access postgresql, and also tcp dump all traffic :)\r\n",
        "createdAt" : "2020-03-20T16:00:52Z",
        "updatedAt" : "2020-03-20T16:24:45Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6b0cc0f6-4fc2-473d-9953-a78d2bc0e1c1",
        "parentId" : "1fbf95e4-f726-4145-acd9-5d017587f07b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "but going to ping Ed.",
        "createdAt" : "2020-03-20T16:01:37Z",
        "updatedAt" : "2020-03-20T16:24:45Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f0d10179-ab45-456d-b531-6ccbd768327e",
        "parentId" : "1fbf95e4-f726-4145-acd9-5d017587f07b",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "It's fairly normal for ops teams to pipe logs to Logstash, Fluentd, StackDriver, etc, which means they might be more readily available, and not subject to any monitoring you might have about who's logged on to a box.",
        "createdAt" : "2020-03-20T16:03:19Z",
        "updatedAt" : "2020-03-20T16:24:45Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "103f2740-79a8-48aa-929f-c90d43b0d2bf",
        "parentId" : "1fbf95e4-f726-4145-acd9-5d017587f07b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "true.",
        "createdAt" : "2020-03-20T16:06:26Z",
        "updatedAt" : "2020-03-20T16:24:45Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a54b46da-75e2-405c-80af-c5dd85a4a3c6",
        "parentId" : "1fbf95e4-f726-4145-acd9-5d017587f07b",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@SamirTalwar thanks a lot for bringing this up... I moved the logging into tests for now, this would help to debug any further test failures/timeouts. As for the prod logging, this is going to be a separate discussion with @nycnewman ",
        "createdAt" : "2020-03-20T16:26:20Z",
        "updatedAt" : "2020-03-20T16:26:20Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "afb4dcec4229e4b29f4fd07708db6be37d6033d9",
    "line" : null,
    "diffHunk" : "@@ -318,6 +318,7 @@ class WebSocketService(\n       .mapAsync(1) {\n         case msg: TextMessage =>\n           msg.toStrict(config.maxDuration).map { m =>\n+            logger.info(s\"request: ${m.text}\")"
  },
  {
    "id" : "1a5ed804-b82a-441c-a607-0461c05de0ad",
    "prId" : 4886,
    "comments" : [
      {
        "id" : "c1868099-7a78-462e-b6c4-800a3ccb8dbf",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "The `WebSocketService` is not an appropriate scope for this.",
        "createdAt" : "2020-03-06T19:53:42Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e8c41c6f-004c-4261-ac67-9e3e94251828",
        "parentId" : "c1868099-7a78-462e-b6c4-800a3ccb8dbf",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "why? it is one instance per client ws connection, so should be all right.",
        "createdAt" : "2020-03-06T19:58:26Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "14acd2aa-1d5c-4e12-b2f5-f2c07f40cc7d",
        "parentId" : "c1868099-7a78-462e-b6c4-800a3ccb8dbf",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "it is defined in the class, not in the companion object.",
        "createdAt" : "2020-03-06T20:04:11Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b774b82-d239-4a57-a616-0984489c2870",
        "parentId" : "c1868099-7a78-462e-b6c4-800a3ccb8dbf",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "No it is not. Note the `numConns` variable immediately adjacent, or\r\n\r\nhttps://github.com/digital-asset/daml/blob/3a79143b98202d656822cd44fdb9d04b5f83bc03/ledger-service/http-json/src/main/scala/com/digitalasset/http/HttpService.scala#L143\r\n\r\nThis confusion is only further evidence that \"within the stream\" is the minimum scope safety required for this feature.",
        "createdAt" : "2020-03-06T20:05:15Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "27f5d105-02ef-48e5-ab73-3bedfaab5af0",
        "parentId" : "c1868099-7a78-462e-b6c4-800a3ccb8dbf",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "yes, you are right... switching it to `Flow.scan`",
        "createdAt" : "2020-03-06T20:28:02Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "41ee53013c9760d2123824d5705920e4ed550345",
    "line" : null,
    "diffHunk" : "@@ -244,15 +246,20 @@ class WebSocketService(\n \n   private val numConns = new java.util.concurrent.atomic.AtomicInteger(0)\n \n+  @volatile private var lastSeenOffset: Option[JsValue] = None"
  },
  {
    "id" : "0e36c016-22b0-4235-8b64-2d8c22b565c7",
    "prId" : 4886,
    "comments" : [
      {
        "id" : "adcdb26d-eb99-48e1-a954-87f8433b06d5",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "This occurring earlier in the stream means that empty (or emptied by means of filtering) steps will not cause offset to \"tick up\". You might have to `-\\/` on the heartbeat before this stage in the flow.",
        "createdAt" : "2020-03-09T19:25:14Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f3059933-6942-48fc-95d1-c76478a243a1",
        "parentId" : "adcdb26d-eb99-48e1-a954-87f8433b06d5",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@S11001001 @hurryabit  is that really important to \"tick up\" empty events? You will get the heartbeat in any case if there is no activity matching the query. We either filter empty events out completely or we need to add some logic for conflating consecutive empty events, which would rather complicate the flow.\r\n\r\nIf you only care about the \"live\" marker, it can be sent explicitly.",
        "createdAt" : "2020-03-11T13:01:13Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5b98b705-f04d-4a0d-81f4-42d847dbbb94",
        "parentId" : "adcdb26d-eb99-48e1-a954-87f8433b06d5",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "It is important, and a prime motivation for this feature.\r\n\r\nConsider the sequence of event blocks, before we filter out the empty ones. Each has a unique offset, representing when it happened, and therefore when the stream will pick up if you resume it.\r\n\r\nA block becomes empty in the stream for only one reason: we filtered out all the events in it. This feature is important to preserve so you don't get spammed with empty event blocks should you choose a particularly strict query (e.g. all key queries are quite strict).\r\n\r\nSuppose that you get a block, and then four hours pass. Suppose that there are empty event blocks in that time. Under the current code, the heartbeat will continue to emit the offset from the last non-empty event block. What we want is for it to emit the offset from the last _empty or non-empty_ event block, so that should you close the stream and resume, you won't necessarily be four hours in the past.\r\n\r\nI don't think this has to terribly affect the current flow; your present logic can work on `StepAndErrors`, possibly making `StepAndErrors` a full ADT (or not, do whatever works structurally), rather than the output of `render`, and an \"empty\" `StepAndErrors` that should be emitted anyway because it is a heartbeat can simply be `nonEmpty`.",
        "createdAt" : "2020-03-11T18:31:09Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9a85df00-9f19-46ce-bf08-8f601e940124",
        "parentId" : "adcdb26d-eb99-48e1-a954-87f8433b06d5",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "See: #4955",
        "createdAt" : "2020-03-11T19:18:13Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "41ee53013c9760d2123824d5705920e4ed550345",
    "line" : 101,
    "diffHunk" : "@@ -315,6 +316,7 @@ class WebSocketService(\n         .filter(_.nonEmpty)"
  },
  {
    "id" : "ebae5247-09cf-4f12-ad1d-8138bea472a5",
    "prId" : 4886,
    "comments" : [
      {
        "id" : "5ef23495-618e-4988-b585-21d8ff59a8e6",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n        .via(renderEventsAndEmitHeartbeats) // wrong place, see https://github.com/digital-asset/daml/issues/4955\r\n```",
        "createdAt" : "2020-03-11T19:21:00Z",
        "updatedAt" : "2020-03-11T19:23:44Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "41ee53013c9760d2123824d5705920e4ed550345",
    "line" : null,
    "diffHunk" : "@@ -315,6 +316,7 @@ class WebSocketService(\n         .filter(_.nonEmpty)\n         .via(removePhantomArchives(remove = !Q.allowPhantonArchives))\n         .map(_.mapPos(Q.renderCreatedMetadata).render)\n+        .via(renderEventsAndEmitHeartbeats)"
  },
  {
    "id" : "2e4082ee-ac2f-4f61-8a13-7bbdb21d0846",
    "prId" : 4819,
    "comments" : [
      {
        "id" : "3219efdc-d79a-4706-afb6-4eb465dd8b60",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "this entire block + `readStartingOffset` could have been simplified with derived JSON Protofol for `domain.StreamingQueryRequest` variant. Hard to comprehend what is going on here.",
        "createdAt" : "2020-03-12T18:35:42Z",
        "updatedAt" : "2020-03-12T21:56:01Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3adc815d-5c59-4752-828a-5bed7f721d4d",
        "parentId" : "3219efdc-d79a-4706-afb6-4eb465dd8b60",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "You might be right about `readStartingOffset`, but that would do nothing to simplify this block.",
        "createdAt" : "2020-03-12T19:03:30Z",
        "updatedAt" : "2020-03-12T21:56:01Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2b225e99-67e7-4296-80da-d4d557343aeb",
        "parentId" : "3219efdc-d79a-4706-afb6-4eb465dd8b60",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "The reason I didn't derive is that I do not want to treat all JSON parse errors equally;\r\n\r\n1. a missing ``offset`` key should mean skip to the required body,\r\n2. a present ``offset`` key with non-string should fail, and\r\n3. mixing an ``offset`` key with any other key should fail,\r\n\r\nbut when you derive parsers\r\n\r\n```\r\nfinal case class Foo(foo: Int)\r\n\"\"\"{\"foo\":1, \"offset\":\"hi\"}\"\"\".parseJson.convertTo[Foo]\r\n// ⇑ evaluates to Foo(1)\r\n```\r\n\r\nOnce you add all this special handling, bothering with the derived parser becomes less a convenience and more a...bother. I can still work it in if you'd prefer, but it's not going to be as pretty as you might be imagining. Let me know what you think.\r\n\r\nI'll also think about what I can do with the definition of `withOptPrefix`, which I believe can be made more complicated to simplify the call to it that you've directly highlighted.",
        "createdAt" : "2020-03-12T19:43:01Z",
        "updatedAt" : "2020-03-12T21:56:01Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5722d235-35a9-4cf7-9780-e3276b88982a",
        "parentId" : "3219efdc-d79a-4706-afb6-4eb465dd8b60",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "See 9abd4e8cd8 for a `withOptPrefix` redesign.",
        "createdAt" : "2020-03-12T21:23:12Z",
        "updatedAt" : "2020-03-12T21:56:01Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7292b064dc3328ac908ca2a8760915e6a17e30c7",
    "line" : null,
    "diffHunk" : "@@ -290,28 +317,38 @@ class WebSocketService(\n     Flow[Message]\n       .mapAsync(1) {\n         case msg: TextMessage =>\n-          msg.toStrict(config.maxDuration).map(m => Q.parse(decoder, m.text))\n+          msg.toStrict(config.maxDuration).map { m =>\n+            SprayJson.parse(m.text).liftErr(InvalidUserInput)\n+          }\n         case _ =>\n           Future successful -\\/(\n             InvalidUserInput(\"Cannot process your input, Expect a single JSON message\"))\n       }\n+      .via(withOptPrefix { ejv: (InvalidUserInput \\/ JsValue) =>\n+        ejv\n+          .flatMap(jv =>\n+            Bitraverse[\\/].bisequence(\n+              readStartingOffset(jv) toLeftDisjunction Q.parse(decoder, jv).strengthL(None)))\n+          .sequence: domain.StartingOffset \\/ (Error \\/ (Option[domain.StartingOffset], A))\n+      }((offPrefix, ejv) => ejv flatMap (jv => Q.parse(decoder, jv) strengthL Some(offPrefix))))"
  },
  {
    "id" : "a9172c2c-911b-4e4f-87bf-9928091ce79b",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "7bd8f173-e0d2-4719-a6a9-35b2be59f454",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Could be written with `for`; whichever way you like.",
        "createdAt" : "2020-02-06T16:26:07Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -172,19 +175,27 @@ object WebSocketService {\n         SprayJson\n           .decode[List[domain.EnrichedContractKey[JsValue]]](str)\n           .liftErr(InvalidUserInput)\n-          .flatMap { as: List[domain.EnrichedContractKey[JsValue]] =>\n-            as.traverse(a => decode(decoder)(a))\n+          .map { as: List[domain.EnrichedContractKey[JsValue]] =>\n+            as.map(a => decodeWithFallback(decoder, a))"
  },
  {
    "id" : "fc7e7619-6d4a-4709-bdc1-f0106df022a4",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "188f962a-f274-4e30-b7f1-20795ce020c5",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n          .valueOr(_ => a.map(...))\r\n```",
        "createdAt" : "2020-02-06T16:28:01Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -172,19 +175,27 @@ object WebSocketService {\n         SprayJson\n           .decode[List[domain.EnrichedContractKey[JsValue]]](str)\n           .liftErr(InvalidUserInput)\n-          .flatMap { as: List[domain.EnrichedContractKey[JsValue]] =>\n-            as.traverse(a => decode(decoder)(a))\n+          .map { as: List[domain.EnrichedContractKey[JsValue]] =>\n+            as.map(a => decodeWithFallback(decoder, a))\n           }\n       }\n \n-      private def decode(decoder: DomainJsonDecoder)(\n-          a: domain.EnrichedContractKey[JsValue]): Error \\/ domain.EnrichedContractKey[LfV] =\n-        decoder.decodeUnderlyingValuesToLf(a).liftErr(InvalidUserInput)\n+      private def decodeWithFallback(\n+          decoder: DomainJsonDecoder,\n+          a: domain.EnrichedContractKey[JsValue]): domain.EnrichedContractKey[LfV] =\n+        decoder\n+          .decodeUnderlyingValuesToLf(a)\n+          .fold("
  },
  {
    "id" : "8dd7d6e9-6073-4e0e-b1a8-a4e4f8f48392",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "38d55380-f870-4a88-a9a8-5e4a0246bf2c",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    else Flow[StepAndErrors[A, B]]\r\n```",
        "createdAt" : "2020-02-06T16:28:31Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -300,6 +312,25 @@ class WebSocketService(\n     }\n   }\n \n+  private def removePhantomArchives[A, B](remove: Boolean) =\n+    if (remove) removePhantomArchives_[A, B]\n+    else Flow[StepAndErrors[A, B]].map(identity)"
  },
  {
    "id" : "2f6c2e82-7274-4b21-9276-a15e6419b8fc",
    "prId" : 4393,
    "comments" : [
      {
        "id" : "ff6a8d52-31d4-41ff-9489-de7563655e71",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n          val deletesToKeep: Set[String] = a0.step.deletes intersect s0\r\n```\r\n\r\nObserving that the above are equal, and `intersect` is symmetric, you could also use partition\r\n\r\n```suggestion\r\n          val (deletesToKeep, s0md) = s0 partition a0.step.deletes\r\n```\r\n\r\nAs `s0md` is `s0 -- deletesToKeep`. (As you may also have gathered, `partition` is the built-in \"blind boolean\" variant of our `partitionMap` utility.)",
        "createdAt" : "2020-02-06T16:31:21Z",
        "updatedAt" : "2020-02-06T18:05:46Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "95d525291dacf9c2f25712dee97c68fdb1666f50",
    "line" : null,
    "diffHunk" : "@@ -300,6 +312,25 @@ class WebSocketService(\n     }\n   }\n \n+  private def removePhantomArchives[A, B](remove: Boolean) =\n+    if (remove) removePhantomArchives_[A, B]\n+    else Flow[StepAndErrors[A, B]].map(identity)\n+\n+  private def removePhantomArchives_[A, B]\n+    : Flow[StepAndErrors[A, B], StepAndErrors[A, B], NotUsed] =\n+    Flow[StepAndErrors[A, B]]\n+      .scan((Set.empty[String], Option.empty[StepAndErrors[A, B]])) {\n+        case ((s0, _), a0) =>\n+          val deletesToKeep: Set[String] = a0.step.deletes.filter(x => s0(x))"
  },
  {
    "id" : "b0b66453-7078-4d1a-bc76-1a3c2c77c2a4",
    "prId" : 4363,
    "comments" : [
      {
        "id" : "32075f0f-2283-4b0e-8652-fb565f6d742a",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "why don't we want to emit `errors` first? the client may decide to cancel the stream processing entirely based on what error(s) they receive.",
        "createdAt" : "2020-02-05T13:37:27Z",
        "updatedAt" : "2020-02-06T14:50:14Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b4419484-24ee-4b60-acdd-2c8d018bde07",
        "parentId" : "32075f0f-2283-4b0e-8652-fb565f6d742a",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@hurryabit  ^^^",
        "createdAt" : "2020-02-05T13:37:57Z",
        "updatedAt" : "2020-02-06T14:50:14Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f74f3e8e-af50-4d75-bf39-d6d0307c0ef4",
        "parentId" : "32075f0f-2283-4b0e-8652-fb565f6d742a",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "This block assembles a single message; the client will get all this at once.",
        "createdAt" : "2020-06-18T18:00:30Z",
        "updatedAt" : "2020-06-18T18:00:31Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0eebf6edfa656f053fe4aa62ae2b225acfed08a5",
    "line" : 69,
    "diffHunk" : "@@ -50,66 +54,88 @@ object WebSocketService {\n       self leftMap (e => f(e.shows))\n   }\n \n-  private final case class StepAndErrors[+LfV](\n+  private final case class StepAndErrors[+Pos, +LfV](\n       errors: Seq[ServerError],\n-      step: InsertDeleteStep[domain.ActiveContract[LfV]]) {\n+      step: InsertDeleteStep[(domain.ActiveContract[LfV], Pos)]) {\n     import json.JsonProtocol._, spray.json._\n-    def render(implicit lfv: LfV <~< JsValue): JsValue = {\n-      def inj[V: JsonWriter](ctor: String) = (v: V) => JsObject(ctor -> v.toJson)\n+    def render(implicit lfv: LfV <~< JsValue, pos: Pos <~< Map[String, JsValue]): JsValue = {\n+      def inj[V: JsonWriter](ctor: String, v: V) = JsObject(ctor -> v.toJson)\n+      val thisw =\n+        Liskov.lift2[StepAndErrors, Pos, Map[String, JsValue], LfV, JsValue](pos, lfv)(this)\n       JsArray(\n-        step.deletes.iterator.map(inj(\"archived\")).toVector\n-          ++ Liskov.co[StepAndErrors, LfV, JsValue](lfv)(this).step.inserts.map(inj(\"created\"))\n-          ++ errors.map(inj[String](\"error\") compose (_.message)))\n+        step.deletes.iterator.map(inj(\"archived\", _)).toVector\n+          ++ thisw.step.inserts.map {\n+            case (ac, pos) =>\n+              val acj = inj(\"created\", ac)\n+              acj copy (fields = acj.fields ++ pos)\n+          } ++ errors.map(e => inj(\"error\", e.message)))"
  },
  {
    "id" : "ac337a2a-3764-4166-8122-8b1f9dfa333d",
    "prId" : 3936,
    "comments" : [
      {
        "id" : "4736692a-1d9a-4f69-8ae5-1904e11dbe3c",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "If you merge master, you can get it from `com.digitalasset.http.util.Collections.SeqOps#partitionMap`. I have borrowed it from here :)",
        "createdAt" : "2020-01-15T21:40:13Z",
        "updatedAt" : "2020-01-15T22:27:19Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a086e70-8bc0-406a-a15a-4163e16b9f94",
        "parentId" : "4736692a-1d9a-4f69-8ae5-1904e11dbe3c",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Used factoring in c3e5537e2aecde8437425b615b2f58a501c67967 ; thanks.",
        "createdAt" : "2020-01-15T22:48:25Z",
        "updatedAt" : "2020-01-15T22:48:26Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3e5537e2aecde8437425b615b2f58a501c67967",
    "line" : null,
    "diffHunk" : "@@ -9,51 +9,119 @@ import akka.stream.scaladsl.{Flow, Source}\n import akka.stream.Materializer\n import com.digitalasset.http.EndpointsCompanion._\n import com.digitalasset.http.domain.{GetActiveContractsRequest, JwtPayload}\n-import com.digitalasset.http.json.SprayJson.JsonReaderError\n import com.digitalasset.http.json.{DomainJsonDecoder, DomainJsonEncoder, SprayJson}\n+import SprayJson.JsonReaderError\n+import ContractsFetch.InsertDeleteStep\n+import com.digitalasset.http.LedgerClientJwt.Terminates\n+import util.ApiValueToLfValueConverter.apiValueToLfValue\n+import json.JsonProtocol.LfValueCodec.{apiValueToJsValue => lfValueToJsValue}\n+import query.ValuePredicate.LfV\n import com.digitalasset.jwt.domain.Jwt\n-import com.digitalasset.ledger.api.v1.transaction.Transaction\n import com.digitalasset.ledger.api.{v1 => api}\n-import com.digitalasset.ledger.client.binding.offset.LedgerOffsetOrdering\n-import com.digitalasset.ledger.client.services.transactions.TransactionClient\n+\n import com.typesafe.scalalogging.LazyLogging\n+import scalaz.Liskov.<~<\n import scalaz.syntax.show._\n+import scalaz.syntax.std.boolean._\n+import scalaz.syntax.tag._\n import scalaz.syntax.traverse._\n-import scalaz.{-\\/, \\/, \\/-}\n+import scalaz.{-\\/, \\/, \\/-, Show}\n import spray.json.{JsObject, JsString, JsValue}\n \n-import scala.collection.immutable.Set\n-import scala.concurrent.ExecutionContext\n+import scala.collection.SeqLike\n+import scala.concurrent.{ExecutionContext, Future}\n import scala.util.{Failure, Success}\n \n object WebSocketService {\n-  val heartBeat: String = JsObject(\"heartbeat\" -> JsString(\"ping\")).toString\n-  val emptyGetActiveContractsRequest = domain.GetActiveContractsRequest(Set.empty, Map.empty)\n-  private val numConns = new java.util.concurrent.atomic.AtomicInteger(0)\n+  private type CompiledQueries = Map[domain.TemplateId.RequiredPkg, LfV => Boolean]\n+  val heartBeat: String = JsObject(\"heartbeat\" -> JsString(\"ping\")).compactPrint\n+\n+  private implicit final class `\\\\/ WSS extras`[L, R](private val self: L \\/ R) extends AnyVal {\n+    def liftErr[M](f: String => M)(implicit L: Show[L]): M \\/ R =\n+      self leftMap (e => f(e.shows))\n+  }\n+\n+  private implicit final class `Seq WSS extras`[A, Self](private val self: SeqLike[A, Self])"
  },
  {
    "id" : "89f69d63-0535-42dd-9461-ba22420b1f67",
    "prId" : 3796,
    "comments" : [
      {
        "id" : "931b9f68-498a-4458-820e-41b7f64bfe64",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Please do not hardcode the `keepAlive` setting, pass it through the `wsConfig`",
        "createdAt" : "2019-12-11T20:51:45Z",
        "updatedAt" : "2019-12-11T21:29:33Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "de976ed59d6d521657884322490436c95dece760",
    "line" : 55,
    "diffHunk" : "@@ -0,0 +1,134 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http\n+\n+import akka.NotUsed\n+import akka.http.scaladsl.model.ws.{Message, TextMessage}\n+import akka.stream.scaladsl.{Flow, Source}\n+import akka.stream.Materializer\n+import com.digitalasset.http.EndpointsCompanion._\n+import com.digitalasset.http.domain.{GetActiveContractsRequest, JwtPayload}\n+import com.digitalasset.http.json.SprayJson.JsonReaderError\n+import com.digitalasset.http.json.{DomainJsonDecoder, DomainJsonEncoder, SprayJson}\n+import com.digitalasset.jwt.domain.Jwt\n+import com.digitalasset.ledger.api.v1.transaction.Transaction\n+import com.digitalasset.ledger.api.{v1 => api}\n+import com.digitalasset.ledger.client.binding.offset.LedgerOffsetOrdering\n+import com.digitalasset.ledger.client.services.transactions.TransactionClient\n+import com.typesafe.scalalogging.LazyLogging\n+import scalaz.syntax.show._\n+import scalaz.syntax.traverse._\n+import scalaz.{-\\/, \\/, \\/-}\n+import spray.json.{JsObject, JsString, JsValue}\n+\n+import scala.collection.immutable.Set\n+import scala.concurrent.ExecutionContext\n+import scala.util.{Failure, Success}\n+\n+object WebSocketService {\n+  val heartBeat: String = JsObject(\"heartbeat\" -> JsString(\"ping\")).toString\n+  val emptyGetActiveContractsRequest = domain.GetActiveContractsRequest(Set.empty, Map.empty)\n+  private val numConns = new java.util.concurrent.atomic.AtomicInteger(0)\n+}\n+\n+class WebSocketService(transactionClient: TransactionClient,\n+                       resolveTemplateIds: PackageService.ResolveTemplateIds,\n+                       encoder: DomainJsonEncoder,\n+                       decoder: DomainJsonDecoder,\n+                       wsConfig: WebsocketConfig)\n+                      (implicit mat: Materializer, ec: ExecutionContext) extends LazyLogging {\n+\n+  import WebSocketService._\n+  import com.digitalasset.http.json.JsonProtocol._\n+\n+  @SuppressWarnings(Array(\"org.wartremover.warts.NonUnitStatements\", \"org.wartremover.warts.JavaSerializable\"))\n+  private[http] def transactionMessageHandler(jwt: Jwt, jwtPayload: JwtPayload): Flow[Message, Message, _] = {\n+    import scala.concurrent.duration._\n+\n+    wsMessageHandler(jwt, jwtPayload)\n+      .takeWithin(wsConfig.maxDuration)\n+      .throttle(wsConfig.throttleElem,\n+                wsConfig.throttlePer,\n+                wsConfig.maxBurst,\n+                wsConfig.mode)\n+      .keepAlive(5.seconds, () => TextMessage.Strict(heartBeat))"
  },
  {
    "id" : "b8ef7789-d745-4994-a00c-f0390f06d489",
    "prId" : 3796,
    "comments" : [
      {
        "id" : "29b9c822-8ecd-48aa-81f6-627b1aa07a41",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "we probably don't want to consume all transactions from the very beginning all the time.",
        "createdAt" : "2019-12-11T21:04:30Z",
        "updatedAt" : "2019-12-11T21:29:33Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "38cbeab0-07a7-45d8-a062-03423ebdf780",
        "parentId" : "29b9c822-8ecd-48aa-81f6-627b1aa07a41",
        "author" : {
          "login" : "lima-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/54044170?u=8e4a52a939c52393e885bbbedc55fef26e05eb55&v=4"
        },
        "body" : "yeah, same thoughts on this too, (see TODO the comment), maybe we can wrap the client request message with offset input",
        "createdAt" : "2019-12-11T21:07:40Z",
        "updatedAt" : "2019-12-11T21:29:33Z",
        "lastEditedBy" : {
          "login" : "lima-da",
          "name" : null,
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/54044170?u=8e4a52a939c52393e885bbbedc55fef26e05eb55&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "de976ed59d6d521657884322490436c95dece760",
    "line" : 104,
    "diffHunk" : "@@ -0,0 +1,134 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http\n+\n+import akka.NotUsed\n+import akka.http.scaladsl.model.ws.{Message, TextMessage}\n+import akka.stream.scaladsl.{Flow, Source}\n+import akka.stream.Materializer\n+import com.digitalasset.http.EndpointsCompanion._\n+import com.digitalasset.http.domain.{GetActiveContractsRequest, JwtPayload}\n+import com.digitalasset.http.json.SprayJson.JsonReaderError\n+import com.digitalasset.http.json.{DomainJsonDecoder, DomainJsonEncoder, SprayJson}\n+import com.digitalasset.jwt.domain.Jwt\n+import com.digitalasset.ledger.api.v1.transaction.Transaction\n+import com.digitalasset.ledger.api.{v1 => api}\n+import com.digitalasset.ledger.client.binding.offset.LedgerOffsetOrdering\n+import com.digitalasset.ledger.client.services.transactions.TransactionClient\n+import com.typesafe.scalalogging.LazyLogging\n+import scalaz.syntax.show._\n+import scalaz.syntax.traverse._\n+import scalaz.{-\\/, \\/, \\/-}\n+import spray.json.{JsObject, JsString, JsValue}\n+\n+import scala.collection.immutable.Set\n+import scala.concurrent.ExecutionContext\n+import scala.util.{Failure, Success}\n+\n+object WebSocketService {\n+  val heartBeat: String = JsObject(\"heartbeat\" -> JsString(\"ping\")).toString\n+  val emptyGetActiveContractsRequest = domain.GetActiveContractsRequest(Set.empty, Map.empty)\n+  private val numConns = new java.util.concurrent.atomic.AtomicInteger(0)\n+}\n+\n+class WebSocketService(transactionClient: TransactionClient,\n+                       resolveTemplateIds: PackageService.ResolveTemplateIds,\n+                       encoder: DomainJsonEncoder,\n+                       decoder: DomainJsonDecoder,\n+                       wsConfig: WebsocketConfig)\n+                      (implicit mat: Materializer, ec: ExecutionContext) extends LazyLogging {\n+\n+  import WebSocketService._\n+  import com.digitalasset.http.json.JsonProtocol._\n+\n+  @SuppressWarnings(Array(\"org.wartremover.warts.NonUnitStatements\", \"org.wartremover.warts.JavaSerializable\"))\n+  private[http] def transactionMessageHandler(jwt: Jwt, jwtPayload: JwtPayload): Flow[Message, Message, _] = {\n+    import scala.concurrent.duration._\n+\n+    wsMessageHandler(jwt, jwtPayload)\n+      .takeWithin(wsConfig.maxDuration)\n+      .throttle(wsConfig.throttleElem,\n+                wsConfig.throttlePer,\n+                wsConfig.maxBurst,\n+                wsConfig.mode)\n+      .keepAlive(5.seconds, () => TextMessage.Strict(heartBeat))\n+      .watchTermination() {\n+        (_, future) =>\n+          numConns.incrementAndGet\n+          logger.info(s\"New websocket client has connected, current number of clients:$numConns\")\n+          future onComplete {\n+            case Success(_) =>\n+              numConns.decrementAndGet\n+              logger.info(s\"Websocket client has disconnected. Current number of clients: $numConns\")\n+            case Failure(ex) =>\n+              numConns.decrementAndGet\n+              logger.info(s\"Websocket client interrupted on Failure: ${ex.getMessage}. remaining number of clients: $numConns\")\n+          }\n+      }\n+  }\n+\n+  private def wsMessageHandler(jwt: Jwt, jwtPayload: JwtPayload): Flow[Message, Message, NotUsed] = {\n+    Flow[Message]\n+      .flatMapConcat {\n+        case msg: TextMessage.Strict => generateOutgoingMessage(jwt, jwtPayload, msg)\n+        case _ => Source.single(wsErrorMessage(\"Cannot process your input, Expect a single strict JSON message\"))\n+      }\n+  }\n+\n+  private def generateOutgoingMessage(jwt: Jwt, jwtPayload: JwtPayload, incoming: TextMessage.Strict): Source[Message, NotUsed] = {\n+    val maybeIncomingJs = SprayJson.parse(incoming.text).toOption\n+    parseActiveContractsRequest(maybeIncomingJs)\n+      .leftMap(e => InvalidUserInput(e.shows)) match {\n+      case \\/-(req) => getTransactionSourceForParty(jwt, jwtPayload, req)\n+      case -\\/(e) => Source.single(wsErrorMessage(s\"Error happend parsing your input message to a valid Json request: $e\"))\n+    }\n+  }\n+\n+  private def parseActiveContractsRequest(\n+                                           incoming: Option[JsValue]\n+                                         ): SprayJson.JsonReaderError \\/ GetActiveContractsRequest = {\n+    incoming match {\n+      case Some(JsObject.empty) => \\/-(emptyGetActiveContractsRequest)\n+      case Some(jsObj) => SprayJson.decode[GetActiveContractsRequest](jsObj)\n+      case None => -\\/(JsonReaderError(\"None\", \"please send a valid json request\"))\n+    }\n+  }\n+\n+  private def getTransactionSourceForParty(jwt: Jwt, jwtPayload: JwtPayload, request: GetActiveContractsRequest): Source[Message, NotUsed] = {\n+    import com.digitalasset.http.util.Transactions._\n+\n+    resolveTemplateIds(request.templateIds) match {\n+      case \\/-(ids) =>\n+        val filter = transactionFilterFor(jwtPayload.party, ids)\n+        transactionClient.getTransactions(LedgerOffsetOrdering.ledgerBegin, None, transactionFilter = filter) // TODO: make offSet pass along with client message"
  },
  {
    "id" : "97da6478-80ef-443f-9698-aa93bcf22798",
    "prId" : 3796,
    "comments" : [
      {
        "id" : "0e9a8e3b-cf49-4e81-8cb2-03a0e1dcc34a",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "Please use `spray.json.JsValue#compactPrint` instead of `toString`",
        "createdAt" : "2019-12-11T21:05:14Z",
        "updatedAt" : "2019-12-11T21:29:33Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "197895ef-90ed-4bf7-a7a4-72451647b0a0",
        "parentId" : "0e9a8e3b-cf49-4e81-8cb2-03a0e1dcc34a",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "this is probably a question for @bame-da\r\nwe currently don't do any API Transaction cleanup, we serialize `com.digitalasset.ledger.api.v1.transaction.Transaction` to JSON as is. The JSON is going to be very noisy.\r\nIn any case if decide to clean it up, it should be done in a separate PR.",
        "createdAt" : "2019-12-11T21:13:53Z",
        "updatedAt" : "2019-12-11T21:29:33Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "de976ed59d6d521657884322490436c95dece760",
    "line" : 108,
    "diffHunk" : "@@ -0,0 +1,134 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.http\n+\n+import akka.NotUsed\n+import akka.http.scaladsl.model.ws.{Message, TextMessage}\n+import akka.stream.scaladsl.{Flow, Source}\n+import akka.stream.Materializer\n+import com.digitalasset.http.EndpointsCompanion._\n+import com.digitalasset.http.domain.{GetActiveContractsRequest, JwtPayload}\n+import com.digitalasset.http.json.SprayJson.JsonReaderError\n+import com.digitalasset.http.json.{DomainJsonDecoder, DomainJsonEncoder, SprayJson}\n+import com.digitalasset.jwt.domain.Jwt\n+import com.digitalasset.ledger.api.v1.transaction.Transaction\n+import com.digitalasset.ledger.api.{v1 => api}\n+import com.digitalasset.ledger.client.binding.offset.LedgerOffsetOrdering\n+import com.digitalasset.ledger.client.services.transactions.TransactionClient\n+import com.typesafe.scalalogging.LazyLogging\n+import scalaz.syntax.show._\n+import scalaz.syntax.traverse._\n+import scalaz.{-\\/, \\/, \\/-}\n+import spray.json.{JsObject, JsString, JsValue}\n+\n+import scala.collection.immutable.Set\n+import scala.concurrent.ExecutionContext\n+import scala.util.{Failure, Success}\n+\n+object WebSocketService {\n+  val heartBeat: String = JsObject(\"heartbeat\" -> JsString(\"ping\")).toString\n+  val emptyGetActiveContractsRequest = domain.GetActiveContractsRequest(Set.empty, Map.empty)\n+  private val numConns = new java.util.concurrent.atomic.AtomicInteger(0)\n+}\n+\n+class WebSocketService(transactionClient: TransactionClient,\n+                       resolveTemplateIds: PackageService.ResolveTemplateIds,\n+                       encoder: DomainJsonEncoder,\n+                       decoder: DomainJsonDecoder,\n+                       wsConfig: WebsocketConfig)\n+                      (implicit mat: Materializer, ec: ExecutionContext) extends LazyLogging {\n+\n+  import WebSocketService._\n+  import com.digitalasset.http.json.JsonProtocol._\n+\n+  @SuppressWarnings(Array(\"org.wartremover.warts.NonUnitStatements\", \"org.wartremover.warts.JavaSerializable\"))\n+  private[http] def transactionMessageHandler(jwt: Jwt, jwtPayload: JwtPayload): Flow[Message, Message, _] = {\n+    import scala.concurrent.duration._\n+\n+    wsMessageHandler(jwt, jwtPayload)\n+      .takeWithin(wsConfig.maxDuration)\n+      .throttle(wsConfig.throttleElem,\n+                wsConfig.throttlePer,\n+                wsConfig.maxBurst,\n+                wsConfig.mode)\n+      .keepAlive(5.seconds, () => TextMessage.Strict(heartBeat))\n+      .watchTermination() {\n+        (_, future) =>\n+          numConns.incrementAndGet\n+          logger.info(s\"New websocket client has connected, current number of clients:$numConns\")\n+          future onComplete {\n+            case Success(_) =>\n+              numConns.decrementAndGet\n+              logger.info(s\"Websocket client has disconnected. Current number of clients: $numConns\")\n+            case Failure(ex) =>\n+              numConns.decrementAndGet\n+              logger.info(s\"Websocket client interrupted on Failure: ${ex.getMessage}. remaining number of clients: $numConns\")\n+          }\n+      }\n+  }\n+\n+  private def wsMessageHandler(jwt: Jwt, jwtPayload: JwtPayload): Flow[Message, Message, NotUsed] = {\n+    Flow[Message]\n+      .flatMapConcat {\n+        case msg: TextMessage.Strict => generateOutgoingMessage(jwt, jwtPayload, msg)\n+        case _ => Source.single(wsErrorMessage(\"Cannot process your input, Expect a single strict JSON message\"))\n+      }\n+  }\n+\n+  private def generateOutgoingMessage(jwt: Jwt, jwtPayload: JwtPayload, incoming: TextMessage.Strict): Source[Message, NotUsed] = {\n+    val maybeIncomingJs = SprayJson.parse(incoming.text).toOption\n+    parseActiveContractsRequest(maybeIncomingJs)\n+      .leftMap(e => InvalidUserInput(e.shows)) match {\n+      case \\/-(req) => getTransactionSourceForParty(jwt, jwtPayload, req)\n+      case -\\/(e) => Source.single(wsErrorMessage(s\"Error happend parsing your input message to a valid Json request: $e\"))\n+    }\n+  }\n+\n+  private def parseActiveContractsRequest(\n+                                           incoming: Option[JsValue]\n+                                         ): SprayJson.JsonReaderError \\/ GetActiveContractsRequest = {\n+    incoming match {\n+      case Some(JsObject.empty) => \\/-(emptyGetActiveContractsRequest)\n+      case Some(jsObj) => SprayJson.decode[GetActiveContractsRequest](jsObj)\n+      case None => -\\/(JsonReaderError(\"None\", \"please send a valid json request\"))\n+    }\n+  }\n+\n+  private def getTransactionSourceForParty(jwt: Jwt, jwtPayload: JwtPayload, request: GetActiveContractsRequest): Source[Message, NotUsed] = {\n+    import com.digitalasset.http.util.Transactions._\n+\n+    resolveTemplateIds(request.templateIds) match {\n+      case \\/-(ids) =>\n+        val filter = transactionFilterFor(jwtPayload.party, ids)\n+        transactionClient.getTransactions(LedgerOffsetOrdering.ledgerBegin, None, transactionFilter = filter) // TODO: make offSet pass along with client message\n+          .via(Flow[Transaction].filter(_.events.nonEmpty))\n+          .map(tx => {\n+            lfVToJson(tx) match {\n+              case \\/-(a) => TextMessage(JsObject(\"transaction\" -> a).toString)"
  }
]