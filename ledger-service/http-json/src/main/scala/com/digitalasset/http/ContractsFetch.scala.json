[
  {
    "id" : "6eaf8365-1646-4328-9b0a-5bbefd065e0a",
    "prId" : 7571,
    "comments" : [
      {
        "id" : "eff31dab-2104-400b-b308-d8826d73f785",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    TransactionFilter(domain.Party.unsubst(parties.iterator).map(_ -> filters).toMap)\r\n```",
        "createdAt" : "2020-10-05T17:42:01Z",
        "updatedAt" : "2020-10-08T11:09:12Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6489aaa0d5262d62016575dbcf3ca97582f3a81b",
    "line" : null,
    "diffHunk" : "@@ -459,6 +459,6 @@ private[http] object ContractsFetch {\n       if (templateIds.isEmpty) Filters.defaultInstance\n       else Filters(Some(lav1.transaction_filter.InclusiveFilters(templateIds.map(apiIdentifier))))\n \n-    TransactionFilter(Map(domain.Party.unwrap(party) -> filters))\n+    TransactionFilter(Map(parties.map(party => domain.Party.unwrap(party) -> filters).toList: _*))"
  },
  {
    "id" : "7fa53e6b-72f0-427e-9793-e730f3a8bcef",
    "prId" : 3989,
    "comments" : [
      {
        "id" : "3c78b4b9-94ea-482c-bac0-d97a3a9b76a9",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      lfKey <- ac.key traverse apiValueToLfValue leftMap (_.cause)\r\n```",
        "createdAt" : "2020-01-08T18:58:30Z",
        "updatedAt" : "2020-01-08T20:11:25Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c57194ca7e9f87b066bfe8f660305f1432b3c3c6",
    "line" : null,
    "diffHunk" : "@@ -111,13 +111,21 @@ private class ContractsFetch(\n     for {\n       ac <- domain.ActiveContract fromLedgerApi ce leftMap (de =>\n         new IllegalArgumentException(s\"contract ${ce.contractId}: ${de.shows}\"))\n+      lfKey <- ac.key.cata("
  },
  {
    "id" : "438ebeab-4614-46c0-baf4-60c6146679af",
    "prId" : 3625,
    "comments" : [
      {
        "id" : "798a4a57-29bd-4897-aea6-74a2ce8508d1",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Because working GADTs are too much to ask for\r\n\r\n```suggestion\r\n      appendWithCid(o)(Liskov.contra1_2[Function1, DBContract[Any, Any, Any], CC, String](cid)(_.contractId))\r\n```",
        "createdAt" : "2019-11-27T20:13:41Z",
        "updatedAt" : "2019-11-27T21:08:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72c61b6ab18acd715e0035a6e7fa5ec50a7dd08b",
    "line" : null,
    "diffHunk" : "@@ -382,9 +382,12 @@ private object ContractsFetch {\n   final case class InsertDeleteStep[+C](inserts: Vector[C], deletes: Set[String]) {\n     def append[CC >: C](o: InsertDeleteStep[CC])(\n         implicit cid: CC <~< DBContract[Any, Any, Any]): InsertDeleteStep[CC] =\n+      appendWithCid(o)(x => cid(x).contractId)"
  },
  {
    "id" : "061b1faa-3929-4e4b-85d1-3405db7b2f67",
    "prId" : 3625,
    "comments" : [
      {
        "id" : "9c62d00f-8490-421a-a632-bf992ad09729",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    def appendWithCid[CC >: C](o: InsertDeleteStep[CC])(cid: CC => String): InsertDeleteStep[CC] =\r\n```",
        "createdAt" : "2019-11-27T20:14:28Z",
        "updatedAt" : "2019-11-27T21:08:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72c61b6ab18acd715e0035a6e7fa5ec50a7dd08b",
    "line" : null,
    "diffHunk" : "@@ -382,9 +382,12 @@ private object ContractsFetch {\n   final case class InsertDeleteStep[+C](inserts: Vector[C], deletes: Set[String]) {\n     def append[CC >: C](o: InsertDeleteStep[CC])(\n         implicit cid: CC <~< DBContract[Any, Any, Any]): InsertDeleteStep[CC] =\n+      appendWithCid(o)(x => cid(x).contractId)\n+\n+    def appendWithCid[CC >: C](o: InsertDeleteStep[CC])(cid: C => String): InsertDeleteStep[CC] ="
  },
  {
    "id" : "4e2db663-9d0a-404c-b2b3-eac6b5ae783e",
    "prId" : 3425,
    "comments" : [
      {
        "id" : "4112d807-3a10-45ab-b24f-929bc823e1ed",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n          connection.raiseError(e)\r\n```",
        "createdAt" : "2019-11-11T21:02:24Z",
        "updatedAt" : "2019-11-12T18:57:26Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9dc62b2aba0c9d4c197e1df63834edb315bfbe80",
    "line" : null,
    "diffHunk" : "@@ -62,6 +62,28 @@ private class ContractsFetch(\n   }\n \n   def contractsIo(jwt: Jwt, party: domain.Party, templateId: domain.TemplateId.RequiredPkg)(\n+      implicit ec: ExecutionContext,\n+      mat: Materializer): ConnectionIO[OffsetBookmark[domain.Offset]] = {\n+\n+    import doobie.postgres._\n+    import doobie.implicits._\n+\n+    def loop(maxAttempts: Int): ConnectionIO[OffsetBookmark[domain.Offset]] = {\n+      logger.debug(s\"contractsIo, maxAttempts: $maxAttempts\")\n+      contractsIo_(jwt, party, templateId).exceptSql {\n+        case e if maxAttempts > 0 && e.getSQLState == sqlstate.class23.UNIQUE_VIOLATION.value =>\n+          logger.debug(s\"contractsIo, exception: ${e.getMessage}, state: ${e.getSQLState}\")\n+          connection.rollback flatMap (_ => loop(maxAttempts - 1))\n+        case e @ _ =>\n+          logger.error(s\"contractsIo3 exception: ${e.getMessage}, state: ${e.getSQLState}\")\n+          throw new IllegalStateException(\"Cannot perform contractsIo\", e)"
  },
  {
    "id" : "0c4b980c-482a-4e54-9cc2-f9db58d51839",
    "prId" : 3425,
    "comments" : [
      {
        "id" : "77f0d387-a44d-48e9-a59d-252dfd06382e",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "A uniqueness violation is not the only form of failure we should retry. For example, if two concurrent transactions attempt to change the offset (which was read at beginning of transaction) to different values, that should be retried as well.",
        "createdAt" : "2019-11-11T21:05:11Z",
        "updatedAt" : "2019-11-12T18:57:26Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8fbdd424-7132-4e94-a33a-35ac4a8e1365",
        "parentId" : "77f0d387-a44d-48e9-a59d-252dfd06382e",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "this is being caught by checking the number of rows updated by:\r\n```\r\nsql\"\"\"UPDATE ledger_offset SET last_offset = $newOffset where ... AND last_offset = $lastOffset\"\"\"\r\n```",
        "createdAt" : "2019-11-12T18:55:35Z",
        "updatedAt" : "2019-11-12T18:57:26Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9dc62b2aba0c9d4c197e1df63834edb315bfbe80",
    "line" : null,
    "diffHunk" : "@@ -62,6 +62,28 @@ private class ContractsFetch(\n   }\n \n   def contractsIo(jwt: Jwt, party: domain.Party, templateId: domain.TemplateId.RequiredPkg)(\n+      implicit ec: ExecutionContext,\n+      mat: Materializer): ConnectionIO[OffsetBookmark[domain.Offset]] = {\n+\n+    import doobie.postgres._\n+    import doobie.implicits._\n+\n+    def loop(maxAttempts: Int): ConnectionIO[OffsetBookmark[domain.Offset]] = {\n+      logger.debug(s\"contractsIo, maxAttempts: $maxAttempts\")\n+      contractsIo_(jwt, party, templateId).exceptSql {\n+        case e if maxAttempts > 0 && e.getSQLState == sqlstate.class23.UNIQUE_VIOLATION.value =>"
  }
]