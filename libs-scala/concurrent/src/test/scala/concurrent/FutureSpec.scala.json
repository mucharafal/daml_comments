[
  {
    "id" : "fa234325-1f1a-47e6-a50e-88324a2e8ed8",
    "prId" : 7347,
    "comments" : [
      {
        "id" : "13187dbb-716c-4004-9d9f-ac216537c478",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "If anyone wants `Future[Cat, Int]` from `sc.Future[Int]`, they should convert it explicitly.\r\nWhat I mean is ```com.daml.concurrent.FutureOf#`future is any` ``` should not exist. I would prefer an explicit converter in the `com.daml.concurrent.FutureOf.Ops`.",
        "createdAt" : "2020-09-16T21:18:49Z",
        "updatedAt" : "2020-09-16T21:34:07Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "411c1bc5-5ced-42ca-8a1b-a6b4922e634d",
        "parentId" : "13187dbb-716c-4004-9d9f-ac216537c478",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Already mentioned this in the previous thread, but https://github.com/digital-asset/daml/pull/7347#discussion_r489001143 for this PR.\r\n\r\nBut since you mentioned it again, I thought I would write down the case for not bothering with an explicit converter:\r\n\r\nThe analogy with Scala vs Java collections is faulty in important ways. That is because there are no operational differences between dc.Futures (the ones here) and sc.Futures, which is not true of, say, java.util.List vs scala.collection.mutable.Buffer (or any other choice you may have). You can view the subtyping hierarchy of ExecutionContext as follows:\r\n\r\n```\r\n            sc.ExecutionContext\r\n                     |\r\n                     |\r\n          dc.ExecutionContext[Any]\r\n                /           \\\r\n               /             \\\r\ndc.ExecutionContext[<complete *-kinded type lattice>]\r\n               \\             /\r\n                \\           /\r\n        dc.ExecutionContext[Nothing]\r\n```\r\n\r\nComparably, *structurally*, the only difference between an sc.Future and dc.Future is which subset of the above types you accept as a context argument:\r\n\r\n```\r\n          dc.Future[Nothing]\r\n            /           \\\r\n           /             \\\r\ndc.Future[<inverted *-kinded type lattice>]\r\n           \\             /\r\n            \\           /\r\n            dc.Future[Any]\r\n                  |\r\n                  |\r\n              sc.Future\r\n```\r\n\r\n(more specific types are lower, wider types are higher, for both graphs)\r\n\r\nWith the top of the Future hierarchy accepting only the bottom of the ExecutionContext hierarchy, each more specific Future accepting a broader, less specific set of ExecutionContexts, until you reach dc.Future[Any] which accepts any dc.ExecutionContext, and then finally the bottom of the Future hierarchy, which is the only one that accepts the top of the ExecutionContext hierarchy (and indeed all other ExecutionContexts).\r\n\r\nExplicit conversion barriers between Scala collections and Java collections, or Scala futures and Java futures for that matter, are desirable because they cannot have a relationship meeting the Liskov Substitution Principle.  They have different dynamic behavior, so neither can be a substitute for the other, i.e. there exist functions on each that simply do not work on the other.\r\n\r\nBy contrast, _all_ functions that operate on a dc.Future[..., T] argument are also functions that operate on a sc.Future argument in the exact same way; LSP holds, there are no dynamic behavior differences at all, and the only difference is the type of ExecutionContext it accepts (which is a contravariant position).\r\n\r\nHonestly I tried to actually reify this type relationship directly in Scala, but the specifics were too tricky to immediately resolve. It is worth further noting, however, that whereas `ScalaConversions` require fancy wrappers (which may have bugs) with special runtime characteristics of their own, the conversion here literally does nothing. That is what you'd expect, given that there is nothing about reifying the type relationship that would cause any particular problems for implementation.\r\n\r\nIt being that an implicit conversion that does nothing is significantly less likely to cause trouble than one that does something, I'd like to see whether it actually causes any problems in practice before assuming it does and adding burdens to anyone who might want to try porting sc.Future code to interact with dc.Futures.",
        "createdAt" : "2020-09-16T22:04:54Z",
        "updatedAt" : "2020-09-16T22:07:32Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b44f34ca-c4ea-42c8-9243-14d46b603456",
        "parentId" : "13187dbb-716c-4004-9d9f-ac216537c478",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "~Correct me if I am wrong. The goal of this entire exercise was to make choosing `ExecutionContext` more explicit. The implicit conversion makes it possible to pass `dc.Future[Cat, Int]` into a method that expects `sc.Future[Int]`. And this whole type safety goes away unnoticed by the compiler. You are making it easier for the programmer to make a mistake.~\r\n\r\nscratch it.\r\n",
        "createdAt" : "2020-09-17T14:06:24Z",
        "updatedAt" : "2020-09-17T14:10:44Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4bb8680b-a85e-4edc-afa5-a0306678a74c",
        "parentId" : "13187dbb-716c-4004-9d9f-ac216537c478",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "it is not exactly like this, it is opposite you can stick an 'untyped' `sc.Future[Int]` into a method that expects `dc.Future[Cat, Int]` and the compiler will not notice this and execute this `sc.Future[Int]` in the `dc.ExecutionContext[Cat]` which might be not describable. ",
        "createdAt" : "2020-09-17T14:14:17Z",
        "updatedAt" : "2020-09-17T14:14:22Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "21ccd437-eee8-4663-89c7-63ffaf4fb757",
        "parentId" : "13187dbb-716c-4004-9d9f-ac216537c478",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "`sc.Future[Int]`'s type says it can be run by any `ExecutionContext`. `dc.ExecutionContext[Cat]` is a member of that set.",
        "createdAt" : "2020-09-17T14:44:20Z",
        "updatedAt" : "2020-09-17T14:44:20Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "57c0cf34-0d68-485d-bef1-dbde9037cf41",
        "parentId" : "13187dbb-716c-4004-9d9f-ac216537c478",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "That is to say, you are correct in that you might not desire to execute that sc.Future against *that* ExecutionContext, despite its type saying that it is okay. But that is why I want to make it as easy as possible to get sc.Futures *into* the dc.Future hierarchy that is placed above it in the type hierarchy; a sc.Future is already a failure of typing in this way, so we might as well ease its transition into a more precisely typed form (which, ironically, has a less specific type, in accordance with the contravariance rule) that *can* be sufficiently specific.",
        "createdAt" : "2020-09-17T14:48:47Z",
        "updatedAt" : "2020-09-17T14:54:16Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4ca24fa2-d524-41f6-a644-d50c4f9b8d8b",
        "parentId" : "13187dbb-716c-4004-9d9f-ac216537c478",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I'd be happy to make the conversions more explicit once we've migrated chunks of the code over and understand this a little more. Right now I want it to be easy to flip back and forth as necessary so I can just use it in one file.",
        "createdAt" : "2020-09-17T15:05:02Z",
        "updatedAt" : "2020-09-17T15:05:02Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "215cb66944783011dae3fbe6053a47d8e858ab4f",
    "line" : 35,
    "diffHunk" : "@@ -0,0 +1,81 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.concurrent\n+\n+import scala.{concurrent => sc}\n+\n+import com.github.ghik.silencer.silent\n+import org.scalatest.{WordSpec, Matchers}\n+import shapeless.test.illTyped\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.NonUnitStatements\"))\n+@silent(\"local method example\")\n+class FutureSpec extends WordSpec with Matchers {\n+  import ExecutionContextSpec._\n+\n+  val elephantVal = 3000\n+  val catVal = 9\n+  val untypedVal = -1\n+\n+  val someElephantFuture: Future[Elephant, Int] = sc.Future successful elephantVal\n+  val someCatFuture: Future[Cat, Int] = sc.Future successful catVal\n+  val someUntypedFuture: sc.Future[Int] = sc.Future successful untypedVal\n+\n+  // we repeat imports below to show exactly what imports are needed for a given\n+  // scenario.  Naturally, in real code, you would not be so repetitive.\n+\n+  \"an untyped future\" can {\n+    \"be flatmapped to by any future\" in {\n+      import scalaz.syntax.bind._, TestImplicits.Elephant\n+      def example = someElephantFuture flatMap (_ => someUntypedFuture)\n+    }\n+\n+    \"simply become a typed future\" in {\n+      def example: Future[Cat, Int] = someUntypedFuture"
  }
]