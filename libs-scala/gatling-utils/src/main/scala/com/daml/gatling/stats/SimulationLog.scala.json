[
  {
    "id" : "727ee835-d88c-4dfc-94b0-8b0dfddd388a",
    "prId" : 7325,
    "comments" : [
      {
        "id" : "b6a1f73e-d12c-4924-8a19-b20ff5c1f619",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "The instance is unlawful as written, because in the min semigroup, `None < Some(a)` for all _a_, but you have declared `None` to be your monoid's zero. Instead, you want the Min applied directly to Duration, then lifted into the option monoid:\r\n\r\n```suggestion\r\n            Tag.unsubst(Tags.Min.subst(s1.start) |+| Tags.Min.subst(s2.start)),\r\n            Tag.unsubst(Tags.Max.subst(s1.end) |+| Tags.Max.subst(s2.end))\r\n```\r\n\r\nIn other words you want to append two `Option[Duration @@ Tags.Min]`, _not_ two `Option[Duration] @@ Tags.Min`.\r\n\r\nYou may find it more expedient to simply leave the `@@ Tags.Min` and max in the correct place in the declaration of `DurationStatistics`; do whichever is more convenient.",
        "createdAt" : "2020-09-09T21:16:41Z",
        "updatedAt" : "2020-09-11T13:32:14Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4c9440e652dd2c98b104ede6120ec76fc9f35173",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,273 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+// Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates.\n+// All rights reserved.\n+\n+package com.daml.gatling.stats\n+\n+import java.io.File\n+\n+import scalaz._\n+import Scalaz._\n+\n+import scala.collection.immutable.ListMap\n+import com.daml.gatling.stats.util.NonEmptySyntax._\n+import com.daml.gatling.stats.util.ReadFileSyntax._\n+import com.daml.gatling.stats.OutputFormattingHelpers._\n+\n+import SimulationLog._\n+\n+case class SimulationLog(simulation: String, scenarios: List[ScenarioStats]) {\n+  import Scalaz._\n+\n+  lazy val requestsByType: Map[String, RequestTypeStats] =\n+    scenarios.foldRight(Map.empty[String, RequestTypeStats])(_.requestsByType |+| _)\n+\n+  def toCsvString: String =\n+    toCsv\n+      .foldRight(Option.empty[Seq[String]]) { (row, result) =>\n+        result\n+          .orElse(List(row.keys.mkString(\",\")).some)\n+          .map(_ :+ row.values.map(_.toString.filterNot(_ == ',')).mkString(\",\"))\n+      }\n+      .map(_.mkString(\"\", System.lineSeparator(), System.lineSeparator()))\n+      .getOrElse(\"\")\n+\n+  private def toCsv: List[ListMap[String, String]] = {\n+    scenarios\n+      .flatMap { scenario =>\n+        scenario.requestsByType.map {\n+          case (requestType, stats) =>\n+            ListMap(\n+              \"simulation\" -> simulation.toString,\n+              \"scenario\" -> scenario.label,\n+              \"maxUsers\" -> scenario.maxUsers.toString,\n+              \"request\" -> requestType,\n+              \"start\" -> format(stats.successful.start),\n+              \"duration\" -> format(stats.successful.duration.map(_.toDouble / 1000)),\n+              \"end\" -> format(stats.successful.end),\n+              \"count\" -> stats.count.toString,\n+              \"successCount\" -> stats.successful.count.toString,\n+              \"errorCount\" -> stats.failed.count.toString,\n+              \"min\" -> format(stats.successful.percentile(0.0)),\n+              \"p90\" -> format(stats.successful.percentile(0.9)),\n+              \"p95\" -> format(stats.successful.percentile(0.95)),\n+              \"p99\" -> format(stats.successful.percentile(0.99)),\n+              \"p999\" -> format(stats.successful.percentile(0.999)),\n+              \"max\" -> format(stats.successful.percentile(1.0)),\n+              \"mean\" -> format(stats.successful.geometricMean.map(math.round)),\n+              \"avg\" -> format(stats.successful.mean.map(math.round)),\n+              \"stddev\" -> format(stats.successful.stdDev.map(math.round)),\n+              \"rps\" -> format(stats.successful.requestsPerSecond)\n+            )\n+        }\n+      }\n+  }\n+}\n+\n+object SimulationLog {\n+  type Timestamp = Long\n+\n+  private def format[A: Numeric: Show](fa: Option[A]): String = {\n+    import scalaz.syntax.show._\n+    val num = implicitly[Numeric[A]]\n+    val zero: A = num.fromInt(0)\n+    fa.getOrElse(zero).shows\n+  }\n+\n+  case class ScenarioStats(\n+      label: String,\n+      maxUsers: Int = 0,\n+      requestsByType: Map[String, RequestTypeStats] = Map.empty)\n+\n+  case class DurationStatistics(\n+      durations: Seq[Int],\n+      start: Option[Timestamp],\n+      end: Option[Timestamp]) {\n+    def count: Int = durations.size\n+    def mean: Option[Double] = durations.nonEmptyOpt.map(ds => ds.sum.toDouble / ds.size)\n+    def geometricMean: Option[Double] =\n+      durations.nonEmptyOpt.map(ds => math.exp(ds.map(d => math.log(d.toDouble)).sum / ds.size))\n+    def duration: Option[Int] = for { s <- start; e <- end } yield (e - s).toInt\n+    def requestsPerSecond: Option[Double] = duration.map(count.toDouble / _.toDouble * 1000)\n+\n+    def stdDev: Option[Double] =\n+      for {\n+        avg <- mean\n+        variance <- durations.nonEmptyOpt.map(ds => ds.map(d => math.pow(d - avg, 2)).sum / ds.size)\n+      } yield math.sqrt(variance)\n+\n+    def percentile(p: Double): Option[Int] = {\n+      require(p >= 0.0 && p <= 1.0, \"Percentile must be between zero and one, inclusive.\")\n+      sortedDurations.nonEmptyOpt.map(ds => ds(Math.round((ds.size - 1).toDouble * p).toInt))\n+    }\n+\n+    private lazy val sortedDurations = durations.toIndexedSeq.sorted\n+  }\n+\n+  object DurationStatistics {\n+    implicit val durationStatisticsMonoid: Monoid[DurationStatistics] =\n+      new Monoid[DurationStatistics] {\n+        override def zero: DurationStatistics = DurationStatistics(Seq.empty, None, None)\n+\n+        override def append(s1: DurationStatistics, s2: => DurationStatistics): DurationStatistics =\n+          DurationStatistics(\n+            s1.durations ++ s2.durations,\n+            Tag.unwrap(Tags.Min(s1.start) |+| Tags.Min(s2.start)),\n+            Tag.unwrap(Tags.Max(s1.end) |+| Tags.Max(s2.end))"
  },
  {
    "id" : "e5e9cd57-53f5-4720-95f1-ced8a6372168",
    "prId" : 7325,
    "comments" : [
      {
        "id" : "535395ad-0af7-44d1-b080-dd17dfa2df6c",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n        .collect { case rowType +: fields => rowType -> fields }\r\n```",
        "createdAt" : "2020-09-09T21:17:35Z",
        "updatedAt" : "2020-09-11T13:32:14Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4c9440e652dd2c98b104ede6120ec76fc9f35173",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,273 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+// Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates.\n+// All rights reserved.\n+\n+package com.daml.gatling.stats\n+\n+import java.io.File\n+\n+import scalaz._\n+import Scalaz._\n+\n+import scala.collection.immutable.ListMap\n+import com.daml.gatling.stats.util.NonEmptySyntax._\n+import com.daml.gatling.stats.util.ReadFileSyntax._\n+import com.daml.gatling.stats.OutputFormattingHelpers._\n+\n+import SimulationLog._\n+\n+case class SimulationLog(simulation: String, scenarios: List[ScenarioStats]) {\n+  import Scalaz._\n+\n+  lazy val requestsByType: Map[String, RequestTypeStats] =\n+    scenarios.foldRight(Map.empty[String, RequestTypeStats])(_.requestsByType |+| _)\n+\n+  def toCsvString: String =\n+    toCsv\n+      .foldRight(Option.empty[Seq[String]]) { (row, result) =>\n+        result\n+          .orElse(List(row.keys.mkString(\",\")).some)\n+          .map(_ :+ row.values.map(_.toString.filterNot(_ == ',')).mkString(\",\"))\n+      }\n+      .map(_.mkString(\"\", System.lineSeparator(), System.lineSeparator()))\n+      .getOrElse(\"\")\n+\n+  private def toCsv: List[ListMap[String, String]] = {\n+    scenarios\n+      .flatMap { scenario =>\n+        scenario.requestsByType.map {\n+          case (requestType, stats) =>\n+            ListMap(\n+              \"simulation\" -> simulation.toString,\n+              \"scenario\" -> scenario.label,\n+              \"maxUsers\" -> scenario.maxUsers.toString,\n+              \"request\" -> requestType,\n+              \"start\" -> format(stats.successful.start),\n+              \"duration\" -> format(stats.successful.duration.map(_.toDouble / 1000)),\n+              \"end\" -> format(stats.successful.end),\n+              \"count\" -> stats.count.toString,\n+              \"successCount\" -> stats.successful.count.toString,\n+              \"errorCount\" -> stats.failed.count.toString,\n+              \"min\" -> format(stats.successful.percentile(0.0)),\n+              \"p90\" -> format(stats.successful.percentile(0.9)),\n+              \"p95\" -> format(stats.successful.percentile(0.95)),\n+              \"p99\" -> format(stats.successful.percentile(0.99)),\n+              \"p999\" -> format(stats.successful.percentile(0.999)),\n+              \"max\" -> format(stats.successful.percentile(1.0)),\n+              \"mean\" -> format(stats.successful.geometricMean.map(math.round)),\n+              \"avg\" -> format(stats.successful.mean.map(math.round)),\n+              \"stddev\" -> format(stats.successful.stdDev.map(math.round)),\n+              \"rps\" -> format(stats.successful.requestsPerSecond)\n+            )\n+        }\n+      }\n+  }\n+}\n+\n+object SimulationLog {\n+  type Timestamp = Long\n+\n+  private def format[A: Numeric: Show](fa: Option[A]): String = {\n+    import scalaz.syntax.show._\n+    val num = implicitly[Numeric[A]]\n+    val zero: A = num.fromInt(0)\n+    fa.getOrElse(zero).shows\n+  }\n+\n+  case class ScenarioStats(\n+      label: String,\n+      maxUsers: Int = 0,\n+      requestsByType: Map[String, RequestTypeStats] = Map.empty)\n+\n+  case class DurationStatistics(\n+      durations: Seq[Int],\n+      start: Option[Timestamp],\n+      end: Option[Timestamp]) {\n+    def count: Int = durations.size\n+    def mean: Option[Double] = durations.nonEmptyOpt.map(ds => ds.sum.toDouble / ds.size)\n+    def geometricMean: Option[Double] =\n+      durations.nonEmptyOpt.map(ds => math.exp(ds.map(d => math.log(d.toDouble)).sum / ds.size))\n+    def duration: Option[Int] = for { s <- start; e <- end } yield (e - s).toInt\n+    def requestsPerSecond: Option[Double] = duration.map(count.toDouble / _.toDouble * 1000)\n+\n+    def stdDev: Option[Double] =\n+      for {\n+        avg <- mean\n+        variance <- durations.nonEmptyOpt.map(ds => ds.map(d => math.pow(d - avg, 2)).sum / ds.size)\n+      } yield math.sqrt(variance)\n+\n+    def percentile(p: Double): Option[Int] = {\n+      require(p >= 0.0 && p <= 1.0, \"Percentile must be between zero and one, inclusive.\")\n+      sortedDurations.nonEmptyOpt.map(ds => ds(Math.round((ds.size - 1).toDouble * p).toInt))\n+    }\n+\n+    private lazy val sortedDurations = durations.toIndexedSeq.sorted\n+  }\n+\n+  object DurationStatistics {\n+    implicit val durationStatisticsMonoid: Monoid[DurationStatistics] =\n+      new Monoid[DurationStatistics] {\n+        override def zero: DurationStatistics = DurationStatistics(Seq.empty, None, None)\n+\n+        override def append(s1: DurationStatistics, s2: => DurationStatistics): DurationStatistics =\n+          DurationStatistics(\n+            s1.durations ++ s2.durations,\n+            Tag.unwrap(Tags.Min(s1.start) |+| Tags.Min(s2.start)),\n+            Tag.unwrap(Tags.Max(s1.end) |+| Tags.Max(s2.end))\n+          )\n+      }\n+  }\n+\n+  case class RequestTypeStats(successful: DurationStatistics, failed: DurationStatistics) {\n+    def count: Int = successful.count + failed.count\n+\n+    // takes a function that calculates a metric for DurationStatistics, and generates a Count for all/successful/failed\n+    // based on that function\n+    def attribute[T](f: DurationStatistics => Option[T])(implicit N: Numeric[T]): Count[T] =\n+      Count(f(all).getOrElse(N.zero), f(successful).getOrElse(N.zero), f(failed).getOrElse(N.zero))\n+\n+    def durationGroup(from: Option[Int], to: Option[Int]) = {\n+      val title = from.map(v => s\"$v ms < \").getOrElse(\"\") + \"t\" + to\n+        .map(v => s\" < $v ms\")\n+        .getOrElse(\"\")\n+      val count = successful.durations.count(d => !from.exists(d < _) && !to.exists(d >= _))\n+      StatGroup(\n+        title,\n+        count,\n+        all.durations.nonEmptyOpt.map(ds => count.toDouble / ds.size * 100).getOrElse(0.0))\n+    }\n+\n+    def formatted(title: String): String =\n+      List(\n+        \"=\" * lineLength,\n+        subtitle(title),\n+        attribute(_.count.some).formatted(\"Number of requests\"),\n+        attribute(_.durations.nonEmptyOpt.map(_.min)).formatted(\"Min. response time\"),\n+        attribute(_.durations.nonEmptyOpt.map(_.max)).formatted(\"Max. response time\"),\n+        attribute(_.mean.map(math.round)).formatted(\"Mean response time\"),\n+        attribute(_.stdDev.map(math.round)).formatted(\"Std. deviation\"),\n+        attribute(_.percentile(0.9)).formatted(\"response time 90th percentile\"),\n+        attribute(_.percentile(0.95)).formatted(\"response time 95th percentile\"),\n+        attribute(_.percentile(0.99)).formatted(\"response time 99th percentile\"),\n+        attribute(_.percentile(0.999)).formatted(\"response time 99.9th percentile\"),\n+        attribute(_.requestsPerSecond).formatted(\"Mean requests/second\"),\n+        subtitle(\"Response time distribution\"),\n+        durationGroup(None, 5000.some).formatted,\n+        durationGroup(5000.some, 30000.some).formatted,\n+        durationGroup(30000.some, None).formatted,\n+        StatGroup(\n+          \"failed\",\n+          failed.durations.size,\n+          all.durations.nonEmptyOpt\n+            .map(ds => failed.durations.size.toDouble / ds.size * 100)\n+            .getOrElse(0.0)).formatted,\n+        \"=\" * lineLength\n+      ).mkString(\"\\n\")\n+\n+    lazy val all = successful |+| failed\n+  }\n+\n+  object RequestTypeStats {\n+    def fromRequestStats(requests: Seq[RequestStats]): RequestTypeStats = {\n+      val successful = Map(true -> Seq(), false -> Seq()) ++ requests.groupBy(_.successful)\n+      val start = requests.nonEmptyOpt.map(_.map(_.start).min)\n+      RequestTypeStats(\n+        successful = DurationStatistics(\n+          successful(true).map(_.duration),\n+          start,\n+          successful(true).map(_.end).nonEmptyOpt.map(_.max)),\n+        failed = DurationStatistics(\n+          successful(false).map(_.duration),\n+          start,\n+          successful(false).map(_.end).nonEmptyOpt.map(_.max))\n+      )\n+    }\n+\n+    implicit val requestTypeStatsMonoid: Monoid[RequestTypeStats] = new Monoid[RequestTypeStats] {\n+      override def zero: RequestTypeStats =\n+        RequestTypeStats(mzero[DurationStatistics], mzero[DurationStatistics])\n+\n+      override def append(s1: RequestTypeStats, s2: => RequestTypeStats): RequestTypeStats =\n+        RequestTypeStats(s1.successful |+| s2.successful, s1.failed |+| s2.failed)\n+    }\n+  }\n+\n+  case class RequestStats(\n+      userId: Int,\n+      requestLabel: String,\n+      start: Timestamp,\n+      end: Timestamp,\n+      successful: Boolean\n+  ) {\n+    def duration: Int = (end - start).toInt\n+  }\n+\n+  def fromFile(file: File): String \\/ SimulationLog =\n+    for {\n+      content <- file.contentsAsString.leftMap(_.getMessage)\n+      simulation <- fromString(content)\n+    } yield simulation\n+\n+  def fromString(content: String): String \\/ SimulationLog =\n+    for {\n+      rowsByType <- groupRowsByType(content)\n+      requests <- processRequests(rowsByType.getOrElse(\"REQUEST\", List.empty))\n+      scenarios <- processScenarios(requests.groupBy(_.userId))(\n+        rowsByType.getOrElse(\"USER\", List.empty))\n+      simulation <- processSimulation(scenarios)(rowsByType.getOrElse(\"RUN\", List.empty))\n+    } yield simulation\n+\n+  private def groupRowsByType(fileContent: String) =\n+    \\/.fromTryCatchNonFatal {\n+      fileContent\n+        .split('\\n')\n+        .map(_.trim.split('\\t').toSeq)\n+        .filterNot(_.isEmpty)\n+        .map { case rowType +: fields => rowType -> fields }"
  }
]