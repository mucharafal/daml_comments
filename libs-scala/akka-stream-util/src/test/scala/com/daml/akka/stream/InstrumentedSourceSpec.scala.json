[
  {
    "id" : "d7872a4c-3701-4ebf-90dc-f744248a1df6",
    "prId" : 7576,
    "comments" : [
      {
        "id" : "c2f5d4a6-e425-4898-81af-c958d7449606",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Would be good to also have a test that checks that `Counter.dec()` gets called.",
        "createdAt" : "2020-10-06T12:25:19Z",
        "updatedAt" : "2020-10-07T11:04:05Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "98463473-7e85-4da0-a249-189a8c3e7e8a",
        "parentId" : "c2f5d4a6-e425-4898-81af-c958d7449606",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Added test.",
        "createdAt" : "2020-10-07T07:21:02Z",
        "updatedAt" : "2020-10-07T11:04:05Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi M채ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "76f067753b482633f0992ac86992896c2f75fcda",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.akka.stream\n+\n+import akka.stream.{OverflowStrategy, QueueOfferResult}\n+import akka.stream.scaladsl.{Keep, Sink}\n+import com.codahale.metrics.Counter\n+import com.daml.ledger.api.testing.utils.AkkaBeforeAndAfterAll\n+import org.scalatest.{AsyncFlatSpec, Matchers}\n+\n+import scala.concurrent.Future\n+\n+final class InstrumentedSourceSpec extends AsyncFlatSpec with Matchers with AkkaBeforeAndAfterAll {\n+\n+  behavior of \"InstrumentedSource.queue\"\n+\n+  it should \"correctly enqueue and track the buffer saturation\" in {\n+\n+    val bufferSize = 10000\n+\n+    val maxBuffered = new InstrumentedSourceSpec.MaxValueCounter()\n+\n+    // The throttling allows us to flood the source queue initially\n+    // and to reliably poll the instrumentation for testing\n+    val (source, sink) =\n+      InstrumentedSource\n+        .queue[Int](bufferSize, OverflowStrategy.backpressure, maxBuffered)\n+        .toMat(Sink.seq)(Keep.both)\n+        .run()\n+\n+    // The values in the queue are not relevant, hence the random generation\n+    val input = Seq.fill(bufferSize)(util.Random.nextInt)\n+\n+    for {\n+      results <- Future.sequence(input.map(source.offer))\n+      _ = source.complete()\n+      output <- sink\n+    } yield {\n+      all(results) shouldBe QueueOfferResult.Enqueued\n+      output shouldEqual input\n+      maxBuffered.getCount shouldEqual bufferSize\n+    }\n+  }\n+\n+  it should \"track the buffer saturation correctly when dropping items\" in {\n+\n+    val bufferSize = 10000\n+\n+    // Due to differences in scheduling, we accept that the highest\n+    // possible recorded saturation value to be more or less equal\n+    // to the buffer size. See the ScalaDoc of `InstrumentedQueue.source`\n+    // for more details\n+    val acceptanceTolerance = bufferSize * 0.05\n+    val lowAcceptanceThreshold = bufferSize - acceptanceTolerance\n+    val highAcceptanceThreshold = bufferSize + acceptanceTolerance\n+\n+    val maxBuffered = new InstrumentedSourceSpec.MaxValueCounter()\n+\n+    // The throttling allows us to flood the source queue initially\n+    // and to reliably poll the instrumentation for testing\n+    val (source, termination) =\n+      InstrumentedSource\n+        .queue[Int](bufferSize, OverflowStrategy.dropNew, maxBuffered)\n+        .watchTermination()(Keep.both)\n+        .toMat(Sink.ignore)(Keep.left)\n+        .run()\n+\n+    // We to enqueue double the items that fit in the buffer\n+    // so to force items to be dropped from the queue\n+    val inputSize = bufferSize * 2\n+    val input = Seq.fill(inputSize)(util.Random.nextInt)\n+\n+    for {\n+      results <- Future.sequence(input.map(source.offer))\n+      _ = source.complete()\n+      _ <- termination\n+    } yield {\n+      val enqueued = results.count {\n+        case QueueOfferResult.Enqueued => true\n+        case _ => false\n+      }\n+      val dropped = results.count {\n+        case QueueOfferResult.Dropped => true\n+        case _ => false\n+      }\n+      inputSize shouldEqual (enqueued + dropped)\n+      assert(enqueued >= bufferSize)\n+      assert(dropped <= bufferSize)\n+      assert(maxBuffered.getCount >= lowAcceptanceThreshold)\n+      assert(maxBuffered.getCount <= highAcceptanceThreshold)\n+    }\n+  }\n+"
  }
]