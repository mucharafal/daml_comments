[
  {
    "id" : "73c67442-32b1-454c-9ca3-1c6cdf1bf38a",
    "prId" : 7347,
    "comments" : [
      {
        "id" : "018ce544-f027-42c5-9bd5-c9f3b9101eb9",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "After writing the initial implementation and looking at it for a bit, I started to worry about the placement of `EC`.  I mean to place limits on the `map`, `flatMap`, &c operations called on this Future.  But the `EC` on a Future has nothing to do with the execution context in which *that future was evaluated*, it constrains only *the combinators on that Future, i.e. other Futures it may produce*.\r\n\r\nMy worry was \"this EC on the Future has nothing to do with the Future; it's not really part of it\".  I thought, \"should I complicate the API by adding a kind of 'projection', a method you call before map, flatmap, &c to declare an EC for the following call?\"  But then I remembered\r\n\r\n> None of this *means* anything, none of it *is* anything.  It's all uninterpreted symbols.  This, in particular, isn't even structural, never mind operational; it's only nominal, so it's even more \"meaning\"-less than all programs already are.\r\n\r\nSpeaking *practically*, and abandoning a quest for \"meaning\" in phantoms, the only thing that matters is **if this purely nominal abstraction well-types the kinds of things we want to be accepted, and ill-types the kinds of things we want to reject** (without further annotation that you know what you're doing).  Any constraints and constraint rules that make that happen are worthy of consideration.",
        "createdAt" : "2020-09-09T00:33:00Z",
        "updatedAt" : "2020-09-16T16:58:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "215cb66944783011dae3fbe6053a47d8e858ab4f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,92 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.scalautil.concurrent\n+\n+import scala.language.{higherKinds, implicitConversions}\n+import scala.{concurrent => sc}\n+import scala.util.Try\n+\n+import scalaz.{Catchable, Cobind, Isomorphism, Leibniz, MonadError, Nondeterminism, Semigroup}\n+import Isomorphism.<~>\n+import Leibniz.===\n+import scalaz.std.scalaFuture._\n+\n+sealed abstract class FutureOf {\n+\n+  /** We don't use [[sc.Future]] as the upper bound because it has methods that\n+    * collide with the versions we want to use, i.e. those that preserve the\n+    * phantom `EC` type parameter.  By contrast, [[sc.Awaitable]] has only the\n+    * `ready` and `result` methods, which are mostly useless.\n+    */\n+  type T[-EC, +A] <: sc.Awaitable[A]"
  },
  {
    "id" : "151a4277-a909-4846-9250-c8d66c98006f",
    "prId" : 7347,
    "comments" : [
      {
        "id" : "254cd251-f345-4c9d-97f0-b4e7fd77be35",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I'm rethinking this; do you think the `scala.concurrent.Future => daml.scalautil.concurrent.Future` implicit conversion should be globally visible (as it is now), or should you have to import a `Conversions._` type thing, or use an explicit `asScalaUtils` method (like `JavaConverters`)?",
        "createdAt" : "2020-09-15T18:59:53Z",
        "updatedAt" : "2020-09-16T16:58:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "80d1fbe7-66d4-46fb-9ac0-5d4799635c9f",
        "parentId" : "254cd251-f345-4c9d-97f0-b4e7fd77be35",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I think it's fine. The odds of it showing up accidentally are near-zero as far as I can see.",
        "createdAt" : "2020-09-15T19:47:45Z",
        "updatedAt" : "2020-09-16T16:58:29Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a52a809d-03d5-4551-955a-1b64fb0952e3",
        "parentId" : "254cd251-f345-4c9d-97f0-b4e7fd77be35",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "My personal preference would be explicit `asScalaUtils` call. We all know that implicit `scala.collection.JavaConversions` are deprecated in favor of more explicit `scala.collection.JavaConverters`, right? I know it is different use case... but I have been bitten by implicit conversions in Scala and C++ before, so I just blindly assume implicit conversions are bad :)",
        "createdAt" : "2020-09-15T20:33:43Z",
        "updatedAt" : "2020-09-16T16:58:29Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a02d2c56-851a-4aae-8169-68b9e41c7c63",
        "parentId" : "254cd251-f345-4c9d-97f0-b4e7fd77be35",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I'm going to go with the current global availability for first PR. We can scope it down if it seems to be a problem.",
        "createdAt" : "2020-09-15T21:52:03Z",
        "updatedAt" : "2020-09-16T16:58:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "215cb66944783011dae3fbe6053a47d8e858ab4f",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,98 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.scalautil.concurrent\n+\n+import scala.language.{higherKinds, implicitConversions}\n+import scala.{concurrent => sc}\n+import scala.util.Try\n+\n+import scalaz.{Catchable, Cobind, Isomorphism, Leibniz, MonadError, Nondeterminism, Semigroup}\n+import Isomorphism.<~>\n+import Leibniz.===\n+import scalaz.std.scalaFuture._\n+\n+sealed abstract class FutureOf {\n+\n+  /** We don't use [[sc.Future]] as the upper bound because it has methods that\n+    * collide with the versions we want to use, i.e. those that preserve the\n+    * phantom `EC` type parameter.  By contrast, [[sc.Awaitable]] has only the\n+    * `ready` and `result` methods, which are mostly useless.\n+    */\n+  type T[-EC, +A] <: sc.Awaitable[A]\n+  private[concurrent] def subst[F[_[+ _]], EC](ff: F[sc.Future]): F[T[EC, +?]]\n+}\n+\n+/** Instances and methods for `FutureOf`. You should not import these; instead,\n+  * enable `-Xsource:2.13` and they will always be available without import.\n+  */\n+object FutureOf {\n+  val Instance: FutureOf = new FutureOf {\n+    type T[-EC, +A] = sc.Future[A]\n+    override private[concurrent] def subst[F[_[+ _]], EC](ff: F[sc.Future]) = ff\n+  }\n+\n+  type ScalazF[F[+ _]] = Nondeterminism[F]\n+    with Cobind[F]\n+    with MonadError[F, Throwable]\n+    with Catchable[F]\n+\n+  implicit def `future Instance`[EC: ExecutionContext]: ScalazF[Future[EC, +?]] =\n+    Instance subst [ScalazF, EC] implicitly\n+\n+  implicit def `future Semigroup`[A: Semigroup, EC: ExecutionContext]: Semigroup[Future[EC, A]] = {\n+    type K[T[+ _]] = Semigroup[T[A]]\n+    Instance subst [K, EC] implicitly\n+  }\n+\n+  implicit def `future is any type`[A]: sc.Future[A] === Future[Any, A] =\n+    Instance subst [Lambda[`t[+_]` => sc.Future[A] === t[A]], Any] Leibniz.refl\n+\n+  implicit def `future is any`[A](sf: sc.Future[A]): Future[Any, A] =\n+    `future is any type`(sf)"
  }
]