[
  {
    "id" : "bf76f8ae-e76a-4751-bd5d-8edbdcb43ed5",
    "prId" : 7812,
    "comments" : [
      {
        "id" : "460ac687-3523-459f-a4c0-2b136bf63394",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we kill this?",
        "createdAt" : "2020-10-27T15:49:27Z",
        "updatedAt" : "2020-10-27T17:17:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "93090869-344b-4aa5-bf8b-ec7431c66471",
        "parentId" : "460ac687-3523-459f-a4c0-2b136bf63394",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Gone. 6d8fd3854f1a530b2ba0e55c895dbcff45a378a8",
        "createdAt" : "2020-10-27T16:50:33Z",
        "updatedAt" : "2020-10-27T17:17:30Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eb276b36d6afbbc0ef08b66b73e27bda3a0144bb",
    "line" : null,
    "diffHunk" : "@@ -37,6 +39,35 @@ private[trigger] sealed abstract class UnfoldState[+T, +A] {\n     go(init)\n   }\n \n+  private[trigger] final def iterator(): Iterator[T \\/ A] =\n+    new Iterator[T \\/ A] {\n+      var last = some(step(init))\n+      override def hasNext() = last.isDefined\n+      override def next() = last match {\n+        case Some(\\/-((a, s))) =>\n+          last = Some(step(s))\n+          \\/-(a)\n+        case Some(et @ -\\/(_)) =>\n+          last = None\n+          et\n+        case None =>\n+          throw new IllegalStateException(\"iterator read past end\")\n+      }\n+    }\n+\n+  /*"
  },
  {
    "id" : "b994b493-38e5-444f-add9-5e5bc8c98981",
    "prId" : 7812,
    "comments" : [
      {
        "id" : "e3e6467e-b623-4168-8a59-dc92dcf7b456",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I find the use of `BidiShape` a bit confusing. The initial state and the messages are both inputs on the “same” side in my mental model. I realize Akka doesn’t care about this and `BidiShape` is just something with two inputs and two outputs without any requirements on the connection between those but maybe it would still be useful to define something custom to avoid confusion?\r\n\r\nThe single element initial state stream also feels slightly weird to me but I don’t have a better solution for that unfortunately.",
        "createdAt" : "2020-10-27T16:34:26Z",
        "updatedAt" : "2020-10-27T17:17:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bf3e17fa-f250-431f-b566-5fb16145e1d4",
        "parentId" : "e3e6467e-b623-4168-8a59-dc92dcf7b456",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "> I realize Akka doesn’t care about this and `BidiShape` is just something with two inputs and two outputs without any requirements on the connection between those but maybe it would still be useful to define something custom to avoid confusion?\r\n\r\nSure. You think type alias, or something like `SourceShape2` (also in this PR)? Words, more code...\r\n\r\nI don't like redefining shapes, but I think adding methods implicitly to replace names like `out1` might be useful. What do you think of that?\r\n\r\n> The single element initial state stream also feels slightly weird to me but I don’t have a better solution for that unfortunately.\r\n\r\nIn general variants of `Inlet` and `Outlet` limited to exactly one element would be a useful abstraction in several ways, but not something we can add ourselves, I think. We cope with this lack of distinction in JSON API's streams, too. It is unfortunate.",
        "createdAt" : "2020-10-27T16:55:39Z",
        "updatedAt" : "2020-10-27T17:17:30Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "64854abd-0884-41c5-8c69-f872878f4607",
        "parentId" : "e3e6467e-b623-4168-8a59-dc92dcf7b456",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I probably would have defined something like `SourceShape2` but I’m also happy with just a type alias or an implicit method. Whatever you prefer.",
        "createdAt" : "2020-10-27T17:00:36Z",
        "updatedAt" : "2020-10-27T17:17:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "47cc2ced-823d-4468-8211-d4b0b1312375",
        "parentId" : "e3e6467e-b623-4168-8a59-dc92dcf7b456",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "eb276b36d6",
        "createdAt" : "2020-10-27T17:17:49Z",
        "updatedAt" : "2020-10-27T17:17:50Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "eb276b36d6afbbc0ef08b66b73e27bda3a0144bb",
    "line" : 91,
    "diffHunk" : "@@ -86,45 +112,94 @@ private[trigger] object UnfoldState {\n     */\n   def flatMapConcatStates[T, A, B](zero: T)(\n       f: (T, A) => UnfoldState[T, B]): Flow[A, T \\/ B, NotUsed] =\n-    Flow[A].statefulMapConcat { () =>\n-      var t = zero\n-      // statefulMapConcat only uses 'iterator'.  We preserve the Iterable's\n-      // immutability by making one strict reference to the 't' var at creation\n-      // time, meaning any later 'iterator' call uses the same start state, no matter\n-      // whether the above 't' has been updated\n-      a =>\n-        new Iterable[T \\/ B] {\n-          private[this] val bs = f(t, a)\n-          import bs.step\n-          override def iterator = new Iterator[T \\/ B] {\n-            private[this] var last: Option[T \\/ (B, bs.S)] = {\n-              val fst = step(bs.init)\n-              fst fold (newT => t = newT, _ => ())\n-              Some(fst)\n-            }\n+    Flow[A].statefulMapConcat(() => mkMapConcatFun(zero, f))\n \n-            // this stream is \"odd\", i.e. we are always evaluating 1 step ahead\n-            // of what the client sees.  We could improve laziness by making it\n-            // \"even\", but it would be a little trickier, as `hasNext` would have\n-            // a forcing side-effect\n-            override def hasNext() = last.isDefined\n-\n-            override def next() =\n-              last match {\n-                case Some(\\/-((b, s))) =>\n-                  val next = step(s)\n-                  // The assumption here is that statefulMapConcat's implementation\n-                  // will always read iterator to end before invoking on the next A\n-                  next fold (newT => t = newT, _ => ())\n-                  last = Some(next)\n-                  \\/-(b)\n-                case Some(et @ -\\/(_)) =>\n-                  last = None\n-                  et\n-                case None =>\n-                  throw new IllegalStateException(\"iterator read past end\")\n-              }\n+  /** Accept 1 initial state on in1, fold over in2 elements, emitting the output\n+    * elements on out1, and each result state after each result of `f` is unfolded\n+    * on out2.\n+    */\n+  def flatMapConcatNode[T, A, B]("
  }
]