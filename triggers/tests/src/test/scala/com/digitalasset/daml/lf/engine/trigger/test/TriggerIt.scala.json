[
  {
    "id" : "8cd656ca-8f20-4c94-900e-8dff88c56705",
    "prId" : 5250,
    "comments" : [
      {
        "id" : "610a24d4-4f9c-43de-ac1d-8139a8b3c9f4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "There is a bit of boilerplate between the tests that we should probably factor out but I wanted to have a few explicit tests for the first version.",
        "createdAt" : "2020-03-27T14:39:23Z",
        "updatedAt" : "2020-03-27T14:39:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6508da30ee95b3fb1a258a2b0a93e1349b62e52c",
    "line" : 179,
    "diffHunk" : "@@ -0,0 +1,247 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.engine.trigger.test\n+\n+import java.io.File\n+import java.util.UUID\n+\n+import akka.stream.scaladsl.{Flow, Sink}\n+import com.digitalasset.api.util.TimeProvider\n+import com.digitalasset.daml.bazeltools.BazelRunfiles._\n+import com.digitalasset.daml.lf.PureCompiledPackages\n+import com.digitalasset.daml.lf.archive.{DarReader, Decode}\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.speedy.SExpr\n+import com.digitalasset.daml.lf.speedy.SExpr._\n+import com.digitalasset.daml.lf.speedy.SValue._\n+import com.digitalasset.daml.lf.value.Value.AbsoluteContractId\n+import com.digitalasset.dec.DirectExecutionContext\n+import com.digitalasset.ledger.api.domain\n+import com.digitalasset.ledger.api.testing.utils.{MockMessages, SuiteResourceManagementAroundAll}\n+import com.digitalasset.ledger.api.v1.command_service.SubmitAndWaitRequest\n+import com.digitalasset.ledger.api.v1.commands._\n+import com.digitalasset.ledger.api.v1.commands.{Command, CreateCommand, ExerciseCommand}\n+import com.digitalasset.ledger.api.v1.event.CreatedEvent\n+import com.digitalasset.ledger.api.refinements.ApiTypes.ApplicationId\n+import com.digitalasset.ledger.api.v1.testing.time_service.TimeServiceGrpc\n+import com.digitalasset.ledger.api.v1.transaction_filter.{Filters, TransactionFilter}\n+import com.digitalasset.ledger.api.v1.{value => LedgerApi}\n+import com.digitalasset.ledger.client.LedgerClient\n+import com.digitalasset.ledger.client.configuration.{\n+  CommandClientConfiguration,\n+  LedgerClientConfiguration,\n+  LedgerIdRequirement\n+}\n+import com.digitalasset.ledger.client.services.testing.time.StaticTime\n+import com.digitalasset.platform.sandbox.services.{SandboxFixture, TestCommands}\n+import com.digitalasset.platform.services.time.TimeProviderType\n+import org.scalatest._\n+import scala.concurrent.Future\n+import scala.util.control.NonFatal\n+import scalaz.syntax.tag._\n+import scalaz.syntax.traverse._\n+\n+import com.digitalasset.daml.lf.engine.trigger.{Runner, Trigger, TriggerMsg}\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+final class TriggerIt\n+    extends AsyncWordSpec\n+    with TestCommands\n+    with SandboxFixture\n+    with Matchers\n+    with SuiteResourceManagementAroundAll\n+    with TryValues {\n+\n+  private val ledgerClientConfiguration =\n+    LedgerClientConfiguration(\n+      applicationId = MockMessages.applicationId,\n+      ledgerIdRequirement = LedgerIdRequirement(\"\", enabled = false),\n+      commandClient = CommandClientConfiguration.default,\n+      sslContext = None,\n+      token = None\n+    )\n+\n+  private def timeProvider(ledgerId: domain.LedgerId): Future[TimeProvider] = {\n+    StaticTime\n+      .updatedVia(TimeServiceGrpc.stub(channel), ledgerId.unwrap)\n+      .recover { case NonFatal(_) => TimeProvider.UTC }(DirectExecutionContext)\n+  }\n+\n+  private def ledgerClient(): Future[LedgerClient] =\n+    LedgerClient.singleHost(\"localhost\", serverPort.value, ledgerClientConfiguration)\n+\n+  override protected def darFile = new File(rlocation(\"triggers/tests/acs.dar\"))\n+\n+  private def dar = DarReader().readArchiveFromFile(darFile).get.map {\n+    case (pkgId, archive) => Decode.readArchivePayload(pkgId, archive)\n+  }\n+  private def compiledPackages = PureCompiledPackages(dar.all.toMap).right.get\n+\n+  private def getRunner(client: LedgerClient, name: QualifiedName, party: String): Runner = {\n+    val triggerId = Identifier(packageId, name)\n+    val trigger = Trigger.fromIdentifier(compiledPackages, triggerId).right.get\n+    new Runner(\n+      compiledPackages,\n+      trigger,\n+      client,\n+      TimeProviderType.WallClock,\n+      ApplicationId(MockMessages.applicationId),\n+      party)\n+  }\n+\n+  private def allocateParty(client: LedgerClient): Future[String] =\n+    client.partyManagementClient.allocateParty(None, None).map(_.party)\n+\n+  private def create(client: LedgerClient, party: String, cmd: CreateCommand): Future[String] = {\n+    val commands = Seq(Command().withCreate(cmd))\n+    val request = SubmitAndWaitRequest(\n+      Some(\n+        Commands(\n+          party = party,\n+          commands = commands,\n+          ledgerId = client.ledgerId.unwrap,\n+          applicationId = MockMessages.applicationId,\n+          commandId = UUID.randomUUID.toString\n+        )))\n+    for {\n+      response <- client.commandServiceClient.submitAndWaitForTransaction(request)\n+    } yield response.getTransaction.events.head.getCreated.contractId\n+  }\n+\n+  private def archive(\n+      client: LedgerClient,\n+      party: String,\n+      templateId: LedgerApi.Identifier,\n+      contractId: String): Future[Unit] = {\n+    val commands = Seq(\n+      Command().withExercise(\n+        ExerciseCommand(\n+          templateId = Some(templateId),\n+          contractId = contractId,\n+          choice = \"Archive\",\n+          choiceArgument = Some(LedgerApi.Value().withRecord(LedgerApi.Record())))))\n+    val request = SubmitAndWaitRequest(\n+      Some(\n+        Commands(\n+          party = party,\n+          commands = commands,\n+          ledgerId = client.ledgerId.unwrap,\n+          applicationId = MockMessages.applicationId,\n+          commandId = UUID.randomUUID.toString\n+        )))\n+    for {\n+      response <- client.commandServiceClient.submitAndWaitForTransaction(request)\n+    } yield ()\n+  }\n+\n+  private def queryACS(client: LedgerClient, party: String) = {\n+    val filter = TransactionFilter(List((party, Filters.defaultInstance)).toMap)\n+    val contractsF: Future[Seq[CreatedEvent]] = client.activeContractSetClient\n+      .getActiveContracts(filter, verbose = true)\n+      .runWith(Sink.seq)\n+      .map(_.flatMap(x => x.activeContracts))\n+    contractsF.map(contracts =>\n+      contracts.map(created => (created.getTemplateId, created.getCreateArguments)).groupBy(_._1))\n+  }\n+\n+  \"Trigger\" can {\n+    \"AcsTests\" should {\n+      val assetId = LedgerApi.Identifier(packageId, \"ACS\", \"Asset\")\n+      val assetMirrorId = LedgerApi.Identifier(packageId, \"ACS\", \"AssetMirror\")\n+      def asset(party: String): CreateCommand =\n+        CreateCommand(\n+          templateId = Some(assetId),\n+          createArguments = Some(\n+            LedgerApi.Record(fields =\n+              Seq(LedgerApi.RecordField(\"issuer\", Some(LedgerApi.Value().withParty(party)))))))\n+\n+      final case class AssetResult(\n+          successfulCompletions: Long,\n+          failedCompletions: Long,\n+          activeAssets: Set[String])\n+\n+      def toResult(expr: SExpr): AssetResult = {\n+        val fields = expr.asInstanceOf[SEValue].v.asInstanceOf[SRecord].values\n+        AssetResult(\n+          successfulCompletions = fields.get(1).asInstanceOf[SInt64].value,\n+          failedCompletions = fields.get(2).asInstanceOf[SInt64].value,\n+          activeAssets = fields\n+            .get(0)\n+            .asInstanceOf[SList]\n+            .list\n+            .map(x =>\n+              x.asInstanceOf[SContractId].value.asInstanceOf[AbsoluteContractId].coid.toString)\n+            .toSet\n+        )\n+      }\n+\n+      \"1 create\" in {"
  }
]