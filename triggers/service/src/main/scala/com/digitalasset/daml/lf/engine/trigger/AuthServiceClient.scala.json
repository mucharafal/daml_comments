[
  {
    "id" : "439d7116-e00a-4c8f-94eb-b7709260560b",
    "prId" : 6804,
    "comments" : [
      {
        "id" : "aafaf98a-7a84-4fcb-a7bb-4d4d90445301",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Only returning a boolean makes it pretty hard to debug failed requests.",
        "createdAt" : "2020-07-21T06:53:01Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1371c27e-c4b9-4687-841b-0c32b6f11a86",
        "parentId" : "aafaf98a-7a84-4fcb-a7bb-4d4d90445301",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "I could return an `Either` with the `HttpResponse` in the failed case?",
        "createdAt" : "2020-07-21T15:38:30Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "75f7a367-b94b-4763-8f66-e8dc470155da",
        "parentId" : "aafaf98a-7a84-4fcb-a7bb-4d4d90445301",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Went with failed futures instead of Either",
        "createdAt" : "2020-07-21T17:52:02Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2c15ae15e57e21aa2c1c4b17932cd408dad2249f",
    "line" : null,
    "diffHunk" : "@@ -29,20 +57,116 @@ class AuthServiceClient(authServiceBaseUri: Uri)(\n   import AuthServiceDomain._\n \n   private val http: HttpExt = Http(system)\n+  private val saSecure = Path(\"/sa/secure\")\n+  private val saLogin = Path(\"/sa/login\")\n \n   def authorize(username: String, password: String): Future[AuthServiceToken] = {\n-    val authorizeUri = authServiceBaseUri.withPath(Path(\"/sa/secure/authorize\"))\n-    val request = HttpRequest(\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"authorize\"))\n+    val req = HttpRequest(\n       method = HttpMethods.POST,\n-      uri = authorizeUri,\n+      uri,\n       headers = List(Authorization(BasicHttpCredentials(username, password)))\n     )\n-    for {\n-      authResponse <- http.singleRequest(request)\n-      authServiceToken <- Unmarshal(authResponse).to[AuthServiceToken]\n-    } yield authServiceToken\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[AuthServiceToken])\n   }\n \n+  def requestServiceAccount(\n+      authServiceToken: AuthServiceToken,\n+      ledgerId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"request\")./(ledgerId))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val nonce = Nonce(UUID.randomUUID.toString)\n+    val entity = HttpEntity(ContentTypes.`application/json`, nonce.toJson.toString)\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+      entity\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)"
  },
  {
    "id" : "193a5265-ec09-4164-9fdc-b0923442db0a",
    "prId" : 6804,
    "comments" : [
      {
        "id" : "b59b8058-ee48-4116-83d6-926a6019f04e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Do you really want to catch all exceptions here?",
        "createdAt" : "2020-07-21T06:56:08Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3798dffb-c75c-40bf-8506-b287a8224a7a",
        "parentId" : "b59b8058-ee48-4116-83d6-926a6019f04e",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Removed the `catch` and now retry only on `NoSuchElementException`.",
        "createdAt" : "2020-07-21T17:53:20Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2c15ae15e57e21aa2c1c4b17932cd408dad2249f",
    "line" : null,
    "diffHunk" : "@@ -29,20 +57,116 @@ class AuthServiceClient(authServiceBaseUri: Uri)(\n   import AuthServiceDomain._\n \n   private val http: HttpExt = Http(system)\n+  private val saSecure = Path(\"/sa/secure\")\n+  private val saLogin = Path(\"/sa/login\")\n \n   def authorize(username: String, password: String): Future[AuthServiceToken] = {\n-    val authorizeUri = authServiceBaseUri.withPath(Path(\"/sa/secure/authorize\"))\n-    val request = HttpRequest(\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"authorize\"))\n+    val req = HttpRequest(\n       method = HttpMethods.POST,\n-      uri = authorizeUri,\n+      uri,\n       headers = List(Authorization(BasicHttpCredentials(username, password)))\n     )\n-    for {\n-      authResponse <- http.singleRequest(request)\n-      authServiceToken <- Unmarshal(authResponse).to[AuthServiceToken]\n-    } yield authServiceToken\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[AuthServiceToken])\n   }\n \n+  def requestServiceAccount(\n+      authServiceToken: AuthServiceToken,\n+      ledgerId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"request\")./(ledgerId))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val nonce = Nonce(UUID.randomUUID.toString)\n+    val entity = HttpEntity(ContentTypes.`application/json`, nonce.toJson.toString)\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+      entity\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)\n+  }\n+\n+  def listServiceAccounts(authServiceToken: AuthServiceToken): Future[ServiceAccountList] = {\n+    val uri = authServiceBaseUri.withPath(saSecure)\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val req = HttpRequest(\n+      method = HttpMethods.GET,\n+      uri,\n+      headers = List(authHeader),\n+    )\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[ServiceAccountList])\n+  }\n+\n+  def getServiceAccount(authServiceToken: AuthServiceToken): Future[Option[ServiceAccount]] =\n+    try {\n+      RetryStrategy.constant(attempts = 3, waitTime = 4.seconds) { (_, _) =>\n+        for {\n+          ServiceAccountList(sa :: _) <- listServiceAccounts(authServiceToken)\n+        } yield Some(sa)\n+      }\n+    } catch {\n+      case e: Throwable => Future(None)"
  },
  {
    "id" : "9c51e3a7-9193-4e7f-94e5-a50a697fac99",
    "prId" : 6804,
    "comments" : [
      {
        "id" : "1496d459-f2ad-4fa3-81f3-01eeba871e8a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here, youâ€™re throwing away all debugging info.",
        "createdAt" : "2020-07-21T06:57:26Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "80e12fe7-2a3e-4649-9e29-c6a5bf88814a",
        "parentId" : "1496d459-f2ad-4fa3-81f3-01eeba871e8a",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Fixed",
        "createdAt" : "2020-07-21T17:53:39Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2c15ae15e57e21aa2c1c4b17932cd408dad2249f",
    "line" : null,
    "diffHunk" : "@@ -29,20 +57,116 @@ class AuthServiceClient(authServiceBaseUri: Uri)(\n   import AuthServiceDomain._\n \n   private val http: HttpExt = Http(system)\n+  private val saSecure = Path(\"/sa/secure\")\n+  private val saLogin = Path(\"/sa/login\")\n \n   def authorize(username: String, password: String): Future[AuthServiceToken] = {\n-    val authorizeUri = authServiceBaseUri.withPath(Path(\"/sa/secure/authorize\"))\n-    val request = HttpRequest(\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"authorize\"))\n+    val req = HttpRequest(\n       method = HttpMethods.POST,\n-      uri = authorizeUri,\n+      uri,\n       headers = List(Authorization(BasicHttpCredentials(username, password)))\n     )\n-    for {\n-      authResponse <- http.singleRequest(request)\n-      authServiceToken <- Unmarshal(authResponse).to[AuthServiceToken]\n-    } yield authServiceToken\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[AuthServiceToken])\n   }\n \n+  def requestServiceAccount(\n+      authServiceToken: AuthServiceToken,\n+      ledgerId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"request\")./(ledgerId))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val nonce = Nonce(UUID.randomUUID.toString)\n+    val entity = HttpEntity(ContentTypes.`application/json`, nonce.toJson.toString)\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+      entity\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)\n+  }\n+\n+  def listServiceAccounts(authServiceToken: AuthServiceToken): Future[ServiceAccountList] = {\n+    val uri = authServiceBaseUri.withPath(saSecure)\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val req = HttpRequest(\n+      method = HttpMethods.GET,\n+      uri,\n+      headers = List(authHeader),\n+    )\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[ServiceAccountList])\n+  }\n+\n+  def getServiceAccount(authServiceToken: AuthServiceToken): Future[Option[ServiceAccount]] =\n+    try {\n+      RetryStrategy.constant(attempts = 3, waitTime = 4.seconds) { (_, _) =>\n+        for {\n+          ServiceAccountList(sa :: _) <- listServiceAccounts(authServiceToken)\n+        } yield Some(sa)\n+      }\n+    } catch {\n+      case e: Throwable => Future(None)\n+    }\n+\n+  def requestCredential(\n+      authServiceToken: AuthServiceToken,\n+      serviceAccountId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(serviceAccountId)./(\"credRequest\"))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)"
  },
  {
    "id" : "4608ac2e-a5d1-45f3-b1cb-232378f7e5a0",
    "prId" : 6804,
    "comments" : [
      {
        "id" : "2be86308-8431-466b-9fb0-451bec1511c8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a guarantee on the order here?",
        "createdAt" : "2020-07-21T07:02:06Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d0fbef7e-5c35-4808-854d-52d062e62787",
        "parentId" : "2be86308-8431-466b-9fb0-451bec1511c8",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Actually I don't know the order of service accounts, but for our use case we only ever have one service account per user, so I shouldn't be depending on the order for this.",
        "createdAt" : "2020-07-21T15:14:41Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2c15ae15e57e21aa2c1c4b17932cd408dad2249f",
    "line" : null,
    "diffHunk" : "@@ -29,20 +57,116 @@ class AuthServiceClient(authServiceBaseUri: Uri)(\n   import AuthServiceDomain._\n \n   private val http: HttpExt = Http(system)\n+  private val saSecure = Path(\"/sa/secure\")\n+  private val saLogin = Path(\"/sa/login\")\n \n   def authorize(username: String, password: String): Future[AuthServiceToken] = {\n-    val authorizeUri = authServiceBaseUri.withPath(Path(\"/sa/secure/authorize\"))\n-    val request = HttpRequest(\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"authorize\"))\n+    val req = HttpRequest(\n       method = HttpMethods.POST,\n-      uri = authorizeUri,\n+      uri,\n       headers = List(Authorization(BasicHttpCredentials(username, password)))\n     )\n-    for {\n-      authResponse <- http.singleRequest(request)\n-      authServiceToken <- Unmarshal(authResponse).to[AuthServiceToken]\n-    } yield authServiceToken\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[AuthServiceToken])\n   }\n \n+  def requestServiceAccount(\n+      authServiceToken: AuthServiceToken,\n+      ledgerId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"request\")./(ledgerId))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val nonce = Nonce(UUID.randomUUID.toString)\n+    val entity = HttpEntity(ContentTypes.`application/json`, nonce.toJson.toString)\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+      entity\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)\n+  }\n+\n+  def listServiceAccounts(authServiceToken: AuthServiceToken): Future[ServiceAccountList] = {\n+    val uri = authServiceBaseUri.withPath(saSecure)\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val req = HttpRequest(\n+      method = HttpMethods.GET,\n+      uri,\n+      headers = List(authHeader),\n+    )\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[ServiceAccountList])\n+  }\n+\n+  def getServiceAccount(authServiceToken: AuthServiceToken): Future[Option[ServiceAccount]] =\n+    try {\n+      RetryStrategy.constant(attempts = 3, waitTime = 4.seconds) { (_, _) =>\n+        for {\n+          ServiceAccountList(sa :: _) <- listServiceAccounts(authServiceToken)\n+        } yield Some(sa)\n+      }\n+    } catch {\n+      case e: Throwable => Future(None)\n+    }\n+\n+  def requestCredential(\n+      authServiceToken: AuthServiceToken,\n+      serviceAccountId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(serviceAccountId)./(\"credRequest\"))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)\n+  }\n+\n+  def getNewCredentialId(\n+      authServiceToken: AuthServiceToken,\n+      serviceAccountId: String): Future[Option[CredentialId]] =\n+    getServiceAccount(authServiceToken) flatMap {\n+      case None => Future(None)\n+      case Some(sa) =>\n+        val numCreds = sa.creds.length\n+        requestCredential(authServiceToken, sa.serviceAccount) flatMap { reqSuccess =>\n+          if (!reqSuccess) Future(None)\n+          else\n+            try {\n+              RetryStrategy.constant(attempts = 3, waitTime = 4.seconds) { (_, _) =>\n+                for {\n+                  ServiceAccountList(sa :: _) <- listServiceAccounts(authServiceToken)"
  },
  {
    "id" : "eee66c56-6332-47cd-b9a9-e62a383f75c7",
    "prId" : 6804,
    "comments" : [
      {
        "id" : "3c18ce92-69bf-479e-8b8d-9f12475ab25f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "maybe call `numCreds`, `oldNumCreds` or `prevNumCreds`. You might also want to avoid shadowing `sa`.",
        "createdAt" : "2020-07-21T07:13:27Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "10b7b500-c2e9-45e3-85cc-61e8da5165a2",
        "parentId" : "3c18ce92-69bf-479e-8b8d-9f12475ab25f",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Renamed, keeping shadowing to avoid using the old `sa`.",
        "createdAt" : "2020-07-21T17:54:07Z",
        "updatedAt" : "2020-07-21T21:05:20Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2c15ae15e57e21aa2c1c4b17932cd408dad2249f",
    "line" : null,
    "diffHunk" : "@@ -29,20 +57,116 @@ class AuthServiceClient(authServiceBaseUri: Uri)(\n   import AuthServiceDomain._\n \n   private val http: HttpExt = Http(system)\n+  private val saSecure = Path(\"/sa/secure\")\n+  private val saLogin = Path(\"/sa/login\")\n \n   def authorize(username: String, password: String): Future[AuthServiceToken] = {\n-    val authorizeUri = authServiceBaseUri.withPath(Path(\"/sa/secure/authorize\"))\n-    val request = HttpRequest(\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"authorize\"))\n+    val req = HttpRequest(\n       method = HttpMethods.POST,\n-      uri = authorizeUri,\n+      uri,\n       headers = List(Authorization(BasicHttpCredentials(username, password)))\n     )\n-    for {\n-      authResponse <- http.singleRequest(request)\n-      authServiceToken <- Unmarshal(authResponse).to[AuthServiceToken]\n-    } yield authServiceToken\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[AuthServiceToken])\n   }\n \n+  def requestServiceAccount(\n+      authServiceToken: AuthServiceToken,\n+      ledgerId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(\"request\")./(ledgerId))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val nonce = Nonce(UUID.randomUUID.toString)\n+    val entity = HttpEntity(ContentTypes.`application/json`, nonce.toJson.toString)\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+      entity\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)\n+  }\n+\n+  def listServiceAccounts(authServiceToken: AuthServiceToken): Future[ServiceAccountList] = {\n+    val uri = authServiceBaseUri.withPath(saSecure)\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val req = HttpRequest(\n+      method = HttpMethods.GET,\n+      uri,\n+      headers = List(authHeader),\n+    )\n+    http.singleRequest(req).flatMap(Unmarshal(_).to[ServiceAccountList])\n+  }\n+\n+  def getServiceAccount(authServiceToken: AuthServiceToken): Future[Option[ServiceAccount]] =\n+    try {\n+      RetryStrategy.constant(attempts = 3, waitTime = 4.seconds) { (_, _) =>\n+        for {\n+          ServiceAccountList(sa :: _) <- listServiceAccounts(authServiceToken)\n+        } yield Some(sa)\n+      }\n+    } catch {\n+      case e: Throwable => Future(None)\n+    }\n+\n+  def requestCredential(\n+      authServiceToken: AuthServiceToken,\n+      serviceAccountId: String): Future[Boolean] = {\n+    val uri = authServiceBaseUri.withPath(saSecure./(serviceAccountId)./(\"credRequest\"))\n+    val authHeader = Authorization(OAuth2BearerToken(authServiceToken.token))\n+    val req = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri,\n+      headers = List(authHeader),\n+    )\n+    http.singleRequest(req).map(_.status.isSuccess)\n+  }\n+\n+  def getNewCredentialId(\n+      authServiceToken: AuthServiceToken,\n+      serviceAccountId: String): Future[Option[CredentialId]] =\n+    getServiceAccount(authServiceToken) flatMap {\n+      case None => Future(None)\n+      case Some(sa) =>\n+        val numCreds = sa.creds.length\n+        requestCredential(authServiceToken, sa.serviceAccount) flatMap { reqSuccess =>\n+          if (!reqSuccess) Future(None)\n+          else\n+            try {\n+              RetryStrategy.constant(attempts = 3, waitTime = 4.seconds) { (_, _) =>\n+                for {\n+                  ServiceAccountList(sa :: _) <- listServiceAccounts(authServiceToken)\n+                  if sa.creds.length > numCreds"
  },
  {
    "id" : "525f8b78-608a-4abb-85c6-c82d85b955d2",
    "prId" : 6768,
    "comments" : [
      {
        "id" : "9e730e6b-faad-44a9-97a6-472f7a11e47d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This suffers from the same issue that I fixed for DAML Script here https://github.com/digital-asset/daml/commit/c0a313c6c578b154198d9ab358c84be0a1f92c51. In addition to that, you are also forcing http whereas this should almost certainly run via https. Maybe the best option here would be to let the user specify a URI instead of a host and a port (probably using the `Uri` type instead of a string). What do you think?",
        "createdAt" : "2020-07-17T07:33:54Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1b33122f-b111-4650-9e88-cc76329510a3",
        "parentId" : "9e730e6b-faad-44a9-97a6-472f7a11e47d",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "That's probably best for the end user, e.g. passing `\"https://localhost:8089\"` instead of 3 different arguments to configure the URI.",
        "createdAt" : "2020-07-17T16:16:03Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "310d5a1bb1a6b68dbb3229efc95a2362d60d7257",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,70 @@\n+package com.daml.lf.engine.trigger\n+\n+import java.net.InetAddress\n+\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.{Http, HttpExt}\n+import akka.http.scaladsl.model.{HttpMethods, HttpRequest, HttpResponse}\n+import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n+import akka.stream.Materializer\n+import akka.util.ByteString\n+import com.daml.ports.Port\n+import spray.json.{JsObject, JsValue}\n+import spray.json._\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+// OAuth2 bearer token for requests to authentication service\n+case class AuthServiceToken(token: String)\n+\n+class AuthServiceClient(\n+    host: InetAddress,\n+    port: Port,\n+)(implicit system: ActorSystem, materializer: Materializer, ec: ExecutionContext) {\n+\n+  private val http: HttpExt = Http(system)\n+\n+  private val authServiceBaseUri = \"http://\" + host.getHostAddress + \":\" + port.toString + \"/sa/\""
  },
  {
    "id" : "519a7930-243e-48aa-9467-466c574e07ef",
    "prId" : 6768,
    "comments" : [
      {
        "id" : "81967f2b-7bea-45f5-a7a1-392574121601",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a reason why you are not defining a proper `RootJsonReader`?",
        "createdAt" : "2020-07-17T08:03:58Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6dda115a-bc54-4c0f-a9a5-22e143c47810",
        "parentId" : "81967f2b-7bea-45f5-a7a1-392574121601",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "No - will do",
        "createdAt" : "2020-07-17T16:25:20Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "310d5a1bb1a6b68dbb3229efc95a2362d60d7257",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,70 @@\n+package com.daml.lf.engine.trigger\n+\n+import java.net.InetAddress\n+\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.{Http, HttpExt}\n+import akka.http.scaladsl.model.{HttpMethods, HttpRequest, HttpResponse}\n+import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n+import akka.stream.Materializer\n+import akka.util.ByteString\n+import com.daml.ports.Port\n+import spray.json.{JsObject, JsValue}\n+import spray.json._\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+// OAuth2 bearer token for requests to authentication service\n+case class AuthServiceToken(token: String)\n+\n+class AuthServiceClient(\n+    host: InetAddress,\n+    port: Port,\n+)(implicit system: ActorSystem, materializer: Materializer, ec: ExecutionContext) {\n+\n+  private val http: HttpExt = Http(system)\n+\n+  private val authServiceBaseUri = \"http://\" + host.getHostAddress + \":\" + port.toString + \"/sa/\"\n+\n+  private def responseBodyToString(resp: HttpResponse): Future[String] = {\n+    resp.entity.dataBytes.runFold(ByteString(\"\"))(_ ++ _).map(_.utf8String)\n+  }\n+\n+  // Extract a field from the JSON object in an HTTP response.\n+  private def parseResponseField(response: HttpResponse, field: String): Future[Option[JsValue]] = {"
  },
  {
    "id" : "7e4633de-0481-4669-ab97-ccaddd715446",
    "prId" : 6768,
    "comments" : [
      {
        "id" : "df57f8e1-9a65-4035-a2af-7eb44ee8ae25",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`withPath` replaces the whole path. Consider what happens if the user specified `examle.com/myauth` as their auth service URI. You will now remove the `myauth` path prefix. This is probably acceptable for now but I would recommend to add some validation logic that the path in `authServiceBaseUri` is empty to catch this early.",
        "createdAt" : "2020-07-20T07:28:01Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "310d5a1bb1a6b68dbb3229efc95a2362d60d7257",
    "line" : 34,
    "diffHunk" : "@@ -0,0 +1,56 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf.engine.trigger\n+\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\n+import akka.http.scaladsl.model.Uri.Path\n+import akka.http.scaladsl.{Http, HttpExt}\n+import akka.http.scaladsl.model.{HttpMethods, HttpRequest, Uri}\n+import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n+import akka.http.scaladsl.unmarshalling.Unmarshal\n+import akka.stream.Materializer\n+import spray.json._\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+object AuthServiceDomain extends DefaultJsonProtocol {\n+  // OAuth2 bearer token for requests to authentication service\n+  case class AuthServiceToken(token: String)\n+  implicit val authServiceTokenFormat: RootJsonFormat[AuthServiceToken] = jsonFormat1(\n+    AuthServiceToken)\n+}\n+\n+class AuthServiceClient(authServiceBaseUri: Uri)(\n+    implicit system: ActorSystem,\n+    materializer: Materializer,\n+    ec: ExecutionContext) {\n+  import AuthServiceDomain._\n+\n+  private val http: HttpExt = Http(system)\n+\n+  def authorize(username: String, password: String): Future[AuthServiceToken] = {\n+    val authorizeUri = authServiceBaseUri.withPath(Path(\"/sa/secure/authorize\"))"
  },
  {
    "id" : "097c71f5-c83f-4acc-bf0c-45c3846fabb4",
    "prId" : 6768,
    "comments" : [
      {
        "id" : "c3e87098-2501-432e-89c0-24e6d15e5b76",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why not just use the constructor directly?",
        "createdAt" : "2020-07-20T07:28:43Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d323e1d4-473b-4213-a893-15f4a9ebd64d",
        "parentId" : "c3e87098-2501-432e-89c0-24e6d15e5b76",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Just habit I guess. Not really necessary here.",
        "createdAt" : "2020-07-20T13:09:05Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "310d5a1bb1a6b68dbb3229efc95a2362d60d7257",
    "line" : 49,
    "diffHunk" : "@@ -0,0 +1,56 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf.engine.trigger\n+\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\n+import akka.http.scaladsl.model.Uri.Path\n+import akka.http.scaladsl.{Http, HttpExt}\n+import akka.http.scaladsl.model.{HttpMethods, HttpRequest, Uri}\n+import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n+import akka.http.scaladsl.unmarshalling.Unmarshal\n+import akka.stream.Materializer\n+import spray.json._\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+object AuthServiceDomain extends DefaultJsonProtocol {\n+  // OAuth2 bearer token for requests to authentication service\n+  case class AuthServiceToken(token: String)\n+  implicit val authServiceTokenFormat: RootJsonFormat[AuthServiceToken] = jsonFormat1(\n+    AuthServiceToken)\n+}\n+\n+class AuthServiceClient(authServiceBaseUri: Uri)(\n+    implicit system: ActorSystem,\n+    materializer: Materializer,\n+    ec: ExecutionContext) {\n+  import AuthServiceDomain._\n+\n+  private val http: HttpExt = Http(system)\n+\n+  def authorize(username: String, password: String): Future[AuthServiceToken] = {\n+    val authorizeUri = authServiceBaseUri.withPath(Path(\"/sa/secure/authorize\"))\n+    val request = HttpRequest(\n+      method = HttpMethods.POST,\n+      uri = authorizeUri,\n+      headers = List(Authorization(BasicHttpCredentials(username, password)))\n+    )\n+    for {\n+      authResponse <- http.singleRequest(request)\n+      authServiceToken <- Unmarshal(authResponse).to[AuthServiceToken]\n+    } yield authServiceToken\n+  }\n+\n+}\n+\n+object AuthServiceClient {\n+  def apply(authServiceBaseUri: Uri)("
  }
]