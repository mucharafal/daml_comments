[
  {
    "id" : "c1e31d22-9bd2-4411-9bab-2de95c0dd35c",
    "prId" : 7654,
    "comments" : [
      {
        "id" : "4b3f5c2b-0345-4337-b4b3-8e81f333286c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we pop from `authRequests` here? Afaict we are leaking memory atm.",
        "createdAt" : "2020-10-13T08:52:40Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2a4c84ed-5adb-4015-a5a2-0d9620407ecd",
        "parentId" : "4b3f5c2b-0345-4337-b4b3-8e81f333286c",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "This calls [`remove`](https://www.scala-lang.org/api/2.12.2/scala/collection/concurrent/TrieMap.html#remove(k:K):Option[V]) which removes the item from `authRequests`. Or do you mean there's another memory leak here?",
        "createdAt" : "2020-10-13T15:21:43Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e2092a39-48e9-42d3-8931-b210f26dbdf4",
        "parentId" : "4b3f5c2b-0345-4337-b4b3-8e81f333286c",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "duh, not sure how I managed to miss that. Sorry :facepalm: ",
        "createdAt" : "2020-10-13T15:52:18Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0b1adc8e2e9d1b4d7828d6b222879ebaabd6947a",
    "line" : null,
    "diffHunk" : "@@ -171,20 +188,102 @@ class Server(\n   private def getTriggerStatus(uuid: UUID): Vector[(LocalDateTime, String)] =\n     triggerLog.getOrDefault(uuid, Vector.empty)\n \n-  private val route = concat(\n+  // TODO[AH] Make sure this is bounded in size.\n+  private val authRequests: TrieMap[UUID, HttpRequest] = TrieMap()\n+\n+  // This directive requires authorization for the given claims via the auth middleware, if configured.\n+  // If no auth middleware is configured, then the request will proceed without attempting authorization.\n+  //\n+  // Authorization follows the steps defined in `triggers/service/authentication.md`.\n+  // First asking for a token on the `/auth` endpoint and redirecting to `/login` if none was returned.\n+  // If a login is required then this will store the current request in `authRequests`\n+  // and register a callback to proceed with the request once the login flow completed.\n+  private def authorize(claims: AuthRequest.Claims)(\n+      implicit ec: ExecutionContext,\n+      system: ActorSystem): Directive1[Option[String]] = Directive { inner => ctx =>\n+    authConfig match {\n+      case NoAuth => inner(Tuple1(None))(ctx)\n+      case AuthMiddleware(authUri) =>\n+        val uri = authUri\n+          .withPath(Path./(\"auth\"))\n+          .withQuery(AuthRequest.Auth(claims).toQuery)\n+        // forward cookies\n+        val cookies = ctx.request.header[headers.Cookie]\n+        val req = HttpRequest(uri = uri, headers = cookies.toList)\n+        import AuthJsonProtocol._\n+        for {\n+          resp <- Http().singleRequest(req)\n+          result <- resp.status match {\n+            case StatusCodes.OK =>\n+              Unmarshal(resp).to[AuthResponse.Authorize].flatMap { auth =>\n+                inner(Tuple1(Some(auth.accessToken)))(ctx)\n+              }\n+            case StatusCodes.Unauthorized =>\n+              val requestId = UUID.randomUUID\n+              authRequests.update(requestId, ctx.request)\n+              val uri = authUri\n+                .withPath(Path./(\"login\"))\n+                .withQuery(\n+                  AuthRequest\n+                    .Login(\n+                      // TODO[AH] Make the redirect URI configurable, especially the authority. E.g. when running behind nginx.\n+                      Uri()\n+                        .withScheme(ctx.request.uri.scheme)\n+                        .withAuthority(ctx.request.uri.authority)\n+                        .withPath(Path./(\"cb\")),\n+                      claims,\n+                      Some(requestId.toString),\n+                    )\n+                    .toQuery)\n+              ctx.redirect(uri, StatusCodes.Found)\n+            case statusCode =>\n+              Unmarshal(resp).to[String].flatMap { msg =>\n+                logger.error(s\"Failed to authorize with middleware ($statusCode): $msg\")\n+                ctx.complete(\n+                  errorResponse(\n+                    StatusCodes.InternalServerError,\n+                    \"Failed to authorize with middleware\"))\n+              }\n+          }\n+        } yield result\n+    }\n+  }\n+\n+  private def authCallback(\n+      requestId: UUID)(implicit ec: ExecutionContext, system: ActorSystem): Route = ctx => {\n+    authRequests.remove(requestId) match {\n+      case None => complete(StatusCodes.NotFound)(ctx)\n+      case Some(req) =>"
  },
  {
    "id" : "ab68d56b-e618-4dd5-9608-e9c0b28339d0",
    "prId" : 7654,
    "comments" : [
      {
        "id" : "e929c682-e50b-4ba8-b05a-132cbe3062a5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We could in principle consider having a type parameter for whether we run with auth middleware or not which would allow us to get rid of some of the `Option`s and make sure that we either consistently run with auth or consistently donâ€™t run with auth.",
        "createdAt" : "2020-10-13T08:55:34Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "531e025b-43e3-455e-a50e-846b63cca0b7",
        "parentId" : "e929c682-e50b-4ba8-b05a-132cbe3062a5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Wouldnâ€™t do it in this PR and Iâ€™m not sure itâ€™s worth doing at all but at least worth considering.",
        "createdAt" : "2020-10-13T08:55:52Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0b1adc8e2e9d1b4d7828d6b222879ebaabd6947a",
    "line" : 93,
    "diffHunk" : "@@ -171,20 +188,102 @@ class Server(\n   private def getTriggerStatus(uuid: UUID): Vector[(LocalDateTime, String)] =\n     triggerLog.getOrDefault(uuid, Vector.empty)\n \n-  private val route = concat(\n+  // TODO[AH] Make sure this is bounded in size.\n+  private val authRequests: TrieMap[UUID, HttpRequest] = TrieMap()\n+\n+  // This directive requires authorization for the given claims via the auth middleware, if configured.\n+  // If no auth middleware is configured, then the request will proceed without attempting authorization.\n+  //\n+  // Authorization follows the steps defined in `triggers/service/authentication.md`.\n+  // First asking for a token on the `/auth` endpoint and redirecting to `/login` if none was returned.\n+  // If a login is required then this will store the current request in `authRequests`\n+  // and register a callback to proceed with the request once the login flow completed.\n+  private def authorize(claims: AuthRequest.Claims)(\n+      implicit ec: ExecutionContext,\n+      system: ActorSystem): Directive1[Option[String]] = Directive { inner => ctx =>\n+    authConfig match {"
  },
  {
    "id" : "a47c893c-3acc-4d5c-9795-8f80db4d8221",
    "prId" : 7654,
    "comments" : [
      {
        "id" : "3ead8336-9ffb-43c7-9198-8d6a9b7e86a1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We probably should do the party validation during decoding instead of asserting here and then crashing on invalid parties.",
        "createdAt" : "2020-10-13T08:56:42Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "479ca657-3f25-43cc-bcc2-407b3e302a81",
        "parentId" : "3ead8336-9ffb-43c7-9198-8d6a9b7e86a1",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "The trigger service is using the `Party` type from `com.daml.ledger.api.refinements.ApiTypes.Party` which doesn't require validation. Aligning the auth middleware to use the same type avoids this issue.",
        "createdAt" : "2020-10-13T15:56:34Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0b1adc8e2e9d1b4d7828d6b222879ebaabd6947a",
    "line" : null,
    "diffHunk" : "@@ -171,20 +188,102 @@ class Server(\n   private def getTriggerStatus(uuid: UUID): Vector[(LocalDateTime, String)] =\n     triggerLog.getOrDefault(uuid, Vector.empty)\n \n-  private val route = concat(\n+  // TODO[AH] Make sure this is bounded in size.\n+  private val authRequests: TrieMap[UUID, HttpRequest] = TrieMap()\n+\n+  // This directive requires authorization for the given claims via the auth middleware, if configured.\n+  // If no auth middleware is configured, then the request will proceed without attempting authorization.\n+  //\n+  // Authorization follows the steps defined in `triggers/service/authentication.md`.\n+  // First asking for a token on the `/auth` endpoint and redirecting to `/login` if none was returned.\n+  // If a login is required then this will store the current request in `authRequests`\n+  // and register a callback to proceed with the request once the login flow completed.\n+  private def authorize(claims: AuthRequest.Claims)(\n+      implicit ec: ExecutionContext,\n+      system: ActorSystem): Directive1[Option[String]] = Directive { inner => ctx =>\n+    authConfig match {\n+      case NoAuth => inner(Tuple1(None))(ctx)\n+      case AuthMiddleware(authUri) =>\n+        val uri = authUri\n+          .withPath(Path./(\"auth\"))\n+          .withQuery(AuthRequest.Auth(claims).toQuery)\n+        // forward cookies\n+        val cookies = ctx.request.header[headers.Cookie]\n+        val req = HttpRequest(uri = uri, headers = cookies.toList)\n+        import AuthJsonProtocol._\n+        for {\n+          resp <- Http().singleRequest(req)\n+          result <- resp.status match {\n+            case StatusCodes.OK =>\n+              Unmarshal(resp).to[AuthResponse.Authorize].flatMap { auth =>\n+                inner(Tuple1(Some(auth.accessToken)))(ctx)\n+              }\n+            case StatusCodes.Unauthorized =>\n+              val requestId = UUID.randomUUID\n+              authRequests.update(requestId, ctx.request)\n+              val uri = authUri\n+                .withPath(Path./(\"login\"))\n+                .withQuery(\n+                  AuthRequest\n+                    .Login(\n+                      // TODO[AH] Make the redirect URI configurable, especially the authority. E.g. when running behind nginx.\n+                      Uri()\n+                        .withScheme(ctx.request.uri.scheme)\n+                        .withAuthority(ctx.request.uri.authority)\n+                        .withPath(Path./(\"cb\")),\n+                      claims,\n+                      Some(requestId.toString),\n+                    )\n+                    .toQuery)\n+              ctx.redirect(uri, StatusCodes.Found)\n+            case statusCode =>\n+              Unmarshal(resp).to[String].flatMap { msg =>\n+                logger.error(s\"Failed to authorize with middleware ($statusCode): $msg\")\n+                ctx.complete(\n+                  errorResponse(\n+                    StatusCodes.InternalServerError,\n+                    \"Failed to authorize with middleware\"))\n+              }\n+          }\n+        } yield result\n+    }\n+  }\n+\n+  private def authCallback(\n+      requestId: UUID)(implicit ec: ExecutionContext, system: ActorSystem): Route = ctx => {\n+    authRequests.remove(requestId) match {\n+      case None => complete(StatusCodes.NotFound)(ctx)\n+      case Some(req) =>\n+        // Replay the stored request forwarding any new cookies.\n+        val newRequest = req\n+          .addHeader(headers.Cookie(cookies = ctx.request.cookies))\n+        val newCtx = ctx\n+          .withRequest(newRequest)\n+          .withUnmatchedPath(newRequest.uri.path)\n+        route(ec, system)(newCtx)\n+    }\n+  }\n+\n+  private def route(implicit ec: ExecutionContext, system: ActorSystem) = concat(\n     post {\n       concat(\n         // Start a new trigger given its identifier and the party it\n         // should be running as.  Returns a UUID for the newly\n         // started trigger.\n         path(\"v1\" / \"start\") {\n-          entity(as[StartParams]) { params =>\n-            startTrigger(params.party, params.triggerName) match {\n-              case Left(err) =>\n-                complete(errorResponse(StatusCodes.UnprocessableEntity, err))\n-              case Right(triggerInstance) =>\n-                complete(successResponse(triggerInstance))\n-            }\n+          entity(as[StartParams]) {\n+            params =>\n+              val claims =\n+                AuthRequest.Claims(actAs = List(Ref.Party.assertFromString(params.party.toString)))"
  },
  {
    "id" : "dc5a71f6-33f1-4c96-9a80-193ff5185803",
    "prId" : 7654,
    "comments" : [
      {
        "id" : "6aa2bfd3-ab4b-4823-b9bc-4c1634303a1b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":thinking: not sure, seems like that should work. Maybe @S11001001 knows why.",
        "createdAt" : "2020-10-13T08:57:02Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0b1adc8e2e9d1b4d7828d6b222879ebaabd6947a",
    "line" : 184,
    "diffHunk" : "@@ -171,20 +188,102 @@ class Server(\n   private def getTriggerStatus(uuid: UUID): Vector[(LocalDateTime, String)] =\n     triggerLog.getOrDefault(uuid, Vector.empty)\n \n-  private val route = concat(\n+  // TODO[AH] Make sure this is bounded in size.\n+  private val authRequests: TrieMap[UUID, HttpRequest] = TrieMap()\n+\n+  // This directive requires authorization for the given claims via the auth middleware, if configured.\n+  // If no auth middleware is configured, then the request will proceed without attempting authorization.\n+  //\n+  // Authorization follows the steps defined in `triggers/service/authentication.md`.\n+  // First asking for a token on the `/auth` endpoint and redirecting to `/login` if none was returned.\n+  // If a login is required then this will store the current request in `authRequests`\n+  // and register a callback to proceed with the request once the login flow completed.\n+  private def authorize(claims: AuthRequest.Claims)(\n+      implicit ec: ExecutionContext,\n+      system: ActorSystem): Directive1[Option[String]] = Directive { inner => ctx =>\n+    authConfig match {\n+      case NoAuth => inner(Tuple1(None))(ctx)\n+      case AuthMiddleware(authUri) =>\n+        val uri = authUri\n+          .withPath(Path./(\"auth\"))\n+          .withQuery(AuthRequest.Auth(claims).toQuery)\n+        // forward cookies\n+        val cookies = ctx.request.header[headers.Cookie]\n+        val req = HttpRequest(uri = uri, headers = cookies.toList)\n+        import AuthJsonProtocol._\n+        for {\n+          resp <- Http().singleRequest(req)\n+          result <- resp.status match {\n+            case StatusCodes.OK =>\n+              Unmarshal(resp).to[AuthResponse.Authorize].flatMap { auth =>\n+                inner(Tuple1(Some(auth.accessToken)))(ctx)\n+              }\n+            case StatusCodes.Unauthorized =>\n+              val requestId = UUID.randomUUID\n+              authRequests.update(requestId, ctx.request)\n+              val uri = authUri\n+                .withPath(Path./(\"login\"))\n+                .withQuery(\n+                  AuthRequest\n+                    .Login(\n+                      // TODO[AH] Make the redirect URI configurable, especially the authority. E.g. when running behind nginx.\n+                      Uri()\n+                        .withScheme(ctx.request.uri.scheme)\n+                        .withAuthority(ctx.request.uri.authority)\n+                        .withPath(Path./(\"cb\")),\n+                      claims,\n+                      Some(requestId.toString),\n+                    )\n+                    .toQuery)\n+              ctx.redirect(uri, StatusCodes.Found)\n+            case statusCode =>\n+              Unmarshal(resp).to[String].flatMap { msg =>\n+                logger.error(s\"Failed to authorize with middleware ($statusCode): $msg\")\n+                ctx.complete(\n+                  errorResponse(\n+                    StatusCodes.InternalServerError,\n+                    \"Failed to authorize with middleware\"))\n+              }\n+          }\n+        } yield result\n+    }\n+  }\n+\n+  private def authCallback(\n+      requestId: UUID)(implicit ec: ExecutionContext, system: ActorSystem): Route = ctx => {\n+    authRequests.remove(requestId) match {\n+      case None => complete(StatusCodes.NotFound)(ctx)\n+      case Some(req) =>\n+        // Replay the stored request forwarding any new cookies.\n+        val newRequest = req\n+          .addHeader(headers.Cookie(cookies = ctx.request.cookies))\n+        val newCtx = ctx\n+          .withRequest(newRequest)\n+          .withUnmatchedPath(newRequest.uri.path)\n+        route(ec, system)(newCtx)\n+    }\n+  }\n+\n+  private def route(implicit ec: ExecutionContext, system: ActorSystem) = concat(\n     post {\n       concat(\n         // Start a new trigger given its identifier and the party it\n         // should be running as.  Returns a UUID for the newly\n         // started trigger.\n         path(\"v1\" / \"start\") {\n-          entity(as[StartParams]) { params =>\n-            startTrigger(params.party, params.triggerName) match {\n-              case Left(err) =>\n-                complete(errorResponse(StatusCodes.UnprocessableEntity, err))\n-              case Right(triggerInstance) =>\n-                complete(successResponse(triggerInstance))\n-            }\n+          entity(as[StartParams]) {\n+            params =>\n+              val claims =\n+                AuthRequest.Claims(actAs = List(Ref.Party.assertFromString(params.party.toString)))\n+              // TODO[AH] Why do we need to pass ec, system explicitly?"
  },
  {
    "id" : "cde17fc6-946d-4d7d-a2a6-fb82da60994b",
    "prId" : 7654,
    "comments" : [
      {
        "id" : "88f1c7cb-62d3-4552-9142-2d04a474d809",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We obviously also need this on other endpoints but I assume weâ€™re going to add this later.",
        "createdAt" : "2020-10-13T09:41:03Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a47403d5-23b8-46d7-b0d2-e12c672b9187",
        "parentId" : "88f1c7cb-62d3-4552-9142-2d04a474d809",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "I've started with this one since it is the one where the token is actually required for the interaction with the ledger. AFAIK the others don't require authorization as far as the ledger is concerned. Do we also want to use the auth middleware to double as an authorization service for actions on the trigger service itself? E.g. uploading a DAR or stopping a trigger.",
        "createdAt" : "2020-10-13T15:28:22Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "65c9963e-e861-4c2f-b712-919b48118351",
        "parentId" : "88f1c7cb-62d3-4552-9142-2d04a474d809",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "For stopping the trigger I think it makes sense and the same for anything that interacts with a trigger. You want the exact same set of claims for this and I donâ€™t really see how else we would handle it. For DAR uploads, Iâ€™m a bit unsure. Thatâ€™s more of an admin operation. We could either require an admin token via the auth middleware and tie ledger admin privileges to trigger service admin privileges. The alternative would be some separate mechanism for admin operations on the trigger service.",
        "createdAt" : "2020-10-13T16:31:06Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6f60ad52-626a-4a2a-b26d-fe0d0483bfd1",
        "parentId" : "88f1c7cb-62d3-4552-9142-2d04a474d809",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Thanks for clarifying. Stop seems straight forward enough, upload sounds like it needs a bit more thinking. I'll leave these for future PRs. ",
        "createdAt" : "2020-10-16T13:49:26Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0b1adc8e2e9d1b4d7828d6b222879ebaabd6947a",
    "line" : 186,
    "diffHunk" : "@@ -171,20 +188,102 @@ class Server(\n   private def getTriggerStatus(uuid: UUID): Vector[(LocalDateTime, String)] =\n     triggerLog.getOrDefault(uuid, Vector.empty)\n \n-  private val route = concat(\n+  // TODO[AH] Make sure this is bounded in size.\n+  private val authRequests: TrieMap[UUID, HttpRequest] = TrieMap()\n+\n+  // This directive requires authorization for the given claims via the auth middleware, if configured.\n+  // If no auth middleware is configured, then the request will proceed without attempting authorization.\n+  //\n+  // Authorization follows the steps defined in `triggers/service/authentication.md`.\n+  // First asking for a token on the `/auth` endpoint and redirecting to `/login` if none was returned.\n+  // If a login is required then this will store the current request in `authRequests`\n+  // and register a callback to proceed with the request once the login flow completed.\n+  private def authorize(claims: AuthRequest.Claims)(\n+      implicit ec: ExecutionContext,\n+      system: ActorSystem): Directive1[Option[String]] = Directive { inner => ctx =>\n+    authConfig match {\n+      case NoAuth => inner(Tuple1(None))(ctx)\n+      case AuthMiddleware(authUri) =>\n+        val uri = authUri\n+          .withPath(Path./(\"auth\"))\n+          .withQuery(AuthRequest.Auth(claims).toQuery)\n+        // forward cookies\n+        val cookies = ctx.request.header[headers.Cookie]\n+        val req = HttpRequest(uri = uri, headers = cookies.toList)\n+        import AuthJsonProtocol._\n+        for {\n+          resp <- Http().singleRequest(req)\n+          result <- resp.status match {\n+            case StatusCodes.OK =>\n+              Unmarshal(resp).to[AuthResponse.Authorize].flatMap { auth =>\n+                inner(Tuple1(Some(auth.accessToken)))(ctx)\n+              }\n+            case StatusCodes.Unauthorized =>\n+              val requestId = UUID.randomUUID\n+              authRequests.update(requestId, ctx.request)\n+              val uri = authUri\n+                .withPath(Path./(\"login\"))\n+                .withQuery(\n+                  AuthRequest\n+                    .Login(\n+                      // TODO[AH] Make the redirect URI configurable, especially the authority. E.g. when running behind nginx.\n+                      Uri()\n+                        .withScheme(ctx.request.uri.scheme)\n+                        .withAuthority(ctx.request.uri.authority)\n+                        .withPath(Path./(\"cb\")),\n+                      claims,\n+                      Some(requestId.toString),\n+                    )\n+                    .toQuery)\n+              ctx.redirect(uri, StatusCodes.Found)\n+            case statusCode =>\n+              Unmarshal(resp).to[String].flatMap { msg =>\n+                logger.error(s\"Failed to authorize with middleware ($statusCode): $msg\")\n+                ctx.complete(\n+                  errorResponse(\n+                    StatusCodes.InternalServerError,\n+                    \"Failed to authorize with middleware\"))\n+              }\n+          }\n+        } yield result\n+    }\n+  }\n+\n+  private def authCallback(\n+      requestId: UUID)(implicit ec: ExecutionContext, system: ActorSystem): Route = ctx => {\n+    authRequests.remove(requestId) match {\n+      case None => complete(StatusCodes.NotFound)(ctx)\n+      case Some(req) =>\n+        // Replay the stored request forwarding any new cookies.\n+        val newRequest = req\n+          .addHeader(headers.Cookie(cookies = ctx.request.cookies))\n+        val newCtx = ctx\n+          .withRequest(newRequest)\n+          .withUnmatchedPath(newRequest.uri.path)\n+        route(ec, system)(newCtx)\n+    }\n+  }\n+\n+  private def route(implicit ec: ExecutionContext, system: ActorSystem) = concat(\n     post {\n       concat(\n         // Start a new trigger given its identifier and the party it\n         // should be running as.  Returns a UUID for the newly\n         // started trigger.\n         path(\"v1\" / \"start\") {\n-          entity(as[StartParams]) { params =>\n-            startTrigger(params.party, params.triggerName) match {\n-              case Left(err) =>\n-                complete(errorResponse(StatusCodes.UnprocessableEntity, err))\n-              case Right(triggerInstance) =>\n-                complete(successResponse(triggerInstance))\n-            }\n+          entity(as[StartParams]) {\n+            params =>\n+              val claims =\n+                AuthRequest.Claims(actAs = List(Ref.Party.assertFromString(params.party.toString)))\n+              // TODO[AH] Why do we need to pass ec, system explicitly?\n+              authorize(claims)(ec, system) { token =>\n+                startTrigger(params.party, params.triggerName, token) match {"
  },
  {
    "id" : "3a6b6645-1bcd-4179-81b0-7101308b06db",
    "prId" : 7654,
    "comments" : [
      {
        "id" : "3556567a-6af3-4c08-801a-328fb647bf7e",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "This directive seems reasonably generic and could potentially be factored out into a client library to be re-used between multiple clients that use the auth middleware.",
        "createdAt" : "2020-10-16T14:00:38Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0b1adc8e2e9d1b4d7828d6b222879ebaabd6947a",
    "line" : 90,
    "diffHunk" : "@@ -171,20 +186,112 @@ class Server(\n   private def getTriggerStatus(uuid: UUID): Vector[(LocalDateTime, String)] =\n     triggerLog.getOrDefault(uuid, Vector.empty)\n \n-  private val route = concat(\n+  // TODO[AH] Make sure this is bounded in size.\n+  private val authCallbacks: TrieMap[UUID, Route] = TrieMap()\n+\n+  // This directive requires authorization for the given claims via the auth middleware, if configured.\n+  // If no auth middleware is configured, then the request will proceed without attempting authorization.\n+  //\n+  // Authorization follows the steps defined in `triggers/service/authentication.md`.\n+  // First asking for a token on the `/auth` endpoint and redirecting to `/login` if none was returned.\n+  // If a login is required then this will store the current continuation in `authCallbacks`\n+  // to proceed once the login flow completed and authentication succeeded.\n+  private def authorize(claims: AuthRequest.Claims)("
  },
  {
    "id" : "aec852a9-b2d2-458b-99eb-cbec29cd317f",
    "prId" : 7205,
    "comments" : [
      {
        "id" : "f7da8089-c90a-47cf-9cdb-c2e6b9a6d499",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```\r\n20:58:59.417 [TriggerService-akka.actor.default-dispatcher-7] INFO  com.daml.lf.engine.trigger.Server - uploading package cc176cffd4667d83c42c1cba4402a21a24a05deb7ba6684cd1a7462809de72b1\r\n20:58:59.448 [TriggerService-akka.actor.default-dispatcher-7] INFO  com.daml.lf.engine.trigger.Server - uploading package c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd\r\n20:58:59.448 [TriggerService-akka.actor.default-dispatcher-7] INFO  com.daml.lf.engine.trigger.Server - uploading package 733e38d36a2759688a4b2c4cec69d48e7b55ecc8dedc8067b815926c917a182a\r\n<...snip...>\r\n```",
        "createdAt" : "2020-09-02T21:09:51Z",
        "updatedAt" : "2020-09-03T15:40:53Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f5d5af3d7402e279de3eb423f6bf09c7b274c605",
    "line" : 24,
    "diffHunk" : "@@ -79,7 +81,9 @@ class Server(\n     }\n \n     pkgMap foreach {\n-      case (pkgId, pkg) => complete(compiledPackages.addPackage(pkgId, pkg))\n+      case (pkgId, pkg) =>\n+        logger.info(s\"uploading package $pkgId\")"
  },
  {
    "id" : "720ca2fb-096e-4cef-bfcd-81ffbad5d89a",
    "prId" : 7092,
    "comments" : [
      {
        "id" : "3ed7615e-ad94-4a65-9aeb-3435bcb71ddf",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "agreed :slightly_smiling_face: ",
        "createdAt" : "2020-08-20T12:58:04Z",
        "updatedAt" : "2020-08-20T16:39:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e22af68c49f95bd05091eee131ff8aa772dbd148",
    "line" : null,
    "diffHunk" : "@@ -417,55 +418,63 @@ object Server {\n               binding.localAddress.getHostString,\n               binding.localAddress.getPort,\n             )\n-            Behaviors.stopped // Automatically stops all actors.\n-        }\n-        .receiveSignal {\n-          case (_, PostStop) =>\n             // TODO SC until this future returns, connections may still be accepted. Consider\n             // coordinating this future with the actor in some way, or use addToCoordinatedShutdown\n             // (though I have a feeling it will not work out so neatly)\n             discard[Future[akka.Done]](binding.unbind())\n-            Behaviors.same\n+            discard[Try[Unit]](Try(dao.close()))\n+            Behaviors.stopped // Automatically stops all actors.\n+        }\n+        .receiveSignal {\n+          case (_, PostStop) =>\n+            // s11 maybe we should just stop believing side-effects ever work"
  },
  {
    "id" : "4ac55f82-7521-40b1-ad6b-c92f51466f80",
    "prId" : 7079,
    "comments" : [
      {
        "id" : "790a591c-96f8-4170-9a60-027dba33f0fa",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "One of the neat things about `discard`'s signature is that you can specify exactly _what_ is being discarded, which may prompt a discussion about whether it _should be_.",
        "createdAt" : "2020-08-10T23:26:20Z",
        "updatedAt" : "2020-08-11T13:50:51Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eee4148c-f4d4-4004-9222-93579dc138a0",
        "parentId" : "790a591c-96f8-4170-9a60-027dba33f0fa",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch! That definitely looks wrong. If you want to leave fixing this to a separate PR, maybe add a TODO.",
        "createdAt" : "2020-08-11T06:18:40Z",
        "updatedAt" : "2020-08-11T13:50:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9c397010-d8ea-4985-8d96-d8ae632ed302",
        "parentId" : "790a591c-96f8-4170-9a60-027dba33f0fa",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "~It would also make sense to update `com.daml.scalautil.Statement#discard` so it logs an error or warning if passed `Future` fails, else we just drop the error without any notificaiton.~\r\n\r\nScratch it... if you care about the failed future you should NOT use `discard` you should handle the failure. `unbind` looks like a case that we should handle. If you cannot `unbind` a service, you cannot restart it properly and your integration tests would start failing.",
        "createdAt" : "2020-08-11T12:50:09Z",
        "updatedAt" : "2020-08-11T13:50:51Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "99b4cfe2-909a-43c3-b71f-8b335ec7f86d",
        "parentId" : "790a591c-96f8-4170-9a60-027dba33f0fa",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "In any case when unbinding, you should return the `Future` to the client, so it can subscribe for the `Future` completion.",
        "createdAt" : "2020-08-11T12:57:51Z",
        "updatedAt" : "2020-08-11T13:50:51Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f226b5ac-c26d-4c87-8015-65560efefe8f",
        "parentId" : "790a591c-96f8-4170-9a60-027dba33f0fa",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "cdc2e247ab17e5c3133b5a21c000025b511298c0 ",
        "createdAt" : "2020-08-11T14:21:54Z",
        "updatedAt" : "2020-08-11T14:21:54Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6f6e0f2e-d0a5-4bd2-96c7-7564d0b3ae8d",
        "parentId" : "790a591c-96f8-4170-9a60-027dba33f0fa",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Follow-up issue #7086",
        "createdAt" : "2020-08-11T14:56:33Z",
        "updatedAt" : "2020-08-11T14:56:34Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cdc2e247ab17e5c3133b5a21c000025b511298c0",
    "line" : null,
    "diffHunk" : "@@ -414,7 +414,7 @@ object Server {\n         }\n         .receiveSignal {\n           case (_, PostStop) =>\n-            binding.unbind()\n+            discard[Future[akka.Done]](binding.unbind())"
  },
  {
    "id" : "850da65c-c8bd-4aa0-a5c2-541976720991",
    "prId" : 7052,
    "comments" : [
      {
        "id" : "6ad806d7-99f7-4e08-a776-987792048bf6",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "And the hypothesis here was the correct one.\r\n\r\n```\r\n  Last failure message: \"s11 running received in 'starting' state\" did not equal \"running\". (TriggerServiceTest.scala:202)\r\n```",
        "createdAt" : "2020-08-10T23:30:31Z",
        "updatedAt" : "2020-08-11T14:33:08Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "56594f9c-7054-42c6-b430-935262d45b6c",
        "parentId" : "6ad806d7-99f7-4e08-a776-987792048bf6",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "@rohanjr Should our behavior in the `starting` state for these messages equal the behavior in the `running` state?",
        "createdAt" : "2020-08-10T23:31:24Z",
        "updatedAt" : "2020-08-11T14:33:08Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e0c55e7f-fb2d-4e05-871a-bf6c3f01013e",
        "parentId" : "6ad806d7-99f7-4e08-a776-987792048bf6",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "I'm not sure I understand exactly what you mean, but I think the misunderstanding here is due to `TriggerStarted` having a bad name and probably should be called `TriggerRunning`, in which case the log messages are more consistent.",
        "createdAt" : "2020-08-11T00:21:36Z",
        "updatedAt" : "2020-08-11T14:33:08Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2c33a9bc-f417-4bf3-9507-4e6b68134a87",
        "parentId" : "6ad806d7-99f7-4e08-a776-987792048bf6",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Class names would not cause a flaky test, nor would changing them fix it ðŸ™‚ ",
        "createdAt" : "2020-08-11T01:01:04Z",
        "updatedAt" : "2020-08-11T14:33:08Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bc9332ac-465d-4e74-9570-69dad6bf823b",
        "parentId" : "6ad806d7-99f7-4e08-a776-987792048bf6",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh great catch! Let me summarize my understanding just to make sure I didnâ€™t miss anything:\r\n\r\nThe issue is that we are starting up the http server in parallel to restarting the triggers which can result in us receiving the `TriggerStarted` message while we are still starting the http server and currently we do not log anything here causing the test to fail.\r\n\r\nThat definitely looks broken. I see two (non-exclusive) options:\r\n1. Treat the messages the same in starting and in running state. Seems very reasonable to me. We donâ€™t need an http server for this.\r\n2. Only restart triggers after starting the http server. Also seems reasonable to me. I donâ€™t think we need to parallelize this necessarily.",
        "createdAt" : "2020-08-11T09:30:52Z",
        "updatedAt" : "2020-08-11T14:33:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bd7e3ded-f7b4-48ea-a9b3-edd96d611c94",
        "parentId" : "6ad806d7-99f7-4e08-a776-987792048bf6",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "@cocreature I'd rather do (1), because it's pretty much done here already, and I don't trust any coordination here. bd8155d4093a711051992581a8b9d835413b5514",
        "createdAt" : "2020-08-11T13:02:38Z",
        "updatedAt" : "2020-08-11T14:33:08Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "179e1607-9342-4b57-beb4-3094e01544a1",
        "parentId" : "6ad806d7-99f7-4e08-a776-987792048bf6",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Makes sense, I was also leaning towards definitely doing 1, we can always do 2 in addition if it makes things easier but no need to do so for now.",
        "createdAt" : "2020-08-11T13:06:24Z",
        "updatedAt" : "2020-08-11T14:33:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "752180e33c9616e9b9c80ea15680fa33c145df6b",
    "line" : null,
    "diffHunk" : "@@ -444,7 +447,16 @@ object Server {\n           // We got a stop message but haven't completed starting\n           // yet. We cannot stop until starting has completed.\n           starting(wasStopped = true, req = None)\n-        case _ =>\n+\n+        case TriggerStarting(triggerInstance) =>\n+          server.logTriggerStatus(triggerInstance, \"s11 starting received in 'starting' state\")\n+          Behaviors.same\n+\n+        case TriggerStarted(triggerInstance) =>\n+          server.logTriggerStatus(triggerInstance, \"s11 running received in 'starting' state\")\n+          Behaviors.same"
  },
  {
    "id" : "89a71331-d947-4ea6-a94a-89c7a7f3e75c",
    "prId" : 6768,
    "comments" : [
      {
        "id" : "7edcffdd-8f92-4f24-8acc-6c00e1842610",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Host and port here need to be configurable and as mentioned above, I think a URI would be a better choice for an http endport.",
        "createdAt" : "2020-07-17T08:16:28Z",
        "updatedAt" : "2020-07-20T13:14:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "310d5a1bb1a6b68dbb3229efc95a2362d60d7257",
    "line" : null,
    "diffHunk" : "@@ -54,6 +56,11 @@ class Server(\n \n   private var triggerLog: Map[UUID, Vector[(LocalDateTime, String)]] = Map.empty\n \n+  private val authServiceClient = AuthServiceClient(InetAddress.getLoopbackAddress, Port(8089))("
  },
  {
    "id" : "60e93dde-4884-4c97-9a9d-8bdc62e6d38a",
    "prId" : 6556,
    "comments" : [
      {
        "id" : "d74f823a-516f-4bcb-b628-b936ea6d4da2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The logic here feels like it might be in the wrong place. Maybe we should move the code for adding it to the table out of `startTrigger` instead of passing an `Option` in here?",
        "createdAt" : "2020-07-01T07:12:58Z",
        "updatedAt" : "2020-07-01T13:04:53Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c5070cc9-353a-4194-8998-c2d24ca44b87",
        "parentId" : "d74f823a-516f-4bcb-b628-b936ea6d4da2",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Not sure - the steps before and after are required in both cases. Will consider changing later though.",
        "createdAt" : "2020-07-01T13:15:12Z",
        "updatedAt" : "2020-07-01T13:15:12Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "44fd02678b0cd8c79abe85f459fcddbe31dca900",
    "line" : 23,
    "diffHunk" : "@@ -98,11 +103,18 @@ class Server(\n \n   private def startTrigger(\n       credentials: UserCredentials,\n-      triggerName: Identifier): Either[String, JsValue] = {\n+      triggerName: Identifier,\n+      existingInstance: Option[UUID] = None): Either[String, JsValue] = {\n     for {\n       trigger <- Trigger.fromIdentifier(compiledPackages, triggerName)\n-      triggerInstance = UUID.randomUUID\n-      _ <- triggerDao.addRunningTrigger(RunningTrigger(triggerInstance, triggerName, credentials))\n+      triggerInstance <- existingInstance match {"
  },
  {
    "id" : "bf2eb24a-ad88-418d-8493-3d6efdbea3b7",
    "prId" : 6556,
    "comments" : [
      {
        "id" : "1d7280af-3ae6-49f9-b384-803d7c32b7ea",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I believe I brought this up before but let me bring it up again: I feel slightly uneasy about the fact that we are only reading from the DB on startup and then only write to it while using the in-memory state as the source of truth. That seems like it might be easy for things to get out of sync.\r\nDid you consider abstracting over things such that if we run with postgres we always use postgres as the source of truth and donâ€™t even keep the in-memory store?",
        "createdAt" : "2020-07-01T07:18:10Z",
        "updatedAt" : "2020-07-01T13:04:53Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "556622cf-8161-47b4-a60c-d8b0e4a61b55",
        "parentId" : "1d7280af-3ae6-49f9-b384-803d7c32b7ea",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "I'm not sure what you mean - the answer to your last question is we already do that. For tracking running triggers, the `RunningTriggerDao` abstracts over the read and write operations so we only use the in-memory store if we don't have a database and we only use the database if we have one. The one exception to this is the package map which we keep in memory in both cases because it's currently required to create a trigger Runner. The code here is specific to when the service is started up with a database provided. Does that address your concern?",
        "createdAt" : "2020-07-01T12:55:12Z",
        "updatedAt" : "2020-07-01T13:04:53Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "eaa3e2b0-171f-44de-8d9d-04e9a4a353a1",
        "parentId" : "1d7280af-3ae6-49f9-b384-803d7c32b7ea",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "ah that sounds good, sorry for the confusion :+1: You might still be able to make startup a bit less specific to the postgres case.  If you run with an in-memory state reading the list of triggers will simply be empty on startup so there is no harm in going through the same logic.",
        "createdAt" : "2020-07-01T13:00:11Z",
        "updatedAt" : "2020-07-01T13:04:53Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1d6c6c73-63d2-490e-a513-87d7d69093d9",
        "parentId" : "1d7280af-3ae6-49f9-b384-803d7c32b7ea",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "That's true - I started down that route since I already have `persistPackages` do nothing in the in-memory case. It seemed like maybe I would be forcing the abstraction continuing that way, but maybe it makes some sense. I'll consider for a future PR.",
        "createdAt" : "2020-07-01T13:11:43Z",
        "updatedAt" : "2020-07-01T13:11:43Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "44fd02678b0cd8c79abe85f459fcddbe31dca900",
    "line" : 40,
    "diffHunk" : "@@ -333,14 +345,19 @@ object Server {\n         (dao, server)\n       case Some(c) =>\n         val dao = DbTriggerDao(c)\n-        dao.readPackages match {\n+        val server = new Server(ledgerConfig, restartConfig, secretKey, dao)\n+        val recovery: Either[String, Unit] = for {"
  }
]