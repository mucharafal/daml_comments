[
  {
    "id" : "674eef04-ea48-4e82-9a12-d9c3c5258710",
    "prId" : 6296,
    "comments" : [
      {
        "id" : "2405f506-86b0-4753-813e-d61555c90b98",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This case should emit a big fat warning and probably require a CLI flag, similar to how the JSON API requires a flag if you do not use https.",
        "createdAt" : "2020-06-10T17:53:12Z",
        "updatedAt" : "2020-06-10T20:58:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7fbee076-f22a-4c6f-810f-efca7f5732f8",
        "parentId" : "2405f506-86b0-4753-813e-d61555c90b98",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yes, fair enough. I've updated the code such that it provides such a big fat warning. If you'll permit me, I'll put the `--no-secret-key` flag in a follow-up PR.",
        "createdAt" : "2020-06-10T18:19:04Z",
        "updatedAt" : "2020-06-10T20:58:15Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "55b6854d7b7c96e69bc1c9cd22b4ed7f8dffb80f",
    "line" : null,
    "diffHunk" : "@@ -3,42 +3,99 @@\n \n package com.daml.lf.engine.trigger\n \n+import com.daml.lf.data.Ref.Party\n import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n import akka.http.scaladsl.model.HttpRequest\n-\n-import scalaz.syntax.std.option._\n-import scalaz.{\\/}\n-\n import java.nio.charset.StandardCharsets\n+import java.util\n+import java.security.MessageDigest\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n \n case class Unauthorized(message: String) extends Error(message)\n+case class EncryptedToken(token: String)\n+case class UnencryptedToken(token: String)\n \n object TokenManagement {\n \n+  private val key =\n+    sys.env.get(\"TRIGGER_SERVICE_SECRET_KEY\") match {\n+      case Some(key) => key\n+      case None => \"secret key\""
  },
  {
    "id" : "9e135de7-544f-42c2-a20c-cd31fad24166",
    "prId" : 6296,
    "comments" : [
      {
        "id" : "8e387cad-d88e-4307-a9f7-32a7bf26337f",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "You seem to encrypt the token in the `collectFirst` and then decrypt it here to check the party is valid. Perhaps split decryption from the decoding/validation and then save one decryption here. Minor point though.",
        "createdAt" : "2020-06-10T19:53:09Z",
        "updatedAt" : "2020-06-10T20:58:15Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "55b6854d7b7c96e69bc1c9cd22b4ed7f8dffb80f",
    "line" : 102,
    "diffHunk" : "@@ -3,42 +3,94 @@\n \n package com.daml.lf.engine.trigger\n \n+import com.daml.lf.data.Ref.Party\n import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n import akka.http.scaladsl.model.HttpRequest\n-\n-import scalaz.syntax.std.option._\n-import scalaz.{\\/}\n-\n import java.nio.charset.StandardCharsets\n+import java.util\n+import java.security.MessageDigest\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n \n case class Unauthorized(message: String) extends Error(message)\n+case class EncryptedToken(token: String)\n+case class UnencryptedToken(token: String)\n \n object TokenManagement {\n \n+  // TL;DR You can store the SALT in plaintext without any form of\n+  // obfuscation or encryption, but don't just give it out to anyone\n+  // that wants it.\n+  private val SALT = \"jMhKlOuJnM34G6NHkqo9V010GhLAqOpF0BePojHgh1HgNg8^72k\"\n+\n+  // Given 'key', use 'SALT' to produce an AES (Advanced Encryption\n+  // Standard) secret key specification. This utility is called from\n+  // the 'encrypt' and 'decrypt' functions.\n+  private def keyToSpec(key: String): SecretKeySpec = {\n+    var keyBytes: Array[Byte] = (SALT + key).getBytes(\"UTF-8\")\n+    val sha: MessageDigest = MessageDigest.getInstance(\"SHA-1\")\n+    keyBytes = sha.digest(keyBytes)\n+    keyBytes = util.Arrays.copyOf(keyBytes, 16)\n+    new SecretKeySpec(keyBytes, \"AES\")\n+  }\n+\n+  // AES encrypt 'value' given 'key'. Proceed by first encrypting the\n+  // value and then base64 encode the result (the resulting string\n+  // consists of characters strictly in the set [a-z], [A-Z], [0-9] +\n+  // and /.\n+  private def encrypt(key: String, value: UnencryptedToken): EncryptedToken = {\n+    val cipher: Cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\")\n+    cipher.init(Cipher.ENCRYPT_MODE, keyToSpec(key))\n+    val bytes = java.util.Base64.getEncoder\n+      .encode(cipher.doFinal(value.token.getBytes(\"UTF-8\")))\n+    EncryptedToken(new String(bytes, StandardCharsets.UTF_8))\n+  }\n+\n+  // AES decrypt 'value' given 'key'. Proceed by first decoding from\n+  // base64 then decrypt the result.\n+  private def decrypt(key: String, value: EncryptedToken): UnencryptedToken = {\n+    val cipher: Cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\")\n+    cipher.init(Cipher.DECRYPT_MODE, keyToSpec(key))\n+    UnencryptedToken(\n+      new String(\n+        cipher.doFinal(java.util.Base64.getDecoder.decode(value.token)),\n+        StandardCharsets.UTF_8))\n+  }\n+\n   // Utility to get the username and password out of a basic auth\n   // token. By construction we ensure that there will always be two\n-  // components (see 'findCredentials'). We use the first component to\n-  // identify parties.\n-  def decodeCredentials(credentials: UserCredentials): (String, String) = {\n-    val token = credentials.token\n-    val bytes = java.util.Base64.getDecoder.decode(token.getBytes())\n-    val components = new String(bytes, StandardCharsets.UTF_8).split(\":\")\n-    (components(0), components(1))\n+  // components and that the first component is a syntactically valid\n+  // party identifier (see 'findCredentials').\n+  def decodeCredentials(\n+      key: String,\n+      credentials: UserCredentials): (com.daml.ledger.api.refinements.ApiTypes.Party, String) = {\n+    val components = decrypt(key, credentials.token).token.split(\":\")\n+    (com.daml.ledger.api.refinements.ApiTypes.Party(components(0)), components(1))\n   }\n \n-  /*\n-   User : alice\n-   Password : &alC2l3SDS*V\n-   curl -X GET localhost:8080/hello -H \"Authorization: Basic YWxpY2U6JmFsQzJsM1NEUypW\"\n-   */\n-  def findCredentials(req: HttpRequest): Unauthorized \\/ UserCredentials = {\n+  // Parse the user credentials out of a request's headers.\n+  def findCredentials(key: String, req: HttpRequest): Either[String, UserCredentials] = {\n     req.headers\n       .collectFirst {\n         case Authorization(c @ BasicHttpCredentials(username, password)) => {\n-          UserCredentials(c.token())\n+          val token = c.token()\n+          val bytes = java.util.Base64.getDecoder.decode(token.getBytes())\n+          UserCredentials(encrypt(key, UnencryptedToken(new String(bytes, StandardCharsets.UTF_8))))\n         }\n-      }\n-      .toRightDisjunction(Unauthorized(\"missing Authorization header with Basic Token\"))\n+      } match {\n+      // Check the given username conforms to the syntactic\n+      // requirements of a party identifier.\n+      case Some(credentials) =>\n+        decodeCredentials(key, credentials) match {"
  },
  {
    "id" : "6320601b-f7a3-497d-b165-1f7927304583",
    "prId" : 6296,
    "comments" : [
      {
        "id" : "8278d5ca-fa30-48cb-ba27-7213607114e4",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Perhaps import this `Party`? Does it clash with `data.Ref.Party`?",
        "createdAt" : "2020-06-10T19:54:22Z",
        "updatedAt" : "2020-06-10T20:58:15Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "55b6854d7b7c96e69bc1c9cd22b4ed7f8dffb80f",
    "line" : 77,
    "diffHunk" : "@@ -3,42 +3,94 @@\n \n package com.daml.lf.engine.trigger\n \n+import com.daml.lf.data.Ref.Party\n import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n import akka.http.scaladsl.model.HttpRequest\n-\n-import scalaz.syntax.std.option._\n-import scalaz.{\\/}\n-\n import java.nio.charset.StandardCharsets\n+import java.util\n+import java.security.MessageDigest\n+import javax.crypto.Cipher\n+import javax.crypto.spec.SecretKeySpec\n \n case class Unauthorized(message: String) extends Error(message)\n+case class EncryptedToken(token: String)\n+case class UnencryptedToken(token: String)\n \n object TokenManagement {\n \n+  // TL;DR You can store the SALT in plaintext without any form of\n+  // obfuscation or encryption, but don't just give it out to anyone\n+  // that wants it.\n+  private val SALT = \"jMhKlOuJnM34G6NHkqo9V010GhLAqOpF0BePojHgh1HgNg8^72k\"\n+\n+  // Given 'key', use 'SALT' to produce an AES (Advanced Encryption\n+  // Standard) secret key specification. This utility is called from\n+  // the 'encrypt' and 'decrypt' functions.\n+  private def keyToSpec(key: String): SecretKeySpec = {\n+    var keyBytes: Array[Byte] = (SALT + key).getBytes(\"UTF-8\")\n+    val sha: MessageDigest = MessageDigest.getInstance(\"SHA-1\")\n+    keyBytes = sha.digest(keyBytes)\n+    keyBytes = util.Arrays.copyOf(keyBytes, 16)\n+    new SecretKeySpec(keyBytes, \"AES\")\n+  }\n+\n+  // AES encrypt 'value' given 'key'. Proceed by first encrypting the\n+  // value and then base64 encode the result (the resulting string\n+  // consists of characters strictly in the set [a-z], [A-Z], [0-9] +\n+  // and /.\n+  private def encrypt(key: String, value: UnencryptedToken): EncryptedToken = {\n+    val cipher: Cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\")\n+    cipher.init(Cipher.ENCRYPT_MODE, keyToSpec(key))\n+    val bytes = java.util.Base64.getEncoder\n+      .encode(cipher.doFinal(value.token.getBytes(\"UTF-8\")))\n+    EncryptedToken(new String(bytes, StandardCharsets.UTF_8))\n+  }\n+\n+  // AES decrypt 'value' given 'key'. Proceed by first decoding from\n+  // base64 then decrypt the result.\n+  private def decrypt(key: String, value: EncryptedToken): UnencryptedToken = {\n+    val cipher: Cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\")\n+    cipher.init(Cipher.DECRYPT_MODE, keyToSpec(key))\n+    UnencryptedToken(\n+      new String(\n+        cipher.doFinal(java.util.Base64.getDecoder.decode(value.token)),\n+        StandardCharsets.UTF_8))\n+  }\n+\n   // Utility to get the username and password out of a basic auth\n   // token. By construction we ensure that there will always be two\n-  // components (see 'findCredentials'). We use the first component to\n-  // identify parties.\n-  def decodeCredentials(credentials: UserCredentials): (String, String) = {\n-    val token = credentials.token\n-    val bytes = java.util.Base64.getDecoder.decode(token.getBytes())\n-    val components = new String(bytes, StandardCharsets.UTF_8).split(\":\")\n-    (components(0), components(1))\n+  // components and that the first component is a syntactically valid\n+  // party identifier (see 'findCredentials').\n+  def decodeCredentials(\n+      key: String,\n+      credentials: UserCredentials): (com.daml.ledger.api.refinements.ApiTypes.Party, String) = {\n+    val components = decrypt(key, credentials.token).token.split(\":\")\n+    (com.daml.ledger.api.refinements.ApiTypes.Party(components(0)), components(1))"
  },
  {
    "id" : "8a0f8493-d006-4991-91ae-eea917045aa6",
    "prId" : 6279,
    "comments" : [
      {
        "id" : "aa1a47cb-3fe9-4aa4-adc1-dd85f7b2e40f",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Any reason you use `\\/` here instead of `Either` which we use everywhere else? If not it would be nice to use the latter for consistency.",
        "createdAt" : "2020-06-09T19:16:18Z",
        "updatedAt" : "2020-06-10T13:34:38Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "72513778-6992-4672-949f-537ce73dc7cd",
        "parentId" : "aa1a47cb-3fe9-4aa4-adc1-dd85f7b2e40f",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Maybe in another PR? That's not introduced here",
        "createdAt" : "2020-06-09T20:23:08Z",
        "updatedAt" : "2020-06-10T13:34:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a1b4263b-bbbd-42db-90e6-1cfbf37f7d55",
        "parentId" : "aa1a47cb-3fe9-4aa4-adc1-dd85f7b2e40f",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Sure, it's not the most important thing here",
        "createdAt" : "2020-06-09T20:30:39Z",
        "updatedAt" : "2020-06-10T13:34:38Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b9464687f8f030036b33ef328663eeb5ef13160c",
    "line" : null,
    "diffHunk" : "@@ -3,60 +3,41 @@\n \n package com.daml.lf.engine.trigger\n \n-import akka.http.scaladsl.model.headers.{Authorization, OAuth2BearerToken}\n+import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n import akka.http.scaladsl.model.HttpRequest\n \n-import com.daml.ledger.api.auth.{AuthServiceJWTCodec}\n-import com.daml.jwt.domain.Jwt\n-import com.daml.jwt.{JwtDecoder}\n-import com.daml.jwt.domain.{DecodedJwt}\n-\n-import scalaz.syntax.show._\n import scalaz.syntax.std.option._\n-import scalaz.{\\/, -\\/}\n+import scalaz.{\\/}\n+\n+import java.nio.charset.StandardCharsets\n \n case class Unauthorized(message: String) extends Error(message)\n-case class JwtPayload(ledgerId: String, applicationId: String, party: String)\n \n object TokenManagement {\n \n-  def decodeJwt(jwt: Jwt): Unauthorized \\/ DecodedJwt[String] = {\n-    JwtDecoder.decode(jwt).leftMap(e => Unauthorized(e.shows))\n+  // Utility to get the username and password out of a basic auth\n+  // token. By construction we ensure that there will always be two\n+  // components (see 'findCredentials'). We use the first component to\n+  // identify parties.\n+  def decodeCredentials(token: String): (String, String) = {\n+    val bytes = java.util.Base64.getDecoder.decode(token.getBytes())\n+    val components = new String(bytes, StandardCharsets.UTF_8).split(\":\")\n+    (components(0), components(1))\n   }\n \n-  def findJwt(req: HttpRequest): Unauthorized \\/ Jwt = {\n+  /*\n+   User : alice\n+   Password : &alC2l3SDS*V\n+   curl -X GET localhost:8080/hello -H \"Authorization: Basic YWxpY2U6JmFsQzJsM1NEUypW\"\n+   */\n+  def findCredentials(req: HttpRequest): Unauthorized \\/ String = {"
  },
  {
    "id" : "771b565e-a0e7-4ff1-b5a2-7fcf8611202e",
    "prId" : 6279,
    "comments" : [
      {
        "id" : "f5463cc3-ef8c-439f-933e-cea76dde4df2",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "I think we need to validate the token. It's passed into an SQL query so it at least needs to not have single quotes in it. We should probably make sure the username is a valid party id otherwise ledger requests will fail.",
        "createdAt" : "2020-06-09T19:53:42Z",
        "updatedAt" : "2020-06-10T13:34:38Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b9464687f8f030036b33ef328663eeb5ef13160c",
    "line" : 34,
    "diffHunk" : "@@ -3,60 +3,41 @@\n \n package com.daml.lf.engine.trigger\n \n-import akka.http.scaladsl.model.headers.{Authorization, OAuth2BearerToken}\n+import akka.http.scaladsl.model.headers.{Authorization, BasicHttpCredentials}\n import akka.http.scaladsl.model.HttpRequest\n \n-import com.daml.ledger.api.auth.{AuthServiceJWTCodec}\n-import com.daml.jwt.domain.Jwt\n-import com.daml.jwt.{JwtDecoder}\n-import com.daml.jwt.domain.{DecodedJwt}\n-\n-import scalaz.syntax.show._\n import scalaz.syntax.std.option._\n-import scalaz.{\\/, -\\/}\n+import scalaz.{\\/}\n+\n+import java.nio.charset.StandardCharsets\n \n case class Unauthorized(message: String) extends Error(message)\n-case class JwtPayload(ledgerId: String, applicationId: String, party: String)\n \n object TokenManagement {\n \n-  def decodeJwt(jwt: Jwt): Unauthorized \\/ DecodedJwt[String] = {\n-    JwtDecoder.decode(jwt).leftMap(e => Unauthorized(e.shows))\n+  // Utility to get the username and password out of a basic auth\n+  // token. By construction we ensure that there will always be two\n+  // components (see 'findCredentials'). We use the first component to\n+  // identify parties.\n+  def decodeCredentials(token: String): (String, String) = {\n+    val bytes = java.util.Base64.getDecoder.decode(token.getBytes())\n+    val components = new String(bytes, StandardCharsets.UTF_8).split(\":\")"
  }
]