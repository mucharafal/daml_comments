[
  {
    "id" : "5771e43d-9c45-4fcd-9674-81c405dd3a6d",
    "prId" : 7654,
    "comments" : [
      {
        "id" : "a6d8f324-6bac-4e3f-9b78-fe272e7d9f6f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Unbinding the middleware first seems more intuitive to me given that it connects to the oauth server.",
        "createdAt" : "2020-10-16T14:56:33Z",
        "updatedAt" : "2020-10-16T15:18:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "17b3f5af-e3fd-4490-abfb-f14bbb6ddbc7",
        "parentId" : "a6d8f324-6bac-4e3f-9b78-fe272e7d9f6f",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Fair enough, fixed.",
        "createdAt" : "2020-10-16T15:15:49Z",
        "updatedAt" : "2020-10-16T15:18:19Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0b1adc8e2e9d1b4d7828d6b222879ebaabd6947a",
    "line" : 90,
    "diffHunk" : "@@ -77,9 +88,43 @@ object TriggerServiceFixture extends StrictLogging {\n \n     val ledgerId = LedgerId(testName)\n     val applicationId = ApplicationId(testName)\n+    val authF: Future[(AuthConfig, () => Future[Unit])] = authTestConfig match {\n+      case None => Future((NoAuth, () => Future(())))\n+      case Some(AuthTestConfig(secret, _)) =>\n+        for {\n+          oauth <- OAuthServer.start(\n+            OAuthConfig(\n+              port = Port.Dynamic,\n+              ledgerId = LedgerId.unwrap(ledgerId),\n+              // TODO[AH] Choose application ID, see https://github.com/digital-asset/daml/issues/7671\n+              applicationId = None,\n+              jwtSecret = secret,\n+            ))\n+          serverUri = Uri()\n+            .withScheme(\"http\")\n+            .withAuthority(oauth.localAddress.getHostString, oauth.localAddress.getPort)\n+          middleware <- MiddlewareServer.start(\n+            MiddlewareConfig(\n+              port = Port.Dynamic,\n+              oauthAuth = serverUri.withPath(Path./(\"authorize\")),\n+              oauthToken = serverUri.withPath(Path./(\"token\")),\n+              clientId = \"oauth-middleware-id\",\n+              clientSecret = \"oauth-middleware-secret\",\n+            ))\n+          middlewareUri = Uri()\n+            .withScheme(\"http\")\n+            .withAuthority(middleware.localAddress.getHostString, middleware.localAddress.getPort)\n+          cleanup = () =>\n+            for {\n+              _ <- oauth.unbind()\n+              _ <- middleware.unbind()"
  },
  {
    "id" : "627c81d9-a1ef-455f-b0e3-b120ffcb93ed",
    "prId" : 6927,
    "comments" : [
      {
        "id" : "9a6ed78b-633d-4cad-8854-4853b20eb087",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It looks like you are now starting toxiproxy in parallel with Sandbox. I believe that is racy, consider the following scenario:\r\n\r\n1. `LockedFreePort.find()` will bind to port 0 to get a free port X and immediately stop listening on that port and give you back the port X it got allocated by the OS.\r\n2. Now port X is free, Sandbox starts up bindings to port 0. This doesn’t go through the locking mechanism afaik as it is only used in the test library. The OS is free to allocate Sandbox to port X since nothing is listening on this.\r\n3. Now toxiproxy is started on port X which is already occupied by Sandbox.\r\n\r\nAt least on Linux, this is very hard to trigger since the Kernel will not immediately reuse the port so Sandbox will be allocated to a different port. Not quite sure about other platforms but I don’t recall seeing issues with this there either. So we probably don’t have to worry about this for now but it’s worth keeping in mind. You could fix it fairly easily by sequencing `toxiproxyF` before starting Sandbox or only create the future after you got `ledgerPort`.",
        "createdAt" : "2020-07-30T06:21:49Z",
        "updatedAt" : "2020-07-30T06:22:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3d62388c-bc9d-448b-af56-1bafed6f26c0",
        "parentId" : "9a6ed78b-633d-4cad-8854-4853b20eb087",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Ahh interesting. I'll keep an eye on it and probably reorder the futures later.",
        "createdAt" : "2020-07-30T17:43:34Z",
        "updatedAt" : "2020-07-30T17:44:08Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d2b26221-455d-4727-800a-2648609a76c0",
        "parentId" : "9a6ed78b-633d-4cad-8854-4853b20eb087",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Something like this maybe?\r\n\r\n```\r\n- should give an 'unauthorized' response for a stop request without an authorization header *** FAILED *** (123 milliseconds)\r\n  java.lang.NullPointerException:\r\n  at com.daml.ports.PortLock$Locked.unlock(PortLock.scala:55)\r\n  at com.daml.ports.PortLock$.lock(PortLock.scala:41)\r\n  at com.daml.ports.LockedFreePort$.find(LockedFreePort.scala:15)\r\n  at com.daml.lf.engine.trigger.TriggerServiceFixture$.$anonfun$withTriggerService$1(TriggerServiceFixture.scala:65)\r\n```",
        "createdAt" : "2020-07-30T18:30:07Z",
        "updatedAt" : "2020-07-30T18:30:07Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9461ca71-d0f5-48df-9b22-321b9049b8c5",
        "parentId" : "9a6ed78b-633d-4cad-8854-4853b20eb087",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "That could be it! I'll submit the PR sequencing `toxiproxyF` before the sandbox as it's an easy change anyway.",
        "createdAt" : "2020-07-30T18:43:55Z",
        "updatedAt" : "2020-07-30T18:43:56Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2b3c3612-e17e-4661-be24-2d7131a163e4",
        "parentId" : "9a6ed78b-633d-4cad-8854-4853b20eb087",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "#6939 for the one, and 69d5d87c904add3ee19566f7ce61d00d3c34db3c for the other.",
        "createdAt" : "2020-07-30T19:36:32Z",
        "updatedAt" : "2020-07-30T19:36:32Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9da65d203728c37c05e82c1cdcd4581d76e66879",
    "line" : 23,
    "diffHunk" : "@@ -56,27 +56,28 @@ object TriggerServiceFixture {\n     val host = InetAddress.getLoopbackAddress\n     val isWindows: Boolean = sys.props(\"os.name\").toLowerCase.contains(\"windows\")\n \n-    // Launch a toxiproxy instance. Wait on it to be ready to accept\n-    // connections.\n-    val toxiProxyExe =\n-      if (!isWindows)\n-        BazelRunfiles.rlocation(\"external/toxiproxy_dev_env/bin/toxiproxy-cmd\")\n-      else\n-        BazelRunfiles.rlocation(\"external/toxiproxy_dev_env/toxiproxy-server-windows-amd64.exe\")\n-    val toxiProxyPort = LockedFreePort.find()\n-    val toxiProxyProc =\n-      Process(Seq(toxiProxyExe, \"--port\", toxiProxyPort.port.value.toString)).run()\n-    RetryStrategy.constant(attempts = 3, waitTime = 2.seconds)((_, _) =>\n-      Future(toxiProxyPort.testAndUnlock(host)))\n-    val toxiProxyClient = new ToxiproxyClient(host.getHostName, toxiProxyPort.port.value)\n+    // Launch a Toxiproxy server. Wait on it to be ready to accept connections and\n+    // then create a client.\n+    val toxiproxyExe =\n+      if (!isWindows) BazelRunfiles.rlocation(\"external/toxiproxy_dev_env/bin/toxiproxy-cmd\")\n+      else BazelRunfiles.rlocation(\"external/toxiproxy_dev_env/toxiproxy-server-windows-amd64.exe\")\n+    val toxiproxyF: Future[(Process, ToxiproxyClient)] = for {\n+      toxiproxyPort <- Future(LockedFreePort.find())"
  },
  {
    "id" : "084d5773-42f2-4888-9d75-8c3ed2353bca",
    "prId" : 6926,
    "comments" : [
      {
        "id" : "454e2305-0491-4f59-8110-465ddffced3c",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Ah, so the problem was that the shutdown here would race with the second use of `withTriggerService` in the test?",
        "createdAt" : "2020-07-30T15:33:39Z",
        "updatedAt" : "2020-08-04T00:41:27Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6368ad95-32d7-4810-a082-d02f73cb9d27",
        "parentId" : "454e2305-0491-4f59-8110-465ddffced3c",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Yes.",
        "createdAt" : "2020-07-30T19:44:59Z",
        "updatedAt" : "2020-08-04T00:41:27Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d621fa244b09f829603ce2baad68676abb485e58",
    "line" : 24,
    "diffHunk" : "@@ -163,14 +163,21 @@ object TriggerServiceFixture {\n       a <- testFn(uri, client, ledgerProxy)\n     } yield a\n \n-    fa.onComplete { _ =>"
  },
  {
    "id" : "f7d28d5c-86a3-4c3a-aa91-07376d61481b",
    "prId" : 6926,
    "comments" : [
      {
        "id" : "d13ea66c-7a98-4db3-9b48-f5f18af148a5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What exactly went wrong with `Future.sequence`? As far as I understand `Future.sequence` is not fail fast so it shouldn’t stop anything from running. Does running these things in parallel cause issues?",
        "createdAt" : "2020-08-04T05:03:33Z",
        "updatedAt" : "2020-08-04T05:03:34Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "94b07919-4c97-46b4-bb14-89404299bc96",
        "parentId" : "d13ea66c-7a98-4db3-9b48-f5f18af148a5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Actually, I think I might have misread something and it is fail fast which probably explains the issue here.",
        "createdAt" : "2020-08-04T05:04:40Z",
        "updatedAt" : "2020-08-04T05:04:41Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5b4f16c6-5408-4d5b-9cb9-af56731ee5f9",
        "parentId" : "d13ea66c-7a98-4db3-9b48-f5f18af148a5",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I don't think `Future.sequence` is fail-fast. It's passed already-running Futures and AFAIK, there's no way to stop them.",
        "createdAt" : "2020-08-04T09:18:31Z",
        "updatedAt" : "2020-08-04T09:18:31Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "95cb8e5f-3143-4fb9-8f88-52526df4453e",
        "parentId" : "d13ea66c-7a98-4db3-9b48-f5f18af148a5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "So the issue was that we tried to stop things in parallel? I’m not quite sure why that’s a problem.",
        "createdAt" : "2020-08-04T09:23:32Z",
        "updatedAt" : "2020-08-04T09:23:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6dd00db0-ad2d-435d-a8ae-8996a4417881",
        "parentId" : "d13ea66c-7a98-4db3-9b48-f5f18af148a5",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "It is fail-fast in the sense that if one future fails, it completed, allowing the next step (the restart) to proceed despite something else's shutdown being in progress.",
        "createdAt" : "2020-08-04T12:09:18Z",
        "updatedAt" : "2020-08-04T12:09:18Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a436343d-e7e7-48d9-ac3f-a8e659e8819f",
        "parentId" : "d13ea66c-7a98-4db3-9b48-f5f18af148a5",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I could possibly restore the parallel shutdown, if the forced success of this chain is really the relevant piece, but would rather get this in as is first.",
        "createdAt" : "2020-08-04T12:13:24Z",
        "updatedAt" : "2020-08-04T12:13:24Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1f57731a-82fa-4e05-b0f7-2d1a47de4959",
        "parentId" : "d13ea66c-7a98-4db3-9b48-f5f18af148a5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Makes sense, thanks for the explanation! I’m not worried about losing parallelism so totally fine to get this in and ignore this.",
        "createdAt" : "2020-08-04T12:14:40Z",
        "updatedAt" : "2020-08-04T12:14:41Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d621fa244b09f829603ce2baad68676abb485e58",
    "line" : 29,
    "diffHunk" : "@@ -134,15 +136,28 @@ object TriggerServiceFixture {\n       a <- testFn(uri, client, ledgerProxy)\n     } yield a\n \n-    fa.onComplete { _ =>\n-      serviceF.foreach({ case (_, system) => system ! Stop })\n-      ledgerF.foreach(_._1.close())\n-      toxiproxyF.foreach(_._1.destroy)\n+    fa.transformWith { ta =>\n+      for {"
  },
  {
    "id" : "df10d0b7-5d91-4708-adfe-c11c7b85e94f",
    "prId" : 6309,
    "comments" : [
      {
        "id" : "e59caa05-ac31-4cba-9853-e3e439096eda",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\n        noSecretKey = true // Use the default secret for testing.\r\n```",
        "createdAt" : "2020-06-11T22:18:15Z",
        "updatedAt" : "2020-06-11T22:19:34Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df38038340aa1699372867c97fee63f61f3bd093",
    "line" : 6,
    "diffHunk" : "@@ -122,7 +122,8 @@ object TriggerServiceFixture {\n         ServiceConfig.DefaultMaxFailureNumberOfRetries,\n         ServiceConfig.DefaultFailureRetryTimeRange,\n         dar,\n-        jdbcConfig\n+        jdbcConfig,\n+        noSecretKey = true // That's ok, use the default."
  },
  {
    "id" : "5afc9161-abfd-42e4-90ca-4936dd507d6f",
    "prId" : 6122,
    "comments" : [
      {
        "id" : "0acdc283-ddf5-48ac-af7f-ef56359dd1d4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Please don’t do this. Define it as a `dev_env_tool` like I suggested and locate that.",
        "createdAt" : "2020-05-27T12:26:54Z",
        "updatedAt" : "2020-05-27T15:24:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "979096a3-4220-43de-8c5e-392f3a2a1568",
        "parentId" : "0acdc283-ddf5-48ac-af7f-ef56359dd1d4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Gimme a break Moritz! I'm working on it!!",
        "createdAt" : "2020-05-27T12:32:05Z",
        "updatedAt" : "2020-05-27T15:24:25Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0aaa63e8-64eb-49cd-a2c3-797a808ab790",
        "parentId" : "0acdc283-ddf5-48ac-af7f-ef56359dd1d4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Sorry I got a bit irritated that you just pushed this commit after my original suggestion to use `dev_env_tool` :slightly_smiling_face: ",
        "createdAt" : "2020-05-27T12:33:31Z",
        "updatedAt" : "2020-05-27T15:24:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "abcf29c8ce2dee7067ebb761f39ae074de735994",
    "line" : null,
    "diffHunk" : "@@ -60,10 +60,15 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n-    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // Launch a toxiproxy instance. Wait on it to be ready to accept\n     // connections.\n     val host = InetAddress.getLoopbackAddress()\n-    val toxiProxyExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyExe =\n+      if (sys.props(\"os.name\").toLowerCase.contains(\"windows\")) {"
  },
  {
    "id" : "b9f6a4bf-15b5-49aa-bfe1-2e1188a4da3f",
    "prId" : 6122,
    "comments" : [
      {
        "id" : "414e0ce6-f3f3-4bce-9c87-c17afbaf06c5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "if it still fails, maybe try adding a `.exe` to the end on Windows or maybe use backslashes.",
        "createdAt" : "2020-05-27T14:02:06Z",
        "updatedAt" : "2020-05-27T15:24:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "abcf29c8ce2dee7067ebb761f39ae074de735994",
    "line" : null,
    "diffHunk" : "@@ -60,11 +60,12 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n-    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // Launch a toxiproxy instance. Wait on it to be ready to accept\n     // connections.\n     val host = InetAddress.getLoopbackAddress()\n-    val toxiProxyExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n-    val toxiProxyPort = findFreePort()\n+    val toxiProxyExe = BazelRunfiles.rlocation(\"external/toxiproxy_dev_env/toxiproxy\")"
  },
  {
    "id" : "c173db76-64a4-4402-a458-4d4e21b52393",
    "prId" : 6122,
    "comments" : [
      {
        "id" : "fa6e39f2-0cc5-410b-bcd8-f0401c614bc1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Seems like we can remove this now?",
        "createdAt" : "2020-05-27T15:23:46Z",
        "updatedAt" : "2020-05-27T15:24:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "287fb170-4716-4e09-ab7c-8748f4040e70",
        "parentId" : "fa6e39f2-0cc5-410b-bcd8-f0401c614bc1",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "yep, just did.",
        "createdAt" : "2020-05-27T15:25:01Z",
        "updatedAt" : "2020-05-27T15:25:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "abcf29c8ce2dee7067ebb761f39ae074de735994",
    "line" : null,
    "diffHunk" : "@@ -60,10 +60,11 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n-    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // Launch a toxiproxy instance. Wait on it to be ready to accept\n     // connections.\n     val host = InetAddress.getLoopbackAddress()\n-    val toxiProxyExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyExe = BazelRunfiles.rlocation(System.getProperty(\"com.daml.toxiproxy\"))\n+    println(toxiProxyExe.toString)"
  },
  {
    "id" : "cf09dc75-7feb-496c-be38-979cfc852314",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "ef6c7398-3990-4b3f-8e6f-e15afc9e073d",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Is the port configurable?",
        "createdAt" : "2020-05-26T20:19:18Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "30a5dd4a-3a0d-4486-8f8f-6f798a45d510",
        "parentId" : "ef6c7398-3990-4b3f-8e6f-e15afc9e073d",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Maybe. I have to look into it. ",
        "createdAt" : "2020-05-26T20:30:34Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e89efc54-d653-47b7-afc0-6b7f8faee161",
        "parentId" : "ef6c7398-3990-4b3f-8e6f-e15afc9e073d",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Reading into the code, it looks like the port is configurable. So you can set it to another literal. Support for dynamic port allocation looks lacking. Overall I would say this test is likely to remain necessarily exclusive.",
        "createdAt" : "2020-05-26T20:36:42Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4f98e882-9ffb-4447-99f7-b30458a8e7c8",
        "parentId" : "ef6c7398-3990-4b3f-8e6f-e15afc9e073d",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "In the Haskell test libraries we have a utility to find and return a free port, which one pass to services to avoid hardcoding the port number. Not suggesting you have to do it in this PR, but there might be something similar in the Scala test utils for doing that and avoiding exclusivity.",
        "createdAt" : "2020-05-26T20:46:55Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "25f1a856-4ead-4bb2-b684-0ec7101236ab",
        "parentId" : "ef6c7398-3990-4b3f-8e6f-e15afc9e073d",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "That's interesting!",
        "createdAt" : "2020-05-26T20:57:13Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -44,12 +46,44 @@ object TriggerServiceFixture {\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n \n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections. Note that it binds to a hard-coded port (8474) here."
  },
  {
    "id" : "60848a32-7d32-45c7-a048-cdf2c4824168",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "5f6d76b2-c14d-4727-956d-8aa0b0066799",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Why do we need to hardcode the sandbox port? Can't we use the `port` value below?",
        "createdAt" : "2020-05-26T20:21:33Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0113d931-c990-4a85-b406-3d966657f3c6",
        "parentId" : "5f6d76b2-c14d-4727-956d-8aa0b0066799",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "We might be able to do dynamic port configuration by reordering things. I don't know yet!",
        "createdAt" : "2020-05-26T20:31:07Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "713124e2-d3bb-45ed-aaa4-d9b8c916dfd3",
        "parentId" : "5f6d76b2-c14d-4727-956d-8aa0b0066799",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "But of course, you observe that the proxy needs the sandbox port naturally.",
        "createdAt" : "2020-05-26T20:31:32Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a9857fd6-b78b-413e-9f4a-9bdbf890a1d8",
        "parentId" : "5f6d76b2-c14d-4727-956d-8aa0b0066799",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Looking at it again, I am convinced we can reorder the program so the sandbox does dynamic port allocation. I don't see that there's any particular merit in it though if the Toxiproxy doesn't support dynamic port allocation (as noted elsewhere in this ticket - it doesn't seem to).\r\n ",
        "createdAt" : "2020-05-26T20:41:37Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9ba2c5bd-6a8b-4c22-8eb1-4097311879dd",
        "parentId" : "5f6d76b2-c14d-4727-956d-8aa0b0066799",
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "It seems like better practice to keep it dynamic where practical (like here) and later try to give a port number to the toxiproxy client which we find to be free.",
        "createdAt" : "2020-05-26T20:49:22Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -44,12 +46,44 @@ object TriggerServiceFixture {\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n \n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections. Note that it binds to a hard-coded port (8474) here.\n+    val toxiProxy =\n+      Process(BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", 8474)\n+        channel.close()\n+        scanning = false\n+      } catch {\n+        case _: Throwable =>\n+          retries = retries + 1\n+          if (retries >= 3) {\n+            println(\"Toxiproxy failed to start. Terminating with errors.\")\n+            System.exit(1) // Give up.\n+          } else {\n+            Thread.sleep(2000)\n+          }\n+      }\n+    }\n+\n+    // The sandbox port is also hard-coded.\n+    val client = new ToxiproxyClient(\"localhost\", 8474);\n+    val sandboxProxy: Proxy =\n+      client.createProxy(\"sandbox\", \"localhost:6866\", \"localhost:6865\")"
  },
  {
    "id" : "29465ec8-a932-4d7a-8c02-b1839f4c5d5b",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "96bfd956-1cd9-4d78-9775-8207414adf23",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Is starting Toxiproxy flaky for some reason or does it just take a while?",
        "createdAt" : "2020-05-26T20:25:39Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c9ebcf31-e581-4eba-9c4b-330981453f4d",
        "parentId" : "96bfd956-1cd9-4d78-9775-8207414adf23",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "It takes a while to bind to its port. You can't rush into the tests while it's not listening.",
        "createdAt" : "2020-05-26T20:32:09Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -44,12 +46,44 @@ object TriggerServiceFixture {\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n \n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections. Note that it binds to a hard-coded port (8474) here.\n+    val toxiProxy =\n+      Process(BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", 8474)\n+        channel.close()\n+        scanning = false\n+      } catch {\n+        case _: Throwable =>\n+          retries = retries + 1\n+          if (retries >= 3) {\n+            println(\"Toxiproxy failed to start. Terminating with errors.\")"
  },
  {
    "id" : "f6e0a88c-dfd4-454c-9b31-1701ed0f320e",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "84d5b0b3-fabe-4083-9234-c8ffd1037bd9",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\n      ledger <- Future(new SandboxServer(ledgerConfig(Port.Dynamic, dars, ledgerId), mat))\r\n```\r\n(Just a name for `Port(0)`)",
        "createdAt" : "2020-05-26T22:48:46Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "939ca3be-da39-40a3-b3ca-579bcac482f8",
        "parentId" : "84d5b0b3-fabe-4083-9234-c8ffd1037bd9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-05-26T23:18:14Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,61 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" ++ toxiProxyPort.toString\n+    val toxiProxyProc = Process(toxiCmd).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", toxiProxyPort)\n+        channel.close()\n+        scanning = false\n+      } catch {\n+        case _: Throwable =>\n+          retries = retries + 1\n+          if (retries >= 3) {\n+            println(\"Toxiproxy failed to start. Terminating with errors.\")\n+            System.exit(1) // Give up.\n+          } else {\n+            Thread.sleep(2000)\n+          }\n+      }\n+    }\n+    val toxiProxyClient = new ToxiproxyClient(\"localhost\", toxiProxyPort);\n \n     val ledgerId = LedgerId(testName)\n     val applicationId = ApplicationId(testName)\n     val ledgerF = for {\n-      ledger <- Future(new SandboxServer(ledgerConfig(Port.Dynamic, dars, ledgerId), mat))\n-      port <- ledger.portF\n-    } yield (ledger, port.value)\n+      ledger <- Future(new SandboxServer(ledgerConfig(Port(0), dars, ledgerId), mat))"
  },
  {
    "id" : "79149f18-9a5d-429e-a200-967a79a43038",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "7f32f9a5-e14f-4916-8521-684ef36a5394",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "It looks like these two bindings are really just `val`s, so you can use `=` instead of `<- Future`.",
        "createdAt" : "2020-05-26T22:52:53Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "edee5024-48c6-4b20-a1f2-12d508ff8b77",
        "parentId" : "7f32f9a5-e14f-4916-8521-684ef36a5394",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-05-26T23:19:53Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,61 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" ++ toxiProxyPort.toString\n+    val toxiProxyProc = Process(toxiCmd).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", toxiProxyPort)\n+        channel.close()\n+        scanning = false\n+      } catch {\n+        case _: Throwable =>\n+          retries = retries + 1\n+          if (retries >= 3) {\n+            println(\"Toxiproxy failed to start. Terminating with errors.\")\n+            System.exit(1) // Give up.\n+          } else {\n+            Thread.sleep(2000)\n+          }\n+      }\n+    }\n+    val toxiProxyClient = new ToxiproxyClient(\"localhost\", toxiProxyPort);\n \n     val ledgerId = LedgerId(testName)\n     val applicationId = ApplicationId(testName)\n     val ledgerF = for {\n-      ledger <- Future(new SandboxServer(ledgerConfig(Port.Dynamic, dars, ledgerId), mat))\n-      port <- ledger.portF\n-    } yield (ledger, port.value)\n+      ledger <- Future(new SandboxServer(ledgerConfig(Port(0), dars, ledgerId), mat))\n+      sandboxPort <- ledger.portF\n+      ledgerProxyPort <- Future(findFreePort())\n+      ledgerProxy <- Future(\n+        toxiProxyClient\n+          .createProxy(\"sandbox\", s\"localhost:${ledgerProxyPort}\", s\"localhost:${sandboxPort}\"))"
  },
  {
    "id" : "ec10eadb-1e4c-475c-b17b-409151e31ac8",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "469b3718-99b0-44ae-b463-415fb748cc09",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "This looks unused?",
        "createdAt" : "2020-05-26T22:58:25Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "64ef2c95-21cc-4b51-889e-c540d3ba41fb",
        "parentId" : "469b3718-99b0-44ae-b463-415fb748cc09",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "It is right now but I anticipate using it in the next PR",
        "createdAt" : "2020-05-26T23:20:30Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,61 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" ++ toxiProxyPort.toString\n+    val toxiProxyProc = Process(toxiCmd).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", toxiProxyPort)\n+        channel.close()\n+        scanning = false\n+      } catch {\n+        case _: Throwable =>\n+          retries = retries + 1\n+          if (retries >= 3) {\n+            println(\"Toxiproxy failed to start. Terminating with errors.\")\n+            System.exit(1) // Give up.\n+          } else {\n+            Thread.sleep(2000)\n+          }\n+      }\n+    }\n+    val toxiProxyClient = new ToxiproxyClient(\"localhost\", toxiProxyPort);\n \n     val ledgerId = LedgerId(testName)\n     val applicationId = ApplicationId(testName)\n     val ledgerF = for {\n-      ledger <- Future(new SandboxServer(ledgerConfig(Port.Dynamic, dars, ledgerId), mat))\n-      port <- ledger.portF\n-    } yield (ledger, port.value)\n+      ledger <- Future(new SandboxServer(ledgerConfig(Port(0), dars, ledgerId), mat))\n+      sandboxPort <- ledger.portF\n+      ledgerProxyPort <- Future(findFreePort())\n+      ledgerProxy <- Future(\n+        toxiProxyClient\n+          .createProxy(\"sandbox\", s\"localhost:${ledgerProxyPort}\", s\"localhost:${sandboxPort}\"))\n+    } yield (ledger, ledgerProxyPort, ledgerProxy)\n+    // Note that it is the 'ledgerProxyPort' on which ledger clients\n+    // connect. This port is managed by the toxiproxy instance and\n+    // forwards to the real sandbox port.\n \n     val clientF: Future[LedgerClient] = for {\n-      (_, ledgerPort) <- ledgerF\n-      client <- LedgerClient.singleHost(\"localhost\", ledgerPort, clientConfig(applicationId))\n+      (_, ledgerProxyPort, _) <- ledgerF\n+      client <- LedgerClient.singleHost(\"localhost\", ledgerProxyPort, clientConfig(applicationId))\n     } yield client\n \n+    val ledgerProxyF: Future[Proxy] = for {"
  },
  {
    "id" : "01610356-721b-466b-9639-881c6517d381",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "e324a371-544a-41d6-8a27-85359ecf1888",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "The code below might be simplified if you omit the `ledger` and even `ledgerProxy`, which don't seem to be used.",
        "createdAt" : "2020-05-26T23:04:25Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "447decdb-848b-4117-862d-c3e689f6b4a3",
        "parentId" : "e324a371-544a-41d6-8a27-85359ecf1888",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "`ledger` is used when the future completes, `ledgerProxy` I anticipate using in the next set of changes.",
        "createdAt" : "2020-05-26T23:21:15Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,61 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" ++ toxiProxyPort.toString\n+    val toxiProxyProc = Process(toxiCmd).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", toxiProxyPort)\n+        channel.close()\n+        scanning = false\n+      } catch {\n+        case _: Throwable =>\n+          retries = retries + 1\n+          if (retries >= 3) {\n+            println(\"Toxiproxy failed to start. Terminating with errors.\")\n+            System.exit(1) // Give up.\n+          } else {\n+            Thread.sleep(2000)\n+          }\n+      }\n+    }\n+    val toxiProxyClient = new ToxiproxyClient(\"localhost\", toxiProxyPort);\n \n     val ledgerId = LedgerId(testName)\n     val applicationId = ApplicationId(testName)\n     val ledgerF = for {\n-      ledger <- Future(new SandboxServer(ledgerConfig(Port.Dynamic, dars, ledgerId), mat))\n-      port <- ledger.portF\n-    } yield (ledger, port.value)\n+      ledger <- Future(new SandboxServer(ledgerConfig(Port(0), dars, ledgerId), mat))\n+      sandboxPort <- ledger.portF\n+      ledgerProxyPort <- Future(findFreePort())\n+      ledgerProxy <- Future(\n+        toxiProxyClient\n+          .createProxy(\"sandbox\", s\"localhost:${ledgerProxyPort}\", s\"localhost:${sandboxPort}\"))\n+    } yield (ledger, ledgerProxyPort, ledgerProxy)"
  },
  {
    "id" : "506de56e-c9f5-4849-9489-3d276f771844",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "faf2d76a-0fbf-4d0a-992a-f83cf4059774",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we use `eventually` here or `com.daml.timer.RetryStrategy`?",
        "createdAt" : "2020-05-27T04:35:15Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3e6d87c7-0dbf-483b-8a87-329ad66eccbb",
        "parentId" : "faf2d76a-0fbf-4d0a-992a-f83cf4059774",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Good call on using `RetryStrategy`. I'd forgotten about it. There are two `eventually` functions but neither are available here—one is in the ledger API test tool, and one is from ScalaTest.\r\n\r\nYou can use `RetryStrategy` as follows:\r\n\r\n```scala\r\n  val eventually = RetryStrategy.constant(attempts = 3, waitTime = 2.seconds)\r\n  // ...\r\n  println(\"Waiting for Toxiproxy...\")\r\n  eventually { (_, _) =>\r\n    new java.net.Socket(\"localhost\", toxiProxyPort).close()\r\n  }\r\n```",
        "createdAt" : "2020-05-27T08:09:38Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "735d02a4-ec9d-4529-9178-b1e12f5431fa",
        "parentId" : "faf2d76a-0fbf-4d0a-992a-f83cf4059774",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Looks like this is what was meant?\r\n```scala\r\n    eventually { (_, _) =>\r\n      for {\r\n        _ <- Future (println(\"Waiting for Toxiproxy...\"))\r\n        channel <- Future (new java.net.Socket(\"localhost\", toxiProxyPort))\r\n      } yield(channel.close())\r\n    }\r\n```",
        "createdAt" : "2020-05-27T09:50:07Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a160d69b-97f3-472a-869b-1b881c9224fc",
        "parentId" : "faf2d76a-0fbf-4d0a-992a-f83cf4059774",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Ah, yes, now it's all futures. You can probably get away with:\r\n\r\n```scala\r\n  val eventually = RetryStrategy.constant(attempts = 3, waitTime = 2.seconds)\r\n  // ...\r\n  Await.result(eventually { (_, _) =>\r\n    println(\"Waiting for Toxiproxy...\")\r\n    new java.net.Socket(\"localhost\", toxiProxyPort).close()\r\n    Future.unit // or `Future.successful(())`, but why not use the constant?\r\n  }, Duration.Inf)\r\n```",
        "createdAt" : "2020-05-27T10:14:23Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,60 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" + toxiProxyPort.toString\n+    val toxiProxyProc = Process(toxiCmd).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {"
  },
  {
    "id" : "f5cd2fde-1a57-42db-a4d6-1aae7778126d",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "6b49fa04-5ee9-42d9-8ea0-5a0ccf31114f",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I suggest returning a `Port` here for clarity, though it's not necessary.",
        "createdAt" : "2020-05-27T08:05:28Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -29,11 +29,23 @@ import com.daml.platform.sandbox.SandboxServer\n import com.daml.platform.sandbox.config.SandboxConfig\n import com.daml.platform.services.time.TimeProviderType\n import com.daml.ports.Port\n-\n-import scala.concurrent.{ExecutionContext, Future}\n+import com.daml.bazeltools.BazelRunfiles\n+import scala.concurrent._\n+import scala.sys.process.Process\n+import eu.rekawek.toxiproxy._\n \n object TriggerServiceFixture {\n \n+  // Might throw IOException (unlikely). Best effort. There's a small\n+  // chance that having found one, it gets taken before we get to use\n+  // it.\n+  private def findFreePort(): Int = {"
  },
  {
    "id" : "e7091f6e-85b8-48f2-9b59-168c8e9532cc",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "33c06f99-7a57-4362-bd12-634da91bc9b5",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "You probably need to call `close()` in a `finally` block.\r\n\r\n```suggestion\r\n    val socket = new java.net.ServerSocket(0)\r\n    try {\r\n      socket.getLocalPort\r\n    } finally {\r\n      socket.close()\r\n    }\r\n```",
        "createdAt" : "2020-05-27T08:06:27Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -29,11 +29,23 @@ import com.daml.platform.sandbox.SandboxServer\n import com.daml.platform.sandbox.config.SandboxConfig\n import com.daml.platform.services.time.TimeProviderType\n import com.daml.ports.Port\n-\n-import scala.concurrent.{ExecutionContext, Future}\n+import com.daml.bazeltools.BazelRunfiles\n+import scala.concurrent._\n+import scala.sys.process.Process\n+import eu.rekawek.toxiproxy._\n \n object TriggerServiceFixture {\n \n+  // Might throw IOException (unlikely). Best effort. There's a small\n+  // chance that having found one, it gets taken before we get to use\n+  // it.\n+  private def findFreePort(): Int = {\n+    val socket = new java.net.ServerSocket(0)\n+    val port = socket.getLocalPort()\n+    socket.close()\n+    port"
  },
  {
    "id" : "2071ce79-d122-48d5-bded-da925b24861e",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "463d7a15-515f-42ca-a79c-f7277daadc9d",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I suggest using a `Seq` here. `Process.apply` accepts that too and you don't need to worry about shell parsing.\r\n\r\n```suggestion\r\n    val toxiCmd = Seq(toxiExe, \"--port\", toxiProxyPort.toString)\r\n```",
        "createdAt" : "2020-05-27T08:11:30Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,60 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" + toxiProxyPort.toString"
  },
  {
    "id" : "8b3698de-8bfc-44c7-b66c-58c72904e247",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "9204c056-3fed-4ccd-8fad-7686ccf81e3b",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "I recommend importing `Socket`.",
        "createdAt" : "2020-05-27T08:13:24Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,60 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" + toxiProxyPort.toString\n+    val toxiProxyProc = Process(toxiCmd).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", toxiProxyPort)"
  },
  {
    "id" : "6a6dff33-95fb-463e-9b03-ea2bca441d50",
    "prId" : 6114,
    "comments" : [
      {
        "id" : "6991c9d6-f607-4a74-aedd-7d841227a47d",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "In general, I'd advise preferring an `InetAddress` instance over a string here. You can use `InetAddress.getLoopbackAddress`. `Socket` will do the conversion from `String` to `InetAddress` for you, but it's an unnecessary jump.\r\n\r\n`Socket` will accept one of these but unfortunately, it seems Toxiproxy likes strings. If you want to stay a little more type-safe and coerce to string at the last moment, you can store `val host = InetAddress.getLoopbackAddress` and call `getHostName` when you need it.",
        "createdAt" : "2020-05-27T08:15:13Z",
        "updatedAt" : "2020-05-27T10:55:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "347873933b0a0ad589e870b16b5ceaa2247aea8b",
    "line" : null,
    "diffHunk" : "@@ -43,24 +55,60 @@ object TriggerServiceFixture {\n       mat: Materializer,\n       aesf: ExecutionSequencerFactory,\n       ec: ExecutionContext): Future[A] = {\n+    // Launch a toxiproxy instance . Wait on it to be ready to accept\n+    // connections.\n+    val toxiExe = BazelRunfiles.rlocation(\"external/toxiproxy_nix/bin/toxiproxy-cmd\")\n+    val toxiProxyPort = findFreePort()\n+    val toxiCmd = toxiExe + \" --port \" + toxiProxyPort.toString\n+    val toxiProxyProc = Process(toxiCmd).run()\n+    var retries = 0\n+    var scanning = true\n+    while (scanning) {\n+      try {\n+        println(\"Waiting for Toxiproxy...\")\n+        val channel = new java.net.Socket(\"localhost\", toxiProxyPort)"
  },
  {
    "id" : "f7024180-3adf-4f68-86aa-c196556621e7",
    "prId" : 6000,
    "comments" : [
      {
        "id" : "d1d1d0b9-4429-4ce5-aa5a-ad105c226a50",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Please use the default you specified above instead of duplicating it.",
        "createdAt" : "2020-05-15T11:57:42Z",
        "updatedAt" : "2020-05-15T13:31:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "079b112d-9af1-4717-801b-64e5c692e34e",
        "parentId" : "d1d1d0b9-4429-4ce5-aa5a-ad105c226a50",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-05-15T13:19:05Z",
        "updatedAt" : "2020-05-15T13:31:26Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "782906c89e3645f5113308c3d79b4d58b1e431b9",
    "line" : null,
    "diffHunk" : "@@ -63,7 +63,7 @@ object TriggerServiceFixture {\n         ledgerPort,\n         TimeProviderType.Static,\n         Duration.ofSeconds(30))\n-      service <- ServiceMain.startServer(\"localhost\", 0, ledgerConfig, dar)\n+      service <- ServiceMain.startServer(\"localhost\", 0, ledgerConfig, 4194304, dar)"
  },
  {
    "id" : "e209092f-cc28-4474-a76d-f2b0b607cb14",
    "prId" : 4287,
    "comments" : [
      {
        "id" : "50d60d5e-3fc7-4d43-b551-40cb1ecc554f",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Can those be removed?",
        "createdAt" : "2020-01-31T09:13:19Z",
        "updatedAt" : "2020-01-31T09:30:36Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "313cae73-2960-4ec9-b97f-0d90b67e01a0",
        "parentId" : "50d60d5e-3fc7-4d43-b551-40cb1ecc554f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "good catch, removed.",
        "createdAt" : "2020-01-31T09:29:23Z",
        "updatedAt" : "2020-01-31T09:30:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "066ec07af8b619d03c7d54bc324fed6b4ac7b4de",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,112 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.engine.trigger\n+\n+import java.io.File\n+\n+import akka.actor.ActorSystem\n+import akka.actor.typed.{ActorSystem => TypedActorSystem}\n+import akka.http.scaladsl.Http.ServerBinding\n+import akka.http.scaladsl.model.Uri\n+import akka.stream.Materializer\n+import java.time.Duration\n+\n+import com.digitalasset.daml.lf.archive.Dar\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.language.Ast._\n+import com.digitalasset.grpc.adapter.ExecutionSequencerFactory\n+import com.digitalasset.ledger.api.auth.AuthService\n+import com.digitalasset.ledger.api.domain.LedgerId\n+import com.digitalasset.ledger.api.refinements.ApiTypes.ApplicationId\n+import com.digitalasset.ledger.client.LedgerClient\n+import com.digitalasset.ledger.client.configuration.{\n+  CommandClientConfiguration,\n+  LedgerClientConfiguration,\n+  LedgerIdRequirement\n+}\n+import com.digitalasset.platform.common.LedgerIdMode\n+import com.digitalasset.platform.sandbox.SandboxServer\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.digitalasset.platform.services.time.TimeProviderType\n+// import scalaz._\n+// import scalaz.std.option._\n+// import scalaz.std.scalaFuture._\n+// import scalaz.syntax.traverse._\n+"
  }
]