[
  {
    "id" : "50c4849f-b299-490f-aa26-d81db355c9e4",
    "prId" : 7629,
    "comments" : [
      {
        "id" : "5b0d5ccc-8d44-4454-84da-a3835809a973",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think I’ve mentioned it before but I expect we need to make the mapping here pretty configurable. For auth0 you are very flexible in defining how scopes are mapped to the token but this isn’t necessarily true for all auth providers and some of them also use arbitrary other arguments. One idea would be to have a jsonnet template (or whatever other template format you come up with, I’m not familiar with what people use for this) to basically define the whole request body here as users need to.\r\n\r\nDefinitely not something for this PR, but something to keep in mind.",
        "createdAt" : "2020-10-09T15:40:32Z",
        "updatedAt" : "2020-10-09T15:43:35Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "58474c34-c16e-477f-ad5f-dbe19be89e38",
        "parentId" : "5b0d5ccc-8d44-4454-84da-a3835809a973",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Yes, this is auth0 specific. What I've seen in other places is presets for known auth providers. Templating is a nice idea, I'll keep it in mind.",
        "createdAt" : "2020-10-09T16:42:22Z",
        "updatedAt" : "2020-10-09T16:42:22Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "58bb1ff30fa2ecc252322bac614323c81e9f5eb1",
    "line" : 59,
    "diffHunk" : "@@ -88,8 +104,10 @@ object Server extends StrictLogging {\n             responseType = \"code\",\n             clientId = config.clientId,\n             redirectUri = toRedirectUri(request.uri),\n-            scope = Some(login.claims),\n-            state = Some(requestId.toString))\n+            scope = Some(login.claims.toQueryString),\n+            state = Some(requestId.toString),\n+            audience = Some(\"https://daml.com/ledger-api\")"
  },
  {
    "id" : "2c8ff0ba-0307-40a1-b3a1-3a10b24a3432",
    "prId" : 7565,
    "comments" : [
      {
        "id" : "cb310b90-6695-43c8-9aff-72970840a83d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I still feel like there must be some builtin pattern for checking the status code and then unmarshalling but I never found one :confused: ",
        "createdAt" : "2020-10-05T12:00:09Z",
        "updatedAt" : "2020-10-05T13:34:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9310bb3f2b0980068c91493742150006dbe5c473",
    "line" : 54,
    "diffHunk" : "@@ -119,13 +116,22 @@ object Server extends StrictLogging {\n                 redirectUri = toRedirectUri(request.uri),\n                 clientId = config.clientId,\n                 clientSecret = config.clientSecret)\n-              val req = HttpRequest(\n-                uri = config.oauthUri.withPath(Uri.Path./(\"token\")),\n-                entity = HttpEntity(MediaTypes.`application/json`, body.toJson.compactPrint),\n-                method = HttpMethods.POST)\n+              import com.daml.oauth.server.Request.Token.marshalRequestEntity\n               val tokenRequest = for {\n+                entity <- Marshal(body).to[RequestEntity]\n+                req = HttpRequest(\n+                  uri = config.oauthToken,\n+                  entity = entity,\n+                  method = HttpMethods.POST)\n                 resp <- Http().singleRequest(req)\n-                tokenResp <- Unmarshal(resp).to[OAuthResponse.Token]\n+                tokenResp <- if (resp.status != StatusCodes.OK) {\n+                  Unmarshal(resp).to[String].flatMap { msg =>"
  },
  {
    "id" : "3f36d5f8-7e3e-44c0-b5d7-a6f1142dc45e",
    "prId" : 7545,
    "comments" : [
      {
        "id" : "64952df8-173c-4b96-98f8-3ec4c90a8503",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "implicit mutable variables creep me out a bit. How bad does it look if we pass this explicitly?",
        "createdAt" : "2020-10-01T13:58:48Z",
        "updatedAt" : "2020-10-01T14:36:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c55758d6-4ae9-4aa2-b98d-27124a72ef77",
        "parentId" : "64952df8-173c-4b96-98f8-3ec4c90a8503",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Not too horrible: https://github.com/digital-asset/daml/pull/7545/commits/9e9ac0a95084e7ba0256549dee8c62a932f569e5",
        "createdAt" : "2020-10-01T14:37:09Z",
        "updatedAt" : "2020-10-01T14:37:09Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9e9ac0a95084e7ba0256549dee8c62a932f569e5",
    "line" : null,
    "diffHunk" : "@@ -34,84 +36,16 @@ object Server extends StrictLogging {\n       .withAuthority(uri.authority)\n       .withPath(Uri.Path./(\"cb\"))\n \n-  def start(\n-      config: Config)(implicit system: ActorSystem, ec: ExecutionContext): Future[ServerBinding] = {\n-    implicit val unmarshal: Unmarshaller[String, Uri] = Unmarshaller.strict(Uri(_))\n+  def start(serverConfig: Config)(\n+      implicit system: ActorSystem,\n+      ec: ExecutionContext): Future[ServerBinding] = {\n+    implicit val config: Config = serverConfig\n     // TODO[AH] Make sure this is bounded in size - or avoid state altogether.\n-    val requests = TrieMap[UUID, Uri]()\n+    implicit val requests: TrieMap[UUID, Uri] = TrieMap()"
  },
  {
    "id" : "7a21eccd-b812-4138-9eab-a3546d4a5a94",
    "prId" : 7519,
    "comments" : [
      {
        "id" : "d61c502a-f48d-416c-982c-be831912be8c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think we might want to make the authority here or probably even better just the full URL configurable. Consider a case where this is running behind NGINX. We might be listening on `localhost` but the external facing host will be different and the path could also be different (e.g. it could be behind some prefix).",
        "createdAt" : "2020-09-30T08:05:40Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d59849e-56b9-471a-93ef-752c68fe2099",
        "parentId" : "d61c502a-f48d-416c-982c-be831912be8c",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Good point",
        "createdAt" : "2020-09-30T08:37:19Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4fd2cbb85e88ccc2b25624f1d6476ec839d66de0",
    "line" : 31,
    "diffHunk" : "@@ -0,0 +1,125 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.oauth.middleware\n+\n+import akka.Done\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.Http\n+import akka.http.scaladsl.Http.ServerBinding\n+import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\n+import akka.http.scaladsl.model._\n+import akka.http.scaladsl.model.headers.HttpCookie\n+import akka.http.scaladsl.server.Directives._\n+import akka.http.scaladsl.unmarshalling.{Unmarshal, Unmarshaller}\n+import com.daml.oauth.server.{Request => OAuthRequest, Response => OAuthResponse}\n+import com.typesafe.scalalogging.StrictLogging\n+import java.util.Base64\n+import java.util.UUID\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.language.postfixOps\n+import scala.util.Try\n+import spray.json._\n+\n+// This is an implementation of the trigger service authentication middleware\n+// for OAuth2 as specified in `/triggers/service/authentication.md`\n+object Server extends StrictLogging {\n+  import com.daml.oauth.server.JsonProtocol._\n+\n+  private def toRedirectUri(uri: Uri) ="
  },
  {
    "id" : "86cad590-9f02-4077-9916-7f96695e996b",
    "prId" : 7519,
    "comments" : [
      {
        "id" : "add93b24-d559-4827-be5d-53f9fd57d52e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe worth extracting the request bodies into separate functions? Totally fine to leave that for separate PRs.",
        "createdAt" : "2020-09-30T08:10:24Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ec11bd9a-3c80-41eb-b2e9-5d6573339167",
        "parentId" : "add93b24-d559-4827-be5d-53f9fd57d52e",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Yeah, that's probably better for readability, especially once the other endpoints are filled in. ",
        "createdAt" : "2020-09-30T08:38:48Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4fd2cbb85e88ccc2b25624f1d6476ec839d66de0",
    "line" : 50,
    "diffHunk" : "@@ -0,0 +1,125 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.oauth.middleware\n+\n+import akka.Done\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.Http\n+import akka.http.scaladsl.Http.ServerBinding\n+import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\n+import akka.http.scaladsl.model._\n+import akka.http.scaladsl.model.headers.HttpCookie\n+import akka.http.scaladsl.server.Directives._\n+import akka.http.scaladsl.unmarshalling.{Unmarshal, Unmarshaller}\n+import com.daml.oauth.server.{Request => OAuthRequest, Response => OAuthResponse}\n+import com.typesafe.scalalogging.StrictLogging\n+import java.util.Base64\n+import java.util.UUID\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.language.postfixOps\n+import scala.util.Try\n+import spray.json._\n+\n+// This is an implementation of the trigger service authentication middleware\n+// for OAuth2 as specified in `/triggers/service/authentication.md`\n+object Server extends StrictLogging {\n+  import com.daml.oauth.server.JsonProtocol._\n+\n+  private def toRedirectUri(uri: Uri) =\n+    Uri()\n+      .withScheme(uri.scheme)\n+      .withAuthority(uri.authority)\n+      .withPath(Uri.Path./(\"cb\"))\n+\n+  def start(\n+      config: Config)(implicit system: ActorSystem, ec: ExecutionContext): Future[ServerBinding] = {\n+    implicit val unmarshal: Unmarshaller[String, Uri] = Unmarshaller.strict(Uri(_))\n+    // TODO[AH] Make sure this is bounded in size - or avoid state altogether.\n+    val requests = TrieMap[UUID, Uri]()\n+    val route = concat(\n+      path(\"auth\") {\n+        get {\n+          complete((StatusCodes.NotImplemented, \"The /auth endpoint is not implemented yet\"))\n+        }\n+      },\n+      path(\"login\") {\n+        get {\n+          parameters(('redirect_uri.as[Uri], 'claims))"
  },
  {
    "id" : "00f74aec-64a5-41e0-b6a2-2b8ed8498aa5",
    "prId" : 7519,
    "comments" : [
      {
        "id" : "ac26c8f6-81b9-4f49-9974-eae467e0fb9a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We probably need to make the scopes configurable to some degree. Some oauth providers (e.g. auth0) also allow you to use custom parameters instead of scopes to accomplish the same thing. Not quite sure what the best UX for that is and we don’t have to solve this in this PR but something to keep in mind for the future.",
        "createdAt" : "2020-09-30T08:11:53Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3503e03b-96f2-4deb-b1d9-a9bf72dda024",
        "parentId" : "ac26c8f6-81b9-4f49-9974-eae467e0fb9a",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "That's good to know, the implementation of that is probably best guided by a concrete use-case that requires that sort of thing. The mapping from claims to scope generally still needs work. ",
        "createdAt" : "2020-09-30T08:40:37Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4fd2cbb85e88ccc2b25624f1d6476ec839d66de0",
    "line" : 61,
    "diffHunk" : "@@ -0,0 +1,125 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.oauth.middleware\n+\n+import akka.Done\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.Http\n+import akka.http.scaladsl.Http.ServerBinding\n+import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\n+import akka.http.scaladsl.model._\n+import akka.http.scaladsl.model.headers.HttpCookie\n+import akka.http.scaladsl.server.Directives._\n+import akka.http.scaladsl.unmarshalling.{Unmarshal, Unmarshaller}\n+import com.daml.oauth.server.{Request => OAuthRequest, Response => OAuthResponse}\n+import com.typesafe.scalalogging.StrictLogging\n+import java.util.Base64\n+import java.util.UUID\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.language.postfixOps\n+import scala.util.Try\n+import spray.json._\n+\n+// This is an implementation of the trigger service authentication middleware\n+// for OAuth2 as specified in `/triggers/service/authentication.md`\n+object Server extends StrictLogging {\n+  import com.daml.oauth.server.JsonProtocol._\n+\n+  private def toRedirectUri(uri: Uri) =\n+    Uri()\n+      .withScheme(uri.scheme)\n+      .withAuthority(uri.authority)\n+      .withPath(Uri.Path./(\"cb\"))\n+\n+  def start(\n+      config: Config)(implicit system: ActorSystem, ec: ExecutionContext): Future[ServerBinding] = {\n+    implicit val unmarshal: Unmarshaller[String, Uri] = Unmarshaller.strict(Uri(_))\n+    // TODO[AH] Make sure this is bounded in size - or avoid state altogether.\n+    val requests = TrieMap[UUID, Uri]()\n+    val route = concat(\n+      path(\"auth\") {\n+        get {\n+          complete((StatusCodes.NotImplemented, \"The /auth endpoint is not implemented yet\"))\n+        }\n+      },\n+      path(\"login\") {\n+        get {\n+          parameters(('redirect_uri.as[Uri], 'claims))\n+            .as[Request.Login](Request.Login) {\n+              login =>\n+                extractRequest {\n+                  request =>\n+                    val requestId = UUID.randomUUID\n+                    requests += (requestId -> login.redirectUri)\n+                    val authorize = OAuthRequest.Authorize(\n+                      responseType = \"code\",\n+                      clientId = config.clientId,\n+                      redirectUri = toRedirectUri(request.uri),\n+                      scope = Some(login.claims),"
  },
  {
    "id" : "a440bd66-9cd6-420d-9e88-8b3ee011f485",
    "prId" : 7519,
    "comments" : [
      {
        "id" : "efe1700e-8ecf-4d91-b271-8b32704e881a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe unauthorized would be a more appropriate status code?",
        "createdAt" : "2020-09-30T08:13:03Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "914e9dfb-e4fa-4ad8-94e3-f85c57416e20",
        "parentId" : "efe1700e-8ecf-4d91-b271-8b32704e881a",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "The idea behind 404 was that the login request under the given `state` was not found. 401 seems problematic, the `/cb` is part of the authentication flow, not something that requires authentication itself, also 401 requires a challenge in the [WWW-Authenticate header field](https://tools.ietf.org/html/rfc7235#section-3.1) which doesn't seem appropriate here. ",
        "createdAt" : "2020-09-30T08:56:38Z",
        "updatedAt" : "2020-09-30T09:47:25Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4fd2cbb85e88ccc2b25624f1d6476ec839d66de0",
    "line" : 86,
    "diffHunk" : "@@ -0,0 +1,125 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.oauth.middleware\n+\n+import akka.Done\n+import akka.actor.ActorSystem\n+import akka.http.scaladsl.Http\n+import akka.http.scaladsl.Http.ServerBinding\n+import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._\n+import akka.http.scaladsl.model._\n+import akka.http.scaladsl.model.headers.HttpCookie\n+import akka.http.scaladsl.server.Directives._\n+import akka.http.scaladsl.unmarshalling.{Unmarshal, Unmarshaller}\n+import com.daml.oauth.server.{Request => OAuthRequest, Response => OAuthResponse}\n+import com.typesafe.scalalogging.StrictLogging\n+import java.util.Base64\n+import java.util.UUID\n+import scala.collection.concurrent.TrieMap\n+import scala.concurrent.{ExecutionContext, Future}\n+import scala.language.postfixOps\n+import scala.util.Try\n+import spray.json._\n+\n+// This is an implementation of the trigger service authentication middleware\n+// for OAuth2 as specified in `/triggers/service/authentication.md`\n+object Server extends StrictLogging {\n+  import com.daml.oauth.server.JsonProtocol._\n+\n+  private def toRedirectUri(uri: Uri) =\n+    Uri()\n+      .withScheme(uri.scheme)\n+      .withAuthority(uri.authority)\n+      .withPath(Uri.Path./(\"cb\"))\n+\n+  def start(\n+      config: Config)(implicit system: ActorSystem, ec: ExecutionContext): Future[ServerBinding] = {\n+    implicit val unmarshal: Unmarshaller[String, Uri] = Unmarshaller.strict(Uri(_))\n+    // TODO[AH] Make sure this is bounded in size - or avoid state altogether.\n+    val requests = TrieMap[UUID, Uri]()\n+    val route = concat(\n+      path(\"auth\") {\n+        get {\n+          complete((StatusCodes.NotImplemented, \"The /auth endpoint is not implemented yet\"))\n+        }\n+      },\n+      path(\"login\") {\n+        get {\n+          parameters(('redirect_uri.as[Uri], 'claims))\n+            .as[Request.Login](Request.Login) {\n+              login =>\n+                extractRequest {\n+                  request =>\n+                    val requestId = UUID.randomUUID\n+                    requests += (requestId -> login.redirectUri)\n+                    val authorize = OAuthRequest.Authorize(\n+                      responseType = \"code\",\n+                      clientId = config.clientId,\n+                      redirectUri = toRedirectUri(request.uri),\n+                      scope = Some(login.claims),\n+                      state = Some(requestId.toString))\n+                    redirect(\n+                      config.oauthUri\n+                        .withPath(Uri.Path./(\"authorize\"))\n+                        .withQuery(authorize.toQuery),\n+                      StatusCodes.Found)\n+                }\n+            }\n+        }\n+      },\n+      path(\"cb\") {\n+        get {\n+          parameters(('code, 'state ?))\n+            .as[OAuthResponse.Authorize](OAuthResponse.Authorize) {\n+              authorize =>\n+                extractRequest {\n+                  request =>\n+                    val redirectUri = for {\n+                      state <- authorize.state\n+                      requestId <- Try(UUID.fromString(state)).toOption\n+                      redirectUri <- requests.remove(requestId)\n+                    } yield redirectUri\n+                    redirectUri match {\n+                      case None =>\n+                        complete(StatusCodes.NotFound)"
  }
]