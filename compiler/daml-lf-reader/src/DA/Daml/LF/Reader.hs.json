[
  {
    "id" : "1df2afba-f67d-4b71-9269-16dc1ea7b2ed",
    "prId" : 2699,
    "comments" : [
      {
        "id" : "ccbad39a-0c68-419e-84da-13295a59a6e5",
        "parentId" : null,
        "author" : null,
        "body" : "Maybe this could be factored out / named as `isHeaderChar` to match the spec.\r\n\r\nAlso, not sure if relevant, but it looks like `isAlphaNum` will accept more than just the ASCII alphanumerics, where the spec defines `alphanum` as `{A-Z} | {a-z} | {0-9}` -- e.g. this rule will accept `Ã‰` in the header name.",
        "createdAt" : "2019-08-29T09:09:08Z",
        "updatedAt" : "2019-08-29T09:32:28Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "de6568d6-0dfc-4fc2-ade8-db9a3ae92266",
        "parentId" : "ccbad39a-0c68-419e-84da-13295a59a6e5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, Iâ€™ve factored out `isHeaderChar`. `isAlphaNum` is fine here even if we want to be strict (which we donâ€™t need to be imho) since we get the Char by applying `chr` to a `Word8`. Iâ€™ve added a comment to that effect.",
        "createdAt" : "2019-08-29T09:33:29Z",
        "updatedAt" : "2019-08-29T09:33:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "650a1923-da02-4989-b48b-5e55ddf85d13",
        "parentId" : "ccbad39a-0c68-419e-84da-13295a59a6e5",
        "author" : null,
        "body" : "I think the `Ã‰` example still stands, since it represents the codepoint `U+00C9`. Agreed about not being strict.",
        "createdAt" : "2019-08-29T14:11:10Z",
        "updatedAt" : "2019-08-29T14:11:11Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c6ccbba-daca-44d9-a771-aada6aa501d6",
        "parentId" : "ccbad39a-0c68-419e-84da-13295a59a6e5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh good point, thanks for pointing it out.",
        "createdAt" : "2019-08-29T14:22:50Z",
        "updatedAt" : "2019-08-29T14:22:50Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "039895b9671724aa28e45b55b9e9b320b2140816",
    "line" : null,
    "diffHunk" : "@@ -2,67 +2,110 @@\n -- SPDX-License-Identifier: Apache-2.0\n \n module DA.Daml.LF.Reader\n-    ( Manifest(..)\n-    , ManifestData(..)\n-    , manifestFromDar\n-    , multiLineContent\n-    , getManifestField\n+    ( parseManifestFile\n+    , readManifest\n+    , manifestPath\n+    , DalfManifest(..)\n+    , Dalfs(..)\n+    , readDalfManifest\n+    , readDalfs\n     ) where\n \n import \"zip-archive\" Codec.Archive.Zip\n+import Data.ByteString (ByteString)\n+import qualified Data.ByteString as BS\n+import qualified Data.ByteString.UTF8 as BSUTF8\n import qualified Data.ByteString.Lazy as BSL\n-import qualified Data.ByteString.Lazy.UTF8 as UTF8\n-import qualified Data.ByteString.Char8 as BSC\n-import qualified Data.HashMap.Strict as Map\n+import Data.Char\n import Data.List.Extra\n-import System.FilePath\n-import Safe\n+import Data.Void\n+import Text.Megaparsec\n+import Text.Megaparsec.Byte\n \n-data Manifest = Manifest\n-    { mainDalf :: FilePath\n-    , dalfs :: [FilePath]\n-    } deriving (Show)\n+type Parser = Parsec Void ByteString\n \n-data ManifestData = ManifestData\n-    { mainDalfContent :: BSL.ByteString\n-    , dalfsContent :: [BSL.ByteString]\n-    } deriving (Show)\n+parseManifestFile :: ByteString -> Either String [(ByteString, ByteString)]\n+parseManifestFile bs = case parse manifestParser \"MANIFEST.MF\" bs of\n+    Left errBundle -> Left $ errorBundlePretty errBundle\n+    Right r -> Right r\n+\n+readManifest :: Archive -> Either String [(ByteString, ByteString)]\n+readManifest dar = do\n+    entry <- getEntry dar manifestPath\n+    parseManifestFile $ BSL.toStrict entry\n+\n+manifestPath :: FilePath\n+manifestPath = \"META-INF/MANIFEST.MF\"\n+\n+-- | We try to be fairly lenient in our parser, e.g., we do not enforce that\n+-- lines abide to the 72 byte limit.\n+--\n+-- See\n+-- https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#JAR_Manifest\n+-- for a description of the format.\n+manifestParser :: Parser [(ByteString, ByteString)]\n+manifestParser = do\n+    xs <- many manifestHeaderParser\n+    _ <- many eol\n+    pure xs\n \n-lineToKeyValue :: String -> (String, String)\n-lineToKeyValue line = case splitOn \":\" line of\n-    [l, r] -> (trim l , trim r)\n-    _ -> error $ \"Expected two fields in line \" <> line\n+manifestHeaderParser :: Parser (ByteString, ByteString)\n+manifestHeaderParser = do\n+    name <- nameParser\n+    _ <- chunk \": \"\n+    value <- valueParser\n+    pure (name, value)\n \n-multiLineContent :: String -> [String]\n-multiLineContent = filter (not . null) . lines . replace \"\\n \" \"\"\n+nameParser :: Parser ByteString\n+nameParser = do\n+    x <- alphaNumChar\n+    xs <- takeWhileP Nothing (\\x -> let xChr = chr $ fromIntegral x in isAlphaNum xChr || xChr == '-' || xChr == '_')"
  },
  {
    "id" : "fc1967dc-e0a0-470e-a125-4fe1d8cc9326",
    "prId" : 2207,
    "comments" : [
      {
        "id" : "93281aff-589f-4e1e-b407-b85cfadae516",
        "parentId" : null,
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "This was exposed just make testing easy, the other way was creating an archive which is very tedious :( ",
        "createdAt" : "2019-07-17T21:18:05Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c9c8ad868f4f9081488f2c4eeb88eadddb2aae50",
    "line" : 4,
    "diffHunk" : "@@ -5,6 +5,7 @@ module DA.Daml.LF.Reader\n     ( Manifest(..)\n     , ManifestData(..)\n     , manifestFromDar\n+    , multiLineContent"
  },
  {
    "id" : "e4743ecc-d800-443a-b21b-5a2829fd4d2a",
    "prId" : 2207,
    "comments" : [
      {
        "id" : "6e764e34-2e7c-469b-a62d-4175cd3f17fc",
        "parentId" : null,
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "The specification reads if a line exceeds 72 bytes start with a space on the next line, collecting lines with space and appending to the previous line seems very easy to implement. Let me know if you think that is too hacky  ",
        "createdAt" : "2019-07-17T21:19:57Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c9c8ad868f4f9081488f2c4eeb88eadddb2aae50",
    "line" : null,
    "diffHunk" : "@@ -29,6 +30,16 @@ lineToKeyValue line = case splitOn \":\" line of\n     [l, r] -> (trim l , trim r)\n     _ -> error $ \"Expected two fields in line \" <> line\n \n+appendToFirstEntry :: [String] -> String -> [String]\n+appendToFirstEntry (h : t) nextLine = (h ++ nextLine) : t\n+appendToFirstEntry _ _ = error $ \"Reading Manifest file from dar failed.\"\n+\n+multiLineContent :: [String] -> [String] -> [String]"
  },
  {
    "id" : "db45b7d6-7d57-43fe-823a-db290ab0b476",
    "prId" : 2207,
    "comments" : [
      {
        "id" : "8fb0e990-bb06-432d-b309-d1f7a14bf065",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I usually find those kind of accumulator functions easier to read if you have one function of type `multiLineContent :: [String] -> [String]` and then define a function that takes the accumulator in a where clause. That said, it looks like this whole function is a `foldl'`, something like \r\n```haskell\r\nmultiLineContent = foldl' (\\acc h -> if \" \" `isPrefixOf` h then appendToFirstEntry acc (trim h) else h:acc) []\r\n```",
        "createdAt" : "2019-07-18T06:59:11Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "88ec8291-451b-43b8-8945-e5caed8aacbd",
        "parentId" : "8fb0e990-bb06-432d-b309-d1f7a14bf065",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This whole `multilineContent` thing looks way too complicated to me. How about something like\r\n```haskell\r\nmultilineContent :: [String] -> [String]\r\nmultilineContent [] = []\r\nmultilineContent (x:xs)\r\n  | all isSpace x = multilineContent xs\r\n  | otherwise = (x ++ concatMap trim ys) : multilineContent zs\r\n    where\r\n      (ys, zs) = span (isPrefixOf \" \") xs\r\n```",
        "createdAt" : "2019-07-18T08:15:59Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "85ed70d7-bd78-4136-9bec-0214ee8769eb",
        "parentId" : "8fb0e990-bb06-432d-b309-d1f7a14bf065",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "I went with foldl. ",
        "createdAt" : "2019-07-18T13:55:23Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "913fd8cc-be3c-4af2-8ccb-35d7379d6922",
        "parentId" : "8fb0e990-bb06-432d-b309-d1f7a14bf065",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not a big fan of `appendToFirstEntry` because it is a partial function when there's no need for a partial function. :(",
        "createdAt" : "2019-07-18T13:58:19Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4236be23-eeb3-4a69-8cb3-f64e001680b6",
        "parentId" : "8fb0e990-bb06-432d-b309-d1f7a14bf065",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "I see, got it. now not using a partial function",
        "createdAt" : "2019-07-18T14:59:50Z",
        "updatedAt" : "2019-07-18T15:00:00Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c9c8ad868f4f9081488f2c4eeb88eadddb2aae50",
    "line" : null,
    "diffHunk" : "@@ -29,6 +30,16 @@ lineToKeyValue line = case splitOn \":\" line of\n     [l, r] -> (trim l , trim r)\n     _ -> error $ \"Expected two fields in line \" <> line\n \n+appendToFirstEntry :: [String] -> String -> [String]\n+appendToFirstEntry (h : t) nextLine = (h ++ nextLine) : t\n+appendToFirstEntry _ _ = error \"Reading Manifest file from dar failed.\"\n+\n+multiLineContent :: [String] -> [String] -> [String]"
  },
  {
    "id" : "e796192b-92f4-4eae-acfc-974b35b592d1",
    "prId" : 2207,
    "comments" : [
      {
        "id" : "f5ceb632-3033-4f1a-bf1b-31aadcdd07eb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        manifestLines = multiLineContent (filter (not . null) linesStr) []\r\n```",
        "createdAt" : "2019-07-18T08:17:20Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7d06e0ad-33cf-4d84-8f19-36de8394fa89",
        "parentId" : "f5ceb632-3033-4f1a-bf1b-31aadcdd07eb",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "Cool. incorporated",
        "createdAt" : "2019-07-18T13:28:02Z",
        "updatedAt" : "2019-07-18T14:59:11Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c9c8ad868f4f9081488f2c4eeb88eadddb2aae50",
    "line" : null,
    "diffHunk" : "@@ -42,9 +53,10 @@ manifestDataFromDar archive manifest = ManifestData manifestDalfByte dependencyD\n         dependencyDalfBytes = [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && elem (trim (eRelativePath e))  (dalfs manifest)]\n \n manifestFromDar :: Archive -> ManifestData\n-manifestFromDar dar =  manifestDataFromDar dar manifest\n+manifestFromDar dar = manifestDataFromDar dar manifest\n     where\n         manifestEntry = head [fromEntry e | e <- zEntries dar, \".MF\" `isExtensionOf` eRelativePath e]\n         linesStr = lines $ UTF8.toString manifestEntry\n-        manifest = manifestMapToManifest $ Map.fromList $ map lineToKeyValue (filter (\\a -> a /= \"\" ) linesStr)\n+        manifestLines = multiLineContent (filter (\\a -> a /= \"\" ) linesStr) []"
  },
  {
    "id" : "4814ee7a-add5-40f7-bcdd-d71fe4f3a3d8",
    "prId" : 1803,
    "comments" : [
      {
        "id" : "1ab8f7ee-3fab-403a-91e7-6af193fba644",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd have split this into separate lines for the fields. Otherwise its hard to write comments.",
        "createdAt" : "2019-06-21T14:53:00Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b6b67e30-d88d-4755-a3b3-24d3206050d4",
        "parentId" : "1ab8f7ee-3fab-403a-91e7-6af193fba644",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "changed",
        "createdAt" : "2019-06-21T15:02:50Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e3c9860e2116e31f3d775b8a0cd2d5704f29ff71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,43 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.LF.Reader\n+    ( Manifest(..)\n+    , ManifestData(..)\n+    , manifestFromDar\n+    ) where\n+\n+import Codec.Archive.Zip\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.ByteString.Lazy.UTF8 as UTF8\n+import qualified Data.HashMap.Strict as Map\n+import Data.List.Extra\n+import System.FilePath\n+\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)"
  },
  {
    "id" : "ca1895fe-79b9-4aaf-9778-9c6f7d175f77",
    "prId" : 1803,
    "comments" : [
      {
        "id" : "b3bec831-7365-4076-8853-a98c83799647",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "dalfsCotent => dalfsContent",
        "createdAt" : "2019-06-21T14:53:13Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e3c9860e2116e31f3d775b8a0cd2d5704f29ff71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,43 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.LF.Reader\n+    ( Manifest(..)\n+    , ManifestData(..)\n+    , manifestFromDar\n+    ) where\n+\n+import Codec.Archive.Zip\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.ByteString.Lazy.UTF8 as UTF8\n+import qualified Data.HashMap.Strict as Map\n+import Data.List.Extra\n+import System.FilePath\n+\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)"
  },
  {
    "id" : "cebf5f29-d7ef-4ce3-bcc2-437c81b5c003",
    "prId" : 1803,
    "comments" : [
      {
        "id" : "0c87e299-0a77-4c08-b2f4-5edb87c8c8b0",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I wonder if we should have `Manifest a` where `a` is either `FilePath` or `BSL.ByteString`?",
        "createdAt" : "2019-06-21T14:54:00Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab8c2753-edb7-408e-87f7-ac8116c8fb69",
        "parentId" : "0c87e299-0a77-4c08-b2f4-5edb87c8c8b0",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Sounds reasonable to me but letâ€™s change it in a separate PR.",
        "createdAt" : "2019-06-21T15:03:41Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c3399a1-da78-43be-8a1f-f1fb7c0b2a98",
        "parentId" : "0c87e299-0a77-4c08-b2f4-5edb87c8c8b0",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "ðŸ‘ ",
        "createdAt" : "2019-06-21T15:05:56Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e3c9860e2116e31f3d775b8a0cd2d5704f29ff71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,43 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.LF.Reader\n+    ( Manifest(..)\n+    , ManifestData(..)\n+    , manifestFromDar\n+    ) where\n+\n+import Codec.Archive.Zip\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.ByteString.Lazy.UTF8 as UTF8\n+import qualified Data.HashMap.Strict as Map\n+import Data.List.Extra\n+import System.FilePath\n+\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)"
  },
  {
    "id" : "8d4ce687-98de-49ed-87a4-1175f415090e",
    "prId" : 1803,
    "comments" : [
      {
        "id" : "169ad0b4-c86b-4689-b141-501b0bc38313",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Not a fan of sneaking `malformed` into places - you're one day going to get an error that just talks about malformed... Perhaps just silently drop them with a Nothing?",
        "createdAt" : "2019-06-21T14:54:45Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b4bf3886-9006-4569-b109-284f4840cc17",
        "parentId" : "169ad0b4-c86b-4689-b141-501b0bc38313",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Iâ€™ve changed it to a call to `error` for now, Iâ€™m not a fan of silently dropping on parse failures.",
        "createdAt" : "2019-06-21T15:05:19Z",
        "updatedAt" : "2019-06-21T15:06:40Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e3c9860e2116e31f3d775b8a0cd2d5704f29ff71",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,43 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.LF.Reader\n+    ( Manifest(..)\n+    , ManifestData(..)\n+    , manifestFromDar\n+    ) where\n+\n+import Codec.Archive.Zip\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.ByteString.Lazy.UTF8 as UTF8\n+import qualified Data.HashMap.Strict as Map\n+import Data.List.Extra\n+import System.FilePath\n+\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)\n+\n+lineToKeyValue :: String -> (String, String)\n+lineToKeyValue line = case splitOn \":\" line of\n+    [l, r] -> (trim l , trim r)\n+    _ -> (\"malformed\", \"malformed\")"
  }
]