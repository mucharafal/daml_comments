[
  {
    "id" : "b71e215c-86d7-47ad-8cba-28f7e9ed8924",
    "prId" : 1991,
    "comments" : [
      {
        "id" : "efb43943-a300-4eb9-a9eb-8fee6750336b",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "My preference is just to always use System.Time.Extra.Seconds for all seconds, since people don't think in microseconds very naturally and always get it wrong.",
        "createdAt" : "2019-07-03T13:24:45Z",
        "updatedAt" : "2019-07-03T16:50:14Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f441ff7fc8861ebde15ab3c043a96f0776a007c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,67 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module Development.IDE.Core.Debouncer\n+    ( MicroSeconds(..)\n+    , Debouncer\n+    , newDebouncer\n+    , withDebouncer\n+    , registerEvent\n+    , killEvents\n+    , waitForEvents\n+    ) where\n+\n+import Control.Concurrent\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Control.Exception\n+import Control.Monad.Extra\n+import Data.Map.Strict (Map)\n+import qualified Data.Map.Strict as Map\n+\n+-- | A debouncer can be used to avoid triggering many events\n+-- (e.g. diagnostics) for the same key (e.g. the same file)\n+-- within a short timeframe. This is accomplished\n+-- by delaying each event for a given time. If another event\n+-- is registered for the same key within that timeframe,\n+-- only the new event will fire.\n+newtype Debouncer k = Debouncer (Var (Map k (Async ())))\n+\n+newtype MicroSeconds = MicroSeconds Int"
  },
  {
    "id" : "066b1395-54b5-44b0-965a-c103f14f9ef5",
    "prId" : 1991,
    "comments" : [
      {
        "id" : "91ddc967-0b98-4177-8f3a-e7dc621c228b",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "This is OK, but a little sad that you always wait the 0.1 even though you know you aren't getting any new things coming in. Not easy to make it better without making it more complex though. Best I can suggest is having a `(Async (), IO ())` where the `IO ()` is a `once` that both try running. However, that's a lot of complexity for something not particularly valuable.",
        "createdAt" : "2019-07-03T15:09:41Z",
        "updatedAt" : "2019-07-03T16:50:14Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a53229c2-6163-4c0a-9c14-648f3c4181f2",
        "parentId" : "91ddc967-0b98-4177-8f3a-e7dc621c228b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’ve just removed `waitForEvents` since we don’t actually use it.",
        "createdAt" : "2019-07-03T15:12:19Z",
        "updatedAt" : "2019-07-03T16:50:14Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a7d31b98-8f23-4c0f-9fd9-79cae334a96a",
        "parentId" : "91ddc967-0b98-4177-8f3a-e7dc621c228b",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Oh, even better!",
        "createdAt" : "2019-07-03T15:13:32Z",
        "updatedAt" : "2019-07-03T16:50:14Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f441ff7fc8861ebde15ab3c043a96f0776a007c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,64 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module Development.IDE.Core.Debouncer\n+    ( Debouncer\n+    , newDebouncer\n+    , withDebouncer\n+    , registerEvent\n+    , killEvents\n+    , waitForEvents\n+    ) where\n+\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Control.Exception\n+import Control.Monad.Extra\n+import Data.Map.Strict (Map)\n+import qualified Data.Map.Strict as Map\n+import System.Time.Extra\n+\n+-- | A debouncer can be used to avoid triggering many events\n+-- (e.g. diagnostics) for the same key (e.g. the same file)\n+-- within a short timeframe. This is accomplished\n+-- by delaying each event for a given time. If another event\n+-- is registered for the same key within that timeframe,\n+-- only the new event will fire.\n+newtype Debouncer k = Debouncer (Var (Map k (Async ())))\n+\n+-- | Create a new empty debouncer.\n+newDebouncer :: IO (Debouncer k)\n+newDebouncer = do\n+    m <- newVar Map.empty\n+    pure $ Debouncer m\n+\n+-- | Operate on a bouncer and wait for all registered\n+-- events to fire.\n+withDebouncer :: (Debouncer k -> IO a) -> IO a\n+withDebouncer = bracket newDebouncer waitForEvents\n+\n+-- | Register an event that will fire after the given delay if no other event\n+-- for the same key gets registered until then.\n+--\n+-- If there is a pending event for the same key, the pending event will be killed.\n+-- Events are run unmasked so it is up to the user of `registerEvent`\n+-- to mask if required.\n+registerEvent :: Ord k => Debouncer k -> Seconds -> k -> IO () -> IO ()\n+registerEvent (Debouncer d) delay k fire = modifyVar_ d $ \\m -> mask_ $ do\n+    whenJust (Map.lookup k m) cancel\n+    a <- asyncWithUnmask $ \\unmask ->\n+        (unmask $ sleep delay >> fire) `finally`\n+        modifyVar_ d (pure . Map.delete k)\n+    pure $ Map.insert k a m\n+\n+-- | Kill all registered events and clear the map.\n+killEvents :: Debouncer k -> IO ()\n+killEvents (Debouncer d) = modifyVar_ d $ \\m -> do\n+    mapM_ cancel $ Map.elems m\n+    pure Map.empty\n+\n+-- | Wait for all registered events to fire.\n+waitForEvents :: Debouncer k -> IO ()\n+waitForEvents (Debouncer d) =\n+    withVar d $ \\m -> mapM_ wait $ Map.elems m"
  },
  {
    "id" : "1c285aae-85a3-4122-9c3a-0abb42726829",
    "prId" : 1991,
    "comments" : [
      {
        "id" : "7f988914-b33f-480b-8d21-41b8befb7b50",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "This is never used. Why have it?",
        "createdAt" : "2019-07-03T15:09:51Z",
        "updatedAt" : "2019-07-03T16:50:14Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8f950783-d042-4d5c-a8b2-10337e91fb52",
        "parentId" : "7f988914-b33f-480b-8d21-41b8befb7b50",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Removed, I wrote the API for the debouncer before implementing it and thought it might turn out to be useful.",
        "createdAt" : "2019-07-03T15:12:37Z",
        "updatedAt" : "2019-07-03T16:50:14Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6f441ff7fc8861ebde15ab3c043a96f0776a007c",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,64 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module Development.IDE.Core.Debouncer\n+    ( Debouncer\n+    , newDebouncer\n+    , withDebouncer\n+    , registerEvent\n+    , killEvents\n+    , waitForEvents\n+    ) where\n+\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Control.Exception\n+import Control.Monad.Extra\n+import Data.Map.Strict (Map)\n+import qualified Data.Map.Strict as Map\n+import System.Time.Extra\n+\n+-- | A debouncer can be used to avoid triggering many events\n+-- (e.g. diagnostics) for the same key (e.g. the same file)\n+-- within a short timeframe. This is accomplished\n+-- by delaying each event for a given time. If another event\n+-- is registered for the same key within that timeframe,\n+-- only the new event will fire.\n+newtype Debouncer k = Debouncer (Var (Map k (Async ())))\n+\n+-- | Create a new empty debouncer.\n+newDebouncer :: IO (Debouncer k)\n+newDebouncer = do\n+    m <- newVar Map.empty\n+    pure $ Debouncer m\n+\n+-- | Operate on a bouncer and wait for all registered\n+-- events to fire.\n+withDebouncer :: (Debouncer k -> IO a) -> IO a\n+withDebouncer = bracket newDebouncer waitForEvents\n+\n+-- | Register an event that will fire after the given delay if no other event\n+-- for the same key gets registered until then.\n+--\n+-- If there is a pending event for the same key, the pending event will be killed.\n+-- Events are run unmasked so it is up to the user of `registerEvent`\n+-- to mask if required.\n+registerEvent :: Ord k => Debouncer k -> Seconds -> k -> IO () -> IO ()\n+registerEvent (Debouncer d) delay k fire = modifyVar_ d $ \\m -> mask_ $ do\n+    whenJust (Map.lookup k m) cancel\n+    a <- asyncWithUnmask $ \\unmask ->\n+        (unmask $ sleep delay >> fire) `finally`\n+        modifyVar_ d (pure . Map.delete k)\n+    pure $ Map.insert k a m\n+\n+-- | Kill all registered events and clear the map.\n+killEvents :: Debouncer k -> IO ()\n+killEvents (Debouncer d) = modifyVar_ d $ \\m -> do"
  }
]