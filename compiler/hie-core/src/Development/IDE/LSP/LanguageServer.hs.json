[
  {
    "id" : "db10ebaa-87ba-4e98-88d2-e0fbe59a7672",
    "prId" : 1954,
    "comments" : [
      {
        "id" : "8ec3eefd-5173-42d9-adae-d87a4146eb61",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Why not just pattern match on the line above?",
        "createdAt" : "2019-07-01T09:17:27Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "145298ec-cf6e-4c10-b123-6b30df3844a5",
        "parentId" : "8ec3eefd-5173-42d9-adae-d87a4146eb61",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point, changed.  I managed to confuse myself with `DuplicateRecordFields` here.",
        "createdAt" : "2019-07-01T09:27:28Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c29c81c51906ef4fd0cbf4fc9b6b0590107e6f76",
    "line" : null,
    "diffHunk" : "@@ -116,12 +151,19 @@ runLanguageServer options userHandlers getIdeState = do\n -- | Things that get sent to us, but we don't deal with.\n --   Set them to avoid a warning in VS Code output.\n setHandlersIgnore :: PartialHandlers\n-setHandlersIgnore = PartialHandlers $ \\_ x -> return x\n-    {LSP.cancelNotificationHandler = none\n-    ,LSP.initializedHandler = none\n+setHandlersIgnore = PartialHandlers $ \\WithMessage{..} x -> return x\n+    {LSP.initializedHandler = none\n     }\n     where none = Just $ const $ return ()\n \n+cancelHandler :: (LspId -> IO ()) -> PartialHandlers\n+cancelHandler cancelRequest = PartialHandlers $ \\_ x -> return x\n+    {LSP.cancelNotificationHandler = Just $ \\msg@NotificationMessage {_params} -> do\n+            let reqId = case _params of CancelParams{_id} -> _id"
  },
  {
    "id" : "c6899214-b803-49a0-87c6-7fd92108c566",
    "prId" : 1954,
    "comments" : [
      {
        "id" : "a54265d7-1b42-42c1-a26f-0480684cbbf7",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\n            whenJust (LSP.cancelNotificationHandler x) ($ msg)\r\n```\r\n\r\nOtherwise you get ambiguities with TH (and I mean humans rather than just compilers)",
        "createdAt" : "2019-07-01T09:17:56Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9eb2df04-220c-477d-bcbf-ca7e303e5819",
        "parentId" : "a54265d7-1b42-42c1-a26f-0480684cbbf7",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point, I also get `hlint` suggesting to me that I create a type error:\r\n```\r\nhie-core/src/Development/IDE/LSP/LanguageServer.hs:164:56: Warning: Redundant bracket\r\nFound:\r\n  ($msg)\r\nPerhaps:\r\n  $msg\r\n```",
        "createdAt" : "2019-07-01T09:29:10Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7ff01033-1a9d-4b06-805f-4a4585dc6d21",
        "parentId" : "a54265d7-1b42-42c1-a26f-0480684cbbf7",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Yes, fixed in newer HLint! But also a sign of the TH confusion.",
        "createdAt" : "2019-07-01T09:48:41Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c29c81c51906ef4fd0cbf4fc9b6b0590107e6f76",
    "line" : null,
    "diffHunk" : "@@ -116,12 +151,19 @@ runLanguageServer options userHandlers getIdeState = do\n -- | Things that get sent to us, but we don't deal with.\n --   Set them to avoid a warning in VS Code output.\n setHandlersIgnore :: PartialHandlers\n-setHandlersIgnore = PartialHandlers $ \\_ x -> return x\n-    {LSP.cancelNotificationHandler = none\n-    ,LSP.initializedHandler = none\n+setHandlersIgnore = PartialHandlers $ \\WithMessage{..} x -> return x\n+    {LSP.initializedHandler = none\n     }\n     where none = Just $ const $ return ()\n \n+cancelHandler :: (LspId -> IO ()) -> PartialHandlers\n+cancelHandler cancelRequest = PartialHandlers $ \\_ x -> return x\n+    {LSP.cancelNotificationHandler = Just $ \\msg@NotificationMessage {_params} -> do\n+            let reqId = case _params of CancelParams{_id} -> _id\n+            cancelRequest reqId\n+            whenJust (LSP.cancelNotificationHandler x) ($msg)"
  },
  {
    "id" : "3bc2a430-f0a7-43fe-85df-0d83149d5bd7",
    "prId" : 1954,
    "comments" : [
      {
        "id" : "5f5cb899-42ca-4627-b417-44814cb8eedc",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\nsetHandlersIgnore = PartialHandlers $ \\_ x -> return x\r\n```",
        "createdAt" : "2019-07-01T09:18:29Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c29c81c51906ef4fd0cbf4fc9b6b0590107e6f76",
    "line" : null,
    "diffHunk" : "@@ -116,12 +151,19 @@ runLanguageServer options userHandlers getIdeState = do\n -- | Things that get sent to us, but we don't deal with.\n --   Set them to avoid a warning in VS Code output.\n setHandlersIgnore :: PartialHandlers\n-setHandlersIgnore = PartialHandlers $ \\_ x -> return x\n-    {LSP.cancelNotificationHandler = none\n-    ,LSP.initializedHandler = none\n+setHandlersIgnore = PartialHandlers $ \\WithMessage{..} x -> return x"
  },
  {
    "id" : "51db3c37-a664-4dfb-8c6e-409f1d1a68aa",
    "prId" : 1954,
    "comments" : [
      {
        "id" : "4b2cabd3-b040-45b0-a7e3-451d6d2dbb69",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd be tempted to use the optimisation of doing a quick \"is it in the cancel set\" before calling `act`. I'm worry that doing this way encourages a lot of async exceptions, and we know that certain places (e.g. TH) go wrong with such exceptions. That said, this approach will quickly weed out such issues, so maybe that's a good thing.",
        "createdAt" : "2019-07-01T09:22:49Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dbdaff31-46cf-4e95-8d63-509bc46d57b5",
        "parentId" : "4b2cabd3-b040-45b0-a7e3-451d6d2dbb69",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I considered doing that but then decided against it exactly for the reasons you mentioned. Iâ€™d rather see things blow up and then fix them properly than try to hide them.",
        "createdAt" : "2019-07-01T09:31:38Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d4b33302-ff67-48ac-b63e-e7802b89dfab",
        "parentId" : "4b2cabd3-b040-45b0-a7e3-451d6d2dbb69",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Perhaps write a comment to that effect?",
        "createdAt" : "2019-07-01T09:48:57Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "207947ee-091f-4f70-85ca-1426ce3772b6",
        "parentId" : "4b2cabd3-b040-45b0-a7e3-451d6d2dbb69",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, added a comment.",
        "createdAt" : "2019-07-01T09:54:21Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c29c81c51906ef4fd0cbf4fc9b6b0590107e6f76",
    "line" : 85,
    "diffHunk" : "@@ -100,9 +127,17 @@ runLanguageServer options userHandlers getIdeState = do\n                                 \"Message: \" ++ show x ++ \"\\n\" ++\n                                 \"Exception: \" ++ show e\n                     Response x@RequestMessage{_id, _params} wrap act ->\n+                        flip finally (clearReqId _id) $\n                         catch (do\n-                            res <- act lspFuncs ide _params\n-                            sendFunc $ wrap $ ResponseMessage \"2.0\" (responseId _id) (Just res) Nothing\n+                            cancelOrRes <- race (waitForCancel _id) $ act lspFuncs ide _params"
  },
  {
    "id" : "e0da26c2-2346-4734-9081-3edb6f822262",
    "prId" : 1954,
    "comments" : [
      {
        "id" : "bbb9aaff-4b3f-4c94-bf34-46be07c46f9d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    let waitForCancel reqId = atomically $ do\r\n```",
        "createdAt" : "2019-07-01T10:16:47Z",
        "updatedAt" : "2019-07-01T10:40:39Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c29c81c51906ef4fd0cbf4fc9b6b0590107e6f76",
    "line" : null,
    "diffHunk" : "@@ -65,30 +67,55 @@ runLanguageServer options userHandlers getIdeState = do\n     -- dies and can be restarted instead of losing threads silently.\n     clientMsgBarrier <- newBarrier\n \n-    let withResponse wrap f = Just $ \\r -> writeChan clientMsgChan $ Response r wrap f\n+    -- The set of requests ids that we have received but not finished processing\n+    pendingRequests <- newTVarIO Set.empty\n+    -- The set of requests that have been cancelled and are also in pendingRequests\n+    cancelledRequests <- newTVarIO Set.empty\n+\n+    let withResponse wrap f = Just $ \\r@RequestMessage{_id} -> do\n+            atomically $ modifyTVar pendingRequests (Set.insert _id)\n+            writeChan clientMsgChan $ Response r wrap f\n     let withNotification old f = Just $ \\r -> writeChan clientMsgChan $ Notification r (\\lsp ide x -> f lsp ide x >> whenJust old ($ r))\n+    let cancelRequest reqId = atomically $ do\n+            queued <- readTVar pendingRequests\n+            -- We want to avoid that the list of cancelled requests\n+            -- keeps growing if we receive cancellations for requests\n+            -- that do not exist or have already been processed.\n+            when (reqId `elem` queued) $\n+                modifyTVar cancelledRequests (Set.insert reqId)\n+    let clearReqId reqId = atomically $ do\n+            modifyTVar pendingRequests (Set.delete reqId)\n+            modifyTVar cancelledRequests (Set.delete reqId)\n+        -- We implement request cancellation by racing waitForCancel against\n+        -- the actual request handler.\n+        waitForCancel reqId = atomically $ do"
  },
  {
    "id" : "cc199086-333a-4f30-925e-97a61c966297",
    "prId" : 1873,
    "comments" : [
      {
        "id" : "8637a165-101f-4ef5-ade3-582612c47d5d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`haskell-lsp` should already take care of this for us https://github.com/alanz/haskell-lsp/blob/47956ad564dcf03472dce00e8d9a6cc13947e6a1/src/Language/Haskell/LSP/Control.hs#L67",
        "createdAt" : "2019-06-26T06:59:27Z",
        "updatedAt" : "2019-06-26T07:36:57Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f3eae75c-bf15-440a-8e7e-e08292c30218",
        "parentId" : "8637a165-101f-4ef5-ade3-582612c47d5d",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Those are the handles that LSP uses for communication on. The purpose of this change is so that our logging messages arrive promptly. The reason for adding these changes is that I was observing huge amounts of buffering, which was making debugging way harder.",
        "createdAt" : "2019-06-26T07:30:04Z",
        "updatedAt" : "2019-06-26T07:36:57Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "eb0359afdc4acb55e9f56e734006e26ddfed3ea2",
    "line" : 28,
    "diffHunk" : "@@ -32,14 +35,18 @@ import Language.Haskell.LSP.Messages\n \n \n runLanguageServer\n-    :: ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n+    :: LSP.Options\n+    -> PartialHandlers\n+    -> ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n     -> IO ()\n-runLanguageServer getIdeState = do\n+runLanguageServer options userHandlers getIdeState = do\n     -- Move stdout to another file descriptor and duplicate stderr\n     -- to stdout. This guards against stray prints from corrupting the JSON-RPC\n     -- message stream.\n     newStdout <- hDuplicate stdout\n     stderr `hDuplicateTo` stdout\n+    hSetBuffering stderr NoBuffering"
  },
  {
    "id" : "9e21cbe3-f2ee-4ff1-997e-56c7bdde373f",
    "prId" : 1873,
    "comments" : [
      {
        "id" : "84254a31-53e9-400d-ab38-e7d7be4d63c5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The default handler here is quite reasonable so Iâ€™m not sure we need to override it https://github.com/alanz/haskell-lsp/blob/d00f83700cdc681f65015c7343206c134919d15f/src/Language/Haskell/LSP/Core.hs#L309",
        "createdAt" : "2019-06-26T07:01:36Z",
        "updatedAt" : "2019-06-26T07:36:57Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4e07e038-8020-487b-a0e6-388e2725e510",
        "parentId" : "84254a31-53e9-400d-ab38-e7d7be4d63c5",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Ah, didn't see the default, will delete. FWIW, before we captured the close notification and shut down on that, which is definitely the wrong thing to do...",
        "createdAt" : "2019-06-26T07:28:58Z",
        "updatedAt" : "2019-06-26T07:36:57Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5edb07f7-d808-4563-9f0e-f40ae0afe70d",
        "parentId" : "84254a31-53e9-400d-ab38-e7d7be4d63c5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yeah that was left over from before we switched to `haskell-lsp`. We never actually got to that code path afaik.",
        "createdAt" : "2019-06-26T07:29:41Z",
        "updatedAt" : "2019-06-26T07:36:57Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "68d86d7f-bfbd-4eeb-a72e-6d3376eaa758",
        "parentId" : "84254a31-53e9-400d-ab38-e7d7be4d63c5",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "My reading was we would - when the shutdown message came in we exited, and VS Code is meant to send shutdown first, then exit. Either way, dropping this code is much nicer.",
        "createdAt" : "2019-06-26T07:37:48Z",
        "updatedAt" : "2019-06-26T07:37:48Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eb0359afdc4acb55e9f56e734006e26ddfed3ea2",
    "line" : null,
    "diffHunk" : "@@ -89,18 +100,20 @@ runLanguageServer getIdeState = do\n \n -- | Things that get sent to us, but we don't deal with.\n --   Set them to avoid a warning in VS Code output.\n-setHandlersIgnore :: WithMessage -> LSP.Handlers -> IO LSP.Handlers\n-setHandlersIgnore _ x = return x\n+setHandlersIgnore :: PartialHandlers\n+setHandlersIgnore = PartialHandlers $ \\_ x -> return x\n     {LSP.cancelNotificationHandler = none\n     ,LSP.initializedHandler = none\n-    ,LSP.codeLensHandler = none -- FIXME: Stop saying we support it in 'options'\n     }\n     where none = Just $ const $ return ()\n \n \n-mergeHandlers :: [WithMessage -> LSP.Handlers -> IO LSP.Handlers] -> WithMessage -> LSP.Handlers -> IO LSP.Handlers\n-mergeHandlers = foldl f (\\_ a -> return a)\n-    where f x1 x2 r a = x1 r a >>= x2 r\n+setHandlersExit :: PartialHandlers\n+setHandlersExit = PartialHandlers $ \\WithMessage{..} x -> return x"
  },
  {
    "id" : "2e2f7cfb-8d0b-4d4e-bd21-4e5806610639",
    "prId" : 1862,
    "comments" : [
      {
        "id" : "0c0645a1-ede7-4eb6-bea3-faeed89b5046",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I donâ€™t think this is a good idea. By setting this to `Just` you announce in the capabilities that you support cancelling. Setting it to `Nothing` so you donâ€™t even get the message seems like a better option.",
        "createdAt" : "2019-06-25T12:46:29Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f10e3e62-2d41-4476-868d-a4fbebd25a57",
        "parentId" : "0c0645a1-ede7-4eb6-bea3-faeed89b5046",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Setting it to Nothing doesn't mean we don't get the messages. I only added none for things I was already getting messages for.",
        "createdAt" : "2019-06-25T13:29:00Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9d0f245e-7c7b-4af6-b9b5-c2020a05490e",
        "parentId" : "0c0645a1-ede7-4eb6-bea3-faeed89b5046",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point, for some reason I thought this was controlled via a capability but looks like that is not the case.",
        "createdAt" : "2019-06-25T14:00:14Z",
        "updatedAt" : "2019-06-25T14:01:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7bc9e951e1b9870a20cebab7f75884497a5ac28e",
    "line" : 230,
    "diffHunk" : "@@ -12,144 +11,102 @@ module Development.IDE.LSP.LanguageServer\n     ) where\n \n import           Development.IDE.LSP.Protocol\n-import           Development.IDE.LSP.Server\n+import           Development.IDE.LSP.Server hiding (runServer)\n+import qualified Language.Haskell.LSP.Control as LSP\n+import qualified Language.Haskell.LSP.Core as LSP\n+import Control.Concurrent.STM\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Data.Default\n+import           GHC.IO.Handle                    (hDuplicate, hDuplicateTo)\n+import System.IO\n+import Control.Monad\n \n-import Control.Monad.IO.Class\n import qualified Development.IDE.LSP.Definition as LS.Definition\n import qualified Development.IDE.LSP.Hover      as LS.Hover\n-import Development.IDE.Types.Logger\n+import Development.IDE.LSP.Notifications\n import Development.IDE.Core.Service\n-import Development.IDE.Types.Location\n-\n-import qualified Data.Aeson                                as Aeson\n-import qualified Data.Rope.UTF16 as Rope\n-import qualified Data.Set                                  as S\n-import qualified Data.Text as T\n-\n import Development.IDE.Core.FileStore\n-import Development.IDE.Core.OfInterest\n-\n-import qualified Network.URI                               as URI\n-\n-import qualified System.Exit\n-\n import Language.Haskell.LSP.Core (LspFuncs(..))\n import Language.Haskell.LSP.Messages\n-import Language.Haskell.LSP.VFS\n-\n-textShow :: Show a => a -> T.Text\n-textShow = T.pack . show\n-\n-------------------------------------------------------------------------\n--- Request handlers\n-------------------------------------------------------------------------\n-\n-handleRequest\n-    :: Logger\n-    -> IdeState\n-    -> (forall resp. resp -> ResponseMessage resp)\n-    -> (ErrorCode -> ResponseMessage ())\n-    -> ServerRequest\n-    -> IO FromServerMessage\n-handleRequest logger compilerH makeResponse makeErrorResponse = \\case\n-    Shutdown -> do\n-      logInfo logger \"Shutdown request received, terminating.\"\n-      System.Exit.exitSuccess\n-\n-    KeepAlive -> pure $ RspCustomServer $ makeResponse Aeson.Null\n-\n-    Definition params -> RspDefinition . makeResponse <$> LS.Definition.handle logger compilerH params\n-    Hover params -> RspHover . makeResponse <$> LS.Hover.handle logger compilerH params\n-    CodeLens _params -> pure $ RspCodeLens $ makeResponse mempty\n-\n-    req -> do\n-        logWarning logger (\"Method not found\" <> T.pack (show req))\n-        pure $ RspError $ makeErrorResponse MethodNotFound\n-\n-\n-handleNotification :: LspFuncs () -> Logger -> IdeState -> ServerNotification -> IO ()\n-handleNotification lspFuncs logger compilerH = \\case\n-\n-    DidOpenTextDocument (DidOpenTextDocumentParams item) -> do\n-        case URI.parseURI $ T.unpack $ getUri $ _uri (item :: TextDocumentItem) of\n-          Just uri\n-              | URI.uriScheme uri == \"file:\"\n-              -> handleDidOpenFile item\n-\n-              | otherwise\n-              -> logWarning logger $ \"Unknown scheme in URI: \"\n-                    <> textShow uri\n-\n-          _ -> logSeriousError logger $ \"Invalid URI in DidOpenTextDocument: \"\n-                    <> textShow (_uri (item :: TextDocumentItem))\n-\n-    DidChangeTextDocument (DidChangeTextDocumentParams docId _) -> do\n-        let uri = _uri (docId :: VersionedTextDocumentIdentifier)\n-\n-        case uriToFilePath' uri of\n-          Just (toNormalizedFilePath -> filePath) -> do\n-            mbVirtual <- getVirtualFileFunc lspFuncs $ toNormalizedUri uri\n-            let contents = maybe \"\" (Rope.toText . (_text :: VirtualFile -> Rope.Rope)) mbVirtual\n-            onFileModified compilerH filePath (Just contents)\n-            logInfo logger\n-              $ \"Updated text document: \" <> textShow (fromNormalizedFilePath filePath)\n-\n-          Nothing ->\n-            logSeriousError logger\n-              $ \"Invalid file path: \" <> textShow (_uri (docId :: VersionedTextDocumentIdentifier))\n-\n-    DidCloseTextDocument (DidCloseTextDocumentParams (TextDocumentIdentifier uri)) ->\n-        case URI.parseURI $ T.unpack $ getUri uri of\n-          Just uri'\n-              | URI.uriScheme uri' == \"file:\" -> do\n-                    Just fp <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-                    handleDidCloseFile fp\n-              | otherwise -> logWarning logger $ \"Unknown scheme in URI: \" <> textShow uri\n-\n-          _ -> logSeriousError logger\n-                 $    \"Invalid URI in DidCloseTextDocument: \"\n-                   <> textShow uri\n-\n-    DidSaveTextDocument _params ->\n-      pure ()\n-\n-    UnknownNotification _method _params -> return ()\n-  where\n-    -- Note that the state changes here are not atomic.\n-    -- When we have parallel compilation we could manage the state\n-    -- changes in STM so that we can atomically change the state.\n-    -- Internally it should be done via the IO oracle. See PROD-2808.\n-    handleDidOpenFile (TextDocumentItem uri _ _ contents) = do\n-        Just filePath <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-        onFileModified compilerH filePath (Just contents)\n-        modifyFilesOfInterest compilerH (S.insert filePath)\n-        logInfo logger $ \"Opened text document: \" <> textShow filePath\n-\n-    handleDidCloseFile filePath = do\n-         logInfo logger $ \"Closed text document: \" <> textShow (fromNormalizedFilePath filePath)\n-         onFileModified compilerH filePath Nothing\n-         modifyFilesOfInterest compilerH (S.delete filePath)\n-\n--- | Manages the file store (caching compilation results and unsaved content).\n-onFileModified\n-    :: IdeState\n-    -> NormalizedFilePath\n-    -> Maybe T.Text\n-    -> IO ()\n-onFileModified service fp mbContents = do\n-    logDebug (ideLogger service) $ \"File modified \" <> T.pack (show fp)\n-    setBufferModified service fp mbContents\n \n-------------------------------------------------------------------------\n--- Server execution\n-------------------------------------------------------------------------\n \n runLanguageServer\n-    :: Logger\n-    -> ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n+    :: ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n     -> IO ()\n-runLanguageServer loggerH getIdeState = do\n-    let getHandlers lspFuncs = do\n-            compilerH <- getIdeState (sendFunc lspFuncs) (makeLSPVFSHandle lspFuncs)\n-            pure $ Handlers (handleRequest loggerH compilerH) (handleNotification lspFuncs loggerH compilerH)\n-    liftIO $ runServer loggerH getHandlers\n+runLanguageServer getIdeState = do\n+    -- Move stdout to another file descriptor and duplicate stderr\n+    -- to stdout. This guards against stray prints from corrupting the JSON-RPC\n+    -- message stream.\n+    newStdout <- hDuplicate stdout\n+    stderr `hDuplicateTo` stdout\n+\n+    -- Print out a single space to assert that the above redirection works.\n+    -- This is interleaved with the logger, hence we just print a space here in\n+    -- order not to mess up the output too much. Verified that this breaks\n+    -- the language server tests without the redirection.\n+    putStr \" \" >> hFlush stdout\n+\n+    clientMsgChan :: TChan AddItem <- newTChanIO\n+    -- These barriers are signaled when the threads reading from these chans exit.\n+    -- This should not happen but if it does, we will make sure that the whole server\n+    -- dies and can be restarted instead of losing threads silently.\n+    clientMsgBarrier <- newBarrier\n+\n+    let runHandler = RunHandler\n+            (\\wrap f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddResponse r wrap f)\n+            (\\f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddNotification r f)\n+    handlers <- mergeHandlers [LS.Definition.addGotoDefinition, LS.Hover.addOnHover, addNotifications, addIgnored] runHandler def\n+\n+    void $ waitAnyCancel =<< traverse async\n+        [ void $ LSP.runWithHandles\n+            stdin\n+            newStdout\n+            ( const $ Right ()\n+            , handleInit (signalBarrier clientMsgBarrier ()) clientMsgChan\n+            )\n+            handlers\n+            options\n+            Nothing\n+        , void $ waitBarrier clientMsgBarrier\n+        ]\n+    where\n+        handleInit :: IO () -> TChan AddItem -> LSP.LspFuncs () -> IO (Maybe err)\n+        handleInit exitClientMsg clientMsgChan lspFuncs@LSP.LspFuncs{..} = do\n+            ide <- getIdeState sendFunc (makeLSPVFSHandle lspFuncs)\n+            _ <- flip forkFinally (const exitClientMsg) $ forever $ do\n+                msg <- atomically $ readTChan clientMsgChan\n+                case msg of\n+                    AddNotification NotificationMessage{_params} act -> act ide _params\n+                    AddResponse RequestMessage{_id, _params} wrap act -> do\n+                        res <- act ide _params\n+                        sendFunc $ wrap $ ResponseMessage \"2.0\" (responseId _id) (Just res) Nothing\n+            pure Nothing\n+\n+\n+-- | Things that come up regularly, but we don't deal with\n+addIgnored :: RunHandler -> LSP.Handlers -> IO LSP.Handlers\n+addIgnored _ x = return x\n+    {LSP.cancelNotificationHandler = none"
  },
  {
    "id" : "9b462151-7fa7-4613-933f-9da305c1c89b",
    "prId" : 1862,
    "comments" : [
      {
        "id" : "5c72b5bc-bd89-4a3b-b108-8b0da9b54d5d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This seems odd, why should we announce that we support codelenses if we ignore them?",
        "createdAt" : "2019-06-25T12:46:51Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6298ea12-6a19-43ff-a916-d0822179f7e7",
        "parentId" : "5c72b5bc-bd89-4a3b-b108-8b0da9b54d5d",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Because the options are tied inside LanguageServer. I'll break them out in a future patch and then this line can be gone.",
        "createdAt" : "2019-06-25T13:29:24Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7bc9e951e1b9870a20cebab7f75884497a5ac28e",
    "line" : null,
    "diffHunk" : "@@ -12,144 +11,102 @@ module Development.IDE.LSP.LanguageServer\n     ) where\n \n import           Development.IDE.LSP.Protocol\n-import           Development.IDE.LSP.Server\n+import           Development.IDE.LSP.Server hiding (runServer)\n+import qualified Language.Haskell.LSP.Control as LSP\n+import qualified Language.Haskell.LSP.Core as LSP\n+import Control.Concurrent.STM\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Data.Default\n+import           GHC.IO.Handle                    (hDuplicate, hDuplicateTo)\n+import System.IO\n+import Control.Monad\n \n-import Control.Monad.IO.Class\n import qualified Development.IDE.LSP.Definition as LS.Definition\n import qualified Development.IDE.LSP.Hover      as LS.Hover\n-import Development.IDE.Types.Logger\n+import Development.IDE.LSP.Notifications\n import Development.IDE.Core.Service\n-import Development.IDE.Types.Location\n-\n-import qualified Data.Aeson                                as Aeson\n-import qualified Data.Rope.UTF16 as Rope\n-import qualified Data.Set                                  as S\n-import qualified Data.Text as T\n-\n import Development.IDE.Core.FileStore\n-import Development.IDE.Core.OfInterest\n-\n-import qualified Network.URI                               as URI\n-\n-import qualified System.Exit\n-\n import Language.Haskell.LSP.Core (LspFuncs(..))\n import Language.Haskell.LSP.Messages\n-import Language.Haskell.LSP.VFS\n-\n-textShow :: Show a => a -> T.Text\n-textShow = T.pack . show\n-\n-------------------------------------------------------------------------\n--- Request handlers\n-------------------------------------------------------------------------\n-\n-handleRequest\n-    :: Logger\n-    -> IdeState\n-    -> (forall resp. resp -> ResponseMessage resp)\n-    -> (ErrorCode -> ResponseMessage ())\n-    -> ServerRequest\n-    -> IO FromServerMessage\n-handleRequest logger compilerH makeResponse makeErrorResponse = \\case\n-    Shutdown -> do\n-      logInfo logger \"Shutdown request received, terminating.\"\n-      System.Exit.exitSuccess\n-\n-    KeepAlive -> pure $ RspCustomServer $ makeResponse Aeson.Null\n-\n-    Definition params -> RspDefinition . makeResponse <$> LS.Definition.handle logger compilerH params\n-    Hover params -> RspHover . makeResponse <$> LS.Hover.handle logger compilerH params\n-    CodeLens _params -> pure $ RspCodeLens $ makeResponse mempty\n-\n-    req -> do\n-        logWarning logger (\"Method not found\" <> T.pack (show req))\n-        pure $ RspError $ makeErrorResponse MethodNotFound\n-\n-\n-handleNotification :: LspFuncs () -> Logger -> IdeState -> ServerNotification -> IO ()\n-handleNotification lspFuncs logger compilerH = \\case\n-\n-    DidOpenTextDocument (DidOpenTextDocumentParams item) -> do\n-        case URI.parseURI $ T.unpack $ getUri $ _uri (item :: TextDocumentItem) of\n-          Just uri\n-              | URI.uriScheme uri == \"file:\"\n-              -> handleDidOpenFile item\n-\n-              | otherwise\n-              -> logWarning logger $ \"Unknown scheme in URI: \"\n-                    <> textShow uri\n-\n-          _ -> logSeriousError logger $ \"Invalid URI in DidOpenTextDocument: \"\n-                    <> textShow (_uri (item :: TextDocumentItem))\n-\n-    DidChangeTextDocument (DidChangeTextDocumentParams docId _) -> do\n-        let uri = _uri (docId :: VersionedTextDocumentIdentifier)\n-\n-        case uriToFilePath' uri of\n-          Just (toNormalizedFilePath -> filePath) -> do\n-            mbVirtual <- getVirtualFileFunc lspFuncs $ toNormalizedUri uri\n-            let contents = maybe \"\" (Rope.toText . (_text :: VirtualFile -> Rope.Rope)) mbVirtual\n-            onFileModified compilerH filePath (Just contents)\n-            logInfo logger\n-              $ \"Updated text document: \" <> textShow (fromNormalizedFilePath filePath)\n-\n-          Nothing ->\n-            logSeriousError logger\n-              $ \"Invalid file path: \" <> textShow (_uri (docId :: VersionedTextDocumentIdentifier))\n-\n-    DidCloseTextDocument (DidCloseTextDocumentParams (TextDocumentIdentifier uri)) ->\n-        case URI.parseURI $ T.unpack $ getUri uri of\n-          Just uri'\n-              | URI.uriScheme uri' == \"file:\" -> do\n-                    Just fp <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-                    handleDidCloseFile fp\n-              | otherwise -> logWarning logger $ \"Unknown scheme in URI: \" <> textShow uri\n-\n-          _ -> logSeriousError logger\n-                 $    \"Invalid URI in DidCloseTextDocument: \"\n-                   <> textShow uri\n-\n-    DidSaveTextDocument _params ->\n-      pure ()\n-\n-    UnknownNotification _method _params -> return ()\n-  where\n-    -- Note that the state changes here are not atomic.\n-    -- When we have parallel compilation we could manage the state\n-    -- changes in STM so that we can atomically change the state.\n-    -- Internally it should be done via the IO oracle. See PROD-2808.\n-    handleDidOpenFile (TextDocumentItem uri _ _ contents) = do\n-        Just filePath <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-        onFileModified compilerH filePath (Just contents)\n-        modifyFilesOfInterest compilerH (S.insert filePath)\n-        logInfo logger $ \"Opened text document: \" <> textShow filePath\n-\n-    handleDidCloseFile filePath = do\n-         logInfo logger $ \"Closed text document: \" <> textShow (fromNormalizedFilePath filePath)\n-         onFileModified compilerH filePath Nothing\n-         modifyFilesOfInterest compilerH (S.delete filePath)\n-\n--- | Manages the file store (caching compilation results and unsaved content).\n-onFileModified\n-    :: IdeState\n-    -> NormalizedFilePath\n-    -> Maybe T.Text\n-    -> IO ()\n-onFileModified service fp mbContents = do\n-    logDebug (ideLogger service) $ \"File modified \" <> T.pack (show fp)\n-    setBufferModified service fp mbContents\n \n-------------------------------------------------------------------------\n--- Server execution\n-------------------------------------------------------------------------\n \n runLanguageServer\n-    :: Logger\n-    -> ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n+    :: ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n     -> IO ()\n-runLanguageServer loggerH getIdeState = do\n-    let getHandlers lspFuncs = do\n-            compilerH <- getIdeState (sendFunc lspFuncs) (makeLSPVFSHandle lspFuncs)\n-            pure $ Handlers (handleRequest loggerH compilerH) (handleNotification lspFuncs loggerH compilerH)\n-    liftIO $ runServer loggerH getHandlers\n+runLanguageServer getIdeState = do\n+    -- Move stdout to another file descriptor and duplicate stderr\n+    -- to stdout. This guards against stray prints from corrupting the JSON-RPC\n+    -- message stream.\n+    newStdout <- hDuplicate stdout\n+    stderr `hDuplicateTo` stdout\n+\n+    -- Print out a single space to assert that the above redirection works.\n+    -- This is interleaved with the logger, hence we just print a space here in\n+    -- order not to mess up the output too much. Verified that this breaks\n+    -- the language server tests without the redirection.\n+    putStr \" \" >> hFlush stdout\n+\n+    clientMsgChan :: TChan AddItem <- newTChanIO\n+    -- These barriers are signaled when the threads reading from these chans exit.\n+    -- This should not happen but if it does, we will make sure that the whole server\n+    -- dies and can be restarted instead of losing threads silently.\n+    clientMsgBarrier <- newBarrier\n+\n+    let runHandler = RunHandler\n+            (\\wrap f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddResponse r wrap f)\n+            (\\f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddNotification r f)\n+    handlers <- mergeHandlers [LS.Definition.addGotoDefinition, LS.Hover.addOnHover, addNotifications, addIgnored] runHandler def\n+\n+    void $ waitAnyCancel =<< traverse async\n+        [ void $ LSP.runWithHandles\n+            stdin\n+            newStdout\n+            ( const $ Right ()\n+            , handleInit (signalBarrier clientMsgBarrier ()) clientMsgChan\n+            )\n+            handlers\n+            options\n+            Nothing\n+        , void $ waitBarrier clientMsgBarrier\n+        ]\n+    where\n+        handleInit :: IO () -> TChan AddItem -> LSP.LspFuncs () -> IO (Maybe err)\n+        handleInit exitClientMsg clientMsgChan lspFuncs@LSP.LspFuncs{..} = do\n+            ide <- getIdeState sendFunc (makeLSPVFSHandle lspFuncs)\n+            _ <- flip forkFinally (const exitClientMsg) $ forever $ do\n+                msg <- atomically $ readTChan clientMsgChan\n+                case msg of\n+                    AddNotification NotificationMessage{_params} act -> act ide _params\n+                    AddResponse RequestMessage{_id, _params} wrap act -> do\n+                        res <- act ide _params\n+                        sendFunc $ wrap $ ResponseMessage \"2.0\" (responseId _id) (Just res) Nothing\n+            pure Nothing\n+\n+\n+-- | Things that come up regularly, but we don't deal with\n+addIgnored :: RunHandler -> LSP.Handlers -> IO LSP.Handlers\n+addIgnored _ x = return x\n+    {LSP.cancelNotificationHandler = none\n+    ,LSP.initializedHandler = none\n+    ,LSP.codeLensHandler = none"
  },
  {
    "id" : "b3275fdb-29b1-4ca0-8f14-412a4612fed4",
    "prId" : 1862,
    "comments" : [
      {
        "id" : "226ffd6a-6149-423e-9f38-392cd43c45fa",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What do we gain from having this be an existential as opposed to just storing something like `IO FromServerMessage` here? Seems like there is only one thing I can do here anyway.",
        "createdAt" : "2019-06-25T12:53:06Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e1a29faa-c349-4283-b8b2-3c97e24b4b79",
        "parentId" : "226ffd6a-6149-423e-9f38-392cd43c45fa",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Type safety and abstraction - you manage to pin down that you are giving back the right response, and you can fill in all the details of `ResponseMessage` like the response id for the user.",
        "createdAt" : "2019-06-25T13:31:59Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7bc9e951e1b9870a20cebab7f75884497a5ac28e",
    "line" : null,
    "diffHunk" : "@@ -12,144 +11,102 @@ module Development.IDE.LSP.LanguageServer\n     ) where\n \n import           Development.IDE.LSP.Protocol\n-import           Development.IDE.LSP.Server\n+import           Development.IDE.LSP.Server hiding (runServer)\n+import qualified Language.Haskell.LSP.Control as LSP\n+import qualified Language.Haskell.LSP.Core as LSP\n+import Control.Concurrent.STM\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Data.Default\n+import           GHC.IO.Handle                    (hDuplicate, hDuplicateTo)\n+import System.IO\n+import Control.Monad\n \n-import Control.Monad.IO.Class\n import qualified Development.IDE.LSP.Definition as LS.Definition\n import qualified Development.IDE.LSP.Hover      as LS.Hover\n-import Development.IDE.Types.Logger\n+import Development.IDE.LSP.Notifications\n import Development.IDE.Core.Service\n-import Development.IDE.Types.Location\n-\n-import qualified Data.Aeson                                as Aeson\n-import qualified Data.Rope.UTF16 as Rope\n-import qualified Data.Set                                  as S\n-import qualified Data.Text as T\n-\n import Development.IDE.Core.FileStore\n-import Development.IDE.Core.OfInterest\n-\n-import qualified Network.URI                               as URI\n-\n-import qualified System.Exit\n-\n import Language.Haskell.LSP.Core (LspFuncs(..))\n import Language.Haskell.LSP.Messages\n-import Language.Haskell.LSP.VFS\n-\n-textShow :: Show a => a -> T.Text\n-textShow = T.pack . show\n-\n-------------------------------------------------------------------------\n--- Request handlers\n-------------------------------------------------------------------------\n-\n-handleRequest\n-    :: Logger\n-    -> IdeState\n-    -> (forall resp. resp -> ResponseMessage resp)\n-    -> (ErrorCode -> ResponseMessage ())\n-    -> ServerRequest\n-    -> IO FromServerMessage\n-handleRequest logger compilerH makeResponse makeErrorResponse = \\case\n-    Shutdown -> do\n-      logInfo logger \"Shutdown request received, terminating.\"\n-      System.Exit.exitSuccess\n-\n-    KeepAlive -> pure $ RspCustomServer $ makeResponse Aeson.Null\n-\n-    Definition params -> RspDefinition . makeResponse <$> LS.Definition.handle logger compilerH params\n-    Hover params -> RspHover . makeResponse <$> LS.Hover.handle logger compilerH params\n-    CodeLens _params -> pure $ RspCodeLens $ makeResponse mempty\n-\n-    req -> do\n-        logWarning logger (\"Method not found\" <> T.pack (show req))\n-        pure $ RspError $ makeErrorResponse MethodNotFound\n-\n-\n-handleNotification :: LspFuncs () -> Logger -> IdeState -> ServerNotification -> IO ()\n-handleNotification lspFuncs logger compilerH = \\case\n-\n-    DidOpenTextDocument (DidOpenTextDocumentParams item) -> do\n-        case URI.parseURI $ T.unpack $ getUri $ _uri (item :: TextDocumentItem) of\n-          Just uri\n-              | URI.uriScheme uri == \"file:\"\n-              -> handleDidOpenFile item\n-\n-              | otherwise\n-              -> logWarning logger $ \"Unknown scheme in URI: \"\n-                    <> textShow uri\n-\n-          _ -> logSeriousError logger $ \"Invalid URI in DidOpenTextDocument: \"\n-                    <> textShow (_uri (item :: TextDocumentItem))\n-\n-    DidChangeTextDocument (DidChangeTextDocumentParams docId _) -> do\n-        let uri = _uri (docId :: VersionedTextDocumentIdentifier)\n-\n-        case uriToFilePath' uri of\n-          Just (toNormalizedFilePath -> filePath) -> do\n-            mbVirtual <- getVirtualFileFunc lspFuncs $ toNormalizedUri uri\n-            let contents = maybe \"\" (Rope.toText . (_text :: VirtualFile -> Rope.Rope)) mbVirtual\n-            onFileModified compilerH filePath (Just contents)\n-            logInfo logger\n-              $ \"Updated text document: \" <> textShow (fromNormalizedFilePath filePath)\n-\n-          Nothing ->\n-            logSeriousError logger\n-              $ \"Invalid file path: \" <> textShow (_uri (docId :: VersionedTextDocumentIdentifier))\n-\n-    DidCloseTextDocument (DidCloseTextDocumentParams (TextDocumentIdentifier uri)) ->\n-        case URI.parseURI $ T.unpack $ getUri uri of\n-          Just uri'\n-              | URI.uriScheme uri' == \"file:\" -> do\n-                    Just fp <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-                    handleDidCloseFile fp\n-              | otherwise -> logWarning logger $ \"Unknown scheme in URI: \" <> textShow uri\n-\n-          _ -> logSeriousError logger\n-                 $    \"Invalid URI in DidCloseTextDocument: \"\n-                   <> textShow uri\n-\n-    DidSaveTextDocument _params ->\n-      pure ()\n-\n-    UnknownNotification _method _params -> return ()\n-  where\n-    -- Note that the state changes here are not atomic.\n-    -- When we have parallel compilation we could manage the state\n-    -- changes in STM so that we can atomically change the state.\n-    -- Internally it should be done via the IO oracle. See PROD-2808.\n-    handleDidOpenFile (TextDocumentItem uri _ _ contents) = do\n-        Just filePath <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-        onFileModified compilerH filePath (Just contents)\n-        modifyFilesOfInterest compilerH (S.insert filePath)\n-        logInfo logger $ \"Opened text document: \" <> textShow filePath\n-\n-    handleDidCloseFile filePath = do\n-         logInfo logger $ \"Closed text document: \" <> textShow (fromNormalizedFilePath filePath)\n-         onFileModified compilerH filePath Nothing\n-         modifyFilesOfInterest compilerH (S.delete filePath)\n-\n--- | Manages the file store (caching compilation results and unsaved content).\n-onFileModified\n-    :: IdeState\n-    -> NormalizedFilePath\n-    -> Maybe T.Text\n-    -> IO ()\n-onFileModified service fp mbContents = do\n-    logDebug (ideLogger service) $ \"File modified \" <> T.pack (show fp)\n-    setBufferModified service fp mbContents\n \n-------------------------------------------------------------------------\n--- Server execution\n-------------------------------------------------------------------------\n \n runLanguageServer\n-    :: Logger\n-    -> ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n+    :: ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n     -> IO ()\n-runLanguageServer loggerH getIdeState = do\n-    let getHandlers lspFuncs = do\n-            compilerH <- getIdeState (sendFunc lspFuncs) (makeLSPVFSHandle lspFuncs)\n-            pure $ Handlers (handleRequest loggerH compilerH) (handleNotification lspFuncs loggerH compilerH)\n-    liftIO $ runServer loggerH getHandlers\n+runLanguageServer getIdeState = do\n+    -- Move stdout to another file descriptor and duplicate stderr\n+    -- to stdout. This guards against stray prints from corrupting the JSON-RPC\n+    -- message stream.\n+    newStdout <- hDuplicate stdout\n+    stderr `hDuplicateTo` stdout\n+\n+    -- Print out a single space to assert that the above redirection works.\n+    -- This is interleaved with the logger, hence we just print a space here in\n+    -- order not to mess up the output too much. Verified that this breaks\n+    -- the language server tests without the redirection.\n+    putStr \" \" >> hFlush stdout\n+\n+    clientMsgChan :: TChan AddItem <- newTChanIO\n+    -- These barriers are signaled when the threads reading from these chans exit.\n+    -- This should not happen but if it does, we will make sure that the whole server\n+    -- dies and can be restarted instead of losing threads silently.\n+    clientMsgBarrier <- newBarrier\n+\n+    let runHandler = RunHandler\n+            (\\wrap f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddResponse r wrap f)\n+            (\\f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddNotification r f)\n+    handlers <- mergeHandlers [LS.Definition.addGotoDefinition, LS.Hover.addOnHover, addNotifications, addIgnored] runHandler def\n+\n+    void $ waitAnyCancel =<< traverse async\n+        [ void $ LSP.runWithHandles\n+            stdin\n+            newStdout\n+            ( const $ Right ()\n+            , handleInit (signalBarrier clientMsgBarrier ()) clientMsgChan\n+            )\n+            handlers\n+            options\n+            Nothing\n+        , void $ waitBarrier clientMsgBarrier\n+        ]\n+    where\n+        handleInit :: IO () -> TChan AddItem -> LSP.LspFuncs () -> IO (Maybe err)\n+        handleInit exitClientMsg clientMsgChan lspFuncs@LSP.LspFuncs{..} = do\n+            ide <- getIdeState sendFunc (makeLSPVFSHandle lspFuncs)\n+            _ <- flip forkFinally (const exitClientMsg) $ forever $ do\n+                msg <- atomically $ readTChan clientMsgChan\n+                case msg of\n+                    AddNotification NotificationMessage{_params} act -> act ide _params\n+                    AddResponse RequestMessage{_id, _params} wrap act -> do\n+                        res <- act ide _params\n+                        sendFunc $ wrap $ ResponseMessage \"2.0\" (responseId _id) (Just res) Nothing\n+            pure Nothing\n+\n+\n+-- | Things that come up regularly, but we don't deal with\n+addIgnored :: RunHandler -> LSP.Handlers -> IO LSP.Handlers\n+addIgnored _ x = return x\n+    {LSP.cancelNotificationHandler = none\n+    ,LSP.initializedHandler = none\n+    ,LSP.codeLensHandler = none\n+    }\n+    where none = Just $ const $ return ()\n+\n+\n+data AddItem\n+    = forall m req resp . AddResponse (RequestMessage m req resp) (ResponseMessage resp -> FromServerMessage) (IdeState -> req -> IO resp)"
  },
  {
    "id" : "5adcdb8e-9d49-4372-becb-5cb7640bcc17",
    "prId" : 1862,
    "comments" : [
      {
        "id" : "1259f568-d9f5-45d1-9496-ebea0e512c3f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This also looks like it could just be `IO ()`. Not necessarily opposed to making it an existential but Iâ€™d like a comment explaining the design decision.",
        "createdAt" : "2019-06-25T12:53:47Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6584b142-6bb8-4e24-9fdc-1e5d4379e0ab",
        "parentId" : "1259f568-d9f5-45d1-9496-ebea0e512c3f",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Not sure in what sense it could be IO. You could lift the NotificationMessage outside this function, but then my concern is people might pattern match and fail outside a tracked context. My plan is to add exception handlers at some point.",
        "createdAt" : "2019-06-25T13:32:52Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4da7658d-f177-4632-b551-fd8cac415a32",
        "parentId" : "1259f568-d9f5-45d1-9496-ebea0e512c3f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Sounds reasonable, :+1: on using existentials for this then.",
        "createdAt" : "2019-06-25T13:40:21Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7bc9e951e1b9870a20cebab7f75884497a5ac28e",
    "line" : null,
    "diffHunk" : "@@ -12,144 +11,102 @@ module Development.IDE.LSP.LanguageServer\n     ) where\n \n import           Development.IDE.LSP.Protocol\n-import           Development.IDE.LSP.Server\n+import           Development.IDE.LSP.Server hiding (runServer)\n+import qualified Language.Haskell.LSP.Control as LSP\n+import qualified Language.Haskell.LSP.Core as LSP\n+import Control.Concurrent.STM\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Data.Default\n+import           GHC.IO.Handle                    (hDuplicate, hDuplicateTo)\n+import System.IO\n+import Control.Monad\n \n-import Control.Monad.IO.Class\n import qualified Development.IDE.LSP.Definition as LS.Definition\n import qualified Development.IDE.LSP.Hover      as LS.Hover\n-import Development.IDE.Types.Logger\n+import Development.IDE.LSP.Notifications\n import Development.IDE.Core.Service\n-import Development.IDE.Types.Location\n-\n-import qualified Data.Aeson                                as Aeson\n-import qualified Data.Rope.UTF16 as Rope\n-import qualified Data.Set                                  as S\n-import qualified Data.Text as T\n-\n import Development.IDE.Core.FileStore\n-import Development.IDE.Core.OfInterest\n-\n-import qualified Network.URI                               as URI\n-\n-import qualified System.Exit\n-\n import Language.Haskell.LSP.Core (LspFuncs(..))\n import Language.Haskell.LSP.Messages\n-import Language.Haskell.LSP.VFS\n-\n-textShow :: Show a => a -> T.Text\n-textShow = T.pack . show\n-\n-------------------------------------------------------------------------\n--- Request handlers\n-------------------------------------------------------------------------\n-\n-handleRequest\n-    :: Logger\n-    -> IdeState\n-    -> (forall resp. resp -> ResponseMessage resp)\n-    -> (ErrorCode -> ResponseMessage ())\n-    -> ServerRequest\n-    -> IO FromServerMessage\n-handleRequest logger compilerH makeResponse makeErrorResponse = \\case\n-    Shutdown -> do\n-      logInfo logger \"Shutdown request received, terminating.\"\n-      System.Exit.exitSuccess\n-\n-    KeepAlive -> pure $ RspCustomServer $ makeResponse Aeson.Null\n-\n-    Definition params -> RspDefinition . makeResponse <$> LS.Definition.handle logger compilerH params\n-    Hover params -> RspHover . makeResponse <$> LS.Hover.handle logger compilerH params\n-    CodeLens _params -> pure $ RspCodeLens $ makeResponse mempty\n-\n-    req -> do\n-        logWarning logger (\"Method not found\" <> T.pack (show req))\n-        pure $ RspError $ makeErrorResponse MethodNotFound\n-\n-\n-handleNotification :: LspFuncs () -> Logger -> IdeState -> ServerNotification -> IO ()\n-handleNotification lspFuncs logger compilerH = \\case\n-\n-    DidOpenTextDocument (DidOpenTextDocumentParams item) -> do\n-        case URI.parseURI $ T.unpack $ getUri $ _uri (item :: TextDocumentItem) of\n-          Just uri\n-              | URI.uriScheme uri == \"file:\"\n-              -> handleDidOpenFile item\n-\n-              | otherwise\n-              -> logWarning logger $ \"Unknown scheme in URI: \"\n-                    <> textShow uri\n-\n-          _ -> logSeriousError logger $ \"Invalid URI in DidOpenTextDocument: \"\n-                    <> textShow (_uri (item :: TextDocumentItem))\n-\n-    DidChangeTextDocument (DidChangeTextDocumentParams docId _) -> do\n-        let uri = _uri (docId :: VersionedTextDocumentIdentifier)\n-\n-        case uriToFilePath' uri of\n-          Just (toNormalizedFilePath -> filePath) -> do\n-            mbVirtual <- getVirtualFileFunc lspFuncs $ toNormalizedUri uri\n-            let contents = maybe \"\" (Rope.toText . (_text :: VirtualFile -> Rope.Rope)) mbVirtual\n-            onFileModified compilerH filePath (Just contents)\n-            logInfo logger\n-              $ \"Updated text document: \" <> textShow (fromNormalizedFilePath filePath)\n-\n-          Nothing ->\n-            logSeriousError logger\n-              $ \"Invalid file path: \" <> textShow (_uri (docId :: VersionedTextDocumentIdentifier))\n-\n-    DidCloseTextDocument (DidCloseTextDocumentParams (TextDocumentIdentifier uri)) ->\n-        case URI.parseURI $ T.unpack $ getUri uri of\n-          Just uri'\n-              | URI.uriScheme uri' == \"file:\" -> do\n-                    Just fp <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-                    handleDidCloseFile fp\n-              | otherwise -> logWarning logger $ \"Unknown scheme in URI: \" <> textShow uri\n-\n-          _ -> logSeriousError logger\n-                 $    \"Invalid URI in DidCloseTextDocument: \"\n-                   <> textShow uri\n-\n-    DidSaveTextDocument _params ->\n-      pure ()\n-\n-    UnknownNotification _method _params -> return ()\n-  where\n-    -- Note that the state changes here are not atomic.\n-    -- When we have parallel compilation we could manage the state\n-    -- changes in STM so that we can atomically change the state.\n-    -- Internally it should be done via the IO oracle. See PROD-2808.\n-    handleDidOpenFile (TextDocumentItem uri _ _ contents) = do\n-        Just filePath <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-        onFileModified compilerH filePath (Just contents)\n-        modifyFilesOfInterest compilerH (S.insert filePath)\n-        logInfo logger $ \"Opened text document: \" <> textShow filePath\n-\n-    handleDidCloseFile filePath = do\n-         logInfo logger $ \"Closed text document: \" <> textShow (fromNormalizedFilePath filePath)\n-         onFileModified compilerH filePath Nothing\n-         modifyFilesOfInterest compilerH (S.delete filePath)\n-\n--- | Manages the file store (caching compilation results and unsaved content).\n-onFileModified\n-    :: IdeState\n-    -> NormalizedFilePath\n-    -> Maybe T.Text\n-    -> IO ()\n-onFileModified service fp mbContents = do\n-    logDebug (ideLogger service) $ \"File modified \" <> T.pack (show fp)\n-    setBufferModified service fp mbContents\n \n-------------------------------------------------------------------------\n--- Server execution\n-------------------------------------------------------------------------\n \n runLanguageServer\n-    :: Logger\n-    -> ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n+    :: ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n     -> IO ()\n-runLanguageServer loggerH getIdeState = do\n-    let getHandlers lspFuncs = do\n-            compilerH <- getIdeState (sendFunc lspFuncs) (makeLSPVFSHandle lspFuncs)\n-            pure $ Handlers (handleRequest loggerH compilerH) (handleNotification lspFuncs loggerH compilerH)\n-    liftIO $ runServer loggerH getHandlers\n+runLanguageServer getIdeState = do\n+    -- Move stdout to another file descriptor and duplicate stderr\n+    -- to stdout. This guards against stray prints from corrupting the JSON-RPC\n+    -- message stream.\n+    newStdout <- hDuplicate stdout\n+    stderr `hDuplicateTo` stdout\n+\n+    -- Print out a single space to assert that the above redirection works.\n+    -- This is interleaved with the logger, hence we just print a space here in\n+    -- order not to mess up the output too much. Verified that this breaks\n+    -- the language server tests without the redirection.\n+    putStr \" \" >> hFlush stdout\n+\n+    clientMsgChan :: TChan AddItem <- newTChanIO\n+    -- These barriers are signaled when the threads reading from these chans exit.\n+    -- This should not happen but if it does, we will make sure that the whole server\n+    -- dies and can be restarted instead of losing threads silently.\n+    clientMsgBarrier <- newBarrier\n+\n+    let runHandler = RunHandler\n+            (\\wrap f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddResponse r wrap f)\n+            (\\f -> Just $ \\r -> atomically $ writeTChan clientMsgChan $ AddNotification r f)\n+    handlers <- mergeHandlers [LS.Definition.addGotoDefinition, LS.Hover.addOnHover, addNotifications, addIgnored] runHandler def\n+\n+    void $ waitAnyCancel =<< traverse async\n+        [ void $ LSP.runWithHandles\n+            stdin\n+            newStdout\n+            ( const $ Right ()\n+            , handleInit (signalBarrier clientMsgBarrier ()) clientMsgChan\n+            )\n+            handlers\n+            options\n+            Nothing\n+        , void $ waitBarrier clientMsgBarrier\n+        ]\n+    where\n+        handleInit :: IO () -> TChan AddItem -> LSP.LspFuncs () -> IO (Maybe err)\n+        handleInit exitClientMsg clientMsgChan lspFuncs@LSP.LspFuncs{..} = do\n+            ide <- getIdeState sendFunc (makeLSPVFSHandle lspFuncs)\n+            _ <- flip forkFinally (const exitClientMsg) $ forever $ do\n+                msg <- atomically $ readTChan clientMsgChan\n+                case msg of\n+                    AddNotification NotificationMessage{_params} act -> act ide _params\n+                    AddResponse RequestMessage{_id, _params} wrap act -> do\n+                        res <- act ide _params\n+                        sendFunc $ wrap $ ResponseMessage \"2.0\" (responseId _id) (Just res) Nothing\n+            pure Nothing\n+\n+\n+-- | Things that come up regularly, but we don't deal with\n+addIgnored :: RunHandler -> LSP.Handlers -> IO LSP.Handlers\n+addIgnored _ x = return x\n+    {LSP.cancelNotificationHandler = none\n+    ,LSP.initializedHandler = none\n+    ,LSP.codeLensHandler = none\n+    }\n+    where none = Just $ const $ return ()\n+\n+\n+data AddItem\n+    = forall m req resp . AddResponse (RequestMessage m req resp) (ResponseMessage resp -> FromServerMessage) (IdeState -> req -> IO resp)\n+    | forall m req . AddNotification (NotificationMessage m req) (IdeState -> req -> IO ())"
  },
  {
    "id" : "fbd8a2a2-0838-4dcd-bf41-c69325b572a9",
    "prId" : 1862,
    "comments" : [
      {
        "id" : "4c7230eb-ec42-493a-a861-3149260187fe",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not really a new thing in your PR but it would be nice to have a comment on why we have this channel indirection. In the current state the answer is that we can only start handling messages once we have the `LspFuncs` but we need to specify the `Handlers` before that. It will probably also come in handy for implementing request cancellation.",
        "createdAt" : "2019-06-25T13:07:51Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1edbc93a-6cbc-4960-9065-e5bcf0200e1b",
        "parentId" : "4c7230eb-ec42-493a-a861-3149260187fe",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'm not sure why we have this channel. I think it might be redundant. Either way, its just a copy of what we had before.",
        "createdAt" : "2019-06-25T13:33:53Z",
        "updatedAt" : "2019-06-25T13:55:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7bc9e951e1b9870a20cebab7f75884497a5ac28e",
    "line" : null,
    "diffHunk" : "@@ -12,144 +11,102 @@ module Development.IDE.LSP.LanguageServer\n     ) where\n \n import           Development.IDE.LSP.Protocol\n-import           Development.IDE.LSP.Server\n+import           Development.IDE.LSP.Server hiding (runServer)\n+import qualified Language.Haskell.LSP.Control as LSP\n+import qualified Language.Haskell.LSP.Core as LSP\n+import Control.Concurrent.STM\n+import Control.Concurrent.Extra\n+import Control.Concurrent.Async\n+import Data.Default\n+import           GHC.IO.Handle                    (hDuplicate, hDuplicateTo)\n+import System.IO\n+import Control.Monad\n \n-import Control.Monad.IO.Class\n import qualified Development.IDE.LSP.Definition as LS.Definition\n import qualified Development.IDE.LSP.Hover      as LS.Hover\n-import Development.IDE.Types.Logger\n+import Development.IDE.LSP.Notifications\n import Development.IDE.Core.Service\n-import Development.IDE.Types.Location\n-\n-import qualified Data.Aeson                                as Aeson\n-import qualified Data.Rope.UTF16 as Rope\n-import qualified Data.Set                                  as S\n-import qualified Data.Text as T\n-\n import Development.IDE.Core.FileStore\n-import Development.IDE.Core.OfInterest\n-\n-import qualified Network.URI                               as URI\n-\n-import qualified System.Exit\n-\n import Language.Haskell.LSP.Core (LspFuncs(..))\n import Language.Haskell.LSP.Messages\n-import Language.Haskell.LSP.VFS\n-\n-textShow :: Show a => a -> T.Text\n-textShow = T.pack . show\n-\n-------------------------------------------------------------------------\n--- Request handlers\n-------------------------------------------------------------------------\n-\n-handleRequest\n-    :: Logger\n-    -> IdeState\n-    -> (forall resp. resp -> ResponseMessage resp)\n-    -> (ErrorCode -> ResponseMessage ())\n-    -> ServerRequest\n-    -> IO FromServerMessage\n-handleRequest logger compilerH makeResponse makeErrorResponse = \\case\n-    Shutdown -> do\n-      logInfo logger \"Shutdown request received, terminating.\"\n-      System.Exit.exitSuccess\n-\n-    KeepAlive -> pure $ RspCustomServer $ makeResponse Aeson.Null\n-\n-    Definition params -> RspDefinition . makeResponse <$> LS.Definition.handle logger compilerH params\n-    Hover params -> RspHover . makeResponse <$> LS.Hover.handle logger compilerH params\n-    CodeLens _params -> pure $ RspCodeLens $ makeResponse mempty\n-\n-    req -> do\n-        logWarning logger (\"Method not found\" <> T.pack (show req))\n-        pure $ RspError $ makeErrorResponse MethodNotFound\n-\n-\n-handleNotification :: LspFuncs () -> Logger -> IdeState -> ServerNotification -> IO ()\n-handleNotification lspFuncs logger compilerH = \\case\n-\n-    DidOpenTextDocument (DidOpenTextDocumentParams item) -> do\n-        case URI.parseURI $ T.unpack $ getUri $ _uri (item :: TextDocumentItem) of\n-          Just uri\n-              | URI.uriScheme uri == \"file:\"\n-              -> handleDidOpenFile item\n-\n-              | otherwise\n-              -> logWarning logger $ \"Unknown scheme in URI: \"\n-                    <> textShow uri\n-\n-          _ -> logSeriousError logger $ \"Invalid URI in DidOpenTextDocument: \"\n-                    <> textShow (_uri (item :: TextDocumentItem))\n-\n-    DidChangeTextDocument (DidChangeTextDocumentParams docId _) -> do\n-        let uri = _uri (docId :: VersionedTextDocumentIdentifier)\n-\n-        case uriToFilePath' uri of\n-          Just (toNormalizedFilePath -> filePath) -> do\n-            mbVirtual <- getVirtualFileFunc lspFuncs $ toNormalizedUri uri\n-            let contents = maybe \"\" (Rope.toText . (_text :: VirtualFile -> Rope.Rope)) mbVirtual\n-            onFileModified compilerH filePath (Just contents)\n-            logInfo logger\n-              $ \"Updated text document: \" <> textShow (fromNormalizedFilePath filePath)\n-\n-          Nothing ->\n-            logSeriousError logger\n-              $ \"Invalid file path: \" <> textShow (_uri (docId :: VersionedTextDocumentIdentifier))\n-\n-    DidCloseTextDocument (DidCloseTextDocumentParams (TextDocumentIdentifier uri)) ->\n-        case URI.parseURI $ T.unpack $ getUri uri of\n-          Just uri'\n-              | URI.uriScheme uri' == \"file:\" -> do\n-                    Just fp <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-                    handleDidCloseFile fp\n-              | otherwise -> logWarning logger $ \"Unknown scheme in URI: \" <> textShow uri\n-\n-          _ -> logSeriousError logger\n-                 $    \"Invalid URI in DidCloseTextDocument: \"\n-                   <> textShow uri\n-\n-    DidSaveTextDocument _params ->\n-      pure ()\n-\n-    UnknownNotification _method _params -> return ()\n-  where\n-    -- Note that the state changes here are not atomic.\n-    -- When we have parallel compilation we could manage the state\n-    -- changes in STM so that we can atomically change the state.\n-    -- Internally it should be done via the IO oracle. See PROD-2808.\n-    handleDidOpenFile (TextDocumentItem uri _ _ contents) = do\n-        Just filePath <- pure $ toNormalizedFilePath <$> uriToFilePath' uri\n-        onFileModified compilerH filePath (Just contents)\n-        modifyFilesOfInterest compilerH (S.insert filePath)\n-        logInfo logger $ \"Opened text document: \" <> textShow filePath\n-\n-    handleDidCloseFile filePath = do\n-         logInfo logger $ \"Closed text document: \" <> textShow (fromNormalizedFilePath filePath)\n-         onFileModified compilerH filePath Nothing\n-         modifyFilesOfInterest compilerH (S.delete filePath)\n-\n--- | Manages the file store (caching compilation results and unsaved content).\n-onFileModified\n-    :: IdeState\n-    -> NormalizedFilePath\n-    -> Maybe T.Text\n-    -> IO ()\n-onFileModified service fp mbContents = do\n-    logDebug (ideLogger service) $ \"File modified \" <> T.pack (show fp)\n-    setBufferModified service fp mbContents\n \n-------------------------------------------------------------------------\n--- Server execution\n-------------------------------------------------------------------------\n \n runLanguageServer\n-    :: Logger\n-    -> ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n+    :: ((FromServerMessage -> IO ()) -> VFSHandle -> IO IdeState)\n     -> IO ()\n-runLanguageServer loggerH getIdeState = do\n-    let getHandlers lspFuncs = do\n-            compilerH <- getIdeState (sendFunc lspFuncs) (makeLSPVFSHandle lspFuncs)\n-            pure $ Handlers (handleRequest loggerH compilerH) (handleNotification lspFuncs loggerH compilerH)\n-    liftIO $ runServer loggerH getHandlers\n+runLanguageServer getIdeState = do\n+    -- Move stdout to another file descriptor and duplicate stderr\n+    -- to stdout. This guards against stray prints from corrupting the JSON-RPC\n+    -- message stream.\n+    newStdout <- hDuplicate stdout\n+    stderr `hDuplicateTo` stdout\n+\n+    -- Print out a single space to assert that the above redirection works.\n+    -- This is interleaved with the logger, hence we just print a space here in\n+    -- order not to mess up the output too much. Verified that this breaks\n+    -- the language server tests without the redirection.\n+    putStr \" \" >> hFlush stdout\n+\n+    clientMsgChan :: TChan AddItem <- newTChanIO"
  }
]