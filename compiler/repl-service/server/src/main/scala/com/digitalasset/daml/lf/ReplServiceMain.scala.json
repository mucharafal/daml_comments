[
  {
    "id" : "c595d911-8e28-4475-89c8-b793fbe4c137",
    "prId" : 7161,
    "comments" : [
      {
        "id" : "2fd60b2e-d5fd-4ff0-8ae4-5536cedd69c3",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I believe there isn’t actually a difference between the server returned by `start` and the one returned by `build` but this matches the grpc-java tutorial and avoids the warning.",
        "createdAt" : "2020-08-18T08:12:09Z",
        "updatedAt" : "2020-08-18T08:20:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ce0b429e18c1eba4becffccae782fb927ed4f05c",
    "line" : 22,
    "diffHunk" : "@@ -155,8 +157,8 @@ object ReplServiceMain extends App {\n       .addService(new ReplService(clients, timeMode, ec, sequencer, materializer))\n       .maxInboundMessageSize(maxMessageSize)\n       .build\n-  server.start()\n-  Files.write(config.portFile, Seq(server.getPort.toString).asJava)\n+      .start"
  },
  {
    "id" : "b5e4d6a7-e92c-4a41-8022-30af59f7bc31",
    "prId" : 6485,
    "comments" : [
      {
        "id" : "b9722fa3-5337-4887-98f0-da3ca40d8673",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not really important here given that this is not a user-facing tool and I’m fairly confident we can write Haskell code that will not pass both but given that you already wrote it we might as well keep it I guess",
        "createdAt" : "2020-06-25T10:38:01Z",
        "updatedAt" : "2020-06-25T12:43:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "787fa9e2d1e70e3404d4996d48837692a91ae6f2",
    "line" : 4,
    "diffHunk" : "@@ -36,12 +36,24 @@ object ReplServiceMain extends App {\n       accessTokenFile: Option[Path],\n       maxInboundMessageSize: Int,\n       tlsConfig: Option[TlsConfiguration],\n+      // optional so we can detect if both --static-time and --wall-clock-time are passed."
  },
  {
    "id" : "0f021533-05d3-4ca4-b832-1d574c90a6f8",
    "prId" : 5347,
    "comments" : [
      {
        "id" : "dd4c891e-c857-441d-957d-8f51ec797543",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "The REPL tests only read stdout. But, also to be consistent with other error printing in this module.",
        "createdAt" : "2020-04-01T15:39:38Z",
        "updatedAt" : "2020-04-03T09:13:27Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89906409657f8b0cdf3c824a05446f7bd08109de",
    "line" : 5,
    "diffHunk" : "@@ -217,7 +217,7 @@ class ReplService(\n       TimeProvider.UTC)\n     runner.runWithClients(clients).onComplete {\n       case Failure(e) =>\n-        System.err.println(s\"$e\")\n+        println(s\"$e\")"
  },
  {
    "id" : "caade1d7-2ccc-436e-822c-06a758ed3423",
    "prId" : 5337,
    "comments" : [
      {
        "id" : "14aa5e96-26b5-4cf7-8baf-3e6c9f8d2b29",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "The REPL server was not printing errors such as when trying to re-allocate the same party. I'm working on a test-case for a separate PR.",
        "createdAt" : "2020-04-01T11:43:16Z",
        "updatedAt" : "2020-04-01T11:43:17Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7edafcdc6d482d8d3947074845131f21846fa79f",
    "line" : 7,
    "diffHunk" : "@@ -216,7 +216,9 @@ class ReplService(\n       ApplicationId(\"daml repl\"),\n       TimeProvider.UTC)\n     runner.runWithClients(clients).onComplete {\n-      case Failure(e) => respObs.onError(e)\n+      case Failure(e) =>\n+        System.err.println(s\"$e\")\n+        respObs.onError(e)"
  },
  {
    "id" : "a88739b6-79b1-47d4-b530-23cfac051cea",
    "prId" : 5157,
    "comments" : [
      {
        "id" : "72b4c1e9-b708-467e-976f-48efc0b82573",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can this ever actually happen? I thought we rely on topological order. If it shuldn’t happen maybe just throw an error?",
        "createdAt" : "2020-03-24T11:58:38Z",
        "updatedAt" : "2020-03-24T15:54:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b6b9f360-4a7a-4cce-b323-d9803c73c19b",
        "parentId" : "72b4c1e9-b708-467e-976f-48efc0b82573",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Yes, I've observed this happening. As the comment below explains, IIUC that's due to compilation happening in parallel. ",
        "createdAt" : "2020-03-24T14:05:23Z",
        "updatedAt" : "2020-03-24T15:54:30Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "07e250980788bf253ea11b5cabed0122318d5135",
    "line" : null,
    "diffHunk" : "@@ -160,19 +165,32 @@ object ReplServiceMain extends App {\n class ReplService(val clients: Participants[LedgerClient], ec: ExecutionContext, mat: Materializer)\n     extends ReplServiceGrpc.ReplServiceImplBase {\n   var packages: Map[PackageId, Package] = Map.empty\n+  var compiledPackages: MutableCompiledPackages = ConcurrentCompiledPackages()\n+  var currentLine: Int = 0\n   var results: Seq[SValue] = Seq()\n   implicit val ec_ = ec\n   implicit val mat_ = mat\n \n-  private val homePackageId: PackageId = PackageId.assertFromString(\"-homePackageId-\")\n+  private def homePackageId(line: Int): PackageId = PackageId.assertFromString(s\"-homePackageId-$line-\")\n \n   override def loadPackage(\n       req: LoadPackageRequest,\n       respObs: StreamObserver[LoadPackageResponse]): Unit = {\n     val (pkgId, pkg) = Decode.decodeArchiveFromInputStream(req.getPackage.newInput)\n-    packages = packages + (pkgId -> pkg)\n-    respObs.onNext(LoadPackageResponse.newBuilder.build)\n-    respObs.onCompleted()\n+    def go: Result[Unit] => Unit = {\n+      case ResultDone(()) =>\n+        packages = packages + (pkgId -> pkg)\n+        respObs.onNext(LoadPackageResponse.newBuilder.build)\n+        respObs.onCompleted()\n+      case ResultNeedPackage(pkgId, resume) =>"
  },
  {
    "id" : "9c244fb2-806b-483d-a222-51b6ec3f0be8",
    "prId" : 5157,
    "comments" : [
      {
        "id" : "4294e16c-fd50-4e62-8e93-6f8b3d58d40b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Are exceptions in grpc handlers automagically caught and turned into error responses or do we need to call `respObs.onError`?",
        "createdAt" : "2020-03-24T12:02:20Z",
        "updatedAt" : "2020-03-24T15:54:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "97ea80c2-9bd8-41df-a163-3cf2e09b7d4e",
        "parentId" : "4294e16c-fd50-4e62-8e93-6f8b3d58d40b",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "They seem to be, the error is displayed in the REPL console and the `Left` branch on `scriptRes` is taken in `handleLine`.",
        "createdAt" : "2020-03-24T14:53:41Z",
        "updatedAt" : "2020-03-24T15:54:30Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "07e250980788bf253ea11b5cabed0122318d5135",
    "line" : null,
    "diffHunk" : "@@ -202,18 +224,22 @@ class ReplService(val clients: Participants[LedgerClient], ec: ExecutionContext,\n       case (pkgId, pkg) => pkg.modules.contains(DottedName.assertFromString(\"Daml.Script\"))\n     }.get\n \n+    // Load the new package. All dependencies should already be loaded.\n+    compiledPackages.addPackage(linePkgId, pkg) match {\n+      case ResultDone(()) => ()\n+      case ResultNeedPackage(pkgId, resume) =>\n+        throw new RuntimeException(s\"Missing package $pkgId\")"
  },
  {
    "id" : "30f90593-f77f-4bf8-bf6e-3bd9930d7e45",
    "prId" : 5157,
    "comments" : [
      {
        "id" : "471174d5-0938-46b9-8679-51d8c6ea4b47",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This seems a bit problematic. You are creating a memory leak here where each line will create a new LF package and they never get garbage collected. While we already have a memory leak since we never collect results even if they are unused (e.g. they are not bound to a name or are shadowed), this one seems a bit more severe (an LF package is likely to be bigger than most results) and is harder to solve.\r\n\r\nLooking at the code, do we actually benefit from `ConcurrentCompiledPackages` over `PureCompiledPackages`? The latter has a constructor that allows you to pass in the compiled expressions (the `apply` method takes care of the compilation otherwise). If we use that we should be able to drop old packages. There is one issue here, namely if the result of some line is a closure as opposed to a simple value, it can keep references to a package. Without this PR that simply fails since we always drop packages. I think with this PR it might actually work?\r\n\r\nI’m fine with using `ConcurrentCompiledPackages` for now and then see if we can switch in anther PR. Maybe just update the comment.",
        "createdAt" : "2020-03-24T12:18:20Z",
        "updatedAt" : "2020-03-24T15:54:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bbe0d1d5-6ed7-4e96-8ab4-8fbc1a50ab55",
        "parentId" : "471174d5-0938-46b9-8679-51d8c6ea4b47",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Hmm, yes, I think we could skip `ConcurrentCompiledPackages` altogether and call the compiler directly within \"load package\" and use `PureCompiledPackages` for the script runner. That would still avoid recompilation.",
        "createdAt" : "2020-03-24T15:02:20Z",
        "updatedAt" : "2020-03-24T15:54:30Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c4c632dd-9c6d-4f04-bc4a-bf2b1d73a1cc",
        "parentId" : "471174d5-0938-46b9-8679-51d8c6ea4b47",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "I've updated the PR to do this. That also makes for a simpler change.",
        "createdAt" : "2020-03-24T15:55:27Z",
        "updatedAt" : "2020-03-24T15:55:27Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a9e743ee-2684-4ed7-b544-ec464f798069",
        "parentId" : "471174d5-0938-46b9-8679-51d8c6ea4b47",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Very nice! That looks so simple that I’m almost slightly embarrassed that I didn’t implement this in the beginning :slightly_smiling_face: ",
        "createdAt" : "2020-03-24T16:16:29Z",
        "updatedAt" : "2020-03-24T16:16:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "07e250980788bf253ea11b5cabed0122318d5135",
    "line" : null,
    "diffHunk" : "@@ -187,12 +206,15 @@ class ReplService(val clients: Participants[LedgerClient], ec: ExecutionContext,\n       .decoder\n     val lfScenarioModule =\n       dop.protoScenarioModule(Decode.damlLfCodedInputStream(req.getDamlLf1.newInput))\n-    val mod: Ast.Module = dop.decodeScenarioModule(homePackageId, lfScenarioModule)\n+    // ConcurrentCompiledPackages doesn't allow overwriting a previously loaded"
  }
]