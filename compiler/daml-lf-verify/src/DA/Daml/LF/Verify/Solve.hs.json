[
  {
    "id" : "1a620911-99a7-4c9b-b613-92072acbace2",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "4b62d772-869f-45b5-8199-8972a0c57c3b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This seems a bit weird. Maybe add a comment explaining why we need it and what the meaning of this is when the condition does not hold.",
        "createdAt" : "2020-05-11T07:35:00Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr"
  },
  {
    "id" : "98e66a51-3a7d-4491-b8c2-8db6a37a904a",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "6ee0732a-7cfd-4545-b173-1ef9b0ecd217",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Happy to keep it for this PR but I generally prefer to derive `Show` instances and define `Pretty` instances (from `prettyprinter` ideally).",
        "createdAt" : "2020-05-11T07:37:19Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where"
  },
  {
    "id" : "10a3d615-cf81-4f53-8de9-22787780f680",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "537af0b2-aab7-4a77-b0d9-52b4a2e6d7f5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n-- | Class covering the types convertible to constraint expressions.\r\n```",
        "createdAt" : "2020-05-11T07:38:10Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions."
  },
  {
    "id" : "68a1dea6-db9c-4a60-84fd-ae430812d431",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "8cd6b9a4-f6ac-48fa-90ae-2fbdfbcee3d2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You could `uniplate` this if you want. Makes it a bit easier to see what’s going on and it’s more robust to changes to the ADT.",
        "createdAt" : "2020-05-11T07:40:35Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 124,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []"
  },
  {
    "id" : "401fe5aa-1b98-462b-b71a-3106fa6711e8",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "85c134ee-4e97-4f18-9173-ef33c3e918ae",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    -- ^ The field values of all newly created contracts.\r\n```",
        "createdAt" : "2020-05-11T07:42:11Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances."
  },
  {
    "id" : "189773f6-6954-4cbc-ae60-4a65ae0bf067",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "67ed93de-8b51-41e7-90ed-d6dad5bfb081",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    -- ^ The field values of all archived contracts.\r\n```",
        "createdAt" : "2020-05-11T07:42:22Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances."
  },
  {
    "id" : "f75cc247-468c-4105-983f-37d49a3d15af",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "97fd74fe-47f1-4cdd-8e7a-6e53351e6c3f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This seems sketchy. Why are you only checking the template names but not the module or package id?",
        "createdAt" : "2020-05-11T07:43:49Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp"
  },
  {
    "id" : "1afee0c3-4b3a-4a16-879e-76d270d7f8ca",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "169d38d1-5d51-493a-a6a9-bf71f59df14b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given my comment above, I believe you can get this to fail if you have two templates of the same name in different modules or packages but different fields.",
        "createdAt" : "2020-05-11T07:44:25Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)"
  },
  {
    "id" : "90e0f46a-ae09-4561-8768-366446b56959",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "43d28189-6a36-4bb2-b1e7-5be70cdf3286",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nfilterCondUpd tem f (Determined x) = both maybeToList $ filterUpd tem f x\r\n```",
        "createdAt" : "2020-05-11T07:45:49Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x"
  },
  {
    "id" : "79e94964-1c56-4b88-83a5-e11c49c25942",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "643904bc-c459-4cbd-879a-8457ca56c6e5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n      cx = both (map (CWhen cb) . maybeToList) $ filterUpd tem f x\r\n```",
        "createdAt" : "2020-05-11T07:46:19Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x"
  },
  {
    "id" : "16f4e2ec-420c-449e-813e-2e17850116b1",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "698e1c20-94c8-40ce-aafb-262982f3c13c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n      (cxcre,cxarc) = both maybeToList maybeToList $ filterUpd tem f x\r\n      (cycre,cyarc) = both maybeToList maybeToList $ filterUpd tem f y\r\n```",
        "createdAt" : "2020-05-11T07:46:40Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y"
  },
  {
    "id" : "a7eba0f7-bd7e-4848-9732-4028226f1026",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "23594a1e-81f6-4952-b100-10a429d12953",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n  in cx\r\n```",
        "createdAt" : "2020-05-11T07:48:37Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx"
  },
  {
    "id" : "0e856706-430d-40b9-8175-ca27123e79bb",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "4b377eac-e91e-404b-8c85-2385f9ba4f77",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n  let freevars = foldl' (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\r\n```",
        "createdAt" : "2020-05-11T07:49:55Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs"
  },
  {
    "id" : "83b775db-9698-45cf-93ff-ff91f3b1c637",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "e53c968b-e842-44fe-b04a-c0a5d9e9be91",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Any reason why we use lists instead of `Set`?",
        "createdAt" : "2020-05-11T07:50:34Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 211,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\n+  in freevars `intersect` vars"
  },
  {
    "id" : "abe57bb8-ff1c-43b6-9ea6-e590d046eceb",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "ba2d2b5d-e2de-4653-b25e-63991e0f7055",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe include the choice name in the error?",
        "createdAt" : "2020-05-11T07:52:28Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\n+  in freevars `intersect` vars\n+\n+-- | Constructs a constraint set from the generator environment, together with\n+-- the template name, the choice and field to be verified.\n+constructConstr :: Env 'Solving\n+  -- ^ The generator environment to convert.\n+  -> TypeConName\n+  -- ^ The template name of the choice to be verified.\n+  -> ChoiceName\n+  -- ^ The choice name to be verified.\n+  -> TypeConName\n+  -- ^ The template name of the field to be verified.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> ConstraintSet\n+constructConstr env chtem ch ftem f =\n+  case lookupChoInHMap (_envschs env) chtem ch of\n+    Just (self, this, arg, updSubst) ->\n+      let upds = _ussUpdate $ updSubst (EVar self) (EVar this) (EVar arg)\n+          vars = concatMap skol2var (_envsskol env)\n+          (cres, arcs) = foldl\n+            (\\(cs,as) upd -> let (cs',as') = filterCondUpd ftem f upd in (cs ++ cs',as ++ as'))\n+            ([],[]) upds\n+      in ConstraintSet vars cres arcs\n+    Nothing -> error \"Choice not found\""
  },
  {
    "id" : "e9d139f3-95e7-4ec5-844d-092ac2569512",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "dade3ed9-86ef-427d-b598-673bad70c476",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Might be worth returning a record instead of a 4-tuple?",
        "createdAt" : "2020-05-11T07:53:06Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\n+  in freevars `intersect` vars\n+\n+-- | Constructs a constraint set from the generator environment, together with\n+-- the template name, the choice and field to be verified.\n+constructConstr :: Env 'Solving\n+  -- ^ The generator environment to convert.\n+  -> TypeConName\n+  -- ^ The template name of the choice to be verified.\n+  -> ChoiceName\n+  -- ^ The choice name to be verified.\n+  -> TypeConName\n+  -- ^ The template name of the field to be verified.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> ConstraintSet\n+constructConstr env chtem ch ftem f =\n+  case lookupChoInHMap (_envschs env) chtem ch of\n+    Just (self, this, arg, updSubst) ->"
  },
  {
    "id" : "b65e6338-66e6-46e5-8fd1-7158e2135fbb",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "eda5151a-14fe-4f1d-be34-e0d2d5d8a07d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "How does this work at all? I would expect that in most cases you will just end up with a type error if you return a real?",
        "createdAt" : "2020-05-11T07:56:54Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\n+  in freevars `intersect` vars\n+\n+-- | Constructs a constraint set from the generator environment, together with\n+-- the template name, the choice and field to be verified.\n+constructConstr :: Env 'Solving\n+  -- ^ The generator environment to convert.\n+  -> TypeConName\n+  -- ^ The template name of the choice to be verified.\n+  -> ChoiceName\n+  -- ^ The choice name to be verified.\n+  -> TypeConName\n+  -- ^ The template name of the field to be verified.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> ConstraintSet\n+constructConstr env chtem ch ftem f =\n+  case lookupChoInHMap (_envschs env) chtem ch of\n+    Just (self, this, arg, updSubst) ->\n+      let upds = _ussUpdate $ updSubst (EVar self) (EVar this) (EVar arg)\n+          vars = concatMap skol2var (_envsskol env)\n+          (cres, arcs) = foldl\n+            (\\(cs,as) upd -> let (cs',as') = filterCondUpd ftem f upd in (cs ++ cs',as ++ as'))\n+            ([],[]) upds\n+      in ConstraintSet vars cres arcs\n+    Nothing -> error \"Choice not found\"\n+\n+-- | Convert a constraint expression into an SMT expression from the solving library.\n+cexp2sexp :: [(ExprVarName,S.SExpr)]\n+  -- ^ The set of variable names, mapped to their corresponding SMT counterparts.\n+  -> ConstraintExpr\n+  -- ^ The constraint expression to convert.\n+  -> IO S.SExpr\n+cexp2sexp _vars (CBool b) = return $ S.bool b\n+cexp2sexp _vars (CInt i) = return $ S.int i\n+cexp2sexp _vars (CReal i) = return $ S.real i\n+cexp2sexp vars (CVar x) = case lookup x vars of\n+  Just exp -> return exp\n+  Nothing -> error (\"Impossible: variable not found \" ++ show x)\n+cexp2sexp vars (CAdd ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.add se1 se2\n+cexp2sexp vars (CSub ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.sub se1 se2\n+cexp2sexp vars (CEq ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.eq se1 se2\n+cexp2sexp vars (CAnd ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.and se1 se2\n+cexp2sexp vars (CNot ce) = do\n+  se <- cexp2sexp vars ce\n+  return $ S.not se\n+cexp2sexp vars (CIf ce1 ce2 ce3) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  se3 <- cexp2sexp vars ce3\n+  return $ S.ite se1 se2 se3\n+cexp2sexp vars (CWhen ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  -- TODO: Temporary hack"
  },
  {
    "id" : "a8de0e6d-2338-4476-8ae9-32bd74e57ccb",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "f6a52de9-a4cf-4f42-ba9d-d22790d47ca5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n          (cres, arcs) = \r\n             foldl' (\\(cs, as) (cs', as') -> (cs ++ cs', as ++ as')) ([], []) $\r\n             map (filterCondUpd ftem f upd) upds\r\n```\r\nAt least to me that’s much easier to understand.",
        "createdAt" : "2020-05-11T08:05:24Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\n+  in freevars `intersect` vars\n+\n+-- | Constructs a constraint set from the generator environment, together with\n+-- the template name, the choice and field to be verified.\n+constructConstr :: Env 'Solving\n+  -- ^ The generator environment to convert.\n+  -> TypeConName\n+  -- ^ The template name of the choice to be verified.\n+  -> ChoiceName\n+  -- ^ The choice name to be verified.\n+  -> TypeConName\n+  -- ^ The template name of the field to be verified.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> ConstraintSet\n+constructConstr env chtem ch ftem f =\n+  case lookupChoInHMap (_envschs env) chtem ch of\n+    Just (self, this, arg, updSubst) ->\n+      let upds = _ussUpdate $ updSubst (EVar self) (EVar this) (EVar arg)\n+          vars = concatMap skol2var (_envsskol env)\n+          (cres, arcs) = foldl\n+            (\\(cs,as) upd -> let (cs',as') = filterCondUpd ftem f upd in (cs ++ cs',as ++ as'))\n+            ([],[]) upds"
  },
  {
    "id" : "8b7be5d4-9463-4ad6-ba71-357905cc7c6d",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "b0004288-e1ea-46d8-b8e4-8e3572c529aa",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we come up with slightly clearer variable names, e.g. `choiceName` `templateName` (or `tpl` which we use in other places so it’s clear enough) and `field` or `fieldName`?",
        "createdAt" : "2020-05-11T08:06:09Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 237,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\n+  in freevars `intersect` vars\n+\n+-- | Constructs a constraint set from the generator environment, together with\n+-- the template name, the choice and field to be verified.\n+constructConstr :: Env 'Solving\n+  -- ^ The generator environment to convert.\n+  -> TypeConName\n+  -- ^ The template name of the choice to be verified.\n+  -> ChoiceName\n+  -- ^ The choice name to be verified.\n+  -> TypeConName\n+  -- ^ The template name of the field to be verified.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> ConstraintSet\n+constructConstr env chtem ch ftem f ="
  },
  {
    "id" : "1407b22d-d56a-4db2-bfa9-630c3b0adeb8",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "1fc2cf37-695a-4e49-aa2b-50c1e8066a0b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "How does this work? You are working with integers in some places.",
        "createdAt" : "2020-05-11T08:55:17Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ffda60a3-de91-40de-b0bd-ea5e7107912f",
        "parentId" : "1fc2cf37-695a-4e49-aa2b-50c1e8066a0b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think it works somewhat by accident because `0` is both a real and an integer literal. We should check the type.",
        "createdAt" : "2020-05-11T08:59:26Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,309 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+\n+-- | Constraint solver for DAML LF static verification\n+module DA.Daml.LF.Verify.Solve\n+  ( constructConstr\n+  , solveConstr\n+  , ConstraintSet(..)\n+  , Result(..)\n+  ) where\n+\n+import Data.Bifunctor\n+import Data.Maybe (fromJust, maybeToList)\n+import Data.List (lookup, union, intersect)\n+import qualified Data.Text as T\n+import qualified SimpleSMT as S\n+\n+import DA.Daml.LF.Ast.Base\n+import DA.Daml.LF.Verify.Context\n+\n+-- TODO: Since S.SExpr is so similar, we could just drop this.\n+-- | A simple form of expressions featuring basic arithmetic.\n+data ConstraintExpr\n+  -- | Boolean value.\n+  = CBool !Bool\n+  -- | Integer value.\n+  | CInt !Integer\n+  -- | Real value.\n+  | CReal !Rational\n+  -- | Reference to an expression variable.\n+  | CVar !ExprVarName\n+  -- | Sum of two expressions.\n+  | CAdd !ConstraintExpr !ConstraintExpr\n+  -- | Subtraction of two expressions.\n+  | CSub !ConstraintExpr !ConstraintExpr\n+  -- | Equals operator.\n+  | CEq !ConstraintExpr !ConstraintExpr\n+  -- | Boolean and operator.\n+  | CAnd !ConstraintExpr !ConstraintExpr\n+  -- | Boolean not operator.\n+  | CNot !ConstraintExpr\n+  -- | If then else expression.\n+  | CIf !ConstraintExpr !ConstraintExpr !ConstraintExpr\n+  -- | If then expression.\n+  | CWhen !ConstraintExpr !ConstraintExpr\n+\n+instance Show ConstraintExpr where\n+  show (CBool b) = show b\n+  show (CInt i) = show i\n+  show (CReal i) = show i\n+  show (CVar x) = T.unpack $ unExprVarName x\n+  show (CAdd e1 e2) = show e1 ++ \" + \" ++ show e2\n+  show (CSub e1 e2) = show e1 ++ \" - \" ++ show e2\n+  show (CEq e1 e2) = show e1 ++ \" == \" ++ show e2\n+  show (CAnd e1 e2) = show e1 ++ \" and \" ++ show e2\n+  show (CNot e) = \"not \" ++ show e\n+  show (CIf e1 e2 e3) = \"if \" ++ show e1 ++ \" then \" ++ show e2 ++ \" else \" ++ show e3\n+  show (CWhen e1 e2) = \"when \" ++ show e1 ++ \" then \" ++ show e2\n+\n+-- | Class covering the types converteable to constraint expressions.\n+class ConstrExpr a where\n+  -- | Convert the given data type to a constraint expression.\n+  toCExp :: a -> ConstraintExpr\n+\n+instance ConstrExpr BoolExpr where\n+  toCExp (BExpr e) = toCExp e\n+  toCExp (BAnd b1 b2) = CAnd (toCExp b1) (toCExp b2)\n+  toCExp (BNot b) = CNot (toCExp b)\n+\n+instance ConstrExpr Expr where\n+  toCExp (EVar x) = CVar x\n+  toCExp (ERecProj _ f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (EStructProj f (EVar x)) = CVar $ recProj2Var x f\n+  toCExp (ETmApp (ETmApp op e1) e2) = case op of\n+    (EBuiltin (BEEqual _)) -> CEq (toCExp e1) (toCExp e2)\n+    (EBuiltin BEAddInt64) -> CAdd (toCExp e1) (toCExp e2)\n+    (EBuiltin BESubInt64) -> CSub (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BEAddNumeric) _) -> CAdd (toCExp e1) (toCExp e2)\n+    (ETyApp (EBuiltin BESubNumeric) _) -> CSub (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"+\"))) _) _) ->\n+      CAdd (toCExp e1) (toCExp e2)\n+    (ETmApp (ETyApp (EVal (Qualified _ _ (ExprValName \"-\"))) _) _) ->\n+      CSub (toCExp e1) (toCExp e2)\n+    _ -> error (\"Builtin: \" ++ show op)\n+  toCExp (ELocation _ e) = toCExp e\n+  toCExp (EBuiltin (BEBool b)) = CBool b\n+  toCExp (EBuiltin (BEInt64 i)) = CInt $ toInteger i\n+  -- TODO\n+  -- toCExp (EBuiltin (BENumeric i)) = CReal i\n+  toCExp e = error (\"Conversion: \" ++ show e)\n+\n+instance ConstrExpr a => ConstrExpr (Cond a) where\n+  toCExp (Determined x) = toCExp x\n+  toCExp (Conditional b x Nothing) = CWhen (toCExp b) (toCExp x)\n+  toCExp (Conditional b x (Just y)) = CIf (toCExp b) (toCExp x) (toCExp y)\n+\n+-- | Gather all free variables in a constraint expression.\n+gatherFreeVars :: ConstraintExpr\n+  -- ^ The constraint expression to traverse.\n+  -> [ExprVarName]\n+gatherFreeVars (CBool _) = []\n+gatherFreeVars (CInt _) = []\n+gatherFreeVars (CReal _) = []\n+gatherFreeVars (CVar x) = [x]\n+gatherFreeVars (CAdd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CSub e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CEq e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CAnd e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+gatherFreeVars (CNot e) = gatherFreeVars e\n+gatherFreeVars (CIf e1 e2 e3) = gatherFreeVars e1 `union`\n+  gatherFreeVars e2 `union` gatherFreeVars e3\n+gatherFreeVars (CWhen e1 e2) = gatherFreeVars e1 `union` gatherFreeVars e2\n+\n+-- | Gather the variable names bound within a skolem variable.\n+skol2var :: Skolem\n+  -- ^ The skolem variable to handle.\n+  -> [ExprVarName]\n+skol2var (SkolVar x) = [x]\n+skol2var (SkolRec x fs) = map (recProj2Var x) fs\n+\n+-- | Squash a record projection into a single variable name.\n+recProj2Var :: ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> ExprVarName\n+recProj2Var (ExprVarName x) (FieldName f) = ExprVarName (x `T.append` \".\" `T.append` f)\n+\n+-- | The set of constraints to be solved.\n+data ConstraintSet = ConstraintSet\n+  { _cVars :: ![ExprVarName]\n+    -- ^ The variables to be declared.\n+  , _cCres :: ![ConstraintExpr]\n+    -- ^ The field values of all newly created instances.\n+  , _cArcs :: ![ConstraintExpr]\n+    -- ^ The field values of all archived instances.\n+  }\n+  deriving Show\n+\n+-- | Filters a single update to match the given template, and takes out the\n+-- field of interest. The update gets converted into a constraint expression.\n+-- It returns either a create or an archive update.\n+filterUpd :: TypeConName\n+  -- ^ The template name to filter against.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Upd\n+  -- ^ The update expression to convert and filter.\n+  -> (Maybe ConstraintExpr, Maybe ConstraintExpr)\n+filterUpd tem f UpdCreate{..} = if tem == qualObject _creTemp\n+  then (Just (toCExp $ fromJust $ lookup f _creField), Nothing)\n+  else (Nothing, Nothing)\n+filterUpd tem f UpdArchive{..} = if tem == qualObject _arcTemp\n+  then (Nothing, Just (toCExp $ fromJust $ lookup f _arcField))\n+  else (Nothing, Nothing)\n+\n+-- | Filters and converts a conditional update into (possibly two) constraint\n+-- expressions, while splitting it into create and archive updates.\n+filterCondUpd :: TypeConName\n+  -- ^ The template name to filter against\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> Cond Upd\n+  -- ^ The conditional update expression to convert and filter.\n+  -> ([ConstraintExpr], [ConstraintExpr])\n+filterCondUpd tem f (Determined x) = bimap maybeToList maybeToList $ filterUpd tem f x\n+filterCondUpd tem f (Conditional b x Nothing) =\n+  let cb = toCExp b\n+      cx = bimap maybeToList maybeToList $ filterUpd tem f x\n+  in bimap (map (CWhen cb)) (map (CWhen cb)) cx\n+filterCondUpd tem f (Conditional b x (Just y)) =\n+  let cb = toCExp b\n+      (cxcre,cxarc) = bimap maybeToList maybeToList $ filterUpd tem f x\n+      (cycre,cyarc) = bimap maybeToList maybeToList $ filterUpd tem f y\n+  -- TODO: We should try to use an if here.\n+  in ( map (CWhen cb) cxcre ++ map (CWhen (CNot cb)) cycre\n+     , map (CWhen cb) cxarc ++ map (CWhen (CNot cb)) cyarc )\n+\n+-- | Filter the given set of skolems, to only include those that occur in the\n+-- given constraint expressions. Remove duplicates in the process.\n+filterVars :: [ExprVarName]\n+  -- ^ The list of skolems to filter.\n+  -> [ConstraintExpr]\n+  -- ^ The constraint expressions in which the skolems should occur.\n+  -> [ExprVarName]\n+filterVars vars cexprs =\n+  let freevars = foldl (\\fv e -> fv `union` gatherFreeVars e) [] cexprs\n+  in freevars `intersect` vars\n+\n+-- | Constructs a constraint set from the generator environment, together with\n+-- the template name, the choice and field to be verified.\n+constructConstr :: Env 'Solving\n+  -- ^ The generator environment to convert.\n+  -> TypeConName\n+  -- ^ The template name of the choice to be verified.\n+  -> ChoiceName\n+  -- ^ The choice name to be verified.\n+  -> TypeConName\n+  -- ^ The template name of the field to be verified.\n+  -> FieldName\n+  -- ^ The field name to be verified.\n+  -> ConstraintSet\n+constructConstr env chtem ch ftem f =\n+  case lookupChoInHMap (_envschs env) chtem ch of\n+    Just (self, this, arg, updSubst) ->\n+      let upds = _ussUpdate $ updSubst (EVar self) (EVar this) (EVar arg)\n+          vars = concatMap skol2var (_envsskol env)\n+          (cres, arcs) = foldl\n+            (\\(cs,as) upd -> let (cs',as') = filterCondUpd ftem f upd in (cs ++ cs',as ++ as'))\n+            ([],[]) upds\n+      in ConstraintSet vars cres arcs\n+    Nothing -> error \"Choice not found\"\n+\n+-- | Convert a constraint expression into an SMT expression from the solving library.\n+cexp2sexp :: [(ExprVarName,S.SExpr)]\n+  -- ^ The set of variable names, mapped to their corresponding SMT counterparts.\n+  -> ConstraintExpr\n+  -- ^ The constraint expression to convert.\n+  -> IO S.SExpr\n+cexp2sexp _vars (CBool b) = return $ S.bool b\n+cexp2sexp _vars (CInt i) = return $ S.int i\n+cexp2sexp _vars (CReal i) = return $ S.real i\n+cexp2sexp vars (CVar x) = case lookup x vars of\n+  Just exp -> return exp\n+  Nothing -> error (\"Impossible: variable not found \" ++ show x)\n+cexp2sexp vars (CAdd ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.add se1 se2\n+cexp2sexp vars (CSub ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.sub se1 se2\n+cexp2sexp vars (CEq ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.eq se1 se2\n+cexp2sexp vars (CAnd ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  return $ S.and se1 se2\n+cexp2sexp vars (CNot ce) = do\n+  se <- cexp2sexp vars ce\n+  return $ S.not se\n+cexp2sexp vars (CIf ce1 ce2 ce3) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  se3 <- cexp2sexp vars ce3\n+  return $ S.ite se1 se2 se3\n+cexp2sexp vars (CWhen ce1 ce2) = do\n+  se1 <- cexp2sexp vars ce1\n+  se2 <- cexp2sexp vars ce2\n+  -- TODO: Temporary hack\n+  return $ S.ite se1 se2 (S.real 0)\n+\n+-- | Declare a list of variables for the SMT solver. Returns a list of the\n+-- declared variables, together with their corresponding SMT counterparts.\n+declareVars :: S.Solver\n+  -- ^ The SMT solver.\n+  -> [ExprVarName]\n+  -- ^ The variables to be declared.\n+  -> IO [(ExprVarName,S.SExpr)]\n+declareVars s xs = zip xs <$> mapM (\\x -> S.declare s (var2str x) S.tReal) xs\n+  where\n+    var2str :: ExprVarName -> String\n+    var2str (ExprVarName x) = T.unpack x\n+\n+-- | Data type denoting the outcome of the solver.\n+data Result\n+  = Success\n+  -- ^ The total field amount remains preserved.\n+  | Fail [(S.SExpr, S.Value)]\n+  -- ^ The total field amound does not remain the same. A counter example is\n+  -- provided.\n+  | Unknown\n+  -- ^ The result is inconclusive.\n+  deriving Eq\n+\n+instance Show Result where\n+  show Success = \"Success!\"\n+  show (Fail cs) = \"Fail. Counter example:\" ++ foldl (flip step) \"\" cs\n+    where\n+      step :: (S.SExpr, S.Value) -> String -> String\n+      step (var, val) str = (\"\\n\" ++) $ S.ppSExpr var $ (\" = \" ++) $ S.ppSExpr (S.value val) str\n+  show Unknown = \"Inconclusive.\"\n+\n+-- | Solve a give constraint set. Prints 'unsat' when the constraint set is\n+-- valid. It asserts that the set of created and archived contracts are not\n+-- equal.\n+solveConstr :: FilePath\n+  -- ^ The path to the constraint solver.\n+  -> ConstraintSet\n+  -- ^ The constraint set to solve.\n+  -> IO Result\n+solveConstr spath ConstraintSet{..} = do\n+  log <- S.newLogger 1\n+  sol <- S.newSolver spath [\"-in\"] (Just log)\n+  vars <- declareVars sol $ filterVars _cVars (_cCres ++ _cArcs)\n+  cre <- foldl S.add (S.real 0) <$> mapM (cexp2sexp vars) _cCres"
  }
]