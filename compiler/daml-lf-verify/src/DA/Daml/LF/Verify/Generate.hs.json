[
  {
    "id" : "72b3457c-c319-4531-bc50-bc028957adb9",
    "prId" : 7548,
    "comments" : [
      {
        "id" : "71607136-82f8-4231-a5c3-8971572913f1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n      (ENil (TBuiltin BTParty)) Nothing (ExprVarName \"self\")\r\n```",
        "createdAt" : "2020-10-14T10:51:54Z",
        "updatedAt" : "2020-10-21T08:55:23Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1968095863437d26708412e9478b8d076d85897c",
    "line" : null,
    "diffHunk" : "@@ -219,7 +219,7 @@ genTemplate pac mod Template{..} = do\n   where\n     archive :: TemplateChoice\n     archive = TemplateChoice Nothing (ChoiceName \"Archive\") True\n-      (ENil (TBuiltin BTParty)) (ExprVarName \"self\")\n+      (ENil (TBuiltin BTParty)) (ENil (TBuiltin BTParty)) (ExprVarName \"self\")"
  },
  {
    "id" : "a393a42d-bb9f-48d3-ad69-50648012d0b3",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "26d10848-66a1-42ce-af32-d28f7058223f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given how many functions take this argument, maybe worth turning it into a `newtype` or a custom ADT with some docs why and when we turn this off.",
        "createdAt" : "2020-06-29T11:31:02Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 298,
    "diffHunk" : "@@ -267,44 +311,31 @@ genForTyApp updFlag expr typ = do\n -- | Analyse a let binding expression.\n genForLet :: (GenPhase ph, MonadEnv m ph)\n   => Bool"
  },
  {
    "id" : "f39a0f2f-5f2c-4bdc-b19d-1cab2d9990e3",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "f46daa10-d419-4063-a37f-957801d1e2b2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why does the type not matter?",
        "createdAt" : "2020-06-29T11:32:52Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3599dabb-653b-42a7-8fdf-fb1c6f59ac16",
        "parentId" : "f46daa10-d419-4063-a37f-957801d1e2b2",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "The only place where these types are used, is in `bindCids`, where they are used to bind fetched / created contract cids. However, as a `UPure` update can't fetch or create a new contract, its type specifically is not important.\r\nBut you're right that that's not very clear at all. I added a note.",
        "createdAt" : "2020-06-30T14:47:32Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 500,
    "diffHunk" : "@@ -440,66 +482,155 @@ genForBind :: (GenPhase ph, MonadEnv m ph)\n   -- ^ The binding being bound with this update.\n   -> Expr\n   -- ^ The expression in which this binding is being made available.\n-  -> m (Output ph, Type, Maybe Expr)\n+  -> m (Output ph, Maybe Type, Maybe Expr)\n genForBind bind body = do\n   bindOut <- genExpr False (bindingBound bind)\n-  bindUpd <- case _oExpr bindOut of\n+  (bindUpd, subst) <- case _oExpr bindOut of\n     EUpdate (UFetch tc cid) -> do\n-      bindCids (TContractId (TCon tc)) cid (EVar $ fst $ bindingBinder bind) Nothing\n-      return emptyUpdateSet\n+      let var0 = fst $ bindingBinder bind\n+      var1 <- genRenamedVar var0\n+      let subst = singleExprSubst var0 (EVar var1)\n+      _ <- bindCids False (Just $ TContractId (TCon tc)) cid (EVar var1) Nothing\n+      return (emptyUpdateSet, subst)\n     EUpdate upd -> do\n       (updOut, updTyp, creFs) <- genUpdate upd\n       this <- genRenamedVar (ExprVarName \"this\")\n-      bindCids updTyp (EVar $ fst $ bindingBinder bind) (EVar this) creFs\n-      return $ _oUpdate updOut\n-    _ -> return emptyUpdateSet\n+      subst <- bindCids True updTyp (EVar $ fst $ bindingBinder bind) (EVar this) creFs\n+      return (_oUpdate updOut, subst)\n+    _ -> return (emptyUpdateSet, emptyExprSubst)\n   extVarEnv (fst $ bindingBinder bind)\n-  bodyOut <- genExpr False body\n-  case _oExpr bodyOut of\n-    EUpdate bodyUpd -> do\n-      (bodyUpdOut, bodyTyp, creFs) <- genUpdate bodyUpd\n-      return ( Output\n-                 (_oExpr bodyUpdOut)\n-                 (_oUpdate bindOut\n-                   `concatUpdateSet` bindUpd\n-                   `concatUpdateSet` _oUpdate bodyOut\n-                   `concatUpdateSet` _oUpdate bodyUpdOut)\n-             , bodyTyp\n-             , creFs )\n-    _ -> error \"Impossible: The body of a bind should be an update expression\"\n+  bodyOut <- genExpr False $ substituteTm subst body\n+  let bodyUpd = case _oExpr bodyOut of\n+        EUpdate bodyUpd -> bodyUpd\n+        -- Note: This is a bit of a hack, as we're forced to provide some type to"
  },
  {
    "id" : "4dc9220e-a67a-4151-8bc6-cda83c242ceb",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "4d260cab-48ed-477e-bd9c-bf8738f7b338",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n  mbPreCond <- lookupPreconds (TCon tem) bind\r\n  whenJust mbPreCond $ \\precond -> do\r\n    precondOut <- genExpr False precond\r\n    extCtr (_oExpr precondOut)\r\n```",
        "createdAt" : "2020-06-29T11:41:11Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -440,66 +482,155 @@ genForBind :: (GenPhase ph, MonadEnv m ph)\n   -- ^ The binding being bound with this update.\n   -> Expr\n   -- ^ The expression in which this binding is being made available.\n-  -> m (Output ph, Type, Maybe Expr)\n+  -> m (Output ph, Maybe Type, Maybe Expr)\n genForBind bind body = do\n   bindOut <- genExpr False (bindingBound bind)\n-  bindUpd <- case _oExpr bindOut of\n+  (bindUpd, subst) <- case _oExpr bindOut of\n     EUpdate (UFetch tc cid) -> do\n-      bindCids (TContractId (TCon tc)) cid (EVar $ fst $ bindingBinder bind) Nothing\n-      return emptyUpdateSet\n+      let var0 = fst $ bindingBinder bind\n+      var1 <- genRenamedVar var0\n+      let subst = singleExprSubst var0 (EVar var1)\n+      _ <- bindCids False (Just $ TContractId (TCon tc)) cid (EVar var1) Nothing\n+      return (emptyUpdateSet, subst)\n     EUpdate upd -> do\n       (updOut, updTyp, creFs) <- genUpdate upd\n       this <- genRenamedVar (ExprVarName \"this\")\n-      bindCids updTyp (EVar $ fst $ bindingBinder bind) (EVar this) creFs\n-      return $ _oUpdate updOut\n-    _ -> return emptyUpdateSet\n+      subst <- bindCids True updTyp (EVar $ fst $ bindingBinder bind) (EVar this) creFs\n+      return (_oUpdate updOut, subst)\n+    _ -> return (emptyUpdateSet, emptyExprSubst)\n   extVarEnv (fst $ bindingBinder bind)\n-  bodyOut <- genExpr False body\n-  case _oExpr bodyOut of\n-    EUpdate bodyUpd -> do\n-      (bodyUpdOut, bodyTyp, creFs) <- genUpdate bodyUpd\n-      return ( Output\n-                 (_oExpr bodyUpdOut)\n-                 (_oUpdate bindOut\n-                   `concatUpdateSet` bindUpd\n-                   `concatUpdateSet` _oUpdate bodyOut\n-                   `concatUpdateSet` _oUpdate bodyUpdOut)\n-             , bodyTyp\n-             , creFs )\n-    _ -> error \"Impossible: The body of a bind should be an update expression\"\n+  bodyOut <- genExpr False $ substituteTm subst body\n+  let bodyUpd = case _oExpr bodyOut of\n+        EUpdate bodyUpd -> bodyUpd\n+        -- Note: This is a bit of a hack, as we're forced to provide some type to\n+        -- UPure, but the type itself doesn't really matter.\n+        expr -> UPure (TBuiltin BTUnit) expr\n+  (bodyUpdOut, bodyTyp, creFs) <- genUpdate bodyUpd\n+  return ( Output\n+             (_oExpr bodyUpdOut)\n+             (_oUpdate bindOut\n+               `concatUpdateSet` bindUpd\n+               `concatUpdateSet` _oUpdate bodyOut\n+               `concatUpdateSet` _oUpdate bodyUpdOut)\n+         , bodyTyp\n+         , creFs )\n \n+-- | Refresh and bind the fetched contract id to the given variable. Returns a\n+-- substitution, mapping the old id to the refreshed one.\n bindCids :: (GenPhase ph, MonadEnv m ph)\n-  => Type\n+  => Bool\n+  -- ^ Flag denoting whether the contract id's should be refreshed.\n+  -- Note that even with the flag on, contract id's are only refreshed on their\n+  -- first encounter.\n+  -> Maybe Type\n   -- ^ The type of the contract id's being bound.\n   -> Expr\n   -- ^ The contract id's being bound.\n   -> Expr\n   -- ^ The variables to bind them to.\n   -> Maybe Expr\n   -- ^ The field values for any created contracts, if available.\n-  -> m ()\n-bindCids (TContractId (TCon tc)) cid (EVar this) fsExpM = do\n-  fs <- recTypConFields $ qualObject tc\n+  -> m ExprSubst\n+bindCids _ Nothing _ _ _ = return emptyExprSubst\n+bindCids b (Just (TContractId (TCon tc))) cid (EVar this) fsExpM = do\n+  fs <- recTypConFields (qualObject tc) >>= \\case\n+    Nothing -> throwError ExpectRecord\n+    Just fs -> return fs\n   extRecEnv this (map fst fs)\n-  cidOut <- genExpr True cid\n-  extCidEnv (_oExpr cidOut) this\n+  subst <- extCidEnv b cid this\n   case fsExpM of\n-    Just fsExp -> recExpFields fsExp >>= \\case\n-      Just fields -> extCtrRec this fields\n-      Nothing -> return ()\n-    Nothing -> return ()\n-bindCids (TCon tc) cid (EVar this) fsExpM = do\n-  fs <- recTypConFields $ qualObject tc\n+    Just fsExp -> do\n+      fsOut <- genExpr False $ substituteTm subst fsExp\n+      recExpFields (_oExpr fsOut) >>= \\case\n+        Just fields -> do\n+          fields' <- mapM (\\(f,e) -> genExpr False e >>= \\out -> return (f,_oExpr out)) fields\n+          extCtrRec this fields'\n+          return subst\n+        Nothing -> throwError ExpectRecord\n+    Nothing -> return subst\n+bindCids b (Just (TCon tc)) cid (EVar this) fsExpM = do\n+  fs <- recTypConFields (qualObject tc) >>= \\case\n+    Nothing -> throwError ExpectRecord\n+    Just fs -> return fs\n   extRecEnv this (map fst fs)\n-  cidOut <- genExpr True cid\n-  extCidEnv (_oExpr cidOut) this\n+  subst <- extCidEnv b cid this\n   case fsExpM of\n-    Just fsExp -> recExpFields fsExp >>= \\case\n-      Just fields -> extCtrRec this fields\n-      Nothing -> return ()\n-    Nothing -> return ()\n-bindCids (TBuiltin BTUnit) _ _ _ = return ()\n-bindCids (TBuiltin BTTimestamp) _ _ _ = return ()\n--- TODO: Extend additional cases, like tuples.\n-bindCids typ _ _ _ =\n+    Just fsExp -> do\n+      fsOut <- genExpr False $ substituteTm subst fsExp\n+      recExpFields (_oExpr fsOut) >>= \\case\n+        Just fields -> do\n+          fields' <- mapM (\\(f,e) -> genExpr False e >>= \\out -> return (f,_oExpr out)) fields\n+          extCtrRec this fields'\n+          return subst\n+        Nothing -> throwError ExpectRecord\n+    Nothing -> return subst\n+bindCids b (Just (TApp (TApp (TCon con) t1) t2)) cid var fsExpM =\n+  case head $ unTypeConName $ qualObject con of\n+    \"Tuple2\" -> do\n+      subst1 <- bindCids b (Just t1) (EStructProj (FieldName \"_1\") cid) var fsExpM\n+      subst2 <- bindCids b (Just t2) (substituteTm subst1 $ EStructProj (FieldName \"_2\") cid) var fsExpM\n+      return (subst1 `concatExprSubst` subst2)\n+    con' -> error (\"Binding contract id's for this constructor has not been implemented yet: \" ++ show con')\n+bindCids _ (Just (TBuiltin BTUnit)) _ _ _ = return emptyExprSubst\n+bindCids _ (Just (TBuiltin BTTimestamp)) _ _ _ = return emptyExprSubst\n+-- TODO: This can be extended with additional cases later on.\n+bindCids _ (Just typ) _ _ _ =\n   error (\"Binding contract id's for this particular type has not been implemented yet: \" ++ show typ)\n+\n+-- Note: It would be much nicer to have these functions in Context.hs, but they\n+-- require the `GenPhase` monad.\n+-- | Lookup the preconditions for a given type, and instantiate the `this`\n+-- variable.\n+lookupPreconds :: (GenPhase ph, MonadEnv m ph)\n+  => Type\n+  -- ^ The type to lookup.\n+  -> ExprVarName\n+  -- ^ The variable for `this` to instantiate with.\n+  -> m (Maybe Expr)\n+lookupPreconds typ this = case typ of\n+  (TCon tem) -> do\n+    preconds <- envPreconds <$> getEnv\n+    case HM.lookup tem preconds of\n+      Nothing -> return Nothing\n+      Just preFunc -> do\n+        preOut <- genExpr False (preFunc $ EVar this)\n+        return $ Just $ _oExpr preOut\n+  _ -> return Nothing\n+\n+-- | Bind the given contract id, and add any required additional constraints to\n+-- the environment.\n+extEnvContract :: (GenPhase ph, MonadEnv m ph)\n+  => Type\n+  -- ^ The contract id type to add to the environment.\n+  -> Expr\n+  -- ^ The contract id being bound.\n+  -> Maybe ExprVarName\n+  -- ^ The variable to bind the contract id to, if available.\n+  -> m ()\n+extEnvContract (TContractId typ) cid bindM = extEnvContract typ cid bindM\n+extEnvContract (TCon tem) cid bindM = do\n+  bindV <- genRenamedVar (ExprVarName \"var\")\n+  let bind = fromMaybe bindV bindM\n+  _ <- bindCids False (Just $ TCon tem) cid (EVar bind) Nothing\n+  lookupPreconds (TCon tem) bind >>= \\case\n+    Nothing -> return ()\n+    Just precond -> do\n+      precondOut <- genExpr False precond\n+      extCtr (_oExpr precondOut)"
  },
  {
    "id" : "ac6db4bc-3227-4ac4-808a-a3afde90c046",
    "prId" : 6344,
    "comments" : [
      {
        "id" : "b8f5011e-b770-4ebc-b94e-5c26fbeb8a2f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Here and for `argFieldSubst` above:\r\n```suggestion\r\n      thisFieldSubst = Map.fromList [(fieldName2VarName f, EStructProj f (EVar this)) | f <- temFs]\r\n```\r\nYou probably want to give `Map.fromList` a name like `substFromList` in `Subst.hs`.",
        "createdAt" : "2020-06-15T09:19:18Z",
        "updatedAt" : "2020-06-15T09:41:15Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ab5289eb91f2d01eb193ec32886c6117516bcb25",
    "line" : null,
    "diffHunk" : "@@ -141,9 +141,16 @@ genChoice pac tem (this',this) temFs TemplateChoice{..} = do\n   extVarEnv self\n   extVarEnv arg\n   argFs <- recTypFields (snd chcArgBinder)\n+  -- Replace the argument and template fields with their record projection form.\n+  let argFieldSubst = foldl concatExprSubst emptyExprSubst\n+        (map (\\f -> singleExprSubst (fieldName2VarName f) (EStructProj f (EVar arg))) argFs)\n+      thisFieldSubst = foldl concatExprSubst emptyExprSubst\n+        (map (\\f -> singleExprSubst (fieldName2VarName f) (EStructProj f (EVar this))) temFs)"
  },
  {
    "id" : "beed5934-9396-4237-8c91-91bfdb058c0f",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "20e22dfd-5421-4f93-9cf4-a9dfe35a6065",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That would be caught by the LF typechecker, so no need to do more than crash here.",
        "createdAt" : "2020-04-07T20:04:34Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)\n+    genModule' :: MonadDelta m => Delta -> (PackageRef, Module) -> m Delta\n+    genModule' deli (paci, modi) = introDelta deli (genModule paci modi)\n+                                   >>= return . (concatDelta deli)\n+\n+-- TODO: Type synonyms and data types are ignored for now.\n+genModule :: MonadDelta m => PackageRef -> Module -> m Delta\n+genModule pac mod = do\n+  del0 <- ask\n+  del1 <- foldM genValue' del0 (NM.toList $ moduleValues mod)\n+  del2 <- foldM genTemplate' del1 (NM.toList $ moduleTemplates mod)\n+  return $ concatDelta del1 del2\n+  where\n+    genValue' :: MonadDelta m => Delta -> DefValue -> m Delta\n+    genValue' deli vali = introDelta deli (genValue pac (moduleName mod) vali)\n+                          >>= return . (concatDelta deli)\n+    genTemplate' :: MonadDelta m => Delta -> Template -> m Delta\n+    genTemplate' deli temi = introDelta deli (genTemplate temi)\n+                          >>= return . (concatDelta deli)\n+\n+genValue :: MonadDelta m => PackageRef -> ModuleName -> DefValue -> m Delta\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  return $ set devals (singleton qname (expOut ^. goExp, expOut ^. goUpd)) emptyDelta\n+\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadDelta m => (Qualified TypeConName) -> TemplateChoice\n+          -> m GenOutput\n+genChoice tem cho = do\n+  expOut <- extVarDelta (fst $ chcArgBinder cho) $ genExpr (chcUpdate cho)\n+  let updSet = if chcConsuming cho\n+        -- TODO: Convert the `ExprVarName`s to `FieldName`s\n+        then over usArc ((:) (UpdArchive tem [])) (expOut ^. goUpd)\n+        else expOut ^. goUpd\n+  return $ set goUpd updSet\n+         $ over (goDel . devars) ((:) (fst $ chcArgBinder cho))\n+         expOut\n+\n+genTemplate :: MonadDelta m => Template -> m Delta\n+genTemplate = undefined -- TODO\n+\n+genExpr :: MonadDelta m => Expr -> m GenOutput\n+genExpr = \\case\n+  ETmApp fun arg  -> genForTmApp fun arg\n+  ETyApp expr typ -> genForTyApp expr typ\n+  EVar name       -> genForVar name\n+  EVal w          -> genForVal w\n+  EUpdate (UCreate tem arg)              -> genForCreate tem arg\n+  EUpdate (UExercise tem ch cid par arg) -> genForExercise tem ch cid par arg\n+  _ -> error \"Not implemented\"\n+\n+genForTmApp :: MonadDelta m => Expr -> Expr -> m GenOutput\n+genForTmApp fun arg = do\n+  funOut <- genExpr fun\n+  argOut <- genExpr arg\n+  case funOut ^. goExp of\n+    ETmLam bndr body -> do\n+      let updDelta = concatDelta (funOut ^. goDel) (argOut ^. goDel)\n+          subst    = singleExprSubst (fst bndr) (argOut ^. goExp)\n+          resExpr  = substituteTmTm subst body\n+      resOut <- introDelta updDelta $ genExpr resExpr\n+      return $ combineGO resOut\n+             $ combineGO funOut argOut\n+    fun'             -> return $ updateGOExpr (ETmApp fun' (argOut ^. goExp))\n+                               $ combineGO funOut argOut\n+\n+genForTyApp :: MonadDelta m => Expr -> Type -> m GenOutput\n+genForTyApp expr typ = do\n+  exprOut <- genExpr expr\n+  case exprOut ^. goExp of\n+    ETyLam bndr body -> do\n+      let subst   = singleTypeSubst (fst bndr) typ\n+          resExpr = substituteTyTm subst body\n+      resOut <- introDelta (exprOut ^. goDel) $ genExpr resExpr\n+      return $ combineGO resOut exprOut\n+    expr'            -> return $ updateGOExpr (ETyApp expr' typ) exprOut\n+\n+genForVar :: MonadDelta m => ExprVarName -> m GenOutput\n+genForVar name = lookupDExprVar name\n+                 >> return (GenOutput (EVar name) emptyUpdateSet emptyDelta)\n+\n+genForVal :: MonadDelta m => (Qualified ExprValName) -> m GenOutput\n+genForVal w = lookupDVal w\n+              >>= \\ (expr, upds) -> return (GenOutput expr upds emptyDelta)\n+\n+genForCreate :: MonadDelta m => (Qualified TypeConName) -> Expr -> m GenOutput\n+genForCreate tem arg = do\n+  argOut <- genExpr arg\n+  case argOut ^. goExp of\n+    argExpr@(ERecCon _ fs) -> return (GenOutput (EUpdate (UCreate tem argExpr))\n+                                      -- TODO: We could potentially filter here\n+                                      -- to only store the interesting fields?\n+                                      (set usCre [UpdCreate tem fs] emptyUpdateSet)\n+                                      (argOut ^. goDel))\n+    _                      -> throwError EEnumTypeWithParams\n+    -- TODO: This is a random error, as we do not have access to the expected\n+    -- type, which we need to constructed the error we really want.\n+    -- Perhaps we do need to define our own set of errors.\n+    -- _                      -> throwError (EExpectedRecordType ty)\n+\n+genForExercise :: MonadDelta m => (Qualified TypeConName) -> ChoiceName\n+               -> Expr -> Maybe Expr -> Expr\n+               -> m GenOutput\n+genForExercise tem ch cid par arg = do\n+  cidOut <- genExpr cid\n+  argOut <- genExpr arg\n+  -- TODO: Take possibility into account that the choice is not found?"
  },
  {
    "id" : "d9eb349c-b4ab-4e19-a750-958fc339581e",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "f947a3d9-3343-4de6-be89-fd12fc02eeef",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We generally format to be somewhat friendly to diffs. So no alignment, line breaks and indentation such that the amount of indentation does not depend on identifier length. Not a hard rule but I like being somewhat consistent here.",
        "createdAt" : "2020-04-07T20:06:47Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)\n+    genModule' :: MonadDelta m => Delta -> (PackageRef, Module) -> m Delta\n+    genModule' deli (paci, modi) = introDelta deli (genModule paci modi)\n+                                   >>= return . (concatDelta deli)\n+\n+-- TODO: Type synonyms and data types are ignored for now.\n+genModule :: MonadDelta m => PackageRef -> Module -> m Delta\n+genModule pac mod = do\n+  del0 <- ask\n+  del1 <- foldM genValue' del0 (NM.toList $ moduleValues mod)\n+  del2 <- foldM genTemplate' del1 (NM.toList $ moduleTemplates mod)\n+  return $ concatDelta del1 del2\n+  where\n+    genValue' :: MonadDelta m => Delta -> DefValue -> m Delta\n+    genValue' deli vali = introDelta deli (genValue pac (moduleName mod) vali)\n+                          >>= return . (concatDelta deli)\n+    genTemplate' :: MonadDelta m => Delta -> Template -> m Delta\n+    genTemplate' deli temi = introDelta deli (genTemplate temi)\n+                          >>= return . (concatDelta deli)\n+\n+genValue :: MonadDelta m => PackageRef -> ModuleName -> DefValue -> m Delta\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  return $ set devals (singleton qname (expOut ^. goExp, expOut ^. goUpd)) emptyDelta\n+\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadDelta m => (Qualified TypeConName) -> TemplateChoice\n+          -> m GenOutput\n+genChoice tem cho = do\n+  expOut <- extVarDelta (fst $ chcArgBinder cho) $ genExpr (chcUpdate cho)\n+  let updSet = if chcConsuming cho\n+        -- TODO: Convert the `ExprVarName`s to `FieldName`s\n+        then over usArc ((:) (UpdArchive tem [])) (expOut ^. goUpd)\n+        else expOut ^. goUpd\n+  return $ set goUpd updSet\n+         $ over (goDel . devars) ((:) (fst $ chcArgBinder cho))\n+         expOut\n+\n+genTemplate :: MonadDelta m => Template -> m Delta\n+genTemplate = undefined -- TODO\n+\n+genExpr :: MonadDelta m => Expr -> m GenOutput\n+genExpr = \\case\n+  ETmApp fun arg  -> genForTmApp fun arg\n+  ETyApp expr typ -> genForTyApp expr typ\n+  EVar name       -> genForVar name\n+  EVal w          -> genForVal w\n+  EUpdate (UCreate tem arg)              -> genForCreate tem arg\n+  EUpdate (UExercise tem ch cid par arg) -> genForExercise tem ch cid par arg\n+  _ -> error \"Not implemented\"\n+\n+genForTmApp :: MonadDelta m => Expr -> Expr -> m GenOutput\n+genForTmApp fun arg = do\n+  funOut <- genExpr fun\n+  argOut <- genExpr arg\n+  case funOut ^. goExp of\n+    ETmLam bndr body -> do\n+      let updDelta = concatDelta (funOut ^. goDel) (argOut ^. goDel)\n+          subst    = singleExprSubst (fst bndr) (argOut ^. goExp)\n+          resExpr  = substituteTmTm subst body\n+      resOut <- introDelta updDelta $ genExpr resExpr\n+      return $ combineGO resOut\n+             $ combineGO funOut argOut\n+    fun'             -> return $ updateGOExpr (ETmApp fun' (argOut ^. goExp))\n+                               $ combineGO funOut argOut\n+\n+genForTyApp :: MonadDelta m => Expr -> Type -> m GenOutput\n+genForTyApp expr typ = do\n+  exprOut <- genExpr expr\n+  case exprOut ^. goExp of\n+    ETyLam bndr body -> do\n+      let subst   = singleTypeSubst (fst bndr) typ\n+          resExpr = substituteTyTm subst body\n+      resOut <- introDelta (exprOut ^. goDel) $ genExpr resExpr\n+      return $ combineGO resOut exprOut\n+    expr'            -> return $ updateGOExpr (ETyApp expr' typ) exprOut\n+\n+genForVar :: MonadDelta m => ExprVarName -> m GenOutput\n+genForVar name = lookupDExprVar name\n+                 >> return (GenOutput (EVar name) emptyUpdateSet emptyDelta)\n+\n+genForVal :: MonadDelta m => (Qualified ExprValName) -> m GenOutput\n+genForVal w = lookupDVal w\n+              >>= \\ (expr, upds) -> return (GenOutput expr upds emptyDelta)\n+\n+genForCreate :: MonadDelta m => (Qualified TypeConName) -> Expr -> m GenOutput\n+genForCreate tem arg = do\n+  argOut <- genExpr arg\n+  case argOut ^. goExp of\n+    argExpr@(ERecCon _ fs) -> return (GenOutput (EUpdate (UCreate tem argExpr))\n+                                      -- TODO: We could potentially filter here\n+                                      -- to only store the interesting fields?\n+                                      (set usCre [UpdCreate tem fs] emptyUpdateSet)\n+                                      (argOut ^. goDel))\n+    _                      -> throwError EEnumTypeWithParams\n+    -- TODO: This is a random error, as we do not have access to the expected\n+    -- type, which we need to constructed the error we really want.\n+    -- Perhaps we do need to define our own set of errors.\n+    -- _                      -> throwError (EExpectedRecordType ty)"
  },
  {
    "id" : "39599eef-2177-4e0e-9b84-9a2c75d5c7e8",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "1161fab9-6e5f-4363-a365-aef54b9ecdaf",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This doesn’t seem quite right to me. You are conflating evaluation and execution afaict. `Update` works like `IO` in Haskell. Evaluating an `Update` expression does not do anything. The way this is implemented at runtime is by passing around an opaque token (similar to the RealWorld token in Haskell) so `Update` expressions are actually functions. You can probably do something similar for your analysis: If you start from a choice you look at the update expression evaluated to the token. If you just see an `Update` expression that is not applied to the token, you don’t look inside.",
        "createdAt" : "2020-04-07T20:11:30Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)\n+    genModule' :: MonadDelta m => Delta -> (PackageRef, Module) -> m Delta\n+    genModule' deli (paci, modi) = introDelta deli (genModule paci modi)\n+                                   >>= return . (concatDelta deli)\n+\n+-- TODO: Type synonyms and data types are ignored for now.\n+genModule :: MonadDelta m => PackageRef -> Module -> m Delta\n+genModule pac mod = do\n+  del0 <- ask\n+  del1 <- foldM genValue' del0 (NM.toList $ moduleValues mod)\n+  del2 <- foldM genTemplate' del1 (NM.toList $ moduleTemplates mod)\n+  return $ concatDelta del1 del2\n+  where\n+    genValue' :: MonadDelta m => Delta -> DefValue -> m Delta\n+    genValue' deli vali = introDelta deli (genValue pac (moduleName mod) vali)\n+                          >>= return . (concatDelta deli)\n+    genTemplate' :: MonadDelta m => Delta -> Template -> m Delta\n+    genTemplate' deli temi = introDelta deli (genTemplate temi)\n+                          >>= return . (concatDelta deli)\n+\n+genValue :: MonadDelta m => PackageRef -> ModuleName -> DefValue -> m Delta\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  return $ set devals (singleton qname (expOut ^. goExp, expOut ^. goUpd)) emptyDelta\n+\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadDelta m => (Qualified TypeConName) -> TemplateChoice\n+          -> m GenOutput\n+genChoice tem cho = do\n+  expOut <- extVarDelta (fst $ chcArgBinder cho) $ genExpr (chcUpdate cho)\n+  let updSet = if chcConsuming cho\n+        -- TODO: Convert the `ExprVarName`s to `FieldName`s\n+        then over usArc ((:) (UpdArchive tem [])) (expOut ^. goUpd)\n+        else expOut ^. goUpd\n+  return $ set goUpd updSet\n+         $ over (goDel . devars) ((:) (fst $ chcArgBinder cho))\n+         expOut\n+\n+genTemplate :: MonadDelta m => Template -> m Delta\n+genTemplate = undefined -- TODO\n+\n+genExpr :: MonadDelta m => Expr -> m GenOutput\n+genExpr = \\case\n+  ETmApp fun arg  -> genForTmApp fun arg\n+  ETyApp expr typ -> genForTyApp expr typ\n+  EVar name       -> genForVar name\n+  EVal w          -> genForVal w\n+  EUpdate (UCreate tem arg)              -> genForCreate tem arg"
  },
  {
    "id" : "56214316-69e6-42e8-a4d8-692a301ebf67",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "7d1b63d5-bc4e-4b08-a7cf-64d64ca97f57",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do all variable names end with `i`? :slightly_smiling_face: ",
        "createdAt" : "2020-04-07T20:25:58Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) ="
  },
  {
    "id" : "5e413392-ae39-4e3b-b1bc-ca3b8ac77ef3",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "065c4d2b-850d-47a0-86ac-15366a87e622",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m probably missing something but it looks to me like this only works if modules are sorted topologically. Otherwise, you might not be able to resolve a cross-module reference since you haven’t yet included the delta for that module?",
        "createdAt" : "2020-04-07T20:29:29Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))"
  },
  {
    "id" : "847c9f53-22c6-4c32-b85b-cb209d71b743",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "e7f8442b-0a42-49fd-bdb9-8480ed7e24e8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What is an annotated choice? Presumably that’s some new annotation that you want to add to express constraints that should be verified?",
        "createdAt" : "2020-04-07T20:31:35Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e4a4ed7c-2f34-4d9b-bbf0-ed19cf77437f",
        "parentId" : "e7f8442b-0a42-49fd-bdb9-8480ed7e24e8",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m still not quite sure what an annotated choice is :slightly_smiling_face: ",
        "createdAt" : "2020-05-11T08:36:25Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 122,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)\n+    genModule' :: MonadDelta m => Delta -> (PackageRef, Module) -> m Delta\n+    genModule' deli (paci, modi) = introDelta deli (genModule paci modi)\n+                                   >>= return . (concatDelta deli)\n+\n+-- TODO: Type synonyms and data types are ignored for now.\n+genModule :: MonadDelta m => PackageRef -> Module -> m Delta\n+genModule pac mod = do\n+  del0 <- ask\n+  del1 <- foldM genValue' del0 (NM.toList $ moduleValues mod)\n+  del2 <- foldM genTemplate' del1 (NM.toList $ moduleTemplates mod)\n+  return $ concatDelta del1 del2\n+  where\n+    genValue' :: MonadDelta m => Delta -> DefValue -> m Delta\n+    genValue' deli vali = introDelta deli (genValue pac (moduleName mod) vali)\n+                          >>= return . (concatDelta deli)\n+    genTemplate' :: MonadDelta m => Delta -> Template -> m Delta\n+    genTemplate' deli temi = introDelta deli (genTemplate temi)\n+                          >>= return . (concatDelta deli)\n+\n+genValue :: MonadDelta m => PackageRef -> ModuleName -> DefValue -> m Delta\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  return $ set devals (singleton qname (expOut ^. goExp, expOut ^. goUpd)) emptyDelta\n+\n+-- TODO: Handle annotated choices, by returning a set of annotations."
  },
  {
    "id" : "ee3d51b1-2891-466c-81cd-89672a829325",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "f29185f7-1f8a-4bbe-bd57-a43aa4ba120e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m perfectly happy with just calling `error` for now for anything that isn’t well-typed LF.",
        "createdAt" : "2020-04-07T20:35:21Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c7db970e-d2ce-4247-b716-49019c39aa0e",
        "parentId" : "f29185f7-1f8a-4bbe-bd57-a43aa4ba120e",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I usually use something ala `error \"IMPOSSIBLE: Ill-typed DAML-LF\"` in situations like this one.",
        "createdAt" : "2020-04-09T09:13:18Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "09805817-6f6c-4ceb-b2ee-e3d0a9aba5bc",
        "parentId" : "f29185f7-1f8a-4bbe-bd57-a43aa4ba120e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The impossible happened :open_mouth: ",
        "createdAt" : "2020-04-09T09:27:39Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)\n+    genModule' :: MonadDelta m => Delta -> (PackageRef, Module) -> m Delta\n+    genModule' deli (paci, modi) = introDelta deli (genModule paci modi)\n+                                   >>= return . (concatDelta deli)\n+\n+-- TODO: Type synonyms and data types are ignored for now.\n+genModule :: MonadDelta m => PackageRef -> Module -> m Delta\n+genModule pac mod = do\n+  del0 <- ask\n+  del1 <- foldM genValue' del0 (NM.toList $ moduleValues mod)\n+  del2 <- foldM genTemplate' del1 (NM.toList $ moduleTemplates mod)\n+  return $ concatDelta del1 del2\n+  where\n+    genValue' :: MonadDelta m => Delta -> DefValue -> m Delta\n+    genValue' deli vali = introDelta deli (genValue pac (moduleName mod) vali)\n+                          >>= return . (concatDelta deli)\n+    genTemplate' :: MonadDelta m => Delta -> Template -> m Delta\n+    genTemplate' deli temi = introDelta deli (genTemplate temi)\n+                          >>= return . (concatDelta deli)\n+\n+genValue :: MonadDelta m => PackageRef -> ModuleName -> DefValue -> m Delta\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  return $ set devals (singleton qname (expOut ^. goExp, expOut ^. goUpd)) emptyDelta\n+\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadDelta m => (Qualified TypeConName) -> TemplateChoice\n+          -> m GenOutput\n+genChoice tem cho = do\n+  expOut <- extVarDelta (fst $ chcArgBinder cho) $ genExpr (chcUpdate cho)\n+  let updSet = if chcConsuming cho\n+        -- TODO: Convert the `ExprVarName`s to `FieldName`s\n+        then over usArc ((:) (UpdArchive tem [])) (expOut ^. goUpd)\n+        else expOut ^. goUpd\n+  return $ set goUpd updSet\n+         $ over (goDel . devars) ((:) (fst $ chcArgBinder cho))\n+         expOut\n+\n+genTemplate :: MonadDelta m => Template -> m Delta\n+genTemplate = undefined -- TODO\n+\n+genExpr :: MonadDelta m => Expr -> m GenOutput\n+genExpr = \\case\n+  ETmApp fun arg  -> genForTmApp fun arg\n+  ETyApp expr typ -> genForTyApp expr typ\n+  EVar name       -> genForVar name\n+  EVal w          -> genForVal w\n+  EUpdate (UCreate tem arg)              -> genForCreate tem arg\n+  EUpdate (UExercise tem ch cid par arg) -> genForExercise tem ch cid par arg\n+  _ -> error \"Not implemented\"\n+\n+genForTmApp :: MonadDelta m => Expr -> Expr -> m GenOutput\n+genForTmApp fun arg = do\n+  funOut <- genExpr fun\n+  argOut <- genExpr arg\n+  case funOut ^. goExp of\n+    ETmLam bndr body -> do\n+      let updDelta = concatDelta (funOut ^. goDel) (argOut ^. goDel)\n+          subst    = singleExprSubst (fst bndr) (argOut ^. goExp)\n+          resExpr  = substituteTmTm subst body\n+      resOut <- introDelta updDelta $ genExpr resExpr\n+      return $ combineGO resOut\n+             $ combineGO funOut argOut\n+    fun'             -> return $ updateGOExpr (ETmApp fun' (argOut ^. goExp))\n+                               $ combineGO funOut argOut\n+\n+genForTyApp :: MonadDelta m => Expr -> Type -> m GenOutput\n+genForTyApp expr typ = do\n+  exprOut <- genExpr expr\n+  case exprOut ^. goExp of\n+    ETyLam bndr body -> do\n+      let subst   = singleTypeSubst (fst bndr) typ\n+          resExpr = substituteTyTm subst body\n+      resOut <- introDelta (exprOut ^. goDel) $ genExpr resExpr\n+      return $ combineGO resOut exprOut\n+    expr'            -> return $ updateGOExpr (ETyApp expr' typ) exprOut\n+\n+genForVar :: MonadDelta m => ExprVarName -> m GenOutput\n+genForVar name = lookupDExprVar name\n+                 >> return (GenOutput (EVar name) emptyUpdateSet emptyDelta)\n+\n+genForVal :: MonadDelta m => (Qualified ExprValName) -> m GenOutput\n+genForVal w = lookupDVal w\n+              >>= \\ (expr, upds) -> return (GenOutput expr upds emptyDelta)\n+\n+genForCreate :: MonadDelta m => (Qualified TypeConName) -> Expr -> m GenOutput\n+genForCreate tem arg = do\n+  argOut <- genExpr arg\n+  case argOut ^. goExp of\n+    argExpr@(ERecCon _ fs) -> return (GenOutput (EUpdate (UCreate tem argExpr))\n+                                      -- TODO: We could potentially filter here\n+                                      -- to only store the interesting fields?\n+                                      (set usCre [UpdCreate tem fs] emptyUpdateSet)\n+                                      (argOut ^. goDel))\n+    _                      -> throwError EEnumTypeWithParams\n+    -- TODO: This is a random error, as we do not have access to the expected"
  },
  {
    "id" : "416809d4-12ef-4840-a7ae-9553921a2a54",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "5f815ede-6613-46b9-883e-595388758647",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Isn't that just plain function application?\r\n```suggestion\r\n  = extendGOUpds (_goUpd genOut2)\r\n  $ extendGODelta (_goDel genOut2)\r\n    genOut1\r\n```",
        "createdAt" : "2020-04-08T08:06:06Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1"
  },
  {
    "id" : "44477050-3571-4257-8816-1e084cc8c440",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "b7f65583-c869-43f7-9a62-f3b63a260f5a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`act >>= return . f` is the same as `fmap f act` or `f <$> act`, depending on what you prefer.",
        "createdAt" : "2020-04-08T08:07:35Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)"
  },
  {
    "id" : "1b77388d-4af6-42d3-9d1a-8e4cbdf170bc",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "84da2d6c-bf86-4064-80a2-5a54ca385b27",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Please don't align the arrows in case expressions. This will lead to a lot of \"diff noise\" down the line.",
        "createdAt" : "2020-04-08T08:08:59Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)\n+    genModule' :: MonadDelta m => Delta -> (PackageRef, Module) -> m Delta\n+    genModule' deli (paci, modi) = introDelta deli (genModule paci modi)\n+                                   >>= return . (concatDelta deli)\n+\n+-- TODO: Type synonyms and data types are ignored for now.\n+genModule :: MonadDelta m => PackageRef -> Module -> m Delta\n+genModule pac mod = do\n+  del0 <- ask\n+  del1 <- foldM genValue' del0 (NM.toList $ moduleValues mod)\n+  del2 <- foldM genTemplate' del1 (NM.toList $ moduleTemplates mod)\n+  return $ concatDelta del1 del2\n+  where\n+    genValue' :: MonadDelta m => Delta -> DefValue -> m Delta\n+    genValue' deli vali = introDelta deli (genValue pac (moduleName mod) vali)\n+                          >>= return . (concatDelta deli)\n+    genTemplate' :: MonadDelta m => Delta -> Template -> m Delta\n+    genTemplate' deli temi = introDelta deli (genTemplate temi)\n+                          >>= return . (concatDelta deli)\n+\n+genValue :: MonadDelta m => PackageRef -> ModuleName -> DefValue -> m Delta\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  return $ set devals (singleton qname (expOut ^. goExp, expOut ^. goUpd)) emptyDelta\n+\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadDelta m => (Qualified TypeConName) -> TemplateChoice\n+          -> m GenOutput\n+genChoice tem cho = do\n+  expOut <- extVarDelta (fst $ chcArgBinder cho) $ genExpr (chcUpdate cho)\n+  let updSet = if chcConsuming cho\n+        -- TODO: Convert the `ExprVarName`s to `FieldName`s\n+        then over usArc ((:) (UpdArchive tem [])) (expOut ^. goUpd)\n+        else expOut ^. goUpd\n+  return $ set goUpd updSet\n+         $ over (goDel . devars) ((:) (fst $ chcArgBinder cho))\n+         expOut\n+\n+genTemplate :: MonadDelta m => Template -> m Delta\n+genTemplate = undefined -- TODO\n+\n+genExpr :: MonadDelta m => Expr -> m GenOutput\n+genExpr = \\case\n+  ETmApp fun arg  -> genForTmApp fun arg\n+  ETyApp expr typ -> genForTyApp expr typ\n+  EVar name       -> genForVar name\n+  EVal w          -> genForVal w"
  },
  {
    "id" : "b8fd0ed6-7311-4c85-84a1-d60de1adf46b",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "89f1dd0e-4497-4dde-aee8-36025188c7cb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n  return $ emptyDelta{_devals = singleton qname (_goExp expOut, _goUpd expOut)}\r\n```",
        "createdAt" : "2020-04-08T08:10:44Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,192 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (genOut2 ^. goUpd)\n+  $ extendGODelta (genOut2 ^. goDel)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+genPackages :: MonadDelta m => [(PackageId, (Package, Maybe PackageName))]\n+            -> m Delta\n+genPackages inp = ask >>= \\del0 -> foldM genPackage' del0 inp\n+  where\n+    -- TODO: These prime definitions are bit silly. Merge with the regular\n+    -- functions.\n+    -- TODO: This >>= return . concatDelta returns a lot. Figure out a way to\n+    -- abstract over it. Same for this returning foldM.\n+    genPackage' :: MonadDelta m => Delta\n+                -> (PackageId, (Package, Maybe PackageName)) -> m Delta\n+    genPackage' deli (idi, (paci, _)) =\n+      -- TODO: This is getting quite unreadable.\n+      foldM (\\deli' modi -> genModule' deli' (PRImport idi, modi))\n+            deli (NM.toList $ packageModules paci)\n+      >>= return . (concatDelta deli)\n+    genModule' :: MonadDelta m => Delta -> (PackageRef, Module) -> m Delta\n+    genModule' deli (paci, modi) = introDelta deli (genModule paci modi)\n+                                   >>= return . (concatDelta deli)\n+\n+-- TODO: Type synonyms and data types are ignored for now.\n+genModule :: MonadDelta m => PackageRef -> Module -> m Delta\n+genModule pac mod = do\n+  del0 <- ask\n+  del1 <- foldM genValue' del0 (NM.toList $ moduleValues mod)\n+  del2 <- foldM genTemplate' del1 (NM.toList $ moduleTemplates mod)\n+  return $ concatDelta del1 del2\n+  where\n+    genValue' :: MonadDelta m => Delta -> DefValue -> m Delta\n+    genValue' deli vali = introDelta deli (genValue pac (moduleName mod) vali)\n+                          >>= return . (concatDelta deli)\n+    genTemplate' :: MonadDelta m => Delta -> Template -> m Delta\n+    genTemplate' deli temi = introDelta deli (genTemplate temi)\n+                          >>= return . (concatDelta deli)\n+\n+genValue :: MonadDelta m => PackageRef -> ModuleName -> DefValue -> m Delta\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  return $ set devals (singleton qname (expOut ^. goExp, expOut ^. goUpd)) emptyDelta"
  },
  {
    "id" : "2b07b0a7-a8ff-42f0-a28e-1102cec70bd8",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "58d53580-63c7-4d1e-9c02-d8c718d010dc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What does the `Gen` prefix stand for? \"generate\" or \"generic\"? Can we strip it?",
        "createdAt" : "2020-04-09T08:13:16Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,182 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput"
  },
  {
    "id" : "06b244f9-4ed9-47ab-ab7f-8bf48267f44b",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "ec8f5b6e-1c50-4c10-817c-cc96ad7e76ee",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This haddock comment will only annotate the first argument, not the second one.",
        "createdAt" : "2020-04-09T08:14:07Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,182 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine."
  },
  {
    "id" : "b76e6e76-fbe1-4d5d-ab4a-ccc7e16e554b",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "bd5dc318-08d2-4471-9cf9-0c9651792bd5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If you write this in a more direct style, you can remove a fair bit of code below:\r\n```suggestion\r\n  = GenOutput\r\n      { _goExp = _goExp genOut1\r\n      , _goDel = _goDel genOut1 `concatUpdateSet` _goDel genOut2\r\n      , _goUpd = _goUpd genOut1 `concatUpdateSet` _goUpd genOut2\r\n      }\r\n```",
        "createdAt" : "2020-04-09T08:20:17Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,182 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (_goUpd genOut2)\n+  $ extendGODelta (_goDel genOut2)\n+    genOut1"
  },
  {
    "id" : "382d4773-c166-46b6-84aa-21e96af0c8d6",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "f2c037cf-6ad0-4e54-a97f-c85abf7e36d4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "In my experience, spelling out identifiers has proven beneficial most of the time, ie., `_goExpr`, `_goUpdate` and `_goDelta`. (`Expr` is such a common unambiguous abbreviation that it's ok, whereas `Del` could also abbreviate \"delete\".)",
        "createdAt" : "2020-04-09T08:22:33Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 28,
    "diffHunk" : "@@ -0,0 +1,182 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }"
  },
  {
    "id" : "5c79df2b-cf78-4115-867f-218a652d9129",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "a50746bf-da07-4f16-8532-c43045bd5859",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "My _suspicion_, fuelled by your comment on `setDelta`, is that you want something like this:\r\n```haskell\r\nintroDeltas :: MonadDelta m => (a -> m Delta) -> [a] -> m b -> m b\r\nintroDeltas _ [] act = act\r\nintroDeltas f (x:xs) act = do\r\n  delta <- f x\r\n  introDelta delta (introDeltas f xs act)\r\n```\r\nand then have functions like\r\n```haskell\r\nintroModule :: MonadDelta m => PackageRef -> Module -> m b -> m b\r\n```\r\nIs that correct?",
        "createdAt" : "2020-04-09T09:09:01Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,182 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , genChoice -- Added export to suppress the unused warning.\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Data.HashMap.Strict (singleton)\n+import Control.Monad.Reader\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data GenOutput = GenOutput\n+  { _goExp :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _goUpd :: UpdateSet\n+    -- ^ The updates, performed by this expression.\n+  , _goDel :: Delta\n+    -- ^ The context extension, made by this expression.\n+  }\n+\n+makeLenses ''GenOutput\n+\n+-- | Extend a generator output with the updates and the context extensions of a\n+-- second generator output. Note that the end result will contain the first\n+-- expression.\n+combineGO :: GenOutput -> GenOutput\n+          -- ^ The two generator outputs to combine.\n+          -> GenOutput\n+combineGO genOut1 genOut2\n+  = extendGOUpds (_goUpd genOut2)\n+  $ extendGODelta (_goDel genOut2)\n+    genOut1\n+\n+updateGOExpr :: Expr\n+             -- ^ The new output expression.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+updateGOExpr expr = set goExp expr\n+\n+extendGOUpds :: UpdateSet\n+             -- ^ The extension of the update set.\n+             -> GenOutput\n+             -- ^ The current generator output.\n+             -> GenOutput\n+extendGOUpds upds = over goUpd (concatUpdateSet upds)\n+\n+extendGODelta :: Delta\n+              -- ^ The additional context extension.\n+              -> GenOutput\n+              -- ^ The current generator output.\n+              -> GenOutput\n+extendGODelta delta = over goDel (concatDelta delta)\n+\n+-- | Builds up the Delta environment by recursively extending the environment\n+-- for each computation, and combining the output environments.\n+buildDelta :: MonadDelta m => Delta -> (a -> m Delta) -> [a] -> m Delta\n+buildDelta del op args = foldM step del args\n+  where\n+    step d x = concatDelta d <$> setDelta d (op x)"
  },
  {
    "id" : "48650e41-ba4a-4da2-bbe0-ff1d61734e99",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "04883758-e38f-450c-bfeb-61beb955d7e8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Somehow this whole GADT/DataKinds thing seems more complex than necessary. Did you start out with just using separate functions for this and it turned out to be more complicated for some reason? If not I think that’s at least worth trying out although not necessarily before merging (I’d like to lock something in sooner rather than later).",
        "createdAt" : "2020-05-11T08:35:14Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 100,
    "diffHunk" : "@@ -0,0 +1,406 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , Phase(..)\n+  ) where\n+\n+import Control.Monad.Error.Class (catchError, throwError)\n+import Data.Maybe (listToMaybe)\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+\n+-- | Data type denoting the output of the constraint generator.\n+data Output (ph :: Phase) = Output\n+  { _oExpr :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _oUpdate :: UpdateSet ph\n+    -- ^ The updates, performed by this expression.\n+  }\n+\n+-- | Construct an output with no updates.\n+emptyOut :: GenPhase ph\n+  => Expr\n+  -- ^ The evaluated expression.\n+  -> Output ph\n+emptyOut expr = Output expr emptyUpdateSet\n+\n+-- | Extend a generator output with the updates of the second generator output.\n+-- Note that the end result will contain only the first expression.\n+combineOut :: Output ph -> Output ph -> Output ph\n+combineOut out1 out2 = extendOutUpds (_oUpdate out2) out1\n+\n+-- | Update an output with a new evaluated expression.\n+updateOutExpr :: Expr\n+  -- ^ The new output expression.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+updateOutExpr expr out = out{_oExpr = expr}\n+\n+-- | Update an output with additional updates.\n+extendOutUpds :: UpdateSet ph\n+  -- ^ The extension of the update set.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+extendOutUpds upds out@Output{..} = out{_oUpdate = concatUpdateSet upds _oUpdate}\n+\n+-- | Update an output with an additional Archive update.\n+addArchiveUpd :: Qualified TypeConName\n+  -- ^ The template to be archived.\n+  -> [(FieldName, Expr)]\n+  -- ^ The fields to be archived, with their respective values.\n+  -> Output 'ChoiceGathering\n+  -- ^ The generator output to be updated.\n+  -> Output 'ChoiceGathering\n+addArchiveUpd temp fs (Output expr upds) =\n+  Output expr (addUpd upds $ UpdArchive temp fs)\n+\n+-- | Generate an environment for a given list of packages.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackages :: (GenPhase ph, MonadEnv m ph)\n+  => [(PackageId, (Package, Maybe PackageName))]\n+  -- ^ The list of packages, as produced by `readPackages`.\n+  -> m ()\n+genPackages inp = mapM_ genPackage inp\n+\n+-- | Generate an environment for a given package.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackage :: (GenPhase ph, MonadEnv m ph)\n+  => (PackageId, (Package, Maybe PackageName))\n+  -- ^ The package, as produced by `readPackages`.\n+  -> m ()\n+genPackage (id, (pac, _)) = mapM_ (genModule (PRImport id)) (NM.toList $ packageModules pac)\n+\n+-- | Generate an environment for a given module.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genModule :: (GenPhase ph, MonadEnv m ph)\n+  => PackageRef\n+  -- ^ A reference to the package in which this module is defined.\n+  -> Module\n+  -- ^ The module to analyse.\n+  -> m ()\n+genModule pac mod = getEnv >>= \\case\n+  EnvVG{} -> do"
  },
  {
    "id" : "8ed04f6d-b6d8-42f0-a094-d278f9d6bef8",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "a5869a55-05e7-4f13-9cec-c44e7f4a09b9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you write this as a record it’s much easier to understand what the arguments mean.",
        "createdAt" : "2020-05-11T08:41:58Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 176,
    "diffHunk" : "@@ -0,0 +1,406 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , Phase(..)\n+  ) where\n+\n+import Control.Monad.Error.Class (catchError, throwError)\n+import Data.Maybe (listToMaybe)\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+\n+-- | Data type denoting the output of the constraint generator.\n+data Output (ph :: Phase) = Output\n+  { _oExpr :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _oUpdate :: UpdateSet ph\n+    -- ^ The updates, performed by this expression.\n+  }\n+\n+-- | Construct an output with no updates.\n+emptyOut :: GenPhase ph\n+  => Expr\n+  -- ^ The evaluated expression.\n+  -> Output ph\n+emptyOut expr = Output expr emptyUpdateSet\n+\n+-- | Extend a generator output with the updates of the second generator output.\n+-- Note that the end result will contain only the first expression.\n+combineOut :: Output ph -> Output ph -> Output ph\n+combineOut out1 out2 = extendOutUpds (_oUpdate out2) out1\n+\n+-- | Update an output with a new evaluated expression.\n+updateOutExpr :: Expr\n+  -- ^ The new output expression.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+updateOutExpr expr out = out{_oExpr = expr}\n+\n+-- | Update an output with additional updates.\n+extendOutUpds :: UpdateSet ph\n+  -- ^ The extension of the update set.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+extendOutUpds upds out@Output{..} = out{_oUpdate = concatUpdateSet upds _oUpdate}\n+\n+-- | Update an output with an additional Archive update.\n+addArchiveUpd :: Qualified TypeConName\n+  -- ^ The template to be archived.\n+  -> [(FieldName, Expr)]\n+  -- ^ The fields to be archived, with their respective values.\n+  -> Output 'ChoiceGathering\n+  -- ^ The generator output to be updated.\n+  -> Output 'ChoiceGathering\n+addArchiveUpd temp fs (Output expr upds) =\n+  Output expr (addUpd upds $ UpdArchive temp fs)\n+\n+-- | Generate an environment for a given list of packages.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackages :: (GenPhase ph, MonadEnv m ph)\n+  => [(PackageId, (Package, Maybe PackageName))]\n+  -- ^ The list of packages, as produced by `readPackages`.\n+  -> m ()\n+genPackages inp = mapM_ genPackage inp\n+\n+-- | Generate an environment for a given package.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackage :: (GenPhase ph, MonadEnv m ph)\n+  => (PackageId, (Package, Maybe PackageName))\n+  -- ^ The package, as produced by `readPackages`.\n+  -> m ()\n+genPackage (id, (pac, _)) = mapM_ (genModule (PRImport id)) (NM.toList $ packageModules pac)\n+\n+-- | Generate an environment for a given module.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genModule :: (GenPhase ph, MonadEnv m ph)\n+  => PackageRef\n+  -- ^ A reference to the package in which this module is defined.\n+  -> Module\n+  -- ^ The module to analyse.\n+  -> m ()\n+genModule pac mod = getEnv >>= \\case\n+  EnvVG{} -> do\n+    extDatsEnv (NM.toHashMap (moduleDataTypes mod))\n+    mapM_ (genValue pac (moduleName mod)) (NM.toList $ moduleValues mod)\n+  EnvCG{} ->\n+    mapM_ (genTemplate pac (moduleName mod)) (NM.toList $ moduleTemplates mod)\n+  EnvS{} -> error \"Impossible: genModule can't be used in the solving phase\"\n+\n+-- | Analyse a value definition and add to the environment.\n+genValue :: (GenPhase ph, MonadEnv m ph)\n+  => PackageRef\n+  -- ^ A reference to the package in which this value is defined.\n+  -> ModuleName\n+  -- ^ The name of the module in which this value is defined.\n+  -> DefValue\n+  -- ^ The value to be analysed and added.\n+  -> m ()\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  extValEnv qname (_oExpr expOut) (_oUpdate expOut)\n+\n+-- | Analyse a choice definition and add to the environment.\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadEnv m 'ChoiceGathering\n+  => Qualified TypeConName\n+  -- ^ The template in which this choice is defined.\n+  -> (ExprVarName,ExprVarName)\n+  -- ^ The original and renamed variable `this` referencing the contract on\n+  -- which this choice is called.\n+  -> [FieldName]\n+  -- ^ The list of fields available in the template.\n+  -> TemplateChoice\n+  -- ^ The choice to be analysed and added.\n+  -> m ()\n+genChoice tem (this',this) temFs TemplateChoice{..} = do\n+  let self' = chcSelfBinder\n+      arg' = fst chcArgBinder\n+  self <- genRenamedVar self'\n+  arg <- genRenamedVar arg'\n+  extVarEnv self\n+  extVarEnv arg\n+  argFs <- recTypFields (snd chcArgBinder)\n+  extRecEnv arg argFs\n+  expOut <- genExpr\n+    $ substituteTm (createExprSubst [(self',EVar self),(this',EVar this),(arg',EVar arg)]) chcUpdate\n+  let out = if chcConsuming\n+        then addArchiveUpd tem fields expOut\n+        else expOut\n+  extChEnv tem chcName self this arg (_oUpdate out)\n+  where\n+    fields = map (\\f -> (f, ERecProj (TypeConApp tem []) f (EVar this))) temFs\n+\n+-- | Analyse a template definition and add all choices to the environment.\n+genTemplate :: MonadEnv m 'ChoiceGathering\n+  => PackageRef\n+  -- ^ A reference to the package in which this template is defined.\n+  -> ModuleName\n+  -- ^ The module in which this template is defined.\n+  -> Template\n+  -- ^ The template to be analysed and added.\n+  -> m ()\n+-- TODO: Take preconditions into account?\n+genTemplate pac mod Template{..} = do\n+  let name = Qualified pac mod tplTypeCon\n+  fields <- recTypConFields tplTypeCon\n+  let fs = map fst fields\n+  this <- genRenamedVar tplParam\n+  extVarEnv this\n+  extRecEnv this fs\n+  extRecEnvLvl1 fields\n+  mapM_ (genChoice name (tplParam,this) fs) (archive : NM.toList tplChoices)\n+  where\n+    archive :: TemplateChoice\n+    archive = TemplateChoice Nothing (ChoiceName \"Archive\") True"
  },
  {
    "id" : "7fc88505-113e-4406-b487-d7db4922d32e",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "aa7be3ae-6eab-4574-820b-dd12022c36dd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "As far as I can tell my previous comment still stands. If I do something like\r\n```\r\nnonconuming choice C : ()\r\n  controller p\r\n  do let _ = archive self\r\n       pure ()\r\n```\r\nit looks like you will incorrectly track this is an `archive`.",
        "createdAt" : "2020-05-11T08:44:19Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,406 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , Phase(..)\n+  ) where\n+\n+import Control.Monad.Error.Class (catchError, throwError)\n+import Data.Maybe (listToMaybe)\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+\n+-- | Data type denoting the output of the constraint generator.\n+data Output (ph :: Phase) = Output\n+  { _oExpr :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _oUpdate :: UpdateSet ph\n+    -- ^ The updates, performed by this expression.\n+  }\n+\n+-- | Construct an output with no updates.\n+emptyOut :: GenPhase ph\n+  => Expr\n+  -- ^ The evaluated expression.\n+  -> Output ph\n+emptyOut expr = Output expr emptyUpdateSet\n+\n+-- | Extend a generator output with the updates of the second generator output.\n+-- Note that the end result will contain only the first expression.\n+combineOut :: Output ph -> Output ph -> Output ph\n+combineOut out1 out2 = extendOutUpds (_oUpdate out2) out1\n+\n+-- | Update an output with a new evaluated expression.\n+updateOutExpr :: Expr\n+  -- ^ The new output expression.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+updateOutExpr expr out = out{_oExpr = expr}\n+\n+-- | Update an output with additional updates.\n+extendOutUpds :: UpdateSet ph\n+  -- ^ The extension of the update set.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+extendOutUpds upds out@Output{..} = out{_oUpdate = concatUpdateSet upds _oUpdate}\n+\n+-- | Update an output with an additional Archive update.\n+addArchiveUpd :: Qualified TypeConName\n+  -- ^ The template to be archived.\n+  -> [(FieldName, Expr)]\n+  -- ^ The fields to be archived, with their respective values.\n+  -> Output 'ChoiceGathering\n+  -- ^ The generator output to be updated.\n+  -> Output 'ChoiceGathering\n+addArchiveUpd temp fs (Output expr upds) =\n+  Output expr (addUpd upds $ UpdArchive temp fs)\n+\n+-- | Generate an environment for a given list of packages.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackages :: (GenPhase ph, MonadEnv m ph)\n+  => [(PackageId, (Package, Maybe PackageName))]\n+  -- ^ The list of packages, as produced by `readPackages`.\n+  -> m ()\n+genPackages inp = mapM_ genPackage inp\n+\n+-- | Generate an environment for a given package.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackage :: (GenPhase ph, MonadEnv m ph)\n+  => (PackageId, (Package, Maybe PackageName))\n+  -- ^ The package, as produced by `readPackages`.\n+  -> m ()\n+genPackage (id, (pac, _)) = mapM_ (genModule (PRImport id)) (NM.toList $ packageModules pac)\n+\n+-- | Generate an environment for a given module.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genModule :: (GenPhase ph, MonadEnv m ph)\n+  => PackageRef\n+  -- ^ A reference to the package in which this module is defined.\n+  -> Module\n+  -- ^ The module to analyse.\n+  -> m ()\n+genModule pac mod = getEnv >>= \\case\n+  EnvVG{} -> do\n+    extDatsEnv (NM.toHashMap (moduleDataTypes mod))\n+    mapM_ (genValue pac (moduleName mod)) (NM.toList $ moduleValues mod)\n+  EnvCG{} ->\n+    mapM_ (genTemplate pac (moduleName mod)) (NM.toList $ moduleTemplates mod)\n+  EnvS{} -> error \"Impossible: genModule can't be used in the solving phase\"\n+\n+-- | Analyse a value definition and add to the environment.\n+genValue :: (GenPhase ph, MonadEnv m ph)\n+  => PackageRef\n+  -- ^ A reference to the package in which this value is defined.\n+  -> ModuleName\n+  -- ^ The name of the module in which this value is defined.\n+  -> DefValue\n+  -- ^ The value to be analysed and added.\n+  -> m ()\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  extValEnv qname (_oExpr expOut) (_oUpdate expOut)\n+\n+-- | Analyse a choice definition and add to the environment.\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadEnv m 'ChoiceGathering\n+  => Qualified TypeConName\n+  -- ^ The template in which this choice is defined.\n+  -> (ExprVarName,ExprVarName)\n+  -- ^ The original and renamed variable `this` referencing the contract on\n+  -- which this choice is called.\n+  -> [FieldName]\n+  -- ^ The list of fields available in the template.\n+  -> TemplateChoice\n+  -- ^ The choice to be analysed and added.\n+  -> m ()\n+genChoice tem (this',this) temFs TemplateChoice{..} = do\n+  let self' = chcSelfBinder\n+      arg' = fst chcArgBinder\n+  self <- genRenamedVar self'\n+  arg <- genRenamedVar arg'\n+  extVarEnv self\n+  extVarEnv arg\n+  argFs <- recTypFields (snd chcArgBinder)\n+  extRecEnv arg argFs\n+  expOut <- genExpr\n+    $ substituteTm (createExprSubst [(self',EVar self),(this',EVar this),(arg',EVar arg)]) chcUpdate\n+  let out = if chcConsuming\n+        then addArchiveUpd tem fields expOut\n+        else expOut\n+  extChEnv tem chcName self this arg (_oUpdate out)\n+  where\n+    fields = map (\\f -> (f, ERecProj (TypeConApp tem []) f (EVar this))) temFs\n+\n+-- | Analyse a template definition and add all choices to the environment.\n+genTemplate :: MonadEnv m 'ChoiceGathering\n+  => PackageRef\n+  -- ^ A reference to the package in which this template is defined.\n+  -> ModuleName\n+  -- ^ The module in which this template is defined.\n+  -> Template\n+  -- ^ The template to be analysed and added.\n+  -> m ()\n+-- TODO: Take preconditions into account?\n+genTemplate pac mod Template{..} = do\n+  let name = Qualified pac mod tplTypeCon\n+  fields <- recTypConFields tplTypeCon\n+  let fs = map fst fields\n+  this <- genRenamedVar tplParam\n+  extVarEnv this\n+  extRecEnv this fs\n+  extRecEnvLvl1 fields\n+  mapM_ (genChoice name (tplParam,this) fs) (archive : NM.toList tplChoices)\n+  where\n+    archive :: TemplateChoice\n+    archive = TemplateChoice Nothing (ChoiceName \"Archive\") True\n+      (ENil (TBuiltin BTParty)) (ExprVarName \"self\")\n+      (ExprVarName \"arg\", TStruct []) (TBuiltin BTUnit)\n+      (EUpdate $ UPure (TBuiltin BTUnit) (EBuiltin BEUnit))\n+\n+-- | Analyse an expression, and produce an Output storing its (partial)\n+-- evaluation result and the set of performed updates.\n+genExpr :: (GenPhase ph, MonadEnv m ph)\n+  => Expr\n+  -- ^ The expression to be analysed.\n+  -> m (Output ph)\n+genExpr = \\case\n+  ETmApp fun arg -> genForTmApp fun arg\n+  ETyApp expr typ -> genForTyApp expr typ\n+  ELet bind body -> genForLet bind body\n+  EVar name -> genForVar name\n+  EVal w -> genForVal w\n+  ERecProj tc f e -> genForRecProj tc f e\n+  EStructProj f e -> genForStructProj f e\n+  ELocation _ expr -> genExpr expr\n+  EUpdate (UCreate tem arg) -> genForCreate tem arg"
  },
  {
    "id" : "b0b24571-5ab4-4be0-aee6-49a5f76523ec",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "888c2b70-404c-4bc7-8401-eae6c0b8d240",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "SMT does have ADTs so we could in principle use those but you can also encode pattern matches without using them.",
        "createdAt" : "2020-05-11T08:52:10Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 355,
    "diffHunk" : "@@ -0,0 +1,406 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+\n+-- | Constraint generator for DAML LF static verification\n+module DA.Daml.LF.Verify.Generate\n+  ( genPackages\n+  , Phase(..)\n+  ) where\n+\n+import Control.Monad.Error.Class (catchError, throwError)\n+import Data.Maybe (listToMaybe)\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Context\n+import DA.Daml.LF.Verify.Subst\n+\n+-- | Data type denoting the output of the constraint generator.\n+data Output (ph :: Phase) = Output\n+  { _oExpr :: Expr\n+    -- ^ The expression, evaluated as far as possible.\n+  , _oUpdate :: UpdateSet ph\n+    -- ^ The updates, performed by this expression.\n+  }\n+\n+-- | Construct an output with no updates.\n+emptyOut :: GenPhase ph\n+  => Expr\n+  -- ^ The evaluated expression.\n+  -> Output ph\n+emptyOut expr = Output expr emptyUpdateSet\n+\n+-- | Extend a generator output with the updates of the second generator output.\n+-- Note that the end result will contain only the first expression.\n+combineOut :: Output ph -> Output ph -> Output ph\n+combineOut out1 out2 = extendOutUpds (_oUpdate out2) out1\n+\n+-- | Update an output with a new evaluated expression.\n+updateOutExpr :: Expr\n+  -- ^ The new output expression.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+updateOutExpr expr out = out{_oExpr = expr}\n+\n+-- | Update an output with additional updates.\n+extendOutUpds :: UpdateSet ph\n+  -- ^ The extension of the update set.\n+  -> Output ph\n+  -- ^ The generator output to be updated.\n+  -> Output ph\n+extendOutUpds upds out@Output{..} = out{_oUpdate = concatUpdateSet upds _oUpdate}\n+\n+-- | Update an output with an additional Archive update.\n+addArchiveUpd :: Qualified TypeConName\n+  -- ^ The template to be archived.\n+  -> [(FieldName, Expr)]\n+  -- ^ The fields to be archived, with their respective values.\n+  -> Output 'ChoiceGathering\n+  -- ^ The generator output to be updated.\n+  -> Output 'ChoiceGathering\n+addArchiveUpd temp fs (Output expr upds) =\n+  Output expr (addUpd upds $ UpdArchive temp fs)\n+\n+-- | Generate an environment for a given list of packages.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackages :: (GenPhase ph, MonadEnv m ph)\n+  => [(PackageId, (Package, Maybe PackageName))]\n+  -- ^ The list of packages, as produced by `readPackages`.\n+  -> m ()\n+genPackages inp = mapM_ genPackage inp\n+\n+-- | Generate an environment for a given package.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genPackage :: (GenPhase ph, MonadEnv m ph)\n+  => (PackageId, (Package, Maybe PackageName))\n+  -- ^ The package, as produced by `readPackages`.\n+  -> m ()\n+genPackage (id, (pac, _)) = mapM_ (genModule (PRImport id)) (NM.toList $ packageModules pac)\n+\n+-- | Generate an environment for a given module.\n+-- Depending on the generator phase, this either adds all value and data type\n+-- definitions to the environment, or all template definitions with their\n+-- respective choices.\n+genModule :: (GenPhase ph, MonadEnv m ph)\n+  => PackageRef\n+  -- ^ A reference to the package in which this module is defined.\n+  -> Module\n+  -- ^ The module to analyse.\n+  -> m ()\n+genModule pac mod = getEnv >>= \\case\n+  EnvVG{} -> do\n+    extDatsEnv (NM.toHashMap (moduleDataTypes mod))\n+    mapM_ (genValue pac (moduleName mod)) (NM.toList $ moduleValues mod)\n+  EnvCG{} ->\n+    mapM_ (genTemplate pac (moduleName mod)) (NM.toList $ moduleTemplates mod)\n+  EnvS{} -> error \"Impossible: genModule can't be used in the solving phase\"\n+\n+-- | Analyse a value definition and add to the environment.\n+genValue :: (GenPhase ph, MonadEnv m ph)\n+  => PackageRef\n+  -- ^ A reference to the package in which this value is defined.\n+  -> ModuleName\n+  -- ^ The name of the module in which this value is defined.\n+  -> DefValue\n+  -- ^ The value to be analysed and added.\n+  -> m ()\n+genValue pac mod val = do\n+  expOut <- genExpr (dvalBody val)\n+  let qname = Qualified pac mod (fst $ dvalBinder val)\n+  extValEnv qname (_oExpr expOut) (_oUpdate expOut)\n+\n+-- | Analyse a choice definition and add to the environment.\n+-- TODO: Handle annotated choices, by returning a set of annotations.\n+genChoice :: MonadEnv m 'ChoiceGathering\n+  => Qualified TypeConName\n+  -- ^ The template in which this choice is defined.\n+  -> (ExprVarName,ExprVarName)\n+  -- ^ The original and renamed variable `this` referencing the contract on\n+  -- which this choice is called.\n+  -> [FieldName]\n+  -- ^ The list of fields available in the template.\n+  -> TemplateChoice\n+  -- ^ The choice to be analysed and added.\n+  -> m ()\n+genChoice tem (this',this) temFs TemplateChoice{..} = do\n+  let self' = chcSelfBinder\n+      arg' = fst chcArgBinder\n+  self <- genRenamedVar self'\n+  arg <- genRenamedVar arg'\n+  extVarEnv self\n+  extVarEnv arg\n+  argFs <- recTypFields (snd chcArgBinder)\n+  extRecEnv arg argFs\n+  expOut <- genExpr\n+    $ substituteTm (createExprSubst [(self',EVar self),(this',EVar this),(arg',EVar arg)]) chcUpdate\n+  let out = if chcConsuming\n+        then addArchiveUpd tem fields expOut\n+        else expOut\n+  extChEnv tem chcName self this arg (_oUpdate out)\n+  where\n+    fields = map (\\f -> (f, ERecProj (TypeConApp tem []) f (EVar this))) temFs\n+\n+-- | Analyse a template definition and add all choices to the environment.\n+genTemplate :: MonadEnv m 'ChoiceGathering\n+  => PackageRef\n+  -- ^ A reference to the package in which this template is defined.\n+  -> ModuleName\n+  -- ^ The module in which this template is defined.\n+  -> Template\n+  -- ^ The template to be analysed and added.\n+  -> m ()\n+-- TODO: Take preconditions into account?\n+genTemplate pac mod Template{..} = do\n+  let name = Qualified pac mod tplTypeCon\n+  fields <- recTypConFields tplTypeCon\n+  let fs = map fst fields\n+  this <- genRenamedVar tplParam\n+  extVarEnv this\n+  extRecEnv this fs\n+  extRecEnvLvl1 fields\n+  mapM_ (genChoice name (tplParam,this) fs) (archive : NM.toList tplChoices)\n+  where\n+    archive :: TemplateChoice\n+    archive = TemplateChoice Nothing (ChoiceName \"Archive\") True\n+      (ENil (TBuiltin BTParty)) (ExprVarName \"self\")\n+      (ExprVarName \"arg\", TStruct []) (TBuiltin BTUnit)\n+      (EUpdate $ UPure (TBuiltin BTUnit) (EBuiltin BEUnit))\n+\n+-- | Analyse an expression, and produce an Output storing its (partial)\n+-- evaluation result and the set of performed updates.\n+genExpr :: (GenPhase ph, MonadEnv m ph)\n+  => Expr\n+  -- ^ The expression to be analysed.\n+  -> m (Output ph)\n+genExpr = \\case\n+  ETmApp fun arg -> genForTmApp fun arg\n+  ETyApp expr typ -> genForTyApp expr typ\n+  ELet bind body -> genForLet bind body\n+  EVar name -> genForVar name\n+  EVal w -> genForVal w\n+  ERecProj tc f e -> genForRecProj tc f e\n+  EStructProj f e -> genForStructProj f e\n+  ELocation _ expr -> genExpr expr\n+  EUpdate (UCreate tem arg) -> genForCreate tem arg\n+  EUpdate (UExercise tem ch cid par arg) -> genForExercise tem ch cid par arg\n+  EUpdate (UBind bind expr) -> genForBind bind expr\n+  EUpdate (UPure _ expr) -> genExpr expr\n+  ECase e cs -> genForCase e cs\n+  -- TODO: Extend additional cases\n+  e -> return $ emptyOut e\n+\n+-- | Analyse a term application expression.\n+genForTmApp :: (GenPhase ph, MonadEnv m ph)\n+  => Expr\n+  -- ^ The function expression.\n+  -> Expr\n+  -- ^ The argument expression.\n+  -> m (Output ph)\n+genForTmApp fun arg = do\n+  funOut <- genExpr fun\n+  arout <- genExpr arg\n+  case _oExpr funOut of\n+    -- TODO: Should we rename here?\n+    ETmLam bndr body -> do\n+      let subst = singleExprSubst (fst bndr) (_oExpr arout)\n+          resExpr = substituteTm subst body\n+      resOut <- genExpr resExpr\n+      return $ combineOut resOut\n+        $ combineOut funOut arout\n+    fun' -> return $ updateOutExpr (ETmApp fun' (_oExpr arout))\n+      $ combineOut funOut arout\n+\n+-- | Analyse a type application expression.\n+genForTyApp :: (GenPhase ph, MonadEnv m ph)\n+  => Expr\n+  -- ^ The function expression.\n+  -> Type\n+  -- ^ The argument type.\n+  -> m (Output ph)\n+genForTyApp expr typ = do\n+  exprOut <- genExpr expr\n+  case _oExpr exprOut of\n+    ETyLam bndr body -> do\n+      let subst = singleTypeSubst (fst bndr) typ\n+          resExpr = substituteTy subst body\n+      resOut <- genExpr resExpr\n+      return $ combineOut resOut exprOut\n+    expr' -> return $ updateOutExpr (ETyApp expr' typ) exprOut\n+\n+-- | Analyse a let binding expression.\n+genForLet :: (GenPhase ph, MonadEnv m ph)\n+  => Binding\n+  -- ^ The binding to be bound.\n+  -> Expr\n+  -- ^ The expression in which the binding should be available.\n+  -> m (Output ph)\n+genForLet bind body = do\n+  bindOut <- genExpr (bindingBound bind)\n+  let subst = singleExprSubst (fst $ bindingBinder bind) (_oExpr bindOut)\n+      resExpr = substituteTm subst body\n+  resOut <- genExpr resExpr\n+  return $ combineOut resOut bindOut\n+\n+-- | Analyse an expression variable.\n+genForVar :: (GenPhase ph, MonadEnv m ph)\n+  => ExprVarName\n+  -- ^ The expression variable to be analysed.\n+  -> m (Output ph)\n+genForVar name = lookupVar name >> return (emptyOut (EVar name))\n+\n+-- | Analyse a value reference.\n+genForVal :: (GenPhase ph, MonadEnv m ph)\n+  => Qualified ExprValName\n+  -- ^ The value reference to be analysed.\n+  -> m (Output ph)\n+genForVal w = getEnv >>= \\case\n+  EnvVG{} -> return $ Output (EVal w) (emptyUpdateSet{_usvgValue = [Determined w]})\n+  EnvCG{} -> lookupVal w >>= \\ (expr, upds) -> return (Output expr upds)\n+  EnvS{} -> error \"Impossible: genForVal can't be used in the solving phase\"\n+\n+-- | Analyse a record projection expression.\n+genForRecProj :: (GenPhase ph, MonadEnv m ph)\n+  => TypeConApp\n+  -- ^ The type constructor of the record which is projected.\n+  -> FieldName\n+  -- ^ The field which is projected.\n+  -> Expr\n+  -- ^ The record expression which is projected.\n+  -> m (Output ph)\n+genForRecProj tc f body = do\n+  bodyOut <- genExpr body\n+  case _oExpr bodyOut of\n+    -- TODO: I think we can reduce duplication a bit more here\n+    EVar x -> do\n+      skol <- lookupRec x f\n+      if skol\n+        then return $ updateOutExpr (ERecProj tc f (EVar x)) bodyOut\n+        else error (\"Impossible: expected skolem record: \" ++ show x ++ \".\" ++ show f)\n+    expr -> do\n+      fs <- recExpFields expr\n+      case lookup f fs of\n+        Just expr -> genExpr expr\n+        Nothing -> throwError $ UnknownRecField f\n+\n+-- | Analyse a struct projection expression.\n+genForStructProj :: (GenPhase ph, MonadEnv m ph)\n+  => FieldName\n+  -- ^ The field which is projected.\n+  -> Expr\n+  -- ^ The record expression which is projected.\n+  -> m (Output ph)\n+genForStructProj f body = do\n+  bodyOut <- genExpr body\n+  case _oExpr bodyOut of\n+    -- TODO: I think we can reduce duplication a bit more here\n+    EVar x -> do\n+      skol <- lookupRec x f\n+      if skol\n+        then return $ updateOutExpr (EStructProj f (EVar x)) bodyOut\n+        else error (\"Impossible: expected skolem record: \" ++ show x ++ \".\" ++ show f)\n+    expr -> do\n+      fs <- recExpFields expr\n+      case lookup f fs of\n+        Just expr -> genExpr expr\n+        Nothing -> throwError $ UnknownRecField f\n+\n+-- | Analyse a case expression.\n+-- TODO: Atm only boolean cases are supported\n+genForCase :: (GenPhase ph, MonadEnv m ph)"
  }
]