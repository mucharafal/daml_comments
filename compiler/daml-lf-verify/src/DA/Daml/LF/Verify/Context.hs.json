[
  {
    "id" : "4cd058e7-5bea-4a98-be66-5bdd926c946e",
    "prId" : 6565,
    "comments" : [
      {
        "id" : "4fe57d67-c031-4e28-9487-7fa697c6c6b0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is going towards a direction where a typeclass might come in handy but given that this is internal to this module it didn’t seem worth it.",
        "createdAt" : "2020-07-01T19:17:41Z",
        "updatedAt" : "2020-07-01T19:17:42Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "46e389f7-ae1a-4e16-b26a-6b47ab17a96e",
        "parentId" : "4fe57d67-c031-4e28-9487-7fa697c6c6b0",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think this combinator style is perfectly fine.",
        "createdAt" : "2020-07-02T05:53:09Z",
        "updatedAt" : "2020-07-02T05:53:43Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "74a01b28d39d5be59fc2b394455104b7c0f7207e",
    "line" : 105,
    "diffHunk" : "@@ -915,35 +916,35 @@ recExpFields (EStructProj f e) = do\n     Nothing -> return Nothing\n recExpFields _ = return Nothing\n \n-instance SubstTm BoolExpr where\n-  substituteTm s (BExpr e) = BExpr (substituteTm s e)\n-  substituteTm s (BAnd e1 e2) = BAnd (substituteTm s e1) (substituteTm s e2)\n-  substituteTm s (BNot e) = BNot (substituteTm s e)\n-  substituteTm s (BEq e1 e2) = BEq (substituteTm s e1) (substituteTm s e2)\n-  substituteTm s (BGt e1 e2) = BGt (substituteTm s e1) (substituteTm s e2)\n-  substituteTm s (BGtE e1 e2) = BGtE (substituteTm s e1) (substituteTm s e2)\n-  substituteTm s (BLt e1 e2) = BLt (substituteTm s e1) (substituteTm s e2)\n-  substituteTm s (BLtE e1 e2) = BLtE (substituteTm s e1) (substituteTm s e2)\n-\n-instance SubstTm a => SubstTm (Cond a) where\n-  substituteTm s (Determined x) = Determined $ substituteTm s x\n-  substituteTm s (Conditional e x y) =\n-    Conditional (substituteTm s e) (map (substituteTm s) x) (map (substituteTm s) y)\n-\n-instance SubstTm a => SubstTm (Rec a) where\n-  substituteTm s = \\case\n-    Simple x -> Simple (substituteTm s x)\n-    Rec xs -> Rec (map (substituteTm s) xs)\n-    MutRec xs -> MutRec (map (second (substituteTm s)) xs)\n-\n-instance IsPhase ph => SubstTm (Upd ph) where\n-  substituteTm s = mapBaseUpd (baseUpd . substituteTm s)\n-\n-instance SubstTm BaseUpd where\n-  substituteTm s UpdCreate{..} = UpdCreate _creTemp\n-    (map (second (substituteTm s)) _creField)\n-  substituteTm s UpdArchive{..} = UpdArchive _arcTemp\n-    (map (second (substituteTm s)) _arcField)\n+applySubstInBoolExpr :: Subst -> BoolExpr -> BoolExpr\n+applySubstInBoolExpr subst = \\case\n+    BExpr e -> BExpr (applySubstInExpr subst e)\n+    BAnd e1 e2 -> BAnd (applySubstInBoolExpr subst e1) (applySubstInBoolExpr subst e2)\n+    BNot e -> BNot (applySubstInBoolExpr subst e)\n+    BEq e1 e2 -> BEq (applySubstInExpr subst e1) (applySubstInExpr subst e2)\n+    BGt e1 e2 -> BGt (applySubstInExpr subst e1) (applySubstInExpr subst e2)\n+    BGtE e1 e2 -> BGtE (applySubstInExpr subst e1) (applySubstInExpr subst e2)\n+    BLt e1 e2 -> BLt (applySubstInExpr subst e1) (applySubstInExpr subst e2)\n+    BLtE e1 e2 -> BLtE (applySubstInExpr subst e1) (applySubstInExpr subst e2)\n+\n+applySubstInCond :: (Subst -> a -> a) -> Subst -> Cond a -> Cond a"
  },
  {
    "id" : "0d45e960-a2cd-45b3-a5fe-b195fa15cf63",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "b70ecdb4-1a46-4610-8503-99f3355f6556",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why is this safe? I.e., what guarantees that our call site never hits this? Would be great to document this in a comment.",
        "createdAt" : "2020-06-29T08:43:56Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -75,18 +75,38 @@ data BoolExpr\n   -- ^ And operator.\n   | BNot BoolExpr\n   -- ^ Not operator.\n-  deriving Show\n+  | BEq Expr Expr\n+  -- ^ Equality operator.\n+  | BGt Expr Expr\n+  -- ^ Greater than operator.\n+  | BGtE Expr Expr\n+  -- ^ Greater than or equal operator.\n+  | BLt Expr Expr\n+  -- ^ Less than operator.\n+  | BLtE Expr Expr\n+  -- ^ Less than or equal operator.\n+  deriving (Eq, Show)\n+\n+-- | Convert an expression constraint into boolean expressions.\n+toBoolExpr :: Expr -> [BoolExpr]\n+toBoolExpr (EBuiltin (BEBool True)) = []\n+toBoolExpr (ETmApp (ETmApp op e1) e2) = case op of\n+  (EBuiltin (BEEqual _)) -> [BEq e1 e2]\n+  (ETyApp (EBuiltin BEGreaterNumeric) _) -> [BGt e1 e2]\n+  (ETyApp (EBuiltin BEGreaterEqNumeric) _) -> [BGtE e1 e2]\n+  (ETyApp (EBuiltin BELessNumeric) _) -> [BLt e1 e2]\n+  (ETyApp (EBuiltin BELessEqNumeric) _) -> [BLtE e1 e2]\n+  _ -> trace (\"Unmatched Expr to BoolExpr Operator: \" ++ show op) []\n+toBoolExpr exp = trace (\"Unmatched Expr to BoolExpr: \" ++ show exp) []"
  },
  {
    "id" : "0e89df3b-3508-4d43-915f-0d0f1c8fff37",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "a1cec887-aff7-4dcb-9a73-54687fcf625e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "In what way do we rely on these simplifications? SMT solvers almost certainly do a better job at this so presumably this is not just to simplify the constraints that end up passed to the SMT solver and our own code requires this somewhere? If we perform fewer simplications what breaks?",
        "createdAt" : "2020-06-29T08:48:11Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6f2d0b2f-9c34-459d-9ba2-e532c70dbed6",
        "parentId" : "a1cec887-aff7-4dcb-9a73-54687fcf625e",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "Nothing would break if we stopped performing these simplifications. The only reason why we have them, is to make the output look less daunting to the user.",
        "createdAt" : "2020-06-29T17:31:51Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d99b3002-13a7-400d-be60-6e80f911ef6a",
        "parentId" : "a1cec887-aff7-4dcb-9a73-54687fcf625e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thanks! Would be great to add a comment for this.",
        "createdAt" : "2020-06-29T17:32:55Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 133,
    "diffHunk" : "@@ -98,52 +118,91 @@ createCond :: BoolExpr\n   -> Cond a\n createCond cond x y = Conditional cond [Determined x] [Determined y]\n \n--- | Shift the conditional inside the update set.\n-introCond :: Cond (UpdateSet ph) -> UpdateSet ph\n+extCond :: Eq a => BoolExpr -> Cond a -> [Cond a]\n+extCond bexp cond =\n+  let cond' = case cond of\n+        (Determined x) -> Conditional bexp [Determined x] []\n+        (Conditional bexp' xs ys) -> Conditional (bexp `BAnd` bexp') xs ys\n+  in simplifyCond cond'\n+\n+-- | Perform common simplifications on Conditionals."
  },
  {
    "id" : "00884d70-48b2-4f40-90e6-48cc5d5c8359",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "fe0479e2-f662-4ca5-be5d-39842937bdbf",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a difference between `Simple a` and `Rec [a]`?",
        "createdAt" : "2020-06-29T08:49:11Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "97a27da8-0f59-46ba-8d19-4ec4f69e90c2",
        "parentId" : "fe0479e2-f662-4ca5-be5d-39842937bdbf",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "Yes! This distinction is important while solving. The `Simple a` values are part of the main flow through the choice definition, while every `Rec [a]` value corresponds to a single recursion cycle. This means that while every `Simple a` value is solved simultaneously, every `Rec [a]` value has to be solved separately, and all of them have to preserve the field.",
        "createdAt" : "2020-06-29T17:35:01Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 209,
    "diffHunk" : "@@ -98,52 +118,91 @@ createCond :: BoolExpr\n   -> Cond a\n createCond cond x y = Conditional cond [Determined x] [Determined y]\n \n--- | Shift the conditional inside the update set.\n-introCond :: Cond (UpdateSet ph) -> UpdateSet ph\n+extCond :: Eq a => BoolExpr -> Cond a -> [Cond a]\n+extCond bexp cond =\n+  let cond' = case cond of\n+        (Determined x) -> Conditional bexp [Determined x] []\n+        (Conditional bexp' xs ys) -> Conditional (bexp `BAnd` bexp') xs ys\n+  in simplifyCond cond'\n+\n+-- | Perform common simplifications on Conditionals.\n+-- TODO: This can be extended with additional cases in the future.\n+simplifyCond :: Eq a => Cond a -> [Cond a]\n+simplifyCond (Conditional (BAnd b1 b2) xs ys)\n+  | b1 == b2 = simplifyCond (Conditional b1 xs ys)\n+  | b1 == BNot b2 = ys\n+  | b2 == BNot b1 = ys\n+simplifyCond (Conditional b [Conditional b1 xs1 _] [Conditional b2 _ ys2])\n+  | b1 == b2 = simplifyCond (Conditional b xs1 ys2)\n+simplifyCond (Conditional _ xs ys)\n+  | xs == ys = concatMap simplifyCond xs\n+simplifyCond c = [c]\n+\n+-- | Shift the conditional inside of the update set, by extending each update\n+-- with the condition.\n+introCond :: IsPhase ph => Cond (UpdateSet ph) -> UpdateSet ph\n introCond (Determined upds) = upds\n-introCond (Conditional e updx updy) = case getPhase updx of\n-  UpdateSetVG{} -> UpdateSetVG\n-    (buildCond updx updy _usvgUpdate)\n-    (buildCond updx updy _usvgChoice)\n-    (buildCond updx updy _usvgValue)\n-  UpdateSetCG{} -> UpdateSetCG\n-    (buildCond updx updy _uscgUpdate)\n-    (buildCond updx updy _uscgChoice)\n-  UpdateSetS{} -> UpdateSetS\n-    (buildCond updx updy _ussUpdate)\n+introCond (Conditional e updx updy) = buildCond e updx updy extCondUpd\n   where\n-    -- | Construct a single conditional, if the input is not empty.\n-    buildCond :: [Cond (UpdateSet ph)]\n-      -- ^ The input for the true case.\n+    -- | Construct a single conditional update set, combining the two input lists\n+    -- and the boolean expression, if the input is non-empty.\n+    buildCond :: IsPhase ph\n+      => BoolExpr\n       -> [Cond (UpdateSet ph)]\n-      -- ^ The input for the false case.\n-      -> (UpdateSet ph -> [Cond a])\n-      -- ^ The fetch function.\n-      -> [Cond a]\n-    buildCond updx updy get =\n-      let xs = concatCond updx get\n-          ys = concatCond updy get\n-      in [Conditional e xs ys | not (null xs && null ys)]\n-\n-    -- TODO: Temporary solution. Make introCond a part of the GenPhase class instead.\n-    getPhase :: [Cond (UpdateSet ph)] -> UpdateSet ph\n-    getPhase lst = case head lst of\n-      Determined upds -> upds\n-      Conditional _ xs _ -> getPhase xs\n-\n--- | Fetch the conditionals from the conditional update set, and flatten the\n--- two layers into one.\n-concatCond :: [Cond (UpdateSet ph)]\n-  -- ^ The conditional update set to fetch from.\n-  -> (UpdateSet ph -> [Cond a])\n-  -- ^ The fetch function.\n-  -> [Cond a]\n-concatCond upds get =\n-  let upds' = map introCond upds\n-  in concatMap get upds'\n-\n--- | Data type denoting an update.\n-data Upd\n+      -> [Cond (UpdateSet ph)]\n+      -> (BoolExpr -> Upd ph -> UpdateSet ph)\n+      -> UpdateSet ph\n+    buildCond bexp cxs cys ext =\n+      let xs = concatMap introCond cxs\n+          ys = concatMap introCond cys\n+      in concatMap (ext bexp) xs ++ concatMap (ext $ BNot bexp) ys\n+\n+-- | Data type denoting a potential recursion cycle.\n+data Rec a"
  },
  {
    "id" : "5611caac-2447-480a-a544-b841e3b8de81",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "c80b8e61-9595-4922-99e9-9f2bc8d88196",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can the list be empty? If not, let’s at least leave a comment.",
        "createdAt" : "2020-06-29T08:49:51Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "91c2ae75-29d0-4c2d-8115-b5047f5a38a7",
        "parentId" : "c80b8e61-9595-4922-99e9-9f2bc8d88196",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "I don't think the tool will ever create an empty `Rec` value. But it also never depends on the assumption that this would be non-empty. So while I don't think it happens in practice atm, I guess that future simplifications could possibly introduce empty `Rec` values. While I haven't extensively tested this, I'm fairly confident that an empty `Rec` value should not pose any issues :) ",
        "createdAt" : "2020-06-29T17:38:47Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 212,
    "diffHunk" : "@@ -98,52 +118,91 @@ createCond :: BoolExpr\n   -> Cond a\n createCond cond x y = Conditional cond [Determined x] [Determined y]\n \n--- | Shift the conditional inside the update set.\n-introCond :: Cond (UpdateSet ph) -> UpdateSet ph\n+extCond :: Eq a => BoolExpr -> Cond a -> [Cond a]\n+extCond bexp cond =\n+  let cond' = case cond of\n+        (Determined x) -> Conditional bexp [Determined x] []\n+        (Conditional bexp' xs ys) -> Conditional (bexp `BAnd` bexp') xs ys\n+  in simplifyCond cond'\n+\n+-- | Perform common simplifications on Conditionals.\n+-- TODO: This can be extended with additional cases in the future.\n+simplifyCond :: Eq a => Cond a -> [Cond a]\n+simplifyCond (Conditional (BAnd b1 b2) xs ys)\n+  | b1 == b2 = simplifyCond (Conditional b1 xs ys)\n+  | b1 == BNot b2 = ys\n+  | b2 == BNot b1 = ys\n+simplifyCond (Conditional b [Conditional b1 xs1 _] [Conditional b2 _ ys2])\n+  | b1 == b2 = simplifyCond (Conditional b xs1 ys2)\n+simplifyCond (Conditional _ xs ys)\n+  | xs == ys = concatMap simplifyCond xs\n+simplifyCond c = [c]\n+\n+-- | Shift the conditional inside of the update set, by extending each update\n+-- with the condition.\n+introCond :: IsPhase ph => Cond (UpdateSet ph) -> UpdateSet ph\n introCond (Determined upds) = upds\n-introCond (Conditional e updx updy) = case getPhase updx of\n-  UpdateSetVG{} -> UpdateSetVG\n-    (buildCond updx updy _usvgUpdate)\n-    (buildCond updx updy _usvgChoice)\n-    (buildCond updx updy _usvgValue)\n-  UpdateSetCG{} -> UpdateSetCG\n-    (buildCond updx updy _uscgUpdate)\n-    (buildCond updx updy _uscgChoice)\n-  UpdateSetS{} -> UpdateSetS\n-    (buildCond updx updy _ussUpdate)\n+introCond (Conditional e updx updy) = buildCond e updx updy extCondUpd\n   where\n-    -- | Construct a single conditional, if the input is not empty.\n-    buildCond :: [Cond (UpdateSet ph)]\n-      -- ^ The input for the true case.\n+    -- | Construct a single conditional update set, combining the two input lists\n+    -- and the boolean expression, if the input is non-empty.\n+    buildCond :: IsPhase ph\n+      => BoolExpr\n       -> [Cond (UpdateSet ph)]\n-      -- ^ The input for the false case.\n-      -> (UpdateSet ph -> [Cond a])\n-      -- ^ The fetch function.\n-      -> [Cond a]\n-    buildCond updx updy get =\n-      let xs = concatCond updx get\n-          ys = concatCond updy get\n-      in [Conditional e xs ys | not (null xs && null ys)]\n-\n-    -- TODO: Temporary solution. Make introCond a part of the GenPhase class instead.\n-    getPhase :: [Cond (UpdateSet ph)] -> UpdateSet ph\n-    getPhase lst = case head lst of\n-      Determined upds -> upds\n-      Conditional _ xs _ -> getPhase xs\n-\n--- | Fetch the conditionals from the conditional update set, and flatten the\n--- two layers into one.\n-concatCond :: [Cond (UpdateSet ph)]\n-  -- ^ The conditional update set to fetch from.\n-  -> (UpdateSet ph -> [Cond a])\n-  -- ^ The fetch function.\n-  -> [Cond a]\n-concatCond upds get =\n-  let upds' = map introCond upds\n-  in concatMap get upds'\n-\n--- | Data type denoting an update.\n-data Upd\n+      -> [Cond (UpdateSet ph)]\n+      -> (BoolExpr -> Upd ph -> UpdateSet ph)\n+      -> UpdateSet ph\n+    buildCond bexp cxs cys ext =\n+      let xs = concatMap introCond cxs\n+          ys = concatMap introCond cys\n+      in concatMap (ext bexp) xs ++ concatMap (ext $ BNot bexp) ys\n+\n+-- | Data type denoting a potential recursion cycle.\n+data Rec a\n+  = Simple a\n+  -- ^ Basic, non-recursive value.\n+  | Rec [a]"
  },
  {
    "id" : "ae494542-c2e7-4360-89ae-e66d7146421f",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "24c3fb7c-0780-4bc5-9465-8d5aac7c175b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What exactly is stored in the `String`?",
        "createdAt" : "2020-06-29T08:50:22Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a9842ca5-fccf-4f25-9067-c7691fe08c55",
        "parentId" : "24c3fb7c-0780-4bc5-9465-8d5aac7c175b",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "At the moment, the names of every let value / choice included within the mutual recursion cycle. But this could easily be extended with additional debugging information in the future. Right now, a simple String seemed sufficient.",
        "createdAt" : "2020-06-29T17:40:03Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 216,
    "diffHunk" : "@@ -98,52 +118,91 @@ createCond :: BoolExpr\n   -> Cond a\n createCond cond x y = Conditional cond [Determined x] [Determined y]\n \n--- | Shift the conditional inside the update set.\n-introCond :: Cond (UpdateSet ph) -> UpdateSet ph\n+extCond :: Eq a => BoolExpr -> Cond a -> [Cond a]\n+extCond bexp cond =\n+  let cond' = case cond of\n+        (Determined x) -> Conditional bexp [Determined x] []\n+        (Conditional bexp' xs ys) -> Conditional (bexp `BAnd` bexp') xs ys\n+  in simplifyCond cond'\n+\n+-- | Perform common simplifications on Conditionals.\n+-- TODO: This can be extended with additional cases in the future.\n+simplifyCond :: Eq a => Cond a -> [Cond a]\n+simplifyCond (Conditional (BAnd b1 b2) xs ys)\n+  | b1 == b2 = simplifyCond (Conditional b1 xs ys)\n+  | b1 == BNot b2 = ys\n+  | b2 == BNot b1 = ys\n+simplifyCond (Conditional b [Conditional b1 xs1 _] [Conditional b2 _ ys2])\n+  | b1 == b2 = simplifyCond (Conditional b xs1 ys2)\n+simplifyCond (Conditional _ xs ys)\n+  | xs == ys = concatMap simplifyCond xs\n+simplifyCond c = [c]\n+\n+-- | Shift the conditional inside of the update set, by extending each update\n+-- with the condition.\n+introCond :: IsPhase ph => Cond (UpdateSet ph) -> UpdateSet ph\n introCond (Determined upds) = upds\n-introCond (Conditional e updx updy) = case getPhase updx of\n-  UpdateSetVG{} -> UpdateSetVG\n-    (buildCond updx updy _usvgUpdate)\n-    (buildCond updx updy _usvgChoice)\n-    (buildCond updx updy _usvgValue)\n-  UpdateSetCG{} -> UpdateSetCG\n-    (buildCond updx updy _uscgUpdate)\n-    (buildCond updx updy _uscgChoice)\n-  UpdateSetS{} -> UpdateSetS\n-    (buildCond updx updy _ussUpdate)\n+introCond (Conditional e updx updy) = buildCond e updx updy extCondUpd\n   where\n-    -- | Construct a single conditional, if the input is not empty.\n-    buildCond :: [Cond (UpdateSet ph)]\n-      -- ^ The input for the true case.\n+    -- | Construct a single conditional update set, combining the two input lists\n+    -- and the boolean expression, if the input is non-empty.\n+    buildCond :: IsPhase ph\n+      => BoolExpr\n       -> [Cond (UpdateSet ph)]\n-      -- ^ The input for the false case.\n-      -> (UpdateSet ph -> [Cond a])\n-      -- ^ The fetch function.\n-      -> [Cond a]\n-    buildCond updx updy get =\n-      let xs = concatCond updx get\n-          ys = concatCond updy get\n-      in [Conditional e xs ys | not (null xs && null ys)]\n-\n-    -- TODO: Temporary solution. Make introCond a part of the GenPhase class instead.\n-    getPhase :: [Cond (UpdateSet ph)] -> UpdateSet ph\n-    getPhase lst = case head lst of\n-      Determined upds -> upds\n-      Conditional _ xs _ -> getPhase xs\n-\n--- | Fetch the conditionals from the conditional update set, and flatten the\n--- two layers into one.\n-concatCond :: [Cond (UpdateSet ph)]\n-  -- ^ The conditional update set to fetch from.\n-  -> (UpdateSet ph -> [Cond a])\n-  -- ^ The fetch function.\n-  -> [Cond a]\n-concatCond upds get =\n-  let upds' = map introCond upds\n-  in concatMap get upds'\n-\n--- | Data type denoting an update.\n-data Upd\n+      -> [Cond (UpdateSet ph)]\n+      -> (BoolExpr -> Upd ph -> UpdateSet ph)\n+      -> UpdateSet ph\n+    buildCond bexp cxs cys ext =\n+      let xs = concatMap introCond cxs\n+          ys = concatMap introCond cys\n+      in concatMap (ext bexp) xs ++ concatMap (ext $ BNot bexp) ys\n+\n+-- | Data type denoting a potential recursion cycle.\n+data Rec a\n+  = Simple a\n+  -- ^ Basic, non-recursive value.\n+  | Rec [a]\n+  -- ^ (Possibly multiple) recursion cycles.\n+  | MutRec [(String,a)]"
  },
  {
    "id" : "eb6d6271-33e2-496d-9d09-245af478baf8",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "4624e393-3c5a-4322-9192-aeafb7248e63",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That typeclass looks very scary especially given that half of the methods call `error` in at least one of the instances. I’ll leave a few comments on individual methods.",
        "createdAt" : "2020-06-29T09:06:51Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 312,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase."
  },
  {
    "id" : "9aecbecf-9845-4cfe-b6d7-82df3debdbb2",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "cd604707-82ce-46bd-aa22-5cccd6804554",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Only called for `ChoiceGathering`.",
        "createdAt" : "2020-06-29T09:47:05Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase.\n+class IsPhase (ph :: Phase) where\n+  -- | The updates which can be performed.\n+  data Upd ph\n+  -- | The environment for the DAML-LF verifier.\n+  data Env ph\n+  -- | Construct a base update.\n+  baseUpd :: Rec [Cond BaseUpd] -> Upd ph\n+  -- | Construct a choice exercise update.\n+  choiceUpd :: Cond UpdChoice -> Upd ph\n+  -- | Construct a value update.\n+  valueUpd :: Cond (Qualified ExprValName) -> Upd ph\n+  -- | Map over a single base update.\n+  mapBaseUpd :: (Rec [Cond BaseUpd] -> Upd ph) -> Upd ph -> Upd ph\n+  -- | Check whether the update set contains any choice references.\n+  containsChoiceRefs :: UpdateSet ph -> Bool\n+  -- | Extend the conditional of an update.\n+  extCondUpd :: BoolExpr -> Upd ph -> UpdateSet ph\n+  -- | Construct an empty environment.\n   emptyEnv :: Env ph\n-\n-instance GenPhase 'ValueGathering where\n-  emptyUpdateSet = UpdateSetVG [] [] []\n+  -- | Combine two environments.\n+  concatEnv :: Env ph -> Env ph -> Env ph\n+  -- | Get the skolemised term variables and fields from the environment.\n+  envSkols :: Env ph -> [Skolem]\n+  -- | Update the skolemised term variables and fields in the environment.\n+  setEnvSkols :: [Skolem] -> Env ph -> Env ph\n+  -- | Get the bound values from the environment.\n+  envVals :: Env ph -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- | Update the bound values in the environment.\n+  setEnvVals :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph) -> Env ph -> Env ph\n+  -- | Get the data constructors from the environment.\n+  envDats :: Env ph -> HM.HashMap TypeConName DefDataType\n+  -- | Update the data constructors in the environment.\n+  setEnvDats :: HM.HashMap TypeConName DefDataType -> Env ph -> Env ph\n+  -- | Get the fetched cid's mapped to their current variable name, along with\n+  -- a list of any potential old variable names, from the environment.\n+  envCids :: Env ph -> HM.HashMap Cid (ExprVarName, [ExprVarName])\n+  -- | Update the fetched cid's in the environment.\n+  setEnvCids :: HM.HashMap Cid (ExprVarName, [ExprVarName]) -> Env ph -> Env ph\n+  -- | Get the set of preconditions from the environment.\n+  envPreconds :: Env ph -> HM.HashMap (Qualified TypeConName) (Expr -> Expr)\n+  -- | Update the set of preconditions in the environment.\n+  setEnvPreconds :: HM.HashMap (Qualified TypeConName) (Expr -> Expr) -> Env ph -> Env ph"
  },
  {
    "id" : "7047dcc8-47f1-48f9-b2e0-9820359d9c3c",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "45fd32c1-6afb-4e2c-b13d-8a6c59f8952b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not entirely sure but I believe only called for `ChoiceGathering`",
        "createdAt" : "2020-06-29T09:47:08Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1646c8a3-1f53-422f-af7a-3f2f8bddca16",
        "parentId" : "45fd32c1-6afb-4e2c-b13d-8a6c59f8952b",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "I don't think that's correct. It could also be called through `genChoice` -> `extEnvContract` -> `extCtr` in the `ValueGathering` phase.\r\nHowever, as this function can't throw any errors, I think that's less of an issue.",
        "createdAt" : "2020-06-30T13:21:48Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 355,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase.\n+class IsPhase (ph :: Phase) where\n+  -- | The updates which can be performed.\n+  data Upd ph\n+  -- | The environment for the DAML-LF verifier.\n+  data Env ph\n+  -- | Construct a base update.\n+  baseUpd :: Rec [Cond BaseUpd] -> Upd ph\n+  -- | Construct a choice exercise update.\n+  choiceUpd :: Cond UpdChoice -> Upd ph\n+  -- | Construct a value update.\n+  valueUpd :: Cond (Qualified ExprValName) -> Upd ph\n+  -- | Map over a single base update.\n+  mapBaseUpd :: (Rec [Cond BaseUpd] -> Upd ph) -> Upd ph -> Upd ph\n+  -- | Check whether the update set contains any choice references.\n+  containsChoiceRefs :: UpdateSet ph -> Bool\n+  -- | Extend the conditional of an update.\n+  extCondUpd :: BoolExpr -> Upd ph -> UpdateSet ph\n+  -- | Construct an empty environment.\n   emptyEnv :: Env ph\n-\n-instance GenPhase 'ValueGathering where\n-  emptyUpdateSet = UpdateSetVG [] [] []\n+  -- | Combine two environments.\n+  concatEnv :: Env ph -> Env ph -> Env ph\n+  -- | Get the skolemised term variables and fields from the environment.\n+  envSkols :: Env ph -> [Skolem]\n+  -- | Update the skolemised term variables and fields in the environment.\n+  setEnvSkols :: [Skolem] -> Env ph -> Env ph\n+  -- | Get the bound values from the environment.\n+  envVals :: Env ph -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- | Update the bound values in the environment.\n+  setEnvVals :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph) -> Env ph -> Env ph\n+  -- | Get the data constructors from the environment.\n+  envDats :: Env ph -> HM.HashMap TypeConName DefDataType\n+  -- | Update the data constructors in the environment.\n+  setEnvDats :: HM.HashMap TypeConName DefDataType -> Env ph -> Env ph\n+  -- | Get the fetched cid's mapped to their current variable name, along with\n+  -- a list of any potential old variable names, from the environment.\n+  envCids :: Env ph -> HM.HashMap Cid (ExprVarName, [ExprVarName])\n+  -- | Update the fetched cid's in the environment.\n+  setEnvCids :: HM.HashMap Cid (ExprVarName, [ExprVarName]) -> Env ph -> Env ph\n+  -- | Get the set of preconditions from the environment.\n+  envPreconds :: Env ph -> HM.HashMap (Qualified TypeConName) (Expr -> Expr)\n+  -- | Update the set of preconditions in the environment.\n+  setEnvPreconds :: HM.HashMap (Qualified TypeConName) (Expr -> Expr) -> Env ph -> Env ph\n+  -- | Get the additional constraints from the environment.\n+  envCtrs :: Env ph -> [BoolExpr]\n+  -- | Update the additional constraints in the environment.\n+  setEnvCtrs :: [BoolExpr] -> Env ph -> Env ph"
  },
  {
    "id" : "37e0e20e-8561-4021-9953-cb35fc5560e8",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "61f2b502-1e6e-4eed-a3a1-6bc2b74312e6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not completely sure but I believe only called for `ChoiceGathering`",
        "createdAt" : "2020-06-29T09:47:59Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "945e7d39-e309-4028-b2b3-04900351c1e9",
        "parentId" : "61f2b502-1e6e-4eed-a3a1-6bc2b74312e6",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "I think this could also be called through `extEnvContract` in the `ValueGathering` phase. But as it never throws an error, that seems fine :) ",
        "createdAt" : "2020-06-30T13:24:42Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 349,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase.\n+class IsPhase (ph :: Phase) where\n+  -- | The updates which can be performed.\n+  data Upd ph\n+  -- | The environment for the DAML-LF verifier.\n+  data Env ph\n+  -- | Construct a base update.\n+  baseUpd :: Rec [Cond BaseUpd] -> Upd ph\n+  -- | Construct a choice exercise update.\n+  choiceUpd :: Cond UpdChoice -> Upd ph\n+  -- | Construct a value update.\n+  valueUpd :: Cond (Qualified ExprValName) -> Upd ph\n+  -- | Map over a single base update.\n+  mapBaseUpd :: (Rec [Cond BaseUpd] -> Upd ph) -> Upd ph -> Upd ph\n+  -- | Check whether the update set contains any choice references.\n+  containsChoiceRefs :: UpdateSet ph -> Bool\n+  -- | Extend the conditional of an update.\n+  extCondUpd :: BoolExpr -> Upd ph -> UpdateSet ph\n+  -- | Construct an empty environment.\n   emptyEnv :: Env ph\n-\n-instance GenPhase 'ValueGathering where\n-  emptyUpdateSet = UpdateSetVG [] [] []\n+  -- | Combine two environments.\n+  concatEnv :: Env ph -> Env ph -> Env ph\n+  -- | Get the skolemised term variables and fields from the environment.\n+  envSkols :: Env ph -> [Skolem]\n+  -- | Update the skolemised term variables and fields in the environment.\n+  setEnvSkols :: [Skolem] -> Env ph -> Env ph\n+  -- | Get the bound values from the environment.\n+  envVals :: Env ph -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- | Update the bound values in the environment.\n+  setEnvVals :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph) -> Env ph -> Env ph\n+  -- | Get the data constructors from the environment.\n+  envDats :: Env ph -> HM.HashMap TypeConName DefDataType\n+  -- | Update the data constructors in the environment.\n+  setEnvDats :: HM.HashMap TypeConName DefDataType -> Env ph -> Env ph\n+  -- | Get the fetched cid's mapped to their current variable name, along with\n+  -- a list of any potential old variable names, from the environment.\n+  envCids :: Env ph -> HM.HashMap Cid (ExprVarName, [ExprVarName])\n+  -- | Update the fetched cid's in the environment.\n+  setEnvCids :: HM.HashMap Cid (ExprVarName, [ExprVarName]) -> Env ph -> Env ph"
  },
  {
    "id" : "82168e5d-0d30-4c9e-817c-524d524611f0",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "f3341d19-e300-444c-9742-d7eebe0d7f46",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Also only called once for `ValueGathering`.",
        "createdAt" : "2020-06-29T09:48:03Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase.\n+class IsPhase (ph :: Phase) where\n+  -- | The updates which can be performed.\n+  data Upd ph\n+  -- | The environment for the DAML-LF verifier.\n+  data Env ph\n+  -- | Construct a base update.\n+  baseUpd :: Rec [Cond BaseUpd] -> Upd ph\n+  -- | Construct a choice exercise update.\n+  choiceUpd :: Cond UpdChoice -> Upd ph\n+  -- | Construct a value update.\n+  valueUpd :: Cond (Qualified ExprValName) -> Upd ph\n+  -- | Map over a single base update.\n+  mapBaseUpd :: (Rec [Cond BaseUpd] -> Upd ph) -> Upd ph -> Upd ph\n+  -- | Check whether the update set contains any choice references.\n+  containsChoiceRefs :: UpdateSet ph -> Bool\n+  -- | Extend the conditional of an update.\n+  extCondUpd :: BoolExpr -> Upd ph -> UpdateSet ph\n+  -- | Construct an empty environment.\n   emptyEnv :: Env ph\n-\n-instance GenPhase 'ValueGathering where\n-  emptyUpdateSet = UpdateSetVG [] [] []\n+  -- | Combine two environments.\n+  concatEnv :: Env ph -> Env ph -> Env ph\n+  -- | Get the skolemised term variables and fields from the environment.\n+  envSkols :: Env ph -> [Skolem]\n+  -- | Update the skolemised term variables and fields in the environment.\n+  setEnvSkols :: [Skolem] -> Env ph -> Env ph\n+  -- | Get the bound values from the environment.\n+  envVals :: Env ph -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- | Update the bound values in the environment.\n+  setEnvVals :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph) -> Env ph -> Env ph\n+  -- | Get the data constructors from the environment.\n+  envDats :: Env ph -> HM.HashMap TypeConName DefDataType\n+  -- | Update the data constructors in the environment.\n+  setEnvDats :: HM.HashMap TypeConName DefDataType -> Env ph -> Env ph"
  },
  {
    "id" : "984a38ec-878c-40b4-8f8a-30c3eb8d67e0",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "a1fd547c-51fe-4173-885e-682136c752bd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is only called once for `ValueGathering` so you can just remove it from the typeclass.",
        "createdAt" : "2020-06-29T09:48:06Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase.\n+class IsPhase (ph :: Phase) where\n+  -- | The updates which can be performed.\n+  data Upd ph\n+  -- | The environment for the DAML-LF verifier.\n+  data Env ph\n+  -- | Construct a base update.\n+  baseUpd :: Rec [Cond BaseUpd] -> Upd ph\n+  -- | Construct a choice exercise update.\n+  choiceUpd :: Cond UpdChoice -> Upd ph\n+  -- | Construct a value update.\n+  valueUpd :: Cond (Qualified ExprValName) -> Upd ph\n+  -- | Map over a single base update.\n+  mapBaseUpd :: (Rec [Cond BaseUpd] -> Upd ph) -> Upd ph -> Upd ph\n+  -- | Check whether the update set contains any choice references.\n+  containsChoiceRefs :: UpdateSet ph -> Bool\n+  -- | Extend the conditional of an update.\n+  extCondUpd :: BoolExpr -> Upd ph -> UpdateSet ph\n+  -- | Construct an empty environment.\n   emptyEnv :: Env ph\n-\n-instance GenPhase 'ValueGathering where\n-  emptyUpdateSet = UpdateSetVG [] [] []\n+  -- | Combine two environments.\n+  concatEnv :: Env ph -> Env ph -> Env ph\n+  -- | Get the skolemised term variables and fields from the environment.\n+  envSkols :: Env ph -> [Skolem]\n+  -- | Update the skolemised term variables and fields in the environment.\n+  setEnvSkols :: [Skolem] -> Env ph -> Env ph\n+  -- | Get the bound values from the environment.\n+  envVals :: Env ph -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- | Update the bound values in the environment.\n+  setEnvVals :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph) -> Env ph -> Env ph"
  },
  {
    "id" : "856ec797-af1b-45de-9684-4967aaacb4c0",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "d4bfe0c7-465b-444a-a25d-57bbcd795885",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Only called for `ChoiceGathering`.",
        "createdAt" : "2020-06-29T10:08:41Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b9da2760-e8cb-43aa-a783-df2ef9fe4f4f",
        "parentId" : "d4bfe0c7-465b-444a-a25d-57bbcd795885",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "Well spotted! This code was refactored quite extensively a couple of days ago, and I never checked whether these methods still needed to be in the type class. But you're absolutely right. I'll remove them from the type class, which should also reduce the number of methods which just return an error significantly :) ",
        "createdAt" : "2020-06-29T17:42:53Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase.\n+class IsPhase (ph :: Phase) where\n+  -- | The updates which can be performed.\n+  data Upd ph\n+  -- | The environment for the DAML-LF verifier.\n+  data Env ph\n+  -- | Construct a base update.\n+  baseUpd :: Rec [Cond BaseUpd] -> Upd ph\n+  -- | Construct a choice exercise update.\n+  choiceUpd :: Cond UpdChoice -> Upd ph\n+  -- | Construct a value update.\n+  valueUpd :: Cond (Qualified ExprValName) -> Upd ph\n+  -- | Map over a single base update.\n+  mapBaseUpd :: (Rec [Cond BaseUpd] -> Upd ph) -> Upd ph -> Upd ph\n+  -- | Check whether the update set contains any choice references.\n+  containsChoiceRefs :: UpdateSet ph -> Bool\n+  -- | Extend the conditional of an update.\n+  extCondUpd :: BoolExpr -> Upd ph -> UpdateSet ph\n+  -- | Construct an empty environment.\n   emptyEnv :: Env ph\n-\n-instance GenPhase 'ValueGathering where\n-  emptyUpdateSet = UpdateSetVG [] [] []\n+  -- | Combine two environments.\n+  concatEnv :: Env ph -> Env ph -> Env ph\n+  -- | Get the skolemised term variables and fields from the environment.\n+  envSkols :: Env ph -> [Skolem]\n+  -- | Update the skolemised term variables and fields in the environment.\n+  setEnvSkols :: [Skolem] -> Env ph -> Env ph\n+  -- | Get the bound values from the environment.\n+  envVals :: Env ph -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- | Update the bound values in the environment.\n+  setEnvVals :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph) -> Env ph -> Env ph\n+  -- | Get the data constructors from the environment.\n+  envDats :: Env ph -> HM.HashMap TypeConName DefDataType\n+  -- | Update the data constructors in the environment.\n+  setEnvDats :: HM.HashMap TypeConName DefDataType -> Env ph -> Env ph\n+  -- | Get the fetched cid's mapped to their current variable name, along with\n+  -- a list of any potential old variable names, from the environment.\n+  envCids :: Env ph -> HM.HashMap Cid (ExprVarName, [ExprVarName])\n+  -- | Update the fetched cid's in the environment.\n+  setEnvCids :: HM.HashMap Cid (ExprVarName, [ExprVarName]) -> Env ph -> Env ph\n+  -- | Get the set of preconditions from the environment.\n+  envPreconds :: Env ph -> HM.HashMap (Qualified TypeConName) (Expr -> Expr)\n+  -- | Update the set of preconditions in the environment.\n+  setEnvPreconds :: HM.HashMap (Qualified TypeConName) (Expr -> Expr) -> Env ph -> Env ph\n+  -- | Get the additional constraints from the environment.\n+  envCtrs :: Env ph -> [BoolExpr]\n+  -- | Update the additional constraints in the environment.\n+  setEnvCtrs :: [BoolExpr] -> Env ph -> Env ph\n+  -- | Get the set of relevant choices from the environment.\n+  envChoices :: Env ph -> HM.HashMap UpdChoice (ChoiceData ph)\n+  -- | Update the set of relevant choices in the environment.\n+  setEnvChoices :: HM.HashMap UpdChoice (ChoiceData ph) -> Env ph -> Env ph"
  },
  {
    "id" : "a4af1197-747e-4e23-86be-a6cdf775ca7e",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "c374a414-213d-4849-9a9e-0c7be138776d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That seems sketchy. Is that what GHC uses? Why do we need to filter this out, i.e., what harm is there in not filtering it out?",
        "createdAt" : "2020-06-29T11:14:24Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "535c8303-e778-423e-b878-f8b73a80a8a6",
        "parentId" : "c374a414-213d-4849-9a9e-0c7be138776d",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "You're right, this was an issue before, when multiple updates were bound to an underscore. But as it has been fixed in the meantime, this can be removed :) ",
        "createdAt" : "2020-06-30T13:34:47Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -447,389 +677,212 @@ extChEnv :: MonadEnv m ph\n   -> Type\n   -- ^ The result type of the new choice.\n   -> m ()\n-extChEnv tc ch self this arg upd typ =\n-  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n-  in getEnv >>= \\case\n-    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n-    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (ChoiceData self this arg substUpd typ) _envcgchs}\n-    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (ChoiceData self this arg substUpd typ) _envschs}\n+extChEnv tc ch self this arg upd typ = do\n+  env <- getEnv\n+  putEnv $ setEnvChoices (HM.insert (UpdChoice tc ch) (ChoiceData self this arg upd typ) $ envChoices env) env\n \n -- | Extend the environment with a list of new data type definitions.\n-extDatsEnv :: MonadEnv m ph\n+extDatsEnv :: (IsPhase ph, MonadEnv m ph)\n   => HM.HashMap TypeConName DefDataType\n   -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n   -> m ()\n-extDatsEnv hmap = getEnv >>= \\case\n-    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n-    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n-    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n-\n--- | Extend the environment with a new contract id, and the variable to which\n--- the fetched contract is bound.\n-extCidEnv :: MonadEnv m ph\n-  => Expr\n+extDatsEnv hmap = do\n+  env <- getEnv\n+  putEnv $ setEnvDats (hmap `HM.union` envDats env) env\n+\n+-- | Extend the environment with a refreshed contract id, and the variable to\n+-- which the fetched contract is bound. Returns a substitution, mapping the\n+-- given contract id, to the refreshed one.\n+-- While it might seem counter intuitive, the function only refreshes the\n+-- contract id on its first encounter. The reason is that it needs to be able to\n+-- keep track of old bindings.\n+-- Note that instead of overwriting old bindings, the function creates a new\n+-- synonym between the old and new binding.\n+extCidEnv :: (IsPhase ph, MonadEnv m ph)\n+  => Bool\n+  -- ^ Flag denoting whether the contract id should be refreshed.\n+  -- Note that even with the flag on, contract id are only refreshed on their\n+  -- first encounter.\n+  -> Expr\n   -- ^ The contract id expression.\n   -> ExprVarName\n   -- ^ The variable name to which the fetched contract is bound.\n+  -> m ExprSubst\n+extCidEnv b exp var = do\n+  case exp of\n+    -- Filter out any bindings to `_`.\n+    EVar (ExprVarName \"ds2\") -> return emptyExprSubst"
  },
  {
    "id" : "676a793a-4748-4ce8-ae4f-38da26d2be6a",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "1ff19b37-f887-45ba-a44a-2dde52585e23",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    step (f,typ) = do\r\n      mbFields <- recTypFields typ\r\n      whenJust mbFields $ \\fsRec -> \r\n        extRecEnv (fieldName2VarName f) $ map fst fsRec\r\n```\r\nA bit easier to parse. Side note: Do you ever expect `recTypFields` to return `Nothing` here? It looks like you are only calling this in cases where the type must be a record so maybe crashing is more appropriate?",
        "createdAt" : "2020-06-29T11:14:29Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -391,47 +600,68 @@ runEnv comp env0 = do\n   return env1\n \n -- | Skolemise an expression variable and extend the environment.\n-extVarEnv :: MonadEnv m ph\n+extVarEnv :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The expression variable to be skolemised.\n   -> m ()\n extVarEnv x = extSkolEnv (SkolVar x)\n \n -- | Skolemise a list of record projection and extend the environment.\n-extRecEnv :: MonadEnv m ph\n+extRecEnv :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The variable on which is being projected.\n   -> [FieldName]\n   -- ^ The fields which should be skolemised.\n   -> m ()\n-extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+extRecEnv x fs = do\n+  env <- getEnv\n+  let skols = envSkols env\n+      curFs = [fs' | SkolRec x' fs' <- skols, x == x']\n+      newFs = if null curFs\n+        then fs\n+        else fs ++ head curFs\n+  extSkolEnv (SkolRec x newFs)\n+\n+-- | Extend the environment with the fields of any given record or type\n+-- constructor type.\n+extRecEnvTCons :: (IsPhase ph, MonadEnv m ph)\n+  => [(FieldName, Type)]\n+  -- ^ The given fields and their corresponding types to analyse.\n+  -> m ()\n+extRecEnvTCons = mapM_ step\n+  where\n+    step :: (IsPhase ph, MonadEnv m ph) => (FieldName, Type) -> m ()\n+    step (f,typ) =\n+      recTypFields typ >>= \\case\n+        Nothing -> return ()\n+        Just fsRec -> do\n+          extRecEnv (fieldName2VarName f) $ map fst fsRec"
  },
  {
    "id" : "a42d2c70-c459-4b37-b1c4-5d3aca549d9d",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "888a372a-c82e-40cf-9b30-3c4e9058583a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t understand this. Why are you appending the fields of an existing skolem? And why only the first one?",
        "createdAt" : "2020-06-29T11:14:31Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "52d6166f-0057-43bc-9e7b-5c6c12784480",
        "parentId" : "888a372a-c82e-40cf-9b30-3c4e9058583a",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "This is very confusing indeed. I added a note. It boils down to this:\r\n- If you skolemise `x.[field1, field2]`, and skolemise `x.field3` afterwards, the end result should be that the list of skolems contains `x.[field1, field2, field3'.\r\n- `extSkolEnv` works by just appending the new skolems to the front of the list, and ignoring any duplicate entries behind it, from now on. This means that adding `x.field3` would overwrite the previous entries.\r\n- To fix this, we look up the latest entry for `x` in the skolems, and copy its fields into the new entry.",
        "createdAt" : "2020-06-30T14:14:10Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -391,47 +600,68 @@ runEnv comp env0 = do\n   return env1\n \n -- | Skolemise an expression variable and extend the environment.\n-extVarEnv :: MonadEnv m ph\n+extVarEnv :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The expression variable to be skolemised.\n   -> m ()\n extVarEnv x = extSkolEnv (SkolVar x)\n \n -- | Skolemise a list of record projection and extend the environment.\n-extRecEnv :: MonadEnv m ph\n+extRecEnv :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The variable on which is being projected.\n   -> [FieldName]\n   -- ^ The fields which should be skolemised.\n   -> m ()\n-extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+extRecEnv x fs = do\n+  env <- getEnv\n+  let skols = envSkols env\n+      curFs = [fs' | SkolRec x' fs' <- skols, x == x']\n+      newFs = if null curFs\n+        then fs\n+        else fs ++ head curFs"
  },
  {
    "id" : "6b31b879-baf6-4c2b-9570-a637b05b3c27",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "70628966-13c9-477b-9b97-a5a75c9efec9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you pattern match you don’t need t call `head`.",
        "createdAt" : "2020-06-29T11:14:32Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -391,47 +600,68 @@ runEnv comp env0 = do\n   return env1\n \n -- | Skolemise an expression variable and extend the environment.\n-extVarEnv :: MonadEnv m ph\n+extVarEnv :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The expression variable to be skolemised.\n   -> m ()\n extVarEnv x = extSkolEnv (SkolVar x)\n \n -- | Skolemise a list of record projection and extend the environment.\n-extRecEnv :: MonadEnv m ph\n+extRecEnv :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The variable on which is being projected.\n   -> [FieldName]\n   -- ^ The fields which should be skolemised.\n   -> m ()\n-extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+extRecEnv x fs = do\n+  env <- getEnv\n+  let skols = envSkols env\n+      curFs = [fs' | SkolRec x' fs' <- skols, x == x']\n+      newFs = if null curFs"
  },
  {
    "id" : "19086ab8-ec32-422d-81dc-8cad5e8d0ff1",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "e12545f7-079a-4d7d-afa6-1aa75f835578",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Does this solve any issue or are you just trying to get nicer names? Variable names in DAML-LF can start with `_` so I don’t believe this helps with ensuring that the variable is fresh. In fact it seems to make it worse since they cannot start with a digit.",
        "createdAt" : "2020-06-29T11:14:42Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "63d72349-e389-450e-8f73-5e537a313efa",
        "parentId" : "e12545f7-079a-4d7d-afa6-1aa75f835578",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "This actually solves an issue! :) \r\nEvery variable gets refreshed at least once, by adding `_Number` to it.\r\n- Variables ending on an underscore don't pose any issue. e.g. if you have both variable `x` and `x_`, they would be translated to `x_Number` and `x__Number` which are different.\r\n- Without the underscore, there is an issue though. Consider having variables `x1` and `x`. While refreshing them, we would add a unique number to them. If those numbers happened to be `2` and `12` for example, the refreshed variables would suddenly collide as `x12`. However, with the underscores this would result in `x1_2` and `x_12`.",
        "createdAt" : "2020-06-29T17:55:08Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 732,
    "diffHunk" : "@@ -378,7 +587,7 @@ fresh :: MonadEnv m ph => m String\n fresh = do\n   (cur,env) <- get\n   put (cur + 1,env)\n-  return $ show cur\n+  return $ \"_\" ++ show cur"
  },
  {
    "id" : "374839a4-9771-42d8-9f70-62175289cada",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "47edb273-4a19-4e08-8d39-289fe47fe2a9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "At least the 4 fields seem to be common to all 3 `Env` types and there also seem to be shared parts between the latter fields in particular for `ChoiceGathering` and `Solving`. How about we either factor them out or factor out the whole `Env` type?",
        "createdAt" : "2020-06-29T11:14:54Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ee2942a6-741f-4ccd-8da0-474e8530cc07",
        "parentId" : "47edb273-4a19-4e08-8d39-289fe47fe2a9",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "What exactly do you mean with `factor out` here? I very much dislike the current definition of `Env`, because there is a lot of overlap indeed. But I don't see a nicer solution?",
        "createdAt" : "2020-06-30T14:16:01Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "efbe2e90-a067-49f5-8bf7-c688d70edb14",
        "parentId" : "47edb273-4a19-4e08-8d39-289fe47fe2a9",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I see two solutions:\r\n1. Use a single `Env` type with one or more type parameters for the fields that are different between the 3 phases. 1 + type families should be enough but you can argue whether type families are easier or harder to understand here compared to just having separate type parameters.\r\n2. Keep using different `Env` types but factor out the shared parts into separate types, e.g., you could make a type with 4 fields that captures the 4 fields currently in `Env` and then give the `Env` types a single field that references that type.\r\n\r\nI’d probably go for 1 since you then have a single Env type that you can operate on generically instead of needing all those `get` methods for things that are common to all 3.",
        "createdAt" : "2020-06-30T14:28:02Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "13d2a727-c023-4467-91e1-c531dcf4e345",
        "parentId" : "47edb273-4a19-4e08-8d39-289fe47fe2a9",
        "author" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "body" : "Cool! I guess that would work indeed, and it would certainly reduce the duplication here :) ",
        "createdAt" : "2020-06-30T14:43:24Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "Gertjan423",
          "name" : "Gert-Jan Bottu",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/5838382?u=b47bd98f384562b45de5cd99b73da4c1aac7aceb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : 368,
    "diffHunk" : "@@ -169,69 +243,247 @@ data UpdChoice = UpdChoice\n   }\n   deriving (Eq, Generic, Hashable, Show)\n \n--- | The collection of updates being performed.\n-data UpdateSet (ph :: Phase) where\n-  UpdateSetVG ::\n-    { _usvgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _usvgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    , _usvgValue :: ![Cond (Qualified ExprValName)]\n-      -- ^ The list of referenced values.\n-    } -> UpdateSet 'ValueGathering\n-  UpdateSetCG ::\n-    { _uscgUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    , _uscgChoice :: ![Cond UpdChoice]\n-      -- ^ The list of exercised choices.\n-    } -> UpdateSet 'ChoiceGathering\n-  UpdateSetS ::\n-    { _ussUpdate :: ![Cond Upd]\n-      -- ^ The list of updates.\n-    } -> UpdateSet 'Solving\n-\n-class GenPhase ph where\n-  emptyUpdateSet :: UpdateSet ph\n+-- | Class containing the environment, and operations on it, for each generator phase.\n+class IsPhase (ph :: Phase) where\n+  -- | The updates which can be performed.\n+  data Upd ph\n+  -- | The environment for the DAML-LF verifier.\n+  data Env ph\n+  -- | Construct a base update.\n+  baseUpd :: Rec [Cond BaseUpd] -> Upd ph\n+  -- | Construct a choice exercise update.\n+  choiceUpd :: Cond UpdChoice -> Upd ph\n+  -- | Construct a value update.\n+  valueUpd :: Cond (Qualified ExprValName) -> Upd ph\n+  -- | Map over a single base update.\n+  mapBaseUpd :: (Rec [Cond BaseUpd] -> Upd ph) -> Upd ph -> Upd ph\n+  -- | Check whether the update set contains any choice references.\n+  containsChoiceRefs :: UpdateSet ph -> Bool\n+  -- | Extend the conditional of an update.\n+  extCondUpd :: BoolExpr -> Upd ph -> UpdateSet ph\n+  -- | Construct an empty environment.\n   emptyEnv :: Env ph\n-\n-instance GenPhase 'ValueGathering where\n-  emptyUpdateSet = UpdateSetVG [] [] []\n+  -- | Combine two environments.\n+  concatEnv :: Env ph -> Env ph -> Env ph\n+  -- | Get the skolemised term variables and fields from the environment.\n+  envSkols :: Env ph -> [Skolem]\n+  -- | Update the skolemised term variables and fields in the environment.\n+  setEnvSkols :: [Skolem] -> Env ph -> Env ph\n+  -- | Get the bound values from the environment.\n+  envVals :: Env ph -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- | Update the bound values in the environment.\n+  setEnvVals :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph) -> Env ph -> Env ph\n+  -- | Get the data constructors from the environment.\n+  envDats :: Env ph -> HM.HashMap TypeConName DefDataType\n+  -- | Update the data constructors in the environment.\n+  setEnvDats :: HM.HashMap TypeConName DefDataType -> Env ph -> Env ph\n+  -- | Get the fetched cid's mapped to their current variable name, along with\n+  -- a list of any potential old variable names, from the environment.\n+  envCids :: Env ph -> HM.HashMap Cid (ExprVarName, [ExprVarName])\n+  -- | Update the fetched cid's in the environment.\n+  setEnvCids :: HM.HashMap Cid (ExprVarName, [ExprVarName]) -> Env ph -> Env ph\n+  -- | Get the set of preconditions from the environment.\n+  envPreconds :: Env ph -> HM.HashMap (Qualified TypeConName) (Expr -> Expr)\n+  -- | Update the set of preconditions in the environment.\n+  setEnvPreconds :: HM.HashMap (Qualified TypeConName) (Expr -> Expr) -> Env ph -> Env ph\n+  -- | Get the additional constraints from the environment.\n+  envCtrs :: Env ph -> [BoolExpr]\n+  -- | Update the additional constraints in the environment.\n+  setEnvCtrs :: [BoolExpr] -> Env ph -> Env ph\n+  -- | Get the set of relevant choices from the environment.\n+  envChoices :: Env ph -> HM.HashMap UpdChoice (ChoiceData ph)\n+  -- | Update the set of relevant choices in the environment.\n+  setEnvChoices :: HM.HashMap UpdChoice (ChoiceData ph) -> Env ph -> Env ph\n+\n+instance IsPhase 'ValueGathering where\n+  data Upd 'ValueGathering\n+    = UpdVGBase ![Cond BaseUpd]\n+    -- ^ A base update.\n+    | UpdVGChoice !(Cond UpdChoice)\n+    -- ^ An exercised choice.\n+    | UpdVGVal !(Cond (Qualified ExprValName))\n+    -- ^ A referenced value.\n+  data Env 'ValueGathering = EnvVG\n+    ![Skolem]"
  },
  {
    "id" : "f3f74e4f-bc4d-4086-aa91-d808e98e1d00",
    "prId" : 6516,
    "comments" : [
      {
        "id" : "5a220ac4-d2f2-41e7-992f-f0c17cad272e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same as above, if you pattern match, it’s clear why `head` is safe.",
        "createdAt" : "2020-06-29T11:28:25Z",
        "updatedAt" : "2020-06-30T18:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8c9efc7a1908f7441b41b0d2ca49c22490f8c777",
    "line" : null,
    "diffHunk" : "@@ -447,389 +677,212 @@ extChEnv :: MonadEnv m ph\n   -> Type\n   -- ^ The result type of the new choice.\n   -> m ()\n-extChEnv tc ch self this arg upd typ =\n-  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n-  in getEnv >>= \\case\n-    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n-    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (ChoiceData self this arg substUpd typ) _envcgchs}\n-    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (ChoiceData self this arg substUpd typ) _envschs}\n+extChEnv tc ch self this arg upd typ = do\n+  env <- getEnv\n+  putEnv $ setEnvChoices (HM.insert (UpdChoice tc ch) (ChoiceData self this arg upd typ) $ envChoices env) env\n \n -- | Extend the environment with a list of new data type definitions.\n-extDatsEnv :: MonadEnv m ph\n+extDatsEnv :: (IsPhase ph, MonadEnv m ph)\n   => HM.HashMap TypeConName DefDataType\n   -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n   -> m ()\n-extDatsEnv hmap = getEnv >>= \\case\n-    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n-    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n-    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n-\n--- | Extend the environment with a new contract id, and the variable to which\n--- the fetched contract is bound.\n-extCidEnv :: MonadEnv m ph\n-  => Expr\n+extDatsEnv hmap = do\n+  env <- getEnv\n+  putEnv $ setEnvDats (hmap `HM.union` envDats env) env\n+\n+-- | Extend the environment with a refreshed contract id, and the variable to\n+-- which the fetched contract is bound. Returns a substitution, mapping the\n+-- given contract id, to the refreshed one.\n+-- While it might seem counter intuitive, the function only refreshes the\n+-- contract id on its first encounter. The reason is that it needs to be able to\n+-- keep track of old bindings.\n+-- Note that instead of overwriting old bindings, the function creates a new\n+-- synonym between the old and new binding.\n+extCidEnv :: (IsPhase ph, MonadEnv m ph)\n+  => Bool\n+  -- ^ Flag denoting whether the contract id should be refreshed.\n+  -- Note that even with the flag on, contract id are only refreshed on their\n+  -- first encounter.\n+  -> Expr\n   -- ^ The contract id expression.\n   -> ExprVarName\n   -- ^ The variable name to which the fetched contract is bound.\n+  -> m ExprSubst\n+extCidEnv b exp var = do\n+  case exp of\n+    -- Filter out any bindings to `_`.\n+    EVar (ExprVarName \"ds2\") -> return emptyExprSubst\n+    _ -> do\n+      prev <- do\n+        { (cur, old) <- lookupCid exp\n+        ; return $ cur : old }\n+        `catchError` (\\_ -> return [])\n+      proj_def <- check_proj_cid exp\n+      (cid, subst) <- expr2cid (b && null prev && proj_def) exp\n+      env <- getEnv\n+      putEnv $ setEnvCids (HM.insert cid (var, prev) $ envCids env) env\n+      return subst\n+  where\n+    -- | Internal function to check whether the given cid has not yet been\n+    -- defined in a different projection.\n+    check_proj_cid :: (IsPhase ph, MonadEnv m ph)\n+      => Expr\n+      -- ^ The cid expression to verify.\n+      -> m Bool\n+    check_proj_cid (ERecProj _ _ (EVar x)) = do\n+      skols <- envSkols <$> getEnv\n+      return $ null [fs' | SkolRec x' fs' <- skols, x == x']\n+    check_proj_cid (EStructProj _ (EVar x)) = do\n+      skols <- envSkols <$> getEnv\n+      return $ null [fs' | SkolRec x' fs' <- skols, x == x']\n+    check_proj_cid _ = return True\n+\n+-- | Extend the environment with an additional precondition, assigned to the\n+-- corresponding template.\n+extPrecond :: (IsPhase ph, MonadEnv m ph)\n+  => Qualified TypeConName\n+  -- ^ The template to assign the precondition to.\n+  -> (Expr -> Expr)\n+  -- ^ The precondition function, taking the `this` variable.\n   -> m ()\n-extCidEnv exp var = do\n-  prev <- do\n-    { (cur, old) <- lookupCid exp\n-    ; return $ cur : old }\n-    `catchError` (\\_ -> return [])\n-  cid <- expr2cid exp\n-  let new = (var, prev)\n-  getEnv >>= \\case\n-    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid new _envvgcids}\n-    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid new _envcgcids}\n-    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid new _envscids}\n+extPrecond tem precond = do\n+  env <- getEnv\n+  putEnv (setEnvPreconds (HM.insert tem precond (envPreconds env)) env)\n \n -- | Extend the environment with additional equality constraints, between a\n -- variable and its field values.\n-extCtrRec :: MonadEnv m ph\n+extCtrRec :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The variable to be asserted.\n   -> [(FieldName, Expr)]\n   -- ^ The fields with their values.\n   -> m ()\n extCtrRec var fields = do\n-  let ctrs = map (\\(f, e) -> (EStructProj f (EVar var), e)) fields\n-  getEnv >>= \\case\n-    env@EnvVG{..} -> putEnv env{_envvgctrs = ctrs ++ _envvgctrs}\n-    env@EnvCG{..} -> putEnv env{_envcgctrs = ctrs ++ _envcgctrs}\n-    env@EnvS{..} -> putEnv env{_envsctrs = ctrs ++ _envsctrs}\n-\n--- TODO: Is one layer of recursion enough?\n--- | Recursively skolemise the given record fields, when they have a record\n--- type. Note that this only works 1 level deep.\n-extRecEnvLvl1 :: MonadEnv m ph\n-  => [(FieldName, Type)]\n-  -- ^ The record fields to skolemise, together with their types.\n+  let ctrs = map (\\(f, e) -> BEq e (EStructProj f (EVar var))) fields\n+  env <- getEnv\n+  putEnv $ setEnvCtrs (ctrs ++ envCtrs env) env\n+\n+-- | Extend the environment with the given constraint.\n+extCtr :: (IsPhase ph, MonadEnv m ph)\n+  => Expr\n+  -- ^ The constraint to add.\n   -> m ()\n-extRecEnvLvl1 = mapM_ step\n-  where\n-    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n-    step (f,typ) = do\n-      { fsRec <- recTypFields typ\n-      ; extRecEnv (fieldName2VarName f) fsRec\n-      }\n-      -- TODO: Temporary fix\n-      `catchError` (\\_ -> return ())\n+extCtr exp = do\n+  let ctrs = toBoolExpr exp\n+  env <- getEnv\n+  putEnv $ setEnvCtrs (ctrs ++ envCtrs env) env\n \n -- | Lookup an expression variable in the environment. Returns `True` if this variable\n -- has been skolemised, or `False` otherwise.\n-lookupVar :: MonadEnv m ph\n+lookupVar :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The expression variable to look up.\n   -> m Bool\n-lookupVar x = getEnv >>= \\case\n-  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n-  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n-  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+lookupVar x = do\n+  skols <- envSkols <$> getEnv\n+  return $ elem (SkolVar x) skols\n \n -- | Lookup a record project in the environment. Returns a boolean denoting\n -- whether or not the record projection has been skolemised.\n-lookupRec :: MonadEnv m ph\n+lookupRec :: (IsPhase ph, MonadEnv m ph)\n   => ExprVarName\n   -- ^ The expression variable on which is being projected.\n   -> FieldName\n   -- ^ The field name which is being projected.\n   -> m Bool\n lookupRec x f = do\n-  skols <- getEnv >>= \\case\n-    EnvVG{..} -> return _envvgskol\n-    EnvCG{..} -> return _envcgskol\n-    EnvS{..} -> return _envsskol\n+  skols <- envSkols <$> getEnv\n   let fields = [ fs | SkolRec y fs <- skols, x == y ]\n   if not (null fields)\n     then return (elem f $ head fields)\n     else return False\n \n -- | Lookup a value name in the environment. Returns its (partially) evaluated\n -- definition, together with the updates it performs.\n-lookupVal :: MonadEnv m ph\n+lookupVal :: (IsPhase ph, MonadEnv m ph)\n   => Qualified ExprValName\n   -- ^ The value name to lookup.\n-  -> m (Expr, UpdateSet ph)\n+  -> m (Maybe (Expr, UpdateSet ph))\n lookupVal val = do\n-  vals <- getEnv >>= \\case\n-    EnvVG{..} -> return _envvgvals\n-    EnvCG{..} -> return _envcgvals\n-    EnvS{..} -> return _envsvals\n-  case HM.lookup val vals of\n-    Just res -> return res\n-    Nothing -> throwError (UnknownValue val)\n+  vals <- envVals <$> getEnv\n+  return $ HM.lookup val vals\n \n -- | Lookup a choice name in the environment. Returns a function which, once\n -- self, this and args have been instantiated, returns the set of updates it\n -- performs. Also returns the return type of the choice.\n-lookupChoice :: MonadEnv m ph\n+lookupChoice :: (IsPhase ph, MonadEnv m ph)\n   => Qualified TypeConName\n   -- ^ The template name in which this choice is defined.\n   -> ChoiceName\n   -- ^ The choice name to lookup.\n-  -> m (Expr -> Expr -> Expr -> UpdateSet ph, Type)\n+  -> m (Maybe (Expr -> Expr -> Expr -> UpdateSet ph, Type))\n lookupChoice tem ch = do\n-  chs <- getEnv >>= \\case\n-    EnvVG{..} -> return HM.empty\n-    EnvCG{..} -> return _envcgchs\n-    EnvS{..} -> return _envschs\n+  chs <- envChoices <$> getEnv\n   case HM.lookup (UpdChoice tem ch) chs of\n-    Nothing -> throwError (UnknownChoice ch)\n-    Just ChoiceData{..} -> return (_cdUpds, _cdType)\n+    Nothing -> return Nothing\n+    Just ChoiceData{..} -> do\n+      let updFunc (self :: Expr) (this :: Expr) (args :: Expr) =\n+            let subst = createExprSubst [(_cdSelf,self),(_cdThis,this),(_cdArgs,args)]\n+            in substituteTm subst _cdUpds\n+      return $ Just (updFunc, _cdType)\n \n -- | Lookup a data type definition in the environment.\n-lookupDataCon :: MonadEnv m ph\n+lookupDataCon :: (IsPhase ph, MonadEnv m ph)\n   => TypeConName\n   -- ^ The data constructor to lookup.\n   -> m DefDataType\n lookupDataCon tc = do\n-  dats <- getEnv >>= \\case\n-    EnvVG{..} -> return _envvgdats\n-    EnvCG{..} -> return _envcgdats\n-    EnvS{..} -> return _envsdats\n+  dats <- envDats <$> getEnv\n   case HM.lookup tc dats of\n     Nothing -> throwError (UnknownDataCons tc)\n     Just def -> return def\n \n -- | Lookup a contract id in the environment. Returns the variable its fetched\n -- contract is bound to, along with a list of any previous bindings.\n-lookupCid :: MonadEnv m ph\n+lookupCid :: (IsPhase ph, MonadEnv m ph)\n   => Expr\n   -- ^ The contract id to lookup.\n   -> m (ExprVarName, [ExprVarName])\n lookupCid exp = do\n-  cid <- expr2cid exp\n-  cids <- getEnv >>= \\case\n-    EnvVG{..} -> return _envvgcids\n-    EnvCG{..} -> return _envcgcids\n-    EnvS{..} -> return _envscids\n+  (cid, _) <- expr2cid False exp\n+  cids <- envCids <$> getEnv\n   case HM.lookup cid cids of\n     Nothing -> throwError $ UnknownCid cid\n     Just var -> return var\n \n--- | Solves the value references by computing the closure of all referenced\n--- values, for each value in the environment.\n--- It thus empties `_usValue` by collecting all updates made by this closure.\n-solveValueReferences :: Env 'ValueGathering -> Env 'ChoiceGathering\n-solveValueReferences EnvVG{..} =\n-  let valhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond empty_upds [] hmap ref) _envvgvals (HM.keys _envvgvals)\n-  in EnvCG _envvgskol (convertHMap valhmap) _envvgdats _envvgcids _envvgctrs HM.empty\n-  where\n-    lookup_ref :: Qualified ExprValName\n-      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n-      -> (Expr, UpdateSet 'ValueGathering)\n-    lookup_ref ref hmap = fromMaybe (error \"Impossible: Undefined value ref while solving\")\n-      (HM.lookup ref hmap)\n-\n-    get_refs :: (Expr, UpdateSet 'ValueGathering)\n-      -> ([Cond (Qualified ExprValName)], (Expr, UpdateSet 'ValueGathering))\n-    get_refs (e, upds@UpdateSetVG{..}) = (_usvgValue, (e, upds{_usvgValue = []}))\n-\n-    ext_upds :: (Expr, UpdateSet 'ValueGathering) -> (Expr, UpdateSet 'ValueGathering)\n-      -> (Expr, UpdateSet 'ValueGathering)\n-    ext_upds (e, upds1)  (_, upds2) = (e, concatUpdateSet upds1 upds2)\n-\n-    intro_cond :: Cond (Expr, UpdateSet 'ValueGathering)\n-      -> (Expr, UpdateSet 'ValueGathering)\n-    -- Note that the expression is not important here, as it will be ignored in\n-    -- `ext_upds` later on.\n-    intro_cond (Determined x) = x\n-    intro_cond (Conditional cond cx cy) =\n-      let xs = map intro_cond cx\n-          ys = map intro_cond cy\n-          e = fst $ head xs\n-          updx = foldl concatUpdateSet emptyUpdateSet $ map snd xs\n-          updy = foldl concatUpdateSet emptyUpdateSet $ map snd ys\n-      in (e, introCond $ createCond cond updx updy)\n-\n-    empty_upds :: (Expr, UpdateSet 'ValueGathering)\n-      -> (Expr, UpdateSet 'ValueGathering)\n-    empty_upds (e, _) = (e, emptyUpdateSet)\n-\n-    convertHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n-      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering)\n-    convertHMap = HM.map (second updateSetVG2CG)\n-\n-    updateSetVG2CG :: UpdateSet 'ValueGathering -> UpdateSet 'ChoiceGathering\n-    updateSetVG2CG UpdateSetVG{..} = if null _usvgValue\n-      then UpdateSetCG _usvgUpdate _usvgChoice\n-      else error \"Impossible: There should be no references remaining after value solving\"\n-\n--- | Solves the choice references by computing the closure of all referenced\n--- choices, for each choice in the environment.\n--- It thus empties `_usChoice` by collecting all updates made by this closure.\n-solveChoiceReferences :: Env 'ChoiceGathering -> Env 'Solving\n-solveChoiceReferences EnvCG{..} =\n-  let chhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond empty_upds [] hmap ref) _envcgchs (HM.keys _envcgchs)\n-      chshmap = convertChHMap chhmap\n-      valhmap = HM.map (inlineChoices chshmap) _envcgvals\n-  in EnvS _envcgskol valhmap _envcgdats _envcgcids _envcgctrs chshmap\n-  where\n-    lookup_ref :: UpdChoice\n-      -> HM.HashMap UpdChoice (ChoiceData 'ChoiceGathering)\n-      -> ChoiceData 'ChoiceGathering\n-    lookup_ref upd hmap = fromMaybe (error \"Impossible: Undefined choice ref while solving\")\n-      (HM.lookup upd hmap)\n-\n-    get_refs :: ChoiceData 'ChoiceGathering\n-      -> ([Cond UpdChoice], ChoiceData 'ChoiceGathering)\n-    -- TODO: This is gonna result in a ton of substitutions\n-    get_refs chdat@ChoiceData{..} =\n-      -- TODO: This seems to be a rather common pattern. Abstract to reduce duplication.\n-      let chos = _uscgChoice $ _cdUpds (EVar _cdSelf) (EVar _cdThis) (EVar _cdArgs)\n-          updfunc1 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n-            let upds@UpdateSetCG{..} = _cdUpds selfexp thisexp argsexp\n-            in upds{_uscgChoice = []}\n-      in (chos, chdat{_cdUpds = updfunc1})\n-\n-    ext_upds :: ChoiceData 'ChoiceGathering\n-      -> ChoiceData 'ChoiceGathering\n-      -> ChoiceData 'ChoiceGathering\n-    ext_upds chdat1 chdat2 =\n-      let updfunc (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n-            _cdUpds chdat1 selfexp thisexp argsexp `concatUpdateSet`\n-              _cdUpds chdat2 selfexp thisexp argsexp\n-      in chdat1{_cdUpds = updfunc}\n-\n-    intro_cond :: GenPhase ph\n-      => Cond (ChoiceData ph)\n-      -> ChoiceData ph\n-    -- Note that the expression and return type is not important here, as it\n-    -- will be ignored in `ext_upds` later on.\n-    intro_cond (Determined x) = x\n-    intro_cond (Conditional cond cdatxs cdatys) =\n-      let datxs = map intro_cond cdatxs\n-          datys = map intro_cond cdatys\n-          updfunc (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n-            introCond (createCond cond\n-              (foldl\n-                (\\upd dat -> upd `concatUpdateSet` _cdUpds dat selfexp thisexp argsexp)\n-                emptyUpdateSet datxs)\n-              (foldl\n-                (\\upd dat -> upd `concatUpdateSet` _cdUpds dat selfexp thisexp argsexp)\n-                emptyUpdateSet datys))\n-      in (head datxs){_cdUpds = updfunc}\n-\n-    empty_upds :: ChoiceData 'ChoiceGathering\n-      -> ChoiceData 'ChoiceGathering\n-    empty_upds dat = dat{_cdUpds = \\ _ _ _ -> emptyUpdateSet}\n-\n-    inlineChoices :: HM.HashMap UpdChoice (ChoiceData 'Solving)\n-      -> (Expr, UpdateSet 'ChoiceGathering)\n-      -> (Expr, UpdateSet 'Solving)\n-    inlineChoices chshmap (exp, UpdateSetCG{..}) =\n-      let lookupRes = map\n-            (intro_cond . fmap (\\ch -> fromMaybe (error \"Impossible: missing choice while solving\") (HM.lookup ch chshmap)))\n-            _uscgChoice\n-          chupds = concatMap (\\ChoiceData{..} -> _ussUpdate $ _cdUpds (EVar _cdSelf) (EVar _cdThis) (EVar _cdArgs)) lookupRes\n-      in (exp, UpdateSetS (_uscgUpdate ++ chupds))\n-\n-    convertChHMap :: HM.HashMap UpdChoice (ChoiceData 'ChoiceGathering)\n-      -> HM.HashMap UpdChoice (ChoiceData 'Solving)\n-    convertChHMap = HM.map (\\chdat@ChoiceData{..} ->\n-      chdat{_cdUpds = \\(selfExp :: Expr) (thisExp :: Expr) (argsExp :: Expr) ->\n-        updateSetCG2S $ _cdUpds selfExp thisExp argsExp})\n-\n-    updateSetCG2S :: UpdateSet 'ChoiceGathering -> UpdateSet 'Solving\n-    updateSetCG2S UpdateSetCG{..} = if null _uscgChoice\n-      then UpdateSetS _uscgUpdate\n-      else error \"Impossible: There should be no references remaining after choice solving\"\n-\n--- | Solves a single reference by recursively inlining the references into updates.\n-solveReference :: forall updset ref. (Eq ref, Hashable ref)\n-  => (ref -> HM.HashMap ref updset -> updset)\n-  -- ^ Function for looking up references in the update set.\n-  -> (updset -> ([Cond ref], updset))\n-  -- ^ Function popping the references from the update set.\n-  -> (updset -> updset -> updset)\n-  -- ^ Function for concatinating update sets.\n-  -> (Cond updset -> updset)\n-  -- ^ Function for moving conditionals inside the update set.\n-  -> (updset -> updset)\n-  -- ^ Function for emptying a given update set of all updates.\n-  -> [ref]\n-  -- ^ The references which have already been visited.\n-  -> HM.HashMap ref updset\n-  -- ^ The hashmap mapping references to update sets.\n-  -> ref\n-  -- ^ The reference to be solved.\n-  -> (updset, HM.HashMap ref updset)\n-solveReference lookup getRefs extUpds introCond emptyUpds vis hmap0 ref0 =\n-  -- Lookup updates performed by the given reference, and split in new\n-  -- references and reference-free updates.\n-  let upd0 = lookup ref0 hmap0\n-      (refs, upd1) = getRefs upd0\n-  -- Check for loops. If the references has already been visited, then the\n-  -- reference should be flagged as recursive.\n-  in if ref0 `elem` vis\n-  -- TODO: Recursion!\n-    then trace \"Recursion!\" (upd1, hmap0) -- TODO: At least remove the references?\n-    -- When no recursion has been detected, continue inlining the references.\n-    else let (upd2, hmap1) = foldl handle_ref (upd1, hmap0) refs\n-      in (upd1, HM.insert ref0 upd2 hmap1)\n-  where\n-    -- | Extend the closure by computing and adding the reference closure for\n-    -- the given reference.\n-    handle_ref :: (updset, HM.HashMap ref updset)\n-      -- ^ The current closure (update set) and the current map for reference to update.\n-      -> Cond ref\n-      -- ^ The reference to be computed and added.\n-      -> (updset, HM.HashMap ref updset)\n-    -- For a simple reference, the closure is computed straightforwardly.\n-    handle_ref (upd_i0, hmap_i0) (Determined ref_i) =\n-      let (upd_i1, hmap_i1) =\n-            solveReference lookup getRefs extUpds introCond emptyUpds (ref0:vis) hmap_i0 ref_i\n-      in (extUpds upd_i0 upd_i1, hmap_i1)\n-    -- A conditional reference is more involved, as the conditional needs to be\n-    -- preserved in the computed closure (update set).\n-    handle_ref (upd_i0, hmap_i0) (Conditional cond refs_ia refs_ib) =\n-          -- Construct an update set without any updates.\n-      let upd_i0_empty = emptyUpds upd_i0\n-          -- Compute the closure for the true-case.\n-          (upd_ia, hmap_ia) = foldl handle_ref (upd_i0_empty, hmap_i0) refs_ia\n-          -- Compute the closure for the false-case.\n-          (upd_ib, hmap_ib) = foldl handle_ref (upd_i0_empty, hmap_ia) refs_ib\n-          -- Move the conditional inwards, in the update set.\n-          upd_i1 = extUpds upd_i0 $ introCond $ createCond cond upd_ia upd_ib\n-      in (upd_i1, hmap_ib)\n-\n--- TODO: This should work recursively\n -- | Lookup the field names and corresponding types, for a given record type\n--- constructor name.\n-recTypConFields :: MonadEnv m ph\n+-- constructor name, if possible.\n+-- TODO: At the moment, this does not work recursively for nested type\n+-- constructors. This might be a useful extension later on.\n+recTypConFields :: (IsPhase ph, MonadEnv m ph)\n   => TypeConName\n   -- ^ The record type constructor name to lookup.\n-  -> m [(FieldName,Type)]\n+  -> m (Maybe [(FieldName,Type)])\n recTypConFields tc = lookupDataCon tc >>= \\dat -> case dataCons dat of\n-  DataRecord fields -> return fields\n-  _ -> throwError ExpectRecord\n+  DataRecord fields -> return $ Just fields\n+  _ -> return Nothing\n \n--- | Lookup the fields for a given record type.\n-recTypFields :: MonadEnv m ph\n+-- | Lookup the fields for a given record type, if possible.\n+recTypFields :: (IsPhase ph, MonadEnv m ph)\n   => Type\n   -- ^ The type to lookup.\n-  -> m [FieldName]\n+  -> m (Maybe [(FieldName,Type)])\n recTypFields (TCon tc) = do\n-  fields <- recTypConFields $ qualObject tc\n-  return $ map fst fields\n-recTypFields (TStruct fs) = return $ map fst fs\n-recTypFields _ = throwError ExpectRecord\n+  recTypConFields $ qualObject tc\n+recTypFields (TStruct fs) = return $ Just fs\n+recTypFields (TApp (TBuiltin BTContractId) t) = recTypFields t\n+recTypFields _ = return Nothing\n \n -- | Lookup the record fields and corresponding values from a given expression.\n-recExpFields :: MonadEnv m ph\n+recExpFields :: (IsPhase ph, MonadEnv m ph)\n   => Expr\n   -- ^ The expression to lookup.\n   -> m (Maybe [(FieldName, Expr)])\n recExpFields (EVar x) = do\n-  skols <- getEnv >>= \\case\n-    EnvVG{..} -> return _envvgskol\n-    EnvCG{..} -> return _envcgskol\n-    EnvS{..} -> return _envsskol\n+  skols <- envSkols <$> getEnv\n   let fss = [ fs | SkolRec y fs <- skols, x == y ]\n   if not (null fss)\n-    -- TODO: I would prefer `this.amount` here\n-    then return $ Just $ zip (head fss) (map (EVar . fieldName2VarName) $ head fss)\n+    then return $ Just $ zip (head fss) (map (\\f -> EStructProj f (EVar x)) $ head fss)"
  },
  {
    "id" : "377c3f2f-7d58-4443-ab39-2d32eed41c8d",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "d7ec9fa1-563a-4df7-b395-bd25d50943e2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We generally avoid TemplateHaskell for the most part. Part of that is just a code style guideline since we generally try write fairly simple Haskell code but for TemplateHaskell there is also a technical resaon: We use a statically linked GHC (I won’t go into the reasons here but I’m happy to expand on that in another context) which makes TemplateHaskell very slow. So if you really do want to use template haskell. You are better off putting all the template Haskell code into a separate Bazel target that changes rarely (Bazel caches at the granularity of individual targets). Otherwise, you will suffer from long compile times while working on this.\r\n\r\nHowever, we also mostly avoid lenses. This is not quite as strict and there is not really a technical reason for this but I’m not aware of any module that uses them as pervasively as you use them here.\r\n\r\nSo overall, I think you’re better off removing the TH lens generation, switch away from using lenses by default for everything and potentially define a few lenses by hand for the things where they do provide a significant benefit.",
        "createdAt" : "2020-04-07T20:16:35Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,138 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet"
  },
  {
    "id" : "e2d8e79e-8f86-49d7-b7c1-11af09d2d200",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "d11235a8-a4ae-474d-9c1b-241adc0f19e2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there some deeper meaning behind calling this `Delta` apart from the fact that this is commonly used in type theory? If not, maybe just call it `Environment` or some variation thereof?",
        "createdAt" : "2020-04-07T20:18:05Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,138 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier"
  },
  {
    "id" : "44b3a567-753f-4d42-9087-f09cb982775a",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "01b00396-b812-4ceb-a573-2200cff2e199",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wouldn’t worry too much about duplicating code for now.",
        "createdAt" : "2020-04-07T20:21:38Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,138 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier\n+data Delta = Delta\n+  { _devars :: ![ExprVarName]\n+    -- ^ The skolemised term variables.\n+  , _devals :: !(HashMap (Qualified ExprValName) (Expr, UpdateSet))\n+    -- ^ The bound values.\n+  , _dchs :: !(HashMap ((Qualified TypeConName), ChoiceName) UpdateSet)\n+    -- ^ The set of relevant choices.\n+  -- TODO: split this off into data types for readability?\n+  }\n+\n+makeLenses ''Delta\n+\n+emptyDelta :: Delta\n+emptyDelta = Delta [] empty empty\n+\n+concatDelta :: Delta -> Delta -> Delta\n+concatDelta (Delta vars1 vals1 chs1) (Delta vars2 vals2 chs2) =\n+  Delta (vars1 ++ vars2) (union vals1 vals2) (union chs1 chs2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first)\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadDelta m = (MonadError Error m, MonadReader Delta m)\n+\n+runDelta :: ReaderT Delta (Either Error) a -> Either Error a\n+runDelta act = runReaderT act emptyDelta\n+\n+-- | Run a computation in the current environment, with an additional\n+-- environment extension.\n+introDelta :: MonadDelta m => Delta -> m a -> m a\n+introDelta delta = local (concatDelta delta)\n+\n+extVarDelta :: MonadDelta m => ExprVarName -> m a -> m a\n+extVarDelta x = local (over devars ((:) x))\n+\n+lookupDExprVar :: MonadDelta m => ExprVarName -> m ()\n+lookupDExprVar x = ask >>= \\ del -> unless (elem x $ del ^. devars)\n+                                          $ throwError $ EUnknownExprVar x\n+\n+lookupDVal :: MonadDelta m => (Qualified ExprValName) -> m (Expr, UpdateSet)\n+lookupDVal w = view (devals . at w) >>= match _Just (EEmptyCase)\n+-- TODO: This is a random error. The thing we really want to write is:\n+-- lookupDVal w = view (devals . at w) >>= match _Just (EUnknownDefinition $ LEValue w)\n+-- The issue here is that our values are currently stored in Delta instead\n+-- of in the world like in the type checker.\n+-- This means that we can't throw the error we want to throw here.\n+-- 2 options:\n+--   + either define our own errors, as they don't correspond 100% to the type\n+--   checking errors anyway.\n+--   + or create our own world environment to store values. This also makes\n+--   sense as these values work similar to how they work in the type checker,\n+--   except that we need to store a partially evaluated definition as well.\n+-- Both approaches make sense, but both imply a lot of code duplication, so they"
  },
  {
    "id" : "9b29e402-1392-493a-819f-0dd733c7d4b9",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "893b13d9-e6a9-4a0b-adb7-f274ec0c0b89",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There are a few more unnecessary parentheses around, but `hlint` should catch that in the end anyway.\r\n```suggestion\r\n  , _dchs :: !(HashMap (Qualified TypeConName, ChoiceName) UpdateSet)\r\n```",
        "createdAt" : "2020-04-08T07:56:54Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,138 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier\n+data Delta = Delta\n+  { _devars :: ![ExprVarName]\n+    -- ^ The skolemised term variables.\n+  , _devals :: !(HashMap (Qualified ExprValName) (Expr, UpdateSet))\n+    -- ^ The bound values.\n+  , _dchs :: !(HashMap ((Qualified TypeConName), ChoiceName) UpdateSet)"
  },
  {
    "id" : "a63fe7e3-5c8a-40f6-9e3e-b1c8163b9800",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "b3a16434-6910-40f8-ae11-f56e43207c12",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't think lenses buy us anything here. I also think `a >>= \\x -> ...` is a sign to use `do` notation.\r\n```suggestion\r\nlookupDExprVar x = do\r\n  del <- ask\r\n  unless (x `elem` _devars del) $ throwError $ EUnknownExprVar x\r\n```",
        "createdAt" : "2020-04-08T08:02:43Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,138 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier\n+data Delta = Delta\n+  { _devars :: ![ExprVarName]\n+    -- ^ The skolemised term variables.\n+  , _devals :: !(HashMap (Qualified ExprValName) (Expr, UpdateSet))\n+    -- ^ The bound values.\n+  , _dchs :: !(HashMap ((Qualified TypeConName), ChoiceName) UpdateSet)\n+    -- ^ The set of relevant choices.\n+  -- TODO: split this off into data types for readability?\n+  }\n+\n+makeLenses ''Delta\n+\n+emptyDelta :: Delta\n+emptyDelta = Delta [] empty empty\n+\n+concatDelta :: Delta -> Delta -> Delta\n+concatDelta (Delta vars1 vals1 chs1) (Delta vars2 vals2 chs2) =\n+  Delta (vars1 ++ vars2) (union vals1 vals2) (union chs1 chs2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first)\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadDelta m = (MonadError Error m, MonadReader Delta m)\n+\n+runDelta :: ReaderT Delta (Either Error) a -> Either Error a\n+runDelta act = runReaderT act emptyDelta\n+\n+-- | Run a computation in the current environment, with an additional\n+-- environment extension.\n+introDelta :: MonadDelta m => Delta -> m a -> m a\n+introDelta delta = local (concatDelta delta)\n+\n+extVarDelta :: MonadDelta m => ExprVarName -> m a -> m a\n+extVarDelta x = local (over devars ((:) x))\n+\n+lookupDExprVar :: MonadDelta m => ExprVarName -> m ()\n+lookupDExprVar x = ask >>= \\ del -> unless (elem x $ del ^. devars)\n+                                          $ throwError $ EUnknownExprVar x"
  },
  {
    "id" : "f20bdedd-ed63-4cad-9235-4c96a909a496",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "2b77d609-dfff-4fea-ad47-e7383a37837a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I guess you want `unionWith concatUpdateSet`.",
        "createdAt" : "2020-04-09T07:44:36Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,143 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, _devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta, setDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier\n+data Delta = Delta\n+  { _devars :: ![ExprVarName]\n+    -- ^ The skolemised term variables.\n+  , _devals :: !(HashMap (Qualified ExprValName) (Expr, UpdateSet))\n+    -- ^ The bound values.\n+  , _dchs :: !(HashMap (Qualified TypeConName, ChoiceName) UpdateSet)\n+    -- ^ The set of relevant choices.\n+  -- TODO: split this off into data types for readability?\n+  }\n+\n+makeLenses ''Delta\n+\n+emptyDelta :: Delta\n+emptyDelta = Delta [] empty empty\n+\n+concatDelta :: Delta -> Delta -> Delta\n+concatDelta (Delta vars1 vals1 chs1) (Delta vars2 vals2 chs2) =\n+  Delta (vars1 ++ vars2) (vals1 `union` vals2) (chs1 `union` chs2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first)"
  },
  {
    "id" : "4b94ea73-613e-4340-9963-78c36bd3d60b",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "19722428-210c-4f4f-ba2b-f9b09ed8063e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Maybe `withDelta` would communicate your intent better?",
        "createdAt" : "2020-04-09T07:45:42Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,143 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, _devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta, setDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier\n+data Delta = Delta\n+  { _devars :: ![ExprVarName]\n+    -- ^ The skolemised term variables.\n+  , _devals :: !(HashMap (Qualified ExprValName) (Expr, UpdateSet))\n+    -- ^ The bound values.\n+  , _dchs :: !(HashMap (Qualified TypeConName, ChoiceName) UpdateSet)\n+    -- ^ The set of relevant choices.\n+  -- TODO: split this off into data types for readability?\n+  }\n+\n+makeLenses ''Delta\n+\n+emptyDelta :: Delta\n+emptyDelta = Delta [] empty empty\n+\n+concatDelta :: Delta -> Delta -> Delta\n+concatDelta (Delta vars1 vals1 chs1) (Delta vars2 vals2 chs2) =\n+  Delta (vars1 ++ vars2) (vals1 `union` vals2) (chs1 `union` chs2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first)\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadDelta m = (MonadError Error m, MonadReader Delta m)\n+\n+runDelta :: ReaderT Delta (Either Error) a -> Either Error a\n+runDelta act = runReaderT act emptyDelta\n+\n+-- | Run a computation in the current environment, with an additional\n+-- environment extension.\n+introDelta :: MonadDelta m => Delta -> m a -> m a\n+introDelta delta = local (concatDelta delta)\n+\n+-- TODO: This is a bit strange in a reader monad.\n+-- Figure out a way to extend, instead of overwrite every time."
  },
  {
    "id" : "dac5953b-eb2d-4b09-a49d-da276e120338",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "42ff934f-0371-4a89-bc66-1d1ab6a752fa",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Would it make sense to have a function\r\n```haskell\r\nvarDelta :: ExprVarName -> Delta\r\n```\r\nand use `introDelta (varDelta x)` instead of `extVarDelta x`? At least to me, these primitives feel \"more orthogonal\" to me.",
        "createdAt" : "2020-04-09T07:47:24Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,143 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, _devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta, setDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier\n+data Delta = Delta\n+  { _devars :: ![ExprVarName]\n+    -- ^ The skolemised term variables.\n+  , _devals :: !(HashMap (Qualified ExprValName) (Expr, UpdateSet))\n+    -- ^ The bound values.\n+  , _dchs :: !(HashMap (Qualified TypeConName, ChoiceName) UpdateSet)\n+    -- ^ The set of relevant choices.\n+  -- TODO: split this off into data types for readability?\n+  }\n+\n+makeLenses ''Delta\n+\n+emptyDelta :: Delta\n+emptyDelta = Delta [] empty empty\n+\n+concatDelta :: Delta -> Delta -> Delta\n+concatDelta (Delta vars1 vals1 chs1) (Delta vars2 vals2 chs2) =\n+  Delta (vars1 ++ vars2) (vals1 `union` vals2) (chs1 `union` chs2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first)\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadDelta m = (MonadError Error m, MonadReader Delta m)\n+\n+runDelta :: ReaderT Delta (Either Error) a -> Either Error a\n+runDelta act = runReaderT act emptyDelta\n+\n+-- | Run a computation in the current environment, with an additional\n+-- environment extension.\n+introDelta :: MonadDelta m => Delta -> m a -> m a\n+introDelta delta = local (concatDelta delta)\n+\n+-- TODO: This is a bit strange in a reader monad.\n+-- Figure out a way to extend, instead of overwrite every time.\n+setDelta :: MonadDelta m => Delta -> m a -> m a\n+setDelta delta = local (const delta)\n+\n+extVarDelta :: MonadDelta m => ExprVarName -> m a -> m a\n+extVarDelta x = local (over devars ((:) x))"
  },
  {
    "id" : "37b35bf3-6301-43be-8816-31b9880b04ab",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "d15b13b5-3a17-485b-a1ff-6de4235f21a2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Nah, I wouldn't bother with it for now. You don't want to tie yourself into unnecessary constraints. 😃",
        "createdAt" : "2020-04-09T07:54:35Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,143 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, _devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta, setDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }\n+\n+makeLenses ''UpdateSet\n+\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] []\n+\n+concatUpdateSet :: UpdateSet -> UpdateSet -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1) (UpdateSet cres2 arcs2 chos2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2)\n+\n+-- | The environment for the DAML-LF verifier\n+data Delta = Delta\n+  { _devars :: ![ExprVarName]\n+    -- ^ The skolemised term variables.\n+  , _devals :: !(HashMap (Qualified ExprValName) (Expr, UpdateSet))\n+    -- ^ The bound values.\n+  , _dchs :: !(HashMap (Qualified TypeConName, ChoiceName) UpdateSet)\n+    -- ^ The set of relevant choices.\n+  -- TODO: split this off into data types for readability?\n+  }\n+\n+makeLenses ''Delta\n+\n+emptyDelta :: Delta\n+emptyDelta = Delta [] empty empty\n+\n+concatDelta :: Delta -> Delta -> Delta\n+concatDelta (Delta vars1 vals1 chs1) (Delta vars2 vals2 chs2) =\n+  Delta (vars1 ++ vars2) (vals1 `union` vals2) (chs1 `union` chs2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first)\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadDelta m = (MonadError Error m, MonadReader Delta m)\n+\n+runDelta :: ReaderT Delta (Either Error) a -> Either Error a\n+runDelta act = runReaderT act emptyDelta\n+\n+-- | Run a computation in the current environment, with an additional\n+-- environment extension.\n+introDelta :: MonadDelta m => Delta -> m a -> m a\n+introDelta delta = local (concatDelta delta)\n+\n+-- TODO: This is a bit strange in a reader monad.\n+-- Figure out a way to extend, instead of overwrite every time.\n+setDelta :: MonadDelta m => Delta -> m a -> m a\n+setDelta delta = local (const delta)\n+\n+extVarDelta :: MonadDelta m => ExprVarName -> m a -> m a\n+extVarDelta x = local (over devars ((:) x))\n+\n+lookupDExprVar :: MonadDelta m => ExprVarName -> m ()\n+lookupDExprVar x = ask >>= \\ del -> unless (elem x $ _devars del)\n+                                          $ throwError $ EUnknownExprVar x\n+\n+lookupDVal :: MonadDelta m => Qualified ExprValName -> m (Expr, UpdateSet)\n+lookupDVal w = view (devals . at w) >>= match _Just EEmptyCase\n+-- TODO: This is a random error. The thing we really want to write is:\n+-- lookupDVal w = view (devals . at w) >>= match _Just (EUnknownDefinition $ LEValue w)\n+-- The issue here is that our values are currently stored in Delta instead\n+-- of in the world like in the type checker.\n+-- This means that we can't throw the error we want to throw here.\n+-- 2 options:\n+--   + either define our own errors, as they don't correspond 100% to the type\n+--   checking errors anyway.\n+--   + or create our own world environment to store values. This also makes\n+--   sense as these values work similar to how they work in the type checker,\n+--   except that we need to store a partially evaluated definition as well.\n+-- Both approaches make sense, but both imply a lot of code duplication, so they\n+-- don't sound that enticing...\n+\n+lookupDChoice :: MonadDelta m => Qualified TypeConName -> ChoiceName\n+             -> m UpdateSet\n+lookupDChoice tem ch = view (dchs . at (tem, ch)) >>= match _Just EEmptyCase\n+-- TODO: Random error.\n+\n+-- | Helper functions mirrored from Env.\n+-- TODO: Reduce duplication by abstracting over MonadGamma and MonadDelta?"
  },
  {
    "id" : "65e86ef2-54b8-4aa0-9775-fc79b2dcca6c",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "69752045-8db0-4631-a2f0-fdcd427e3465",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Don't we need to account for fetches as well?",
        "createdAt" : "2020-04-09T09:14:34Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,143 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE RankNTypes #-}\n+{-# LANGUAGE TemplateHaskell #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Delta\n+  , MonadDelta, devars, _devals\n+  , UpdateSet(..)\n+  , UpdCreate(..), usCre, usArc, usCho\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , runDelta\n+  , emptyDelta, setDelta\n+  , introDelta, extVarDelta\n+  , lookupDExprVar, lookupDVal, lookupDChoice\n+  , concatDelta\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  ) where\n+\n+import Control.Lens hiding (Context)\n+import Control.Monad.Error.Class (MonadError (..))\n+import Control.Monad.Reader\n+import Data.HashMap.Strict (HashMap, union, empty)\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.TypeChecker.Error\n+\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  }"
  },
  {
    "id" : "aa1f497e-3436-4b78-aa9d-db6180ac0d64",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "d5b42be4-7509-40dc-8919-017599d13cb3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This does not necessarily rename to a fresh name. For instance, `x` could be renamed to `x1` which is already in use. Is this intended?",
        "createdAt" : "2020-04-29T08:42:04Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 251,
    "diffHunk" : "@@ -0,0 +1,525 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , UpdCreate(..)\n+  , UpdArchive(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , solveValueUpdatesEnv\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- | Data type denoting a create update.\n+data UpdCreate = UpdCreate\n+  { _creTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _creField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+  deriving Show\n+-- | Data type denoting an archive update.\n+data UpdArchive = UpdArchive\n+  { _arcTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _arcField :: ![(FieldName, Expr)]\n+    -- ^ The fields to be verified, together with their value.\n+  }\n+  deriving Show\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving Show\n+\n+-- | The List of updates being performed\n+data UpdateSet = UpdateSet\n+  { _usCre :: ![UpdCreate]\n+    -- ^ The list of create updates.\n+  , _usArc :: ![UpdArchive]\n+    -- ^ The list of archive updates.\n+  , _usCho :: ![UpdChoice]\n+    -- ^ The list of choice updates.\n+  , _usVal :: ![Qualified ExprValName]\n+    -- ^ The list of referenced values. These will be replaced by their\n+    -- respective updates after solving.\n+    -- Note that this should be empty after the `ValuePhase`.\n+  }\n+  deriving Show\n+\n+-- | Create an empty update set.\n+emptyUpdateSet :: UpdateSet\n+emptyUpdateSet = UpdateSet [] [] [] []\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet\n+concatUpdateSet (UpdateSet cres1 arcs1 chos1 vals1) (UpdateSet cres2 arcs2 chos2 vals2) =\n+  UpdateSet (cres1 ++ cres2) (arcs1 ++ arcs2) (chos1 ++ chos2) (vals1 ++ vals2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote it's number.\n+genRenamedVar :: MonadEnv m\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh"
  },
  {
    "id" : "58600a3e-a5ad-4d25-a858-2f355612e9ed",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "0f563e7e-50a1-4f1b-ae1d-2ec257fc1cad",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n-- introduced to avoid having to use imported daml-lf prelude functions.\r\n```\r\nAlthough I’m not sure I understand what this comment is trying to tell me.",
        "createdAt" : "2020-05-08T11:35:44Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions."
  },
  {
    "id" : "2d36fcd7-2ad5-41de-a863-d431ed2bb4ee",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "99e74fa8-3fb9-4f50-9d12-fc1f73d4441f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n  deriving (Show, Functor)\r\n```",
        "createdAt" : "2020-05-08T11:38:13Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)"
  },
  {
    "id" : "d30f32b2-8bf0-41cf-9770-8a6c2247102d",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "5a5764e9-1292-4de5-b58d-ad9416db37f7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You don’t seem to be making use of this typeclass. You only have one instance so you can just make that implementation specific to `UpdateSet ph` and kill this typeclass.",
        "createdAt" : "2020-05-08T11:39:52Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where"
  },
  {
    "id" : "ce6a0826-4455-4577-959e-917f1d320555",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "866053e1-7252-4edd-878c-49dae5bb07ab",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n-- | Data type denoting an exercised choice.\r\n```",
        "createdAt" : "2020-05-11T08:08:25Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update."
  },
  {
    "id" : "3628d317-8e66-4325-a555-a360f4cb2936",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "e3c22df8-58d9-4a1f-902a-e77e28a5fd24",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I guess record projections just occur particularly often so it’s important to add them here while other expressions (e.g. a variant with a contract id that you can select) are not common enough so we can ignore them at least for now?",
        "createdAt" : "2020-05-11T08:14:55Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 266,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName"
  },
  {
    "id" : "cbc68fcb-3029-43d5-9f3b-c3a1a3aecf9b",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "6e5f2ab1-81c4-4240-89b1-8c664792ff9a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n-- | Lookup an expression variable in the environment. Returns `True` if this variable\r\n-- has been skolemised, or `False` otherwise.\r\n```",
        "createdAt" : "2020-05-11T08:24:55Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't."
  },
  {
    "id" : "3a6b8811-ec10-44d3-99e9-25ce31ca75bf",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "fe5d1690-d20b-4f6e-a8fa-d59a01c3a5b1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "My impression is that you're using GADTs here to link the `UpdateSet` types from the three different phases with their `Env` counterparts. This problem might be better solved with associated data types similar to\r\n```haskell\r\nclass IsPhase (ph :: Phase) where\r\n  data UpdateSet ph\r\n  data Env ph\r\n```\r\nLet's try that out in a follow-up PR.",
        "createdAt" : "2020-05-11T08:26:44Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 173,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where"
  },
  {
    "id" : "0b60246c-2e9c-4097-98e7-5c548248dc05",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "cc313a0e-0ece-40e9-bf96-d9ba2b3fb203",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "How so?",
        "createdAt" : "2020-05-11T08:26:59Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified."
  },
  {
    "id" : "b95a5155-f3ab-44d1-be62-1c6b9805f7b3",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "e9a1a972-0b9b-4c26-ba96-7290789959c3",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":+1:",
        "createdAt" : "2020-05-11T08:27:53Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified.\n+-- | Helper function to lookup a value definition in a HashMap.\n+lookupValInHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> Maybe (Expr, UpdateSet ph)\n+lookupValInHMap hmap val = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\name _ -> qualObject name == qualObject val && qualModule name == qualModule val) hmap\n+\n+-- TODO: Does this really need to be a seperate function?\n+-- | Helper function to lookup a choice in a HashMap. Returns the variables for\n+-- self, this and args used, as well as a function which, given the values for\n+-- self, this and args, produces the list of updates performed by this choice.\n+lookupChoInHMap :: HM.HashMap UpdChoice\n+    (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> TypeConName\n+  -- ^ The template in which the choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> Maybe (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+-- TODO: This TypeConName should be qualified\n+-- TODO: The type con name really should be taken into account here"
  },
  {
    "id" : "a1c0eaee-dfb8-4590-973b-176fec5623a9",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "b248c6a6-f7a8-44af-a7c8-3350f9e8295a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Are you aware that there is `PRSelf` for references into the same package? You might want to rewrite all these references into `PRImport <own-package-id>` during package loading.",
        "createdAt" : "2020-05-11T08:37:43Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified."
  },
  {
    "id" : "995d1ce6-ac9c-43b1-9454-82e1a6907a4f",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "c8b45c2f-563e-4a36-92c9-bf50badb4d37",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Don't we have `(==)` in `Qualified`? But maybe it's relating to your the package reference problem mentioned above.",
        "createdAt" : "2020-05-11T08:39:30Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified.\n+-- | Helper function to lookup a value definition in a HashMap.\n+lookupValInHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> Maybe (Expr, UpdateSet ph)\n+lookupValInHMap hmap val = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\name _ -> qualObject name == qualObject val && qualModule name == qualModule val) hmap"
  },
  {
    "id" : "f8882f4f-c7db-4438-9cb3-08e175dfd88e",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "e4904cd5-bccf-4ca0-bc4d-912cc8630829",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`rec` is not the best prefix when both \"record\" and \"recursion\" are common words in your problem domain. 😄",
        "createdAt" : "2020-05-11T08:41:59Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 800,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified.\n+-- | Helper function to lookup a value definition in a HashMap.\n+lookupValInHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> Maybe (Expr, UpdateSet ph)\n+lookupValInHMap hmap val = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\name _ -> qualObject name == qualObject val && qualModule name == qualModule val) hmap\n+\n+-- TODO: Does this really need to be a seperate function?\n+-- | Helper function to lookup a choice in a HashMap. Returns the variables for\n+-- self, this and args used, as well as a function which, given the values for\n+-- self, this and args, produces the list of updates performed by this choice.\n+lookupChoInHMap :: HM.HashMap UpdChoice\n+    (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> TypeConName\n+  -- ^ The template in which the choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> Maybe (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+-- TODO: This TypeConName should be qualified\n+-- TODO: The type con name really should be taken into account here\n+lookupChoInHMap hmap _tem cho = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\upd _ -> _choName upd == cho) hmap\n+\n+-- | Solves the value references by computing the closure of all referenced\n+-- values, for each value in the environment.\n+-- It thus empties `_usValue` by collecting all updates made by this closure.\n+solveValueReferences :: Env 'ValueGathering -> Env 'ChoiceGathering\n+solveValueReferences EnvVG{..} =\n+  let valhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envvgvals (HM.keys _envvgvals)\n+  in EnvCG _envvgskol (convertHMap valhmap) _envvgdats _envvgcids HM.empty\n+  where\n+    lookup_ref :: Qualified ExprValName\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    lookup_ref ref hmap = fromMaybe (error \"Impossible: Undefined value ref while solving\")\n+      (lookupValInHMap hmap ref)\n+\n+    get_refs :: (Expr, UpdateSet 'ValueGathering)\n+      -> ([Cond (Qualified ExprValName)], (Expr, UpdateSet 'ValueGathering))\n+    get_refs (e, upds@UpdateSetVG{..}) = (_usvgValue, (e, upds{_usvgValue = []}))\n+\n+    ext_upds :: (Expr, UpdateSet 'ValueGathering) -> (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    ext_upds (e, upds1)  (_, upds2) = (e, concatUpdateSet upds1 upds2)\n+\n+    intro_cond :: Cond (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    -- Note that the expression is not important here, as it will be ignored in\n+    -- `ext_upds` later on.\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (e,updx) y) = (e, introCond (Conditional cond updx (snd <$> y)))\n+\n+    convertHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering)\n+    convertHMap = HM.map (second updateSetVG2CG)\n+\n+    updateSetVG2CG :: UpdateSet 'ValueGathering -> UpdateSet 'ChoiceGathering\n+    updateSetVG2CG UpdateSetVG{..} = if null _usvgValue\n+      then UpdateSetCG _usvgUpdate _usvgChoice\n+      else error \"Impossible: There should be no references remaining after value solving\"\n+\n+-- | Solves the choice references by computing the closure of all referenced\n+-- choices, for each choice in the environment.\n+-- It thus empties `_usChoice` by collecting all updates made by this closure.\n+solveChoiceReferences :: Env 'ChoiceGathering -> Env 'Solving\n+solveChoiceReferences EnvCG{..} =\n+  let chhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envcgchs (HM.keys _envcgchs)\n+      chshmap = convertChHMap chhmap\n+      valhmap = HM.map (inlineChoices chshmap) _envcgvals\n+  in EnvS _envcgskol valhmap _envcgdats _envcgcids chshmap\n+  where\n+    lookup_ref :: UpdChoice\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    lookup_ref UpdChoice{..} hmap = fromMaybe (error \"Impossible: Undefined choice ref while solving\")\n+      (lookupChoInHMap hmap (qualObject _choTemp) _choName)\n+\n+    get_refs :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> ([Cond UpdChoice], (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+    -- TODO: This is gonna result in a ton of substitutions\n+    get_refs (self,this,args,updfunc0) =\n+      -- TODO: This seems to be a rather common pattern. Abstract to reduce duplication.\n+      let chos = _uscgChoice $ updfunc0 (EVar self) (EVar this) (EVar args)\n+          updfunc1 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            let upds@UpdateSetCG{..} = updfunc0 selfexp thisexp argsexp\n+            in upds{_uscgChoice = []}\n+      in (chos, (self,this,args,updfunc1))\n+\n+    ext_upds :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    ext_upds (self,this,args,updfunc1) (_,_,_,updfunc2) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            updfunc1 selfexp thisexp argsexp `concatUpdateSet` updfunc2 selfexp thisexp argsexp\n+      in (self,this,args,updfunc3)\n+\n+    intro_cond :: Cond (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (self,this,args,updfunc1) y) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            introCond (Conditional cond (updfunc1 selfexp thisexp argsexp)\n+              ((\\(_,_,_,updfunc2) -> updfunc2 selfexp thisexp argsexp) <$> y))\n+      in (self,this,args,updfunc3)\n+\n+    inlineChoices :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+      -> (Expr, UpdateSet 'ChoiceGathering)\n+      -> (Expr, UpdateSet 'Solving)\n+    inlineChoices chshmap (exp, UpdateSetCG{..}) =\n+      let lookupRes = map\n+            (intro_cond . fmap (\\ch -> fromMaybe (error \"Impossible: missing choice while solving\") (HM.lookup ch chshmap)))\n+            _uscgChoice\n+          chupds = concatMap (\\(self,this,args,upds) -> _ussUpdate $ upds (EVar self) (EVar this) (EVar args)) lookupRes\n+      in (exp, UpdateSetS (_uscgUpdate ++ chupds))\n+\n+    convertChHMap :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+    convertChHMap = HM.map (\\(self,this,args,updfunc) ->\n+      (self,this,args, \\(selfExp :: Expr) (thisExp :: Expr) (argsExp :: Expr) ->\n+        updateSetCG2S $ updfunc selfExp thisExp argsExp))\n+\n+    updateSetCG2S :: UpdateSet 'ChoiceGathering -> UpdateSet 'Solving\n+    updateSetCG2S UpdateSetCG{..} = if null _uscgChoice\n+      then UpdateSetS _uscgUpdate\n+      else error \"Impossible: There should be no references remaining after choice solving\"\n+\n+-- | Solves a single reference by recursively inlining the references into updates.\n+solveReference :: forall updset ref. (Eq ref, Hashable ref)\n+  => (ref -> HM.HashMap ref updset -> updset)\n+  -- ^ Function for looking up references in the update set.\n+  -> (updset -> ([Cond ref], updset))\n+  -- ^ Function popping the references from the update set.\n+  -> (updset -> updset -> updset)\n+  -- ^ Function for concatinating update sets.\n+  -> (Cond updset -> updset)\n+  -- ^ Function for moving conditionals inside the update set.\n+  -> [ref]\n+  -- ^ The references which have already been visited.\n+  -> HM.HashMap ref updset\n+  -- ^ The hashmap mapping references to update sets.\n+  -> ref\n+  -- ^ The reference to be solved.\n+  -> (updset, HM.HashMap ref updset)\n+solveReference lookup getRefs extUpds introCond vis hmap0 ref0 =\n+  let upd0 = lookup ref0 hmap0\n+      (refs, upd1) = getRefs upd0\n+  in if ref0 `elem` vis\n+  -- TODO: Recursion!\n+    then (upd1, hmap0) -- TODO: At least remove the references?\n+    else let (upd2, hmap1) = foldl handle_ref (upd1, hmap0) refs\n+      in (upd1, HM.insert ref0 upd2 hmap1)\n+  where\n+    handle_ref :: (updset, HM.HashMap ref updset) -> Cond ref\n+      -> (updset, HM.HashMap ref updset)\n+    handle_ref (upd_i0, hmap_i0) (Determined ref_i) =\n+      let (upd_i1, hmap_i1) = solveReference lookup getRefs extUpds introCond (ref0:vis) hmap_i0 ref_i\n+      in (extUpds upd_i0 upd_i1, hmap_i1)\n+    handle_ref (upd_i0, hmap_i0) (Conditional cond ref_ia ref_ib) =\n+      let (upd_ia, hmap_ia) = solveReference lookup getRefs extUpds introCond (ref0:vis) hmap_i0 ref_ia\n+          (upd_ib, hmap_ib) = maybe (Nothing, hmap_ia)\n+            (first Just . solveReference lookup getRefs extUpds introCond (ref0:vis) hmap_ia) ref_ib\n+          upd_i1 = extUpds upd_i0 $ introCond $ Conditional cond upd_ia upd_ib\n+      in (upd_i1, hmap_ib)\n+\n+-- TODO: This should work recursively\n+-- | Lookup the field names and corresponding types, for a given record type\n+-- constructor name.\n+recTypConFields :: MonadEnv m ph"
  },
  {
    "id" : "03c67154-b638-4afa-ba44-5e8caa9b2487",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "89b4c8f0-a5b9-46bf-aeb2-e7d05a71f0b4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Any reason why this is not a `HashSet`?",
        "createdAt" : "2020-05-11T08:49:07Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 751,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified.\n+-- | Helper function to lookup a value definition in a HashMap.\n+lookupValInHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> Maybe (Expr, UpdateSet ph)\n+lookupValInHMap hmap val = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\name _ -> qualObject name == qualObject val && qualModule name == qualModule val) hmap\n+\n+-- TODO: Does this really need to be a seperate function?\n+-- | Helper function to lookup a choice in a HashMap. Returns the variables for\n+-- self, this and args used, as well as a function which, given the values for\n+-- self, this and args, produces the list of updates performed by this choice.\n+lookupChoInHMap :: HM.HashMap UpdChoice\n+    (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> TypeConName\n+  -- ^ The template in which the choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> Maybe (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+-- TODO: This TypeConName should be qualified\n+-- TODO: The type con name really should be taken into account here\n+lookupChoInHMap hmap _tem cho = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\upd _ -> _choName upd == cho) hmap\n+\n+-- | Solves the value references by computing the closure of all referenced\n+-- values, for each value in the environment.\n+-- It thus empties `_usValue` by collecting all updates made by this closure.\n+solveValueReferences :: Env 'ValueGathering -> Env 'ChoiceGathering\n+solveValueReferences EnvVG{..} =\n+  let valhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envvgvals (HM.keys _envvgvals)\n+  in EnvCG _envvgskol (convertHMap valhmap) _envvgdats _envvgcids HM.empty\n+  where\n+    lookup_ref :: Qualified ExprValName\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    lookup_ref ref hmap = fromMaybe (error \"Impossible: Undefined value ref while solving\")\n+      (lookupValInHMap hmap ref)\n+\n+    get_refs :: (Expr, UpdateSet 'ValueGathering)\n+      -> ([Cond (Qualified ExprValName)], (Expr, UpdateSet 'ValueGathering))\n+    get_refs (e, upds@UpdateSetVG{..}) = (_usvgValue, (e, upds{_usvgValue = []}))\n+\n+    ext_upds :: (Expr, UpdateSet 'ValueGathering) -> (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    ext_upds (e, upds1)  (_, upds2) = (e, concatUpdateSet upds1 upds2)\n+\n+    intro_cond :: Cond (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    -- Note that the expression is not important here, as it will be ignored in\n+    -- `ext_upds` later on.\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (e,updx) y) = (e, introCond (Conditional cond updx (snd <$> y)))\n+\n+    convertHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering)\n+    convertHMap = HM.map (second updateSetVG2CG)\n+\n+    updateSetVG2CG :: UpdateSet 'ValueGathering -> UpdateSet 'ChoiceGathering\n+    updateSetVG2CG UpdateSetVG{..} = if null _usvgValue\n+      then UpdateSetCG _usvgUpdate _usvgChoice\n+      else error \"Impossible: There should be no references remaining after value solving\"\n+\n+-- | Solves the choice references by computing the closure of all referenced\n+-- choices, for each choice in the environment.\n+-- It thus empties `_usChoice` by collecting all updates made by this closure.\n+solveChoiceReferences :: Env 'ChoiceGathering -> Env 'Solving\n+solveChoiceReferences EnvCG{..} =\n+  let chhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envcgchs (HM.keys _envcgchs)\n+      chshmap = convertChHMap chhmap\n+      valhmap = HM.map (inlineChoices chshmap) _envcgvals\n+  in EnvS _envcgskol valhmap _envcgdats _envcgcids chshmap\n+  where\n+    lookup_ref :: UpdChoice\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    lookup_ref UpdChoice{..} hmap = fromMaybe (error \"Impossible: Undefined choice ref while solving\")\n+      (lookupChoInHMap hmap (qualObject _choTemp) _choName)\n+\n+    get_refs :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> ([Cond UpdChoice], (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+    -- TODO: This is gonna result in a ton of substitutions\n+    get_refs (self,this,args,updfunc0) =\n+      -- TODO: This seems to be a rather common pattern. Abstract to reduce duplication.\n+      let chos = _uscgChoice $ updfunc0 (EVar self) (EVar this) (EVar args)\n+          updfunc1 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            let upds@UpdateSetCG{..} = updfunc0 selfexp thisexp argsexp\n+            in upds{_uscgChoice = []}\n+      in (chos, (self,this,args,updfunc1))\n+\n+    ext_upds :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    ext_upds (self,this,args,updfunc1) (_,_,_,updfunc2) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            updfunc1 selfexp thisexp argsexp `concatUpdateSet` updfunc2 selfexp thisexp argsexp\n+      in (self,this,args,updfunc3)\n+\n+    intro_cond :: Cond (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (self,this,args,updfunc1) y) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            introCond (Conditional cond (updfunc1 selfexp thisexp argsexp)\n+              ((\\(_,_,_,updfunc2) -> updfunc2 selfexp thisexp argsexp) <$> y))\n+      in (self,this,args,updfunc3)\n+\n+    inlineChoices :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+      -> (Expr, UpdateSet 'ChoiceGathering)\n+      -> (Expr, UpdateSet 'Solving)\n+    inlineChoices chshmap (exp, UpdateSetCG{..}) =\n+      let lookupRes = map\n+            (intro_cond . fmap (\\ch -> fromMaybe (error \"Impossible: missing choice while solving\") (HM.lookup ch chshmap)))\n+            _uscgChoice\n+          chupds = concatMap (\\(self,this,args,upds) -> _ussUpdate $ upds (EVar self) (EVar this) (EVar args)) lookupRes\n+      in (exp, UpdateSetS (_uscgUpdate ++ chupds))\n+\n+    convertChHMap :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+    convertChHMap = HM.map (\\(self,this,args,updfunc) ->\n+      (self,this,args, \\(selfExp :: Expr) (thisExp :: Expr) (argsExp :: Expr) ->\n+        updateSetCG2S $ updfunc selfExp thisExp argsExp))\n+\n+    updateSetCG2S :: UpdateSet 'ChoiceGathering -> UpdateSet 'Solving\n+    updateSetCG2S UpdateSetCG{..} = if null _uscgChoice\n+      then UpdateSetS _uscgUpdate\n+      else error \"Impossible: There should be no references remaining after choice solving\"\n+\n+-- | Solves a single reference by recursively inlining the references into updates.\n+solveReference :: forall updset ref. (Eq ref, Hashable ref)\n+  => (ref -> HM.HashMap ref updset -> updset)\n+  -- ^ Function for looking up references in the update set.\n+  -> (updset -> ([Cond ref], updset))\n+  -- ^ Function popping the references from the update set.\n+  -> (updset -> updset -> updset)\n+  -- ^ Function for concatinating update sets.\n+  -> (Cond updset -> updset)\n+  -- ^ Function for moving conditionals inside the update set.\n+  -> [ref]"
  },
  {
    "id" : "614b23c1-9137-4d17-8d3b-cd613e4d4e7e",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "aec9c611-725f-40cc-9c6c-94a90ca5b454",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we give this a Semigroup instance?",
        "createdAt" : "2020-05-11T08:49:41Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : 745,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified.\n+-- | Helper function to lookup a value definition in a HashMap.\n+lookupValInHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> Maybe (Expr, UpdateSet ph)\n+lookupValInHMap hmap val = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\name _ -> qualObject name == qualObject val && qualModule name == qualModule val) hmap\n+\n+-- TODO: Does this really need to be a seperate function?\n+-- | Helper function to lookup a choice in a HashMap. Returns the variables for\n+-- self, this and args used, as well as a function which, given the values for\n+-- self, this and args, produces the list of updates performed by this choice.\n+lookupChoInHMap :: HM.HashMap UpdChoice\n+    (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> TypeConName\n+  -- ^ The template in which the choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> Maybe (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+-- TODO: This TypeConName should be qualified\n+-- TODO: The type con name really should be taken into account here\n+lookupChoInHMap hmap _tem cho = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\upd _ -> _choName upd == cho) hmap\n+\n+-- | Solves the value references by computing the closure of all referenced\n+-- values, for each value in the environment.\n+-- It thus empties `_usValue` by collecting all updates made by this closure.\n+solveValueReferences :: Env 'ValueGathering -> Env 'ChoiceGathering\n+solveValueReferences EnvVG{..} =\n+  let valhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envvgvals (HM.keys _envvgvals)\n+  in EnvCG _envvgskol (convertHMap valhmap) _envvgdats _envvgcids HM.empty\n+  where\n+    lookup_ref :: Qualified ExprValName\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    lookup_ref ref hmap = fromMaybe (error \"Impossible: Undefined value ref while solving\")\n+      (lookupValInHMap hmap ref)\n+\n+    get_refs :: (Expr, UpdateSet 'ValueGathering)\n+      -> ([Cond (Qualified ExprValName)], (Expr, UpdateSet 'ValueGathering))\n+    get_refs (e, upds@UpdateSetVG{..}) = (_usvgValue, (e, upds{_usvgValue = []}))\n+\n+    ext_upds :: (Expr, UpdateSet 'ValueGathering) -> (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    ext_upds (e, upds1)  (_, upds2) = (e, concatUpdateSet upds1 upds2)\n+\n+    intro_cond :: Cond (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    -- Note that the expression is not important here, as it will be ignored in\n+    -- `ext_upds` later on.\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (e,updx) y) = (e, introCond (Conditional cond updx (snd <$> y)))\n+\n+    convertHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering)\n+    convertHMap = HM.map (second updateSetVG2CG)\n+\n+    updateSetVG2CG :: UpdateSet 'ValueGathering -> UpdateSet 'ChoiceGathering\n+    updateSetVG2CG UpdateSetVG{..} = if null _usvgValue\n+      then UpdateSetCG _usvgUpdate _usvgChoice\n+      else error \"Impossible: There should be no references remaining after value solving\"\n+\n+-- | Solves the choice references by computing the closure of all referenced\n+-- choices, for each choice in the environment.\n+-- It thus empties `_usChoice` by collecting all updates made by this closure.\n+solveChoiceReferences :: Env 'ChoiceGathering -> Env 'Solving\n+solveChoiceReferences EnvCG{..} =\n+  let chhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envcgchs (HM.keys _envcgchs)\n+      chshmap = convertChHMap chhmap\n+      valhmap = HM.map (inlineChoices chshmap) _envcgvals\n+  in EnvS _envcgskol valhmap _envcgdats _envcgcids chshmap\n+  where\n+    lookup_ref :: UpdChoice\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    lookup_ref UpdChoice{..} hmap = fromMaybe (error \"Impossible: Undefined choice ref while solving\")\n+      (lookupChoInHMap hmap (qualObject _choTemp) _choName)\n+\n+    get_refs :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> ([Cond UpdChoice], (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+    -- TODO: This is gonna result in a ton of substitutions\n+    get_refs (self,this,args,updfunc0) =\n+      -- TODO: This seems to be a rather common pattern. Abstract to reduce duplication.\n+      let chos = _uscgChoice $ updfunc0 (EVar self) (EVar this) (EVar args)\n+          updfunc1 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            let upds@UpdateSetCG{..} = updfunc0 selfexp thisexp argsexp\n+            in upds{_uscgChoice = []}\n+      in (chos, (self,this,args,updfunc1))\n+\n+    ext_upds :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    ext_upds (self,this,args,updfunc1) (_,_,_,updfunc2) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            updfunc1 selfexp thisexp argsexp `concatUpdateSet` updfunc2 selfexp thisexp argsexp\n+      in (self,this,args,updfunc3)\n+\n+    intro_cond :: Cond (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (self,this,args,updfunc1) y) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            introCond (Conditional cond (updfunc1 selfexp thisexp argsexp)\n+              ((\\(_,_,_,updfunc2) -> updfunc2 selfexp thisexp argsexp) <$> y))\n+      in (self,this,args,updfunc3)\n+\n+    inlineChoices :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+      -> (Expr, UpdateSet 'ChoiceGathering)\n+      -> (Expr, UpdateSet 'Solving)\n+    inlineChoices chshmap (exp, UpdateSetCG{..}) =\n+      let lookupRes = map\n+            (intro_cond . fmap (\\ch -> fromMaybe (error \"Impossible: missing choice while solving\") (HM.lookup ch chshmap)))\n+            _uscgChoice\n+          chupds = concatMap (\\(self,this,args,upds) -> _ussUpdate $ upds (EVar self) (EVar this) (EVar args)) lookupRes\n+      in (exp, UpdateSetS (_uscgUpdate ++ chupds))\n+\n+    convertChHMap :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+    convertChHMap = HM.map (\\(self,this,args,updfunc) ->\n+      (self,this,args, \\(selfExp :: Expr) (thisExp :: Expr) (argsExp :: Expr) ->\n+        updateSetCG2S $ updfunc selfExp thisExp argsExp))\n+\n+    updateSetCG2S :: UpdateSet 'ChoiceGathering -> UpdateSet 'Solving\n+    updateSetCG2S UpdateSetCG{..} = if null _uscgChoice\n+      then UpdateSetS _uscgUpdate\n+      else error \"Impossible: There should be no references remaining after choice solving\"\n+\n+-- | Solves a single reference by recursively inlining the references into updates.\n+solveReference :: forall updset ref. (Eq ref, Hashable ref)\n+  => (ref -> HM.HashMap ref updset -> updset)\n+  -- ^ Function for looking up references in the update set.\n+  -> (updset -> ([Cond ref], updset))\n+  -- ^ Function popping the references from the update set.\n+  -> (updset -> updset -> updset)"
  },
  {
    "id" : "08462c9b-3015-454d-8caf-4ad6b9c27ed7",
    "prId" : 5472,
    "comments" : [
      {
        "id" : "814879a8-c8dd-4548-8d81-17e2e222979e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I find this really hard to follow. Can we add some comments on what exactly this is doing?",
        "createdAt" : "2020-05-11T08:50:20Z",
        "updatedAt" : "2020-05-19T20:39:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2d7c840ec94d841cd4a9d3f0bd85eabff75e5d3a",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,812 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE ConstraintKinds #-}\n+{-# LANGUAGE DataKinds #-}\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE GADTs #-}\n+{-# LANGUAGE KindSignatures #-}\n+{-# LANGUAGE RankNTypes #-}\n+\n+-- | Contexts for DAML LF static verification\n+module DA.Daml.LF.Verify.Context\n+  ( Phase(..)\n+  , GenPhase\n+  , BoolExpr(..)\n+  , Cond(..)\n+  , Env(..)\n+  , Error(..)\n+  , MonadEnv\n+  , UpdateSet(..)\n+  , Upd(..)\n+  , UpdChoice(..)\n+  , Skolem(..)\n+  , getEnv\n+  , runEnv\n+  , genRenamedVar\n+  , emptyEnv\n+  , extVarEnv, extRecEnv, extValEnv, extChEnv, extDatsEnv, extCidEnv\n+  , extRecEnvLvl1\n+  , lookupVar, lookupRec, lookupVal, lookupChoice, lookupDataCon, lookupCid\n+  , concatEnv\n+  , emptyUpdateSet\n+  , concatUpdateSet\n+  , addUpd\n+  , conditionalUpdateSet\n+  , solveValueReferences\n+  , solveChoiceReferences\n+  , lookupChoInHMap\n+  , fieldName2VarName\n+  , recTypConFields, recTypFields, recExpFields\n+  ) where\n+\n+import Control.Monad.Error.Class (MonadError (..), throwError)\n+import Control.Monad.State.Lazy\n+import Data.Hashable\n+import GHC.Generics\n+import Data.Maybe (listToMaybe, isJust, fromMaybe)\n+import Data.List (find)\n+import Data.Bifunctor\n+import qualified Data.HashMap.Strict as HM\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast hiding (lookupChoice)\n+import DA.Daml.LF.Verify.Subst\n+\n+-- TODO: Move these data types to a seperate file?\n+-- | Data type denoting the phase of the constraint generator.\n+data Phase\n+  = ValueGathering\n+  -- ^ The value phase gathers all value and data type definitions across modules.\n+  | ChoiceGathering\n+  -- ^ The choice phase gathers the updates performed in choice definitions.\n+  | Solving\n+  -- ^ During the solving phase, all definitions have been loaded and updates\n+  -- have been inlined.\n+\n+-- | Data type denoting a boolean condition expression. This data type was\n+-- introduced to avoid having to use imported daml-if prelude functions.\n+data BoolExpr\n+  = BExpr Expr\n+  -- ^ A daml-lf expression.\n+  | BAnd BoolExpr BoolExpr\n+  -- ^ And operator.\n+  | BNot BoolExpr\n+  -- ^ Not operator.\n+  deriving Show\n+\n+-- | Data type denoting a potentially conditional value.\n+data Cond a\n+  = Determined a\n+  -- ^ Non-conditional value.\n+  | Conditional BoolExpr a (Maybe a)\n+  -- ^ Conditional value, with a (Boolean) condition, a value in case the\n+  -- condition holds, and possibly a value in case it doesn't.\n+  deriving Show\n+\n+instance Functor Cond where\n+  fmap f (Determined x) = Determined (f x)\n+  fmap f (Conditional e x y) = Conditional e (f x) (f <$> y)\n+\n+-- | Class covering the types which store conditionals inside.\n+class Conditional a where\n+  -- | Shift the conditional inside the data type.\n+  introCond :: Cond a -> a\n+\n+instance Conditional (UpdateSet ph) where\n+  introCond (Determined upds) = upds\n+  introCond (Conditional e updx updy) = case updx of\n+    UpdateSetVG{} -> UpdateSetVG\n+      (concatCond $ Conditional e (_usvgUpdate updx) (_usvgUpdate <$> updy))\n+      (concatCond $ Conditional e (_usvgChoice updx) (_usvgChoice <$> updy))\n+      (concatCond $ Conditional e (_usvgValue updx) (_usvgValue <$> updy))\n+    UpdateSetCG{} -> UpdateSetCG\n+      (concatCond $ Conditional e (_uscgUpdate updx) (_uscgUpdate <$> updy))\n+      (concatCond $ Conditional e (_uscgChoice updx) (_uscgChoice <$> updy))\n+    UpdateSetS{} -> UpdateSetS\n+      (concatCond $ Conditional e (_ussUpdate updx) (_ussUpdate <$> updy))\n+\n+-- | Flatten nested conditionals into a single level.\n+concatCond :: Cond [Cond a] -> [Cond a]\n+concatCond (Determined xs) = xs\n+concatCond (Conditional e xs mys) = case mys of\n+  Just ys -> map (ext_cond e) xs ++ map (ext_cond (BNot e)) ys\n+  Nothing -> map (ext_cond e) xs\n+  where\n+    ext_cond :: BoolExpr -> Cond b -> Cond b\n+    ext_cond e (Determined x) = Conditional e x Nothing\n+    ext_cond e1 (Conditional e2 x y) = Conditional (BAnd e1 e2) x y\n+\n+-- | Data type denoting an update.\n+data Upd\n+  = UpdCreate\n+  -- ^ Data type denoting a create update.\n+    { _creTemp  :: !(Qualified TypeConName)\n+     -- ^ Qualified type constructor corresponding to the contract template.\n+    , _creField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  | UpdArchive\n+  -- ^ Data type denoting an archive update.\n+    { _arcTemp  :: !(Qualified TypeConName)\n+      -- ^ Qualified type constructor corresponding to the contract template.\n+    , _arcField :: ![(FieldName, Expr)]\n+      -- ^ The fields to be verified, together with their value.\n+    }\n+  deriving Show\n+\n+-- | Data type denoting an exercised choice update.\n+data UpdChoice = UpdChoice\n+  { _choTemp  :: !(Qualified TypeConName)\n+    -- ^ Qualified type constructor corresponding to the contract template.\n+  , _choName  :: !ChoiceName\n+    -- ^ The name of the choice.\n+  }\n+  deriving (Eq, Generic, Hashable, Show)\n+\n+-- | The collection of updates being performed.\n+data UpdateSet (ph :: Phase) where\n+  UpdateSetVG ::\n+    { _usvgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _usvgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    , _usvgValue :: ![Cond (Qualified ExprValName)]\n+      -- ^ The list of referenced values.\n+    } -> UpdateSet 'ValueGathering\n+  UpdateSetCG ::\n+    { _uscgUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    , _uscgChoice :: ![Cond UpdChoice]\n+      -- ^ The list of exercised choices.\n+    } -> UpdateSet 'ChoiceGathering\n+  UpdateSetS ::\n+    { _ussUpdate :: ![Cond Upd]\n+      -- ^ The list of updates.\n+    } -> UpdateSet 'Solving\n+\n+class GenPhase ph where\n+  emptyUpdateSet :: UpdateSet ph\n+  emptyEnv :: Env ph\n+\n+instance GenPhase 'ValueGathering where\n+  emptyUpdateSet = UpdateSetVG [] [] []\n+  emptyEnv = EnvVG [] HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'ChoiceGathering where\n+  emptyUpdateSet = UpdateSetCG [] []\n+  emptyEnv = EnvCG [] HM.empty HM.empty HM.empty HM.empty\n+\n+instance GenPhase 'Solving where\n+  emptyUpdateSet = UpdateSetS []\n+  emptyEnv = EnvS [] HM.empty HM.empty HM.empty HM.empty\n+\n+-- | Combine two update sets.\n+concatUpdateSet :: UpdateSet ph\n+  -- ^ The first update set to be combined.\n+  -> UpdateSet ph\n+  -- ^ The second update set to be combined.\n+  -> UpdateSet ph\n+concatUpdateSet (UpdateSetVG upd1 cho1 val1) (UpdateSetVG upd2 cho2 val2) =\n+  UpdateSetVG (upd1 ++ upd2) (cho1 ++ cho2) (val1 ++ val2)\n+concatUpdateSet (UpdateSetCG upd1 cho1) (UpdateSetCG upd2 cho2) =\n+  UpdateSetCG (upd1 ++ upd2) (cho1 ++ cho2)\n+concatUpdateSet (UpdateSetS upd1) (UpdateSetS upd2) =\n+  UpdateSetS (upd1 ++ upd2)\n+\n+-- | Add a single Upd to an UpdateSet\n+addUpd :: UpdateSet ph\n+  -- ^ The update set to extend.\n+  -> Upd\n+  -- ^ The update to add.\n+  -> UpdateSet ph\n+addUpd upds@UpdateSetVG{..} upd = upds{_usvgUpdate = Determined upd : _usvgUpdate}\n+addUpd upds@UpdateSetCG{..} upd = upds{_uscgUpdate = Determined upd : _uscgUpdate}\n+addUpd upds@UpdateSetS{..} upd = upds{_ussUpdate = Determined upd : _ussUpdate}\n+\n+-- | Make an update set conditional. A second update set can also be introduced\n+-- for the case where the condition does not hold.\n+conditionalUpdateSet :: Expr\n+  -- ^ The condition on which to combine the two update sets.\n+  -> UpdateSet ph\n+  -- ^ The update set in case the condition holds.\n+  -> Maybe (UpdateSet ph)\n+  -- ^ Possibly a second update set.\n+  -> UpdateSet ph\n+conditionalUpdateSet exp upd1 upd2 =\n+  introCond (Conditional (BExpr exp) upd1 upd2)\n+\n+-- | Refresh a given expression variable by producing a fresh renamed variable.\n+-- TODO: when a renamed var gets renamed again, it might overlap again.\n+-- We should have an additional field in VarName to denote its number.\n+genRenamedVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable to be renamed.\n+  -> m ExprVarName\n+genRenamedVar (ExprVarName x) = ExprVarName . T.append x . T.pack <$> fresh\n+\n+-- | Data type denoting a skolemized variable.\n+data Skolem\n+  = SkolVar ExprVarName\n+    -- ^ Skolemised term variable.\n+  | SkolRec ExprVarName [FieldName]\n+    -- ^ List of skolemised field names, with their variable.\n+    -- e.g. `this.field`\n+  deriving (Eq, Show)\n+\n+-- | Data type denoting a contract id.\n+data Cid\n+  = CidVar ExprVarName\n+    -- ^ An expression variable denoting a contract id.\n+  | CidRec ExprVarName FieldName\n+    -- ^ A record projection denoting a contract id.\n+  deriving (Generic, Hashable, Eq, Show)\n+\n+-- | Convert an expression to a contract id, if possible.\n+expr2cid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The expression to be converted.\n+  -> m Cid\n+expr2cid (EVar x) = return $ CidVar x\n+expr2cid (ERecProj _ f (EVar x)) = return $ CidRec x f\n+expr2cid (EStructProj f (EVar x)) = return $ CidRec x f\n+expr2cid _ = throwError ExpectCid\n+\n+-- TODO: Could we alternatively just declare the variables that occur in the updates and drop the skolems?\n+-- | The environment for the DAML-LF verifier\n+data Env (ph :: Phase) where\n+  EnvVG ::\n+    { _envvgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envvgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering))\n+      -- ^ The bound values.\n+    , _envvgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envvgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    } -> Env 'ValueGathering\n+  EnvCG ::\n+    { _envcgskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envcgvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering))\n+      -- ^ The bound values.\n+    , _envcgdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envcgcids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envcgchs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'ChoiceGathering\n+  EnvS ::\n+    { _envsskol :: ![Skolem]\n+      -- ^ The skolemised term variables and fields.\n+    , _envsvals :: !(HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'Solving))\n+      -- ^ The bound values.\n+    , _envsdats :: !(HM.HashMap TypeConName DefDataType)\n+      -- ^ The set of data constructors.\n+    , _envscids :: !(HM.HashMap Cid ExprVarName)\n+      -- ^ The set of fetched cid's mapped to their variable name.\n+    , _envschs :: !(HM.HashMap UpdChoice\n+        (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving))\n+      -- ^ The set of relevant choices, mapping to functions from self, this and args to its updates.\n+    } -> Env 'Solving\n+\n+-- | Combine two environments.\n+concatEnv :: Env ph\n+  -- ^ The first environment to be combined.\n+  -> Env ph\n+  -- ^ The second environment to be combined.\n+  -> Env ph\n+concatEnv (EnvVG vars1 vals1 dats1 cids1) (EnvVG vars2 vals2 dats2 cids2) =\n+  EnvVG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2)\n+concatEnv (EnvCG vars1 vals1 dats1 cids1 chos1) (EnvCG vars2 vals2 dats2 cids2 chos2) =\n+  EnvCG (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+concatEnv (EnvS vars1 vals1 dats1 cids1 chos1) (EnvS vars2 vals2 dats2 cids2 chos2) =\n+  EnvS (vars1 ++ vars2) (vals1 `HM.union` vals2) (dats1 `HM.union` dats2)\n+    (cids1 `HM.union` cids2) (chos1 `HM.union` chos2)\n+  -- TODO: union makes me slightly nervous, as it allows overlapping keys\n+  -- (and just uses the first). `unionWith concatUpdateSet` would indeed be better,\n+  -- but this still makes me nervous as the expr and exprvarnames wouldn't be merged.\n+\n+-- | Convert a fieldname into an expression variable name.\n+fieldName2VarName :: FieldName -> ExprVarName\n+fieldName2VarName = ExprVarName . unFieldName\n+\n+-- | Type class constraint with the required monadic effects for functions\n+-- manipulating the verification environment.\n+type MonadEnv m ph = (MonadError Error m, MonadState (Int,Env ph) m)\n+\n+-- | Fetch the current environment.\n+getEnv :: MonadEnv m ph => m (Env ph)\n+getEnv = snd <$> get\n+\n+-- | Set the current environment.\n+putEnv :: MonadEnv m ph => Env ph -> m ()\n+putEnv env = get >>= \\(uni,_) -> put (uni,env)\n+\n+-- | Generate a new unique name.\n+fresh :: MonadEnv m ph => m String\n+fresh = do\n+  (cur,env) <- get\n+  put (cur + 1,env)\n+  return $ show cur\n+\n+-- | Evaluate the MonadEnv to produce an error message or the final environment.\n+runEnv :: StateT (Int, Env ph) (Either Error) ()\n+  -- ^ The monadic computation to be evaluated.\n+  -> Env ph\n+  -- ^ The initial environment to start from.\n+  -> Either Error (Env ph)\n+runEnv comp env0 = do\n+  (_res, (_uni,env1)) <- runStateT comp (0,env0)\n+  return env1\n+\n+-- | Skolemise an expression variable and extend the environment.\n+extVarEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to be skolemised.\n+  -> m ()\n+extVarEnv x = extSkolEnv (SkolVar x)\n+\n+-- | Skolemise a list of record projection and extend the environment.\n+extRecEnv :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The variable on which is being projected.\n+  -> [FieldName]\n+  -- ^ The fields which should be skolemised.\n+  -> m ()\n+extRecEnv x fs = extSkolEnv (SkolRec x fs)\n+\n+-- | Extend the environment with a new skolem variable.\n+extSkolEnv :: MonadEnv m ph\n+  => Skolem\n+  -- ^ The skolem variable to add.\n+  -> m ()\n+extSkolEnv skol = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgskol = skol : _envvgskol}\n+  env@EnvCG{..} -> putEnv env{_envcgskol = skol : _envcgskol}\n+  env@EnvS{..} -> putEnv env{_envsskol = skol : _envsskol}\n+\n+-- | Extend the environment with a new value definition.\n+extValEnv :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The name of the value being defined.\n+  -> Expr\n+  -- ^ The (partially) evaluated value definition.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by this value.\n+  -> m ()\n+extValEnv val expr upd = getEnv >>= \\case\n+  env@EnvVG{..} -> putEnv env{_envvgvals = HM.insert val (expr, upd) _envvgvals}\n+  env@EnvCG{..} -> putEnv env{_envcgvals = HM.insert val (expr, upd) _envcgvals}\n+  env@EnvS{..} -> putEnv env{_envsvals = HM.insert val (expr, upd) _envsvals}\n+\n+-- | Extends the environment with a new choice.\n+extChEnv :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The type of the template on which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The name of the new choice.\n+  -> ExprVarName\n+  -- ^ Variable to bind the ContractId on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the contract on which this choice is exercised on to.\n+  -> ExprVarName\n+  -- ^ Variable to bind the choice argument to.\n+  -> UpdateSet ph\n+  -- ^ The updates performed by the new choice.\n+  -> m ()\n+extChEnv tc ch self this arg upd =\n+  let substUpd sExp tExp aExp = substituteTm (createExprSubst [(self,sExp),(this,tExp),(arg,aExp)]) upd\n+  in getEnv >>= \\case\n+    EnvVG{} -> error \"Impossible: extChEnv is not used in the value gathering phase\"\n+    env@EnvCG{..} -> putEnv env{_envcgchs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envcgchs}\n+    env@EnvS{..} -> putEnv env{_envschs = HM.insert (UpdChoice tc ch) (self,this,arg,substUpd) _envschs}\n+\n+-- | Extend the environment with a list of new data type definitions.\n+extDatsEnv :: MonadEnv m ph\n+  => HM.HashMap TypeConName DefDataType\n+  -- ^ A hashmap of the data constructor names, with their corresponding definitions.\n+  -> m ()\n+extDatsEnv hmap = getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgdats = hmap `HM.union` _envvgdats}\n+    env@EnvCG{..} -> putEnv env{_envcgdats = hmap `HM.union` _envcgdats}\n+    env@EnvS{..} -> putEnv env{_envsdats = hmap `HM.union` _envsdats}\n+\n+-- | Extend the environment with a new contract id, and the variable to which\n+-- the fetched contract is bound.\n+extCidEnv :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id expression.\n+  -> ExprVarName\n+  -- ^ The variable name to which the fetched contract is bound.\n+  -> m ()\n+extCidEnv exp var = do\n+  cid <- expr2cid exp\n+  getEnv >>= \\case\n+    env@EnvVG{..} -> putEnv env{_envvgcids = HM.insert cid var _envvgcids}\n+    env@EnvCG{..} -> putEnv env{_envcgcids = HM.insert cid var _envcgcids}\n+    env@EnvS{..} -> putEnv env{_envscids = HM.insert cid var _envscids}\n+\n+-- TODO: Is one layer of recursion enough?\n+-- | Recursively skolemise the given record fields, when they have a record\n+-- type. Note that this only works 1 level deep.\n+extRecEnvLvl1 :: MonadEnv m ph\n+  => [(FieldName, Type)]\n+  -- ^ The record fields to skolemise, together with their types.\n+  -> m ()\n+extRecEnvLvl1 = mapM_ step\n+  where\n+    step :: MonadEnv m ph => (FieldName, Type) -> m ()\n+    step (f,typ) = do\n+      { fsRec <- recTypFields typ\n+      ; extRecEnv (fieldName2VarName f) fsRec\n+      }\n+      -- TODO: Temporary fix\n+      `catchError` (\\_ -> return ())\n+\n+-- | Lookup an expression variable in the environment. Succeeds if this variable\n+-- has been skolemised, or throws an error if it hasn't.\n+lookupVar :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable to look up.\n+  -> m Bool\n+lookupVar x = getEnv >>= \\case\n+  EnvVG{..} -> return $ elem (SkolVar x) _envvgskol\n+  EnvCG{..} -> return $ elem (SkolVar x) _envcgskol\n+  EnvS{..} -> return $ elem (SkolVar x) _envsskol\n+\n+-- | Lookup a record project in the environment. Returns a boolean denoting\n+-- whether or not the record projection has been skolemised.\n+lookupRec :: MonadEnv m ph\n+  => ExprVarName\n+  -- ^ The expression variable on which is being projected.\n+  -> FieldName\n+  -- ^ The field name which is being projected.\n+  -> m Bool\n+lookupRec x f = do\n+  skols <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgskol\n+    EnvCG{..} -> return _envcgskol\n+    EnvS{..} -> return _envsskol\n+  let fields = [ fs | SkolRec y fs <- skols, x == y ]\n+  if not (null fields)\n+    then return (elem f $ head fields)\n+    else return False\n+\n+-- | Lookup a value name in the environment. Returns its (partially) evaluated\n+-- definition, together with the updates it performs.\n+lookupVal :: MonadEnv m ph\n+  => Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> m (Expr, UpdateSet ph)\n+lookupVal val = do\n+  vals <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgvals\n+    EnvCG{..} -> return _envcgvals\n+    EnvS{..} -> return _envsvals\n+  case lookupValInHMap vals val of\n+    Just res -> return res\n+    Nothing -> throwError (UnknownValue val)\n+\n+-- | Lookup a choice name in the environment. Returns a function which, once\n+-- self, this and args have been instantiated, returns the set of updates it\n+-- performs.\n+lookupChoice :: MonadEnv m ph\n+  => Qualified TypeConName\n+  -- ^ The template name in which this choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> m (Expr -> Expr -> Expr -> UpdateSet ph)\n+lookupChoice tem ch = do\n+  chs <- getEnv >>= \\case\n+    EnvVG{..} -> return HM.empty\n+    EnvCG{..} -> return _envcgchs\n+    EnvS{..} -> return _envschs\n+  case lookupChoInHMap chs (qualObject tem) ch of\n+    Nothing -> throwError (UnknownChoice ch)\n+    Just (_,_,_,upd) -> return upd\n+\n+-- | Lookup a data type definition in the environment.\n+lookupDataCon :: MonadEnv m ph\n+  => TypeConName\n+  -- ^ The data constructor to lookup.\n+  -> m DefDataType\n+lookupDataCon tc = do\n+  dats <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgdats\n+    EnvCG{..} -> return _envcgdats\n+    EnvS{..} -> return _envsdats\n+  case HM.lookup tc dats of\n+    Nothing -> throwError (UnknownDataCons tc)\n+    Just def -> return def\n+\n+-- | Lookup a contract id in the environment. Returns the variable its fetched\n+-- contract is bound to.\n+lookupCid :: MonadEnv m ph\n+  => Expr\n+  -- ^ The contract id to lookup.\n+  -> m ExprVarName\n+lookupCid exp = do\n+  cid <- expr2cid exp\n+  cids <- getEnv >>= \\case\n+    EnvVG{..} -> return _envvgcids\n+    EnvCG{..} -> return _envcgcids\n+    EnvS{..} -> return _envscids\n+  case HM.lookup cid cids of\n+    Nothing -> throwError $ UnknownCid cid\n+    Just var -> return var\n+\n+-- TODO: There seems to be something wrong with the PackageRef in Qualified.\n+-- | Helper function to lookup a value definition in a HashMap.\n+lookupValInHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> Qualified ExprValName\n+  -- ^ The value name to lookup.\n+  -> Maybe (Expr, UpdateSet ph)\n+lookupValInHMap hmap val = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\name _ -> qualObject name == qualObject val && qualModule name == qualModule val) hmap\n+\n+-- TODO: Does this really need to be a seperate function?\n+-- | Helper function to lookup a choice in a HashMap. Returns the variables for\n+-- self, this and args used, as well as a function which, given the values for\n+-- self, this and args, produces the list of updates performed by this choice.\n+lookupChoInHMap :: HM.HashMap UpdChoice\n+    (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+  -- ^ The HashMap in which to look.\n+  -> TypeConName\n+  -- ^ The template in which the choice is defined.\n+  -> ChoiceName\n+  -- ^ The choice name to lookup.\n+  -> Maybe (ExprVarName, ExprVarName, ExprVarName, Expr -> Expr -> Expr -> UpdateSet ph)\n+-- TODO: This TypeConName should be qualified\n+-- TODO: The type con name really should be taken into account here\n+lookupChoInHMap hmap _tem cho = listToMaybe $ HM.elems\n+  $ HM.filterWithKey (\\upd _ -> _choName upd == cho) hmap\n+\n+-- | Solves the value references by computing the closure of all referenced\n+-- values, for each value in the environment.\n+-- It thus empties `_usValue` by collecting all updates made by this closure.\n+solveValueReferences :: Env 'ValueGathering -> Env 'ChoiceGathering\n+solveValueReferences EnvVG{..} =\n+  let valhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envvgvals (HM.keys _envvgvals)\n+  in EnvCG _envvgskol (convertHMap valhmap) _envvgdats _envvgcids HM.empty\n+  where\n+    lookup_ref :: Qualified ExprValName\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    lookup_ref ref hmap = fromMaybe (error \"Impossible: Undefined value ref while solving\")\n+      (lookupValInHMap hmap ref)\n+\n+    get_refs :: (Expr, UpdateSet 'ValueGathering)\n+      -> ([Cond (Qualified ExprValName)], (Expr, UpdateSet 'ValueGathering))\n+    get_refs (e, upds@UpdateSetVG{..}) = (_usvgValue, (e, upds{_usvgValue = []}))\n+\n+    ext_upds :: (Expr, UpdateSet 'ValueGathering) -> (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    ext_upds (e, upds1)  (_, upds2) = (e, concatUpdateSet upds1 upds2)\n+\n+    intro_cond :: Cond (Expr, UpdateSet 'ValueGathering)\n+      -> (Expr, UpdateSet 'ValueGathering)\n+    -- Note that the expression is not important here, as it will be ignored in\n+    -- `ext_upds` later on.\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (e,updx) y) = (e, introCond (Conditional cond updx (snd <$> y)))\n+\n+    convertHMap :: HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ValueGathering)\n+      -> HM.HashMap (Qualified ExprValName) (Expr, UpdateSet 'ChoiceGathering)\n+    convertHMap = HM.map (second updateSetVG2CG)\n+\n+    updateSetVG2CG :: UpdateSet 'ValueGathering -> UpdateSet 'ChoiceGathering\n+    updateSetVG2CG UpdateSetVG{..} = if null _usvgValue\n+      then UpdateSetCG _usvgUpdate _usvgChoice\n+      else error \"Impossible: There should be no references remaining after value solving\"\n+\n+-- | Solves the choice references by computing the closure of all referenced\n+-- choices, for each choice in the environment.\n+-- It thus empties `_usChoice` by collecting all updates made by this closure.\n+solveChoiceReferences :: Env 'ChoiceGathering -> Env 'Solving\n+solveChoiceReferences EnvCG{..} =\n+  let chhmap = foldl (\\hmap ref -> snd $ solveReference lookup_ref get_refs ext_upds intro_cond [] hmap ref) _envcgchs (HM.keys _envcgchs)\n+      chshmap = convertChHMap chhmap\n+      valhmap = HM.map (inlineChoices chshmap) _envcgvals\n+  in EnvS _envcgskol valhmap _envcgdats _envcgcids chshmap\n+  where\n+    lookup_ref :: UpdChoice\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    lookup_ref UpdChoice{..} hmap = fromMaybe (error \"Impossible: Undefined choice ref while solving\")\n+      (lookupChoInHMap hmap (qualObject _choTemp) _choName)\n+\n+    get_refs :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> ([Cond UpdChoice], (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering))\n+    -- TODO: This is gonna result in a ton of substitutions\n+    get_refs (self,this,args,updfunc0) =\n+      -- TODO: This seems to be a rather common pattern. Abstract to reduce duplication.\n+      let chos = _uscgChoice $ updfunc0 (EVar self) (EVar this) (EVar args)\n+          updfunc1 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            let upds@UpdateSetCG{..} = updfunc0 selfexp thisexp argsexp\n+            in upds{_uscgChoice = []}\n+      in (chos, (self,this,args,updfunc1))\n+\n+    ext_upds :: (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+    ext_upds (self,this,args,updfunc1) (_,_,_,updfunc2) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            updfunc1 selfexp thisexp argsexp `concatUpdateSet` updfunc2 selfexp thisexp argsexp\n+      in (self,this,args,updfunc3)\n+\n+    intro_cond :: Cond (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+      -> (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet ph)\n+    intro_cond (Determined x) = x\n+    intro_cond (Conditional cond (self,this,args,updfunc1) y) =\n+      let updfunc3 (selfexp :: Expr) (thisexp :: Expr) (argsexp :: Expr) =\n+            introCond (Conditional cond (updfunc1 selfexp thisexp argsexp)\n+              ((\\(_,_,_,updfunc2) -> updfunc2 selfexp thisexp argsexp) <$> y))\n+      in (self,this,args,updfunc3)\n+\n+    inlineChoices :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+      -> (Expr, UpdateSet 'ChoiceGathering)\n+      -> (Expr, UpdateSet 'Solving)\n+    inlineChoices chshmap (exp, UpdateSetCG{..}) =\n+      let lookupRes = map\n+            (intro_cond . fmap (\\ch -> fromMaybe (error \"Impossible: missing choice while solving\") (HM.lookup ch chshmap)))\n+            _uscgChoice\n+          chupds = concatMap (\\(self,this,args,upds) -> _ussUpdate $ upds (EVar self) (EVar this) (EVar args)) lookupRes\n+      in (exp, UpdateSetS (_uscgUpdate ++ chupds))\n+\n+    convertChHMap :: HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'ChoiceGathering)\n+      -> HM.HashMap UpdChoice (ExprVarName,ExprVarName,ExprVarName,Expr -> Expr -> Expr -> UpdateSet 'Solving)\n+    convertChHMap = HM.map (\\(self,this,args,updfunc) ->\n+      (self,this,args, \\(selfExp :: Expr) (thisExp :: Expr) (argsExp :: Expr) ->\n+        updateSetCG2S $ updfunc selfExp thisExp argsExp))\n+\n+    updateSetCG2S :: UpdateSet 'ChoiceGathering -> UpdateSet 'Solving\n+    updateSetCG2S UpdateSetCG{..} = if null _uscgChoice\n+      then UpdateSetS _uscgUpdate\n+      else error \"Impossible: There should be no references remaining after choice solving\"\n+\n+-- | Solves a single reference by recursively inlining the references into updates.\n+solveReference :: forall updset ref. (Eq ref, Hashable ref)\n+  => (ref -> HM.HashMap ref updset -> updset)\n+  -- ^ Function for looking up references in the update set.\n+  -> (updset -> ([Cond ref], updset))\n+  -- ^ Function popping the references from the update set.\n+  -> (updset -> updset -> updset)\n+  -- ^ Function for concatinating update sets.\n+  -> (Cond updset -> updset)\n+  -- ^ Function for moving conditionals inside the update set.\n+  -> [ref]\n+  -- ^ The references which have already been visited.\n+  -> HM.HashMap ref updset\n+  -- ^ The hashmap mapping references to update sets.\n+  -> ref\n+  -- ^ The reference to be solved.\n+  -> (updset, HM.HashMap ref updset)\n+solveReference lookup getRefs extUpds introCond vis hmap0 ref0 =\n+  let upd0 = lookup ref0 hmap0\n+      (refs, upd1) = getRefs upd0\n+  in if ref0 `elem` vis\n+  -- TODO: Recursion!\n+    then (upd1, hmap0) -- TODO: At least remove the references?\n+    else let (upd2, hmap1) = foldl handle_ref (upd1, hmap0) refs\n+      in (upd1, HM.insert ref0 upd2 hmap1)\n+  where\n+    handle_ref :: (updset, HM.HashMap ref updset) -> Cond ref"
  }
]