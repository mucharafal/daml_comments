[
  {
    "id" : "804251fe-3ac2-4e56-ad56-37a2096b58d1",
    "prId" : 4810,
    "comments" : [
      {
        "id" : "8565bbc2-86bb-4b59-b5b9-38753f923edc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If I'm not missing something, `followUp` is instantiated with `goPart` on all call sites.",
        "createdAt" : "2020-03-04T17:16:23Z",
        "updatedAt" : "2020-03-04T17:46:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b04c519-3144-4c50-9753-36f4c58b9ace",
        "parentId" : "8565bbc2-86bb-4b59-b5b9-38753f923edc",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`followUp` is dead.",
        "createdAt" : "2020-03-04T17:49:41Z",
        "updatedAt" : "2020-03-04T17:50:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91ceae53309ae1bbb54b7b6ef69df5b7cb90cdb3",
    "line" : null,
    "diffHunk" : "@@ -108,39 +109,42 @@ mangleIdentifier txt = case T.foldl' f (MangledSize 0 0) txt of\n \n unmangleIdentifier :: T.Text -> Either String T.Text\n unmangleIdentifier txt = do\n-  chs <- goStart (T.unpack txt)\n-  if null chs\n+  chs <- goStart txt\n+  if T.null chs\n     then Left \"Empty identifier\"\n-    else Right (T.pack chs)\n+    else Right chs\n   where\n-    go :: (Char -> Bool) -> (String -> Either String String) -> String -> Either String String\n-    go isAllowed followUp = \\case\n-      [] -> Right []\n-      ['$'] -> Left \"Got control character $ with nothing after it. It should be followed by $, u, or U\"\n-      '$' : ctrlCh : chs0 -> case ctrlCh of\n-        '$' -> ('$' :) <$> followUp chs0\n-        'u' -> do\n-          (ch, chs1) <- readEscaped \"$u\" 4 chs0\n-          (ch :) <$> followUp chs1\n-        'U' -> do\n-          (ch, chs1) <- readEscaped \"$U\" 8 chs0\n-          (ch :) <$> followUp chs1\n-        ch -> Left (\"Control character $ should be followed by $, u, or U, but got \" ++ show ch)\n-      ch : chs -> if isAllowed ch\n-        then (ch :) <$> followUp chs\n-        else Left (\"Unexpected unescaped character \" ++ show ch)\n-    \n+    go :: (Char -> Bool) -> (T.Text -> Either String T.Text) -> T.Text -> Either String T.Text\n+    go isAllowed followUp s"
  },
  {
    "id" : "fee7355b-100a-4234-afd0-010cf58102b3",
    "prId" : 4810,
    "comments" : [
      {
        "id" : "a01921db-8e0f-4b46-91d4-5c78b47746eb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Have you benchmarked computing a list of `Text`s and concatenating them in the end? This might be faster than repeated appending when there are a few escaped characters.",
        "createdAt" : "2020-03-04T17:18:35Z",
        "updatedAt" : "2020-03-04T17:46:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d81729bf-c1e4-4ff8-88aa-7738075d8664",
        "parentId" : "a01921db-8e0f-4b46-91d4-5c78b47746eb",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "No I was planning to do that next. I also have some ideas for caching `unmangleIdentifier` as we run it way more often than we should atm which might just move `unmangleIdentifier` out of the hot path.",
        "createdAt" : "2020-03-04T17:50:27Z",
        "updatedAt" : "2020-03-04T17:50:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eb6135f6-c607-40fa-b49c-b5ae2990a11c",
        "parentId" : "a01921db-8e0f-4b46-91d4-5c78b47746eb",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let me guess, we're _not_ doing it once per entry of the interning table but once per reference into the interning table?",
        "createdAt" : "2020-03-04T18:01:25Z",
        "updatedAt" : "2020-03-04T18:01:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b5658934-e360-4dea-a3a0-530a365a645d",
        "parentId" : "a01921db-8e0f-4b46-91d4-5c78b47746eb",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Exactly :slightly_smiling_face: ",
        "createdAt" : "2020-03-04T18:02:55Z",
        "updatedAt" : "2020-03-04T18:02:55Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91ceae53309ae1bbb54b7b6ef69df5b7cb90cdb3",
    "line" : null,
    "diffHunk" : "@@ -108,39 +109,42 @@ mangleIdentifier txt = case T.foldl' f (MangledSize 0 0) txt of\n \n unmangleIdentifier :: T.Text -> Either String T.Text\n unmangleIdentifier txt = do\n-  chs <- goStart (T.unpack txt)\n-  if null chs\n+  chs <- goStart txt\n+  if T.null chs\n     then Left \"Empty identifier\"\n-    else Right (T.pack chs)\n+    else Right chs\n   where\n-    go :: (Char -> Bool) -> (String -> Either String String) -> String -> Either String String\n-    go isAllowed followUp = \\case\n-      [] -> Right []\n-      ['$'] -> Left \"Got control character $ with nothing after it. It should be followed by $, u, or U\"\n-      '$' : ctrlCh : chs0 -> case ctrlCh of\n-        '$' -> ('$' :) <$> followUp chs0\n-        'u' -> do\n-          (ch, chs1) <- readEscaped \"$u\" 4 chs0\n-          (ch :) <$> followUp chs1\n-        'U' -> do\n-          (ch, chs1) <- readEscaped \"$U\" 8 chs0\n-          (ch :) <$> followUp chs1\n-        ch -> Left (\"Control character $ should be followed by $, u, or U, but got \" ++ show ch)\n-      ch : chs -> if isAllowed ch\n-        then (ch :) <$> followUp chs\n-        else Left (\"Unexpected unescaped character \" ++ show ch)\n-    \n+    go :: (Char -> Bool) -> (T.Text -> Either String T.Text) -> T.Text -> Either String T.Text"
  },
  {
    "id" : "b4ca68af-4308-47a5-a3e0-785a98604ccd",
    "prId" : 4810,
    "comments" : [
      {
        "id" : "a0c4d701-afaa-44c0-bb0d-85df934f9d65",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we really need this restriction? What happens if we make the decoder more lenient? This would allow us to avoid the check above and fully rely on `T.hexadecimal`.",
        "createdAt" : "2020-03-04T17:23:36Z",
        "updatedAt" : "2020-03-04T17:46:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f99d0d2d-64da-42e4-8df2-126e93e7a036",
        "parentId" : "a0c4d701-afaa-44c0-bb0d-85df934f9d65",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Should be fine but I don’t want to add more things to this PR than necessary. I also don’t really expect it to make a difference.",
        "createdAt" : "2020-03-04T17:49:29Z",
        "updatedAt" : "2020-03-04T17:50:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "91ceae53309ae1bbb54b7b6ef69df5b7cb90cdb3",
    "line" : 81,
    "diffHunk" : "@@ -108,39 +109,42 @@ mangleIdentifier txt = case T.foldl' f (MangledSize 0 0) txt of\n \n unmangleIdentifier :: T.Text -> Either String T.Text\n unmangleIdentifier txt = do\n-  chs <- goStart (T.unpack txt)\n-  if null chs\n+  chs <- goStart txt\n+  if T.null chs\n     then Left \"Empty identifier\"\n-    else Right (T.pack chs)\n+    else Right chs\n   where\n-    go :: (Char -> Bool) -> (String -> Either String String) -> String -> Either String String\n-    go isAllowed followUp = \\case\n-      [] -> Right []\n-      ['$'] -> Left \"Got control character $ with nothing after it. It should be followed by $, u, or U\"\n-      '$' : ctrlCh : chs0 -> case ctrlCh of\n-        '$' -> ('$' :) <$> followUp chs0\n-        'u' -> do\n-          (ch, chs1) <- readEscaped \"$u\" 4 chs0\n-          (ch :) <$> followUp chs1\n-        'U' -> do\n-          (ch, chs1) <- readEscaped \"$U\" 8 chs0\n-          (ch :) <$> followUp chs1\n-        ch -> Left (\"Control character $ should be followed by $, u, or U, but got \" ++ show ch)\n-      ch : chs -> if isAllowed ch\n-        then (ch :) <$> followUp chs\n-        else Left (\"Unexpected unescaped character \" ++ show ch)\n-    \n+    go :: (Char -> Bool) -> (T.Text -> Either String T.Text) -> T.Text -> Either String T.Text\n+    go isAllowed followUp s\n+        | T.null s = Right T.empty\n+        | Just ('$', s) <- T.uncons s =\n+              case T.uncons s of\n+                  Just ('$', s) -> T.cons '$' <$> followUp s\n+                  Just ('u', s) -> do\n+                      (ch, s') <- readEscaped \"$u\" 4 s\n+                      T.cons ch <$> followUp s'\n+                  Just ('U', s) -> do\n+                      (ch, s') <- readEscaped \"$U\" 8 s\n+                      T.cons ch <$> followUp s'\n+                  _ -> Left \"Control character $ should be followed by $, u or U\"\n+        | otherwise = case T.span isAllowed s of\n+              (prefix, suffix)\n+                  | T.null prefix -> Left (\"Unexpected unescaped character \" ++ show (T.head suffix))\n+                  | otherwise -> fmap (prefix <>) (followUp suffix)\n+\n     goStart = go isAllowedStart goPart\n     goPart = go isAllowedPart goPart\n \n     readEscaped what n chs0 = let\n-      (escaped, chs) = splitAt n chs0\n+      (escaped, chs) = T.splitAt n chs0\n       in if\n-        | length escaped < n ->\n-            Left (\"Expected \" ++ show n ++ \" characters after \" ++ what ++ \", but got \" ++ show (length escaped))\n-        | not (all (`Set.member` escapeSequencesChars) escaped) ->\n+        | T.length escaped < n ->\n+            Left (\"Expected \" ++ show n ++ \" characters after \" ++ what ++ \", but got \" ++ show (T.length escaped))\n+        | not (T.all isEscapeSequenceChars escaped) ->\n             Left (\"Expected only lowercase hex code in escape sequences, but got \" ++ show escaped)\n-        | otherwise -> Right (toEnum (read (\"0x\" ++ escaped)), chs)\n+        | otherwise ->\n+          -- We’ve already done the validation so fromRight is safe.\n+          Right (toEnum (fst $ fromRight (error $ \"Internal error in unmangleIdentifier: \" <> show escaped) $ T.hexadecimal escaped), chs)\n \n     -- only lowercase, as per printf"
  },
  {
    "id" : "74fa46f0-73e0-478e-92b7-b32b4395d266",
    "prId" : 4810,
    "comments" : [
      {
        "id" : "dac5fdbb-9157-4654-8aa0-a5472fa58e92",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This only does the right thing because `isAllowedStart` selects a subset of `isAllowedPart`. Is that intended? If so, we should leave a comment.\r\nThe code would also be easier using `let ... in if ...`.\r\nFinally, it takes some reasoning why the `T.head` never fails. Is there an obvious way to simplify this?",
        "createdAt" : "2020-03-04T17:31:09Z",
        "updatedAt" : "2020-03-04T17:46:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ee203845-47ed-4dd4-8dae-163618fa883e",
        "parentId" : "dac5fdbb-9157-4654-8aa0-a5472fa58e92",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, I’ve refactored this to simple do the `isAllowedStart` check at the beginning (one extra check but it doesn’t make a difference) which allows us to kill both parameters and I’ve also removed the `T.head` call.",
        "createdAt" : "2020-03-04T17:48:59Z",
        "updatedAt" : "2020-03-04T17:50:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "91ceae53309ae1bbb54b7b6ef69df5b7cb90cdb3",
    "line" : null,
    "diffHunk" : "@@ -108,39 +109,42 @@ mangleIdentifier txt = case T.foldl' f (MangledSize 0 0) txt of\n \n unmangleIdentifier :: T.Text -> Either String T.Text\n unmangleIdentifier txt = do\n-  chs <- goStart (T.unpack txt)\n-  if null chs\n+  chs <- goStart txt\n+  if T.null chs\n     then Left \"Empty identifier\"\n-    else Right (T.pack chs)\n+    else Right chs\n   where\n-    go :: (Char -> Bool) -> (String -> Either String String) -> String -> Either String String\n-    go isAllowed followUp = \\case\n-      [] -> Right []\n-      ['$'] -> Left \"Got control character $ with nothing after it. It should be followed by $, u, or U\"\n-      '$' : ctrlCh : chs0 -> case ctrlCh of\n-        '$' -> ('$' :) <$> followUp chs0\n-        'u' -> do\n-          (ch, chs1) <- readEscaped \"$u\" 4 chs0\n-          (ch :) <$> followUp chs1\n-        'U' -> do\n-          (ch, chs1) <- readEscaped \"$U\" 8 chs0\n-          (ch :) <$> followUp chs1\n-        ch -> Left (\"Control character $ should be followed by $, u, or U, but got \" ++ show ch)\n-      ch : chs -> if isAllowed ch\n-        then (ch :) <$> followUp chs\n-        else Left (\"Unexpected unescaped character \" ++ show ch)\n-    \n+    go :: (Char -> Bool) -> (T.Text -> Either String T.Text) -> T.Text -> Either String T.Text\n+    go isAllowed followUp s\n+        | T.null s = Right T.empty\n+        | Just ('$', s) <- T.uncons s =\n+              case T.uncons s of\n+                  Just ('$', s) -> T.cons '$' <$> followUp s\n+                  Just ('u', s) -> do\n+                      (ch, s') <- readEscaped \"$u\" 4 s\n+                      T.cons ch <$> followUp s'\n+                  Just ('U', s) -> do\n+                      (ch, s') <- readEscaped \"$U\" 8 s\n+                      T.cons ch <$> followUp s'\n+                  _ -> Left \"Control character $ should be followed by $, u or U\"\n+        | otherwise = case T.span isAllowed s of"
  },
  {
    "id" : "467a9eff-3c2d-4a8e-9f13-f3192db3b2bd",
    "prId" : 2350,
    "comments" : [
      {
        "id" : "ac1162ae-2404-49a1-869d-af0e2591c6a3",
        "parentId" : null,
        "author" : null,
        "body" : "Nice explanation! :+1: ",
        "createdAt" : "2019-07-31T10:35:14Z",
        "updatedAt" : "2019-07-31T13:20:19Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "fbde3f500aaaccb86c12bf249730d56aefc891c7",
    "line" : 56,
    "diffHunk" : "@@ -46,29 +49,61 @@ isAllowedStart c = c == '_' || isAsciiLetter c\n isAllowedPart :: Char -> Bool\n isAllowedPart c = c == '_' || isAsciiLetter c || isDigit c\n \n-mangleIdentifier :: T.Text -> Either String String\n-mangleIdentifier txt = case T.unpack txt of\n-    [] -> Left \"Empty identifier\"\n-    ch : chs -> Right $ escapeStart ch ++ concatMap escapePart chs\n-\n-escapeStart :: Char -> String\n-escapeStart ch = if\n-  | ch == '$' -> \"$$\"\n-  | isAllowedStart ch -> [ch]\n-  | otherwise -> escapeChar ch\n+data MangledSize = MangledSize\n+    { _unmangledChars :: !Int\n+    , _mangledWord16s :: !Int\n+    }\n \n-escapePart :: Char -> String\n-escapePart ch = if\n-  | ch == '$' -> \"$$\"\n-  | isAllowedPart ch -> [ch]\n-  | otherwise -> escapeChar ch\n+ord' :: Char -> Word16\n+ord' = fromIntegral . ord\n \n-escapeChar :: Char -> String\n-escapeChar ch = let \n-  codePoint = fromEnum ch\n-  in if codePoint > 0xFFFF\n-    then printf \"$U%08x\" codePoint\n-    else printf \"$u%04x\" codePoint\n+-- | We spend a fair amount of time in encodeModule which in turn calls\n+-- `mangleIdentifier` all over the place so we use a heavily optimized implementation.\n+-- In particular, we optimize for the case where don’t have to do any mangling and\n+-- can avoid allocating new `Text`s and we optimize the case where we do have to\n+-- mangle by preallocating the array of the right size and writing the characters\n+-- directly to that."
  },
  {
    "id" : "ebb89ec6-8039-4f9a-9008-736bb5179bd4",
    "prId" : 2350,
    "comments" : [
      {
        "id" : "02d7c3ba-b758-4593-bf15-efc8ee4b5a70",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This might become even faster if we do\r\n```haskell\r\nlet !x' = x `unsafeShiftR` 4\r\nlet !r = x .&. 0x0F\r\n```",
        "createdAt" : "2019-07-31T13:16:12Z",
        "updatedAt" : "2019-07-31T13:20:19Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d940c0dc-c869-4f68-ae55-0eaada1ce56b",
        "parentId" : "02d7c3ba-b758-4593-bf15-efc8ee4b5a70",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thanks Dr. Bittwiddler!",
        "createdAt" : "2019-07-31T13:21:34Z",
        "updatedAt" : "2019-07-31T13:21:35Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fbde3f500aaaccb86c12bf249730d56aefc891c7",
    "line" : null,
    "diffHunk" : "@@ -46,29 +49,61 @@ isAllowedStart c = c == '_' || isAsciiLetter c\n isAllowedPart :: Char -> Bool\n isAllowedPart c = c == '_' || isAsciiLetter c || isDigit c\n \n-mangleIdentifier :: T.Text -> Either String String\n-mangleIdentifier txt = case T.unpack txt of\n-    [] -> Left \"Empty identifier\"\n-    ch : chs -> Right $ escapeStart ch ++ concatMap escapePart chs\n-\n-escapeStart :: Char -> String\n-escapeStart ch = if\n-  | ch == '$' -> \"$$\"\n-  | isAllowedStart ch -> [ch]\n-  | otherwise -> escapeChar ch\n+data MangledSize = MangledSize\n+    { _unmangledChars :: !Int\n+    , _mangledWord16s :: !Int\n+    }\n \n-escapePart :: Char -> String\n-escapePart ch = if\n-  | ch == '$' -> \"$$\"\n-  | isAllowedPart ch -> [ch]\n-  | otherwise -> escapeChar ch\n+ord' :: Char -> Word16\n+ord' = fromIntegral . ord\n \n-escapeChar :: Char -> String\n-escapeChar ch = let \n-  codePoint = fromEnum ch\n-  in if codePoint > 0xFFFF\n-    then printf \"$U%08x\" codePoint\n-    else printf \"$u%04x\" codePoint\n+-- | We spend a fair amount of time in encodeModule which in turn calls\n+-- `mangleIdentifier` all over the place so we use a heavily optimized implementation.\n+-- In particular, we optimize for the case where don’t have to do any mangling and\n+-- can avoid allocating new `Text`s and we optimize the case where we do have to\n+-- mangle by preallocating the array of the right size and writing the characters\n+-- directly to that.\n+mangleIdentifier :: T.Text -> Either String TL.Text\n+mangleIdentifier txt = case T.foldl' f (MangledSize 0 0) txt of\n+    MangledSize 0 _ -> Left \"Empty identifier\"\n+    MangledSize chars word16s\n+      | chars == word16s -> Right $! TL.fromStrict txt\n+      | otherwise -> Right $! TL.fromStrict $\n+        let !arr = TA.run $ do\n+            a <- TA.new word16s\n+            let poke !j !minj !x\n+                  | j < minj = pure ()\n+                  | otherwise = do\n+                        let !(!x', !r) = quotRem x 16"
  }
]