[
  {
    "id" : "545e7272-8ad3-4e06-97a5-596f01678d1a",
    "prId" : 1787,
    "comments" : [
      {
        "id" : "47638c26-79aa-49ba-b96b-b6353d528abf",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Not convinced this primitive is useful, or safe. `actionCatch` has a lot of health warnings around it...",
        "createdAt" : "2019-06-20T19:58:41Z",
        "updatedAt" : "2019-06-20T21:50:12Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "12c953f0-5842-4ed6-87e5-51d00656d05b",
        "parentId" : "47638c26-79aa-49ba-b96b-b6353d528abf",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It was useful to implement things like `getDefinition` where you want short circuiting. I’ve switched those over to use `MaybeT` + `use` now. Not entirely sure I like that given that we are now still mixing two different mechanisms for short circuiting but at least it’s somewhat consistent in the sense that we use `MaybeT` outside of rules and exceptions in a rule.\r\n\r\nSide note: Turning that stuff into rules would mean that we can just use a single call to `use`. Leaving aside the fact that I think that change is orthogonal to this PR, it would also mean that the results would get cached which given the way we currently do garbage collection would mean that we gradually increase memory usage as users hover over more things so I don’t think turning it into rules is a good idea.",
        "createdAt" : "2019-06-20T21:48:02Z",
        "updatedAt" : "2019-06-20T21:50:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5fadf614-495b-45e4-b35f-15a369d898b3",
        "parentId" : "47638c26-79aa-49ba-b96b-b6353d528abf",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I might be convinced its safe over time, and thus we can use it consistently, but at the moment I'm nervous about its semantics.\r\n\r\nAgreed that turning this stuff into rules itself would be a bad idea.",
        "createdAt" : "2019-06-21T07:25:04Z",
        "updatedAt" : "2019-06-21T07:25:04Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6c63c3c27ddcd86f48255895209a8c629b2a0651",
    "line" : null,
    "diffHunk" : "@@ -331,6 +331,10 @@ isBadDependency x\n     | Just (_ :: BadDependency) <- fromException x = True\n     | otherwise = False\n \n+-- | Catches BadDependency exception thrown by uses_ and use_\n+-- and turns it into a Maybe.\n+actionToMaybe :: Action a -> Action (Maybe a)\n+actionToMaybe act = actionCatch (Just <$> act) (\\(_ :: BadDependency) -> pure Nothing)"
  },
  {
    "id" : "e42319e4-54e9-4249-b940-7b3c4beaccd1",
    "prId" : 1423,
    "comments" : [
      {
        "id" : "24caeab1-b1df-4c55-9a17-5755b5e32eb5",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I really like this style of code.",
        "createdAt" : "2019-05-30T11:41:21Z",
        "updatedAt" : "2019-05-30T11:50:11Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "55ff51b7e3b25657762ac2910822bd5ab50d66d2",
    "line" : 92,
    "diffHunk" : "@@ -213,18 +205,21 @@ getValues :: forall k v. IdeRule k v => Var Values -> k -> FilePath -> IO (Maybe\n getValues state key file = do\n     vs <- readVar state\n     return $ do\n-        f <- Map.lookup file vs\n-        v <- Map.lookup (Key key) f\n-        pure $ fmap (fromJust . fromDynamic @v) $ snd v\n+        v <- Map.lookup (file, Key key) vs\n+        pure $ fmap (fromJust . fromDynamic @v) v\n \n -- | Open a 'IdeState', should be shut using 'shakeShut'.\n shakeOpen :: (Event -> IO ()) -- ^ diagnostic handler\n           -> Logger.Handle\n           -> ShakeOptions\n           -> Rules ()\n           -> IO IdeState\n-shakeOpen diags shakeLogger opts rules = do\n-    shakeExtras <- ShakeExtras diags shakeLogger <$> newVar Map.empty <*> newVar Map.empty\n+shakeOpen eventer logger opts rules = do\n+    shakeExtras <- do"
  },
  {
    "id" : "9d9d5b3d-9700-4174-9270-b02c790aafdd",
    "prId" : 1423,
    "comments" : [
      {
        "id" : "16f2ab97-f10f-464d-bab3-b0baffb78c98",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd have put the do on the same line as the `liftIO`. I find the below indentation a bit weird.",
        "createdAt" : "2019-05-30T11:42:07Z",
        "updatedAt" : "2019-05-30T11:50:11Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "55ff51b7e3b25657762ac2910822bd5ab50d66d2",
    "line" : 124,
    "diffHunk" : "@@ -263,20 +258,22 @@ useStale IdeState{shakeExtras=ShakeExtras{state}} k fp =\n \n \n getAllDiagnostics :: IdeState -> IO [FileDiagnostic]\n-getAllDiagnostics IdeState{shakeExtras = ShakeExtras{state}} = do\n-    val <- readVar state\n-    return $ concatMap (concatMap fst . Map.elems) $ Map.elems val\n+getAllDiagnostics IdeState{shakeExtras = ShakeExtras{diagnostics}} = do\n+    val <- readVar diagnostics\n+    return $ D.getAllDiagnostics val\n \n -- | FIXME: This function is temporary! Only required because the files of interest doesn't work\n unsafeClearAllDiagnostics :: IdeState -> IO ()\n-unsafeClearAllDiagnostics IdeState{shakeExtras = ShakeExtras{state}} = modifyVar_ state $\n-    return . Map.map (Map.map (\\(_, x) -> ([], x)))\n+unsafeClearAllDiagnostics IdeState{shakeExtras = ShakeExtras{diagnostics}} =\n+    writeVar diagnostics emptyDiagnostics\n \n -- | Clear the results for all files that do not match the given predicate.\n garbageCollect :: (FilePath -> Bool) -> Action ()\n garbageCollect keep = do\n-    ShakeExtras{state} <- getShakeExtras\n-    liftIO $ modifyVar_ state $ return . Map.filterWithKey (\\file _ -> keep file)\n+    ShakeExtras{state, diagnostics} <- getShakeExtras\n+    liftIO $"
  },
  {
    "id" : "f725851e-028a-4b29-b684-23d8a89d5623",
    "prId" : 724,
    "comments" : [
      {
        "id" : "3f20b0d3-c851-4d5a-bdb3-5c9d85c13096",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "👍 ",
        "createdAt" : "2019-04-26T10:43:11Z",
        "updatedAt" : "2019-04-26T11:19:10Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "214e30babe5d470b67534d40584c7716be75c15f",
    "line" : 6,
    "diffHunk" : "@@ -201,6 +201,9 @@ setValues state key file val = modifyVar state $ \\inVal -> do\n         f = concatMap fst . Map.elems\n     return (outVal, (f <$> Map.lookup file inVal, f $ outVal Map.! file))\n \n+-- | The outer Maybe is Nothing if this function hasn't been computed before\n+--   the inner Maybe is Nothing if the result of the previous computation failed to produce\n+--   a value"
  },
  {
    "id" : "5d648b46-ae03-4207-aaf3-7de55e519f4e",
    "prId" : 708,
    "comments" : [
      {
        "id" : "1e00721d-3420-4d79-9b27-663053292add",
        "parentId" : null,
        "author" : {
          "login" : "DavidM-D",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/11191170?u=3edc6e08b7c7f0d980a6dc81e5a2ce49dd1ef0f0&v=4"
        },
        "body" : "What does the Maybe (Maybe v) mean? For example what does Just Nothing tell me?",
        "createdAt" : "2019-04-26T09:55:39Z",
        "updatedAt" : "2019-04-26T09:55:39Z",
        "lastEditedBy" : {
          "login" : "DavidM-D",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/11191170?u=3edc6e08b7c7f0d980a6dc81e5a2ce49dd1ef0f0&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d508b6a1-c9e3-4aaf-86f1-ecdbd6c74bee",
        "parentId" : "1e00721d-3420-4d79-9b27-663053292add",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Just Nothing tells you that it has been computed, but that last time it computed, it failed to produce a value. There's no point rerunning it because it has working dependencies, so it will fail again. In contrast, Nothing means it hasn't ever been computed.",
        "createdAt" : "2019-04-26T10:01:05Z",
        "updatedAt" : "2019-04-26T10:01:06Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6c53a20bb97387e1da28312292f457da6ca1522f",
    "line" : 56,
    "diffHunk" : "@@ -184,15 +197,17 @@ setValues :: IdeRule k v\n           -> IO (Maybe [Diagnostic], [Diagnostic]) -- ^ (before, after)\n setValues state key file val = modifyVar state $ \\inVal -> do\n     let k = Key key\n-        outVal = Map.insertWith Map.union file (Map.singleton k $ fmap toDyn <$> val) inVal\n+        outVal = Map.insertWith Map.union file (Map.singleton k $ second (fmap toDyn) val) inVal\n         f = concatMap fst . Map.elems\n     return (outVal, (f <$> Map.lookup file inVal, f $ outVal Map.! file))\n \n-getValues :: forall k v. IdeRule k v => Var Values -> k -> FilePath -> IO (Maybe (IdeResult v))\n-getValues state key file = flip fmap (readVar state) $ \\vs -> do\n-    f <- Map.lookup file vs\n-    k <- Map.lookup (Key key) f\n-    pure $ fmap (fromJust . fromDynamic) <$> k\n+getValues :: forall k v. IdeRule k v => Var Values -> k -> FilePath -> IO (Maybe (Maybe v))"
  }
]