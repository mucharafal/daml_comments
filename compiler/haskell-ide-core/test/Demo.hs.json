[
  {
    "id" : "65a6b443-ba53-4838-8d27-fc31e41b850e",
    "prId" : 1670,
    "comments" : [
      {
        "id" : "73950a7a-9444-4ee7-82c6-e8024d436e00",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Best to avoid unsafePerformIO here since it's quite easy to avoid here.",
        "createdAt" : "2019-06-14T13:04:50Z",
        "updatedAt" : "2019-06-14T13:10:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "cbcd4a055d330f14e9aacf57400b77ffba151b84",
    "line" : null,
    "diffHunk" : "@@ -31,8 +31,13 @@ import CmdLineParser\n import DynFlags\n import Panic\n import GHC\n-import GHC.Paths\n+import qualified GHC.Paths\n \n+import System.IO.Unsafe\n+\n+-- Set the GHC libdir to the nix libdir if it's present.\n+libdir :: FilePath\n+libdir = fromMaybe GHC.Paths.libdir $ unsafePerformIO (lookupEnv \"NIX_GHC_LIBDIR\")"
  },
  {
    "id" : "105b3ec7-a05c-49e8-9933-c56240593a9d",
    "prId" : 1251,
    "comments" : [
      {
        "id" : "3dc1c3d0-02cf-49f6-b78a-548ddff71773",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What does this comment want to say?",
        "createdAt" : "2019-05-20T13:38:03Z",
        "updatedAt" : "2019-05-20T14:43:48Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f75c8deb-9adf-47bf-a03f-7bf25955977a",
        "parentId" : "3dc1c3d0-02cf-49f6-b78a-548ddff71773",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Revised, hopefully what it does now say",
        "createdAt" : "2019-05-20T13:45:45Z",
        "updatedAt" : "2019-05-20T14:43:48Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d6b19294-ac9e-4a01-abad-a17b8eb88569",
        "parentId" : "3dc1c3d0-02cf-49f6-b78a-548ddff71773",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Ah, it's about a \"completed message\". I didn't get that. Thanks for expanding.",
        "createdAt" : "2019-05-20T14:01:10Z",
        "updatedAt" : "2019-05-20T14:43:48Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "01413adad4645a3f04f3f75f809fae7042790784",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,100 @@\n+\n+module Demo(main) where\n+\n+import Control.Concurrent.Extra\n+import Control.Monad\n+import System.Time.Extra\n+import Development.IDE.State.Service\n+import Development.IDE.State.Rules\n+import Development.IDE.State.Shake\n+import Development.IDE.State.RuleTypes\n+import Development.IDE.Types.Diagnostics\n+import Development.IDE.Types.Options\n+import Development.IDE.Logger\n+import qualified Data.Text.IO as T\n+import System.Environment\n+import Data.List\n+import Data.Maybe\n+import System.FilePath\n+import Data.Tuple.Extra\n+import System.IO.Extra\n+import Development.IDE.Types.LSP\n+import Development.Shake hiding (Env)\n+import qualified Data.Set as Set\n+\n+import CmdLineParser\n+import DynFlags\n+import Panic\n+import GHC\n+import GHC.Paths\n+\n+\n+main :: IO ()\n+main = do\n+    (ghcOptions, files) <- getCmdLine\n+\n+    -- lock to avoid overlapping output on stdout\n+    lock <- newLock\n+\n+    ide <- initialise\n+        mainRule\n+        (Just $ showEvent lock)\n+        (makeOneHandle $ withLock lock . T.putStrLn)\n+        IdeOptions\n+            {optPreprocessor = (,) []\n+            ,optWriteIface = False\n+            ,optGhcSession = liftIO $ newSession ghcOptions\n+            ,optExtensions = [\"hs\"]\n+            ,optPkgLocationOpts = error \"optPkgLocationOpts not implemented yet\"\n+            ,optThreads = 0\n+            ,optShakeProfiling = Nothing -- Just \"output.html\"\n+            }\n+    setFilesOfInterest ide $ Set.fromList files\n+    _ <- runAction ide $ uses_ TypeCheck files\n+    sleep 0.01 -- since Shake puts its completely message to stdout async"
  }
]