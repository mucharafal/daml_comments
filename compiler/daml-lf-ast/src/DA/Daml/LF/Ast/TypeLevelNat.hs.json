[
  {
    "id" : "c86e3d7d-a4a3-418c-9069-d69d7ef5b4f1",
    "prId" : 3139,
    "comments" : [
      {
        "id" : "381767f2-af95-45c6-a5e5-1584bb239fdd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "For the sake of consistency:\r\n```suggestion\r\n    | n < fromTypeLevelNat minBound || n > fromTypeLevelNat maxBound = Left TLNEOutOfBounds\r\n```",
        "createdAt" : "2019-10-10T10:11:00Z",
        "updatedAt" : "2019-10-10T10:15:58Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2546cc51-00c0-403e-a80e-a3f65cf3e8d0",
        "parentId" : "381767f2-af95-45c6-a5e5-1584bb239fdd",
        "author" : null,
        "body" : "That looks good, thanks!",
        "createdAt" : "2019-10-10T10:16:28Z",
        "updatedAt" : "2019-10-10T10:16:29Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "780d24946d274b5f73e3f046b33a5d44cf55e38e",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,76 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+{-# LANGUAGE DeriveAnyClass #-}\n+{-# LANGUAGE DerivingStrategies #-}\n+{-# LANGUAGE PatternSynonyms #-}\n+\n+-- | Representation of DAML-LF type-level naturals.\n+module DA.Daml.LF.Ast.TypeLevelNat\n+    ( TypeLevelNat\n+    , TypeLevelNatError (..)\n+    , pattern TypeLevelNat10\n+    , fromTypeLevelNat\n+    , typeLevelNatE\n+    , typeLevelNat\n+    ) where\n+\n+import Control.DeepSeq\n+import Data.Data\n+import Data.Hashable\n+import Data.Maybe\n+import Numeric.Natural\n+import GHC.Generics (Generic)\n+\n+-- | A type-level natural. For now these are restricted to being between\n+-- 0 and 37 (inclusive). We do not expose the constructor of this type\n+-- to prevent the construction of values outside of that bound.\n+newtype TypeLevelNat\n+    = TypeLevelNat { unTypeLevelNat :: Int }\n+    deriving newtype (Eq, NFData, Ord, Show, Hashable)\n+    deriving (Data, Generic)\n+\n+data TypeLevelNatError\n+    = TLNEOutOfBounds\n+    deriving (Eq, Ord, Show)\n+\n+instance Bounded TypeLevelNat where\n+    minBound = TypeLevelNat 0\n+    maxBound = TypeLevelNat 37\n+\n+fromTypeLevelNat :: Num b => TypeLevelNat -> b\n+fromTypeLevelNat = fromIntegral . unTypeLevelNat\n+\n+-- | Construct a type-level natural in a safe way.\n+typeLevelNatE :: Integral a => a -> Either TypeLevelNatError TypeLevelNat\n+typeLevelNatE n'\n+    | n < 0 || n > fromTypeLevelNat maxBound = Left TLNEOutOfBounds"
  }
]