[
  {
    "id" : "cb819243-0ae9-46a1-930e-e013947bc6cd",
    "prId" : 5759,
    "comments" : [
      {
        "id" : "01eb5561-b035-4406-90e9-b9137876b233",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This might be easier to read (at least for me):\r\n```suggestion\r\nonMaybe f me1 me2 = case (me1, me2) of\r\n    (Nothing, Nothing) -> True\r\n    (Nothing, Just _) -> False\r\n    (Just _, Nothing) -> False\r\n    (Just e1, Just e2) -> f e1 e2\r\n```",
        "createdAt" : "2020-05-08T17:50:51Z",
        "updatedAt" : "2020-05-11T15:11:14Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7e304c5bdbe25b859f5355cd5e3c0b4e8f275415",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,346 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+-- | Alpha equivalence of types and expressions.\n+module DA.Daml.LF.Ast.Alpha\n+    ( alphaType\n+    , alphaExpr\n+    ) where\n+\n+import qualified Data.Map.Strict as Map\n+\n+import DA.Daml.LF.Ast.Base\n+\n+-- | Auxiliary data structure to track bound variables.\n+data AlphaEnv = AlphaEnv\n+  { currentDepth :: !Int\n+    -- ^ Current binding depth.\n+  , boundTypeVarsLhs :: !(Map.Map TypeVarName Int)\n+    -- ^ Maps bound type variables from the left-hand-side to\n+    -- the depth of the binder which introduced them.\n+  , boundTypeVarsRhs :: !(Map.Map TypeVarName Int)\n+    -- ^ Maps bound type variables from the right-hand-side to\n+    -- the depth of the binder which introduced them.\n+  , boundExprVarsLhs :: !(Map.Map ExprVarName Int)\n+    -- ^ Maps bound expr variables from the left-hand-side  to\n+    -- the depth of the binder which introduced them.\n+  , boundExprVarsRhs :: !(Map.Map ExprVarName Int)\n+    -- ^ Maps bound expr variables from the right-hand-side to\n+    -- the depth of the binder which introduced them.\n+  }\n+\n+onMaybe :: (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool\n+onMaybe f = \\case\n+    Just e1 -> \\case\n+        Just e2 -> f e1 e2\n+        Nothing -> False\n+    Nothing -> \\case\n+        Just _ -> False\n+        Nothing -> True"
  },
  {
    "id" : "588fcdeb-8314-421c-a7fa-67780df0020b",
    "prId" : 5759,
    "comments" : [
      {
        "id" : "4f1ded6c-3bce-498e-8ab1-c3f4a282e8e3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This whole module is written in a very clear style that gives me a lot of trust in the correctness of the code. Great work!",
        "createdAt" : "2020-05-08T18:08:42Z",
        "updatedAt" : "2020-05-11T15:11:14Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7e304c5bdbe25b859f5355cd5e3c0b4e8f275415",
    "line" : 344,
    "diffHunk" : "@@ -0,0 +1,346 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+-- | Alpha equivalence of types and expressions.\n+module DA.Daml.LF.Ast.Alpha\n+    ( alphaType\n+    , alphaExpr\n+    ) where\n+\n+import qualified Data.Map.Strict as Map\n+\n+import DA.Daml.LF.Ast.Base\n+\n+-- | Auxiliary data structure to track bound variables.\n+data AlphaEnv = AlphaEnv\n+  { currentDepth :: !Int\n+    -- ^ Current binding depth.\n+  , boundTypeVarsLhs :: !(Map.Map TypeVarName Int)\n+    -- ^ Maps bound type variables from the left-hand-side to\n+    -- the depth of the binder which introduced them.\n+  , boundTypeVarsRhs :: !(Map.Map TypeVarName Int)\n+    -- ^ Maps bound type variables from the right-hand-side to\n+    -- the depth of the binder which introduced them.\n+  , boundExprVarsLhs :: !(Map.Map ExprVarName Int)\n+    -- ^ Maps bound expr variables from the left-hand-side  to\n+    -- the depth of the binder which introduced them.\n+  , boundExprVarsRhs :: !(Map.Map ExprVarName Int)\n+    -- ^ Maps bound expr variables from the right-hand-side to\n+    -- the depth of the binder which introduced them.\n+  }\n+\n+onMaybe :: (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool\n+onMaybe f = \\case\n+    Just e1 -> \\case\n+        Just e2 -> f e1 e2\n+        Nothing -> False\n+    Nothing -> \\case\n+        Just _ -> False\n+        Nothing -> True\n+\n+onList :: (a -> a -> Bool) -> [a] -> [a] -> Bool\n+onList f xs ys = length xs == length ys\n+    && and (zipWith f xs ys)\n+\n+onFieldList :: Eq a => (b -> b -> Bool) -> [(a,b)] -> [(a,b)] -> Bool\n+onFieldList f xs ys = map fst xs == map fst ys\n+    && and (zipWith f (map snd xs) (map snd ys))\n+\n+bindTypeVar :: TypeVarName -> TypeVarName -> AlphaEnv -> AlphaEnv\n+bindTypeVar x1 x2 env@AlphaEnv{..} = env\n+    { currentDepth = currentDepth + 1\n+    , boundTypeVarsLhs = Map.insert x1 currentDepth boundTypeVarsLhs\n+    , boundTypeVarsRhs = Map.insert x2 currentDepth boundTypeVarsRhs }\n+\n+bindExprVar :: ExprVarName -> ExprVarName -> AlphaEnv -> AlphaEnv\n+bindExprVar x1 x2 env@AlphaEnv{..} = env\n+    { currentDepth = currentDepth + 1\n+    , boundExprVarsLhs = Map.insert x1 currentDepth boundExprVarsLhs\n+    , boundExprVarsRhs = Map.insert x2 currentDepth boundExprVarsRhs }\n+\n+alphaTypeVar :: AlphaEnv -> TypeVarName -> TypeVarName -> Bool\n+alphaTypeVar AlphaEnv{..} x1 x2 =\n+    case (Map.lookup x1 boundTypeVarsLhs, Map.lookup x2 boundTypeVarsRhs) of\n+        (Just l1, Just l2) -> l1 == l2\n+        (Nothing, Nothing) -> x1 == x2\n+        _ -> False\n+\n+alphaExprVar :: AlphaEnv -> ExprVarName -> ExprVarName -> Bool\n+alphaExprVar AlphaEnv{..} x1 x2 =\n+    case (Map.lookup x1 boundExprVarsLhs, Map.lookup x2 boundExprVarsRhs) of\n+        (Just l1, Just l2) -> l1 == l2\n+        (Nothing, Nothing) -> x1 == x2\n+        _ -> False\n+\n+-- | Strongly typed version of (==) for qualified type constructor names.\n+alphaTypeCon :: Qualified TypeConName -> Qualified TypeConName -> Bool\n+alphaTypeCon = (==)\n+\n+alphaType' :: AlphaEnv -> Type -> Type -> Bool\n+alphaType' env = \\case\n+    TVar x1 -> \\case\n+        TVar x2 -> alphaTypeVar env x1 x2\n+        _ -> False\n+    TCon c1 -> \\case\n+        TCon c2 -> alphaTypeCon c1 c2\n+        _ -> False\n+    TApp t1a t1b -> \\case\n+        TApp t2a t2b -> alphaType' env t1a t2a && alphaType' env t1b t2b\n+        _ -> False\n+    TBuiltin b1 -> \\case\n+        TBuiltin b2 -> b1 == b2\n+        _ -> False\n+    TForall (x1, k1) t1' -> \\case\n+        TForall (x2, k2) t2' -> k1 == k2 &&\n+            let env' = bindTypeVar x1 x2 env\n+            in alphaType' env' t1' t2'\n+        _ -> False\n+    TStruct fs1 -> \\case\n+        TStruct fs2 -> onFieldList (alphaType' env) fs1 fs2\n+        _ -> False\n+    TNat n1 -> \\case\n+        TNat n2 -> n1 == n2\n+        _ -> False\n+    TSynApp s1 ts1 -> \\case\n+        TSynApp s2 ts2 -> s1 == s2 && onList (alphaType' env) ts1 ts2\n+        _ -> False\n+\n+alphaTypeConApp :: AlphaEnv -> TypeConApp -> TypeConApp -> Bool\n+alphaTypeConApp env (TypeConApp c1 ts1) (TypeConApp c2 ts2) =\n+    c1 == c2 && onList (alphaType' env) ts1 ts2\n+\n+alphaExpr' :: AlphaEnv -> Expr -> Expr -> Bool\n+alphaExpr' env = \\case\n+    EVar x1 -> \\case\n+        EVar x2 -> alphaExprVar env x1 x2\n+        _ -> False\n+    EVal v1 -> \\case\n+        EVal v2 -> v1 == v2\n+        _ -> False\n+    EBuiltin b1 -> \\case\n+        EBuiltin b2 -> b1 == b2\n+        _ -> False\n+    ERecCon t1 fs1 -> \\case\n+        ERecCon t2 fs2 -> alphaTypeConApp env t1 t2\n+            && onFieldList (alphaExpr' env) fs1 fs2\n+        _ -> False\n+    ERecProj t1 f1 e1 -> \\case\n+        ERecProj t2 f2 e2 -> f1 == f2\n+            && alphaTypeConApp env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    ERecUpd t1 f1 e1a e1b -> \\case\n+        ERecUpd t2 f2 e2a e2b -> f1 == f2\n+            && alphaTypeConApp env t1 t2\n+            && alphaExpr' env e1a e2a\n+            && alphaExpr' env e1b e2b\n+        _ -> False\n+    EVariantCon t1 c1 e1 -> \\case\n+        EVariantCon t2 c2 e2 -> c1 == c2\n+            && alphaTypeConApp env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    EEnumCon t1 c1 -> \\case\n+        EEnumCon t2 c2 -> alphaTypeCon t1 t2 && c1 == c2\n+        _ -> False\n+    EStructCon fs1 -> \\case\n+        EStructCon fs2 -> onFieldList (alphaExpr' env) fs1 fs2\n+        _ -> False\n+    EStructProj f1 e1 -> \\case\n+        EStructProj f2 e2 -> f1 == f2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    EStructUpd f1 e1a e1b -> \\case\n+        EStructUpd f2 e2a e2b -> f1 == f2\n+            && alphaExpr' env e1a e2a\n+            && alphaExpr' env e1b e2b\n+        _ -> False\n+    ETmApp e1a e1b -> \\case\n+        ETmApp e2a e2b -> alphaExpr' env e1a e2a\n+            && alphaExpr' env e1b e2b\n+        _ -> False\n+    ETyApp e1 t1 -> \\case\n+        ETyApp e2 t2 -> alphaExpr' env e1 e2\n+            && alphaType' env t1 t2\n+        _ -> False\n+    ETmLam (x1,t1) e1 -> \\case\n+        ETmLam (x2,t2) e2 -> alphaType' env t1 t2\n+            && alphaExpr' (bindExprVar x1 x2 env) e1 e2\n+        _ -> False\n+    ETyLam (x1,k1) e1 -> \\case\n+        ETyLam (x2,k2) e2 -> k1 == k2\n+            && alphaExpr' (bindTypeVar x1 x2 env) e1 e2\n+        _ -> False\n+    ECase e1 ps1 -> \\case\n+        ECase e2 ps2 -> alphaExpr' env e1 e2\n+            && onList (alphaCase env) ps1 ps2\n+        _ -> False\n+    ELet b1 e1 -> \\case\n+        ELet b2 e2 ->\n+            alphaBinding env b1 b2 (\\env' -> alphaExpr' env' e1 e2)\n+        _ -> False\n+    ENil t1 -> \\case\n+        ENil t2 -> alphaType' env t1 t2\n+        _ -> False\n+    ECons t1 e1a e1b -> \\case\n+        ECons t2 e2a e2b -> alphaType' env t1 t2\n+            && alphaExpr' env e1a e2a\n+            && alphaExpr' env e1b e2b\n+        _ -> False\n+    ESome t1 e1 -> \\case\n+        ESome t2 e2 -> alphaType' env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    ENone t1 -> \\case\n+        ENone t2 -> alphaType' env t1 t2\n+        _ -> False\n+    EToAny t1 e1 -> \\case\n+        EToAny t2 e2 -> alphaType' env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    EFromAny t1 e1 -> \\case\n+        EFromAny t2 e2 -> alphaType' env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    ETypeRep t1 -> \\case\n+        ETypeRep t2 -> alphaType' env t1 t2\n+        _ -> False\n+    EUpdate u1 -> \\case\n+        EUpdate u2 -> alphaUpdate env u1 u2\n+        _ -> False\n+    EScenario s1 -> \\case\n+        EScenario s2 -> alphaScenario env s1 s2\n+        _ -> False\n+    ELocation _ e1 -> \\case\n+        ELocation _ e2 -> alphaExpr' env e1 e2\n+        _ -> False\n+\n+alphaBinding :: AlphaEnv -> Binding -> Binding -> (AlphaEnv -> Bool) -> Bool\n+alphaBinding env (Binding (x1,t1) e1) (Binding (x2,t2) e2) k =\n+    alphaType' env t1 t2 && alphaExpr' env e1 e2 && k (bindExprVar x1 x2 env)\n+\n+alphaCase :: AlphaEnv -> CaseAlternative -> CaseAlternative -> Bool\n+alphaCase env (CaseAlternative p1 e1) (CaseAlternative p2 e2) =\n+    alphaPattern env p1 p2 (\\env' -> alphaExpr' env' e1 e2)\n+\n+alphaPattern :: AlphaEnv -> CasePattern -> CasePattern -> (AlphaEnv -> Bool) -> Bool\n+alphaPattern env p1 p2 k = case p1 of\n+    CPVariant t1 c1 x1 -> case p2 of\n+        CPVariant t2 c2 x2 -> alphaTypeCon t1 t2 && c1 == c2 && k (bindExprVar x1 x2 env)\n+        _ -> False\n+    CPEnum t1 c1 -> case p2 of\n+        CPEnum t2 c2 -> alphaTypeCon t1 t2 && c1 == c2 && k env\n+        _ -> False\n+    CPUnit -> case p2 of\n+        CPUnit -> k env\n+        _ -> False\n+    CPBool b1 -> case p2 of\n+        CPBool b2 -> b1 == b2 && k env\n+        _ -> False\n+    CPNil -> case p2 of\n+        CPNil -> k env\n+        _ -> False\n+    CPCons x1a x1b -> case p2 of\n+        CPCons x2a x2b -> k (bindExprVar x1a x2a (bindExprVar x1b x2b env))\n+        _ -> False\n+    CPNone -> case p2 of\n+        CPNone -> k env\n+        _ -> False\n+    CPSome x1 -> case p2 of\n+        CPSome x2 -> k (bindExprVar x1 x2 env)\n+        _ -> False\n+    CPDefault -> case p2 of\n+        CPDefault -> k env\n+        _ -> False\n+\n+alphaUpdate :: AlphaEnv -> Update -> Update -> Bool\n+alphaUpdate env = \\case\n+    UPure t1 e1 -> \\case\n+        UPure t2 e2 -> alphaType' env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    UBind b1 e1 -> \\case\n+        UBind b2 e2 ->\n+            alphaBinding env b1 b2 (\\env' -> alphaExpr' env' e1 e2)\n+        _ -> False\n+    UCreate t1 e1 -> \\case\n+        UCreate t2 e2 -> alphaTypeCon t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    UExercise t1 c1 e1a e1b e1c -> \\case\n+        UExercise t2 c2 e2a e2b e2c -> alphaTypeCon t1 t2\n+            && c1 == c2\n+            && alphaExpr' env e1a e2a\n+            && onMaybe (alphaExpr' env) e1b e2b\n+            && alphaExpr' env e1c e2c\n+        _ -> False\n+    UFetch t1 e1 -> \\case\n+        UFetch t2 e2 -> alphaTypeCon t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    UGetTime -> \\case\n+        UGetTime -> True\n+        _ -> False\n+    UEmbedExpr t1 e1 -> \\case\n+        UEmbedExpr t2 e2 -> alphaType' env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    ULookupByKey r1 -> \\case\n+        ULookupByKey r2 -> alphaRetrieveByKey env r1 r2\n+        _ -> False\n+    UFetchByKey r1 -> \\case\n+        UFetchByKey r2 -> alphaRetrieveByKey env r1 r2\n+        _ -> False\n+\n+alphaRetrieveByKey :: AlphaEnv -> RetrieveByKey -> RetrieveByKey -> Bool\n+alphaRetrieveByKey env (RetrieveByKey t1 e1) (RetrieveByKey t2 e2) =\n+    alphaTypeCon t1 t2 && alphaExpr' env e1 e2\n+\n+alphaScenario :: AlphaEnv -> Scenario -> Scenario -> Bool\n+alphaScenario env = \\case\n+    SPure t1 e1 -> \\case\n+        SPure t2 e2 -> alphaType' env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+    SBind b1 e1 -> \\case\n+        SBind b2 e2 ->\n+            alphaBinding env b1 b2 (\\env' -> alphaExpr' env' e1 e2)\n+        _ -> False\n+    SCommit t1 e1a e1b -> \\case\n+        SCommit t2 e2a e2b -> alphaType' env t1 t2\n+            && alphaExpr' env e1a e2a\n+            && alphaExpr' env e1b e2b\n+        _ -> False\n+    SMustFailAt t1 e1a e1b -> \\case\n+        SMustFailAt t2 e2a e2b -> alphaType' env t1 t2\n+            && alphaExpr' env e1a e2a\n+            && alphaExpr' env e1b e2b\n+        _ -> False\n+    SPass e1 -> \\case\n+        SPass e2 -> alphaExpr' env e1 e2\n+        _ -> False\n+    SGetTime -> \\case\n+        SGetTime -> True\n+        _ -> False\n+    SGetParty e1 -> \\case\n+        SGetParty e2 -> alphaExpr' env e1 e2\n+        _ -> False\n+    SEmbedExpr t1 e1 -> \\case\n+        SEmbedExpr t2 e2 -> alphaType' env t1 t2\n+            && alphaExpr' env e1 e2\n+        _ -> False\n+\n+initialAlphaEnv :: AlphaEnv\n+initialAlphaEnv = AlphaEnv\n+    { currentDepth = 0\n+    , boundTypeVarsLhs = Map.empty\n+    , boundTypeVarsRhs = Map.empty\n+    , boundExprVarsLhs = Map.empty\n+    , boundExprVarsRhs = Map.empty\n+    }\n+\n+alphaType :: Type -> Type -> Bool\n+alphaType = alphaType' initialAlphaEnv\n+\n+alphaExpr :: Expr -> Expr -> Bool\n+alphaExpr = alphaExpr' initialAlphaEnv"
  }
]