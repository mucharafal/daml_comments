[
  {
    "id" : "63969ea0-23b9-4e35-b428-54db71c03ed8",
    "prId" : 5759,
    "comments" : [
      {
        "id" : "27614ea1-874a-4963-ba87-529ba79ee056",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm slightly worried that we'll end up in situations where optimizations don't kick in because we've overapproximated the free variables. I know that we deliberately overapproximate in other places and that's why this function will probably be the last suspect when debugging. That said, I'd prefer if we make this function precise, either here or in a follow-up PR.",
        "createdAt" : "2020-05-08T18:18:56Z",
        "updatedAt" : "2020-05-11T15:11:14Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7434e9fd-e493-443f-9ee7-ac6aa520eeb1",
        "parentId" : "27614ea1-874a-4963-ba87-529ba79ee056",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "üëç Making it more precise. ",
        "createdAt" : "2020-05-11T10:22:42Z",
        "updatedAt" : "2020-05-11T15:11:14Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7e304c5bdbe25b859f5355cd5e3c0b4e8f275415",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,141 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.LF.Ast.FreeVars\n+    ( FreeVars\n+    , freeTypeVars\n+    , freeExprVars\n+    , freeTypeVar\n+    , freeExprVar\n+    , bindTypeVar\n+    , bindExprVar\n+    , isFreeTypeVar\n+    , isFreeExprVar\n+    , freeVarsInType\n+    , freeVarsInTypeConApp\n+    , freeVarsInExpr\n+    , freeVarsStep\n+    , freshenTypeVar\n+    , freshenExprVar\n+    ) where\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Ast.Recursive\n+import qualified DA.Daml.LF.Ast.Type as Type\n+\n+import Data.Functor.Foldable (cata)\n+import Data.Maybe (fromMaybe)\n+import qualified Data.Set as Set\n+import qualified Data.Text as T\n+import Safe (findJust)\n+\n+data FreeVars = FreeVars\n+    { freeTypeVars :: Set.Set TypeVarName\n+    , freeExprVars :: Set.Set ExprVarName\n+    }\n+\n+instance Semigroup FreeVars where\n+    FreeVars a1 b1 <> FreeVars a2 b2 =\n+        FreeVars (Set.union a1 a2) (Set.union b1 b2)\n+\n+instance Monoid FreeVars where\n+    mempty = FreeVars Set.empty Set.empty\n+\n+freeTypeVar :: TypeVarName -> FreeVars\n+freeTypeVar x = FreeVars (Set.singleton x) Set.empty\n+\n+freeExprVar :: ExprVarName -> FreeVars\n+freeExprVar x = FreeVars Set.empty (Set.singleton x)\n+\n+bindTypeVar :: TypeVarName -> FreeVars -> FreeVars\n+bindTypeVar x fvs = fvs { freeTypeVars = Set.delete x (freeTypeVars fvs) }\n+\n+bindExprVar :: ExprVarName -> FreeVars -> FreeVars\n+bindExprVar x fvs = fvs { freeExprVars = Set.delete x (freeExprVars fvs) }\n+\n+isFreeTypeVar :: TypeVarName -> FreeVars -> Bool\n+isFreeTypeVar x = Set.member x . freeTypeVars\n+\n+isFreeExprVar :: ExprVarName -> FreeVars -> Bool\n+isFreeExprVar x = Set.member x . freeExprVars\n+\n+freeVarsInType :: Type -> FreeVars\n+freeVarsInType ty = FreeVars (Type.freeVars ty) Set.empty\n+\n+freeVarsInTypeConApp :: TypeConApp -> FreeVars\n+freeVarsInTypeConApp (TypeConApp _ tys) = foldMap freeVarsInType tys\n+\n+freeVarsInExpr :: Expr -> FreeVars\n+freeVarsInExpr = cata freeVarsStep\n+\n+freeVarsStep :: ExprF FreeVars -> FreeVars\n+freeVarsStep = \\case\n+    EVarF x -> freeExprVar x\n+    EValF _ -> mempty\n+    EBuiltinF _ -> mempty\n+    ERecConF t fs -> freeVarsInTypeConApp t <> foldMap snd fs\n+    ERecProjF t _ e -> freeVarsInTypeConApp t <> e\n+    ERecUpdF t _ e1 e2 -> freeVarsInTypeConApp t <> e1 <> e2\n+    EVariantConF t _ e -> freeVarsInTypeConApp t <> e\n+    EEnumConF _ _ -> mempty\n+    EStructConF fs -> foldMap snd fs\n+    EStructProjF _ e -> e\n+    EStructUpdF _ e1 e2 -> e1 <> e2\n+    ETmAppF e1 e2 -> e1 <> e2\n+    ETyAppF e t -> e <> freeVarsInType t\n+    ETmLamF (x, t) e -> freeVarsInType t <> bindExprVar x e\n+    ETyLamF (x, _) e -> bindTypeVar x e\n+    ECaseF e cs -> e <> foldMap goCase cs\n+    ELetF b e -> goBinding b e\n+    ENilF t -> freeVarsInType t\n+    EConsF t e1 e2 -> freeVarsInType t <> e1 <> e2\n+    EUpdateF u -> goUpdate u\n+    EScenarioF s -> goScenario s\n+    ELocationF _ e -> e\n+    ENoneF t -> freeVarsInType t\n+    ESomeF t e -> freeVarsInType t <> e\n+    EToAnyF t e -> freeVarsInType t <> e\n+    EFromAnyF t e -> freeVarsInType t <> e\n+    ETypeRepF t -> freeVarsInType t\n+\n+  where\n+\n+    goCase :: (CasePattern, FreeVars) -> FreeVars\n+    goCase = snd -- overapproximation is fine and cheap"
  }
]