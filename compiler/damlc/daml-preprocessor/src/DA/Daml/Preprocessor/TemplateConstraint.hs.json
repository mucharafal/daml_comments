[
  {
    "id" : "f42075da-72ff-450f-aebf-414e3623aa94",
    "prId" : 2871,
    "comments" : [
      {
        "id" : "7cf20f91-d7eb-42c9-b4c3-fc441f38b9e1",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Great comment :D",
        "createdAt" : "2019-09-10T19:54:15Z",
        "updatedAt" : "2019-09-11T08:58:14Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "40382b239dcd82ff6195ff55027641feacaa396f",
    "line" : 25,
    "diffHunk" : "@@ -0,0 +1,83 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+-- | Every `template T a_1 a_n` gets desugared into a `class TInstance a_1 ... a_n`,\n+-- an instance\n+-- ```\n+-- (*)    instance TInstance a_1 ... a_n => Template (T a_1 ... a_n)\n+-- ```\n+-- and instances `instance TInstance a_1 ... a_n => Choice (T a_1 ... a_n) C R`\n+-- for each choice `C`.\n+--\n+-- Thus, a _generic_ exercise of a choice on `T t_1 ... t_n` needs to have the\n+-- `TInstance t_1 ... t_n` constraint in scope. However, we want to keep the\n+-- existence of the `TInstance` class an implementation detail and not expose\n+-- it to our users. Instead we want our users to add a `Template (T t_1 ... t_n)`\n+-- constraint when they want to perform the generic exercise.\n+--\n+-- Due to the (*) instance above, the constraint `Template (T t_1 ... t_n)`\n+-- is satisfied if and only if the constraint `TInstance t_1 ... t_n` is\n+-- satisfied. For the intent described above it would be necessary that GHC\n+-- conlcudes the latter from the former. Unfortunately, GHC's type system only\n+-- allows for concluding the former from the latter.\n+--\n+-- Thus, we add a preprocessing step which rewrites all constraints of\n+-- the form `Template (T t_1 ... t_n)` into `TInstance t_1 ... t_n`."
  },
  {
    "id" : "bf5b7481-9a74-409b-8d63-b86b6582bd74",
    "prId" : 2871,
    "comments" : [
      {
        "id" : "dbdd20f7-fa06-49e5-98e4-d8c61f543ffa",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "`HsContext` is a synonym for `[HsType]` as I remember - does Uniplate `descend` not understand that and descend on the contexts?",
        "createdAt" : "2019-09-10T20:15:34Z",
        "updatedAt" : "2019-09-11T08:58:14Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d54b8119-dc52-48e1-a442-e804b041f2d0",
        "parentId" : "dbdd20f7-fa06-49e5-98e4-d8c61f543ffa",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Uniplate works type based. Thus, it would descend into all `[HsType]` occurrences. I don't know if they appear somewhere else now or might do so in the future. That's why I prefer to be precise about this.",
        "createdAt" : "2019-09-11T08:49:32Z",
        "updatedAt" : "2019-09-11T08:58:14Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "40382b239dcd82ff6195ff55027641feacaa396f",
    "line" : 45,
    "diffHunk" : "@@ -0,0 +1,83 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+-- | Every `template T a_1 a_n` gets desugared into a `class TInstance a_1 ... a_n`,\n+-- an instance\n+-- ```\n+-- (*)    instance TInstance a_1 ... a_n => Template (T a_1 ... a_n)\n+-- ```\n+-- and instances `instance TInstance a_1 ... a_n => Choice (T a_1 ... a_n) C R`\n+-- for each choice `C`.\n+--\n+-- Thus, a _generic_ exercise of a choice on `T t_1 ... t_n` needs to have the\n+-- `TInstance t_1 ... t_n` constraint in scope. However, we want to keep the\n+-- existence of the `TInstance` class an implementation detail and not expose\n+-- it to our users. Instead we want our users to add a `Template (T t_1 ... t_n)`\n+-- constraint when they want to perform the generic exercise.\n+--\n+-- Due to the (*) instance above, the constraint `Template (T t_1 ... t_n)`\n+-- is satisfied if and only if the constraint `TInstance t_1 ... t_n` is\n+-- satisfied. For the intent described above it would be necessary that GHC\n+-- conlcudes the latter from the former. Unfortunately, GHC's type system only\n+-- allows for concluding the former from the latter.\n+--\n+-- Thus, we add a preprocessing step which rewrites all constraints of\n+-- the form `Template (T t_1 ... t_n)` into `TInstance t_1 ... t_n`.\n+module DA.Daml.Preprocessor.TemplateConstraint (\n+    templateConstraintPreprocessor\n+    ) where\n+\n+import \"ghc-lib\" GHC\n+import \"ghc-lib-parser\" BasicTypes\n+import \"ghc-lib-parser\" OccName\n+import \"ghc-lib-parser\" RdrName\n+\n+import Data.Generics.Uniplate.Data\n+\n+templateConstraintPreprocessor :: ParsedSource -> ParsedSource\n+templateConstraintPreprocessor = fmap onModule\n+\n+onModule :: HsModule GhcPs -> HsModule GhcPs\n+onModule = transformBi onType . transformBi onTyClDecl\n+\n+-- | The contexts of class and data definitions do not live inside an\n+-- `HsType` but in their respective AST nodes. That's why we need to chase\n+-- them down separately."
  },
  {
    "id" : "5ee1b434-46c5-4db9-b6cd-857a58855eb8",
    "prId" : 2871,
    "comments" : [
      {
        "id" : "8d97f5ed-e517-4858-8c8d-db97d571f670",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we at least check the module here as well?",
        "createdAt" : "2019-09-11T06:15:16Z",
        "updatedAt" : "2019-09-11T08:58:14Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "86f9e3cb-bae5-4843-87cc-ba439abc9456",
        "parentId" : "8d97f5ed-e517-4858-8c8d-db97d571f670",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The module name would be the alias the user picks when importing the module containing the `Template` class. Thus, there's nothing we could really check for.",
        "createdAt" : "2019-09-11T08:50:25Z",
        "updatedAt" : "2019-09-11T08:58:14Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "40382b239dcd82ff6195ff55027641feacaa396f",
    "line" : 59,
    "diffHunk" : "@@ -0,0 +1,83 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+-- | Every `template T a_1 a_n` gets desugared into a `class TInstance a_1 ... a_n`,\n+-- an instance\n+-- ```\n+-- (*)    instance TInstance a_1 ... a_n => Template (T a_1 ... a_n)\n+-- ```\n+-- and instances `instance TInstance a_1 ... a_n => Choice (T a_1 ... a_n) C R`\n+-- for each choice `C`.\n+--\n+-- Thus, a _generic_ exercise of a choice on `T t_1 ... t_n` needs to have the\n+-- `TInstance t_1 ... t_n` constraint in scope. However, we want to keep the\n+-- existence of the `TInstance` class an implementation detail and not expose\n+-- it to our users. Instead we want our users to add a `Template (T t_1 ... t_n)`\n+-- constraint when they want to perform the generic exercise.\n+--\n+-- Due to the (*) instance above, the constraint `Template (T t_1 ... t_n)`\n+-- is satisfied if and only if the constraint `TInstance t_1 ... t_n` is\n+-- satisfied. For the intent described above it would be necessary that GHC\n+-- conlcudes the latter from the former. Unfortunately, GHC's type system only\n+-- allows for concluding the former from the latter.\n+--\n+-- Thus, we add a preprocessing step which rewrites all constraints of\n+-- the form `Template (T t_1 ... t_n)` into `TInstance t_1 ... t_n`.\n+module DA.Daml.Preprocessor.TemplateConstraint (\n+    templateConstraintPreprocessor\n+    ) where\n+\n+import \"ghc-lib\" GHC\n+import \"ghc-lib-parser\" BasicTypes\n+import \"ghc-lib-parser\" OccName\n+import \"ghc-lib-parser\" RdrName\n+\n+import Data.Generics.Uniplate.Data\n+\n+templateConstraintPreprocessor :: ParsedSource -> ParsedSource\n+templateConstraintPreprocessor = fmap onModule\n+\n+onModule :: HsModule GhcPs -> HsModule GhcPs\n+onModule = transformBi onType . transformBi onTyClDecl\n+\n+-- | The contexts of class and data definitions do not live inside an\n+-- `HsType` but in their respective AST nodes. That's why we need to chase\n+-- them down separately.\n+onTyClDecl :: TyClDecl GhcPs -> TyClDecl GhcPs\n+onTyClDecl decl = case decl of\n+    ClassDecl{tcdCtxt} -> decl{tcdCtxt = fmap onContext tcdCtxt}\n+    DataDecl{tcdDataDefn = defn@HsDataDefn{dd_ctxt}} -> decl{tcdDataDefn = defn{dd_ctxt = fmap onContext dd_ctxt}}\n+    _ -> decl\n+\n+onType :: HsType GhcPs-> HsType GhcPs\n+onType = \\case\n+    HsQualTy ext ctxt t -> HsQualTy ext (fmap onContext ctxt) (fmap onType t)\n+    t -> descend onType t\n+\n+onContext :: HsContext GhcPs -> HsContext GhcPs\n+onContext = map . fmap $ \\case\n+    HsAppTy _ (L _ (HsTyVar _ _ (L _ (occNameString . rdrNameOcc -> \"Template\")))) (L _ t)"
  }
]