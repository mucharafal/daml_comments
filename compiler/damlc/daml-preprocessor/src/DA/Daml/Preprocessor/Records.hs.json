[
  {
    "id" : "103868a6-9dff-49d0-8ec7-1ea175ca5099",
    "prId" : 2873,
    "comments" : [
      {
        "id" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "“never appears to need bracketing” seems a bit too unsure to make me comfortable :slightly_smiling_face:. I don’t really know how GHC resolves precedences but it seems like you could end up with `(setField @\"foo\" x y) + z` instead of `setField @\"foo\" x (y + z)`. Have you tested this and similar cases, e.g., it would also be interesting to have another function application there so `y z`.",
        "createdAt" : "2019-09-11T06:49:52Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b04ef6ca-140e-4a6d-84a1-9ace42daa8c2",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We probably at least want to have some test cases that hit this.",
        "createdAt" : "2019-09-11T06:52:28Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "148bb4a7-11ae-4907-a03d-d804e579629c",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : null,
        "body" : "`rupd_expr` is the record part of the update in `RecordUpd {rupd_expr; rupd_fields}`. I think there are 3 possibilities : `rupd_expr` is a var, `rupd_expr` is an application, `rupd_expr` is a record constructor/update. (1) doesn't need bracketing, (2) needs to be in brackets already or it won't parse and (3) never needs bracketing.  ",
        "createdAt" : "2019-09-11T09:14:23Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ad24ad20-6520-46d0-a790-ebe4cedf2b1b",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : null,
        "body" : "I'll fix the comment. I agree it doesn't inspire confidence :) I wrote it based on practice before I'd convinced myself by theory.",
        "createdAt" : "2019-09-11T09:34:18Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a38942b5-fb01-4615-aa28-9f96912e400e",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : null,
        "body" : "(1) `-- 'rupd_expr' never needs bracketing.`\r\n(2) `-- Don't bracket here. The argument came in as a section so it's already enclosed in brackets.`",
        "createdAt" : "2019-09-11T09:35:39Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "965d3f6f-4999-40a0-a260-e2a0078e29fc",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m still not convinced, sorry :slightly_smiling_face:  In particular, I am not convinced that 2 holds. If I have `x { a = y, b = z }` I believe you will first rewrite this to `setField @\"a\" x { b = z }` and then when you rewrite this it breaks.",
        "createdAt" : "2019-09-11T09:42:46Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "820c04ed-04f6-4929-993c-ba3f6174e95d",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : null,
        "body" : "Test:\r\n```\r\ndata C = C {a : Int, b: Int}\r\ng x y z = x {a = y, b = z}\r\n```\r\nCompiles and is lint free.",
        "createdAt" : "2019-09-11T09:54:10Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5c50ff6d-e075-469e-b369-c45e7668dc99",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : null,
        "body" : "Which 2 is it that you are not convinced holds?",
        "createdAt" : "2019-09-11T09:57:07Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eae77558-73d5-46a1-a750-0258f929caa4",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : null,
        "body" : "> “never appears to need bracketing” seems a bit too unsure to make me comfortable 🙂. I don’t really know how GHC resolves precedences but it seems like you could end up with `(setField @\"foo\" x y) + z` instead of `setField @\"foo\" x (y + z)`. Have you tested this and similar cases, e.g., it would also be interesting to have another function application there so `y z`.\r\n\r\nHere's some tests that I think covers those?\r\n```\r\ndata C = C {a : Int, b: Int}\r\ng x y z = x {a = y, b = z}\r\nh x y z = x {a = y + z}\r\n\r\nmkC a b = C with a, b\r\n\r\nmain = scenario do\r\n  let x = C {a = 1, b = 2}\r\n  let x' = g x 3 4\r\n  assert $ x'.a == 3 && x'.b == 4\r\n\r\n  let x'' = h x 1 2\r\n  assert $ x''.a == 3\r\n\r\n  let x''' = h (mkC 5 6) 1 1\r\n  assert $ x'''.a == 2\r\n```",
        "createdAt" : "2019-09-11T10:17:23Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c43005c4-d319-44fa-9863-37ffa2f6ca63",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : null,
        "body" : "One more from above you asked for and I missed `i x y =  x {a = succ y}` :\r\n```\r\n  let x'''' = i C {a = 1, b = 2} 2\r\n  assert $ x''''.a == 3\r\n```\r\n",
        "createdAt" : "2019-09-11T10:32:13Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bd99e9df-b5c3-4106-a938-07cd06076233",
        "parentId" : "4e67c3d3-1b5f-4820-a704-c15c10e6d9e4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If it works then all is good but I’m still not sure I understand how it works. Is it as simple as GHC doesn’t care if `rupd_expr` has parentheses or not? It seems like you will definitely not always have parentheses around the expression if there are multiple field updates.",
        "createdAt" : "2019-09-11T11:13:46Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6423ef3c9ef66717c4d2bf90fb6cdfd33bb403a6",
    "line" : null,
    "diffHunk" : "@@ -158,13 +158,14 @@ onExp (L o (SectionR _ mid@(isDot -> True) rhs))\n     , srcSpanStart o == srcSpanStart (getLoc mid)\n     , srcSpanEnd o == srcSpanEnd (getLoc rhs)\n     , Just sels <- getSelectors rhs\n-    = setL o $ mkParen $ foldl1 (\\x y -> noL $ OpApp noE x (mkVar var_dot) y) $ map (mkVar var_getField `mkAppType`) $ reverse sels\n+    -- Don't bracket : it came in as a section so it's already enclosed.\n+    = setL o $ foldl1 (\\x y -> noL $ OpApp noE x (mkVar var_dot) y) $ map (mkVar var_getField `mkAppType`) $ reverse sels\n \n -- Turn a{b=c, ...} into setField calls\n onExp (L o upd@RecordUpd{rupd_expr,rupd_flds=L _ (HsRecField (fmap rdrNameAmbiguousFieldOcc -> lbl) arg pun):flds})\n     | let sel = mkSelector lbl\n     , let arg2 = if pun then noL $ HsVar noE lbl else arg\n-    , let expr = mkParen $ mkVar var_setField `mkAppType` sel `mkApp` arg2 `mkApp` mkParen rupd_expr\n+    , let expr = mkParen $ mkVar var_setField `mkAppType` sel `mkApp` arg2 `mkApp` rupd_expr -- 'rupd_expr' never appears to need bracketing."
  },
  {
    "id" : "64fa7ca4-b1c0-41fc-80f3-6a80693e8e9a",
    "prId" : 2873,
    "comments" : [
      {
        "id" : "758817e3-8949-46f3-bf53-20fdf37b6e8f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is not about `:` is it? At least according to the comment above this is about sections on record accessors so `(.foo.bar)`. It is also not clear to me how this ends up looking in the AST. Do we end up with `mkParen (SectionR …)` or does the whole thing parse as `SectionR …`? In the latter case, removing the parenthesis is not going to work.",
        "createdAt" : "2019-09-11T06:54:52Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a77bcea2-7a91-4531-af8a-8b17c3d0a8bc",
        "parentId" : "758817e3-8949-46f3-bf53-20fdf37b6e8f",
        "author" : null,
        "body" : "This is about sections. It is lexically impossible to write a \"raw\" section in Haskell - they must be parenthesized. That means that the expression being transformed is in the context of an enclosing brackets. Bracketing here the causes double ups `((expr))`. ",
        "createdAt" : "2019-09-11T09:17:10Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "676cf02f-30c2-4d66-9c5b-3c871e4ee802",
        "parentId" : "758817e3-8949-46f3-bf53-20fdf37b6e8f",
        "author" : null,
        "body" : "To clarify, `(.foo.bar)` is parsed as `HsPar (HsSectionR {...})`. \r\n",
        "createdAt" : "2019-09-11T09:18:19Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9ff0138d-18da-4bcc-9121-6bc5e33c6dbc",
        "parentId" : "758817e3-8949-46f3-bf53-20fdf37b6e8f",
        "author" : null,
        "body" : "I'll improve the comment.",
        "createdAt" : "2019-09-11T09:18:51Z",
        "updatedAt" : "2019-09-11T15:56:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6423ef3c9ef66717c4d2bf90fb6cdfd33bb403a6",
    "line" : null,
    "diffHunk" : "@@ -158,13 +158,14 @@ onExp (L o (SectionR _ mid@(isDot -> True) rhs))\n     , srcSpanStart o == srcSpanStart (getLoc mid)\n     , srcSpanEnd o == srcSpanEnd (getLoc rhs)\n     , Just sels <- getSelectors rhs\n-    = setL o $ mkParen $ foldl1 (\\x y -> noL $ OpApp noE x (mkVar var_dot) y) $ map (mkVar var_getField `mkAppType`) $ reverse sels\n+    -- Don't bracket : it came in as a section so it's already enclosed."
  },
  {
    "id" : "667c3d16-b6d4-430f-98cb-b9308e9ab66b",
    "prId" : 2865,
    "comments" : [
      {
        "id" : "1ef5436a-f67d-4fe5-b1b4-1ceeeeb33ccb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        result = foldl' (\\x y -> noL $ HsAppTy noE x $ hsLTyVarBndrToType y)\r\n```",
        "createdAt" : "2019-09-10T15:08:16Z",
        "updatedAt" : "2019-09-10T15:17:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6f05a8af-7657-4d73-82ee-91dca9a83a7b",
        "parentId" : "1ef5436a-f67d-4fe5-b1b4-1ceeeeb33ccb",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-09-10T15:15:02Z",
        "updatedAt" : "2019-09-10T15:17:59Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "52c2d609718a90b6f6baa1c559546e5630d68eba",
    "line" : null,
    "diffHunk" : "@@ -117,16 +117,22 @@ onDecl o = descendBi onExp o : extraDecls o\n             where ctors = dd_cons $ tcdDataDefn x\n         extraDecls _ = []\n \n-getFields :: TyClDecl GhcPs -> [(LHsType GhcPs, IdP GhcPs, FieldOcc GhcPs, HsType GhcPs)]\n+-- Process a Haskell data type definition. Walk its constructors. For\n+-- each, harvest a tuple of the parent type, the ctor name, the field\n+-- name and the field type.\n+getFields :: TyClDecl GhcPs ->\n+               [(LHsType GhcPs, IdP GhcPs, FieldOcc GhcPs, HsType GhcPs)]\n getFields DataDecl{tcdDataDefn=HsDataDefn{..}, ..} = concatMap ctor dd_cons\n     where\n         ctor (L _ ConDeclH98{con_args=RecCon (L _ fields),con_name=L _ name}) = concatMap (field name) fields\n-        ctor _ = []\n+        ctor _ = [] -- GADT ctors ignored.\n \n         field name (L _ ConDeclField{cd_fld_type=L _ ty, ..}) = [(result, name, fld, ty) | L _ fld <- cd_fld_names]\n         field _ _ = error \"unknown field declaration in getFields\"\n \n-        result = noL $ HsParTy noE $ foldl (\\x y -> noL $ HsAppTy noE x $ hsLTyVarBndrToType y) (noL $ HsTyVar noE GHC.NotPromoted tcdLName) $ hsq_explicit tcdTyVars\n+        -- A value of this data declaration will have this type.\n+        result = foldl (\\x y -> noL $ HsAppTy noE x $ hsLTyVarBndrToType y)"
  },
  {
    "id" : "c3930ba4-3969-4b0b-be4e-7f523e66a267",
    "prId" : 2865,
    "comments" : [
      {
        "id" : "193375e5-f395-4f23-a9b6-3a8abc8c6cb7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Leverage the compiler to \"check\" the comment:\r\n```suggestion\r\n        ctor (L _ ConDeclGADT{}) = []\r\n```",
        "createdAt" : "2019-09-10T15:10:15Z",
        "updatedAt" : "2019-09-10T15:17:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0dd817ea-1434-4caa-98e3-0f730ca43f52",
        "parentId" : "193375e5-f395-4f23-a9b6-3a8abc8c6cb7",
        "author" : null,
        "body" : "✔️ \r\n",
        "createdAt" : "2019-09-10T15:14:41Z",
        "updatedAt" : "2019-09-10T15:17:59Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "52c2d609718a90b6f6baa1c559546e5630d68eba",
    "line" : null,
    "diffHunk" : "@@ -117,16 +117,22 @@ onDecl o = descendBi onExp o : extraDecls o\n             where ctors = dd_cons $ tcdDataDefn x\n         extraDecls _ = []\n \n-getFields :: TyClDecl GhcPs -> [(LHsType GhcPs, IdP GhcPs, FieldOcc GhcPs, HsType GhcPs)]\n+-- Process a Haskell data type definition. Walk its constructors. For\n+-- each, harvest a tuple of the parent type, the ctor name, the field\n+-- name and the field type.\n+getFields :: TyClDecl GhcPs ->\n+               [(LHsType GhcPs, IdP GhcPs, FieldOcc GhcPs, HsType GhcPs)]\n getFields DataDecl{tcdDataDefn=HsDataDefn{..}, ..} = concatMap ctor dd_cons\n     where\n         ctor (L _ ConDeclH98{con_args=RecCon (L _ fields),con_name=L _ name}) = concatMap (field name) fields\n-        ctor _ = []\n+        ctor _ = [] -- GADT ctors ignored."
  }
]