[
  {
    "id" : "bcca6cca-2209-44c0-839f-fc4af88cca7a",
    "prId" : 7146,
    "comments" : [
      {
        "id" : "3b1c6bf7-9424-441d-b157-e39ced449352",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This seems unnecessary.",
        "createdAt" : "2020-08-17T13:24:22Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "26d53157-a2f6-498b-a818-0a233d6654e3",
        "parentId" : "3b1c6bf7-9424-441d-b157-e39ced449352",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Unfortunately GHC thinks it is. Removing it produces:\r\n\r\n```\r\nFile:     compiler/damlc/daml-stdlib-src/DA/Internal/Template/Functions.daml\r\nHidden:   no\r\nRange:    320:24-320:76\r\nSource:   typecheck\r\nSeverity: DsError\r\nMessage: \r\n  compiler/damlc/daml-stdlib-src/DA/Internal/Template/Functions.daml:320:25: error:\r\n  â€¢ Could not deduce (HasLookupByKey t0 k)\r\n  from the context: HasLookupByKey t k\r\n  bound by the type signature for:\r\n  canSeeContractWithKey : forall t k.\r\n  HasLookupByKey t k =>\r\n  k -> Update Bool\r\n  at compiler/damlc/daml-stdlib-src/DA/Internal/Template/Functions.daml:320:25-76\r\n  The type variable â€˜t0â€™ is ambiguous\r\n  â€¢ In the ambiguity check for â€˜canSeeContractWithKeyâ€™\r\n  To defer the ambiguity check to use sites, enable AllowAmbiguousTypes\r\n  In the type signature:\r\n  canSeeContractWithKey : forall t k.\r\n  (HasLookupByKey t k) => k -> Update Bool\r\nERROR: Compilation failed.\r\n```\r\n\r\nHappy to learn of a better way to resolve this if there is one.",
        "createdAt" : "2020-08-17T14:35:32Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "71e861b8-d4ba-421d-8651-899276597f17",
        "parentId" : "3b1c6bf7-9424-441d-b157-e39ced449352",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is the correct way to solve this. There is no way for GHC to infer the template type since all it has to work with is the key type (two templates can have the same key type) and the return type `Boolean`. This is pretty harmless. Since the introduction of type families you can easily provide the template type using that.",
        "createdAt" : "2020-08-17T15:13:53Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "11f4318b-d1f7-4dac-b660-4b04c7cad879",
        "parentId" : "3b1c6bf7-9424-441d-b157-e39ced449352",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I understand why this pragma is necessary in `DA.Internal.Template.Functions`. What I don't understand is why it is necessary here where we don't mention `canSeeContractWithKey` at all.",
        "createdAt" : "2020-08-17T16:27:08Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "698af574-2d88-449a-a8c8-a2a886339dd0",
        "parentId" : "3b1c6bf7-9424-441d-b157-e39ced449352",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh I misunderstood the question. Yeah we can probably kill it here.",
        "createdAt" : "2020-08-17T16:28:55Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "068a18fc-ce8e-4402-bcf0-57971ed4b17b",
        "parentId" : "3b1c6bf7-9424-441d-b157-e39ced449352",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "ðŸ¤¦ \r\n\r\nI had put the function in Prelude first, then moved it to Template. Sorry.",
        "createdAt" : "2020-08-17T17:31:15Z",
        "updatedAt" : "2020-08-24T12:11:38Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fc3351a23f3b5dd403214e0e6d5c60cf5c1289e",
    "line" : null,
    "diffHunk" : "@@ -1,6 +1,7 @@\n -- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n -- SPDX-License-Identifier: Apache-2.0\n \n+{-# LANGUAGE AllowAmbiguousTypes #-}"
  },
  {
    "id" : "70aeeca2-716e-40d9-ac2c-5e99b62418d3",
    "prId" : 5809,
    "comments" : [
      {
        "id" : "38e92e80-b3bd-40d6-8af8-c5b03a6cf062",
        "parentId" : null,
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "```suggestion\r\n-- condition for the corresponding contracts.\r\n```",
        "createdAt" : "2020-05-01T00:21:20Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9c7040573e0f8c6fdc3f288fe87609bc173cccf1",
    "line" : null,
    "diffHunk" : "@@ -624,10 +624,25 @@ null : [a] -> Bool\n null [] = True\n null _ = False\n \n--- | Filter the list using the function: keep only the elements where the predicate holds.\n+-- | Filters the list using the function: keep only the elements where the predicate holds.\n filter : (a -> Bool) -> [a] -> [a]\n filter p = foldr (\\x xs -> if p x then x :: xs else xs) []\n \n+-- | Filters the list using the applicative function: keeps only the elements where the predicate holds.\n+-- Useful for example when a list of contract IDs are known, which should be filtered based on some\n+-- condition for the correspodning contracts."
  },
  {
    "id" : "3aa35e9d-168f-4d0b-ae4e-ae2367154561",
    "prId" : 5809,
    "comments" : [
      {
        "id" : "1e934ba0-a28c-41f7-821f-b62cc8ebc846",
        "parentId" : null,
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I don't think this comment is very useful. ",
        "createdAt" : "2020-05-01T00:21:55Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9c7040573e0f8c6fdc3f288fe87609bc173cccf1",
    "line" : null,
    "diffHunk" : "@@ -624,10 +624,25 @@ null : [a] -> Bool\n null [] = True\n null _ = False\n \n--- | Filter the list using the function: keep only the elements where the predicate holds.\n+-- | Filters the list using the function: keep only the elements where the predicate holds.\n filter : (a -> Bool) -> [a] -> [a]\n filter p = foldr (\\x xs -> if p x then x :: xs else xs) []\n \n+-- | Filters the list using the applicative function: keeps only the elements where the predicate holds.\n+-- Useful for example when a list of contract IDs are known, which should be filtered based on some"
  },
  {
    "id" : "17adfae2-1e0c-4c38-ac97-71f221b52bc3",
    "prId" : 5809,
    "comments" : [
      {
        "id" : "0d1db4b6-3459-4458-a1d5-47a608fdc433",
        "parentId" : null,
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I think this function should be in `DA.Action` rather than `Prelude`?",
        "createdAt" : "2020-05-01T00:24:38Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "920b385a-e280-4a97-a2ad-2fc9f880fd82",
        "parentId" : "0d1db4b6-3459-4458-a1d5-47a608fdc433",
        "author" : {
          "login" : "tamaskalcza-da",
          "name" : "TamÃ¡s KÃ¡lcza",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/54800417?u=2f23b2f81e5322e0a3ccde86f489a6f607b51fcb&v=4"
        },
        "body" : "I thought it's similar in nature to `mapA` hence put here. I can move it.",
        "createdAt" : "2020-05-01T00:43:14Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "tamaskalcza-da",
          "name" : "TamÃ¡s KÃ¡lcza",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/54800417?u=2f23b2f81e5322e0a3ccde86f489a6f607b51fcb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "69d45714-da51-483c-8c47-8c3319eb621c",
        "parentId" : "0d1db4b6-3459-4458-a1d5-47a608fdc433",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yes, I see. I note that `mapM` is in the Haskell `Prelude` but `filterM` requires `Control.Monad`. If we are taking our queues from that decision then it probably belongs in `DA.Action` (along with `foldrA` and friends).",
        "createdAt" : "2020-05-01T01:03:43Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9c7040573e0f8c6fdc3f288fe87609bc173cccf1",
    "line" : null,
    "diffHunk" : "@@ -624,10 +624,25 @@ null : [a] -> Bool\n null [] = True\n null _ = False\n \n--- | Filter the list using the function: keep only the elements where the predicate holds.\n+-- | Filters the list using the function: keep only the elements where the predicate holds.\n filter : (a -> Bool) -> [a] -> [a]\n filter p = foldr (\\x xs -> if p x then x :: xs else xs) []\n \n+-- | Filters the list using the applicative function: keeps only the elements where the predicate holds.\n+-- Useful for example when a list of contract IDs are known, which should be filtered based on some\n+-- condition for the correspodning contracts.\n+--\n+-- ```\n+-- >>> filterA (\\x -> Some (x % 2 == 0)) [0..5]\n+-- Some [0, 2, 4]\n+-- ```\n+filterA : Applicative m => (a -> m Bool) -> [a] -> m [a]"
  },
  {
    "id" : "1bb790a4-0bba-49dd-9e5a-010ac502fbe0",
    "prId" : 5809,
    "comments" : [
      {
        "id" : "0f0f3d41-ace8-421b-9995-692854d680af",
        "parentId" : null,
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "\r\nThe implementation looks correct but maybe this one-liner is sweeter?\r\n```suggestion\r\nfilterA p = foldr (\\ x -> liftA2 (\\ flg -> if flg then (x:) else id) (p x)) (pure [])\r\n```",
        "createdAt" : "2020-05-01T00:32:34Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "60f75d53-85c5-4480-8ea0-b236bbbb2531",
        "parentId" : "0f0f3d41-ace8-421b-9995-692854d680af",
        "author" : {
          "login" : "tamaskalcza-da",
          "name" : "TamÃ¡s KÃ¡lcza",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/54800417?u=2f23b2f81e5322e0a3ccde86f489a6f607b51fcb&v=4"
        },
        "body" : "In my original implementation I even specified the signatures of the inner functions as well. For me and other colleagues it was really useful to understand the implementation.\r\n\r\nIf you think this additional clarity is not needed I'm happy to accept the suggestion.",
        "createdAt" : "2020-05-01T00:39:52Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "tamaskalcza-da",
          "name" : "TamÃ¡s KÃ¡lcza",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/54800417?u=2f23b2f81e5322e0a3ccde86f489a6f607b51fcb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d8b69484-15d2-452d-bd47-63c0ac2d169d",
        "parentId" : "0f0f3d41-ace8-421b-9995-692854d680af",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I'm easy but I think we probably favor succinctness over clarity in the context of the standard library.",
        "createdAt" : "2020-05-01T01:05:17Z",
        "updatedAt" : "2020-05-04T16:03:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9c7040573e0f8c6fdc3f288fe87609bc173cccf1",
    "line" : null,
    "diffHunk" : "@@ -624,10 +624,25 @@ null : [a] -> Bool\n null [] = True\n null _ = False\n \n--- | Filter the list using the function: keep only the elements where the predicate holds.\n+-- | Filters the list using the function: keep only the elements where the predicate holds.\n filter : (a -> Bool) -> [a] -> [a]\n filter p = foldr (\\x xs -> if p x then x :: xs else xs) []\n \n+-- | Filters the list using the applicative function: keeps only the elements where the predicate holds.\n+-- Useful for example when a list of contract IDs are known, which should be filtered based on some\n+-- condition for the correspodning contracts.\n+--\n+-- ```\n+-- >>> filterA (\\x -> Some (x % 2 == 0)) [0..5]\n+-- Some [0, 2, 4]\n+-- ```\n+filterA : Applicative m => (a -> m Bool) -> [a] -> m [a]\n+filterA p =\n+  foldr filtering (pure [])\n+  where\n+    filtering a = liftA2 (prependIf a) (p a)\n+    prependIf a prepend filtered = if prepend then a :: filtered else filtered"
  },
  {
    "id" : "fa0116b3-e61c-4bc7-8b57-be732b17d8fe",
    "prId" : 4807,
    "comments" : [
      {
        "id" : "6e4e90ce-d62e-4221-a596-1ed49751b2cc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Under what circumstances is this lazier? Only if `>>=` involved some sort of function composition, as in `State` or `Reader` and in `Update` or `Scenario` because they get rewritten into some sort of `Reader` in the speedy compiler, right? `Optional` and `Either _` are unaffected by this. Should we add some documentation around this? Or should we add an internal type class for monads that allow for `debug`?",
        "createdAt" : "2020-03-04T15:39:18Z",
        "updatedAt" : "2020-03-04T15:45:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d084f266-c7ed-484c-84a4-eeea10e8b68f",
        "parentId" : "6e4e90ce-d62e-4221-a596-1ed49751b2cc",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that I constantly get confused by strictness myself, I think trying to explain this in docs is probably going to do more harm than good. For `Either` it works as expected with and without this change but I think I managed to confuse myself sufficiently now to not be able to tell you why exactly :slightly_smiling_face: ",
        "createdAt" : "2020-03-04T16:20:38Z",
        "updatedAt" : "2020-03-04T16:20:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c72d3341b427eb431e7830ecc69effad10916d2f",
    "line" : 13,
    "diffHunk" : "@@ -528,8 +528,14 @@ traceId : Show b => b -> b\n traceId x = trace x x\n \n -- | `debug x` prints `x` for debugging purposes.\n-debug : (Show b, Applicative m) => b -> m ()\n-debug x = trace x (pure ())\n+debug : (Show b, Action m) => b -> m ()\n+debug x =\n+  -- NOTE (MK): We introduce an explicit indirection via >>=\n+  -- to make sure that evaluating something like\n+  -- `debug x >> pure ()` does not print the debug statement.\n+  -- Instead it will only be printed when you execute the monadic\n+  -- action.\n+  pure () >>= \\_ -> pure (trace x ())"
  },
  {
    "id" : "45f976ad-8c21-47ef-8ff3-b0a547745cbd",
    "prId" : 4552,
    "comments" : [
      {
        "id" : "dbcf7a83-f5b9-4e86-8cbe-8016d4a095d4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It would be good to document why we give this the more restrictive constraint.",
        "createdAt" : "2020-02-17T17:11:16Z",
        "updatedAt" : "2020-02-18T13:22:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "26b61142-6e5e-4041-a0ac-12e0cf1e068b",
        "parentId" : "dbcf7a83-f5b9-4e86-8cbe-8016d4a095d4",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Totally agreed. And done.",
        "createdAt" : "2020-02-17T17:59:17Z",
        "updatedAt" : "2020-02-18T13:22:23Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e65fd8da34470a622c7f2e0a13f72ab5e3079ff7",
    "line" : 5,
    "diffHunk" : "@@ -86,7 +86,7 @@ class Functor f => Applicative f where\n -- | Sequentially compose two actions, discarding any value produced\n -- by the first. This is like sequencing operators (such as the semicolon)\n -- in imperative languages.\n-(>>) : Applicative m => m a -> m b -> m b\n+(>>) : Action m => m a -> m b -> m b"
  },
  {
    "id" : "88e42207-eadd-41dd-93e0-7a2bba94f8a4",
    "prId" : 4318,
    "comments" : [
      {
        "id" : "6d7414e8-8e7e-4e25-b5f8-88d1ee4a0388",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n-- | The `partition` function takes a predicate a list and returns\r\n-- the pair of lists of elements which do and do not satisfy the\r\n-- predicate, respectively; i.e.,\r\n--\r\n-- > partition p xs == (filter p xs, filter (not . p) xs)\r\n--\r\n-- ```\r\n-- >>> partition (`elem` \"aeiou\") \"Hello World!\"\r\n-- (\"eoo\",\"Hll Wrld!\")\r\n-- ```\r\n```\r\nThis is just the description from the Haskell standard library which I quite like. The translation to `filter` makes the behavior clear and it has an doctest in it which we test automatically.",
        "createdAt" : "2020-01-31T08:08:11Z",
        "updatedAt" : "2020-01-31T09:42:42Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f75ed03830a0b16cb2ef5844d9ed7662dcc94528",
    "line" : null,
    "diffHunk" : "@@ -445,6 +445,16 @@ span p xs@(x::xs')\n          | p x          =  let (ys,zs) = span p xs' in (x::ys,zs)\n          | otherwise    =  ([],xs)\n \n+-- | Splits the given list into a pair of lists. All elements of the first list"
  },
  {
    "id" : "9c5058ae-18d7-477c-a3d5-6356cf28e077",
    "prId" : 4318,
    "comments" : [
      {
        "id" : "d9d2f82d-7c23-4140-b561-4ace94741c9f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2020-01-31T08:08:23Z",
        "updatedAt" : "2020-01-31T09:42:42Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f75ed03830a0b16cb2ef5844d9ed7662dcc94528",
    "line" : null,
    "diffHunk" : "@@ -445,6 +445,16 @@ span p xs@(x::xs')\n          | p x          =  let (ys,zs) = span p xs' in (x::ys,zs)\n          | otherwise    =  ([],xs)\n \n+-- | Splits the given list into a pair of lists. All elements of the first list\n+-- satisfy the given predicate, and all elements of the second list do not."
  },
  {
    "id" : "53bb8316-4ebd-41fb-abdd-2c7ed2f47bf9",
    "prId" : 4318,
    "comments" : [
      {
        "id" : "c166df60-5806-4008-8c4b-4b80b07d297c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh this doesnâ€™t actually work (use `bazel test //compiler/damlc:daml-stdlib-doctest` to reproduce locally) becaues string literals are not lists of characters in DAML. Maybe just turn it into something like `partition (> 5) [1,7,3,8]`.",
        "createdAt" : "2020-01-31T09:10:55Z",
        "updatedAt" : "2020-01-31T09:42:42Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f75ed03830a0b16cb2ef5844d9ed7662dcc94528",
    "line" : null,
    "diffHunk" : "@@ -445,6 +445,24 @@ span p xs@(x::xs')\n          | p x          =  let (ys,zs) = span p xs' in (x::ys,zs)\n          | otherwise    =  ([],xs)\n \n+-- | The `partition` function takes a predicate, a list and returns\n+-- the pair of lists of elements which do and do not satisfy the\n+-- predicate, respectively; i.e.,\n+--\n+-- > partition p xs == (filter p xs, filter (not . p) xs)\n+--\n+-- ```\n+-- >>> partition (`elem` \"aeiou\") \"Hello World!\""
  },
  {
    "id" : "3a00a41c-e27c-40e4-bc90-1c077a3eddb6",
    "prId" : 3886,
    "comments" : [
      {
        "id" : "b02afdaa-be69-400a-87b4-05a0ce65bb80",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n      problematicDiff = (0.5 : Numeric 1) `divNumeric` (10.0 ^ d : Numeric 0) * signum x\r\n```",
        "createdAt" : "2019-12-18T10:09:38Z",
        "updatedAt" : "2019-12-18T10:45:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9da6cb7b3117afe90d7f85d1e29170a62de174e8",
    "line" : null,
    "diffHunk" : "@@ -538,13 +538,41 @@ intToDecimal = IF_NUMERIC(intToNumeric, primitive @\"BEInt64ToDecimal\")\n roundBankers : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n roundBankers = primitive @IF_NUMERIC(\"BERoundNumeric\", \"BERoundDecimal\")\n \n+#ifdef DAML_NUMERIC\n+divNumeric : Numeric n1 -> Numeric n2 -> Numeric n3\n+divNumeric = primitive @\"BEDivNumeric\"\n+#endif\n+\n -- | Commercial Rounding: `roundCommercial dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded away from zero.\n-roundCommercial : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n+#ifdef DAML_NUMERIC\n+roundCommercial : forall n. NumericScale n => Int -> Numeric n -> Numeric n\n+#else\n+roundCommercial : Int -> Decimal -> Decimal\n+#endif\n roundCommercial d x =\n+#ifdef DAML_NUMERIC\n+  -- We must avoid conversions to Int, otherwise this will crash in some cases.\n+  -- Until we have a `roundCommercial` primitive, we use a somewhat hacky implementation\n+  -- relying on `roundBankers` is a primitive.\n+\n+  -- We first use bankers rounding and then check if the difference is exactly .5\n+  -- If that is the case, we shift the result by 1.\n+  let t = roundBankers d x\n+      diff = x - t\n+      problematicDiff = (0.5 : Numeric 1) `divNumeric` (10.0 ^ d : Numeric 0)"
  },
  {
    "id" : "eee6c60e-c463-4858-bbb2-88da6c27444c",
    "prId" : 3886,
    "comments" : [
      {
        "id" : "1507168d-0d89-47d6-805c-ae5c4fe0fbe5",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n  in if diff == problematicDiff\r\n```",
        "createdAt" : "2019-12-18T10:09:53Z",
        "updatedAt" : "2019-12-18T10:45:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9da6cb7b3117afe90d7f85d1e29170a62de174e8",
    "line" : null,
    "diffHunk" : "@@ -538,13 +538,41 @@ intToDecimal = IF_NUMERIC(intToNumeric, primitive @\"BEInt64ToDecimal\")\n roundBankers : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n roundBankers = primitive @IF_NUMERIC(\"BERoundNumeric\", \"BERoundDecimal\")\n \n+#ifdef DAML_NUMERIC\n+divNumeric : Numeric n1 -> Numeric n2 -> Numeric n3\n+divNumeric = primitive @\"BEDivNumeric\"\n+#endif\n+\n -- | Commercial Rounding: `roundCommercial dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded away from zero.\n-roundCommercial : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n+#ifdef DAML_NUMERIC\n+roundCommercial : forall n. NumericScale n => Int -> Numeric n -> Numeric n\n+#else\n+roundCommercial : Int -> Decimal -> Decimal\n+#endif\n roundCommercial d x =\n+#ifdef DAML_NUMERIC\n+  -- We must avoid conversions to Int, otherwise this will crash in some cases.\n+  -- Until we have a `roundCommercial` primitive, we use a somewhat hacky implementation\n+  -- relying on `roundBankers` is a primitive.\n+\n+  -- We first use bankers rounding and then check if the difference is exactly .5\n+  -- If that is the case, we shift the result by 1.\n+  let t = roundBankers d x\n+      diff = x - t\n+      problematicDiff = (0.5 : Numeric 1) `divNumeric` (10.0 ^ d : Numeric 0)\n+      offset | d == 0 = munit\n+             | otherwise = (1.0 : Numeric 0) `divNumeric` (10.0 ^ d : Numeric 0)\n+  in if diff == signum x * problematicDiff"
  },
  {
    "id" : "8c3006c7-341a-407b-8a06-342808f93db2",
    "prId" : 3886,
    "comments" : [
      {
        "id" : "697389fe-8c8b-4a40-a257-c67039a518ac",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n       then x + problematicDiff\r\n```",
        "createdAt" : "2019-12-18T10:10:08Z",
        "updatedAt" : "2019-12-18T10:45:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9da6cb7b3117afe90d7f85d1e29170a62de174e8",
    "line" : null,
    "diffHunk" : "@@ -538,13 +538,41 @@ intToDecimal = IF_NUMERIC(intToNumeric, primitive @\"BEInt64ToDecimal\")\n roundBankers : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n roundBankers = primitive @IF_NUMERIC(\"BERoundNumeric\", \"BERoundDecimal\")\n \n+#ifdef DAML_NUMERIC\n+divNumeric : Numeric n1 -> Numeric n2 -> Numeric n3\n+divNumeric = primitive @\"BEDivNumeric\"\n+#endif\n+\n -- | Commercial Rounding: `roundCommercial dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded away from zero.\n-roundCommercial : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n+#ifdef DAML_NUMERIC\n+roundCommercial : forall n. NumericScale n => Int -> Numeric n -> Numeric n\n+#else\n+roundCommercial : Int -> Decimal -> Decimal\n+#endif\n roundCommercial d x =\n+#ifdef DAML_NUMERIC\n+  -- We must avoid conversions to Int, otherwise this will crash in some cases.\n+  -- Until we have a `roundCommercial` primitive, we use a somewhat hacky implementation\n+  -- relying on `roundBankers` is a primitive.\n+\n+  -- We first use bankers rounding and then check if the difference is exactly .5\n+  -- If that is the case, we shift the result by 1.\n+  let t = roundBankers d x\n+      diff = x - t\n+      problematicDiff = (0.5 : Numeric 1) `divNumeric` (10.0 ^ d : Numeric 0)\n+      offset | d == 0 = munit\n+             | otherwise = (1.0 : Numeric 0) `divNumeric` (10.0 ^ d : Numeric 0)\n+  in if diff == signum x * problematicDiff\n+       then t + offset * signum x"
  },
  {
    "id" : "4081bfa5-67c1-45f8-9efa-28b3a483af29",
    "prId" : 3886,
    "comments" : [
      {
        "id" : "79a6c2ad-4239-4a3e-bc76-984ec9b5dfb4",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2019-12-18T10:15:18Z",
        "updatedAt" : "2019-12-18T10:45:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9da6cb7b3117afe90d7f85d1e29170a62de174e8",
    "line" : null,
    "diffHunk" : "@@ -538,13 +538,41 @@ intToDecimal = IF_NUMERIC(intToNumeric, primitive @\"BEInt64ToDecimal\")\n roundBankers : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n roundBankers = primitive @IF_NUMERIC(\"BERoundNumeric\", \"BERoundDecimal\")\n \n+#ifdef DAML_NUMERIC\n+divNumeric : Numeric n1 -> Numeric n2 -> Numeric n3\n+divNumeric = primitive @\"BEDivNumeric\"\n+#endif\n+\n -- | Commercial Rounding: `roundCommercial dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded away from zero.\n-roundCommercial : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n+#ifdef DAML_NUMERIC\n+roundCommercial : forall n. NumericScale n => Int -> Numeric n -> Numeric n\n+#else\n+roundCommercial : Int -> Decimal -> Decimal\n+#endif\n roundCommercial d x =\n+#ifdef DAML_NUMERIC\n+  -- We must avoid conversions to Int, otherwise this will crash in some cases.\n+  -- Until we have a `roundCommercial` primitive, we use a somewhat hacky implementation\n+  -- relying on `roundBankers` is a primitive.\n+\n+  -- We first use bankers rounding and then check if the difference is exactly .5\n+  -- If that is the case, we shift the result by 1.\n+  let t = roundBankers d x\n+      diff = x - t\n+      problematicDiff = (0.5 : Numeric 1) `divNumeric` (10.0 ^ d : Numeric 0)\n+      offset | d == 0 = munit"
  },
  {
    "id" : "d653155c-71b4-4e83-b612-63bab1c0ea2b",
    "prId" : 3886,
    "comments" : [
      {
        "id" : "8580d4ae-f867-477c-8347-9dec8af68ae1",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2019-12-18T10:15:42Z",
        "updatedAt" : "2019-12-18T10:45:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9da6cb7b3117afe90d7f85d1e29170a62de174e8",
    "line" : null,
    "diffHunk" : "@@ -538,13 +538,41 @@ intToDecimal = IF_NUMERIC(intToNumeric, primitive @\"BEInt64ToDecimal\")\n roundBankers : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n roundBankers = primitive @IF_NUMERIC(\"BERoundNumeric\", \"BERoundDecimal\")\n \n+#ifdef DAML_NUMERIC\n+divNumeric : Numeric n1 -> Numeric n2 -> Numeric n3\n+divNumeric = primitive @\"BEDivNumeric\"\n+#endif\n+\n -- | Commercial Rounding: `roundCommercial dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded away from zero.\n-roundCommercial : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n+#ifdef DAML_NUMERIC\n+roundCommercial : forall n. NumericScale n => Int -> Numeric n -> Numeric n\n+#else\n+roundCommercial : Int -> Decimal -> Decimal\n+#endif\n roundCommercial d x =\n+#ifdef DAML_NUMERIC\n+  -- We must avoid conversions to Int, otherwise this will crash in some cases.\n+  -- Until we have a `roundCommercial` primitive, we use a somewhat hacky implementation\n+  -- relying on `roundBankers` is a primitive.\n+\n+  -- We first use bankers rounding and then check if the difference is exactly .5\n+  -- If that is the case, we shift the result by 1.\n+  let t = roundBankers d x\n+      diff = x - t\n+      problematicDiff = (0.5 : Numeric 1) `divNumeric` (10.0 ^ d : Numeric 0)\n+      offset | d == 0 = munit\n+             | otherwise = (1.0 : Numeric 0) `divNumeric` (10.0 ^ d : Numeric 0)"
  },
  {
    "id" : "00b91c7b-fdca-4693-b1e9-6e18e7df0fea",
    "prId" : 3886,
    "comments" : [
      {
        "id" : "290097a3-6975-431a-b129-9ec1e70486f2",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n  -- If that is the case, weâ€™ve rounded in the wrong direction, so we shift it the other way.\r\n```",
        "createdAt" : "2019-12-18T10:44:51Z",
        "updatedAt" : "2019-12-18T10:45:43Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9da6cb7b3117afe90d7f85d1e29170a62de174e8",
    "line" : null,
    "diffHunk" : "@@ -539,12 +539,36 @@ roundBankers : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n roundBankers = primitive @IF_NUMERIC(\"BERoundNumeric\", \"BERoundDecimal\")\n \n -- | Commercial Rounding: `roundCommercial dp x` rounds `x` to `dp` decimal places, where a `.5` is rounded away from zero.\n-roundCommercial : Int -> IF_NUMERIC(Numeric n -> Numeric n, Decimal -> Decimal)\n+#ifdef DAML_NUMERIC\n+roundCommercial : forall n. NumericScale n => Int -> Numeric n -> Numeric n\n+#else\n+roundCommercial : Int -> Decimal -> Decimal\n+#endif\n roundCommercial d x =\n+#ifdef DAML_NUMERIC\n+  -- We must avoid conversions to Int, otherwise this will crash in some cases.\n+  -- Until we have a `roundCommercial` primitive, we use a somewhat hacky implementation\n+  -- relying on `roundBankers` is a primitive.\n+\n+  -- We first use bankers rounding and then check if the difference is exactly .5\n+  -- If that is the case, weâ€™ve rounded in the wrong directino, so we shift it the other way."
  },
  {
    "id" : "b6e0d53d-2632-4e12-b2e1-4d96bd1f6f8e",
    "prId" : 2203,
    "comments" : [
      {
        "id" : "aac515d1-743d-43f2-99c6-389b8c50cf1c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n-- | This function is a left fold, which you can use to inspect/analyse/consume lists. \r\n```\r\n\"manipulate\" sounds like you're changing the list, which doesn't happen.",
        "createdAt" : "2019-07-17T14:51:32Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2aebf000215a856fb6744cfa41948bb17074da55",
    "line" : null,
    "diffHunk" : "@@ -135,50 +136,62 @@ guard : ActionFail m => Bool -> m ()\n guard False = fail \"guard is false\"\n guard True = pure ()\n \n--- | `foldl f i xs` performs a left fold over `xs` using `f` with the starting value `i`.\n+-- | This function is a left fold, which you can use to manipulate lists. "
  },
  {
    "id" : "56e20cd3-c94f-4e99-af97-7faced0f0c7d",
    "prId" : 2203,
    "comments" : [
      {
        "id" : "fad0a3f5-c333-47b6-a0ee-35e689bd254e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n-- `elem x xs` is `True` if `x` is _not_ an element of the list `xs`.\r\n```",
        "createdAt" : "2019-07-17T14:52:15Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2aebf000215a856fb6744cfa41948bb17074da55",
    "line" : null,
    "diffHunk" : "@@ -135,50 +136,62 @@ guard : ActionFail m => Bool -> m ()\n guard False = fail \"guard is false\"\n guard True = pure ()\n \n--- | `foldl f i xs` performs a left fold over `xs` using `f` with the starting value `i`.\n+-- | This function is a left fold, which you can use to manipulate lists. \n+-- `foldl f i xs` performs a left fold over the list `xs` using\n+-- the function `f`, using the starting value `i`.\n --\n--- #### Examples\n+-- Examples:\n --\n -- ```\n -- >>> foldl (+) 0 [1,2,3]\n -- 6\n+-- \n -- >>> foldl (^) 10 [2,3]\n -- 1000000\n -- ```\n --\n+-- Note that foldl works from left-to-right over the list arguments.\n foldl : (b -> a -> b) -> b -> [a] -> b\n foldl = primitive @\"BEFoldl\"\n \n--- | `find p xs` finds the first element of `xs` where the predicate `p` holds.\n+-- | `find p xs` finds the first element of the list `xs` where the \n+-- predicate `p` is true. There might not be such an element, which \n+-- is why this function returns an `Optional a`.\n find : (a -> Bool) -> [a] -> Optional a\n find p [] = None\n find p (x::xs) = if p x then Some x else find p xs\n \n--- | Calculate the length of a list.\n+-- | Gives the length of the list.\n length : [a] -> Int\n length = foldl (\\l _ -> l + 1) 0\n \n--- | `any p xs` is `True` if `p` holds for at least one element of `xs`.\n+-- | Are there any elements in the list where the predicate is true?\n+-- `any p xs` is `True` if `p` holds for at least one element of `xs`.\n any : (a -> Bool) -> [a] -> Bool\n any f = foldl (\\b x -> b || f x) False\n \n--- | `all p xs` is `True` if `p` holds for every element of `xs`.\n+-- | Is the predicate true for all of the elements in the list?\n+-- `all p xs` is `True` if `p` holds for every element of `xs`.\n all : (a -> Bool) -> [a] -> Bool\n all f = foldl (\\b x -> b && f x) True\n \n--- | `or bs` is `True` if at least one element of `bs` is `True`.\n+-- | Is at least one of elements in a list of `Bool` true?\n+-- `or bs` is `True` if at least one element of `bs` is `True`.\n or : [Bool] -> Bool\n or = any identity\n \n--- | `and bs` is `True` if every element of `bs` is `True`.\n+-- | Is every element in a list of Bool true?\n+-- `and bs` is `True` if every element of `bs` is `True`.\n and : [Bool] -> Bool\n and = all identity\n \n--- | `elem x xs` is `True` if `x` is an element of the list `xs`.\n+-- | Does this value exist in this list?\n+-- `elem x xs` is `True` if `x` is an element of the list `xs`.\n elem : Eq a => a -> [a] -> Bool\n elem x = any (== x)\n \n--- | Negation of `elem`.\n+-- | Negation of `elem`:\n+-- `elem x xs` is `True` if `x` is NOT an element of the list `xs`."
  },
  {
    "id" : "3efa4c9d-8b36-466e-9375-444f606c6173",
    "prId" : 2203,
    "comments" : [
      {
        "id" : "06b2144f-41fe-4efb-9ed7-ef296abe2026",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not sure this explanation adds value.",
        "createdAt" : "2019-07-17T14:53:39Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "337fee07-7d40-41e1-a418-7261ec878c5c",
        "parentId" : "06b2144f-41fe-4efb-9ed7-ef296abe2026",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "fair enough, will remove",
        "createdAt" : "2019-07-17T15:40:02Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2aebf000215a856fb6744cfa41948bb17074da55",
    "line" : null,
    "diffHunk" : "@@ -380,7 +393,8 @@ infixr 1 =<<\n concatMap : (a -> [b]) -> [a] -> [b]\n concatMap f = concat . map f\n \n--- | `replicate i x` is the list `[x, x, x, ..., x]` with `i` copies of `x`.\n+-- | Create a list with the first argument number of copies of the second argument."
  },
  {
    "id" : "20eacc33-f05e-4a16-b8a6-4d4ac907b833",
    "prId" : 2203,
    "comments" : [
      {
        "id" : "d82fe456-a076-4bad-8a3f-d34edc8b9b68",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think pairs is better than tuples as it is more precise. Same in many places below.",
        "createdAt" : "2019-07-17T14:54:07Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "434b8940-8a9d-4d20-b1d1-ab0ddb7df2cb",
        "parentId" : "d82fe456-a076-4bad-8a3f-d34edc8b9b68",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Ok, I can change back",
        "createdAt" : "2019-07-17T15:20:14Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2aebf000215a856fb6744cfa41948bb17074da55",
    "line" : null,
    "diffHunk" : "@@ -438,7 +452,7 @@ lookup  key ((x,y)::xys)\n enumerate : (Enum a, Bounded a) => [a]\n enumerate = [minBound .. maxBound]\n \n--- | `zip` takes two lists and returns a list of corresponding pairs.\n+-- | `zip` takes two lists and returns a list of corresponding tuples."
  },
  {
    "id" : "7e19c7d7-0daa-4798-aeb7-d1af3cfe6ba2",
    "prId" : 2203,
    "comments" : [
      {
        "id" : "292c6d59-9b7b-417d-95c7-30a7fb1c0334",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n-- It generalises `zip` by combining elements using the function, instead of forming pairs.\r\n```",
        "createdAt" : "2019-07-17T14:54:30Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2aebf000215a856fb6744cfa41948bb17074da55",
    "line" : null,
    "diffHunk" : "@@ -449,18 +463,19 @@ zip3 : [a] -> [b] -> [c] -> [(a, b, c)]\n zip3 (a::as) (b::bs) (c::cs) = (a,b,c) :: zip3 as bs cs\n zip3 _ _ _ = []\n \n--- | `zipWith` generalises `zip` by combining elements using the function, instead of making pairs.\n+-- | `zipWith` takes a function and two lists.\n+-- It generalises `zip` by combining elements using the function, instead of making tuples."
  },
  {
    "id" : "934871a5-264a-4dbb-b29b-c0a30e927e07",
    "prId" : 2203,
    "comments" : [
      {
        "id" : "17656b1e-34e8-4c4d-8cef-cc9898b11364",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n-- | `zipWith3` generalises `zip3` by combining elements using the function, instead of forming triples.\r\n```",
        "createdAt" : "2019-07-17T14:54:49Z",
        "updatedAt" : "2019-07-17T15:41:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2aebf000215a856fb6744cfa41948bb17074da55",
    "line" : null,
    "diffHunk" : "@@ -449,18 +463,19 @@ zip3 : [a] -> [b] -> [c] -> [(a, b, c)]\n zip3 (a::as) (b::bs) (c::cs) = (a,b,c) :: zip3 as bs cs\n zip3 _ _ _ = []\n \n--- | `zipWith` generalises `zip` by combining elements using the function, instead of making pairs.\n+-- | `zipWith` takes a function and two lists.\n+-- It generalises `zip` by combining elements using the function, instead of making tuples.\n -- If one list is shorter, the excess elements of the longer list are discarded.\n zipWith : (a -> b -> c) -> [a] -> [b] -> [c]\n zipWith f (a::as) (b::bs) = f a b :: zipWith f as bs\n zipWith _ _ _ = []\n \n--- | `zipWith3` generalises `zip3` by combining elements using the function, instead of making pairs.\n+-- | `zipWith3` generalises `zip3` by combining elements using the function, instead of making tuples."
  },
  {
    "id" : "79beac87-d6ad-48d3-abad-fdf2cf6cf9d5",
    "prId" : 2178,
    "comments" : [
      {
        "id" : "8859eedf-2278-40ac-a729-2bccbbcc0f93",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's not add this but rather replace the use sites by stuff like `magic @\"exercise\"` and `magic @\"archive\"`. If that breaks stuff because we don't erase all the `magic`s during conversion to DAML-LF, let's fix that.",
        "createdAt" : "2019-07-17T08:14:15Z",
        "updatedAt" : "2019-07-30T22:55:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ca591f5890a7d9487d0b2351de3d08b4592a1a87",
    "line" : null,
    "diffHunk" : "@@ -561,3 +561,6 @@ sum = foldl (+) aunit\n -- | Calculate the product over all elements\n product : Multiplicative a => [a] -> a\n product = foldl (*) munit\n+\n+undefined : a\n+undefined = error \"undefined\""
  },
  {
    "id" : "e4577bd6-8421-4bb1-ad1c-c17fe7b3ae2c",
    "prId" : 2163,
    "comments" : [
      {
        "id" : "320d0b2a-aa72-49b2-a5fb-d9525f37d52b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you want to be precise, we are applying the function to the value of type `a` not to `a`. It might also be worth pointing out that the point of this function is that it has a very low precedence, otherwise itâ€™s unclear why you would want to use this as opposed to regular function application.",
        "createdAt" : "2019-07-16T14:08:19Z",
        "updatedAt" : "2019-07-17T07:09:05Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a785640fe8d72eb256de0bbfe8b1eaf7c46d032e",
    "line" : null,
    "diffHunk" : "@@ -26,6 +26,8 @@ import GHC.Tuple()\n import GHC.Types as GHC (Bool (..), Int, Ordering (..), Text, Decimal, ifThenElse, primitive)\n \n infixr 0 $\n+-- | Take a function from `a` to `b` and a value of type `a`, and apply the\n+-- function to `a`, returning a `b`."
  },
  {
    "id" : "2c7a193b-e373-4ac2-9a15-38142033a1ed",
    "prId" : 2163,
    "comments" : [
      {
        "id" : "399fee08-1d17-4857-b7df-05d20681dd72",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not really sure what a better description would be but this seems like we should be able to come up with something better.",
        "createdAt" : "2019-07-16T14:09:19Z",
        "updatedAt" : "2019-07-17T07:09:05Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bf9fb3f1-ae69-4a55-a06b-0ea01d21b983",
        "parentId" : "399fee08-1d17-4857-b7df-05d20681dd72",
        "author" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "body" : "Yeah, I really don't like this either, but I don't know how to improve.",
        "createdAt" : "2019-07-16T14:14:11Z",
        "updatedAt" : "2019-07-17T07:09:05Z",
        "lastEditedBy" : {
          "login" : "bethaitman",
          "name" : "Beth Aitman",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/3482051?u=97f3942927ae304a99251ea448bb8b65b6024e74&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a785640fe8d72eb256de0bbfe8b1eaf7c46d032e",
    "line" : 16,
    "diffHunk" : "@@ -45,7 +47,7 @@ class Functor f => Applicative f where\n     -- | Lift a value.\n     pure : a -> f a\n \n-    -- | Sequential application.\n+    -- | Sequentially apply the function."
  },
  {
    "id" : "93f0cd97-483d-4cb5-bd1a-9dec6e018ea9",
    "prId" : 2163,
    "comments" : [
      {
        "id" : "7e9cdbad-7ec8-4d14-be4e-250a27112084",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch!",
        "createdAt" : "2019-07-16T14:09:56Z",
        "updatedAt" : "2019-07-17T07:09:05Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a785640fe8d72eb256de0bbfe8b1eaf7c46d032e",
    "line" : 44,
    "diffHunk" : "@@ -188,9 +191,9 @@ infixl 4 <$>\n -- deal with errors or exceptional cases without resorting to drastic\n -- measures such as `error`.\n --\n--- The `Optional` type is also a monad.  It is a simple kind of error\n--- monad, where all errors are represented by `None`.  A richer\n--- error monad can be built using the `Data.Either.Either` type.\n+-- The `Optional` type is also an `Action`.  It is a simple kind of error"
  }
]