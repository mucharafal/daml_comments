[
  {
    "id" : "af73c28d-4532-4e80-a4ba-4b1173b28b92",
    "prId" : 3696,
    "comments" : [
      {
        "id" : "86369976-c876-4974-8f00-de800ebf2b2d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Don't we still support DAML-LF 1.6? If so, we should use DAML-LF 1.6 here. Otherwise, packages could reference packages produced with a new DAML-LF version. This might not be a problem but feels slightly odd.",
        "createdAt" : "2019-12-02T19:54:31Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "73fdd2ec-2f53-4d11-9506-820e91f9e7fb",
        "parentId" : "86369976-c876-4974-8f00-de800ebf2b2d",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point, changed.",
        "createdAt" : "2019-12-02T20:10:18Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72ee178dfa935c138612161f3bdfb610910e1412",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,140 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module GenerateStablePackage (main) where\n+\n+import qualified Data.ByteString as BS\n+import qualified Data.NameMap as NM\n+import Options.Applicative\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Proto3.Archive\n+import DA.Daml.LFConversion.UtilLF hiding (ghcTypes)\n+\n+data Opts = Opts\n+  { optModule :: ModuleName\n+  -- ^ The module that we generate as a standalone package\n+  , optModuleDeps :: [ModuleDep]\n+  -- ^ Dependencies of this module, i.e., modules that we reference.\n+  -- We donâ€™t want to hardcode package ids in here\n+  -- (even though we could since they must be stable)\n+  -- so we require that users pass in a mapping from module names\n+  -- to package ids.\n+  , optOutputPath :: FilePath\n+  } deriving Show\n+\n+data ModuleDep = ModuleDep\n+  { depModuleName :: ModuleName\n+  , depPackageId :: PackageId\n+  } deriving Show\n+\n+optParser :: Parser Opts\n+optParser =\n+  Opts\n+    <$> option modNameReader (long \"module\")\n+    <*> many (option modDepReader (long \"module-dep\" <> help \"Module.Name:packageid\"))\n+    <*> option str (short 'o')\n+  where\n+    modNameReader = maybeReader (Just . ModuleName . T.splitOn \".\" . T.pack)\n+    modDepReader = maybeReader $ \\s ->\n+      case T.splitOn \":\" (T.pack s) of\n+        [modName, packageId] -> Just ModuleDep\n+          { depModuleName = ModuleName (T.splitOn \".\" modName)\n+          , depPackageId = PackageId packageId\n+          }\n+        _ -> Nothing\n+\n+main :: IO ()\n+main = do\n+  Opts{..} <- execParser (info optParser idm)\n+  case optModule of\n+    ModuleName [\"GHC\", \"Types\"] ->\n+      writePackage ghcTypes optOutputPath\n+    ModuleName [\"GHC\", \"Prim\"] ->\n+      writePackage ghcPrim optOutputPath\n+    _ -> fail $ \"Unknown module: \" <> show optModule\n+\n+lfVersion :: Version\n+lfVersion = version1_7"
  },
  {
    "id" : "1c2e92bb-d82b-4def-a995-7aa2b3436c8e",
    "prId" : 3696,
    "comments" : [
      {
        "id" : "1d6dea88-d6cc-40fa-ae43-abc24a50b49d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We have this twice now. The other version is in `compiler/damlc/daml-lf-conversion/src/DA/Daml/LFConversion/UtilLF.hs`.",
        "createdAt" : "2019-12-02T19:56:35Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "11a7f715-1880-4019-aa40-19db00c3cb87",
        "parentId" : "1d6dea88-d6cc-40fa-ae43-abc24a50b49d",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "oops, forgot to remove it, thanks!",
        "createdAt" : "2019-12-02T20:10:37Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "72ee178dfa935c138612161f3bdfb610910e1412",
    "line" : 66,
    "diffHunk" : "@@ -0,0 +1,140 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module GenerateStablePackage (main) where\n+\n+import qualified Data.ByteString as BS\n+import qualified Data.NameMap as NM\n+import Options.Applicative\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Proto3.Archive\n+import DA.Daml.LFConversion.UtilLF hiding (ghcTypes)\n+\n+data Opts = Opts\n+  { optModule :: ModuleName\n+  -- ^ The module that we generate as a standalone package\n+  , optModuleDeps :: [ModuleDep]\n+  -- ^ Dependencies of this module, i.e., modules that we reference.\n+  -- We donâ€™t want to hardcode package ids in here\n+  -- (even though we could since they must be stable)\n+  -- so we require that users pass in a mapping from module names\n+  -- to package ids.\n+  , optOutputPath :: FilePath\n+  } deriving Show\n+\n+data ModuleDep = ModuleDep\n+  { depModuleName :: ModuleName\n+  , depPackageId :: PackageId\n+  } deriving Show\n+\n+optParser :: Parser Opts\n+optParser =\n+  Opts\n+    <$> option modNameReader (long \"module\")\n+    <*> many (option modDepReader (long \"module-dep\" <> help \"Module.Name:packageid\"))\n+    <*> option str (short 'o')\n+  where\n+    modNameReader = maybeReader (Just . ModuleName . T.splitOn \".\" . T.pack)\n+    modDepReader = maybeReader $ \\s ->\n+      case T.splitOn \":\" (T.pack s) of\n+        [modName, packageId] -> Just ModuleDep\n+          { depModuleName = ModuleName (T.splitOn \".\" modName)\n+          , depPackageId = PackageId packageId\n+          }\n+        _ -> Nothing\n+\n+main :: IO ()\n+main = do\n+  Opts{..} <- execParser (info optParser idm)\n+  case optModule of\n+    ModuleName [\"GHC\", \"Types\"] ->\n+      writePackage ghcTypes optOutputPath\n+    ModuleName [\"GHC\", \"Prim\"] ->\n+      writePackage ghcPrim optOutputPath\n+    _ -> fail $ \"Unknown module: \" <> show optModule\n+\n+lfVersion :: Version\n+lfVersion = version1_7\n+\n+writePackage :: Module -> FilePath -> IO ()\n+writePackage mod path = do\n+  let pkg = Package lfVersion (NM.fromList [mod])\n+  BS.writeFile path $ encodeArchive pkg\n+\n+ghcTypes :: Module"
  },
  {
    "id" : "bfad55ee-1fc0-4b31-89b3-b7a21f3a805f",
    "prId" : 3696,
    "comments" : [
      {
        "id" : "205817e3-8bd6-4587-9f40-366a6cade4e3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`Proxy` never made it into the docs. We could just kill it.",
        "createdAt" : "2019-12-02T19:57:30Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f1fc9ca5-7a11-4c46-ae6b-fce0168cf1e3",
        "parentId" : "205817e3-8bd6-4587-9f40-366a6cade4e3",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Very confusing, we didnâ€™t even have a definition for this in `GHC.Types.daml` so it wasnâ€™t actually usable even if you tried. Burned with :fire: ",
        "createdAt" : "2019-12-02T20:24:21Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72ee178dfa935c138612161f3bdfb610910e1412",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,140 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module GenerateStablePackage (main) where\n+\n+import qualified Data.ByteString as BS\n+import qualified Data.NameMap as NM\n+import Options.Applicative\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Proto3.Archive\n+import DA.Daml.LFConversion.UtilLF hiding (ghcTypes)\n+\n+data Opts = Opts\n+  { optModule :: ModuleName\n+  -- ^ The module that we generate as a standalone package\n+  , optModuleDeps :: [ModuleDep]\n+  -- ^ Dependencies of this module, i.e., modules that we reference.\n+  -- We donâ€™t want to hardcode package ids in here\n+  -- (even though we could since they must be stable)\n+  -- so we require that users pass in a mapping from module names\n+  -- to package ids.\n+  , optOutputPath :: FilePath\n+  } deriving Show\n+\n+data ModuleDep = ModuleDep\n+  { depModuleName :: ModuleName\n+  , depPackageId :: PackageId\n+  } deriving Show\n+\n+optParser :: Parser Opts\n+optParser =\n+  Opts\n+    <$> option modNameReader (long \"module\")\n+    <*> many (option modDepReader (long \"module-dep\" <> help \"Module.Name:packageid\"))\n+    <*> option str (short 'o')\n+  where\n+    modNameReader = maybeReader (Just . ModuleName . T.splitOn \".\" . T.pack)\n+    modDepReader = maybeReader $ \\s ->\n+      case T.splitOn \":\" (T.pack s) of\n+        [modName, packageId] -> Just ModuleDep\n+          { depModuleName = ModuleName (T.splitOn \".\" modName)\n+          , depPackageId = PackageId packageId\n+          }\n+        _ -> Nothing\n+\n+main :: IO ()\n+main = do\n+  Opts{..} <- execParser (info optParser idm)\n+  case optModule of\n+    ModuleName [\"GHC\", \"Types\"] ->\n+      writePackage ghcTypes optOutputPath\n+    ModuleName [\"GHC\", \"Prim\"] ->\n+      writePackage ghcPrim optOutputPath\n+    _ -> fail $ \"Unknown module: \" <> show optModule\n+\n+lfVersion :: Version\n+lfVersion = version1_7\n+\n+writePackage :: Module -> FilePath -> IO ()\n+writePackage mod path = do\n+  let pkg = Package lfVersion (NM.fromList [mod])\n+  BS.writeFile path $ encodeArchive pkg\n+\n+ghcTypes :: Module\n+ghcTypes = Module\n+  { moduleName = modName\n+  , moduleSource = Nothing\n+  , moduleFeatureFlags = daml12FeatureFlags\n+  , moduleDataTypes = NM.fromList [dataOrdering, dataProxy]\n+  , moduleValues = NM.fromList (proxyCtor : map valCtor cons)\n+  , moduleTemplates = NM.empty\n+  }\n+  where\n+    modName = mkModName [\"GHC\", \"Types\"]\n+    qual = Qualified PRSelf modName\n+    cons = [\"LT\", \"EQ\", \"GT\"]\n+    dataOrdering = DefDataType\n+      { dataLocation= Nothing\n+      , dataTypeCon = mkTypeCon [\"Ordering\"]\n+      , dataSerializable = IsSerializable True\n+      , dataParams = []\n+      , dataCons = DataEnum $ map mkVariantCon cons\n+      }\n+    valCtor con = DefValue\n+      { dvalLocation = Nothing\n+      , dvalBinder = (mkVal (\"$ctor:\" <> con), TCon (qual (dataTypeCon dataOrdering)))\n+      , dvalNoPartyLiterals= HasNoPartyLiterals True\n+      , dvalIsTest = IsTest False\n+      , dvalBody = EEnumCon (qual (dataTypeCon dataOrdering)) (mkVariantCon con)\n+      }\n+    dataProxy = DefDataType"
  },
  {
    "id" : "cb951c63-055b-4bc3-8219-5a227c1d7648",
    "prId" : 3696,
    "comments" : [
      {
        "id" : "5aca5c8d-1880-4ce7-971c-12047c868c1e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we still produce these `$ctor` functions in the conversion to DAML-LF? I thought I removed them a while ago. ðŸ¤” ",
        "createdAt" : "2019-12-02T19:58:47Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7b3d09ea-7cfe-41ce-9e99-aad7ff68ea5c",
        "parentId" : "5aca5c8d-1880-4ce7-971c-12047c868c1e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Looks like we donâ€™t, I had just copied this module but I tried removing them and nothing broke so letâ€™s kill them.",
        "createdAt" : "2019-12-02T20:14:38Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72ee178dfa935c138612161f3bdfb610910e1412",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,140 @@\n+-- Copyright (c) 2019 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module GenerateStablePackage (main) where\n+\n+import qualified Data.ByteString as BS\n+import qualified Data.NameMap as NM\n+import Options.Applicative\n+import qualified Data.Text as T\n+\n+import DA.Daml.LF.Ast\n+import DA.Daml.LF.Proto3.Archive\n+import DA.Daml.LFConversion.UtilLF hiding (ghcTypes)\n+\n+data Opts = Opts\n+  { optModule :: ModuleName\n+  -- ^ The module that we generate as a standalone package\n+  , optModuleDeps :: [ModuleDep]\n+  -- ^ Dependencies of this module, i.e., modules that we reference.\n+  -- We donâ€™t want to hardcode package ids in here\n+  -- (even though we could since they must be stable)\n+  -- so we require that users pass in a mapping from module names\n+  -- to package ids.\n+  , optOutputPath :: FilePath\n+  } deriving Show\n+\n+data ModuleDep = ModuleDep\n+  { depModuleName :: ModuleName\n+  , depPackageId :: PackageId\n+  } deriving Show\n+\n+optParser :: Parser Opts\n+optParser =\n+  Opts\n+    <$> option modNameReader (long \"module\")\n+    <*> many (option modDepReader (long \"module-dep\" <> help \"Module.Name:packageid\"))\n+    <*> option str (short 'o')\n+  where\n+    modNameReader = maybeReader (Just . ModuleName . T.splitOn \".\" . T.pack)\n+    modDepReader = maybeReader $ \\s ->\n+      case T.splitOn \":\" (T.pack s) of\n+        [modName, packageId] -> Just ModuleDep\n+          { depModuleName = ModuleName (T.splitOn \".\" modName)\n+          , depPackageId = PackageId packageId\n+          }\n+        _ -> Nothing\n+\n+main :: IO ()\n+main = do\n+  Opts{..} <- execParser (info optParser idm)\n+  case optModule of\n+    ModuleName [\"GHC\", \"Types\"] ->\n+      writePackage ghcTypes optOutputPath\n+    ModuleName [\"GHC\", \"Prim\"] ->\n+      writePackage ghcPrim optOutputPath\n+    _ -> fail $ \"Unknown module: \" <> show optModule\n+\n+lfVersion :: Version\n+lfVersion = version1_7\n+\n+writePackage :: Module -> FilePath -> IO ()\n+writePackage mod path = do\n+  let pkg = Package lfVersion (NM.fromList [mod])\n+  BS.writeFile path $ encodeArchive pkg\n+\n+ghcTypes :: Module\n+ghcTypes = Module\n+  { moduleName = modName\n+  , moduleSource = Nothing\n+  , moduleFeatureFlags = daml12FeatureFlags\n+  , moduleDataTypes = NM.fromList [dataOrdering, dataProxy]\n+  , moduleValues = NM.fromList (proxyCtor : map valCtor cons)\n+  , moduleTemplates = NM.empty\n+  }\n+  where\n+    modName = mkModName [\"GHC\", \"Types\"]\n+    qual = Qualified PRSelf modName\n+    cons = [\"LT\", \"EQ\", \"GT\"]\n+    dataOrdering = DefDataType\n+      { dataLocation= Nothing\n+      , dataTypeCon = mkTypeCon [\"Ordering\"]\n+      , dataSerializable = IsSerializable True\n+      , dataParams = []\n+      , dataCons = DataEnum $ map mkVariantCon cons\n+      }\n+    valCtor con = DefValue\n+      { dvalLocation = Nothing\n+      , dvalBinder = (mkVal (\"$ctor:\" <> con), TCon (qual (dataTypeCon dataOrdering)))\n+      , dvalNoPartyLiterals= HasNoPartyLiterals True\n+      , dvalIsTest = IsTest False\n+      , dvalBody = EEnumCon (qual (dataTypeCon dataOrdering)) (mkVariantCon con)\n+      }\n+    dataProxy = DefDataType\n+      { dataLocation= Nothing\n+      , dataTypeCon = mkTypeCon [\"Proxy\"]\n+      , dataSerializable = IsSerializable True\n+      , dataParams = [(mkTypeVar \"a\", KStar)]\n+      , dataCons = DataRecord []\n+      }\n+    proxyCtor = DefValue"
  }
]