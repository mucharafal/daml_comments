[
  {
    "id" : "8852feaf-aa78-4853-adfb-feec6182a88b",
    "prId" : 4023,
    "comments" : [
      {
        "id" : "b13fe6d6-f8ea-49d8-8814-a4deb66d1ddc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is enabled by default.",
        "createdAt" : "2020-01-23T13:14:15Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b956f6d7-11fc-495f-94f3-b8f621f20c82",
        "parentId" : "b13fe6d6-f8ea-49d8-8814-a4deb66d1ddc",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Actually it isn‚Äôt. The GHC docs lied to me by claiming that `MultiParamTypeclasses` imply `ConstrainedClassMethods`.",
        "createdAt" : "2020-01-23T13:27:59Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7756a58dadb0273a3e473dd5238baa88e5f39809",
    "line" : 1,
    "diffHunk" : "@@ -1,5 +1,3 @@\n-{-# LANGUAGE ConstrainedClassMethods #-}"
  },
  {
    "id" : "04505ca1-3a23-48b7-9760-fd674a426c2e",
    "prId" : 4023,
    "comments" : [
      {
        "id" : "e89d0386-6370-4f28-9698-a8105ce1191c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We decided to just disable this for now. We don‚Äôt use this on our large internal DAML codebase. There is a reasonable workaround with manual dictionary passing and if it does become a record we could either handle this in the LF conversion or support infinite types (something like OCaml‚Äôs `-rectypes`).",
        "createdAt" : "2020-01-23T13:19:01Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a36b125a-41e5-45c8-a165-5ba0ddd21ddd",
        "parentId" : "e89d0386-6370-4f28-9698-a8105ce1191c",
        "author" : null,
        "body" : "Seems reasonable to me. I don't know of any natural examples of a class that requires itself as a constraint.",
        "createdAt" : "2020-01-24T08:36:42Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "7756a58dadb0273a3e473dd5238baa88e5f39809",
    "line" : 12,
    "diffHunk" : "@@ -9,5 +7,8 @@ class A t where\n     foo : t -> t\n     bar : Eq t => t -> t\n \n-class B t where\n-    baz : B b => b -> t\n+-- This would create a recursive type synonym."
  },
  {
    "id" : "79ee6628-4477-44eb-a678-4fa1d1f9e483",
    "prId" : 2632,
    "comments" : [
      {
        "id" : "c5b169cf-44f7-4d70-a8bb-f4846a273b56",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "fwiw it‚Äôs not that much of an edge case `foldMap` is the first non-artifical example that comes to mind.",
        "createdAt" : "2019-08-22T12:34:09Z",
        "updatedAt" : "2019-08-22T13:17:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "05887c1c-6e29-4e9d-b486-f7f7e5a03fe0",
        "parentId" : "c5b169cf-44f7-4d70-a8bb-f4846a273b56",
        "author" : null,
        "body" : "Good point! üëç ",
        "createdAt" : "2019-08-22T13:17:59Z",
        "updatedAt" : "2019-08-22T13:17:59Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "bbcd2c41d3a0b442a584d575d784209b0d007d0b",
    "line" : 8,
    "diffHunk" : "@@ -0,0 +1,13 @@\n+{-# LANGUAGE ConstrainedClassMethods #-}\n+\n+daml 1.2\n+-- | This module tests the case where a class method contains a constraint\n+-- not present in the class itself.\n+module ConstrainedClassMethod where\n+\n+class A t where"
  }
]