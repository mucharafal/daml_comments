[
  {
    "id" : "00b25c60-1e39-4f5d-9232-d4b2761e53d7",
    "prId" : 7544,
    "comments" : [
      {
        "id" : "0ada1f84-8b63-4731-8d89-6323cdf88d99",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Not for this PR, but I'm wondering if the outputs should be qualified too in this case.",
        "createdAt" : "2020-10-02T10:11:22Z",
        "updatedAt" : "2020-10-02T10:18:04Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5d33ec72-a6cb-46b4-9648-8345967d30ee",
        "parentId" : "0ada1f84-8b63-4731-8d89-6323cdf88d99",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not sure I understand what you are suggesting. This is just the `Show` instance. We don’t have any control over this and it doesn’t depend on imports.",
        "createdAt" : "2020-10-02T10:18:36Z",
        "updatedAt" : "2020-10-02T10:18:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bf8dc543-452e-4031-8650-daf5b07d84af",
        "parentId" : "0ada1f84-8b63-4731-8d89-6323cdf88d99",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Ah, right, forgot that this is just `Show`. Nvm.",
        "createdAt" : "2020-10-02T12:20:40Z",
        "updatedAt" : "2020-10-02T12:20:41Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4fea2aeb19f36d50d35597db4587eae2f35fcb86",
    "line" : 20,
    "diffHunk" : "@@ -327,6 +327,15 @@ functionalTests replClient replLogger serviceOut options ideState = describe \"re\n           , input \":json x\"\n           , matchOutput \"1\"\n           ]\n+    , testInteraction' \"collision\"\n+      -- Test that collisions are handled correctly if users qualify names.\n+          [ input \"let x = ReplTest.NameCollision \\\"abc\\\"\"\n+          , input \"x\"\n+          , matchOutput \"NameCollision {field = \\\"abc\\\"}\"\n+          , input \"y <- pure $ Colliding.NameCollision 42\"\n+          , input \"y\"\n+          , matchOutput \"NameCollision {field = 42}\""
  },
  {
    "id" : "68188be0-0571-42ec-8992-dd7bca8dcb8b",
    "prId" : 5450,
    "comments" : [
      {
        "id" : "34f50b6e-e242-4f8c-bb55-7e9507731351",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "What's `-l`?",
        "createdAt" : "2020-04-06T13:38:54Z",
        "updatedAt" : "2020-04-07T06:39:23Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a403d70e-fef0-4c35-83a9-e6bdfa94189f",
        "parentId" : "34f50b6e-e242-4f8c-bb55-7e9507731351",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "An impressively bad typo of `it` :joy: ",
        "createdAt" : "2020-04-06T19:45:45Z",
        "updatedAt" : "2020-04-07T06:39:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9e526fb13548ec2a6ed5eb583311d1c63b0759ed",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,296 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+module DA.Test.Repl.FuncTests (main) where\n+\n+import Control.Concurrent.Async\n+import Control.Exception\n+import Control.Monad.Extra\n+import DA.Bazel.Runfiles\n+import DA.Cli.Damlc.IdeState\n+import DA.Cli.Damlc.Packaging\n+import DA.Cli.Output\n+import DA.Daml.Compiler.Repl\n+import qualified DA.Daml.LF.ReplClient as ReplClient\n+import DA.Daml.Options.Types\n+import DA.Daml.Package.Config\n+import DA.Daml.Project.Types\n+import DA.Test.Sandbox\n+import DA.Test.Util\n+import Data.Foldable\n+import Development.IDE.Types.Location\n+import qualified DA.Service.Logger as Logger\n+import qualified DA.Service.Logger.Impl.IO as Logger\n+import GHC.IO.Handle\n+import SdkVersion\n+import System.Directory\n+import System.Environment.Blank\n+import System.FilePath\n+import System.IO.Extra\n+import System.Process\n+import Test.Hspec\n+import Text.Regex.TDFA\n+\n+-- NOTE (MK) This test suite tests the repl as a library rather than creating a separate\n+-- process for each test. This is significantly faster but comes with a few challenges:\n+--\n+-- 1. repline (and for the most part haskeline) do not provide a way to supply custom handles\n+-- 2. This means that we have to temporarily redirect stdin and stdout to capture them.\n+-- 3. Tasty interleaves its own output with the output of tests. This breaks any attempts\n+--    at capturing stdout.\n+-- 4. hspec in single-threaded mode luckily works as we want to so for now, this is our only\n+--    hspec test suite. Another option would be to write a reporter for tasty that prints to\n+--    stderr.\n+\n+main :: IO ()\n+main = do\n+    scriptDar <- locateRunfiles (mainWorkspace </> \"daml-script\" </> \"daml\" </> \"daml-script.dar\")\n+    testDar <- locateRunfiles (mainWorkspace </> \"compiler\" </> \"damlc\" </> \"tests\" </> \"repl-test.dar\")\n+    replDir <- locateRunfiles (mainWorkspace </> \"compiler/repl-service/server\")\n+    forM_ [stdin, stdout, stderr] $ \\h -> hSetBuffering h LineBuffering\n+    let replJar = replDir </> \"repl-service.jar\"\n+    -- Turning the repl client into a resource is a bit annoying since it requires\n+    -- pulling apart functions like `withGrpcClient`. Therefore we just\n+    -- allocate the resources before handing over to tasty and accept that\n+    -- -l will spin up sandbox and the repl client."
  },
  {
    "id" : "bf817c22-9ea8-4f8f-9a68-4cc1cb700b6c",
    "prId" : 5450,
    "comments" : [
      {
        "id" : "7383deaf-195c-4772-8481-a0397430963e",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\n-- | Based on the function in @main-tester@ of the same name which is sadly not exposed.\r\n```\r\nhaddock markup",
        "createdAt" : "2020-04-06T13:40:54Z",
        "updatedAt" : "2020-04-07T06:39:23Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9e526fb13548ec2a6ed5eb583311d1c63b0759ed",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,296 @@\n+-- Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+module DA.Test.Repl.FuncTests (main) where\n+\n+import Control.Concurrent.Async\n+import Control.Exception\n+import Control.Monad.Extra\n+import DA.Bazel.Runfiles\n+import DA.Cli.Damlc.IdeState\n+import DA.Cli.Damlc.Packaging\n+import DA.Cli.Output\n+import DA.Daml.Compiler.Repl\n+import qualified DA.Daml.LF.ReplClient as ReplClient\n+import DA.Daml.Options.Types\n+import DA.Daml.Package.Config\n+import DA.Daml.Project.Types\n+import DA.Test.Sandbox\n+import DA.Test.Util\n+import Data.Foldable\n+import Development.IDE.Types.Location\n+import qualified DA.Service.Logger as Logger\n+import qualified DA.Service.Logger.Impl.IO as Logger\n+import GHC.IO.Handle\n+import SdkVersion\n+import System.Directory\n+import System.Environment.Blank\n+import System.FilePath\n+import System.IO.Extra\n+import System.Process\n+import Test.Hspec\n+import Text.Regex.TDFA\n+\n+-- NOTE (MK) This test suite tests the repl as a library rather than creating a separate\n+-- process for each test. This is significantly faster but comes with a few challenges:\n+--\n+-- 1. repline (and for the most part haskeline) do not provide a way to supply custom handles\n+-- 2. This means that we have to temporarily redirect stdin and stdout to capture them.\n+-- 3. Tasty interleaves its own output with the output of tests. This breaks any attempts\n+--    at capturing stdout.\n+-- 4. hspec in single-threaded mode luckily works as we want to so for now, this is our only\n+--    hspec test suite. Another option would be to write a reporter for tasty that prints to\n+--    stderr.\n+\n+main :: IO ()\n+main = do\n+    scriptDar <- locateRunfiles (mainWorkspace </> \"daml-script\" </> \"daml\" </> \"daml-script.dar\")\n+    testDar <- locateRunfiles (mainWorkspace </> \"compiler\" </> \"damlc\" </> \"tests\" </> \"repl-test.dar\")\n+    replDir <- locateRunfiles (mainWorkspace </> \"compiler/repl-service/server\")\n+    forM_ [stdin, stdout, stderr] $ \\h -> hSetBuffering h LineBuffering\n+    let replJar = replDir </> \"repl-service.jar\"\n+    -- Turning the repl client into a resource is a bit annoying since it requires\n+    -- pulling apart functions like `withGrpcClient`. Therefore we just\n+    -- allocate the resources before handing over to tasty and accept that\n+    -- -l will spin up sandbox and the repl client.\n+    withTempFile $ \\portFile ->\n+        withBinaryFile nullDevice WriteMode $ \\devNull ->\n+        bracket (createSandbox portFile devNull defaultSandboxConf { dars = [testDar] }) destroySandbox $ \\SandboxResource{sandboxPort} ->\n+        ReplClient.withReplClient (ReplClient.Options replJar \"localhost\" (show sandboxPort) Nothing Nothing CreatePipe) $ \\replHandle mbServiceOut ->\n+        -- TODO We could share some of this setup with the actual repl code in damlc.\n+        withTempDir $ \\dir ->\n+        withCurrentDirectory dir $ do\n+        Just serviceOut <- pure mbServiceOut\n+        writeFileUTF8 \"daml.yaml\" $ unlines\n+            [ \"sdk-version: \" <> sdkVersion\n+            , \"name: repl\"\n+            , \"version: 0.0.1\"\n+            , \"source: .\"\n+            , \"dependencies:\"\n+            , \"- daml-prim\"\n+            , \"- daml-stdlib\"\n+            , \"- \" <> show scriptDar\n+            , \"- \" <> show testDar\n+            ]\n+        withPackageConfig (ProjectPath \".\") $ \\PackageConfigFields {..} -> do\n+            createProjectPackageDb (toNormalizedFilePath' dir) options pSdkVersion pDependencies pDataDependencies\n+            logger <- Logger.newStderrLogger Logger.Warning \"repl-tests\"\n+            withDamlIdeState options logger (hDiagnosticsLogger stdout) $ \\ideState -> do\n+                args <- getArgs\n+                withArgs (\"--jobs=1\" : args) $\n+                    hspec $ functionalTests replHandle serviceOut testDar options ideState\n+\n+options :: Options\n+options = (defaultOptions Nothing) { optScenarioService = EnableScenarioService False }\n+\n+functionalTests :: ReplClient.Handle -> Handle -> FilePath -> Options -> IdeState -> Spec\n+functionalTests replClient serviceOut testDar options ideState = describe \"repl func tests\" $ sequence_\n+    [ testInteraction' \"create and query\"\n+          [ input \"alice <- allocateParty \\\"Alice\\\"\"\n+          , input \"debug =<< query @T alice\"\n+          , matchServiceOutput \"^.*: \\\\[\\\\]$\"\n+          , input \"submit alice $ createCmd (T alice alice)\"\n+          , input \"debug =<< query @T alice\"\n+          , matchServiceOutput \"^.*: \\\\[\\\\(<contract-id>,T {proposer = '[^']+', accepter = '[^']+'}.*\\\\)\\\\]$\"\n+          ]\n+    , testInteraction' \"propose and accept\"\n+          [ input \"alice <- allocateParty \\\"Alice\\\"\"\n+          , input \"bob <- allocateParty \\\"Bob\\\"\"\n+          , input \"submit alice $ createCmd (TProposal alice bob)\"\n+          , input \"props <- query @TProposal bob\"\n+          , input \"debug props\"\n+          , matchServiceOutput \"^.*: \\\\[\\\\(<contract-id>,TProposal {proposer = '[^']+', accepter = '[^']+'}.*\\\\)\\\\]$\"\n+          , input \"forA props $ \\\\(prop, _) -> submit bob $ exerciseCmd prop Accept\"\n+          , input \"debug =<< query @T bob\"\n+          , matchServiceOutput \"^.*: \\\\[\\\\(<contract-id>,T {proposer = '[^']+', accepter = '[^']+'}.*\\\\)\\\\]$\"\n+          , input \"debug =<< query @TProposal bob\"\n+          , matchServiceOutput \"^.*: \\\\[\\\\]$\"\n+          ]\n+    , testInteraction' \"shadowing\"\n+          [ input \"x <- pure 1\"\n+          , input \"debug x\"\n+          , matchServiceOutput \"^.*: 1$\"\n+          , input \"x <- pure $ x + x\"\n+          , input \"debug x\"\n+          , matchServiceOutput \"^.*: 2$\"\n+          ]\n+    , testInteraction' \"parse error\"\n+          [ input \"eaiu\\\\1\"\n+          , matchOutput \"^parse error.*$\"\n+          , input \"debug 1\"\n+          , matchServiceOutput \"^.*: 1\"\n+          ]\n+    , testInteraction' \"Tuple patterns\"\n+          [ input \"(a, b) <- pure (1, 2)\"\n+          , input \"(b, c) <- pure (3, 4)\"\n+          , input \"debug a\"\n+          , matchServiceOutput \"^.*: 1\"\n+          , input \"debug b\"\n+          , matchServiceOutput \"^.*: 3\"\n+          , input \"debug c\"\n+          , matchServiceOutput \"^.*: 4\"\n+          ]\n+    , testInteraction' \"Partial patterns\"\n+          -- TODO (MK) We do not test failing patterns yet\n+          -- since `error` calls aren’t handled nicely atm.\n+          [ input \"Some (x, Some y) <- pure (Some (1, Some 2))\"\n+          , input \"debug x\"\n+          , matchServiceOutput \"^.*: 1\"\n+          , input \"debug y\"\n+          , matchServiceOutput \"^.*: 2\"\n+          ]\n+    , testInteraction' \"type error\"\n+          [ input \"1\"\n+          -- TODO Make this less noisy\n+          , matchOutput \"^File:.*$\"\n+          , matchOutput \"^Hidden:.*$\"\n+          , matchOutput \"^Range:.*$\"\n+          , matchOutput \"^Source:.*$\"\n+          , matchOutput \"^Severity:.*$\"\n+          , matchOutput \"^Message:.*$\"\n+          , matchOutput \"^.*error.*$\"\n+          , matchOutput \"^.*expected type .*Script .* with actual type .*Int.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , input \"debug 1\"\n+          , matchServiceOutput \"^.*: 1\"\n+          ]\n+    , testInteraction' \"script error\"\n+          [ input \"alice <- allocateParty \\\"Alice\\\"\"\n+          , input \"bob <- allocateParty \\\"Bob\\\"\"\n+          , input \"submit alice (createCmd (T alice bob))\"\n+          , matchServiceOutput \"^.*Submit failed.*requires authorizers.*but only.*were given.*$\"\n+          , matchServiceOutput \"^.*$\"\n+          , input \"debug 1\"\n+          , matchServiceOutput \"^.*: 1\"\n+          ]\n+    , testInteraction' \"server error\"\n+          [ input \"alice <- allocatePartyWithHint \\\"Alice\\\" (PartyIdHint \\\"alice_doubly_allocated\\\")\"\n+          , input \"alice <- allocatePartyWithHint \\\"Alice\\\" (PartyIdHint \\\"alice_doubly_allocated\\\")\"\n+          , matchServiceOutput \"io.grpc.StatusRuntimeException: INVALID_ARGUMENT: Invalid argument: Party already exists\"\n+          , input \"debug 1\"\n+          , matchServiceOutput \"^.*: 1\"\n+          ]\n+    , testInteraction' \"module imports\"\n+          [ input \"debug (days 1)\"\n+          , matchOutput \"^File:.*$\"\n+          , matchOutput \"^Hidden:.*$\"\n+          , matchOutput \"^Range:.*$\"\n+          , matchOutput \"^Source:.*$\"\n+          , matchOutput \"^Severity:.*$\"\n+          , matchOutput \"^Message:.*error: Variable not in scope: days.*$\"\n+          , input \"import DA.Time.Misspelled\"\n+          , matchOutput \"^File:.*$\"\n+          , matchOutput \"^Hidden:.*$\"\n+          , matchOutput \"^Range:.*$\"\n+          , matchOutput \"^Source:.*$\"\n+          , matchOutput \"^Severity:.*$\"\n+          , matchOutput \"^Message:.*$\"\n+          , matchOutput \"^.*Could not find module.*$\"\n+          -- TODO[AH]: We get \"diagnostics echo\", presumably because we don't\n+          -- increment the line number and therefore don't change module name\n+          -- as long as there are errors.\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , input \"import DA.Time\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , matchOutput \"^.*$\"\n+          , input \"debug (days 1)\"\n+          , matchServiceOutput \"^.*: RelTime {microseconds = 86400000000}$\"\n+          ]\n+    ]\n+  where\n+    testInteraction' testName steps =\n+        it testName $\n+        testInteraction testDar replClient serviceOut options ideState steps\n+\n+testInteraction\n+    :: FilePath\n+    -> ReplClient.Handle\n+    -> Handle\n+    -> Options\n+    -> IdeState\n+    -> [Step]\n+    -> Expectation\n+testInteraction testDar replClient serviceOut options ideState steps = withRepl $ \\hIn hOut async -> do\n+    for_ steps $ \\step -> do\n+        case step of\n+            Input s -> do\n+                readPrompt hOut\n+                hPutStrLn hIn s\n+            MatchOutput regex regexStr producer -> do\n+                line <- case producer of\n+                    ReplClient -> hGetLine hOut\n+                    ReplService -> hGetLine serviceOut\n+                unless (matchTest regex line) $\n+                    expectationFailure (show line <> \" did not match \" <> show regexStr)\n+    hClose hIn\n+    wait async\n+  where\n+     withRepl f =\n+         -- Sadly haskeline does not provide a way to tell it which handles we use\n+         -- have to mess around with stdout/stdin\n+         bracket createPipe (\\(a, b) -> mapM_ hClose [a,b]) $ \\(readOut, writeOut) ->\n+         bracket createPipe (\\(a, b) -> mapM_ hClose [a,b]) $ \\(readIn, writeIn) -> do\n+         forM_ [readIn, writeIn, readOut, writeOut] $ \\h -> hSetBuffering h LineBuffering\n+         redirectingHandle stdout writeOut $\n+           redirectingHandle stdin readIn $ do\n+           Right () <- ReplClient.clearResults replClient\n+           withAsync (runRepl options testDar replClient ideState) $ f writeIn readOut\n+\n+data Step\n+    = Input String\n+    -- ^ Input a line into the repl\n+    | MatchOutput Regex String Producer\n+    -- ^ Match a line of output against a given regex.\n+    -- The String is used for error messages since Regex\n+    -- does not have a Show instance.\n+\n+data Producer = ReplClient | ReplService\n+\n+input :: String -> Step\n+input = Input\n+\n+matchOutput :: String -> Step\n+matchOutput s = MatchOutput (makeRegex s) s ReplClient\n+\n+matchServiceOutput :: String -> Step\n+matchServiceOutput s = MatchOutput (makeRegex s) s ReplService\n+\n+readPrompt :: Handle -> Expectation\n+readPrompt h = do\n+    res <- replicateM 6 (hGetChar h)\n+    res `shouldBe` \"daml> \"\n+\n+-- | Based on the function in `main-tester` of the same name which is sadly not exposed."
  }
]