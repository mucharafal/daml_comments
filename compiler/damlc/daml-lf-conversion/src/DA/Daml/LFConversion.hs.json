[
  {
    "id" : "66ba3f85-82d2-472f-bdf9-d87e3757321c",
    "prId" : 7815,
    "comments" : [
      {
        "id" : "8e4b6820-51ab-4f33-a2cf-938db0ee3ce9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                    | let names = [ name | BF.Var name <- map unLoc subclauses ]\r\n```",
        "createdAt" : "2020-10-27T13:55:10Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "323977ef2324d231a554726a69744fffb86d151b",
    "line" : null,
    "diffHunk" : "@@ -544,8 +545,27 @@ convertClassDef env tycon\n             EBuiltin (BEText \"undefined\") -- We only care about the type, not the expr.\n         funDepDef = defValue tycon (funDepName tsynName, funDepType) funDepExpr\n \n-    pure $ [typeDef] ++ [funDepDef | classHasFds cls && newStyle]\n-        -- NOTE (SF): No reason to generate fundep metadata with old-style typeclasses,\n+    let minimal = fmap getOccText (classMinimalDef cls)\n+        methodsWithNoDefault = sort [ getOccText id | (id, Nothing) <- classOpItems cls ]\n+            -- ^ Used when MINIMAL pragma is not given,\n+            -- i.e. the minimal sig is all methods without a default implementation.\n+        minimalIsDefault =\n+            case minimal of\n+                BF.Var x -> [x] == methodsWithNoDefault\n+                BF.And subclauses\n+                    | names <- [ name | BF.Var name <- map unLoc subclauses ]"
  },
  {
    "id" : "904a24a0-5359-49b6-a56f-7f523ec28749",
    "prId" : 7815,
    "comments" : [
      {
        "id" : "4431b822-4d18-4e56-a779-a3c8edd2c025",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we need all this special casing for default handling? Isn’t not specifying a minimal pragma equivalent to all methods being part of the default pragma and we can just aways reconstruct the pragma?",
        "createdAt" : "2020-10-27T14:50:23Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0dd039f3-6c5f-48fa-8c4c-419632e84a52",
        "parentId" : "4431b822-4d18-4e56-a779-a3c8edd2c025",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "nvm, of course it isn’t equivalent.",
        "createdAt" : "2020-10-27T14:58:47Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "13e3abd2-b5ae-436b-9d56-420c8a84430b",
        "parentId" : "4431b822-4d18-4e56-a779-a3c8edd2c025",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "A good reason is to avoid encoding the minimal pragmas unless we have to, to keep DAR size down. A certain codebase has a lot of typeclasses...",
        "createdAt" : "2020-10-27T15:04:38Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "323977ef2324d231a554726a69744fffb86d151b",
    "line" : 27,
    "diffHunk" : "@@ -544,8 +545,27 @@ convertClassDef env tycon\n             EBuiltin (BEText \"undefined\") -- We only care about the type, not the expr.\n         funDepDef = defValue tycon (funDepName tsynName, funDepType) funDepExpr\n \n-    pure $ [typeDef] ++ [funDepDef | classHasFds cls && newStyle]\n-        -- NOTE (SF): No reason to generate fundep metadata with old-style typeclasses,\n+    let minimal = fmap getOccText (classMinimalDef cls)\n+        methodsWithNoDefault = sort [ getOccText id | (id, Nothing) <- classOpItems cls ]\n+            -- ^ Used when MINIMAL pragma is not given,\n+            -- i.e. the minimal sig is all methods without a default implementation.\n+        minimalIsDefault =\n+            case minimal of\n+                BF.Var x -> [x] == methodsWithNoDefault\n+                BF.And subclauses\n+                    | names <- [ name | BF.Var name <- map unLoc subclauses ]\n+                    , length names == length subclauses\n+                    -> sort names == methodsWithNoDefault"
  },
  {
    "id" : "f86736b8-5317-47c4-942d-9d2e62e838ae",
    "prId" : 7765,
    "comments" : [
      {
        "id" : "7606e211-51b7-4704-bad8-34b6795a6c83",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we really want to support this?",
        "createdAt" : "2020-10-22T13:18:48Z",
        "updatedAt" : "2020-10-22T13:21:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f96c23f0-515d-45b8-be43-872ad880904f",
        "parentId" : "7606e211-51b7-4704-bad8-34b6795a6c83",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "As far as damlc is concerned, it's an \"overlap mode\" pragma like any other. In this light, I don't have any problem with it, or any reason to oppose it, compared to any other overlap modes.\r\n\r\nOne okay reason to support it is because instances marked \"INCOHERENT\" always have the lowest priority, so they have a kind of a unique function as an \"ultimate default option\", if you're going to be relying on overlapping instances at all. ",
        "createdAt" : "2020-10-22T14:24:42Z",
        "updatedAt" : "2020-10-22T14:24:42Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d1356ff9-707a-4511-a6b2-53471fed116c",
        "parentId" : "7606e211-51b7-4704-bad8-34b6795a6c83",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "But I don't feel strongly either way. It is currently less work to support it than to emit a warning.",
        "createdAt" : "2020-10-22T14:35:08Z",
        "updatedAt" : "2020-10-22T14:35:08Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c340f90b83721e8e33d79aa8f76e91309b67121a",
    "line" : 76,
    "diffHunk" : "@@ -730,21 +740,44 @@ convertBind env (name, x)\n     | ConstraintTupleProjectionName _ _ <- name\n     = pure []\n \n+    -- Typeclass instance dictionaries\n+    | DFunId isNewtype <- idDetails name\n+    = withRange (convNameLoc name) $ do\n+    x' <- convertExpr env x\n+    -- NOTE(MH): This is DICTIONARY SANITIZATION step (3).\n+    -- The sanitization for newtype dictionaries is done in `convertCoercion`.\n+    let sanitized_x'\n+          | isNewtype = x'\n+          | otherwise =\n+            let fieldsPrism\n+                  | envLfVersion env `supports` featureTypeSynonyms = _EStructCon\n+                  | otherwise = _ERecCon . _2\n+            in over (_ETyLams . _2 . _ETmLams . _2 . fieldsPrism . each . _2) (ETmLam (mkVar \"_\", TUnit)) x'\n+    name' <- convValWithType env name\n+\n+    -- OVERLAP* annotations\n+    let overlapModeName = ExprValName (\"$$om\" <> getOccText name)\n+        overlapModeValueM =\n+            case MS.lookup name (envModInstanceInfo env) of\n+                Nothing -> Nothing\n+                Just (NoOverlap _) -> Nothing\n+                Just (Overlappable _) -> Just \"OVERLAPPABLE\"\n+                Just (Overlapping _) -> Just \"OVERLAPPING\"\n+                Just (Overlaps _) -> Just \"OVERLAPS\"\n+                Just (Incoherent _) -> Just \"INCOHERENT\""
  },
  {
    "id" : "fb6e7e1b-9eb7-48d8-9519-5e92f0b47b4e",
    "prId" : 7765,
    "comments" : [
      {
        "id" : "fb0df2a8-228c-4fd7-aa95-dd9558627590",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This refactoring reminds me of something I did a few days ago. Is that the change I reverted?",
        "createdAt" : "2020-10-22T13:20:13Z",
        "updatedAt" : "2020-10-22T13:21:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4d5fd711-9743-4f69-b47a-8103a8e04b84",
        "parentId" : "fb0df2a8-228c-4fd7-aa95-dd9558627590",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Yes ... I was working off the master that was reverted. This caused some merge conflicts due to the reversion, but actually having typeclass instances as a separate case in `convertBind` (as it is here) is more convenient, so the refactoring ended up sneaking back in. :) ",
        "createdAt" : "2020-10-22T14:16:29Z",
        "updatedAt" : "2020-10-22T14:16:30Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c340f90b83721e8e33d79aa8f76e91309b67121a",
    "line" : 52,
    "diffHunk" : "@@ -730,21 +740,44 @@ convertBind env (name, x)\n     | ConstraintTupleProjectionName _ _ <- name\n     = pure []\n \n+    -- Typeclass instance dictionaries"
  },
  {
    "id" : "004c0926-fe1a-44a6-8f77-b9da009787a3",
    "prId" : 7725,
    "comments" : [
      {
        "id" : "c9953dc6-767c-4147-8342-8d7cf39d0cca",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is this really only a problem in combination with typeclasses? I thought erased kinds cause problems everywhere.",
        "createdAt" : "2020-10-19T07:15:20Z",
        "updatedAt" : "2020-10-19T07:29:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0e4320f5-1c54-4275-b171-4bebfe5ebd54",
        "parentId" : "c9953dc6-767c-4147-8342-8d7cf39d0cca",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "You're right, erased kinds are problematic everywhere. With code using promoted kinds does not compile in the first case. Functions using promoted kinds in their signature will have a different signature after importing via data-dependencies. This might become annoying but does not stop a package from being imported. The problem with typeclasses is that you might end up with overlapping instances after kind erasure where there was no overlap before. This will prevent a package from being data-dependable. I still don't understand the full picture and I expect these warnings to extend to more places in the long run.",
        "createdAt" : "2020-10-19T08:13:47Z",
        "updatedAt" : "2020-10-19T08:13:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "263edefbe9170285fb42164094fed7944166b805",
    "line" : 30,
    "diffHunk" : "@@ -150,6 +150,29 @@ unknown unitId pkgMap = conversionError errMsg\n unhandled :: (HasCallStack, Data a, Outputable a) => String -> a -> ConvertM e\n unhandled typ x = unsupported (typ ++ \" with \" ++ lower (show (toConstr x))) x\n \n+warn :: String -> ConvertM ()\n+warn msg = do\n+    ConversionEnv{..} <- ask\n+    let diag = (convModuleFilePath, ShowDiag, Diagnostic\n+            { _range = maybe noRange sourceLocToRange convRange\n+            , _severity = Just DsWarning\n+            , _source = Just \"Core to DAML-LF\"\n+            , _message = T.pack msg\n+            , _code = Nothing\n+            , _relatedInformation = Nothing\n+            , _tags = Nothing\n+            })\n+    modify' $ \\st -> ConversionState (diag : convWarnings st)\n+\n+warnNotDataDependable :: String -> ConvertM ()\n+warnNotDataDependable what =\n+    warn $ unlines\n+        [ \"Using \" ++ what ++ \" in combination with type classes\""
  },
  {
    "id" : "9ac1a259-ca63-4d2c-8f14-b363d9b431e4",
    "prId" : 7698,
    "comments" : [
      {
        "id" : "ab999bc2-af0a-4b5f-bde3-340e4d507bbe",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Perhaps worth adding a comment that we don’t care about this.",
        "createdAt" : "2020-10-15T14:02:20Z",
        "updatedAt" : "2020-10-15T14:15:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ac7c1e47-ea2a-4eb0-a68f-d1ef0c235f43",
        "parentId" : "ab999bc2-af0a-4b5f-bde3-340e4d507bbe",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Good idea, added. :-) ",
        "createdAt" : "2020-10-15T14:15:53Z",
        "updatedAt" : "2020-10-15T14:15:53Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4479fba4bdac074e6f2798d5cb3c3870ee1a1255",
    "line" : 46,
    "diffHunk" : "@@ -509,14 +512,48 @@ convertClassDef env tycon = do\n     let fields = zipExact labels (map sanitize fieldTypes)\n         tconName = mkTypeCon [getOccText tycon]\n         tsynName = mkTypeSyn [getOccText tycon]\n+        newStyle = envLfVersion env `supports` featureTypeSynonyms\n+            -- \"new-style typeclasses\" are type synonyms\n+            -- \"old-style typeclasses\" were record types\n         typeDef\n-            | envLfVersion env `supports` featureTypeSynonyms =\n-              -- Structs must have > 0 fields, therefore we simply make a typeclass a synonym for Unit\n-              -- if it has no fields\n-              defTypeSyn tsynName tyVars (if null fields then TUnit else TStruct fields)\n+            | newStyle =\n+                -- LF structs must have > 0 fields, therefore we define the\n+                -- typeclass as a synonym for Unit if it has no fields.\n+                defTypeSyn tsynName tyVars (if null fields then TUnit else TStruct fields)\n             | otherwise = defDataType tconName tyVars (DataRecord fields)\n \n-    pure [typeDef]\n+    let funDeps = snd (classTvsFds cls)\n+    funDeps' <- mapM (mapFunDepM (convTypeVarName env')) funDeps\n+\n+    let funDepTyVars = [(v, KStar) | (v, _) <- tyVars]\n+            -- We use the the type variables as types in the fundep encoding,\n+            -- not as whatever kind they were previously defined.\n+        funDepName = ExprValName (\"$fd\" <> getOccText tycon)\n+        funDepType = TForalls funDepTyVars (encodeFunDeps funDeps')\n+        funDepExpr = EBuiltin BEError `ETyApp` funDepType `ETmApp`"
  },
  {
    "id" : "af3cbf7a-99d9-40c2-9713-2457fea887ab",
    "prId" : 7698,
    "comments" : [
      {
        "id" : "dc04ea85-aabf-40d3-a06d-4a905f8e9827",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Dictionaries start with `$f`. Can this become a problem? Should we try to find some definitely unoccupied space, like starting with `$$`?",
        "createdAt" : "2020-10-15T14:43:44Z",
        "updatedAt" : "2020-10-15T14:45:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "217edabb-d564-4b7c-94cb-56eecd2c8ce6",
        "parentId" : "dc04ea85-aabf-40d3-a06d-4a905f8e9827",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Oh, shoot. And the PR merged already... I'll open a new PR to rename this.\r\n\r\nFortunately I don't think a conflict is actually possible with `$fd` because dictionary functions names always start with `$fT` where `T` is the name of the class, and `T` can never start with a lowercase `d`. ",
        "createdAt" : "2020-10-15T14:54:53Z",
        "updatedAt" : "2020-10-15T14:54:54Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2ee964c5-19f9-427a-a047-25b3b0566845",
        "parentId" : "dc04ea85-aabf-40d3-a06d-4a905f8e9827",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can you write instances like\r\n```haskell\r\ninstance (Functor a, Show a) => Foo (d a) where\r\n```\r\nMaybe I'm just paranoid but I'd prefer to be on the really safe side. 😺 ",
        "createdAt" : "2020-10-15T15:03:22Z",
        "updatedAt" : "2020-10-15T15:03:22Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a5a73663-2fc3-4cec-910c-498321ed41ff",
        "parentId" : "dc04ea85-aabf-40d3-a06d-4a905f8e9827",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "And thanks for changing it.",
        "createdAt" : "2020-10-15T15:05:11Z",
        "updatedAt" : "2020-10-15T15:05:11Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7436d391-d018-4465-9acd-e2ac43a5e8a1",
        "parentId" : "dc04ea85-aabf-40d3-a06d-4a905f8e9827",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "No, the dictionary function would be `$fFood` in that case.\r\n\r\nHere's the PR: https://github.com/digital-asset/daml/pull/7701",
        "createdAt" : "2020-10-15T15:29:36Z",
        "updatedAt" : "2020-10-15T15:29:36Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6164bc6a-f579-42de-907e-6edcba26659b",
        "parentId" : "dc04ea85-aabf-40d3-a06d-4a905f8e9827",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`$fFood`? That sounds yummy. 😋\r\n\r\nThanks for changing it.",
        "createdAt" : "2020-10-15T16:43:47Z",
        "updatedAt" : "2020-10-15T16:43:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4479fba4bdac074e6f2798d5cb3c3870ee1a1255",
    "line" : 44,
    "diffHunk" : "@@ -509,14 +512,48 @@ convertClassDef env tycon = do\n     let fields = zipExact labels (map sanitize fieldTypes)\n         tconName = mkTypeCon [getOccText tycon]\n         tsynName = mkTypeSyn [getOccText tycon]\n+        newStyle = envLfVersion env `supports` featureTypeSynonyms\n+            -- \"new-style typeclasses\" are type synonyms\n+            -- \"old-style typeclasses\" were record types\n         typeDef\n-            | envLfVersion env `supports` featureTypeSynonyms =\n-              -- Structs must have > 0 fields, therefore we simply make a typeclass a synonym for Unit\n-              -- if it has no fields\n-              defTypeSyn tsynName tyVars (if null fields then TUnit else TStruct fields)\n+            | newStyle =\n+                -- LF structs must have > 0 fields, therefore we define the\n+                -- typeclass as a synonym for Unit if it has no fields.\n+                defTypeSyn tsynName tyVars (if null fields then TUnit else TStruct fields)\n             | otherwise = defDataType tconName tyVars (DataRecord fields)\n \n-    pure [typeDef]\n+    let funDeps = snd (classTvsFds cls)\n+    funDeps' <- mapM (mapFunDepM (convTypeVarName env')) funDeps\n+\n+    let funDepTyVars = [(v, KStar) | (v, _) <- tyVars]\n+            -- We use the the type variables as types in the fundep encoding,\n+            -- not as whatever kind they were previously defined.\n+        funDepName = ExprValName (\"$fd\" <> getOccText tycon)"
  },
  {
    "id" : "6ac8802c-337d-4265-a39f-d95672b829eb",
    "prId" : 7548,
    "comments" : [
      {
        "id" : "1f1d0518-27ee-4ae0-b428-4547630aaaef",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's do that in a separate PR.",
        "createdAt" : "2020-10-15T11:50:47Z",
        "updatedAt" : "2020-10-21T08:55:23Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1968095863437d26708412e9478b8d076d85897c",
    "line" : null,
    "diffHunk" : "@@ -655,6 +655,7 @@ convertChoice env tbinds (ChoiceData ty expr)\n         , chcName = choiceName\n         , chcConsuming = consuming == Consuming\n         , chcControllers = controllers `ETmApp` EVar this `ETmApp` EVar arg\n+        , chcObservers = Nothing -- NICK, need syntax for non-empty choice-observers"
  },
  {
    "id" : "5ebca5f9-67f7-472b-aa05-aac870d96ffb",
    "prId" : 7252,
    "comments" : [
      {
        "id" : "141edebe-d82d-4b20-9989-87f902d71cfc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Answering my own question: No we don’t have to worry about backwards compatibility. `data-dependencies` only rely on types not values so they do not care about this.",
        "createdAt" : "2020-08-27T15:35:10Z",
        "updatedAt" : "2020-08-28T11:39:11Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5cd8cd54f886d4b5d729f46c48c70c22c49f3082",
    "line" : 5,
    "diffHunk" : "@@ -886,7 +886,7 @@ convertExpr env0 e = do\n         = fmap (, args) $ mkIf <$> convertExpr env x <*> convertExpr env y <*> mkPure env monad dict TUnit EUnit\n     go env (VarIn DA_Action \"unless\") (LType monad : LExpr dict : LExpr x : LExpr y : args)\n         = fmap (, args) $ mkIf <$> convertExpr env x <*> mkPure env monad dict TUnit EUnit <*> convertExpr env y\n-    go env submit@(VarIn DA_Internal_LF \"submit\") (LType m : LType cmds : LExpr dict : LType typ : LExpr pty : LExpr upd : args) = fmap (, args) $ do\n+    go env submit@(VarIn DA_Internal_LF \"submit\") (LType m : LType cmds : LExpr dict : LType typ : LExpr callstack : LExpr pty : LExpr upd : args) = fmap (, args) $ do"
  },
  {
    "id" : "1b14d1c2-5168-4828-959b-e8f78d3a02eb",
    "prId" : 6894,
    "comments" : [
      {
        "id" : "e24ee9c1-cc22-4fb2-9585-3884b017abdd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "A brief comment on this check and the one below would be great. This one seems to be to get `*`, `Constraint`, …. I’m not quite sure about the second one.",
        "createdAt" : "2020-07-28T12:02:00Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd8b14438d3d1adcf5a65aa01490d7b2fe3202d6",
    "line" : null,
    "diffHunk" : "@@ -475,6 +476,28 @@ convertSimpleRecordDef env tycon = do\n \n     pure $ typeDef : [workerDef | flavour == NewtypeFlavour]\n \n+convertTypeSynonym :: Env -> TyCon -> ConvertM [Definition]\n+convertTypeSynonym env tycon\n+    | NameIn DA_Generics _ <- GHC.tyConName tycon\n+    = pure []\n+\n+    | envLfVersion env `supports` featureTypeSynonyms\n+    , Just (params, body) <- synTyConDefn_maybe tycon\n+    , isLiftedTypeKind (tyConResKind tycon)"
  },
  {
    "id" : "36ab8b05-21b4-4a7c-9c60-2cf21366610f",
    "prId" : 6894,
    "comments" : [
      {
        "id" : "2eeca83f-3ae6-4851-ab6e-918608c1da50",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is there a technical reason for moving this further down or is it just a stylistic thing? I'm fine either way but would like to understand the former if that's the case.",
        "createdAt" : "2020-07-28T12:06:48Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "10bf6c8f-fb41-4976-8003-9b5821501dbc",
        "parentId" : "2eeca83f-3ae6-4851-ab6e-918608c1da50",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "I moved it down below typeclasses and constraint tuples before realizing it doesn't make a difference anyway.",
        "createdAt" : "2020-07-28T12:32:33Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "33a037a6-2511-415d-bfb6-e8e5fb7d0010",
        "parentId" : "2eeca83f-3ae6-4851-ab6e-918608c1da50",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Thanks for the explanation.",
        "createdAt" : "2020-07-28T13:20:57Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "dd8b14438d3d1adcf5a65aa01490d7b2fe3202d6",
    "line" : 18,
    "diffHunk" : "@@ -435,6 +431,11 @@ convertTypeDef env o@(ATyCon t) = withRange (convNameLoc t) $ if\n     | isClassTyCon t\n     -> convertClassDef env t\n \n+    -- Type synonyms get expanded out during conversion (see 'convertType'), but we also\n+    -- convert the synonyms we can so that we can expose them via data-dependencies.\n+    | isTypeSynonymTyCon t\n+    -> convertTypeSynonym env t"
  },
  {
    "id" : "22c16560-a894-42bd-b06c-32f2a5632c7a",
    "prId" : 6894,
    "comments" : [
      {
        "id" : "348018b9-9964-4d0a-8e32-8ab499b34b1d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Aren't we translating empty type classes into empty structural records? Isn't that different from the unit type?",
        "createdAt" : "2020-07-28T12:07:46Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "10975c6d-826b-47bb-930e-bac50ab9fc4f",
        "parentId" : "348018b9-9964-4d0a-8e32-8ab499b34b1d",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "LF does not allow for empty structural records.",
        "createdAt" : "2020-07-28T12:14:05Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "57db9a3d-c83e-4d5b-a12b-acd7a7ed4fc4",
        "parentId" : "348018b9-9964-4d0a-8e32-8ab499b34b1d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I wonder why we decided to do it like that. I have no recollection... 🤔 ",
        "createdAt" : "2020-07-28T13:20:38Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "dd8b14438d3d1adcf5a65aa01490d7b2fe3202d6",
    "line" : 43,
    "diffHunk" : "@@ -475,6 +476,28 @@ convertSimpleRecordDef env tycon = do\n \n     pure $ typeDef : [workerDef | flavour == NewtypeFlavour]\n \n+convertTypeSynonym :: Env -> TyCon -> ConvertM [Definition]\n+convertTypeSynonym env tycon\n+    | NameIn DA_Generics _ <- GHC.tyConName tycon\n+    = pure []\n+\n+    | envLfVersion env `supports` featureTypeSynonyms\n+    , Just (params, body) <- synTyConDefn_maybe tycon\n+    , isLiftedTypeKind (tyConResKind tycon)\n+    , not (isKindTyCon tycon)\n+    = do\n+        (env', tsynParams) <- bindTypeVars env params\n+        tsynType <- convertType env' body\n+        let tsynName = mkTypeSyn [getOccText tycon]\n+        case tsynType of\n+            TUnit -> pure []\n+                -- ^ We avoid converting TUnit type synonyms because it\n+                -- clashes with the conversion of empty typeclasses."
  },
  {
    "id" : "6f716c31-6517-4a1e-9955-7b3968584de1",
    "prId" : 6894,
    "comments" : [
      {
        "id" : "fce6a45f-8652-4e62-9461-8a68794c7d47",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does that check that we only export synonyms of kind star?",
        "createdAt" : "2020-07-28T12:08:55Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e1684be2-e099-416b-a089-f5fa2e38fa97",
        "parentId" : "fce6a45f-8652-4e62-9461-8a68794c7d47",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "So ... I just tested and this does indeed export constraint synonyms as well. But it also exports them without problem in data-dependencies (they work correctly, according to my tests).\r\n\r\nSo is it better to reject constraint synonyms (making the implementation more complicated), or to add a test to make sure they work (without changing the implementation)?",
        "createdAt" : "2020-07-28T12:50:15Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "09b9032c-4915-439d-bf2b-ebe62e44d195",
        "parentId" : "fce6a45f-8652-4e62-9461-8a68794c7d47",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "(cc @cocreature ^^)",
        "createdAt" : "2020-07-28T12:56:51Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "096f40e9-0341-4772-a8f2-a3f710401622",
        "parentId" : "fce6a45f-8652-4e62-9461-8a68794c7d47",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’d say support it and add a test for it.",
        "createdAt" : "2020-07-28T12:58:52Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8fa4ee80-640a-45f3-91f7-2e56b2236faf",
        "parentId" : "fce6a45f-8652-4e62-9461-8a68794c7d47",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Supporting and testing it sounds fine.",
        "createdAt" : "2020-07-28T13:20:47Z",
        "updatedAt" : "2020-07-28T13:34:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "dd8b14438d3d1adcf5a65aa01490d7b2fe3202d6",
    "line" : null,
    "diffHunk" : "@@ -475,6 +476,28 @@ convertSimpleRecordDef env tycon = do\n \n     pure $ typeDef : [workerDef | flavour == NewtypeFlavour]\n \n+convertTypeSynonym :: Env -> TyCon -> ConvertM [Definition]\n+convertTypeSynonym env tycon\n+    | NameIn DA_Generics _ <- GHC.tyConName tycon\n+    = pure []\n+\n+    | envLfVersion env `supports` featureTypeSynonyms\n+    , Just (params, body) <- synTyConDefn_maybe tycon\n+    , isLiftedTypeKind (tyConResKind tycon)"
  },
  {
    "id" : "9adc87dc-1084-40d2-bc15-266168e31f2a",
    "prId" : 6590,
    "comments" : [
      {
        "id" : "356b8707-a081-4767-85ce-5543583bfd8a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "In your PR description you mention that this will be a major challenge. Could you expand on that? I certainly see how it can be annoying to implement but I don’t see what exactly makes it challenging.",
        "createdAt" : "2020-07-03T07:08:27Z",
        "updatedAt" : "2020-07-03T09:22:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "06622c57-646b-4c36-a474-c8ffa03cc900",
        "parentId" : "356b8707-a081-4767-85ce-5543583bfd8a",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "I slept on it and I think there's an easy way to do it actually -- rewrite it as an `ELet` expression to force the \"record\" argument to be evaluated before the field. Before I thought it would have to branch on each constructor.",
        "createdAt" : "2020-07-03T09:00:18Z",
        "updatedAt" : "2020-07-03T09:22:38Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e9376d837f80d18b52ddb67f6b5420b992417047",
    "line" : 13,
    "diffHunk" : "@@ -760,6 +760,18 @@ convertExpr env0 e = do\n             recordType <- convertType env recordType\n             record <- convertExpr env record\n             pure $ ERecProj (fromTCon recordType) (mkField $ fsToText name) record\n+    -- NOTE(SF): We also need to inline `setField` in order to get the correct\n+    -- evaluation order (record first, then fields in order).\n+    go env (VarIn DA_Internal_Record \"setField\") (LType (isStrLitTy -> Just name) : LType record@(TypeCon recordTyCon _) : LType field : _dict : args)\n+        | isSingleConType recordTyCon = do\n+            record' <- convertType env record\n+            field' <- convertType env field\n+            withTmArg env (varV1, field') args $ \\x1 args ->\n+                withTmArg env (varV2, record') args $ \\x2 args ->\n+                    pure (ERecUpd (fromTCon record') (mkField $ fsToText name) x2 x1, args)\n+        -- TODO: Also fix evaluation order for sum-of-record types."
  },
  {
    "id" : "80be80d6-df4f-4162-8146-c6fc2ee270f4",
    "prId" : 5123,
    "comments" : [
      {
        "id" : "97f9e682-9875-41a9-8423-12302674a8f1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What changed here?",
        "createdAt" : "2020-03-22T14:58:40Z",
        "updatedAt" : "2020-03-22T16:01:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "aff65a83-7df2-4f1a-976e-57cb294293af",
        "parentId" : "97f9e682-9875-41a9-8423-12302674a8f1",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "It no longer exports a function called `for`.",
        "createdAt" : "2020-03-22T15:08:23Z",
        "updatedAt" : "2020-03-22T16:01:39Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ef219f1763d7684a1ed673985f1f6409a04531a8",
    "line" : 4,
    "diffHunk" : "@@ -99,7 +99,7 @@ import           Data.Data hiding (TyCon)\n import qualified Data.Decimal as Decimal\n import           Data.Foldable (foldlM)\n import           Data.Int\n-import           Data.List.Extra hiding (for)"
  },
  {
    "id" : "3b562a4b-ea1b-48a7-a9ea-00c4ce0a2121",
    "prId" : 4552,
    "comments" : [
      {
        "id" : "b04bc728-6f2b-4c17-a22b-1e58751f650e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There's a bit of code shared between the handling of `>>=` and `>>`. I'll do a slight refactoring in a separate PR if you think that would improve the situation.",
        "createdAt" : "2020-02-17T16:39:00Z",
        "updatedAt" : "2020-02-18T13:22:23Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e65fd8da34470a622c7f2e0a13f72ab5e3079ff7",
    "line" : 28,
    "diffHunk" : "@@ -886,19 +886,20 @@ convertExpr env0 e = do\n               y' <- convertExpr env y\n               b' <- convVarWithType env b\n               pure (inj (bind (Binding b' x') y'))\n-    go env semi@(VarIn DA_Internal_Prelude \">>\") allArgs@(LType monad : LType t : LType _ : LExpr _dict : LExpr x : LExpr y : args) = do\n+    go env semi@(VarIn DA_Internal_Prelude \">>\") (LType monad : LType t1 : LType t2 : LExpr dict : LExpr x : LExpr y : args) = fmap (, args) $ do\n         monad' <- convertType env monad\n+        dict' <- convertExpr env dict\n+        t1' <- convertType env t1\n+        t2' <- convertType env t2\n+        x' <- convertExpr env x\n+        y' <- convertExpr env y\n         case monad' of\n-          TBuiltin BTUpdate -> mkSeq EUpdate UBind\n-          TBuiltin BTScenario -> mkSeq EScenario SBind\n-          _ -> fmap (, allArgs) $ convertExpr env semi\n-        where\n-          mkSeq :: (m -> LF.Expr) -> (Binding -> LF.Expr -> m) -> ConvertM (LF.Expr, [LArg Var])\n-          mkSeq inj bind = fmap (, args) $ do\n-              t' <- convertType env t\n-              x' <- convertExpr env x\n-              y' <- convertExpr env y\n-              pure $ inj (bind (Binding (mkVar \"_\", t') x') y')\n+          TBuiltin BTUpdate -> pure $ EUpdate (UBind (Binding (mkVar \"_\", t1') x') y')\n+          TBuiltin BTScenario -> pure $ EScenario (SBind (Binding (mkVar \"_\", t1') x') y')\n+          _ -> do\n+            EVal semi' <- convertExpr env semi\n+            let bind' = EVal semi'{qualObject = mkVal \">>=\"}\n+            pure $ mkEApps bind' [TyArg monad', TmArg dict', TyArg t1', TyArg t2', TmArg x', TmArg (ETmLam (mkVar \"_\", t1') y')]"
  },
  {
    "id" : "fe9cce86-abea-401c-a1ab-337d4f7b9295",
    "prId" : 4552,
    "comments" : [
      {
        "id" : "3729b089-c0d6-43a6-92ab-29828b8910ad",
        "parentId" : null,
        "author" : null,
        "body" : "Worried about the future possibility that `>>` and `>>=` will move to different modules, and this will be hard to debug. But the tests should catch this at least.",
        "createdAt" : "2020-02-18T10:48:20Z",
        "updatedAt" : "2020-02-18T13:22:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "e65fd8da34470a622c7f2e0a13f72ab5e3079ff7",
    "line" : 27,
    "diffHunk" : "@@ -886,19 +886,20 @@ convertExpr env0 e = do\n               y' <- convertExpr env y\n               b' <- convVarWithType env b\n               pure (inj (bind (Binding b' x') y'))\n-    go env semi@(VarIn DA_Internal_Prelude \">>\") allArgs@(LType monad : LType t : LType _ : LExpr _dict : LExpr x : LExpr y : args) = do\n+    go env semi@(VarIn DA_Internal_Prelude \">>\") (LType monad : LType t1 : LType t2 : LExpr dict : LExpr x : LExpr y : args) = fmap (, args) $ do\n         monad' <- convertType env monad\n+        dict' <- convertExpr env dict\n+        t1' <- convertType env t1\n+        t2' <- convertType env t2\n+        x' <- convertExpr env x\n+        y' <- convertExpr env y\n         case monad' of\n-          TBuiltin BTUpdate -> mkSeq EUpdate UBind\n-          TBuiltin BTScenario -> mkSeq EScenario SBind\n-          _ -> fmap (, allArgs) $ convertExpr env semi\n-        where\n-          mkSeq :: (m -> LF.Expr) -> (Binding -> LF.Expr -> m) -> ConvertM (LF.Expr, [LArg Var])\n-          mkSeq inj bind = fmap (, args) $ do\n-              t' <- convertType env t\n-              x' <- convertExpr env x\n-              y' <- convertExpr env y\n-              pure $ inj (bind (Binding (mkVar \"_\", t') x') y')\n+          TBuiltin BTUpdate -> pure $ EUpdate (UBind (Binding (mkVar \"_\", t1') x') y')\n+          TBuiltin BTScenario -> pure $ EScenario (SBind (Binding (mkVar \"_\", t1') x') y')\n+          _ -> do\n+            EVal semi' <- convertExpr env semi\n+            let bind' = EVal semi'{qualObject = mkVal \">>=\"}"
  },
  {
    "id" : "4b500b0e-8f85-4f93-9757-57664b8d855c",
    "prId" : 4474,
    "comments" : [
      {
        "id" : "9bf1151f-4aa5-4cce-a36a-b3bef9c5de0b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is that really what we want? Don't we only get into this situation when the type does not actually matter? Can we get here with kinds other than star?",
        "createdAt" : "2020-02-11T21:28:40Z",
        "updatedAt" : "2020-02-11T21:57:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "19e99064-12bd-445c-8118-c09f0f78fa59",
        "parentId" : "9bf1151f-4aa5-4cce-a36a-b3bef9c5de0b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I thought about this for a bit and while I’m not entirely clear on this I think `Erased` does make sense for 2 reasons:\r\n\r\n1. The motivation for `Erased` is to avoid trying to reconstruct stuff that we cannot reconstruct. If I see a `TUnit` coming from `Any` in a definition somewhere in DAML-LF, I’m pretty sure I do not want to translate this to a DAML definition that accepts `()`.\r\n2. We never actually have values of type `Any` (there is no case in the LF conversion that would translate them to `EUnit` and that would also go horribly wrong) so an uninhabited type matches this.\r\n\r\nI’ve added a comment.",
        "createdAt" : "2020-02-11T21:58:07Z",
        "updatedAt" : "2020-02-11T21:58:07Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9ada9a757fbb117d5c645e777b7623f8be5b1cd5",
    "line" : null,
    "diffHunk" : "@@ -1510,10 +1518,9 @@ convertType env = go env\n             pure TText\n         | NameIn DA_Generics n <- t\n         , n `elementOfUniqSet` metadataTys\n-        , [_] <- ts =\n-            pure TUnit\n+        , [_] <- ts = erasedTy env\n         | t == anyTyCon, [_] <- ts =\n-            pure TUnit -- used for type-zonking\n+            erasedTy env -- used for type-zonking"
  },
  {
    "id" : "831f00df-a27f-41e4-b677-150efb4fbf69",
    "prId" : 4037,
    "comments" : [
      {
        "id" : "3baec490-4cfd-432c-868c-35ebbfb7037a",
        "parentId" : null,
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Why does `rewriteStableQualified` have to handle the case of the version-id being present?",
        "createdAt" : "2020-01-14T10:05:55Z",
        "updatedAt" : "2020-01-14T10:58:45Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d85e9cf7-67a0-41b6-92b1-6fd468a5a840",
        "parentId" : "3baec490-4cfd-432c-868c-35ebbfb7037a",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The unit id of the actual stdlib is `daml-stdlib-$SDK_VERSION`. The stable package is stored at key `(\"daml-stdlib\", modName)` so when we do a lookup to figure out if we have a module that we need to translate, we need to strip the version. The alternative would be that we store it at key `(\"daml-stdlib-$SDK-VERSION\", modName)` (which is what we did before this PR) and which removes the need to strip  the version here but then we have to strip the version when writing the LF package and we have to keep the code that adds the version when building up the map.\r\n\r\nSo the solution in this PR only requires stripping the version in one place instead of having to add it in one place only to strip it in another place.",
        "createdAt" : "2020-01-14T10:12:00Z",
        "updatedAt" : "2020-01-14T10:58:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0eff8944-7ca0-4f0c-a2f2-e9b95956a688",
        "parentId" : "3baec490-4cfd-432c-868c-35ebbfb7037a",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "ended up doing it the other way around after all since I forgot that `discardInternalModules` also needs changing so either way, we need to change two places.",
        "createdAt" : "2020-01-14T10:59:09Z",
        "updatedAt" : "2020-01-14T10:59:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "42a1d537a4bf7c1eb5782895df9625e7f82c9331",
    "line" : null,
    "diffHunk" : "@@ -1446,9 +1446,13 @@ rewriteStableQualified env q@(Qualified pkgRef modName obj) =\n             PRImport pkgId ->\n                 -- TODO We probably want to replace this my a more efficient lookup at some point\n                 fmap fst $ find (\\(_, dalfPkg) -> dalfPackageId dalfPkg == pkgId) $ MS.toList $ envPkgMap env\n-    in case (\\unitId -> MS.lookup (unitId, modName) (envStablePackages env)) =<< mbUnitId of\n+    in case (\\unitId -> MS.lookup (stripStdlibVersion unitId, modName) (envStablePackages env)) =<< mbUnitId of"
  },
  {
    "id" : "f5a86134-1792-43a7-bfff-ac6f2f2f9e3e",
    "prId" : 4030,
    "comments" : [
      {
        "id" : "38641e02-b1d1-4008-aa5f-5513d328824c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This looks a bit weird. Why do we want this in CPS-style instead of having something like `getDFun` (or maybe `getTypeClassDict` because I can never remember what a `DFun` is) and then simply applying the function at the call site ```getTypeClassDict env fSignatory `ETmApp` EVar this``` doesn’t look worse than ```makeDesugarDFunProjection env fSignatory (`ETmApp` EVar this)``` imho.",
        "createdAt" : "2020-01-14T14:59:01Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0d3c5f52-d48b-4205-9914-19d1c2affa70",
        "parentId" : "38641e02-b1d1-4008-aa5f-5513d328824c",
        "author" : null,
        "body" : "that would be ideal, but there's an extra conversion step in there that messes that up :-/",
        "createdAt" : "2020-01-14T15:11:06Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "87aaa1e2-0a56-459b-97f9-7545573277e0",
        "parentId" : "38641e02-b1d1-4008-aa5f-5513d328824c",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m not following, why does `getTypeClassDict env (Cast ghcExpr _) = convertExpr env ghcExpr` not do the trick?",
        "createdAt" : "2020-01-14T15:17:20Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cacbafab-a030-4992-9c1a-77a74de92698",
        "parentId" : "38641e02-b1d1-4008-aa5f-5513d328824c",
        "author" : null,
        "body" : "this is the part that doesn't typecheck:\r\n\r\n```Haskell\r\ngetTypeClassDict env fSignatory `ETmApp` EVar this\r\n```",
        "createdAt" : "2020-01-14T15:32:21Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3a6d332937a2569a52ae38499c6fe1022c9fe04c",
    "line" : null,
    "diffHunk" : "@@ -530,255 +536,102 @@ this = mkVar \"this\"\n self = mkVar \"self\"\n arg = mkVar \"arg\"\n res = mkVar \"res\"\n-proxyVar :: TypeVarName\n-proxyVar = mkTypeVar \"proxy\"\n-mkProxy :: LF.Type -> LF.Type\n-mkProxy = TApp (TVar proxyVar)\n+\n+convertTemplateDefs :: Env -> ConvertM [Definition]\n+convertTemplateDefs env =\n+    forM (MS.toList (envTemplateBinds env)) $ \\(tname, tbinds) ->\n+        DTemplate <$> convertTemplate env tname tbinds\n+\n+convertTemplate :: Env -> LF.TypeConName -> TemplateBinds -> ConvertM Template\n+convertTemplate env tplTypeCon tbinds@TemplateBinds{..}\n+    | Just tplTyCon <- tbTyCon\n+    , Just fSignatory <- tbSignatory\n+    , Just fObserver <- tbObserver\n+    , Just fEnsure <- tbEnsure\n+    , Just fAgreement <- tbAgreement\n+    , tplLocation <- convNameLoc (GHC.tyConName tplTyCon)\n+    = withRange tplLocation $ do\n+        let tplParam = this\n+        tplSignatories <- makeDesugarDFunProjection env fSignatory (`ETmApp` EVar this)\n+        tplObservers <- makeDesugarDFunProjection env fObserver (`ETmApp` EVar this)\n+        tplPrecondition <- makeDesugarDFunProjection env fEnsure (`ETmApp` EVar this)\n+        tplAgreement <- makeDesugarDFunProjection env fAgreement (`ETmApp` EVar this)\n+        tplChoices <- convertChoices env tplTypeCon tbinds\n+        tplKey <- convertTemplateKey env tplTypeCon tbinds\n+        pure Template {..}\n+\n+    | otherwise =\n+        unhandled \"Missing required instances in template definition.\" (show tplTypeCon)\n+\n+convertTemplateKey :: Env -> LF.TypeConName -> TemplateBinds -> ConvertM (Maybe TemplateKey)\n+convertTemplateKey env tname TemplateBinds{..}\n+    | Just keyTy <- tbKeyType\n+    , Just fKey <- tbKey\n+    , Just fMaintainer <- tbMaintainer\n+    = do\n+        let qtname = Qualified PRSelf (envLFModuleName env) tname\n+        tplKeyType <- convertType env keyTy\n+        tplKeyBody <- makeDesugarDFunProjection env fKey (`ETmApp` EVar this)\n+        tplKeyMaintainers <- makeDesugarDFunProjection env fMaintainer $ \\f ->\n+            f `ETyApp` TBuiltin BTList `ETmApp` ENil (TCon qtname)\n+        pure $ Just TemplateKey {..}\n+\n+    | otherwise\n+    = pure Nothing\n+\n+makeDesugarDFunProjection :: Env -> GHC.Expr Var -> (LF.Expr -> t) -> ConvertM t"
  },
  {
    "id" : "35b49a06-738d-4aa6-944f-b45854673fe8",
    "prId" : 4030,
    "comments" : [
      {
        "id" : "076cafb2-930e-4070-a8a5-321a753009b1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I guess this is no longer necessary since we don’t have any default implementations?",
        "createdAt" : "2020-01-14T15:01:17Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "534facda-9dad-48ae-bbf0-8a97234911d8",
        "parentId" : "076cafb2-930e-4070-a8a5-321a753009b1",
        "author" : null,
        "body" : "Right, and we don't want to filter out the `$c` methods either. We don't actually want templates to be special in any way with respect to GHC's & damlc's handling of typeclasses.",
        "createdAt" : "2020-01-14T15:18:48Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "3a6d332937a2569a52ae38499c6fe1022c9fe04c",
    "line" : 445,
    "diffHunk" : "@@ -530,255 +536,102 @@ this = mkVar \"this\"\n self = mkVar \"self\"\n arg = mkVar \"arg\"\n res = mkVar \"res\"\n-proxyVar :: TypeVarName\n-proxyVar = mkTypeVar \"proxy\"\n-mkProxy :: LF.Type -> LF.Type\n-mkProxy = TApp (TVar proxyVar)\n+\n+convertTemplateDefs :: Env -> ConvertM [Definition]\n+convertTemplateDefs env =\n+    forM (MS.toList (envTemplateBinds env)) $ \\(tname, tbinds) ->\n+        DTemplate <$> convertTemplate env tname tbinds\n+\n+convertTemplate :: Env -> LF.TypeConName -> TemplateBinds -> ConvertM Template\n+convertTemplate env tplTypeCon tbinds@TemplateBinds{..}\n+    | Just tplTyCon <- tbTyCon\n+    , Just fSignatory <- tbSignatory\n+    , Just fObserver <- tbObserver\n+    , Just fEnsure <- tbEnsure\n+    , Just fAgreement <- tbAgreement\n+    , tplLocation <- convNameLoc (GHC.tyConName tplTyCon)\n+    = withRange tplLocation $ do\n+        let tplParam = this\n+        tplSignatories <- makeDesugarDFunProjection env fSignatory (`ETmApp` EVar this)\n+        tplObservers <- makeDesugarDFunProjection env fObserver (`ETmApp` EVar this)\n+        tplPrecondition <- makeDesugarDFunProjection env fEnsure (`ETmApp` EVar this)\n+        tplAgreement <- makeDesugarDFunProjection env fAgreement (`ETmApp` EVar this)\n+        tplChoices <- convertChoices env tplTypeCon tbinds\n+        tplKey <- convertTemplateKey env tplTypeCon tbinds\n+        pure Template {..}\n+\n+    | otherwise =\n+        unhandled \"Missing required instances in template definition.\" (show tplTypeCon)\n+\n+convertTemplateKey :: Env -> LF.TypeConName -> TemplateBinds -> ConvertM (Maybe TemplateKey)\n+convertTemplateKey env tname TemplateBinds{..}\n+    | Just keyTy <- tbKeyType\n+    , Just fKey <- tbKey\n+    , Just fMaintainer <- tbMaintainer\n+    = do\n+        let qtname = Qualified PRSelf (envLFModuleName env) tname\n+        tplKeyType <- convertType env keyTy\n+        tplKeyBody <- makeDesugarDFunProjection env fKey (`ETmApp` EVar this)\n+        tplKeyMaintainers <- makeDesugarDFunProjection env fMaintainer $ \\f ->\n+            f `ETyApp` TBuiltin BTList `ETmApp` ENil (TCon qtname)\n+        pure $ Just TemplateKey {..}\n+\n+    | otherwise\n+    = pure Nothing\n+\n+makeDesugarDFunProjection :: Env -> GHC.Expr Var -> (LF.Expr -> t) -> ConvertM t\n+makeDesugarDFunProjection env (Cast ghcExpr _) f = do\n+    lfExpr <- convertExpr env ghcExpr\n+    pure (f lfExpr)\n+\n+convertChoices :: Env -> LF.TypeConName -> TemplateBinds -> ConvertM (NM.NameMap TemplateChoice)\n+convertChoices env tplTypeCon tbinds =\n+    NM.fromList <$> traverse (convertChoice env tbinds)\n+        (MS.findWithDefault [] tplTypeCon (envChoiceData env))\n+\n+convertChoice :: Env -> TemplateBinds -> ChoiceData -> ConvertM TemplateChoice\n+convertChoice env tbinds (ChoiceData ty expr)\n+    | Just fArchive <- tbArchive tbinds = do\n+    TConApp _ [_, _ :-> _ :-> choiceTy@(TConApp choiceTyCon _) :-> TUpdate choiceRetTy, consumingTy] <- convertType env ty\n+    let choiceName = ChoiceName (T.intercalate \".\" $ unTypeConName $ qualObject choiceTyCon)\n+    ERecCon _ [(_, controllers), (_, action), _] <- convertExpr env expr\n+    consuming <- case consumingTy of\n+        TConApp (Qualified { qualObject = TypeConName con }) _\n+            | con == [\"NonConsuming\"] -> pure NonConsuming\n+            | con == [\"PreConsuming\"] -> pure PreConsuming\n+            | con == [\"PostConsuming\"] -> pure PostConsuming\n+        _ -> unhandled \"choice consumption type\" (show consumingTy)\n+    let update = action `ETmApp` EVar self `ETmApp` EVar this `ETmApp` EVar arg\n+    archiveSelf <- makeDesugarDFunProjection env fArchive (`ETmApp` EVar self)\n+    update <- pure $ if consuming /= PostConsuming\n+        then update\n+        else EUpdate $ UBind (Binding (res, choiceRetTy) update) $\n+            EUpdate $ UBind (Binding (mkVar \"_\", TUnit) archiveSelf) $\n+            EUpdate $ UPure choiceRetTy $ EVar res\n+\n+    pure TemplateChoice\n+        { chcLocation = Nothing\n+        , chcName = choiceName\n+        , chcConsuming = consuming == PreConsuming\n+        , chcControllers = controllers `ETmApp` EVar this `ETmApp` EVar (arg)\n+        , chcSelfBinder = self\n+        , chcArgBinder = (arg, choiceTy)\n+        , chcReturnType = choiceRetTy\n+        , chcUpdate = update\n+        }\n+\n \n convertBind :: Env -> (Var, GHC.Expr Var) -> ConvertM [Definition]\n convertBind env (name, x)\n-    | \"$fTemplateKey\" `T.isPrefixOf` getOccText name\n-    , not (envIsGenerated env)\n-    , TypeCon classTyCon [tplTy, keyTy] <- varType name = withRange (convNameLoc name) $ do\n-      TCon classTyConLf <- convertTyCon env classTyCon\n-      tplTyLf@(TCon tplTyConLf) <- convertType env tplTy\n-      keyTyLf <- convertType env keyTy\n-      ERecCon _\n-        ( (_, tplSuperDict)\n-        : (_, key)\n-        : _lookupByKey\n-        : _fetchByKey\n-        : (_, maintainer)\n-        : _toAnyContractKey\n-        : _fromAnyContractKey\n-        : []\n-        ) <- convertExpr env x\n-      tupleTyCon <- qDA_Types env $ mkTypeCon [\"Tuple2\"]\n-      let tupleType = TypeConApp tupleTyCon [TContractId tplTyLf, tplTyLf]\n-      let selfField = FieldName \"contractId\"\n-      let thisField = FieldName \"contract\"\n-      let retrieveByKey = RetrieveByKey tplTyConLf (EVar $ mkVar \"key\")\n-      let lookupByKey =\n-            ETmLam (mkVar \"key\", keyTyLf) $\n-            EUpdate $ ULookupByKey retrieveByKey\n-      let fetchByKey =\n-            ETmLam (mkVar \"key\", keyTyLf) $\n-            EUpdate $ UBind (Binding (res, TStruct [(selfField, TContractId tplTyLf), (thisField, tplTyLf)]) $ EUpdate $ UFetchByKey retrieveByKey) $\n-            EUpdate $ UPure (typeConAppToType tupleType) $ ERecCon tupleType\n-                [ (mkIndexedField 1, EStructProj selfField $ EVar res)\n-                , (mkIndexedField 2, EStructProj thisField $ EVar res)\n-                ]\n-      let toAnyContractKey =\n-            if envLfVersion env `supports` featureAnyType\n-              then\n-                ETyLam (proxyVar, KArrow KStar KStar) $\n-                  ETmLam\n-                    (mkVar \"_\", mkProxy tplTyLf) $\n-                    ETmLam (mkVar \"arg\", keyTyLf) $\n-                      EToAny keyTyLf (EVar $ mkVar \"arg\")\n-              else\n-                EBuiltin BEError `ETyApp`\n-                TForall (proxyVar, KArrow KStar KStar) (mkProxy tplTyLf :-> keyTyLf :-> TUnit) `ETmApp`\n-                EBuiltin (BEText \"toAnyContractKey is not supported in this DAML-LF version\")\n-      let fromAnyContractKey =\n-            if envLfVersion env `supports` featureAnyType\n-              then\n-                ETyLam (proxyVar, KArrow KStar KStar) $\n-                  ETmLam\n-                    (mkVar \"_\", mkProxy tplTyLf) $\n-                    ETmLam (mkVar \"any\", TAny) $\n-                      EFromAny keyTyLf (EVar $ mkVar \"any\")\n-              else EBuiltin BEError `ETyApp`\n-                   TForall (proxyVar, KArrow KStar KStar) (mkProxy tplTyLf :-> TUnit :-> TOptional keyTyLf) `ETmApp`\n-                   EBuiltin (BEText \"fromAnyContractKey is not supported in this DAML-LF version\")\n-      let dict = ERecCon (TypeConApp classTyConLf [tplTyLf, keyTyLf]) $\n-            map (second (ETmLam (mkVar \"_\", TUnit))) $\n-              [ (mkIndexedField 1, tplSuperDict)\n-              , (mkIndexedField 2, key)\n-              , (mkIndexedField 3, lookupByKey)\n-              , (mkIndexedField 4, fetchByKey)\n-              , (mkIndexedField 5, maintainer)\n-              , (mkIndexedField 6, toAnyContractKey)\n-              , (mkIndexedField 7, fromAnyContractKey)\n-              ]\n-      name' <- convValWithType env name\n-      pure [defValue name name' dict]\n-    | \"$fTemplate\" `T.isPrefixOf` getOccText name\n-    , TypeCon classTyCon [tplTy@(TypeCon tplTyCon _)] <- varType name\n-    , not (envIsGenerated env)  = withRange (convNameLoc name) $ do\n-       TCon classTyConLf <- convertTyCon env classTyCon\n-       tplTyLf@(TCon tplTyConLf) <- convertType env tplTy\n-       ERecCon _\n-         ( (_, signatory)\n-         : (_, observer)\n-         : (_, ensure)\n-         : (_, agreement)\n-         : _create\n-         : _fetch\n-         : (_, archive)\n-         : _)\n-         <- convertExpr env x\n-       stdlibRef <- packageNameToPkgRef env damlStdlib\n-       let anyTemplateTy = anyTemplateTyFromStdlib env stdlibRef\n-       let templateTypeRepTy = templateTypeRepTyFromStdlib env stdlibRef\n-       let create = ETmLam (this, tplTyLf) $ EUpdate $ UCreate tplTyConLf (EVar (this))\n-       let fetch = ETmLam (this, TContractId tplTyLf) $ EUpdate $ UFetch tplTyConLf (EVar this)\n-       let toAnyTemplate =\n-             if envLfVersion env `supports` featureAnyType\n-                then ETmLam (this, tplTyLf) $ ERecCon anyTemplateTy [(anyTemplateField, EToAny tplTyLf (EVar (this)))]\n-                else EBuiltin BEError `ETyApp` (tplTyLf :-> typeConAppToType anyTemplateTy) `ETmApp` EBuiltin (BEText \"toAnyTemplate is not supported in this DAML-LF version\")\n-       let fromAnyTemplate =\n-             if envLfVersion env `supports` featureAnyType\n-               then ETmLam\n-                 (mkVar \"any\", typeConAppToType anyTemplateTy) $\n-                 EFromAny tplTyLf (ERecProj anyTemplateTy anyTemplateField (EVar $ mkVar \"any\"))\n-               else EBuiltin BEError `ETyApp` (typeConAppToType anyTemplateTy :-> TOptional tplTyLf) `ETmApp` EBuiltin (BEText \"fromAnyTemplate is not supported in this DAML-LF version\")\n-       let templateTypeRep =\n-             ETyLam (proxyVar, KArrow KStar KStar) $\n-               if envLfVersion env `supports` featureTypeRep\n-                 then ETmLam\n-                   (mkVar \"_\", mkProxy tplTyLf) $\n-                   ERecCon templateTypeRepTy [(templateTypeRepField, ETypeRep tplTyLf)]\n-                 else EBuiltin BEError `ETyApp` (mkProxy tplTyLf :-> typeConAppToType templateTypeRepTy) `ETmApp` EBuiltin (BEText \"templateTypeRep is not supported in this DAML-LF version\")\n-       let dict = ERecCon (TypeConApp classTyConLf [tplTyLf]) $\n-             map (second (ETmLam (mkVar \"_\", TUnit)))\n-             [ (mkIndexedField 1, signatory)\n-             , (mkIndexedField 2, observer)\n-             , (mkIndexedField 3, ensure)\n-             , (mkIndexedField 4, agreement)\n-             , (mkIndexedField 5, create)\n-             , (mkIndexedField 6, fetch)\n-             , (mkIndexedField 7, archive)\n-             , (mkIndexedField 8, toAnyTemplate)\n-             , (mkIndexedField 9, fromAnyTemplate)\n-             , (mkIndexedField 10, templateTypeRep)\n-             ]\n-       let choiceData = MS.findWithDefault [] (qualObject tplTyConLf) (envChoiceData env)\n-       let convertChoice :: ChoiceData -> ConvertM TemplateChoice\n-           convertChoice (ChoiceData ty expr) = do\n-             TConApp _ [_, _ :-> _ :-> choiceTy@(TConApp choiceTyCon _) :-> TUpdate choiceRetTy, consumingTy] <- convertType env ty\n-             let choiceName = ChoiceName (T.intercalate \".\" $ unTypeConName $ qualObject choiceTyCon)\n-             ERecCon _ [(_, controllers), (_, action), _] <- convertExpr env expr\n-             consuming <- case consumingTy of\n-                 TConApp (Qualified { qualObject = TypeConName con }) _\n-                   | con == [\"NonConsuming\"] -> pure NonConsuming\n-                   | con == [\"PreConsuming\"] -> pure PreConsuming\n-                   | con == [\"PostConsuming\"] -> pure PostConsuming\n-                 _ -> unhandled \"choice consumption type\" (show consumingTy)\n-             let update = action `ETmApp` EVar self `ETmApp` EVar this ` ETmApp` EVar (arg)\n-             update <- pure $ if consuming /= PostConsuming\n-                 then update\n-                 else EUpdate $ UBind (Binding (res, choiceRetTy) update) $\n-                      EUpdate $ UBind (Binding (mkVar \"_\", TUnit) $ archive `ETmApp` EVar self) $\n-                      EUpdate $ UPure choiceRetTy $ EVar res\n-             pure TemplateChoice\n-               { chcLocation = Nothing\n-               , chcName = choiceName\n-               , chcConsuming = consuming == PreConsuming\n-               , chcControllers = controllers `ETmApp` EVar this `ETmApp` EVar (arg)\n-               , chcSelfBinder = self\n-               , chcArgBinder = (arg, choiceTy)\n-               , chcReturnType = choiceRetTy\n-               , chcUpdate = update\n-               }\n-       choices <- NM.fromList <$> traverse convertChoice choiceData\n-       key <- for (MS.lookup (qualObject tplTyConLf) (envTemplateKeyData env)) $ \\(TemplateKeyData keyTy keyDict) -> do\n-           keyTyLf <- convertType env keyTy\n-           (dictName, TConApp dictTy dictTyArgs) <- convValWithType env keyDict\n-           let dictTyConApp = TypeConApp dictTy dictTyArgs\n-           Just m <- pure $ nameModule_maybe $ varName keyDict\n-           qualDictName <- qualify env m dictName\n-           pure TemplateKey\n-             { tplKeyType = keyTyLf\n-             , tplKeyBody =\n-                 ERecProj dictTyConApp (mkIndexedField 2) (EVal qualDictName)\n-                 `ETmApp` EUnit\n-                 `ETmApp` EVar this\n-             , tplKeyMaintainers =\n-                 ERecProj dictTyConApp (mkIndexedField 5) (EVal qualDictName)\n-                 `ETmApp` EUnit\n-                 `ETyApp` TBuiltin BTList\n-                 `ETmApp` ENil tplTyLf\n-             }\n-       let template = Template\n-             { tplLocation = convNameLoc tplTyCon\n-             , tplTypeCon = qualObject tplTyConLf\n-             , tplParam = this\n-             , tplPrecondition = ensure `ETmApp` EVar this\n-             , tplSignatories = signatory `ETmApp` EVar this\n-             , tplObservers = observer `ETmApp` EVar this\n-             , tplAgreement = agreement `ETmApp` EVar this\n-             , tplChoices = choices\n-             , tplKey = key\n-             }\n-       name' <- convValWithType env name\n-       pure [defValue name name' dict, DTemplate template]\n-    | \"$fChoice\" `T.isPrefixOf` getOccText name\n-    , not (envIsGenerated env)\n-    , TypeCon tyCon [tplTy, choiceArgTy, choiceRetTy] <- varType name = withRange (convNameLoc name) $ do\n-          TConApp choiceTyLf _ <- convertTyCon env tyCon\n-          ERecCon _ [(_, tplSuperDict), _, _, _] <- convertExpr env x\n-          tplTyLf@(TCon tplTyConLf) <- convertType env tplTy\n-          choiceArgTyLf@(TConApp choiceTyCon _) <- convertType env choiceArgTy\n-          let choiceName = ChoiceName (T.intercalate \".\" $ unTypeConName $ qualObject choiceTyCon)\n-          choiceRetTyLf <- convertType env choiceRetTy\n-          let exercise =\n-                ETmLam (this, TContractId tplTyLf) $\n-                  ETmLam (arg, choiceArgTyLf) $\n-                    EUpdate $ UExercise\n-                      tplTyConLf\n-                      choiceName\n-                      (EVar this)\n-                      Nothing\n-                      (EVar arg)\n-          let toAnyChoice =\n-                if envLfVersion env `supports` featureAnyType\n-                  then\n-                    ETyLam (proxyVar, KArrow KStar KStar) $\n-                      ETmLam\n-                        (mkVar \"_\", mkProxy tplTyLf) $\n-                        ETmLam (mkVar \"arg\", choiceArgTyLf) $\n-                          EToAny choiceArgTyLf (EVar arg)\n-                  else EBuiltin BEError `ETyApp`\n-                       TForall (proxyVar, KArrow KStar KStar) (mkProxy tplTyLf :-> choiceArgTyLf :-> TUnit) `ETmApp`\n-                       EBuiltin (BEText \"toAnyChoice is not supported in this DAML-LF version\")\n-          let fromAnyChoice =\n-                if envLfVersion env `supports` featureAnyType\n-                  then\n-                    ETyLam (proxyVar, KArrow KStar KStar) $\n-                      ETmLam\n-                        (mkVar \"_\", mkProxy tplTyLf) $\n-                        ETmLam (mkVar \"any\", TAny) $\n-                          EFromAny choiceArgTyLf (EVar $ mkVar \"any\")\n-                  else EBuiltin BEError `ETyApp`\n-                         TForall (proxyVar, KArrow KStar KStar) (mkProxy tplTyLf :-> TUnit :-> TOptional choiceArgTyLf) `ETmApp`\n-                         EBuiltin (BEText \"fromAnyChoice is not supported in this DAML-LF version\")\n-          let dict = ERecCon (TypeConApp choiceTyLf [tplTyLf, choiceArgTyLf, choiceRetTyLf]) $\n-                map (second (ETmLam (mkVar \"_\", TUnit)))\n-                [ (mkIndexedField 1, tplSuperDict)\n-                , (mkIndexedField 2, exercise)\n-                , (mkIndexedField 3, toAnyChoice)\n-                , (mkIndexedField 4, fromAnyChoice)\n-                ]\n-          name' <- convValWithType env name\n-          pure [defValue name name' dict]\n     -- This is inlined in the choice in the template so we can just drop this.\n-    | \"_choice_\" `T.isPrefixOf` getOccText name = pure []\n+    | \"_choice_\" `T.isPrefixOf` getOccText name\n+    = pure []\n+\n+    -- Remove internal functions.\n     | Just internals <- lookupUFM internalFunctions (envGHCModuleName env)\n     , getOccFS name `elementOfUniqSet` internals\n     = pure []\n-    -- NOTE(MH): Desugaring `template X` will result in a type class"
  },
  {
    "id" : "adc5c7c1-6cf8-4396-a468-6439684f236c",
    "prId" : 4030,
    "comments" : [
      {
        "id" : "51d41c44-9b2b-4f9c-b316-589ca51a8bcc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This seems to be the only place where you don’t use a section in combination with `makeDesugarDFunProjection` but I don’t really understand why.",
        "createdAt" : "2020-01-14T15:04:18Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f6e168e7-989c-492c-8749-8183362ddc13",
        "parentId" : "51d41c44-9b2b-4f9c-b316-589ca51a8bcc",
        "author" : null,
        "body" : "It's awkward / doesn't really work, because there's two operators in there, `ETyApp` followed by `ETmApp`.",
        "createdAt" : "2020-01-14T15:26:23Z",
        "updatedAt" : "2020-01-15T14:32:49Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3a6d332937a2569a52ae38499c6fe1022c9fe04c",
    "line" : null,
    "diffHunk" : "@@ -492,255 +536,102 @@ this = mkVar \"this\"\n self = mkVar \"self\"\n arg = mkVar \"arg\"\n res = mkVar \"res\"\n-proxyVar :: TypeVarName\n-proxyVar = mkTypeVar \"proxy\"\n-mkProxy :: LF.Type -> LF.Type\n-mkProxy = TApp (TVar proxyVar)\n+\n+convertTemplateDefs :: Env -> ConvertM [Definition]\n+convertTemplateDefs env =\n+    forM (MS.toList (envTemplateBinds env)) $ \\(tname, tbinds) ->\n+        DTemplate <$> convertTemplate env tname tbinds\n+\n+convertTemplate :: Env -> LF.TypeConName -> TemplateBinds -> ConvertM Template\n+convertTemplate env tplTypeCon tbinds@TemplateBinds{..}\n+    | Just tplTyCon <- tbTyCon\n+    , Just fSignatory <- tbSignatory\n+    , Just fObserver <- tbObserver\n+    , Just fEnsure <- tbEnsure\n+    , Just fAgreement <- tbAgreement\n+    , tplLocation <- convNameLoc (GHC.tyConName tplTyCon)\n+    = withRange tplLocation $ do\n+        let tplParam = this\n+        tplSignatories <- makeDesugarDFunProjection env fSignatory (`ETmApp` EVar this)\n+        tplObservers <- makeDesugarDFunProjection env fObserver (`ETmApp` EVar this)\n+        tplPrecondition <- makeDesugarDFunProjection env fEnsure (`ETmApp` EVar this)\n+        tplAgreement <- makeDesugarDFunProjection env fAgreement (`ETmApp` EVar this)\n+        tplChoices <- convertChoices env tplTypeCon tbinds\n+        tplKey <- convertTemplateKey env tplTypeCon tbinds\n+        pure Template {..}\n+\n+    | otherwise =\n+        unhandled \"Missing required instances in template definition.\" (show tplTypeCon)\n+\n+convertTemplateKey :: Env -> LF.TypeConName -> TemplateBinds -> ConvertM (Maybe TemplateKey)\n+convertTemplateKey env tname TemplateBinds{..}\n+    | Just keyTy <- tbKeyType\n+    , Just fKey <- tbKey\n+    , Just fMaintainer <- tbMaintainer\n+    = do\n+        let qtname = Qualified PRSelf (envLFModuleName env) tname\n+        tplKeyType <- convertType env keyTy\n+        tplKeyBody <- makeDesugarDFunProjection env fKey (`ETmApp` EVar this)\n+        tplKeyMaintainers <- makeDesugarDFunProjection env fMaintainer $ \\f ->"
  },
  {
    "id" : "5cf32803-7f92-4080-b147-ddcb66a1bbc9",
    "prId" : 4023,
    "comments" : [
      {
        "id" : "6427494a-c725-4f74-86e6-fb3d5d73b7f4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n       ( templateKeyCon\r\n```",
        "createdAt" : "2020-01-13T13:49:11Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bde8b162-4186-410b-a27e-4ba265a51e68",
        "parentId" : "6427494a-c725-4f74-86e6-fb3d5d73b7f4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":fire: ",
        "createdAt" : "2020-01-13T13:53:41Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7756a58dadb0273a3e473dd5238baa88e5f39809",
    "line" : null,
    "diffHunk" : "@@ -505,16 +520,15 @@ convertBind env (name, x)\n       TCon classTyConLf <- convertTyCon env classTyCon\n       tplTyLf@(TCon tplTyConLf) <- convertType env tplTy\n       keyTyLf <- convertType env keyTy\n-      ERecCon _\n-        ( (_, tplSuperDict)\n-        : (_, key)\n-        : _lookupByKey\n-        : _fetchByKey\n-        : (_, maintainer)\n-        : _toAnyContractKey\n-        : _fromAnyContractKey\n-        : []\n-        ) <- convertExpr env x\n+      ( templateKeyCon"
  },
  {
    "id" : "69116a6f-813d-4a06-9c5a-a0b5519ee00a",
    "prId" : 4023,
    "comments" : [
      {
        "id" : "06b1af94-a6fd-474e-8a66-65e3854afd70",
        "parentId" : null,
        "author" : null,
        "body" : "IMO at this point we should split the handling of simple record types (these remain as `SimpleRecordCon`) and typeclass dictionaries (by adding a new `TypeClassDictCon` or something)",
        "createdAt" : "2020-01-17T16:28:04Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "7756a58dadb0273a3e473dd5238baa88e5f39809",
    "line" : 135,
    "diffHunk" : "@@ -1105,8 +1114,11 @@ convertDataCon env m con args\n                     [tmArg] -> pure tmArg\n                     _ -> unhandled \"constructor with more than two unnamed arguments\" xargs\n \n-            SimpleRecordCon ->"
  },
  {
    "id" : "c8c3fe1f-1142-4459-8a3f-b79fe736d346",
    "prId" : 4023,
    "comments" : [
      {
        "id" : "c7b30c63-b2d6-423e-9065-f58193c3929a",
        "parentId" : null,
        "author" : null,
        "body" : "Another suggestion I have is to move (almost) all of these ```envLfVersion env `supports` featureTypeSynonyms``` checks to a set of related utility functions, something like\r\n\r\n```Haskell\r\nmkDictProj :: Env -> TypeConApp -> FieldName -> LF.Expr -> LF.Expr\r\nmkDictProj env tcon fieldName\r\n  if envLFVersion env `supports` featureTypeSynonyms\r\n    then EStructProj fieldName\r\n    else ERecProj tcon fieldName\r\n \r\nmkDictCon :: Env -> TypeConApp -> [(String, LF.Expr)] -> Expr\r\nmkDictcon env tcon =\r\n  if envLFVersion env `supports` featureTypeSynonyms\r\n    then EStructCon\r\n    else ERecCon tcon   \r\n```\r\n\r\netc",
        "createdAt" : "2020-01-17T16:47:00Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7756a58dadb0273a3e473dd5238baa88e5f39809",
    "line" : null,
    "diffHunk" : "@@ -941,7 +948,9 @@ convertExpr env0 e = do\n             let fldIndex = fromJust (elemIndex x vs)\n             let fldName = fldNames !! fldIndex\n             recTyp <- convertType env (varType bind)\n-            pure $ ERecProj (fromTCon recTyp) fldName scrutinee' `ETmApp` EUnit\n+            if envLfVersion env `supports` featureTypeSynonyms"
  },
  {
    "id" : "0e4ff2a3-76b1-4ee5-a28d-93e9dfd59ec2",
    "prId" : 4023,
    "comments" : [
      {
        "id" : "33862378-e766-4fcb-a40b-60db5e903eb4",
        "parentId" : null,
        "author" : null,
        "body" : "I think you can replace this `if` expression by using the helper function,\r\n\r\n```Haskell\r\npure $ mkDictProj env (fromTCon recTyp) fldName scrutinee' `ETmApp` EUnit\r\n```",
        "createdAt" : "2020-01-24T08:30:49Z",
        "updatedAt" : "2020-01-24T08:42:32Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "639cd70e-5ccd-4975-8ff3-805246a5f40a",
        "parentId" : "33862378-e766-4fcb-a40b-60db5e903eb4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "good catch, fixed. Thank you!",
        "createdAt" : "2020-01-24T08:42:55Z",
        "updatedAt" : "2020-01-24T08:42:55Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7756a58dadb0273a3e473dd5238baa88e5f39809",
    "line" : null,
    "diffHunk" : "@@ -944,7 +971,9 @@ convertExpr env0 e = do\n             let fldIndex = fromJust (elemIndex x vs)\n             let fldName = fldNames !! fldIndex\n             recTyp <- convertType env (varType bind)\n-            pure $ ERecProj (fromTCon recTyp) fldName scrutinee' `ETmApp` EUnit\n+            if envLfVersion env `supports` featureTypeSynonyms\n+              then pure $ EStructProj fldName scrutinee' `ETmApp` EUnit\n+              else pure $ ERecProj (fromTCon recTyp) fldName scrutinee' `ETmApp` EUnit"
  },
  {
    "id" : "c1842b1b-fc42-42b5-8606-34ec4827c183",
    "prId" : 3973,
    "comments" : [
      {
        "id" : "9d642820-7a64-4c2a-aad0-055747ed61a4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we really need to add `Optional` to that list? It's a list of types defined in `DA.Internal.LF` whereas `Optional` is defined in `DA.Internal.Prelude`.",
        "createdAt" : "2020-01-08T12:49:45Z",
        "updatedAt" : "2020-01-08T12:49:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5bbf2d7d-e400-41e9-953e-7d60cc181402",
        "parentId" : "9d642820-7a64-4c2a-aad0-055747ed61a4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, that was leftover from when I tried to move it to `DA.Internal.LF`. Fixed in https://github.com/digital-asset/daml/pull/3981",
        "createdAt" : "2020-01-08T12:54:23Z",
        "updatedAt" : "2020-01-08T12:54:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "496f33167705e2653f7b3b2c2b6e8912a9e32853",
    "line" : 13,
    "diffHunk" : "@@ -778,7 +779,7 @@ convertBind env (name, x)\n -- during conversion to DAML-LF together with their constructors since we\n -- deliberately remove 'GHC.Types.Opaque' as well.\n internalTypes :: UniqSet FastString\n-internalTypes = mkUniqSet [\"Scenario\",\"Update\",\"ContractId\",\"Time\",\"Date\",\"Party\",\"Pair\", \"TextMap\", \"Map\", \"Any\", \"TypeRep\"]\n+internalTypes = mkUniqSet [\"Scenario\",\"Update\",\"ContractId\",\"Time\",\"Date\",\"Party\",\"Pair\", \"TextMap\", \"Map\", \"Any\", \"TypeRep\", \"Optional\"]"
  },
  {
    "id" : "e8587d69-5d0e-4af8-b611-815d988f7fa3",
    "prId" : 3702,
    "comments" : [
      {
        "id" : "c35fa9b8-1f7d-4a10-8928-9f02c63d0f57",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What is a range here?",
        "createdAt" : "2019-12-02T19:42:46Z",
        "updatedAt" : "2019-12-03T08:54:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "abace8cb-993d-45b8-83ed-0b3fc57be0f7",
        "parentId" : "c35fa9b8-1f7d-4a10-8928-9f02c63d0f57",
        "author" : null,
        "body" : "The set of values in the map (without the keys).",
        "createdAt" : "2019-12-03T07:18:55Z",
        "updatedAt" : "2019-12-03T08:54:12Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c58a4a35d1fbcd28a5f6c3f8ca6c66310383f151",
    "line" : null,
    "diffHunk" : "@@ -162,6 +163,8 @@ data Env = Env\n     ,envChoiceData :: MS.Map TypeConName [ChoiceData]\n     ,envTemplateKeyData :: MS.Map TypeConName TemplateKeyData\n     ,envIsGenerated :: Bool\n+    ,envTypeVars :: !(MS.Map Var TypeVarName)\n+    ,envTypeVarNames :: !(S.Set TypeVarName) -- cached range of envTypeVars"
  },
  {
    "id" : "e0cb4543-578c-47d7-b657-5f23b5369527",
    "prId" : 3702,
    "comments" : [
      {
        "id" : "47b41bf8-180e-4689-9ffa-a45bcfbb5c4f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It would be nice to document here what we are tracking in those two variables and why we need it.",
        "createdAt" : "2019-12-02T19:43:24Z",
        "updatedAt" : "2019-12-03T08:54:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c58a4a35d1fbcd28a5f6c3f8ca6c66310383f151",
    "line" : 12,
    "diffHunk" : "@@ -162,6 +163,8 @@ data Env = Env\n     ,envChoiceData :: MS.Map TypeConName [ChoiceData]\n     ,envTemplateKeyData :: MS.Map TypeConName TemplateKeyData\n     ,envIsGenerated :: Bool\n+    ,envTypeVars :: !(MS.Map Var TypeVarName)"
  },
  {
    "id" : "5626cfa7-2401-4720-92df-2005fa45334d",
    "prId" : 3702,
    "comments" : [
      {
        "id" : "855a49d6-a8dd-44e7-a6cf-39e85fea5ccb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        try !i name =\r\n```",
        "createdAt" : "2019-12-02T20:01:23Z",
        "updatedAt" : "2019-12-03T08:54:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eb6892c5-9c0b-4bbb-8dd3-566ff5f987bc",
        "parentId" : "855a49d6-a8dd-44e7-a6cf-39e85fea5ccb",
        "author" : null,
        "body" : "👍 ",
        "createdAt" : "2019-12-03T09:04:07Z",
        "updatedAt" : "2019-12-03T09:04:07Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c58a4a35d1fbcd28a5f6c3f8ca6c66310383f151",
    "line" : null,
    "diffHunk" : "@@ -181,6 +184,38 @@ envInsertAlias v x env = env{envAliases = MS.insert v x (envAliases env)}\n envLookupAlias :: Var -> Env -> Maybe LF.Expr\n envLookupAlias x = MS.lookup x . envAliases\n \n+-- | Bind a type var without shadowing its LF name.\n+envBindTypeVar :: Var -> Env -> (TypeVarName, Env)\n+envBindTypeVar x env = try 1 (TypeVarName prefix)\n+    where\n+        prefix = getOccText x\n+        nameFor i = TypeVarName (prefix <> T.pack (show i))\n+\n+        try :: Integer -> TypeVarName -> (TypeVarName, Env)\n+        try i name ="
  },
  {
    "id" : "2d1fe5b7-ea6a-4e9e-9c34-1e026315dee0",
    "prId" : 3702,
    "comments" : [
      {
        "id" : "1221ddff-a648-4bf1-87f6-159d36316536",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        try :: Int -> TypeVarName -> (TypeVarName, Env)\r\n```\r\nIf you get over 2^63-1 type variable collisions you probably have bigger problems :slightly_smiling_face: ",
        "createdAt" : "2019-12-02T20:03:17Z",
        "updatedAt" : "2019-12-03T08:54:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "aa1c9edd-3a16-4ecb-82c1-2e50e40901e4",
        "parentId" : "1221ddff-a648-4bf1-87f6-159d36316536",
        "author" : null,
        "body" : "👍 ",
        "createdAt" : "2019-12-03T07:19:20Z",
        "updatedAt" : "2019-12-03T08:54:12Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c58a4a35d1fbcd28a5f6c3f8ca6c66310383f151",
    "line" : null,
    "diffHunk" : "@@ -181,6 +184,38 @@ envInsertAlias v x env = env{envAliases = MS.insert v x (envAliases env)}\n envLookupAlias :: Var -> Env -> Maybe LF.Expr\n envLookupAlias x = MS.lookup x . envAliases\n \n+-- | Bind a type var without shadowing its LF name.\n+envBindTypeVar :: Var -> Env -> (TypeVarName, Env)\n+envBindTypeVar x env = try 1 (TypeVarName prefix)\n+    where\n+        prefix = getOccText x\n+        nameFor i = TypeVarName (prefix <> T.pack (show i))\n+\n+        try :: Integer -> TypeVarName -> (TypeVarName, Env)"
  },
  {
    "id" : "845bf80c-f502-41e9-9efc-3bfdef8fccd8",
    "prId" : 3696,
    "comments" : [
      {
        "id" : "6dd59c65-240a-4ef1-ad6e-8e17adcc7294",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Should we put the word \"stable\" in the name here to make it clear that we're only rewriting references to stable names?",
        "createdAt" : "2019-12-02T19:50:27Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e6a9366b-127a-4384-9744-48797bf9412e",
        "parentId" : "6dd59c65-240a-4ef1-ad6e-8e17adcc7294",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, renamed and added a comment.",
        "createdAt" : "2019-12-02T20:08:54Z",
        "updatedAt" : "2019-12-04T14:02:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72ee178dfa935c138612161f3bdfb610910e1412",
    "line" : null,
    "diffHunk" : "@@ -1369,19 +1377,31 @@ convertModuleName =\n qualify :: Env -> GHC.Module -> a -> ConvertM (Qualified a)\n qualify env m x = do\n     unitId <- convertUnitId (envModuleUnitId env) (envPkgMap env) $ GHC.moduleUnitId m\n-    pure $ Qualified unitId (convertModuleName $ GHC.moduleName m) x\n+    pure $ rewriteQualified env $ Qualified unitId (convertModuleName $ GHC.moduleName m) x\n \n qDA_Types :: Env -> a -> ConvertM (Qualified a)\n qDA_Types env a = do\n   pkgRef <- packageNameToPkgRef env \"daml-prim\"\n   pure $ Qualified pkgRef (mkModName [\"DA\", \"Types\"]) a\n \n+rewriteQualified :: Env -> Qualified a -> Qualified a"
  },
  {
    "id" : "40efabda-7c6d-42b6-b2dd-aff584a761d6",
    "prId" : 3670,
    "comments" : [
      {
        "id" : "19756969-2920-4c06-b07f-1a49c1141710",
        "parentId" : null,
        "author" : null,
        "body" : "these (and all the other examples) could be:\r\n\r\n```suggestion\r\n             [ (mkIndexedField 1, signatory)\r\n```",
        "createdAt" : "2019-11-29T09:03:37Z",
        "updatedAt" : "2019-11-29T13:04:50Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6fa7a821-d60c-430b-969b-e2b5ead00668",
        "parentId" : "19756969-2920-4c06-b07f-1a49c1141710",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thanks, fixed!",
        "createdAt" : "2019-11-29T09:32:42Z",
        "updatedAt" : "2019-11-29T13:04:50Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "abb363aad65b2173e41b6b0e0e9a16e83c6474a2",
    "line" : null,
    "diffHunk" : "@@ -653,13 +485,230 @@ convertTemplateInstanceDef env tname templateTyCon args = do\n \n convertBind :: Env -> (Var, GHC.Expr Var) -> ConvertM [Definition]\n convertBind env (name, x)\n-    | DFunId _ <- idDetails name\n-    , TypeCon (Is tplInst) _ <- varType name\n-    , \"Instance\" `T.isSuffixOf` fsToText tplInst\n-    = withRange (convNameLoc name) $ do\n-        (tmpl, dict) <- convertGenericTemplate env x\n-        name' <- convValWithType env name\n-        pure [DTemplate tmpl, defValue name name' dict]\n+    | \"$fTemplateKey\" `T.isPrefixOf` getOccText name\n+    , TypeCon classTyCon [tplTy, keyTy] <- varType name = withRange (convNameLoc name) $ do\n+      TCon classTyConLf <- convertTyCon env classTyCon\n+      tplTyLf@(TCon tplTyConLf) <- convertType env tplTy\n+      keyTyLf <- convertType env keyTy\n+      ERecCon _\n+        ( (_, tplSuperDict)\n+        : (_, key)\n+        : _lookupByKey\n+        : _fetchByKey\n+        : (_, maintainer)\n+        : _toAnyContractKey\n+        : _fromAnyContractKey\n+        : []\n+        ) <- convertExpr env x\n+      tupleTyCon <- qDA_Types env $ mkTypeCon [\"Tuple2\"]\n+      let tupleType = TypeConApp tupleTyCon [TContractId tplTyLf, tplTyLf]\n+      let selfField = FieldName \"contractId\"\n+      let thisField = FieldName \"contract\"\n+      let retrieveByKey = RetrieveByKey tplTyConLf (EVar $ mkVar \"key\")\n+      let lookupByKey =\n+            ETmLam (mkVar \"key\", keyTyLf) $\n+            EUpdate $ ULookupByKey retrieveByKey\n+      let fetchByKey =\n+            ETmLam (mkVar \"key\", keyTyLf) $\n+            EUpdate $ UBind (Binding (res, TStruct [(selfField, TContractId tplTyLf), (thisField, tplTyLf)]) $ EUpdate $ UFetchByKey retrieveByKey) $\n+            EUpdate $ UPure (typeConAppToType tupleType) $ ERecCon tupleType\n+                [ (FieldName \"_1\", EStructProj selfField $ EVar res)\n+                , (FieldName \"_2\", EStructProj thisField $ EVar res)\n+                ]\n+      let toAnyContractKey =\n+            if envLfVersion env `supports` featureAnyType\n+              then\n+                ETyLam (proxyVar, KArrow KStar KStar) $\n+                  ETmLam\n+                    (mkVar \"_\", mkProxy tplTyLf) $\n+                    ETmLam (mkVar \"arg\", keyTyLf) $\n+                      EToAny keyTyLf (EVar $ mkVar \"arg\")\n+              else\n+                EBuiltin BEError `ETyApp`\n+                TForall (proxyVar, KArrow KStar KStar) (mkProxy tplTyLf :-> keyTyLf :-> TUnit) `ETmApp`\n+                EBuiltin (BEText \"toAnyContractKey is not supported in this DAML-LF version\")\n+      let fromAnyContractKey =\n+            if envLfVersion env `supports` featureAnyType\n+              then\n+                ETyLam (proxyVar, KArrow KStar KStar) $\n+                  ETmLam\n+                    (mkVar \"_\", mkProxy tplTyLf) $\n+                    ETmLam (mkVar \"any\", TAny) $\n+                      EFromAny keyTyLf (EVar $ mkVar \"any\")\n+              else EBuiltin BEError `ETyApp`\n+                   TForall (proxyVar, KArrow KStar KStar) (mkProxy tplTyLf :-> TUnit :-> TOptional keyTyLf) `ETmApp`\n+                   EBuiltin (BEText \"fromAnyContractKey is not supported in this DAML-LF version\")\n+      let dict = ERecCon (TypeConApp classTyConLf [tplTyLf, keyTyLf]) $\n+            map (second (ETmLam (mkVar \"_\", TUnit))) $\n+              [ (FieldName \"_1\", tplSuperDict)\n+              , (FieldName \"_2\", key)\n+              , (FieldName \"_3\", lookupByKey)\n+              , (FieldName \"_4\", fetchByKey)\n+              , (FieldName \"_5\", maintainer)\n+              , (FieldName \"_6\", toAnyContractKey)\n+              , (FieldName \"_7\", fromAnyContractKey)\n+              ]\n+      name' <- convValWithType env name\n+      pure [defValue name name' dict]\n+    | \"$fTemplate\" `T.isPrefixOf` getOccText name\n+    , TypeCon classTyCon [tplTy@(TypeCon tplTyCon _)] <- varType name = withRange (convNameLoc name) $ do\n+       TCon classTyConLf <- convertTyCon env classTyCon\n+       tplTyLf@(TCon tplTyConLf) <- convertType env tplTy\n+       ERecCon _\n+         ( (_, signatory)\n+         : (_, observer)\n+         : (_, ensure)\n+         : (_, agreement)\n+         : _create\n+         : _fetch\n+         : (_, archive)\n+         : _)\n+         <- convertExpr env x\n+       stdlibRef <- packageNameToPkgRef env damlStdlib\n+       let anyTemplateTy = anyTemplateTyFromStdlib stdlibRef\n+       let templateTypeRepTy = templateTypeRepTyFromStdlib stdlibRef\n+       let create = ETmLam (this, tplTyLf) $ EUpdate $ UCreate tplTyConLf (EVar (this))\n+       let fetch = ETmLam (this, TContractId tplTyLf) $ EUpdate $ UFetch tplTyConLf (EVar this)\n+       let toAnyTemplate =\n+             if envLfVersion env `supports` featureAnyType\n+                then ETmLam (this, tplTyLf) $ ERecCon anyTemplateTy [(anyTemplateField, EToAny tplTyLf (EVar (this)))]\n+                else EBuiltin BEError `ETyApp` (tplTyLf :-> typeConAppToType anyTemplateTy) `ETmApp` EBuiltin (BEText \"toAnyTemplate is not supported in this DAML-LF version\")\n+       let fromAnyTemplate =\n+             if envLfVersion env `supports` featureAnyType\n+               then ETmLam\n+                 (mkVar \"any\", typeConAppToType anyTemplateTy) $\n+                 EFromAny tplTyLf (ERecProj anyTemplateTy anyTemplateField (EVar $ mkVar \"any\"))\n+               else EBuiltin BEError `ETyApp` (typeConAppToType anyTemplateTy :-> TOptional tplTyLf) `ETmApp` EBuiltin (BEText \"fromAnyTemplate is not supported in this DAML-LF version\")\n+       let templateTypeRep =\n+             ETyLam (proxyVar, KArrow KStar KStar) $\n+               if envLfVersion env `supports` featureTypeRep\n+                 then ETmLam\n+                   (mkVar \"_\", mkProxy tplTyLf) $\n+                   ERecCon templateTypeRepTy [(templateTypeRepField, ETypeRep tplTyLf)]\n+                 else EBuiltin BEError `ETyApp` (mkProxy tplTyLf :-> typeConAppToType templateTypeRepTy) `ETmApp` EBuiltin (BEText \"templateTypeRep is not supported in this DAML-LF version\")\n+       let dict = ERecCon (TypeConApp classTyConLf [tplTyLf]) $\n+             map (second (ETmLam (mkVar \"_\", TUnit)))\n+             [ (FieldName \"_1\", signatory)"
  },
  {
    "id" : "1898d22e-8117-46ee-a50a-71ed262c40ab",
    "prId" : 3667,
    "comments" : [
      {
        "id" : "c2ec731b-7dde-4660-8583-18063fbee1ab",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    -- | Constraint tuple projections are turned into LF struct projections at use site.\r\n```",
        "createdAt" : "2019-11-28T16:11:34Z",
        "updatedAt" : "2019-11-28T16:35:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e7e947c49297bdbff942b9e807224650ca4f775",
    "line" : null,
    "diffHunk" : "@@ -685,6 +689,11 @@ convertBind env (name, x)\n     -- lifter or DAML-LF supports local recursion.\n     | (as, Let (Rec [(f, Lam v y)]) (Var f')) <- collectBinders x, f == f'\n     = convertBind env $ (,) name $ mkLams as $ Lam v $ Let (NonRec f $ mkVarApps (Var name) as) y\n+\n+    -- | Constraint tuple projections are turned into LF strict projections at use site."
  },
  {
    "id" : "f0dd9496-ddbe-49e0-b6db-16c69203d7b5",
    "prId" : 3667,
    "comments" : [
      {
        "id" : "450ca707-eb1d-4dcb-8377-b00ef7687b5e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    go env (ConstraintTupleProjection index arity) args | (LExpr x : args') <- drop arity args =\r\n```",
        "createdAt" : "2019-11-28T16:12:47Z",
        "updatedAt" : "2019-11-28T16:35:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e7e947c49297bdbff942b9e807224650ca4f775",
    "line" : null,
    "diffHunk" : "@@ -802,6 +811,12 @@ convertExpr env0 e = do\n         t2' <- convertType env t2\n         pure (x' `ETyApp` t1' `ETyApp` t2' `ETmApp` EBuiltin (BEText (unpackCStringUtf8 s)))\n \n+    go env (ConstraintTupleProjection i j) args | (LExpr x : args') <- drop j args ="
  },
  {
    "id" : "7a544ae9-4037-40d3-ab1a-dcdc9d383e79",
    "prId" : 3667,
    "comments" : [
      {
        "id" : "d30639df-2c4b-44e4-a4cf-fc41529b6b82",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Should we factor out the naming scheme used for this fields so that we can make sure that this conversion and the definition of the struct type agree?",
        "createdAt" : "2019-11-28T16:17:24Z",
        "updatedAt" : "2019-11-28T16:35:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "25721a1e-02d7-4c41-b7c0-18a7cbdfc1b7",
        "parentId" : "d30639df-2c4b-44e4-a4cf-fc41529b6b82",
        "author" : null,
        "body" : "That sounds good. It shows up in a few more places as well, so I made it a utility function.",
        "createdAt" : "2019-11-28T16:35:06Z",
        "updatedAt" : "2019-11-28T16:35:51Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e7e947c49297bdbff942b9e807224650ca4f775",
    "line" : null,
    "diffHunk" : "@@ -802,6 +811,12 @@ convertExpr env0 e = do\n         t2' <- convertType env t2\n         pure (x' `ETyApp` t1' `ETyApp` t2' `ETmApp` EBuiltin (BEText (unpackCStringUtf8 s)))\n \n+    go env (ConstraintTupleProjection i j) args | (LExpr x : args') <- drop j args =\n+        fmap (, args') $ do\n+            let fieldName = mkField (\"_\" <> T.pack (show i))"
  },
  {
    "id" : "eebbdd9e-0044-414b-9a6e-5f8ae2a2e4f2",
    "prId" : 3667,
    "comments" : [
      {
        "id" : "601036be-ef9e-4b41-a70f-97a3f1c73abd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Are the `arity` arguments that we drop the types? If so, it would be good to add a comment since I had to spend 5 minutes staring at this to figure it out :slightly_smiling_face: ",
        "createdAt" : "2019-11-28T16:22:11Z",
        "updatedAt" : "2019-11-28T16:35:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8d87951c-a327-420c-b9f0-3bfb83a0635b",
        "parentId" : "601036be-ef9e-4b41-a70f-97a3f1c73abd",
        "author" : null,
        "body" : "Yes, will do!",
        "createdAt" : "2019-11-28T16:25:38Z",
        "updatedAt" : "2019-11-28T16:35:51Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e7e947c49297bdbff942b9e807224650ca4f775",
    "line" : null,
    "diffHunk" : "@@ -802,6 +811,12 @@ convertExpr env0 e = do\n         t2' <- convertType env t2\n         pure (x' `ETyApp` t1' `ETyApp` t2' `ETmApp` EBuiltin (BEText (unpackCStringUtf8 s)))\n \n+    go env (ConstraintTupleProjection i j) args | (LExpr x : args') <- drop j args ="
  },
  {
    "id" : "83cfcf9f-7927-4990-830e-b7bb024c1dfc",
    "prId" : 3541,
    "comments" : [
      {
        "id" : "9e2b6765-ed13-4a6c-9107-321e530545d2",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Why is this `TUnit`?",
        "createdAt" : "2019-11-20T08:37:24Z",
        "updatedAt" : "2019-11-20T09:34:16Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2ae42b8b-281a-4bff-846a-67e6b21c84b6",
        "parentId" : "9e2b6765-ed13-4a6c-9107-321e530545d2",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Because we translate `TAny` to `TUnit` for DAML-LF versions that don’t support `Any` and this now uses `Any` directly.",
        "createdAt" : "2019-11-20T08:42:59Z",
        "updatedAt" : "2019-11-20T09:34:16Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "63489026-96b9-4ae0-a0c0-fa21b821474d",
        "parentId" : "9e2b6765-ed13-4a6c-9107-321e530545d2",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Ah, got it. Thanks for explaining!",
        "createdAt" : "2019-11-20T08:54:26Z",
        "updatedAt" : "2019-11-20T09:34:16Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e4d320e108de235fc3db045fb1ce33afd8c40cba",
    "line" : 17,
    "diffHunk" : "@@ -379,19 +377,19 @@ convertGenericTemplate env x\n                                          (mkTypeVar \"proxy\", KArrow KStar KStar)\n                                          (ETmLam\n                                             (mkVar \"_\", TApp (TVar $ mkTypeVar \"proxy\") polyType)\n-                                            (ETmLam (mkVar \"key\", keyType) $ ERecCon anyContractKeyTy [(anyContractKeyField, EToAny keyType $ EVar $ mkVar \"key\")]))\n+                                            (ETmLam (mkVar \"key\", keyType) $ EToAny keyType $ EVar $ mkVar \"key\"))\n                                   else EBuiltin BEError `ETyApp`\n-                                       TForall (mkTypeVar \"proxy\", KArrow KStar KStar) (TApp (TVar $ mkTypeVar \"proxy\") polyType :-> keyType :-> typeConAppToType anyContractKeyTy) `ETmApp`\n+                                       TForall (mkTypeVar \"proxy\", KArrow KStar KStar) (TApp (TVar $ mkTypeVar \"proxy\") polyType :-> keyType :-> TUnit) `ETmApp`"
  },
  {
    "id" : "7eb272f6-b2e8-4255-a7d8-924b85970bc2",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "ba944eaa-593a-4dc9-a7ee-af5649855c08",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, thanks!",
        "createdAt" : "2019-11-15T09:36:45Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 5,
    "diffHunk" : "@@ -382,7 +382,7 @@ convertGenericTemplate env x\n                                             (ETmLam (mkVar \"key\", keyType) $ ERecCon anyContractKeyTy [(anyContractKeyField, EToAny keyType $ EVar $ mkVar \"key\")]))\n                                   else EBuiltin BEError `ETyApp`\n                                        TForall (mkTypeVar \"proxy\", KArrow KStar KStar) (TApp (TVar $ mkTypeVar \"proxy\") polyType :-> keyType :-> typeConAppToType anyContractKeyTy) `ETmApp`\n-                                       EBuiltin (BEText \"toAnyChoice is not supported in this DAML-LF version\")\n+                                       EBuiltin (BEText \"toAnyContractKey is not supported in this DAML-LF version\")"
  },
  {
    "id" : "b6322d57-20ee-45e8-a9c2-5a551d2e2ef5",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "04c85516-7abd-4237-86e8-bc4c26a9fd8e",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "you can just use the `chcArgBinder` variable here.",
        "createdAt" : "2019-11-19T12:15:10Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e16113e6-f99d-44de-a921-80c6c1dc652b",
        "parentId" : "04c85516-7abd-4237-86e8-bc4c26a9fd8e",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "ok",
        "createdAt" : "2019-11-19T16:07:48Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -1660,8 +1660,34 @@ convertExternal env stdlibRef primId lfType\n     | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n     , Nothing <- lookup pkgId modStr templName =\n         error $ \"convertExternal: external template not found \" <> primId\n+    | [pkgId, modStr, templName, choiceName, method] <- splitOn \":\" primId\n+    , Just LF.Template {tplTypeCon,tplChoices} <- lookup pkgId modStr templName\n+    , choice <- ChoiceName (T.pack choiceName)\n+    , Just TemplateChoice {chcSelfBinder,chcArgBinder} <- NM.lookup choice tplChoices = do\n+        let pkgRef = PRImport $ PackageId $ T.pack pkgId\n+        let mod = ModuleName $ map T.pack $ splitOn \".\" modStr\n+        let qualify tconName = Qualified { qualPackage = pkgRef , qualModule = mod , qualObject = tconName}\n+        let templateDataType = TCon . qualify\n+        let (choiceArg, choiceArgType) = chcArgBinder\n+        case method of\n+          \"exercise\" -> do\n+            ETmLam (chcSelfBinder, TApp (TBuiltin BTContractId) (templateDataType tplTypeCon)) $\n+              ETmLam (choiceArg, choiceArgType) $"
  },
  {
    "id" : "3e58745e-bb7e-45c8-acc0-88792dbafed6",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "7cf4cbed-bf7b-4017-81f2-d3e779f203c9",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "This is just a let binding, right?",
        "createdAt" : "2019-11-19T12:15:53Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b8b7763a-57f3-4f95-8f6e-90322100a3eb",
        "parentId" : "7cf4cbed-bf7b-4017-81f2-d3e779f203c9",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "yes",
        "createdAt" : "2019-11-19T16:07:56Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 33,
    "diffHunk" : "@@ -1660,8 +1660,34 @@ convertExternal env stdlibRef primId lfType\n     | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n     , Nothing <- lookup pkgId modStr templName =\n         error $ \"convertExternal: external template not found \" <> primId\n+    | [pkgId, modStr, templName, choiceName, method] <- splitOn \":\" primId\n+    , Just LF.Template {tplTypeCon,tplChoices} <- lookup pkgId modStr templName\n+    , choice <- ChoiceName (T.pack choiceName)"
  },
  {
    "id" : "6d76bf5c-8364-4c1e-9eee-90d05bee7404",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "10e684e2-400c-490b-8d1c-061734c315c5",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Can  we not add the implementation already for the lf versions that support `Any`?",
        "createdAt" : "2019-11-19T12:17:09Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "30aec168-e067-46ed-b4b5-770e55e47c98",
        "parentId" : "10e684e2-400c-490b-8d1c-061734c315c5",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "As discussed, let's leave this to a following PR",
        "createdAt" : "2019-11-19T16:18:05Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 46,
    "diffHunk" : "@@ -1660,8 +1660,34 @@ convertExternal env stdlibRef primId lfType\n     | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n     , Nothing <- lookup pkgId modStr templName =\n         error $ \"convertExternal: external template not found \" <> primId\n+    | [pkgId, modStr, templName, choiceName, method] <- splitOn \":\" primId\n+    , Just LF.Template {tplTypeCon,tplChoices} <- lookup pkgId modStr templName\n+    , choice <- ChoiceName (T.pack choiceName)\n+    , Just TemplateChoice {chcSelfBinder,chcArgBinder} <- NM.lookup choice tplChoices = do\n+        let pkgRef = PRImport $ PackageId $ T.pack pkgId\n+        let mod = ModuleName $ map T.pack $ splitOn \".\" modStr\n+        let qualify tconName = Qualified { qualPackage = pkgRef , qualModule = mod , qualObject = tconName}\n+        let templateDataType = TCon . qualify\n+        let (choiceArg, choiceArgType) = chcArgBinder\n+        case method of\n+          \"exercise\" -> do\n+            ETmLam (chcSelfBinder, TApp (TBuiltin BTContractId) (templateDataType tplTypeCon)) $\n+              ETmLam (choiceArg, choiceArgType) $\n+                EUpdate $ UExercise (qualify tplTypeCon) choice (EVar chcSelfBinder) Nothing (EVar choiceArg)\n+          \"_toAnyChoice\" ->\n+            -- TODO: envLfVersion env `supports` featureAnyType"
  },
  {
    "id" : "30279dce-8327-4bb1-bb28-73422762bee0",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "7f83f771-4247-4bcd-8ee6-adb4fe714784",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Thanks for these!",
        "createdAt" : "2019-11-19T12:18:21Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "92f440ec-f943-4bd7-86ee-143f3914115f",
        "parentId" : "7f83f771-4247-4bcd-8ee6-adb4fe714784",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "you're welcome!",
        "createdAt" : "2019-11-19T16:08:10Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 14,
    "diffHunk" : "@@ -392,7 +392,7 @@ convertGenericTemplate env x\n                                             (ETmLam (mkVar \"any\", typeConAppToType anyContractKeyTy) $ EFromAny keyType $ ERecProj anyContractKeyTy anyContractKeyField $ EVar $ mkVar \"any\"))\n                                   else EBuiltin BEError `ETyApp`\n                                        TForall (mkTypeVar \"proxy\", KArrow KStar KStar) (TApp (TVar $ mkTypeVar \"proxy\") polyType :-> typeConAppToType anyContractKeyTy :-> TOptional keyType) `ETmApp`\n-                                       EBuiltin (BEText \"toAnyChoice is not supported in this DAML-LF version\")\n+                                       EBuiltin (BEText \"fromAnyContractKey is not supported in this DAML-LF version\")"
  },
  {
    "id" : "eb53815c-f60d-4a27-ba7b-c622209ab6af",
    "prId" : 3434,
    "comments" : [
      {
        "id" : "0ca78bc4-7417-4268-92b8-d751fe85c521",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Good catch!",
        "createdAt" : "2019-11-12T18:59:55Z",
        "updatedAt" : "2019-11-12T19:01:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "52581640eac42333bda95c3963414d7e418fa7e3",
    "line" : 23,
    "diffHunk" : "@@ -964,7 +964,7 @@ convertExpr env0 e = do\n             TUpdate{} -> asLet\n             TScenario{} -> asLet\n             TAny{} -> asLet\n-            tcon | isRecordCon con -> do\n+            tcon | isSimpleRecordCon con -> do"
  },
  {
    "id" : "481de96c-940f-4602-a593-21e6fc230c33",
    "prId" : 3434,
    "comments" : [
      {
        "id" : "202677c2-f6bc-4c7e-ae0a-8aac1ec9adbc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "![sad panda](https://i.kym-cdn.com/photos/images/newsfeed/000/092/706/Sad_Panda_Chibi_by_mongrelssister.png)\r\n\r\nPanda wants existentials :wink: ",
        "createdAt" : "2019-11-13T07:50:27Z",
        "updatedAt" : "2019-11-13T07:50:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "494bc9a2-85d2-4ef5-a483-2395622b7fe7",
        "parentId" : "202677c2-f6bc-4c7e-ae0a-8aac1ec9adbc",
        "author" : null,
        "body" : "hahahaha :-)",
        "createdAt" : "2019-11-13T10:07:00Z",
        "updatedAt" : "2019-11-13T10:07:00Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "52581640eac42333bda95c3963414d7e418fa7e3",
    "line" : 80,
    "diffHunk" : "@@ -1180,35 +1177,38 @@ convertAlt env ty (DataAlt con, [a,b], x)\n convertAlt env ty (DataAlt con, [a], x)\n     | NameIn DA_Internal_Prelude \"Some\" <- con\n     = CaseAlternative (CPSome (convVar a)) <$> convertExpr env x\n+\n convertAlt env (TConApp tcon targs) alt@(DataAlt con, vs, x) = do\n-    Ctor (mkVariantCon . getOccText -> variantName) fldNames fldTys <- toCtor env con\n-    let patVariant = variantName\n-    if\n-      | isEnumCon con ->\n-        CaseAlternative (CPEnum patTypeCon patVariant) <$> convertExpr env x\n-      | null fldNames ->\n-        case zipExactMay vs fldTys of\n-          Nothing -> unsupported \"Pattern match with existential type\" alt\n-          Just [] ->\n-            let patBinder = vArg\n-            in  CaseAlternative CPVariant{..} <$> convertExpr env x\n-          Just [(v, _)] ->\n-            let patBinder = convVar v\n-            in  CaseAlternative CPVariant{..} <$> convertExpr env x\n-          Just (_:_:_) -> unsupported \"Data constructor with multiple unnamed fields\" alt\n-      | otherwise ->\n-        case zipExactMay vs (zipExact fldNames fldTys) of\n-          Nothing -> unsupported \"Pattern match with existential type\" alt\n-          Just vsFlds ->\n-            let patBinder = vArg\n-            in  do\n-              x' <- convertExpr env x\n-              projBinds <- mkProjBindings env (EVar vArg) (TypeConApp (synthesizeVariantRecord variantName <$> tcon) targs) vsFlds x'\n-              pure $ CaseAlternative CPVariant{..} projBinds\n-    where\n-        -- TODO(MH): We need to generate fresh names.\n+    let patTypeCon = tcon\n+        patVariant = mkVariantCon (getOccText con)\n         vArg = mkVar \"$arg\"\n-        patTypeCon = tcon\n+\n+    case classifyDataCon con of\n+        EnumCon ->\n+            CaseAlternative (CPEnum patTypeCon patVariant) <$> convertExpr env x\n+\n+        SimpleVariantCon -> do\n+            when (length vs /= dataConRepArity con) $\n+                unsupported \"Pattern match with existential type\" alt"
  },
  {
    "id" : "9f60482f-a2a8-459d-8130-4b58916b4a5e",
    "prId" : 3408,
    "comments" : [
      {
        "id" : "3fed34d9-9a67-45e5-8309-561e088bef1d",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Why both the `_` prefixed and non-prefixed version? And if that's necessary, then maybe also for `_fromAnyChoice`, `_toAnyChoice`, and `templateTypeRep`?",
        "createdAt" : "2019-11-11T10:33:15Z",
        "updatedAt" : "2019-11-11T16:56:01Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1540be8e-2f3d-448f-8137-dc323183c5c9",
        "parentId" : "3fed34d9-9a67-45e5-8309-561e088bef1d",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Both seems to be necessary. I’m a bit surprised why it doesn’t seem to be necessary for the AnyChoice methods but I haven’t investigated why it’s not an issue there.",
        "createdAt" : "2019-11-11T10:46:50Z",
        "updatedAt" : "2019-11-11T16:56:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7a5da145-011d-4d64-be09-65cb8e922a40",
        "parentId" : "3fed34d9-9a67-45e5-8309-561e088bef1d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm surprised we need the version without an `_` prefix here. To me, this feels like we're removing too much. Let's please find out what's going on here before we merge.",
        "createdAt" : "2019-11-11T13:25:33Z",
        "updatedAt" : "2019-11-11T16:56:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2eadbc21-e7a6-43bc-8e0e-c38a3def244b",
        "parentId" : "3fed34d9-9a67-45e5-8309-561e088bef1d",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Fixed, the one we don’t need is the one with the `_`, that is only added to the `TemplateKey` instance but not to the method in the `XInstance` typeclass. I messed this up in `ProposalDesugared` during development which made me think we need to filter both.",
        "createdAt" : "2019-11-11T13:31:54Z",
        "updatedAt" : "2019-11-11T16:56:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "29ae4640a6cc3c5f0bd4293eea900227a7c4d69a",
    "line" : null,
    "diffHunk" : "@@ -651,7 +673,7 @@ convertBind env (name, x)\n     --\n     -- TODO(MH): The check is an approximation which will fail when users\n     -- start the name of their own methods with, say, `_exercise`.\n-    | any (`T.isPrefixOf` getOccText name) [ \"$\" <> prefix <> \"_\" <> method | prefix <- [\"dm\", \"c\"], method <- [\"create\", \"fetch\", \"exercise\", \"toAnyTemplate\", \"fromAnyTemplate\", \"_templateTypeRep\", \"fetchByKey\", \"lookupByKey\", \"toAnyChoice\", \"fromAnyChoice\"] ]\n+    | any (`T.isPrefixOf` getOccText name) [ \"$\" <> prefix <> \"_\" <> method | prefix <- [\"dm\", \"c\"], method <- [\"create\", \"fetch\", \"exercise\", \"toAnyTemplate\", \"fromAnyTemplate\", \"_templateTypeRep\", \"fetchByKey\", \"lookupByKey\", \"toAnyChoice\", \"fromAnyChoice\", \"_toAnyContractKey\", \"_fromAnyContractKey\", \"toAnyContractKey\", \"fromAnyContractKey\"] ]"
  },
  {
    "id" : "7f87f585-a588-4b1b-8d00-fd2a0b2f1f0e",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "3bd14679-6b4d-4060-a670-3d53244250ce",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Please check the module name and maybe even the package name, we should try to reduce the functions that just do string matching, not add more.",
        "createdAt" : "2019-11-06T14:15:16Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "37cee780-74e2-4f5a-adc9-ca0f84431b5a",
        "parentId" : "3bd14679-6b4d-4060-a670-3d53244250ce",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "done.",
        "createdAt" : "2019-11-06T16:39:25Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : null,
    "diffHunk" : "@@ -751,6 +756,9 @@ convertExpr env0 e = do\n             mkFieldProj i (name, _typ) = (mkField (\"_\" <> T.pack (show i)), ETupleProj name (EVar varV1))\n     go env (VarIs \"primitive\") (LType (isStrLitTy -> Just y) : LType t : args)\n         = fmap (, args) $ convertPrim (envLfVersion env) (unpackFS y) <$> convertType env t\n+    go env (VarIs \"external\") (LType (isStrLitTy -> Just y) : LType t : args) = do"
  },
  {
    "id" : "4be4a7ad-b19a-4271-b97c-f7fdffea75a8",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "c75b5d34-2ed1-4cc5-b76a-2f00ce184386",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we try to cram all information into a single string that we then have to deconstruct? It seems easier to just give `external` multiple parameters.",
        "createdAt" : "2019-11-06T14:17:02Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ef1deb36-d465-459d-90a0-1254f3cc4594",
        "parentId" : "c75b5d34-2ed1-4cc5-b76a-2f00ce184386",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I think the parameter number will be different for Choice instances and I wouldn't want to have a second primitive for those. If not, I'm happy to have a `external @pkg @mod @templ @method` primitive.",
        "createdAt" : "2019-11-06T17:51:01Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "57bb6986-6545-4ea3-a12b-b12a12dd4f8e",
        "parentId" : "c75b5d34-2ed1-4cc5-b76a-2f00ce184386",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "we should be able to match on the number of parameters that `external` is applied to. That said, it doesn’t seem that unreasonable to have two primitives.",
        "createdAt" : "2019-11-06T17:52:48Z",
        "updatedAt" : "2019-11-06T17:52:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 89,
    "diffHunk" : "@@ -1523,6 +1531,162 @@ toCtor env con =\n isRecordCtor :: Ctor -> Bool\n isRecordCtor (Ctor _ fldNames fldTys) = not (null fldNames) || null fldTys\n \n+------------------------------------------------------------------------------\n+-- EXTERNAL PACKAGES\n+\n+-- External instance methods\n+convertExternal :: Env -> LF.PackageRef -> String -> LF.Type -> LF.Expr\n+convertExternal env stdlibRef primId lfType\n+    | [pkgId, modStr, templName, method] <- splitOn \":\" primId"
  },
  {
    "id" : "3d667f94-a7f3-442e-9688-287ad8305173",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "a4b56652-66c8-48b3-b2b7-29dbd3e63d09",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The error here seems a bit confusing. It sounds like this case is missing in your implementation whereas what’s missing is the `archive` choice in the DALF so we cannot possibly come up with an implementation for this.",
        "createdAt" : "2019-11-06T14:22:44Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "56fca621-9508-45e6-99ac-4b07a8a4a8e3",
        "parentId" : "a4b56652-66c8-48b3-b2b7-29dbd3e63d09",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "made the error clearer.",
        "createdAt" : "2019-11-06T17:21:09Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : null,
    "diffHunk" : "@@ -1523,6 +1531,162 @@ toCtor env con =\n isRecordCtor :: Ctor -> Bool\n isRecordCtor (Ctor _ fldNames fldTys) = not (null fldNames) || null fldTys\n \n+------------------------------------------------------------------------------\n+-- EXTERNAL PACKAGES\n+\n+-- External instance methods\n+convertExternal :: Env -> LF.PackageRef -> String -> LF.Type -> LF.Expr\n+convertExternal env stdlibRef primId lfType\n+    | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n+    , Just LF.Template {..} <- lookup pkgId modStr templName =\n+        let pkgRef = PRImport $ PackageId $ T.pack pkgId\n+            mod = ModuleName $ map T.pack $ splitOn \".\" modStr\n+            qualify tconName =\n+                Qualified\n+                    { qualPackage = pkgRef\n+                    , qualModule = mod\n+                    , qualObject = tconName\n+                    }\n+            templateDataType = TCon . qualify\n+         in case method of\n+                \"signatory\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplSignatories\n+                \"observer\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplObservers\n+                \"agreement\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplAgreement\n+                \"ensure\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplPrecondition\n+                \"create\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        (EUpdate $ UCreate (qualify tplTypeCon) (EVar tplParam))\n+                \"fetch\" ->\n+                    let coid = mkVar \"$coid\"\n+                     in ETmLam\n+                            ( coid\n+                            , TApp\n+                                  (TBuiltin BTContractId)\n+                                  (templateDataType tplTypeCon))\n+                            (EUpdate $ UFetch (qualify tplTypeCon) (EVar coid))\n+                \"archive\" ->\n+                    let archiveChoice = ChoiceName \"Archive\"\n+                     in case NM.lookup archiveChoice tplChoices of\n+                            Nothing -> errorExpr \"archive\""
  },
  {
    "id" : "c8eec0f7-24a4-43c5-9a88-c4acd2cdf1ed",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "b7a5de23-3e4d-4c40-9005-32dad6f45b0e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This code is somewhat sketchy. I can give you a DALF where `archive` does something completely different and you will happily generate a `Template` instance using this choice as the `archive` implementation. I don’t have a great solution here apart from verifying that this choice is actually the archive choice that we expect. Another hint that archive should really be a primitive.",
        "createdAt" : "2019-11-06T14:24:35Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2ea596e5-0081-4884-ac8b-1e647263d719",
        "parentId" : "b7a5de23-3e4d-4c40-9005-32dad6f45b0e",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I think that would actually be fine. We would archive the template in the way the signatories agreed to upfront. But I wouldn't mind if it would be a primitive either so that a weird `archive` can't happen.",
        "createdAt" : "2019-11-06T16:21:54Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0a2a69ae-0acf-472b-b12c-4b441c3ad141",
        "parentId" : "b7a5de23-3e4d-4c40-9005-32dad6f45b0e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It’s fine in the sense that you can’t do anything people haven’t agreed to before but it means that `archive` is now no longer guaranteed to archive a template, e.g., I could give you a nonconsuming choice that doesn’t archive anything.",
        "createdAt" : "2019-11-06T16:23:37Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 134,
    "diffHunk" : "@@ -1523,6 +1531,162 @@ toCtor env con =\n isRecordCtor :: Ctor -> Bool\n isRecordCtor (Ctor _ fldNames fldTys) = not (null fldNames) || null fldTys\n \n+------------------------------------------------------------------------------\n+-- EXTERNAL PACKAGES\n+\n+-- External instance methods\n+convertExternal :: Env -> LF.PackageRef -> String -> LF.Type -> LF.Expr\n+convertExternal env stdlibRef primId lfType\n+    | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n+    , Just LF.Template {..} <- lookup pkgId modStr templName =\n+        let pkgRef = PRImport $ PackageId $ T.pack pkgId\n+            mod = ModuleName $ map T.pack $ splitOn \".\" modStr\n+            qualify tconName =\n+                Qualified\n+                    { qualPackage = pkgRef\n+                    , qualModule = mod\n+                    , qualObject = tconName\n+                    }\n+            templateDataType = TCon . qualify\n+         in case method of\n+                \"signatory\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplSignatories\n+                \"observer\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplObservers\n+                \"agreement\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplAgreement\n+                \"ensure\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplPrecondition\n+                \"create\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        (EUpdate $ UCreate (qualify tplTypeCon) (EVar tplParam))\n+                \"fetch\" ->\n+                    let coid = mkVar \"$coid\"\n+                     in ETmLam\n+                            ( coid\n+                            , TApp\n+                                  (TBuiltin BTContractId)\n+                                  (templateDataType tplTypeCon))\n+                            (EUpdate $ UFetch (qualify tplTypeCon) (EVar coid))\n+                \"archive\" ->\n+                    let archiveChoice = ChoiceName \"Archive\"\n+                     in case NM.lookup archiveChoice tplChoices of\n+                            Nothing -> errorExpr \"archive\"\n+                            Just TemplateChoice {..} ->\n+                                case chcArgBinder of"
  },
  {
    "id" : "43fd174d-a0dd-4427-a250-5db4a546bccb",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "2ea3dbdf-7e68-423c-8353-3f2347d6069b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This error message could probably be a bit more clear. It looks like there are two cases where we will hit this:\r\n1. The argument passed to `external` cannot be split into the right number of components.\r\n2. The template does not exist.\r\n\r\nSo we should probably point out more clearly what exactly went wrong.",
        "createdAt" : "2019-11-06T14:27:15Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "96901d94-a903-48a1-bef5-e8e753c3f1aa",
        "parentId" : "2ea3dbdf-7e68-423c-8353-3f2347d6069b",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "agreed, separated the two cases.",
        "createdAt" : "2019-11-06T17:33:02Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : null,
    "diffHunk" : "@@ -1523,6 +1531,162 @@ toCtor env con =\n isRecordCtor :: Ctor -> Bool\n isRecordCtor (Ctor _ fldNames fldTys) = not (null fldNames) || null fldTys\n \n+------------------------------------------------------------------------------\n+-- EXTERNAL PACKAGES\n+\n+-- External instance methods\n+convertExternal :: Env -> LF.PackageRef -> String -> LF.Type -> LF.Expr\n+convertExternal env stdlibRef primId lfType\n+    | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n+    , Just LF.Template {..} <- lookup pkgId modStr templName =\n+        let pkgRef = PRImport $ PackageId $ T.pack pkgId\n+            mod = ModuleName $ map T.pack $ splitOn \".\" modStr\n+            qualify tconName =\n+                Qualified\n+                    { qualPackage = pkgRef\n+                    , qualModule = mod\n+                    , qualObject = tconName\n+                    }\n+            templateDataType = TCon . qualify\n+         in case method of\n+                \"signatory\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplSignatories\n+                \"observer\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplObservers\n+                \"agreement\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplAgreement\n+                \"ensure\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplPrecondition\n+                \"create\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        (EUpdate $ UCreate (qualify tplTypeCon) (EVar tplParam))\n+                \"fetch\" ->\n+                    let coid = mkVar \"$coid\"\n+                     in ETmLam\n+                            ( coid\n+                            , TApp\n+                                  (TBuiltin BTContractId)\n+                                  (templateDataType tplTypeCon))\n+                            (EUpdate $ UFetch (qualify tplTypeCon) (EVar coid))\n+                \"archive\" ->\n+                    let archiveChoice = ChoiceName \"Archive\"\n+                     in case NM.lookup archiveChoice tplChoices of\n+                            Nothing -> errorExpr \"archive\"\n+                            Just TemplateChoice {..} ->\n+                                case chcArgBinder of\n+                                    (_, LF.TCon tcon) ->\n+                                        let coid = mkVar \"$coid\"\n+                                            archiveChoiceArg =\n+                                                LF.ERecCon\n+                                                    { LF.recTypeCon =\n+                                                          LF.TypeConApp tcon []\n+                                                    , LF.recFields = []\n+                                                    }\n+                                         in ETmLam\n+                                                ( coid\n+                                                , TApp\n+                                                      (TBuiltin BTContractId)\n+                                                      (templateDataType\n+                                                           tplTypeCon))\n+                                                (EUpdate $\n+                                                 UExercise\n+                                                     (qualify tplTypeCon)\n+                                                     archiveChoice\n+                                                     (EVar coid)\n+                                                     Nothing\n+                                                     archiveChoiceArg)\n+                                    otherwise ->\n+                                        error\n+                                            \"convertExternal: Archive choice exists but has the wrong type.\"\n+                \"toAnyTemplate\"\n+                    | envLfVersion env `supports` featureAnyType ->\n+                        ETmLam (tplParam, templateDataType tplTypeCon) $\n+                        ERecCon\n+                            anyTemplateTy\n+                            [ ( anyTemplateField\n+                              , EToAny\n+                                    (templateDataType tplTypeCon)\n+                                    (EVar tplParam))\n+                            ]\n+                \"toAnyTemplate\"\n+                    | otherwise ->\n+                        EBuiltin BEError `ETyApp` lfType `ETmApp`\n+                        EBuiltin\n+                            (BEText\n+                                 \"toAnyTemplate is not supported in this DAML-LF version\")\n+                \"fromAnyTemplate\"\n+                    | envLfVersion env `supports` featureAnyType ->\n+                        ETmLam (anyTpl, typeConAppToType anyTemplateTy) $\n+                        ECase\n+                            (EFromAny\n+                                 (templateDataType tplTypeCon)\n+                                 (ERecProj\n+                                      anyTemplateTy\n+                                      anyTemplateField\n+                                      (EVar anyTpl)))\n+                            [ CaseAlternative CPNone $\n+                              ENone $ templateDataType tplTypeCon\n+                            , CaseAlternative (CPSome tplParam) $\n+                              ESome (templateDataType tplTypeCon) $\n+                              EVar tplParam\n+                            ]\n+                    | otherwise ->\n+                        EBuiltin BEError `ETyApp` lfType `ETmApp`\n+                        EBuiltin\n+                            (BEText\n+                                 \"fromAnyTemplate is not supported in this DAML-LF version\")\n+                \"_templateTypeRep\"\n+                    | envLfVersion env `supports` featureTypeRep ->\n+                        let resType =\n+                                TypeConApp\n+                                    (Qualified\n+                                         stdlibRef\n+                                         (mkModName [\"DA\", \"Internal\", \"LF\"])\n+                                         (mkTypeCon [\"TemplateTypeRep\"]))\n+                                    []\n+                            resField = mkField \"getTemplateTypeRep\"\n+                         in ERecCon\n+                                resType\n+                                [ ( resField\n+                                  , ETypeRep $ templateDataType tplTypeCon)\n+                                ]\n+                    | otherwise ->\n+                        EBuiltin BEError `ETyApp` lfType `ETmApp`\n+                        EBuiltin\n+                            (BEText\n+                                 \"templateTypeRep is not supported in this DAML-LF version\")\n+                other -> error \"convertExternal: Unknown external method\"\n+    | otherwise = error $ \"convertExternal: Unable to inline call to external method: \" <> primId"
  },
  {
    "id" : "aee7e294-eb29-4b1c-810b-a2b7b1e283d6",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "9f576596-9fd8-41df-916d-5ec42baa9766",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We can probably factor this out since it’s shared with the regular LF conversion.",
        "createdAt" : "2019-11-06T14:28:13Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "99951337-c4b6-49b4-8970-61008855f02d",
        "parentId" : "9f576596-9fd8-41df-916d-5ec42baa9766",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "factored it out.",
        "createdAt" : "2019-11-06T17:29:20Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : null,
    "diffHunk" : "@@ -1523,6 +1531,162 @@ toCtor env con =\n isRecordCtor :: Ctor -> Bool\n isRecordCtor (Ctor _ fldNames fldTys) = not (null fldNames) || null fldTys\n \n+------------------------------------------------------------------------------\n+-- EXTERNAL PACKAGES\n+\n+-- External instance methods\n+convertExternal :: Env -> LF.PackageRef -> String -> LF.Type -> LF.Expr\n+convertExternal env stdlibRef primId lfType\n+    | [pkgId, modStr, templName, method] <- splitOn \":\" primId\n+    , Just LF.Template {..} <- lookup pkgId modStr templName =\n+        let pkgRef = PRImport $ PackageId $ T.pack pkgId\n+            mod = ModuleName $ map T.pack $ splitOn \".\" modStr\n+            qualify tconName =\n+                Qualified\n+                    { qualPackage = pkgRef\n+                    , qualModule = mod\n+                    , qualObject = tconName\n+                    }\n+            templateDataType = TCon . qualify\n+         in case method of\n+                \"signatory\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplSignatories\n+                \"observer\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplObservers\n+                \"agreement\" ->\n+                    ETmLam (tplParam, templateDataType tplTypeCon) tplAgreement\n+                \"ensure\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        tplPrecondition\n+                \"create\" ->\n+                    ETmLam\n+                        (tplParam, templateDataType tplTypeCon)\n+                        (EUpdate $ UCreate (qualify tplTypeCon) (EVar tplParam))\n+                \"fetch\" ->\n+                    let coid = mkVar \"$coid\"\n+                     in ETmLam\n+                            ( coid\n+                            , TApp\n+                                  (TBuiltin BTContractId)\n+                                  (templateDataType tplTypeCon))\n+                            (EUpdate $ UFetch (qualify tplTypeCon) (EVar coid))\n+                \"archive\" ->\n+                    let archiveChoice = ChoiceName \"Archive\"\n+                     in case NM.lookup archiveChoice tplChoices of\n+                            Nothing -> errorExpr \"archive\"\n+                            Just TemplateChoice {..} ->\n+                                case chcArgBinder of\n+                                    (_, LF.TCon tcon) ->\n+                                        let coid = mkVar \"$coid\"\n+                                            archiveChoiceArg =\n+                                                LF.ERecCon\n+                                                    { LF.recTypeCon =\n+                                                          LF.TypeConApp tcon []\n+                                                    , LF.recFields = []\n+                                                    }\n+                                         in ETmLam\n+                                                ( coid\n+                                                , TApp\n+                                                      (TBuiltin BTContractId)\n+                                                      (templateDataType\n+                                                           tplTypeCon))\n+                                                (EUpdate $\n+                                                 UExercise\n+                                                     (qualify tplTypeCon)\n+                                                     archiveChoice\n+                                                     (EVar coid)\n+                                                     Nothing\n+                                                     archiveChoiceArg)\n+                                    otherwise ->\n+                                        error\n+                                            \"convertExternal: Archive choice exists but has the wrong type.\"\n+                \"toAnyTemplate\"\n+                    | envLfVersion env `supports` featureAnyType ->\n+                        ETmLam (tplParam, templateDataType tplTypeCon) $\n+                        ERecCon\n+                            anyTemplateTy\n+                            [ ( anyTemplateField\n+                              , EToAny\n+                                    (templateDataType tplTypeCon)\n+                                    (EVar tplParam))\n+                            ]\n+                \"toAnyTemplate\"\n+                    | otherwise ->\n+                        EBuiltin BEError `ETyApp` lfType `ETmApp`\n+                        EBuiltin\n+                            (BEText\n+                                 \"toAnyTemplate is not supported in this DAML-LF version\")\n+                \"fromAnyTemplate\"\n+                    | envLfVersion env `supports` featureAnyType ->\n+                        ETmLam (anyTpl, typeConAppToType anyTemplateTy) $\n+                        ECase\n+                            (EFromAny\n+                                 (templateDataType tplTypeCon)\n+                                 (ERecProj\n+                                      anyTemplateTy\n+                                      anyTemplateField\n+                                      (EVar anyTpl)))\n+                            [ CaseAlternative CPNone $\n+                              ENone $ templateDataType tplTypeCon\n+                            , CaseAlternative (CPSome tplParam) $\n+                              ESome (templateDataType tplTypeCon) $\n+                              EVar tplParam\n+                            ]\n+                    | otherwise ->\n+                        EBuiltin BEError `ETyApp` lfType `ETmApp`\n+                        EBuiltin\n+                            (BEText\n+                                 \"fromAnyTemplate is not supported in this DAML-LF version\")\n+                \"_templateTypeRep\"\n+                    | envLfVersion env `supports` featureTypeRep ->\n+                        let resType =\n+                                TypeConApp\n+                                    (Qualified\n+                                         stdlibRef\n+                                         (mkModName [\"DA\", \"Internal\", \"LF\"])\n+                                         (mkTypeCon [\"TemplateTypeRep\"]))\n+                                    []\n+                            resField = mkField \"getTemplateTypeRep\"\n+                         in ERecCon\n+                                resType\n+                                [ ( resField\n+                                  , ETypeRep $ templateDataType tplTypeCon)\n+                                ]\n+                    | otherwise ->\n+                        EBuiltin BEError `ETyApp` lfType `ETmApp`\n+                        EBuiltin\n+                            (BEText\n+                                 \"templateTypeRep is not supported in this DAML-LF version\")\n+                other -> error \"convertExternal: Unknown external method\"\n+    | otherwise = error $ \"convertExternal: Unable to inline call to external method: \" <> primId\n+  where\n+    errorExpr s =\n+        EBuiltin BEError `ETyApp` lfType `ETmApp`\n+        EBuiltin\n+            (BEText $ \"convertExternal: method \" <> s <> \" not implemented\")\n+    lookup pId modName temName = do\n+        mods <- MS.lookup pId pkgIdToModules\n+        mod <- NM.lookup (LF.ModuleName $ map T.pack $ splitOn \".\" modName) mods\n+        NM.lookup (LF.TypeConName [T.pack temName]) $ LF.moduleTemplates mod\n+    pkgIdToModules =\n+        MS.fromList\n+            [ (T.unpack $ LF.unPackageId dalfPackageId, LF.packageModules pkg)\n+            | (_uId, DalfPackage {..}) <- MS.toList $ envPkgMap env\n+            , let ExternalPackage _pid pkg = dalfPackagePkg\n+            ]\n+    anyTemplateTy ="
  },
  {
    "id" : "2528c7a1-47f2-48da-adb1-aedb8142ab50",
    "prId" : 3251,
    "comments" : [
      {
        "id" : "2e105014-f28c-48e4-bf08-2d4a0e1a91d8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It seems a bit odd, to enable this just for this module. Can we just add the type signatures and leave it disabled or is there a specific reason for why we need this here?",
        "createdAt" : "2019-10-28T12:42:32Z",
        "updatedAt" : "2019-10-28T16:04:43Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e432643c-e54f-40d2-9d3b-a0d4f0ad1095",
        "parentId" : "2e105014-f28c-48e4-bf08-2d4a0e1a91d8",
        "author" : null,
        "body" : "I can definitely remove it and keep the type signatures. :) ",
        "createdAt" : "2019-10-28T15:48:28Z",
        "updatedAt" : "2019-10-28T16:04:43Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a4389c8613a48afa8ef43ab1525efd41cc59ffe3",
    "line" : null,
    "diffHunk" : "@@ -2,7 +2,8 @@\n -- SPDX-License-Identifier: Apache-2.0\n \n {-# LANGUAGE MultiWayIf #-}\n-{-# LANGUAGE PatternSynonyms     #-}\n+{-# LANGUAGE PatternSynonyms #-}\n+{-# LANGUAGE MonoLocalBinds #-}"
  },
  {
    "id" : "1231f95e-9f0f-4903-8333-2b4183f1ffcc",
    "prId" : 3251,
    "comments" : [
      {
        "id" : "71575b6e-1e7c-4f0d-a504-dc0216b1afbb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    pure $ typeDef : [workerDef | flavour == NewtypeFlavour]\r\n```",
        "createdAt" : "2019-10-28T12:49:00Z",
        "updatedAt" : "2019-10-28T16:04:43Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6ce47f45-a03a-4db4-a82e-86a45d15549b",
        "parentId" : "71575b6e-1e7c-4f0d-a504-dc0216b1afbb",
        "author" : null,
        "body" : "D'oh :-) Thanks!",
        "createdAt" : "2019-10-28T15:53:40Z",
        "updatedAt" : "2019-10-28T16:04:43Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a4389c8613a48afa8ef43ab1525efd41cc59ffe3",
    "line" : null,
    "diffHunk" : "@@ -497,70 +498,135 @@ data Consuming = PreConsuming\n                deriving (Eq)\n \n convertTypeDef :: Env -> TyThing -> ConvertM [Definition]\n-convertTypeDef env (ATyCon t)\n-  | GHC.moduleNameFS (GHC.moduleName (nameModule (getName t))) == \"DA.Internal.LF\"\n-  , getOccFS t `elementOfUniqSet` internalTypes\n-  = pure []\n-convertTypeDef env (ATyCon t)\n+convertTypeDef env o@(ATyCon t) = withRange (convNameLoc t) $ if\n+    -- Internal types (i.e. already defined in LF)\n+    | GHC.moduleNameFS (GHC.moduleName (nameModule (getName t))) == \"DA.Internal.LF\"\n+    , getOccFS t `elementOfUniqSet` internalTypes\n+    -> pure []\n+\n     -- NOTE(MH): We detect type synonyms produced by the desugaring\n     -- of `template instance` declarations and inline the record definition\n     -- of the generic template.\n+    --\n+    -- TODO(FM): Precompute a map of possible template instances in Env\n+    -- instead of checking every closed type synonym against every class\n+    -- instance (or improve this some other way to subquadratic time).\n     | Just ([], TypeCon tpl args) <- synTyConDefn_maybe t\n     , any (\\(c, args') -> getOccFS c == getOccFS tpl <> \"Instance\" && eqTypes args args') $ envInstances env\n-    = do\n-        ctors0 <- toCtors env tpl\n-        args <- mapM (convertType env) args\n-        let subst = MS.fromList $ zipExact (map fst (_cParams ctors0)) args\n-        let ctors1 = ctors0\n-                { _cTypeName = getName t\n-                , _cParams = []\n-                , _cCtors = map (\\(Ctor n fs ts) -> Ctor n fs $ map (LF.substitute subst) ts) (_cCtors ctors0)\n-                }\n-        convertCtors env ctors1\n-convertTypeDef env o@(ATyCon t) = withRange (convNameLoc t) $\n-    case tyConFlavour t of\n-      fl | fl `elem` [ClassFlavour,DataTypeFlavour,NewtypeFlavour] -> convertCtors env =<< toCtors env t\n-      TypeSynonymFlavour -> pure []\n-      _ -> unsupported (\"Data definition, of type \" ++ prettyPrint (tyConFlavour t)) o\n-convertTypeDef env x = pure []\n+    -> convertTemplateInstanceDef env (getName t) tpl args\n \n+    -- Type synonyms get expanded out during conversion (see 'convertType').\n+    | isTypeSynonymTyCon t\n+    -> pure []\n \n-convertCtors :: Env -> Ctors -> ConvertM [Definition]\n-convertCtors env (Ctors name flavour tys [o@(Ctor ctor fldNames fldTys)])\n-  | isRecordCtor o\n-  = pure $ [defDataType tconName tys $ DataRecord flds] ++\n-      [ defValue name (mkVal $ \"$W\" <> getOccText ctor, mkTForalls tys $ mkTFuns fldTys (typeConAppToType tcon)) expr\n-      | flavour == NewtypeFlavour\n-      ]\n-    where\n-        flds = zipExact fldNames fldTys\n-        tconName = mkTypeCon [getOccText name]\n-        tcon = TypeConApp (Qualified PRSelf (envLFModuleName env) tconName) $ map (TVar . fst) tys\n-        expr = mkETyLams tys $ mkETmLams (map (first fieldToVar ) flds) $ ERecCon tcon [(l, EVar $ fieldToVar l) | l <- fldNames]\n-convertCtors env o@(Ctors name _ _ cs) | isEnumCtors o = do\n-    let ctorNames = map (\\(Ctor ctor _ _) -> mkVariantCon $ getOccText ctor) cs\n+    -- Enum types. These are algebraic types without any type arguments,\n+    -- with two or more constructors that have no arguments.\n+    | isEnumTyCon t\n+    -> convertEnumDef env t\n+\n+    -- Simple record types. This includes newtypes, typeclasses, and\n+    -- single constructor algebraic types with no fields or with\n+    -- labelled fields.\n+    | isSimpleRecordTyCon t\n+    -> convertSimpleRecordDef env t\n+\n+    -- Variants are algebraic types that are not enums and not simple\n+    -- record types. This includes most 'data' types.\n+    | isVariantTyCon t\n+    -> convertVariantDef env t\n+\n+    | otherwise\n+    -> unsupported (\"Data definition, of type \" ++ prettyPrint (tyConFlavour t)) o\n+\n+convertTypeDef env x = pure []\n+\n+convertEnumDef :: Env -> TyCon -> ConvertM [Definition]\n+convertEnumDef env t =\n     pure [defDataType tconName [] $ DataEnum ctorNames]\n   where\n-    tconName = mkTypeCon [getOccText name]\n-convertCtors env (Ctors name _ tys cs) = do\n-    (constrs, funs) <- mapAndUnzipM convertCtor cs\n-    pure $ [defDataType tconName tys $ DataVariant constrs] ++ concat funs\n-    where\n-      tconName = mkTypeCon [getOccText name]\n-      convertCtor :: Ctor -> ConvertM ((VariantConName, LF.Type), [Definition])\n-      convertCtor o@(Ctor ctor fldNames fldTys) =\n-        case (fldNames, fldTys) of\n-          ([], []) -> pure ((ctorName, TUnit), [])\n-          ([], [typ]) -> pure ((ctorName, typ), [])\n-          ([], _:_:_) -> unsupported \"Data constructor with multiple unnamed fields\" (prettyPrint name)\n-          (_:_, _) ->\n+    tconName = mkTypeCon [getOccText t]\n+    ctorNames = map (mkVariantCon . getOccText) (tyConDataCons t)\n+\n+convertSimpleRecordDef :: Env -> TyCon -> ConvertM [Definition]\n+convertSimpleRecordDef env tycon = do\n+    let con = tyConSingleDataCon tycon\n+        flavour = tyConFlavour tycon\n+        sanitize -- DICTIONARY SANITIZATION step (1)\n+            | flavour == ClassFlavour = (TUnit :->)\n+            | otherwise = id\n+    tyVars <- mapM convTypeVar (tyConTyVars tycon)\n+    fields <- convertRecordFields env con sanitize\n+    let tconName = mkTypeCon [getOccText tycon]\n+        typeDef = defDataType tconName tyVars (DataRecord fields)\n+        workerDef = defNewtypeWorker env tycon tconName con tyVars fields\n+    pure $ [typeDef] ++ [workerDef | flavour == NewtypeFlavour]"
  },
  {
    "id" : "5151d00f-55ed-4e9f-979c-b339d908e20a",
    "prId" : 3251,
    "comments" : [
      {
        "id" : "9c6b9c79-287b-4401-8f0e-c6e66d4a84ad",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The `SimpleVariantCon` case covers variant constructors whose fields are not labeled. Is that is correct, then I suggest\r\n```suggestion\r\n        -- constructor cannot have more than two arguments\r\n```",
        "createdAt" : "2019-10-28T14:06:05Z",
        "updatedAt" : "2019-10-28T16:04:43Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ee17a9fe-cc46-4e60-8760-a4059fef4348",
        "parentId" : "9c6b9c79-287b-4401-8f0e-c6e66d4a84ad",
        "author" : null,
        "body" : "Yes, that looks good! Thanks!",
        "createdAt" : "2019-10-28T15:49:16Z",
        "updatedAt" : "2019-10-28T16:04:43Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "119d6e93-e893-467e-9fd0-093ac779822d",
        "parentId" : "9c6b9c79-287b-4401-8f0e-c6e66d4a84ad",
        "author" : null,
        "body" : "Changing this to `more than one argument` which is more precise.",
        "createdAt" : "2019-10-28T16:00:18Z",
        "updatedAt" : "2019-10-28T16:04:43Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a4389c8613a48afa8ef43ab1525efd41cc59ffe3",
    "line" : null,
    "diffHunk" : "@@ -1011,6 +1007,124 @@ convertExpr env0 e = do\n     go env o@(Coercion _) args = unhandled \"Coercion\" o\n     go _ x args = unhandled \"Expression\" x\n \n+-- | Is this an enum type?\n+isEnumTyCon :: TyCon -> Bool\n+isEnumTyCon tycon =\n+    isEnumerationTyCon tycon\n+    && (tyConArity tycon == 0)\n+    && (length (tyConDataCons tycon) >= 2)\n+\n+-- | Is this a simple record type?\n+isSimpleRecordTyCon :: TyCon -> Bool\n+isSimpleRecordTyCon tycon =\n+    maybe False isSimpleRecordCon (tyConSingleDataCon_maybe tycon)\n+\n+-- | Is this a variant type?\n+isVariantTyCon :: TyCon -> Bool\n+isVariantTyCon tycon =\n+    (tyConFlavour tycon == DataTypeFlavour)\n+    && not (isEnumTyCon tycon)\n+    && not (isSimpleRecordTyCon tycon)\n+\n+conIsSingle :: DataCon -> Bool\n+conIsSingle = isSingleConType . dataConTyCon\n+\n+conHasNoArgs :: DataCon -> Bool\n+conHasNoArgs = null . dataConOrigArgTys\n+\n+conHasLabels :: DataCon -> Bool\n+conHasLabels = notNull . ctorLabels\n+\n+isEnumCon :: DataCon -> Bool\n+isEnumCon = isEnumTyCon . dataConTyCon\n+\n+isSimpleRecordCon :: DataCon -> Bool\n+isSimpleRecordCon con = (conHasLabels con || conHasNoArgs con) && conIsSingle con\n+\n+isVariantRecordCon :: DataCon -> Bool\n+isVariantRecordCon con = conHasLabels con && not (conIsSingle con)\n+\n+-- | The different classes of data cons with respect to LF conversion.\n+data DataConClass\n+    = EnumCon -- ^ constructor for an enum type\n+    | SimpleRecordCon -- ^ constructor for a record type\n+    | SimpleVariantCon -- ^ constructor for a variant type with no synthetic record type\n+    | VariantRecordCon -- ^ constructor for a variant type with a synthetic record type\n+    deriving (Eq, Show)\n+\n+classifyDataCon :: DataCon -> DataConClass\n+classifyDataCon con\n+    | isEnumCon con = EnumCon\n+    | isSimpleRecordCon con = SimpleRecordCon\n+    | isVariantRecordCon con = VariantRecordCon\n+    | otherwise = SimpleVariantCon\n+        -- in which case, daml-preprocessor ensures that the\n+        -- constructor cannot have more than two unlabeled arguments"
  },
  {
    "id" : "0b2917a1-6169-4571-9976-42f627512380",
    "prId" : 3085,
    "comments" : [
      {
        "id" : "f8fb3618-210f-4a15-8518-07a28bea39a9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Only catching this during LF conversion seems slightly ugly but admittedly I don’t know how to catch it earlier :disappointed: ",
        "createdAt" : "2019-10-02T13:21:30Z",
        "updatedAt" : "2019-10-02T13:29:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f9631283dd43576f6c41d5712f5867927ac1fabc",
    "line" : 45,
    "diffHunk" : "@@ -687,11 +658,7 @@ convertExpr env0 e = do\n     go env (VarIs \"fromRational\") (LType (isNumLitTy -> Just n) : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\n         = fmap (, args) $ convertRationalNumericMono env n top bot\n     go env (VarIs \"fromRational\") (LType scaleTyCoRep : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\n-        = do\n-            scaleType <- convertType env scaleTyCoRep\n-            fmap (, args) $ convertRationalNumericPoly env scaleType top bot\n-\n-\n+        = unsupported \"Polymorphic numeric literal. Specify a fixed scale by giving the type, e.g. (1.2345 : Numeric 10)\" ()"
  },
  {
    "id" : "132c97ad-7aba-4369-9397-30646c046727",
    "prId" : 3038,
    "comments" : [
      {
        "id" : "d202f291-c5b1-471b-ad8c-b3b08bc3be96",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Shouldn't this be something like\r\n```suggestion\r\n            (\"Rational is out of bounds: \" ++ show double ++ \". The range of values representable by the Numeric \" ++ show scale ++ \" type is  -10^\" ++ show maxPower ++ \" + 10^-\" ++ show scale ++ \"  through  10^\" ++ show maxPower ++ \" - 1.\")\r\n```",
        "createdAt" : "2019-09-26T08:25:27Z",
        "updatedAt" : "2019-09-26T09:05:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2305577f-2e13-4812-9168-738fc8d54ead",
        "parentId" : "d202f291-c5b1-471b-ad8c-b3b08bc3be96",
        "author" : null,
        "body" : "ah, you're right",
        "createdAt" : "2019-09-26T08:34:06Z",
        "updatedAt" : "2019-09-26T09:05:12Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d387dbaf-8c70-4135-9b4c-67059b00576c",
        "parentId" : "d202f291-c5b1-471b-ad8c-b3b08bc3be96",
        "author" : null,
        "body" : "gosh, what a cumbersome number to describe ... perhaps I can say \"Numeric scale can only represent numbers greater than -10^maxPower and smaller than 10^maxPower\"",
        "createdAt" : "2019-09-26T08:35:50Z",
        "updatedAt" : "2019-09-26T09:05:12Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "856b2296-231b-46ac-91bd-bc5ba06209c8",
        "parentId" : "d202f291-c5b1-471b-ad8c-b3b08bc3be96",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would use language like \"between ... (exlusive)\" or \"strictly between\". But I don't really care.",
        "createdAt" : "2019-09-26T12:31:08Z",
        "updatedAt" : "2019-09-26T12:31:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c4ab003e15de2d7fd0620de6727edbea265df7dc",
    "line" : null,
    "diffHunk" : "@@ -237,36 +237,34 @@ convertRationalDecimal env num denom\n     maxPrecision = 10 :: Integer\n \n -- | Convert a rational number into a fixed scale Numeric literal. We check\n--- that the scale is in bounds, and the number can be represented without\n+-- that the scale is in bound, and the number can be represented without\n -- overflow or loss of precision.\n convertRationalNumericMono :: Env -> Integer -> Integer -> Integer -> ConvertM LF.Expr\n-convertRationalNumericMono env scale num denom =\n-    if  | scale < 0 || scale > 37 ->\n-            unsupported\n-                (\"Tried to construct value of type Numeric \" ++ show scale ++ \", but scale is out of bounds. Scale must be between 0 through 37, not \" ++ show scale ++ \".\")\n-                scale\n-\n-        | abs (r * 10 ^ scale) >= upperBound128Bit ->\n-            unsupported\n-                (\"Rational is out of bounds: \" ++\n-                show ((fromInteger num / fromInteger denom) :: Double) ++\n-                \". The range of values representable by the Numeric \" ++ show scale ++ \" type is  -10^\" ++ show (38-scale) ++ \" + 1  through  10^\" ++ show (38-scale) ++ \" - 1.\")\n-                (num, denom)\n+convertRationalNumericMono env scale num denom\n+    | scale < 0 || scale > fromIntegral numericMaxScale =\n+        unsupported\n+            (\"Tried to construct value of type Numeric \" ++ show scale ++ \", but scale is out of bounds. Scale must be between 0 through 37, not \" ++ show scale ++ \".\")\n+            scale\n+\n+    | abs (rational * 10 ^ scale) >= 10 ^ numericMaxPrecision =\n+        unsupported\n+            (\"Rational is out of bounds: \" ++ show double ++ \". The range of values representable by the Numeric \" ++ show scale ++ \" type is  -10^\" ++ show maxPower ++ \" + 1  through  10^\" ++ show maxPower ++ \" - 1.\")"
  },
  {
    "id" : "ca08d013-b8a1-4d0a-811d-f1a26500dec9",
    "prId" : 2950,
    "comments" : [
      {
        "id" : "d979b327-ce41-48b1-9b9d-3f7d153279fc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There's no need for a multiway if here. ;)",
        "createdAt" : "2019-09-23T16:24:10Z",
        "updatedAt" : "2019-09-24T14:18:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bae243c1ecdc420b8ddb5e91675a9a0deec24993",
    "line" : 30,
    "diffHunk" : "@@ -235,6 +236,67 @@ convertRational env num denom\n     upperBound128Bit = 10 ^ (38 :: Integer)\n     maxPrecision = 10 :: Integer\n \n+-- | Convert a rational number into a fixed scale Numeric literal. We check\n+-- that the scale is in bounds, and the number can be represented without\n+-- overflow or loss of precision.\n+convertRationalNumericMono :: Env -> Integer -> Integer -> Integer -> ConvertM LF.Expr\n+convertRationalNumericMono env scale num denom =\n+    if  | scale < 0 || scale > 37 ->"
  },
  {
    "id" : "fc02b1b4-9c5f-4e4c-91e0-8849f2be02fe",
    "prId" : 2950,
    "comments" : [
      {
        "id" : "4fbc7e30-a370-40fd-99a2-4dbac5d0e0d1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    go env (VarIs \"fromRational\") (LType scaleTyCoRep : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\r\n        | Just n <- isNumLitTy scaleTyCoRep\r\n        = fmap (, args) $ convertRationalNumericMono env n top bot\r\n        | otherwise\r\n```\r\nand remove the case above. This will avoid some repetition.",
        "createdAt" : "2019-09-23T16:31:22Z",
        "updatedAt" : "2019-09-24T14:18:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bae243c1ecdc420b8ddb5e91675a9a0deec24993",
    "line" : 97,
    "diffHunk" : "@@ -622,7 +684,15 @@ convertExpr env0 e = do\n             withTmArg env (varV2, record') args $ \\x2 args ->\n                 pure (ERecUpd (fromTCon record') (mkField $ fsToText name) x2 x1, args)\n     go env (VarIs \"fromRational\") (LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\n-        = fmap (, args) $ convertRational env top bot\n+        = fmap (, args) $ convertRationalDecimal env top bot\n+    go env (VarIs \"fromRational\") (LType (isNumLitTy -> Just n) : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)\n+        = fmap (, args) $ convertRationalNumericMono env n top bot\n+    go env (VarIs \"fromRational\") (LType scaleTyCoRep : LExpr (VarIs \":%\" `App` tyInteger `App` Lit (LitNumber _ top _) `App` Lit (LitNumber _ bot _)) : args)"
  },
  {
    "id" : "012d6959-e689-4f80-a23d-dfb57d1a8c20",
    "prId" : 2779,
    "comments" : [
      {
        "id" : "286012a6-5d13-42da-937f-117ec9442b17",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not really new in this PR and might be consistent with other parts of this module but for me shadowing the GHC identifiers with the converted DAML-LF identifiers makes things harder to understand. I would prefer something like `polyTypeLf <- convertType env polyType`. Since they have different types anyway the main advantage of shadowing namely that you can’t accidentally refer to the old identifier does not apply.",
        "createdAt" : "2019-09-05T16:58:00Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3cac4be1-a583-4414-887f-a59b19be8d6d",
        "parentId" : "286012a6-5d13-42da-937f-117ec9442b17",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'll change this and a few other thing you mentioned in a cleanup PR. There's more stuff around there that needs some cleaning.",
        "createdAt" : "2019-09-05T19:47:19Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 56,
    "diffHunk" : "@@ -278,17 +287,24 @@ convertGenericTemplate env x\n     , (tyArgs, args) <- span isTypeArg args\n     , Just tyArgs <- mapM isType_maybe tyArgs\n     , Just (superClassDicts, signatories : observers : ensure : agreement : create : _fetch : archive : keyAndChoices) <- span isSuperClassDict <$> mapM isVar_maybe (dropWhile isTypeArg args)\n-    , Just (polyType, _) <- splitFunTy_maybe (varType create)\n-    , Just (monoTyCon, unwrapCo) <- findMonoTyp polyType\n+    , Just (polyType@(TypeCon polyTyCon _), _) <- splitFunTy_maybe (varType create)\n+    , Just monoTyCon <- findMonoTyp polyType\n     = do\n         let tplLocation = convNameLoc monoTyCon\n-        polyType <- convertType env polyType\n+        Ctors{_cCtors = [Ctor _ fields _]} <- toCtors env polyTyCon"
  },
  {
    "id" : "fd9e3a3b-0a87-4472-b579-c90e4b90c79c",
    "prId" : 2779,
    "comments" : [
      {
        "id" : "c63132c4-7048-448a-b0f0-2c9680127e52",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        let coerceRecord fromType toType fromExpr =\r\n```\r\n`rec` is too overloaded (recursive, record, I’m sure you can come up with other things) especially since you use it in a binding here.",
        "createdAt" : "2019-09-05T16:58:52Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 64,
    "diffHunk" : "@@ -278,17 +287,24 @@ convertGenericTemplate env x\n     , (tyArgs, args) <- span isTypeArg args\n     , Just tyArgs <- mapM isType_maybe tyArgs\n     , Just (superClassDicts, signatories : observers : ensure : agreement : create : _fetch : archive : keyAndChoices) <- span isSuperClassDict <$> mapM isVar_maybe (dropWhile isTypeArg args)\n-    , Just (polyType, _) <- splitFunTy_maybe (varType create)\n-    , Just (monoTyCon, unwrapCo) <- findMonoTyp polyType\n+    , Just (polyType@(TypeCon polyTyCon _), _) <- splitFunTy_maybe (varType create)\n+    , Just monoTyCon <- findMonoTyp polyType\n     = do\n         let tplLocation = convNameLoc monoTyCon\n-        polyType <- convertType env polyType\n+        Ctors{_cCtors = [Ctor _ fields _]} <- toCtors env polyTyCon\n+        polyType@(TConApp polyTyCon polyTyArgs) <- convertType env polyType\n+        let polyTCA = TypeConApp polyTyCon polyTyArgs\n         monoType@(TCon monoTyCon) <- convertTyCon env monoTyCon\n-        (unwrapTpl, wrapTpl) <- convertCoercion env unwrapCo\n-        let (unwrapCid, wrapCid)\n-                | isReflCo unwrapCo = (id, id)\n+        let monoTCA = TypeConApp monoTyCon []\n+        let coerceRec fromType toType fromExpr ="
  },
  {
    "id" : "93ec6764-5d25-4ed0-9046-d8901c03db81",
    "prId" : 2779,
    "comments" : [
      {
        "id" : "106de221-b96d-4d88-9564-afa533bbb86d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This does look like it will make conversion more expensive both in runtime costs and codesize costs. Not necessarily an issue but worth keeping in mind.",
        "createdAt" : "2019-09-05T16:59:48Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "635152c7-147a-4047-afd5-5d7d225bc35a",
        "parentId" : "106de221-b96d-4d88-9564-afa533bbb86d",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "One way to make codesize smaller would be to factor this out into top-level functions so you don’t have to inline it into every choice.",
        "createdAt" : "2019-09-05T17:37:52Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d9363a16-314d-4880-a6f3-f3fbb38ef353",
        "parentId" : "106de221-b96d-4d88-9564-afa533bbb86d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That's a good idea. I'll do that in a separate PR.",
        "createdAt" : "2019-09-05T19:48:11Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 71,
    "diffHunk" : "@@ -278,17 +287,24 @@ convertGenericTemplate env x\n     , (tyArgs, args) <- span isTypeArg args\n     , Just tyArgs <- mapM isType_maybe tyArgs\n     , Just (superClassDicts, signatories : observers : ensure : agreement : create : _fetch : archive : keyAndChoices) <- span isSuperClassDict <$> mapM isVar_maybe (dropWhile isTypeArg args)\n-    , Just (polyType, _) <- splitFunTy_maybe (varType create)\n-    , Just (monoTyCon, unwrapCo) <- findMonoTyp polyType\n+    , Just (polyType@(TypeCon polyTyCon _), _) <- splitFunTy_maybe (varType create)\n+    , Just monoTyCon <- findMonoTyp polyType\n     = do\n         let tplLocation = convNameLoc monoTyCon\n-        polyType <- convertType env polyType\n+        Ctors{_cCtors = [Ctor _ fields _]} <- toCtors env polyTyCon\n+        polyType@(TConApp polyTyCon polyTyArgs) <- convertType env polyType\n+        let polyTCA = TypeConApp polyTyCon polyTyArgs\n         monoType@(TCon monoTyCon) <- convertTyCon env monoTyCon\n-        (unwrapTpl, wrapTpl) <- convertCoercion env unwrapCo\n-        let (unwrapCid, wrapCid)\n-                | isReflCo unwrapCo = (id, id)\n+        let monoTCA = TypeConApp monoTyCon []\n+        let coerceRec fromType toType fromExpr =\n+                ELet (Binding (rec, typeConAppToType fromType) fromExpr) $\n+                ERecCon toType $ map (\\field -> (field, ERecProj fromType field (EVar rec))) fields\n+        let (unwrapTpl, wrapTpl, unwrapCid, wrapCid)\n+                | null polyTyArgs = (id, id, id, id)\n                 | otherwise =\n-                    ( ETmApp $ mkETyApps (EBuiltin BECoerceContractId) [monoType, polyType]\n+                    ( coerceRec monoTCA polyTCA"
  },
  {
    "id" : "58d2d68f-2a81-4124-9583-370e93f4def9",
    "prId" : 2779,
    "comments" : [
      {
        "id" : "a1214754-0edd-47fc-a7de-e091e5a8c814",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Do we really have no better way to detect this than to search for an `Instance` suffix? That seems quite easy to fool.",
        "createdAt" : "2019-09-05T17:00:37Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "148d5b72-5883-404c-a8cb-7eaa371bd87b",
        "parentId" : "a1214754-0edd-47fc-a7de-e091e5a8c814",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Right now, I can't thing of any better. My plan is to change the class name from `FooInstance` to `Foo:Instance` or something similar that cannot be written by the user since it doesn't match the lexical rules.",
        "createdAt" : "2019-09-05T19:49:23Z",
        "updatedAt" : "2019-09-10T11:14:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1ad2528d6a9763bf396a1c03fb414d73fa20ebee",
    "line" : 105,
    "diffHunk" : "@@ -403,6 +420,23 @@ convertTypeDef env (ATyCon t)\n   | GHC.moduleNameFS (GHC.moduleName (nameModule (getName t))) == \"DA.Internal.LF\"\n   , getOccFS t `elementOfUniqSet` internalTypes\n   = pure []\n+convertTypeDef env (ATyCon t)\n+    -- NOTE(MH): We detect `newtype` definitions produced by the desugring\n+    -- of `template instance` declarations and inline the record definition\n+    -- of the generic template.\n+    | isNewTyCon t\n+    , ([], TypeCon tpl args) <- newTyConRhs t\n+    , any (\\(c, args') -> getOccFS c == getOccFS tpl <> \"Instance\" && eqTypes args args') $ envInstances env"
  },
  {
    "id" : "1c335971-1179-4601-a360-8f0eca677936",
    "prId" : 2730,
    "comments" : [
      {
        "id" : "65a0b72c-cd1f-41cb-ab5c-91c596291bfc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I liked the way this was factored out into a separate function before.",
        "createdAt" : "2019-09-03T06:49:14Z",
        "updatedAt" : "2019-09-03T06:51:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4d1604d740ba4147cc7704c264ca375e2a788165",
    "line" : 19,
    "diffHunk" : "@@ -235,14 +235,24 @@ convertRational env num denom\n \n convertModule :: LF.Version -> MS.Map UnitId T.Text -> NormalizedFilePath -> CoreModule -> Either FileDiagnostic LF.Module\n convertModule lfVersion pkgMap file x = runConvertM (ConversionEnv file Nothing) $ do\n-    definitions <- concatMapM (convertBind env) $ filter (not . isTypeableInfo) $ cm_binds x\n+    definitions <- concatMapM (convertBind env) binds\n     types <- concatMapM (convertTypeDef env) (eltsUFM (cm_types x))\n     pure (LF.moduleFromDefinitions lfModName (Just $ fromNormalizedFilePath file) flags (types ++ definitions))\n     where\n         ghcModName = GHC.moduleName $ cm_module x\n         thisUnitId = GHC.moduleUnitId $ cm_module x\n         lfModName = convertModuleName ghcModName\n         flags = LF.daml12FeatureFlags\n+        binds =\n+          [ bind\n+          | bindGroup <- cm_binds x\n+          , bind <- case bindGroup of\n+              NonRec name body\n+                -- NOTE(MH): We can't cope with the generated Typeable stuff, so remove those bindings\n+                | any (`T.isPrefixOf` getOccText name) [\"$krep\", \"$tc\", \"$trModule\"] -> []"
  },
  {
    "id" : "50f744c8-9826-48fe-912b-09ca64e2c6d9",
    "prId" : 2730,
    "comments" : [
      {
        "id" : "3e5dcf9d-967c-4cf8-b070-a0d60a9087b8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Much nicer, thanks! `convertBind2` was a pretty bad name :slightly_smiling_face: ",
        "createdAt" : "2019-09-03T06:50:15Z",
        "updatedAt" : "2019-09-03T06:51:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4d1604d740ba4147cc7704c264ca375e2a788165",
    "line" : 55,
    "diffHunk" : "@@ -452,19 +457,15 @@ convertCtors env (Ctors name _ tys cs) = do\n               mkETyLams tys $ mkETmLams (zipExact (map fieldToVar fldNames') fldTys) $ EVariantCon tcon ctorName ctorArg\n \n \n-convertBind :: Env -> CoreBind -> ConvertM [Definition]\n-convertBind env (NonRec name x)\n+convertBind :: Env -> (Var, GHC.Expr Var) -> ConvertM [Definition]\n+convertBind env (name, x)\n     | DFunId _ <- idDetails name\n     , TypeCon (Is tplInst) _ <- varType name\n     , \"Instance\" `T.isSuffixOf` fsToText tplInst\n     = withRange (convNameLoc name) $ do\n         (tmpl, dict) <- convertGenericTemplate env x\n         name' <- convValWithType env name\n         pure [DTemplate tmpl, defValue name name' dict]\n-convertBind env x = convertBind2 env x\n-\n-convertBind2 :: Env -> CoreBind -> ConvertM [Definition]"
  },
  {
    "id" : "1682244c-f4aa-4f61-950b-47d1a6788af7",
    "prId" : 2475,
    "comments" : [
      {
        "id" : "39a73be8-547a-4d08-bdaf-75cc5101b9ef",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@cocreature Unfortunately, comparing with `tupleDataCon Boxed 1` fails although that is exactly what we're looking for. Somehow the uniques don't match. Do you have an _immediate_ idea what could be going wrong?",
        "createdAt" : "2019-08-09T09:45:05Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c224558c-bb08-4906-bcd6-c16ad72d2b0b",
        "parentId" : "39a73be8-547a-4d08-bdaf-75cc5101b9ef",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "@hurryabit Which part exactly is the one that ends up getting a different unique?",
        "createdAt" : "2019-08-09T09:47:29Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "07c4b1c6-b838-40a1-b8d5-87b9d11947dc",
        "parentId" : "39a73be8-547a-4d08-bdaf-75cc5101b9ef",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@cocreature The unique of `con` is different from the unique of `tupleDataCon Boxed 1` even when `con` matches the filter in line 1211. Does that answer your question?",
        "createdAt" : "2019-08-09T10:00:32Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fbbaf626-55c1-4c13-92ac-af5e91c233f0",
        "parentId" : "39a73be8-547a-4d08-bdaf-75cc5101b9ef",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not sure what is going wrong here. Looking at the code, it seems like the unique in `tupleDataCon Boxed 1` should always be fixed so I guess the one in `con` is the one that varies? No idea why :confused: ",
        "createdAt" : "2019-08-09T10:47:50Z",
        "updatedAt" : "2019-08-12T08:50:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7623b54ec5f1094aed76e39eb7b121105c038996",
    "line" : 7,
    "diffHunk" : "@@ -1206,7 +1206,9 @@ ctorLabels flv con =\n     | flv `elem` [ClassFlavour, TupleFlavour Boxed] || isTupleDataCon con\n       -- NOTE(MH): The line below is a workaround for ghc issue\n       -- https://github.com/ghc/ghc/blob/ae4f1033cfe131fca9416e2993bda081e1f8c152/compiler/types/TyCon.hs#L2030\n-      || (getOccFS con == \"Unit\" && GHC.moduleNameFS (GHC.moduleName (nameModule (getName con))) == \"GHC.Tuple\")\n+      -- If we omit this workaround, `GHC.Tuple.Unit` gets translated into a\n+      -- variant rather than a record and the `SugarUnit` test will fail.\n+      || (getOccFS con == \"Unit\" && nameModule (getName con) == gHC_TUPLE)"
  },
  {
    "id" : "1d519476-f040-4529-b81e-85a166197d6f",
    "prId" : 2466,
    "comments" : [
      {
        "id" : "d432f04e-e877-4d8e-9982-39e401e0bb89",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe worth pulling `\\x -> mkVal $ \"$W\" <> x` into a top-level function? Having the assumptions about how GHC calls certain functions factored out into a few top-level functions seems much nicer than having this littered through the code.",
        "createdAt" : "2019-08-08T18:27:44Z",
        "updatedAt" : "2019-08-08T18:30:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6df20b14-600d-4aba-be30-5cda0d22a6f0",
        "parentId" : "d432f04e-e877-4d8e-9982-39e401e0bb89",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Good point. I'll do it in a cleanup PR.",
        "createdAt" : "2019-08-08T18:35:29Z",
        "updatedAt" : "2019-08-08T18:35:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ed4ea23a1498fbba4293b55a70c352da3a1a045",
    "line" : 10,
    "diffHunk" : "@@ -409,11 +409,11 @@ convertTypeDef env x = pure []\n -- here and the `$WFoo` functions generated by GHC. At some point we need to\n -- figure out which ones to keep and which ones to throw away.\n convertCtors :: Env -> Ctors -> ConvertM [Definition]\n-convertCtors env (Ctors name isTypeClass tys [o@(Ctor ctor fldNames fldTys)])\n+convertCtors env (Ctors name flavour tys [o@(Ctor ctor fldNames fldTys)])\n   | isRecordCtor o\n   = pure $ [defDataType tconName tys $ DataRecord flds] ++\n-      [ defValue name (mkVal $ \"$ctor:\" <> getOccText ctor, mkTForalls tys $ mkTFuns fldTys (typeConAppToType tcon)) expr\n-      | not isTypeClass\n+      [ defValue name (mkVal $ \"$W\" <> getOccText ctor, mkTForalls tys $ mkTFuns fldTys (typeConAppToType tcon)) expr"
  },
  {
    "id" : "3a1f05dd-1e8f-494a-b956-b512f0e2e373",
    "prId" : 2252,
    "comments" : [
      {
        "id" : "489f7a84-7ef5-4bae-a519-9237512f1be5",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Nit\r\n```suggestion\r\n    -- `_fetchByKeyX` and `_lookupByKeyX`\r\n```",
        "createdAt" : "2019-07-22T17:54:06Z",
        "updatedAt" : "2019-07-22T18:43:01Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1ec6165deb0faf1702d6f6f401167b326dc97c95",
    "line" : null,
    "diffHunk" : "@@ -608,15 +608,16 @@ convertBind2 env (NonRec name x)\n     , is name `elem` internals\n     = pure []\n     -- NOTE(MH): Desugaring `template X` will result in a type class\n-    -- `XInstance` which has methods `createX`, `fetchX` and `exerciseXY`\n+    -- `XInstance` which has methods `_createX`, `_fetchX`, `_exerciseXY`,\n+    -- `fetchByKeyX` and `lokkupByKeyX`"
  },
  {
    "id" : "f09f1d4d-6265-456a-a4af-fdb257d4b4d8",
    "prId" : 2249,
    "comments" : [
      {
        "id" : "04605d1f-ca48-4cea-90e4-35cd6833d795",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Now `_createX` etc",
        "createdAt" : "2019-07-22T16:22:29Z",
        "updatedAt" : "2019-07-22T16:43:15Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0f35d92cf0b18616e2341e0b92ac7330dd26a60b",
    "line" : 5,
    "diffHunk" : "@@ -607,6 +607,17 @@ convertBind2 env (NonRec name x)\n     | Just internals <- MS.lookup (envGHCModuleName env) (internalFunctions $ envLfVersion env)\n     , is name `elem` internals\n     = pure []\n+    -- NOTE(MH): Desugaring `template X` will result in a type class\n+    -- `XInstance` which has methods `createX`, `fetchX` and `exerciseXY`"
  }
]