[
  {
    "id" : "b12c083c-e44c-4d5b-814e-cb54027956a0",
    "prId" : 7815,
    "comments" : [
      {
        "id" : "26a3a25c-ce53-4d6e-b937-fc379e72d736",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n-- MINIMAL PRAGMAS --\r\n```\r\nJust to make it slightly more explicit what this is about.",
        "createdAt" : "2020-10-27T14:35:33Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a443aff9-b09d-43f0-a803-586b5a998cbe",
        "parentId" : "26a3a25c-ce53-4d6e-b937-fc379e72d736",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Will do, thanks!",
        "createdAt" : "2020-10-27T15:05:37Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "323977ef2324d231a554726a69744fffb86d151b",
    "line" : null,
    "diffHunk" : "@@ -82,6 +93,40 @@ mapFunDep f (a, b) = (map f a, map f b)\n mapFunDepM :: Monad m => (a -> m b) -> (GHC.FunDep a -> m (GHC.FunDep b))\n mapFunDepM f (a, b) = liftM2 (,) (mapM f a) (mapM f b)\n \n+-------------\n+-- MINIMAL --"
  },
  {
    "id" : "b93c4dab-6f56-4360-a80b-4675f18fe71c",
    "prId" : 7815,
    "comments" : [
      {
        "id" : "0cd576f9-5769-47b6-a5e7-a9d044edf365",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I spent an embarrassing amount of time getting confused by the name `TCon` which is something very different from `LF.TCon`. How about calling this something like `EncodedTCon`?",
        "createdAt" : "2020-10-27T14:47:03Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3708d7ce-a5a1-4fc3-a77c-fae7885b4e0e",
        "parentId" : "0cd576f9-5769-47b6-a5e7-a9d044edf365",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Ah, yeah, that is a good point!",
        "createdAt" : "2020-10-27T15:02:53Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "323977ef2324d231a554726a69744fffb86d151b",
    "line" : null,
    "diffHunk" : "@@ -82,6 +93,40 @@ mapFunDep f (a, b) = (map f a, map f b)\n mapFunDepM :: Monad m => (a -> m b) -> (GHC.FunDep a -> m (GHC.FunDep b))\n mapFunDepM f (a, b) = liftM2 (,) (mapM f a) (mapM f b)\n \n+-------------\n+-- MINIMAL --\n+-------------\n+\n+minimalName :: LF.TypeSynName -> LF.ExprValName\n+minimalName (LF.TypeSynName xs) = LF.ExprValName (\"$$minimal\" <> T.concat xs)\n+\n+pattern TStr :: T.Text -> LF.Type\n+pattern TStr x = LF.TStruct [(LF.FieldName x, LF.TUnit)]\n+\n+pattern TCon :: T.Text -> LF.Type -> LF.Type\n+pattern TCon a b = LF.TStruct [(LF.FieldName a, b)]\n+\n+encodeLBooleanFormula :: BF.LBooleanFormula T.Text -> LF.Type\n+encodeLBooleanFormula = encodeBooleanFormula . GHC.unLoc\n+\n+decodeLBooleanFormula :: LF.Type -> Maybe (BF.LBooleanFormula T.Text)\n+decodeLBooleanFormula = fmap GHC.noLoc . decodeBooleanFormula\n+\n+encodeBooleanFormula :: BF.BooleanFormula T.Text -> LF.Type\n+encodeBooleanFormula = \\case\n+    BF.Var x -> TCon \"Var\" (TStr x)"
  },
  {
    "id" : "91a5f7b9-5540-44df-9f2d-a9b90229d7f1",
    "prId" : 7815,
    "comments" : [
      {
        "id" : "023a95d4-390a-4ea4-842d-e4a343964253",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The MINIMAL pragma can be loaded with arbitrary positive Boolean formulae? Wow, I didn't know that. It's also a bit scary. What do you think about \"flattening\" the formula into disjunctive normal form and encode the result as a list of lists of strings? I would assume the blowup coming with conversion to DNF doesn't matter here in practice and it would allow us to drop the `And`, `Or`, and `Parens` thingies.",
        "createdAt" : "2020-10-27T16:06:09Z",
        "updatedAt" : "2020-10-28T09:48:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "947b26fb-087a-45ac-bf2f-3b746565714f",
        "parentId" : "023a95d4-390a-4ea4-842d-e4a343964253",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Yeah. I think I prefer to leave the boolean formulas in place. GHC already does some simplifying, but it doesn't go full DNF for good reasons, I assume (e.g. better error messages). Also I don't want to risk introducing new errors by normalizing the boolean formula incorrectly.",
        "createdAt" : "2020-10-28T09:51:42Z",
        "updatedAt" : "2020-10-28T09:51:42Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "323977ef2324d231a554726a69744fffb86d151b",
    "line" : 69,
    "diffHunk" : "@@ -82,6 +93,40 @@ mapFunDep f (a, b) = (map f a, map f b)\n mapFunDepM :: Monad m => (a -> m b) -> (GHC.FunDep a -> m (GHC.FunDep b))\n mapFunDepM f (a, b) = liftM2 (,) (mapM f a) (mapM f b)\n \n+---------------------\n+-- MINIMAL PRAGMAS --\n+---------------------\n+\n+minimalName :: LF.TypeSynName -> LF.ExprValName\n+minimalName (LF.TypeSynName xs) = LF.ExprValName (\"$$minimal\" <> T.concat xs)\n+\n+pattern TEncodedStr :: T.Text -> LF.Type\n+pattern TEncodedStr x = LF.TStruct [(LF.FieldName x, LF.TUnit)]\n+\n+pattern TEncodedCon :: T.Text -> LF.Type -> LF.Type\n+pattern TEncodedCon a b = LF.TStruct [(LF.FieldName a, b)]\n+\n+encodeLBooleanFormula :: BF.LBooleanFormula T.Text -> LF.Type\n+encodeLBooleanFormula = encodeBooleanFormula . GHC.unLoc\n+\n+decodeLBooleanFormula :: LF.Type -> Maybe (BF.LBooleanFormula T.Text)\n+decodeLBooleanFormula = fmap GHC.noLoc . decodeBooleanFormula\n+\n+encodeBooleanFormula :: BF.BooleanFormula T.Text -> LF.Type"
  }
]