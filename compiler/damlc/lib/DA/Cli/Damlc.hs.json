[
  {
    "id" : "c2667e76-2572-4440-a6d2-c0babab6b6a2",
    "prId" : 7466,
    "comments" : [
      {
        "id" : "9f2f7c39-aa1a-448d-b3e1-7ac52a75af41",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n       progDesc \"Deprecated. Compile the DAML program into a DAR\"\r\n```\r\nThis is consistent with the format @bame-da introduced in https://github.com/digital-asset/daml/pull/7458/files.",
        "createdAt" : "2020-09-23T12:47:58Z",
        "updatedAt" : "2020-09-24T09:44:50Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3e6546a9e07f9fb8c292cc9d6fc4cc2f4cd61b55",
    "line" : 5,
    "diffHunk" : "@@ -361,7 +361,7 @@ cmdInit numProcessors =\n cmdPackage :: Int -> Mod CommandFields Command\n cmdPackage numProcessors =\n     command \"package\" $ info (helper <*> cmd) $\n-       progDesc \"Compile the DAML program into a DAML Archive (DAR)\"\n+       progDesc \"Compile the DAML program into a DAR (deprecated)\""
  },
  {
    "id" : "3b084aca-c5bf-4772-a2e0-1d417888d6aa",
    "prId" : 6707,
    "comments" : [
      {
        "id" : "be5993a3-1d21-4b0f-aab6-00a97d799b79",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not for this PR but we can and imho should change that to `many`.",
        "createdAt" : "2020-07-13T15:29:09Z",
        "updatedAt" : "2020-07-14T10:14:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d849d136-5b7b-4179-b288-b8ac2bc725c8",
        "parentId" : "be5993a3-1d21-4b0f-aab6-00a97d799b79",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/6710",
        "createdAt" : "2020-07-13T15:55:42Z",
        "updatedAt" : "2020-07-14T10:14:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2f4a5b241cc9a50a4f78cae3c4538f5f1e87352d",
    "line" : null,
    "diffHunk" : "@@ -261,6 +261,7 @@ cmdRepl numProcessors =\n             <*> strOption (long \"script-lib\" <> value \"daml-script\" <> internal)\n             -- ^ This is useful for tests and `bazel run`.\n             <*> some (strArgument (help \"DAR to load in the repl\" <> metavar \"DAR\"))"
  },
  {
    "id" : "42c6bc01-78c9-4440-bd59-5fcc91f54750",
    "prId" : 6485,
    "comments" : [
      {
        "id" : "7308ad2b-0430-41c5-bafc-61d01043eee8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n            , help \"Use wall clock time (UTC). (this is the default)\"\r\n```",
        "createdAt" : "2020-06-25T10:29:49Z",
        "updatedAt" : "2020-06-25T12:43:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "787fa9e2d1e70e3404d4996d48837692a91ae6f2",
    "line" : null,
    "diffHunk" : "@@ -304,6 +305,19 @@ cmdRepl numProcessors =\n                 , clientMetadataPlugin = Nothing\n                 }\n \n+    timeModeFlag :: Parser ReplClient.ReplTimeMode\n+    timeModeFlag =\n+        (flag' ReplClient.ReplWallClock $ mconcat\n+            [ short 'w'\n+            , long \"wall-clock-time\"\n+            , help \"Use wall clock time (UTC).\""
  },
  {
    "id" : "2571acd6-3503-4137-bf06-869561a9a2fd",
    "prId" : 4678,
    "comments" : [
      {
        "id" : "7ebfce69-d20b-4afe-a1d2-a13929c01704",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "\"REPL\" is typically all caps; [it's an acronym](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop). Can I suggest using \"REPL\" everywhere user-facing rather than \"Repl\" or \"repl\"?",
        "createdAt" : "2020-02-25T10:27:26Z",
        "updatedAt" : "2020-02-25T10:34:16Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "df9c8838-34bc-4288-883e-1e0495ce5b58",
        "parentId" : "7ebfce69-d20b-4afe-a1d2-a13929c01704",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I actually looked this up and got mislead by `Repl.it` thinking that this is the spelling people commonly use. I’ve changed it now.",
        "createdAt" : "2020-02-25T10:34:19Z",
        "updatedAt" : "2020-02-25T10:34:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b21c5b7de3be97ac61e682ccdccf0039435ea754",
    "line" : null,
    "diffHunk" : "@@ -252,16 +252,17 @@ cmdBuild numProcessors =\n \n cmdRepl :: Int -> Mod CommandFields Command\n cmdRepl numProcessors =\n-    command \"repl\" $\n-    info (helper <*> cmd) fullDesc\n+    command \"repl\" $ info (helper <*> cmd) $\n+    progDesc \"Launch the DAML Repl.\" <>"
  },
  {
    "id" : "6a779e86-b3b9-4b18-867b-27c25a10db9c",
    "prId" : 4660,
    "comments" : [
      {
        "id" : "6aeff441-04e7-4c54-8995-b0eeaa3c233e",
        "parentId" : null,
        "author" : null,
        "body" : "It might be nice to add the rest of the project's dependencies/data-dependencies as well (if we're in a project), in the future.",
        "createdAt" : "2020-02-24T09:45:16Z",
        "updatedAt" : "2020-02-24T10:04:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "8aa2901b-5562-4008-82d4-ff9006eb9a7b",
        "parentId" : "6aeff441-04e7-4c54-8995-b0eeaa3c233e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yeah, either that or at least add CLI flags for adding new dependencies/data-dependencies. We also need to support adding imports.",
        "createdAt" : "2020-02-24T10:06:20Z",
        "updatedAt" : "2020-02-24T10:06:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "760346aad542cb7fd96ef1141ec51bc525702a51",
    "line" : 73,
    "diffHunk" : "@@ -576,6 +595,35 @@ execBuild projectOpts opts mbOutFile incrementalBuild initPkgDb =\n             where\n                 targetFilePath name = fromMaybe (distDir </> name <.> \"dar\") mbOutFile\n \n+execRepl :: ProjectOpts -> Options -> FilePath -> FilePath -> String -> String -> Command\n+execRepl projectOpts opts scriptDar mainDar ledgerHost ledgerPort = Command Repl (Just projectOpts) effect\n+  where effect = do\n+            opts <- pure opts\n+                { optDlintUsage = DlintDisabled\n+                , optScenarioService = EnableScenarioService False\n+                }\n+            logger <- getLogger opts \"repl\"\n+            runfilesDir <- locateRunfiles (mainWorkspace </> \"compiler/repl-service/server\")\n+            let jar = runfilesDir </> \"repl-service.jar\"\n+            ReplClient.withReplClient (ReplClient.Options jar ledgerHost ledgerPort) $ \\replHandle ->\n+                withTempDir $ \\dir ->\n+                withCurrentDirectory dir $ do\n+                sdkVer <- fromMaybe SdkVersion.sdkVersion <$> lookupEnv sdkVersionEnvVar\n+                writeFileUTF8 \"daml.yaml\" $ unlines\n+                    [ \"sdk-version: \" <> sdkVer\n+                    , \"name: repl\"\n+                    , \"version: 0.0.1\"\n+                    , \"source: .\"\n+                    , \"dependencies:\""
  },
  {
    "id" : "1950d6f9-734d-4204-af89-6c808300e65b",
    "prId" : 4648,
    "comments" : [
      {
        "id" : "90bf7410-957a-4299-ba91-07fc03c5e7fe",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Note that this is not actually changing anything, it just makes it a bit more explicit. I thought you might be able to inject `version: null` in a `daml.yaml` but the check in `queryProjectConfigRequired` treats `null` and the absence of a field identical.",
        "createdAt" : "2020-02-21T10:35:35Z",
        "updatedAt" : "2020-02-21T10:35:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8afff54f07edf4c4983b62e012c1bf961f504ef9",
    "line" : 5,
    "diffHunk" : "@@ -482,7 +482,7 @@ parseProjectConfig project = do\n     pName <- queryProjectConfigRequired [\"name\"] project\n     pSrc <- queryProjectConfigRequired [\"source\"] project\n     pExposedModules <- queryProjectConfig [\"exposed-modules\"] project\n-    pVersion <- queryProjectConfigRequired [\"version\"] project\n+    pVersion <- Just <$> queryProjectConfigRequired [\"version\"] project"
  },
  {
    "id" : "971e25df-b82c-46eb-9429-413ec6f5e84a",
    "prId" : 4513,
    "comments" : [
      {
        "id" : "de600c00-2e6c-4ca2-8738-0eb32dc1890b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\ngetSdkVersion :: ProjectConfig -> Either ConfigError PackageSdkVersion\r\n```\r\nGiven that the `daml.yaml` has both an `sdk-version` field and a `version` field for the version of your project, `getVersion` is slightly confusing.",
        "createdAt" : "2020-02-19T10:12:35Z",
        "updatedAt" : "2020-02-25T14:08:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f4ec7eb7-3894-404c-86f9-431ec36f2221",
        "parentId" : "de600c00-2e6c-4ca2-8738-0eb32dc1890b",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Will update, thanks.",
        "createdAt" : "2020-02-19T12:36:42Z",
        "updatedAt" : "2020-02-25T14:08:02Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7224e4d1-ccf3-455b-819a-07bfb2e10dba",
        "parentId" : "de600c00-2e6c-4ca2-8738-0eb32dc1890b",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "I've ended up completely restructuring this; I don't think the new approach introduces any confusing name.",
        "createdAt" : "2020-02-24T19:03:09Z",
        "updatedAt" : "2020-02-25T14:08:02Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "81246bd2733ace93653cb663dca5a0cdaf7c11e9",
    "line" : null,
    "diffHunk" : "@@ -476,6 +476,24 @@ execLint inputFile opts =\n          DlintEnabled _ _ -> opts\n          DlintDisabled  -> opts{optDlintUsage=DlintEnabled defaultDir True}\n \n+-- | Gets a ghc_pkg-compatible version string\n+--\n+-- The DAML SDK uses semantic versioning, while internally we need a version\n+-- string that ghc_pkg can understand. We do that by removing the `-alpha`\n+-- qualifier when present.\n+--\n+-- Expected version strings:\n+-- 0.13.51 -> release, no change\n+-- 0.13.51-alpha.20200212.3024.04e6fa2c -> alpha release, change to\n+         --                                0.13.51.20200212.3024 internally\n+getVersion :: ProjectConfig -> Either ConfigError PackageSdkVersion"
  },
  {
    "id" : "1fc73788-2dba-420a-a1ba-0a1946eca3ba",
    "prId" : 4391,
    "comments" : [
      {
        "id" : "edcaafa7-97f9-4a3c-a420-d60335aa7e17",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This breaks `--init-package-db=no`. We need to get the unit ids of the dependencies even if we are not reinitializing the package db. So the flag should probably be passed on to `createProjectPackageDb` which then always returns the unit ids but skips actually overwriting the package db. Given that we haven’t really advertised `--init-package-db=no` and #4413 should make it redundant, we might be able to just break it for now and handle it in a separate PR.",
        "createdAt" : "2020-02-11T09:08:49Z",
        "updatedAt" : "2020-02-18T11:12:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b9aa2d5-3823-45f3-8cb6-455bbf171162",
        "parentId" : "edcaafa7-97f9-4a3c-a420-d60335aa7e17",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "this issue still needs to be resolved...",
        "createdAt" : "2020-02-11T22:15:48Z",
        "updatedAt" : "2020-02-18T11:12:21Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6225cdba-f615-4d0d-9f8d-b1f9c2da1ac4",
        "parentId" : "edcaafa7-97f9-4a3c-a420-d60335aa7e17",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "The changes were removed from `Damlc.hs`, so nothing to do here",
        "createdAt" : "2020-02-17T20:59:00Z",
        "updatedAt" : "2020-02-18T11:12:21Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "e29eddf5d338724158422a9fd62bf47e4131c5c1",
    "line" : null,
    "diffHunk" : "@@ -518,18 +520,27 @@ withPackageConfig projectPath f = do\n execInit :: Options -> ProjectOpts -> Command\n execInit opts projectOpts =\n   Command Init (Just projectOpts) effect\n-  where effect = withProjectRoot' projectOpts $ \\_relativize ->\n-          initPackageDb\n+  where effect = withProjectRoot' projectOpts $ \\_relativize -> do\n+          _ <- initPackageDb\n             opts\n             (InitPkgDb True)\n+          return ()\n \n-initPackageDb :: Options -> InitPkgDb -> IO ()\n+initPackageDb :: Options -> InitPkgDb -> IO [UnitId]\n initPackageDb opts (InitPkgDb shouldInit) =\n-    when shouldInit $ do\n+    if shouldInit\n+    then do\n         isProject <- doesFileExist projectConfigName\n-        when isProject $ do\n+        if isProject then do\n             withPackageConfig defaultProjectPath $ \\PackageConfigFields {..} ->\n                 createProjectPackageDb opts pSdkVersion pDependencies pDataDependencies\n+        else\n+           return []\n+    else\n+      return []"
  },
  {
    "id" : "fc0a7866-5d2b-4528-8d4c-44610cdc89da",
    "prId" : 4336,
    "comments" : [
      {
        "id" : "fc454534-ae07-4155-9deb-d950206c6e0b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yeah, that’s off. You should be able to get the dependencies from `GeneratePackageMap`. That said, this command is only for debugging (and tbh I don’t even use it for that) so I’m fine with addressing this separately.",
        "createdAt" : "2020-02-03T08:18:28Z",
        "updatedAt" : "2020-02-03T11:00:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cda5e2e9-8771-47d1-995c-d5cd0a45e24b",
        "parentId" : "fc454534-ae07-4155-9deb-d950206c6e0b",
        "author" : null,
        "body" : "ok, I'm using those package ids for the dependencies here. :-)",
        "createdAt" : "2020-02-03T11:14:09Z",
        "updatedAt" : "2020-02-03T11:14:09Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f7a75365b89d256e55bf0795b4284729c3b038de",
    "line" : null,
    "diffHunk" : "@@ -827,7 +827,15 @@ execGenerateSrc opts dalfOrDar mbOutDir = Command GenerateSrc Nothing effect\n             stablePkgIds :: Set.Set LF.PackageId\n             stablePkgIds = Set.fromList $ map LF.dalfPackageId $ MS.elems stableDalfPkgMap\n \n-            genSrcs = generateSrcPkgFromLf pkgMap (getUnitId unitId unitIdMap) stablePkgIds (Just \"CurrentSdk\") pkg\n+            config = DataDeps.Config\n+                { configPackages = pkgMap\n+                , configGetUnitId = getUnitId unitId unitIdMap\n+                , configStablePackages = stablePkgIds\n+                , configDependencyPackages = Set.empty -- this isn't right, is it?"
  },
  {
    "id" : "099756b8-f24c-4133-8426-56365d4782b6",
    "prId" : 4213,
    "comments" : [
      {
        "id" : "810a4cfa-0ad6-41c3-9ac5-f68e6cbe22cc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@cocreature Is this too permissive? What's the right place to add tests for this?",
        "createdAt" : "2020-01-24T22:43:47Z",
        "updatedAt" : "2020-01-28T15:01:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6599201c-cc70-42fd-b29b-0be0e150605b",
        "parentId" : "810a4cfa-0ad6-41c3-9ac5-f68e6cbe22cc",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Should be fine I think. I don’t see any options that are less useful for `damlc ide` than they are for `damlc build`. Not sure what good tests for this would be. We have tests for the config parser but I think the parser is not the issue here. I guess you could extend the LSP tests to check different flag combinations but I’m fine to not have tests for this now.",
        "createdAt" : "2020-01-24T22:48:40Z",
        "updatedAt" : "2020-01-28T15:01:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ba81e7635187faae2df66e955a5426793eb7a1df",
    "line" : 18,
    "diffHunk" : "@@ -126,9 +126,7 @@ cmdIde =\n         <$> telemetryOpt\n         <*> debugOpt\n         <*> enableScenarioOpt\n-        <*> optGhcCustomOptions\n-        <*> shakeProfilingOpt\n-        <*> optional lfVersionOpt\n+        <*> optionsParser numProcessors (EnableScenarioService True) (pure Nothing)"
  },
  {
    "id" : "88c1a0c3-7754-4df3-9f6f-9782b4f1ddea",
    "prId" : 4213,
    "comments" : [
      {
        "id" : "7063bd4f-206b-4d22-8e77-6e38252d15b8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You are missing a call to `mkOptions` before calling this which is probably the reason why none of the modules in the standard library are found (yes this API is horrible).",
        "createdAt" : "2020-01-27T09:43:32Z",
        "updatedAt" : "2020-01-28T15:01:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ba81e7635187faae2df66e955a5426793eb7a1df",
    "line" : null,
    "diffHunk" : "@@ -382,24 +378,24 @@ execIde telemetry (Debug debug) enableScenarioService ghcOpts mbProfileDir (from\n                       Logger.GCP.logOptOut gcpState\n                       f loggerH\n                   Undecided -> f loggerH\n-          opts <- defaultOptionsIO (Just lfVersion)\n-          initPackageDb opts (InitPkgDb True)\n-          dlintDataDir <-locateRunfiles $ mainWorkspace </> \"compiler/damlc/daml-ide-core\"\n-          opts <- pure $ opts\n+          initPackageDb options (InitPkgDb True)"
  },
  {
    "id" : "25656e03-6c4d-499f-83ee-bcb3242a098b",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "621a6b9d-957d-4d4e-8944-915289d81930",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not necessary to address this in this PR but some type signatures for these maps might be nice.",
        "createdAt" : "2020-01-27T09:36:15Z",
        "updatedAt" : "2020-01-27T09:37:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 18,
    "diffHunk" : "@@ -806,14 +806,27 @@ execGenerateSrc opts dalfOrDar mbOutDir = Command GenerateSrc Nothing effect\n         (pkgId, pkg) <- decode bytes\n         opts <- mkOptions opts\n         logger <- getLogger opts \"generate-src\"\n-        (pkgMap0, stablePkgIds) <- withDamlIdeState opts { optScenarioService = EnableScenarioService False } logger diagnosticsLogger $ \\ideState -> runAction ideState $ do\n-          pkgs <-\n-              MS.fromList . map (\\(unitId, dalfPkg) -> (LF.dalfPackageId dalfPkg, unitId)) . MS.toList <$>\n-              useNoFile_ GeneratePackageMap\n-          stablePkgIds <- fmap (MS.fromList . map (\\(k, pkg) -> (LF.dalfPackageId pkg, k)) . MS.toList) (useNoFile_ GenerateStablePackages)\n-          pure (pkgs `MS.union` MS.map fst stablePkgIds, stablePkgIds)\n-        let pkgMap = MS.insert pkgId unitId pkgMap0\n-        let genSrcs = generateSrcPkgFromLf (getUnitId unitId pkgMap) stablePkgIds (Just \"CurrentSdk\") pkg\n+\n+        (dalfPkgMap, stableDalfPkgMap) <- withDamlIdeState opts { optScenarioService = EnableScenarioService False } logger diagnosticsLogger $ \\ideState -> runAction ideState $ do\n+            dalfPkgMap <- useNoFile_ GeneratePackageMap\n+            stableDalfPkgMap <- useNoFile_ GenerateStablePackages\n+            pure (dalfPkgMap, stableDalfPkgMap)\n+\n+        let allDalfPkgs ="
  },
  {
    "id" : "f3382857-e7f0-4b53-ba34-608eeb1f65bf",
    "prId" : 4051,
    "comments" : [
      {
        "id" : "8c4419c0-b25f-4704-b929-5e5bde314b9b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n-- | Given a path to a .dalf or a .dar return the bytes of either the .dalf file\r\n```",
        "createdAt" : "2020-01-15T10:12:14Z",
        "updatedAt" : "2020-01-15T10:15:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8070c0fdb1b2bbc5b95267b94fb75adedc260b6a",
    "line" : null,
    "diffHunk" : "@@ -627,19 +627,25 @@ execPackage projectOpts filePath opts mbOutFile dalfInput =\n \n     targetFilePath = fromMaybe defaultDarFile mbOutFile\n \n+-- | Given a path to a .dalf or a .dar either return either the bytes of the .dalf file"
  },
  {
    "id" : "5d10ff1c-6281-4bd5-82ff-7ed318a6c04f",
    "prId" : 4051,
    "comments" : [
      {
        "id" : "d67df5be-b793-46c2-b668-7ff04038d8fe",
        "parentId" : null,
        "author" : null,
        "body" : "Surprised `either fail pure` isn't in extra. It's `requiredE` in the assistant codebase (± exception handling details), but that is neither here nor there.",
        "createdAt" : "2020-01-15T11:05:51Z",
        "updatedAt" : "2020-01-15T11:06:04Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "8070c0fdb1b2bbc5b95267b94fb75adedc260b6a",
    "line" : 13,
    "diffHunk" : "@@ -627,19 +627,25 @@ execPackage projectOpts filePath opts mbOutFile dalfInput =\n \n     targetFilePath = fromMaybe defaultDarFile mbOutFile\n \n+-- | Given a path to a .dalf or a .dar return the bytes of either the .dalf file\n+-- or the the main dalf from the .dar\n+-- In addition to the bytes, we also return the basename of the dalf file.\n+getDalfBytes :: FilePath -> IO (B.ByteString, FilePath)\n+getDalfBytes fp\n+  | \"dar\" `isExtensionOf` fp = do\n+        dar <- B.readFile fp\n+        let archive = ZipArchive.toArchive $ BSL.fromStrict dar\n+        manifest <- either fail pure $ readDalfManifest archive\n+        dalfs <- either fail pure $ readDalfs archive"
  },
  {
    "id" : "79f5fcfc-4b89-4fa7-930b-4453ae42cb16",
    "prId" : 4025,
    "comments" : [
      {
        "id" : "313b46c6-1224-4951-8b88-54da25199b7c",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Maybe call `envProjectPath` `mbEnvProjectPath`, and name `projectRoot =<< ...` as `mbOptProjectPath` to make this a little more obvious to read?",
        "createdAt" : "2020-01-13T14:19:09Z",
        "updatedAt" : "2020-01-13T14:25:09Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "95be2642-93f2-4bc0-aa6d-032b2eb2049b",
        "parentId" : "313b46c6-1224-4951-8b88-54da25199b7c",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "good idea! changed",
        "createdAt" : "2020-01-13T14:25:15Z",
        "updatedAt" : "2020-01-13T14:25:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b949c6ac1ca9b32fff6c405e3a5d1f5315546189",
    "line" : null,
    "diffHunk" : "@@ -916,10 +918,14 @@ parserInfo numProcessors =\n         ])\n     )\n \n-cliArgsFromDamlYaml :: IO [String]\n-cliArgsFromDamlYaml = do\n+cliArgsFromDamlYaml :: Maybe ProjectOpts -> IO [String]\n+cliArgsFromDamlYaml mbProjectOpts = do\n+    -- This is the same logic used in withProjectRoot but we don’t need to change CWD here\n+    -- and this is simple enough so we inline it here.\n+    envProjectPath <- fmap ProjectPath <$> getProjectPath\n+    let projectPath = fromMaybe (ProjectPath \".\") ((projectRoot =<< mbProjectOpts) <|> envProjectPath)"
  },
  {
    "id" : "8c0ae2f2-86ef-4211-8401-04da1b327e04",
    "prId" : 3587,
    "comments" : [
      {
        "id" : "71eabc61-242b-4f19-a00a-0e38d56a0b8f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This looks like `sdk-version` is now no longer required if the environment variable is set. Is this intended? I think it’s probably better to always enforce it to exist and maybe emit a warning if it is being overwritten by the environment variable.",
        "createdAt" : "2019-11-22T13:54:25Z",
        "updatedAt" : "2019-11-22T15:48:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "77f71a26-b8f7-403d-877e-3d74880d3d0d",
        "parentId" : "71eabc61-242b-4f19-a00a-0e38d56a0b8f",
        "author" : null,
        "body" : "That sounds like a better idea. I'll make it so.",
        "createdAt" : "2019-11-22T14:12:19Z",
        "updatedAt" : "2019-11-22T15:48:02Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bfe363dc238d3f0e67fabb145355ec9a22f98ecd",
    "line" : null,
    "diffHunk" : "@@ -457,24 +458,23 @@ execLint inputFile opts =\n          DlintDisabled  -> opts{optDlintUsage=DlintEnabled defaultDir True}\n \n -- | Parse the daml.yaml for package specific config fields.\n-parseProjectConfig :: ProjectConfig -> Either ConfigError PackageConfigFields\n-parseProjectConfig project = do\n-    name <- queryProjectConfigRequired [\"name\"] project\n-    main <- queryProjectConfigRequired [\"source\"] project\n-    exposedModules <- queryProjectConfig [\"exposed-modules\"] project\n-    version <- queryProjectConfigRequired [\"version\"] project\n-    dependencies <-\n-        queryProjectConfigRequired [\"dependencies\"] project\n-    dataDeps <- fromMaybe [] <$> queryProjectConfig [\"data-dependencies\"] project\n-    sdkVersion <- queryProjectConfigRequired [\"sdk-version\"] project\n-    cliOpts <- queryProjectConfig [\"build-options\"] project\n-    Right $ PackageConfigFields name main exposedModules version dependencies dataDeps sdkVersion cliOpts\n+parseProjectConfig :: Maybe PackageSdkVersion -> ProjectConfig -> Either ConfigError PackageConfigFields\n+parseProjectConfig sdkVersionM project = do\n+    pName <- queryProjectConfigRequired [\"name\"] project\n+    pSrc <- queryProjectConfigRequired [\"source\"] project\n+    pExposedModules <- queryProjectConfig [\"exposed-modules\"] project\n+    pVersion <- queryProjectConfigRequired [\"version\"] project\n+    pDependencies <- queryProjectConfigRequired [\"dependencies\"] project\n+    pDataDependencies <- fromMaybe [] <$> queryProjectConfig [\"data-dependencies\"] project\n+    pSdkVersion <- maybe (queryProjectConfigRequired [\"sdk-version\"] project) Right sdkVersionM"
  },
  {
    "id" : "16b76dfd-8677-4e62-8c20-a4625e881bbb",
    "prId" : 3503,
    "comments" : [
      {
        "id" : "173f2c1f-e375-4daa-bc9d-a2976499f7d5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We should come up with a better syntax for those flags or just give up and accept them as JSON or something like that. Fine to do that separately given that I hope nobody specifies this manually :slightly_smiling_face: ",
        "createdAt" : "2019-11-18T12:29:51Z",
        "updatedAt" : "2019-11-18T20:20:05Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3c94fae8-0302-4efb-b026-24adaa956804",
        "parentId" : "173f2c1f-e375-4daa-bc9d-a2976499f7d5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "my favourite option would be to just use the ghc `package-id` flag and pass it through as ghc option.",
        "createdAt" : "2019-11-18T14:08:51Z",
        "updatedAt" : "2019-11-18T20:20:05Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e11899fa2735e5f9588b587ccc13106f6598a88d",
    "line" : 6,
    "diffHunk" : "@@ -688,8 +688,8 @@ execMigrate projectOpts inFile1_ inFile2_ mbDir =\n                   (NM.names $ LF.packageModules lfPkg2)\n           let eqModNamesStr = map (T.unpack . LF.moduleNameString) eqModNames\n           let buildOptions =\n-                  [ \"'--package=\" <> show (\"instances-\" <> pkgName1, [(m, m ++ \"A\") | m <- eqModNamesStr]) <> \"'\"\n-                  , \"'--package=\" <> show (\"instances-\" <> pkgName2, [(m, m ++ \"B\") | m <- eqModNamesStr]) <> \"'\"\n+                  [ \"'--package=\" <> show (\"instances-\" <> pkgName1, True, [(m, m ++ \"A\") | m <- eqModNamesStr]) <> \"'\""
  },
  {
    "id" : "e1dec67d-52d9-426c-a6cd-e2566f7ad409",
    "prId" : 3441,
    "comments" : [
      {
        "id" : "26e8f3d9-8df4-47a8-aca1-c76f240be273",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Is this a typo or is \"dalm\" a thing?",
        "createdAt" : "2019-11-13T09:24:26Z",
        "updatedAt" : "2019-11-19T15:10:10Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6611354a-9ef7-4c4c-935a-cb35d1ce2ef3",
        "parentId" : "26e8f3d9-8df4-47a8-aca1-c76f240be273",
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Can I propose test cases? 🙃 ",
        "createdAt" : "2019-11-13T09:24:59Z",
        "updatedAt" : "2019-11-19T15:10:10Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eff993c856bef39dda178c0b0ca7b3cc76f89f26",
    "line" : null,
    "diffHunk" : "@@ -1294,3 +1323,76 @@ main = do\n withProjectRoot' :: ProjectOpts -> ((FilePath -> IO FilePath) -> IO a) -> IO a\n withProjectRoot' ProjectOpts{..} act =\n     withProjectRoot projectRoot projectCheck (const act)\n+\n+daml2ts :: LF.PackageId -> LF.Package -> IO ()\n+daml2ts _pkgId pkg = do\n+    forM_ (LF.packageModules pkg) $ \\mod -> do\n+        T.putStrLn (genModule mod)\n+  where\n+    genModule :: LF.Module -> T.Text\n+    genModule mod = T.unlines $\n+        [\"// \" <> T.intercalate \"/\" (LF.unModuleName (LF.moduleName mod))]\n+        ++ concatMap (genDefDataType (LF.moduleName mod)) (LF.moduleDataTypes mod)\n+\n+    genDefDataType :: LF.ModuleName -> LF.DefDataType -> [T.Text]\n+    genDefDataType curModName def\n+        | not (LF.getIsSerializable (LF.dataSerializable def)) = []\n+        | otherwise = case LF.unTypeConName (LF.dataTypeCon def) of\n+            [] -> error \"IMPOSSIBLE: empty type constructor name\"\n+            _:_:_ -> error \"TODO(MH): multi-part type constructor names\"\n+            [conName] -> case LF.dataCons def of\n+                LF.DataVariant{} -> error \"TODO(MH): variant types\"\n+                LF.DataEnum{} -> error \"TODO(MH): enum types\"\n+                LF.DataRecord fields ->\n+                    let params\n+                          | null (LF.dataParams def) = \"\"\n+                          | otherwise = \"<\" <> T.intercalate \", \" (map (LF.unTypeVarName . fst) (LF.dataParams def)) <> \">\"\n+                    in\n+                    [\"type \" <> conName <> params <> \" = {\"]\n+                    ++ [\"  \" <> LF.unFieldName x <> \": \" <> genType curModName t <> \";\" | (x, t) <- fields]\n+                    ++ [\"}\"]\n+\n+\n+    genType :: LF.ModuleName -> LF.Type -> T.Text\n+    genType curModName = go\n+      where\n+        go = \\case\n+            LF.TVar v -> LF.unTypeVarName v\n+            LF.TUnit -> \"{}\"\n+            LF.TBool -> \"boolean\"\n+            LF.TInt64 -> \"daml.Int\"\n+            LF.TDecimal -> \"daml.Decimal\"\n+            LF.TNumeric _ -> \"dalm.Numeric\"  -- TODO(MH): Figure out what to do with the scale."
  },
  {
    "id" : "4857bbd0-1a6b-49df-a016-562d83f94072",
    "prId" : 3441,
    "comments" : [
      {
        "id" : "42cb192e-f37b-48f4-b3f0-40db682300dc",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "let's move this to Cli/Options.hs if it's not already implemented there.",
        "createdAt" : "2019-11-13T14:24:20Z",
        "updatedAt" : "2019-11-19T15:10:10Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "eff993c856bef39dda178c0b0ca7b3cc76f89f26",
    "line" : null,
    "diffHunk" : "@@ -213,6 +215,15 @@ cmdInspect =\n             optional $ option auto $ long \"detail\" <> metavar \"LEVEL\" <> help \"Detail level of the pretty printed output (default: 0)\"\n     cmd = execInspect <$> inputFileOptWithExt \".dalf or .dar\" <*> outputFileOpt <*> jsonOpt <*> detailOpt\n \n+cmdDaml2ts :: Mod CommandFields Command\n+cmdDaml2ts =\n+    command \"daml2ts\" $ info (helper <*> cmd)\n+      $ progDesc \"Generate the TypeScript bindings for the main DALF in a DAR or a DALF\"\n+    <> fullDesc\n+  where\n+    outputDirOpt = argument str $ metavar \"OUTPUT_DIR\" <> help \"Output directory\""
  },
  {
    "id" : "94936574-5d7f-4bb8-9562-517fab740339",
    "prId" : 3406,
    "comments" : [
      {
        "id" : "891ac25c-38ab-42bb-a2d3-9d5ad1232eb7",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "No need to rewrite self references here, the dalf won't be linked or typechecked and for code generation it's easier if you just have the PRSelf references and translate those to the unit it.",
        "createdAt" : "2019-11-10T12:54:59Z",
        "updatedAt" : "2019-11-10T18:38:25Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "aada4ba363644b3ada5ab8ecb1443ad386c52708",
    "line" : 5,
    "diffHunk" : "@@ -554,7 +554,8 @@ createProjectPackageDb opts thisSdkVer deps0 dataDeps = do\n         forM allDalfs $ \\(name, dalf) -> do\n             (pkgId, package) <-\n                 either (fail . DA.Pretty.renderPretty) pure $\n-                Archive.decodeArchive dalf\n+                -- FIXME(MH): This keeps the old behaviour but seems wrong to me."
  },
  {
    "id" : "f329fa69-f023-44ce-9ccd-f0636a9a4774",
    "prId" : 3399,
    "comments" : [
      {
        "id" : "2b33d6a6-447e-48a8-8c9d-fa7912d2a12e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Does `optAllowDifferentSdks` still make sense? It seems like there are two cases:\r\n1. I have a data import. In that case an SDK check doesn’t make sense.\r\n2. I have a regular dependency. If that dependency is from a different SDK it should always be an error.\r\n\r\nGiven that I don’t see the need for manual control in either of those cases, the option doesn’t seem useful but maybe I’m missing something?",
        "createdAt" : "2019-11-08T12:22:18Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a192755-794d-4a4c-9116-004eaa4b0528",
        "parentId" : "2b33d6a6-447e-48a8-8c9d-fa7912d2a12e",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Happy to drop it too, I check if we don't need it anymore.",
        "createdAt" : "2019-11-08T13:37:25Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3d9851e204dcebd5655cc9f17cb2763d0fa1942c",
    "line" : null,
    "diffHunk" : "@@ -524,111 +525,113 @@ createProjectPackageDb opts fps = do\n                 | otherwise\n                 = pure fp\n           in mapM expand\n-    fps0 <- handleSdkPackages $ filter (`notElem` basePackages) fps\n-    let (fpDars, fpDalfs) = partition ((== \".dar\") . takeExtension) fps0\n-    dars <- mapM extractDar fpDars\n-    let uniqSdkVersions = nubSort $ map edSdkVersions dars\n-    if | (length uniqSdkVersions > 1 && optAllowDifferentSdks opts) || not (null fpDalfs)\n-        -> do\n-              let dalfs = concatMap edDalfs dars\n-              -- when we compile packages with different sdk versions or with dalf dependencies, we\n-              -- need to generate the interface files\n-              let dalfsFromDars =\n-                      [ ( dropExtension $ takeFileName $ ZipArchive.eRelativePath e\n-                        , BSL.toStrict $ ZipArchive.fromEntry e)\n-                      | e <- dalfs\n-                      ]\n-              dalfsFromFps <-\n-                  forM fpDalfs $ \\fp -> do\n-                      bs <- B.readFile fp\n-                      pure (dropExtension $ takeFileName fp, bs)\n-              let allDalfs = dalfsFromDars ++ dalfsFromFps\n-              pkgs <-\n-                  forM allDalfs $ \\(name, dalf) -> do\n-                      (pkgId, package) <-\n-                          either (fail . DA.Pretty.renderPretty) pure $\n-                          Archive.decodeArchive dalf\n-                      pure (pkgId, package, dalf, stringToUnitId name)\n-              -- mapping from package id's to unit id's. if the same package is imported with\n-              -- different unit id's, we would loose a unit id here.\n-              let pkgMap =\n-                      MS.fromList\n-                          [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n-              -- order the packages in topological order\n-              let (depGraph, vertexToNode, _keyToVertex) =\n-                      graphFromEdges $ do\n-                          (pkgId, dalf, bs, unitId) <- pkgs\n-                          let pkgRefs =\n-                                  [ pid\n-                                  | LF.PRImport pid <- toListOf packageRefs dalf\n-                                  ]\n-                          let getUid = getUnitId unitId pkgMap\n-                          let src = generateSrcPkgFromLf getUid pkgId dalf\n-                          let templInstSrc =\n-                                  generateTemplateInstancesPkgFromLf\n-                                      getUid\n-                                      pkgId\n-                                      dalf\n-                          pure\n-                              ( (src, templInstSrc, unitId, dalf, bs)\n-                              , pkgId\n-                              , pkgRefs)\n-              let pkgIdsTopoSorted = reverse $ topSort depGraph\n-              dbPathAbs <- makeAbsolute dbPath\n-              projectPackageDatabaseAbs <- makeAbsolute projectPackageDatabase\n-              forM_ pkgIdsTopoSorted $ \\vertex -> do\n-                  let ((src, templInstSrc, uid, dalf, bs), pkgId, _) =\n-                          vertexToNode vertex\n-                  when (uid /= primUnitId) $ do\n-                      let unitIdStr = unitIdString uid\n-                      let instancesUnitIdStr = \"instances-\" <> unitIdStr\n-                      let pkgIdStr = T.unpack $ LF.unPackageId pkgId\n-                      let (pkgName, mbPkgVersion) =\n-                              fromMaybe (unitIdStr, Nothing) $ do\n-                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n-                                  guard $ all (`elem` '.' : ['0' .. '9']) ver\n-                                  Just (uId, Just ver)\n-                      let deps =\n-                              [ unitIdString uId <.> \"dalf\"\n-                              | ((_src, _templSrc, uId, _dalf, _bs), pId, _) <-\n-                                    map vertexToNode $ reachable depGraph vertex\n-                              , pkgId /= pId\n-                              ]\n-                      let workDir = dbPath </> unitIdStr <> \"-\" <> pkgIdStr\n-                      createDirectoryIfMissing True workDir\n-                      -- write the dalf package\n-                      B.writeFile (workDir </> unitIdStr <.> \"dalf\") bs\n-                      generateAndInstallIfaceFiles\n-                          dalf\n-                          src\n-                          opts\n-                          workDir\n-                          dbPath\n-                          projectPackageDatabase\n-                          unitIdStr\n-                          pkgIdStr\n-                          pkgName\n-                          mbPkgVersion\n-                          deps\n-\n-                      unless (null templInstSrc) $\n-                          generateAndInstallInstancesPkg\n-                              templInstSrc\n-                              opts\n-                              dbPathAbs\n-                              projectPackageDatabaseAbs\n-                              unitIdStr\n-                              instancesUnitIdStr\n-                              pkgName\n-                              mbPkgVersion\n-                              deps\n-\n-       | length uniqSdkVersions <= 1 -> forM_ dars $\n-            \\ExtractedDar{..} -> installDar dbPath edConfFiles edDalfs edSrcs\n-       | otherwise ->\n+    deps <- handleSdkPackages $ filter (`notElem` basePackages) deps0\n+    depsExtracted <- mapM extractDar deps\n+    let uniqSdkVersions = nubSort $ filter (/= \"0.0.0\") $ thisSdkVer : map edSdkVersions depsExtracted\n+    unless (length uniqSdkVersions <= 1 || optAllowDifferentSdks opts) $"
  },
  {
    "id" : "d6ed9bda-85f2-42b0-8466-56cb2f8e5e8a",
    "prId" : 3399,
    "comments" : [
      {
        "id" : "b7753eb9-66ff-40c9-9a6c-d578e68ad54f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we filter out `0.0.0`? The only case where I can see this being useful is immediately after a release where things are compatible for a very short amount of time. But that doesn’t seem like something anyone should rely on so I’d rather prevent it.",
        "createdAt" : "2019-11-08T12:23:48Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d0be8972-604f-4d75-8bc8-37a03a89cdeb",
        "parentId" : "b7753eb9-66ff-40c9-9a6c-d578e68ad54f",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "It's there because otherwise the assistant integration tests will fail, when they import SDK packages (which have a different sdk version than 0.0.0). ",
        "createdAt" : "2019-11-08T14:10:16Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a1789d40-a733-4e17-aae9-7f7a2ea3a635",
        "parentId" : "b7753eb9-66ff-40c9-9a6c-d578e68ad54f",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I added a comment, I'd like to drop it if somehow possible.",
        "createdAt" : "2019-11-08T14:13:04Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3d9851e204dcebd5655cc9f17cb2763d0fa1942c",
    "line" : 136,
    "diffHunk" : "@@ -524,111 +525,113 @@ createProjectPackageDb opts fps = do\n                 | otherwise\n                 = pure fp\n           in mapM expand\n-    fps0 <- handleSdkPackages $ filter (`notElem` basePackages) fps\n-    let (fpDars, fpDalfs) = partition ((== \".dar\") . takeExtension) fps0\n-    dars <- mapM extractDar fpDars\n-    let uniqSdkVersions = nubSort $ map edSdkVersions dars\n-    if | (length uniqSdkVersions > 1 && optAllowDifferentSdks opts) || not (null fpDalfs)\n-        -> do\n-              let dalfs = concatMap edDalfs dars\n-              -- when we compile packages with different sdk versions or with dalf dependencies, we\n-              -- need to generate the interface files\n-              let dalfsFromDars =\n-                      [ ( dropExtension $ takeFileName $ ZipArchive.eRelativePath e\n-                        , BSL.toStrict $ ZipArchive.fromEntry e)\n-                      | e <- dalfs\n-                      ]\n-              dalfsFromFps <-\n-                  forM fpDalfs $ \\fp -> do\n-                      bs <- B.readFile fp\n-                      pure (dropExtension $ takeFileName fp, bs)\n-              let allDalfs = dalfsFromDars ++ dalfsFromFps\n-              pkgs <-\n-                  forM allDalfs $ \\(name, dalf) -> do\n-                      (pkgId, package) <-\n-                          either (fail . DA.Pretty.renderPretty) pure $\n-                          Archive.decodeArchive dalf\n-                      pure (pkgId, package, dalf, stringToUnitId name)\n-              -- mapping from package id's to unit id's. if the same package is imported with\n-              -- different unit id's, we would loose a unit id here.\n-              let pkgMap =\n-                      MS.fromList\n-                          [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n-              -- order the packages in topological order\n-              let (depGraph, vertexToNode, _keyToVertex) =\n-                      graphFromEdges $ do\n-                          (pkgId, dalf, bs, unitId) <- pkgs\n-                          let pkgRefs =\n-                                  [ pid\n-                                  | LF.PRImport pid <- toListOf packageRefs dalf\n-                                  ]\n-                          let getUid = getUnitId unitId pkgMap\n-                          let src = generateSrcPkgFromLf getUid pkgId dalf\n-                          let templInstSrc =\n-                                  generateTemplateInstancesPkgFromLf\n-                                      getUid\n-                                      pkgId\n-                                      dalf\n-                          pure\n-                              ( (src, templInstSrc, unitId, dalf, bs)\n-                              , pkgId\n-                              , pkgRefs)\n-              let pkgIdsTopoSorted = reverse $ topSort depGraph\n-              dbPathAbs <- makeAbsolute dbPath\n-              projectPackageDatabaseAbs <- makeAbsolute projectPackageDatabase\n-              forM_ pkgIdsTopoSorted $ \\vertex -> do\n-                  let ((src, templInstSrc, uid, dalf, bs), pkgId, _) =\n-                          vertexToNode vertex\n-                  when (uid /= primUnitId) $ do\n-                      let unitIdStr = unitIdString uid\n-                      let instancesUnitIdStr = \"instances-\" <> unitIdStr\n-                      let pkgIdStr = T.unpack $ LF.unPackageId pkgId\n-                      let (pkgName, mbPkgVersion) =\n-                              fromMaybe (unitIdStr, Nothing) $ do\n-                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n-                                  guard $ all (`elem` '.' : ['0' .. '9']) ver\n-                                  Just (uId, Just ver)\n-                      let deps =\n-                              [ unitIdString uId <.> \"dalf\"\n-                              | ((_src, _templSrc, uId, _dalf, _bs), pId, _) <-\n-                                    map vertexToNode $ reachable depGraph vertex\n-                              , pkgId /= pId\n-                              ]\n-                      let workDir = dbPath </> unitIdStr <> \"-\" <> pkgIdStr\n-                      createDirectoryIfMissing True workDir\n-                      -- write the dalf package\n-                      B.writeFile (workDir </> unitIdStr <.> \"dalf\") bs\n-                      generateAndInstallIfaceFiles\n-                          dalf\n-                          src\n-                          opts\n-                          workDir\n-                          dbPath\n-                          projectPackageDatabase\n-                          unitIdStr\n-                          pkgIdStr\n-                          pkgName\n-                          mbPkgVersion\n-                          deps\n-\n-                      unless (null templInstSrc) $\n-                          generateAndInstallInstancesPkg\n-                              templInstSrc\n-                              opts\n-                              dbPathAbs\n-                              projectPackageDatabaseAbs\n-                              unitIdStr\n-                              instancesUnitIdStr\n-                              pkgName\n-                              mbPkgVersion\n-                              deps\n-\n-       | length uniqSdkVersions <= 1 -> forM_ dars $\n-            \\ExtractedDar{..} -> installDar dbPath edConfFiles edDalfs edSrcs\n-       | otherwise ->\n+    deps <- handleSdkPackages $ filter (`notElem` basePackages) deps0\n+    depsExtracted <- mapM extractDar deps\n+    let uniqSdkVersions = nubSort $ filter (/= \"0.0.0\") $ thisSdkVer : map edSdkVersions depsExtracted"
  },
  {
    "id" : "575f018b-b967-4b13-9179-f5333f916e56",
    "prId" : 3399,
    "comments" : [
      {
        "id" : "41432a03-3c55-4886-b376-690e8ae7b366",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I feel like these arguments would be easier if you inline it into the tuple, i..e,\r\n```\r\n[(m <> \"Instances\", m <> \"AInstances\") | m <- eqModNamesStr]\r\n```",
        "createdAt" : "2019-11-08T12:26:41Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e57abb3e-65af-4aa6-9cef-43c5345c5d4c",
        "parentId" : "41432a03-3c55-4886-b376-690e8ae7b366",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "yes, why not!",
        "createdAt" : "2019-11-08T13:37:45Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3d9851e204dcebd5655cc9f17cb2763d0fa1942c",
    "line" : 300,
    "diffHunk" : "@@ -1033,37 +1039,30 @@ execMigrate projectOpts inFile1_ inFile2_ mbDir =\n                   let pkgName = takeBaseName $ mainDalfPath dalfManifest\n                   mainDalfEntry <- getEntry (mainDalfPath dalfManifest) dar\n                   (mainPkgId, mainLfPkg) <- decode $ BSL.toStrict $ ZipArchive.fromEntry mainDalfEntry\n-                  pure (pkgName, mainPkgId, mainLfPkg, sdkVersion dalfManifest)\n+                  pure (pkgName, mainPkgId, mainLfPkg)\n           -- generate upgrade modules and instances modules\n           let eqModNames =\n                   (NM.names $ LF.packageModules lfPkg1) `intersect`\n                   (NM.names $ LF.packageModules lfPkg2)\n-          thisSdkVer <- getSdkVersion\n-          let differentSdks = (length $ nubSort [sdkVer1, sdkVer2, thisSdkVer]) /= 1\n           let eqModNamesStr = map (T.unpack . LF.moduleNameString) eqModNames\n-          let buildOptions0 =\n-                  [ \"--allow-different-sdks\"\n-                  , \"'--package=\" <> show (\"instances-\" <> pkgName1\n-                                          , [(m', m' ++ \"A\")\n-                                            | m <- eqModNamesStr, let m' = m <> \"Instances\"\n+          let buildOptions =\n+                  [\"'--package=\" <> show (\"instances-\" <> pkgName1\n+                                          , [(m', m'')\n+                                            | m <- eqModNamesStr\n+                                            , let m' = m <> \"Instances\""
  },
  {
    "id" : "e3525bae-26c2-409a-8f60-7a4438afceaf",
    "prId" : 3399,
    "comments" : [
      {
        "id" : "032e899c-1b7c-4bec-9388-55372026d12d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here.",
        "createdAt" : "2019-11-08T12:26:50Z",
        "updatedAt" : "2019-11-08T14:53:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3d9851e204dcebd5655cc9f17cb2763d0fa1942c",
    "line" : 307,
    "diffHunk" : "@@ -1033,37 +1039,30 @@ execMigrate projectOpts inFile1_ inFile2_ mbDir =\n                   let pkgName = takeBaseName $ mainDalfPath dalfManifest\n                   mainDalfEntry <- getEntry (mainDalfPath dalfManifest) dar\n                   (mainPkgId, mainLfPkg) <- decode $ BSL.toStrict $ ZipArchive.fromEntry mainDalfEntry\n-                  pure (pkgName, mainPkgId, mainLfPkg, sdkVersion dalfManifest)\n+                  pure (pkgName, mainPkgId, mainLfPkg)\n           -- generate upgrade modules and instances modules\n           let eqModNames =\n                   (NM.names $ LF.packageModules lfPkg1) `intersect`\n                   (NM.names $ LF.packageModules lfPkg2)\n-          thisSdkVer <- getSdkVersion\n-          let differentSdks = (length $ nubSort [sdkVer1, sdkVer2, thisSdkVer]) /= 1\n           let eqModNamesStr = map (T.unpack . LF.moduleNameString) eqModNames\n-          let buildOptions0 =\n-                  [ \"--allow-different-sdks\"\n-                  , \"'--package=\" <> show (\"instances-\" <> pkgName1\n-                                          , [(m', m' ++ \"A\")\n-                                            | m <- eqModNamesStr, let m' = m <> \"Instances\"\n+          let buildOptions =\n+                  [\"'--package=\" <> show (\"instances-\" <> pkgName1\n+                                          , [(m', m'')\n+                                            | m <- eqModNamesStr\n+                                            , let m' = m <> \"Instances\"\n+                                            , let m'' = m <> \"AInstances\"\n                                             ]\n                                           ) <> \"'\"\n                   , \"'--package=\" <> show (\"instances-\" <> pkgName2\n-                                          , [(m', m' ++ \"B\")\n-                                            | m <- eqModNamesStr, let m' = m <> \"Instances\"\n+                                          , [(m', m'')"
  },
  {
    "id" : "b492f299-1a0a-4124-b161-06402f30afc1",
    "prId" : 3379,
    "comments" : [
      {
        "id" : "ac1acbd8-140c-42cf-9c41-b1c46294c6ea",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why did this change?",
        "createdAt" : "2019-11-07T14:49:25Z",
        "updatedAt" : "2019-11-07T15:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4dffa785-30f5-45f8-98a6-5bd211096ea0",
        "parentId" : "ac1acbd8-140c-42cf-9c41-b1c46294c6ea",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "We write the interfaces with `writeIfaceAndHie` in the next step. This way we don't do it two times.",
        "createdAt" : "2019-11-07T15:04:59Z",
        "updatedAt" : "2019-11-07T15:06:09Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f6971519-e2b2-4e7f-ab33-7bee3aa109d2",
        "parentId" : "ac1acbd8-140c-42cf-9c41-b1c46294c6ea",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "So this was redundant before this PR as well? Makes sense in that case, thanks for the explanation!",
        "createdAt" : "2019-11-07T15:06:18Z",
        "updatedAt" : "2019-11-07T15:06:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f580f413-bae6-4ee7-8555-32c2e0db9c7e",
        "parentId" : "ac1acbd8-140c-42cf-9c41-b1c46294c6ea",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "yes, this was redundant before.",
        "createdAt" : "2019-11-07T15:13:23Z",
        "updatedAt" : "2019-11-07T15:13:24Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a63b2d51d7218279407aef334b68a2efb59dadd2",
    "line" : 56,
    "diffHunk" : "@@ -638,33 +636,38 @@ createProjectPackageDb opts fps = do\n         -> Options\n         -> FilePath\n         -> FilePath\n+        -> FilePath\n         -> String\n         -> String\n         -> String\n         -> Maybe String\n         -> [String]\n         -> IO ()\n-    generateAndInstallIfaceFiles dalf src opts dbPathAbs projectPackageDatabaseAbs unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n+    generateAndInstallIfaceFiles dalf src opts workDir dbPath projectPackageDatabase unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n         loggerH <- getLogger opts \"generate interface files\"\n-        mapM_ writeSrc src\n+        let src' = [ (toNormalizedFilePath $ workDir </> fromNormalizedFilePath nfp, str) | (nfp, str) <- src]\n+        mapM_ writeSrc src'\n         opts' <-\n             mkOptions $\n             opts\n-                { optWriteInterface = True\n-                , optPackageDbs = projectPackageDatabaseAbs : optPackageDbs opts\n-                , optIfaceDir = Just \"./\"\n+                { optWriteInterface = False"
  },
  {
    "id" : "44ffa051-ae83-41ad-b9ca-3e98489eaeb3",
    "prId" : 3379,
    "comments" : [
      {
        "id" : "afc1436f-98d2-43fb-a3ff-5b880a00f2b5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Looks like leftover debugging output.",
        "createdAt" : "2019-11-07T14:50:35Z",
        "updatedAt" : "2019-11-07T15:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5d165e8c-76ea-40b1-8c16-2228c63ba611",
        "parentId" : "afc1436f-98d2-43fb-a3ff-5b880a00f2b5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "will remove.",
        "createdAt" : "2019-11-07T15:05:09Z",
        "updatedAt" : "2019-11-07T15:06:09Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a63b2d51d7218279407aef334b68a2efb59dadd2",
    "line" : null,
    "diffHunk" : "@@ -638,33 +636,38 @@ createProjectPackageDb opts fps = do\n         -> Options\n         -> FilePath\n         -> FilePath\n+        -> FilePath\n         -> String\n         -> String\n         -> String\n         -> Maybe String\n         -> [String]\n         -> IO ()\n-    generateAndInstallIfaceFiles dalf src opts dbPathAbs projectPackageDatabaseAbs unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n+    generateAndInstallIfaceFiles dalf src opts workDir dbPath projectPackageDatabase unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n         loggerH <- getLogger opts \"generate interface files\"\n-        mapM_ writeSrc src\n+        let src' = [ (toNormalizedFilePath $ workDir </> fromNormalizedFilePath nfp, str) | (nfp, str) <- src]\n+        mapM_ writeSrc src'\n         opts' <-\n             mkOptions $\n             opts\n-                { optWriteInterface = True\n-                , optPackageDbs = projectPackageDatabaseAbs : optPackageDbs opts\n-                , optIfaceDir = Just \"./\"\n+                { optWriteInterface = False\n+                , optPackageDbs = projectPackageDatabase : optPackageDbs opts\n+                , optIfaceDir = Nothing\n                 , optIsGenerated = True\n                 , optDflagCheck = False\n                 , optMbPackageName = Just unitIdStr\n                 , optHideAllPkgs = False\n                 , optGhcCustomOpts = []\n                 , optPackageImports = []\n+                , optImportPath = workDir : optImportPath opts\n                 }\n+\n+        putStrLn $ show $ optImportPath opts'"
  },
  {
    "id" : "ca69787f-6d77-4cdb-a2f9-969857db0bf2",
    "prId" : 3379,
    "comments" : [
      {
        "id" : "9fae5079-eadd-41bb-b0dd-96bd58fe826d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same question here, do we need no longer need `optIfaceDir`?",
        "createdAt" : "2019-11-07T14:51:43Z",
        "updatedAt" : "2019-11-07T15:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "16d92ede-8ab1-41f7-8d4c-33833693fa4b",
        "parentId" : "9fae5079-eadd-41bb-b0dd-96bd58fe826d",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "same as above.",
        "createdAt" : "2019-11-07T15:05:15Z",
        "updatedAt" : "2019-11-07T15:06:09Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a63b2d51d7218279407aef334b68a2efb59dadd2",
    "line" : 58,
    "diffHunk" : "@@ -638,33 +636,38 @@ createProjectPackageDb opts fps = do\n         -> Options\n         -> FilePath\n         -> FilePath\n+        -> FilePath\n         -> String\n         -> String\n         -> String\n         -> Maybe String\n         -> [String]\n         -> IO ()\n-    generateAndInstallIfaceFiles dalf src opts dbPathAbs projectPackageDatabaseAbs unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n+    generateAndInstallIfaceFiles dalf src opts workDir dbPath projectPackageDatabase unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n         loggerH <- getLogger opts \"generate interface files\"\n-        mapM_ writeSrc src\n+        let src' = [ (toNormalizedFilePath $ workDir </> fromNormalizedFilePath nfp, str) | (nfp, str) <- src]\n+        mapM_ writeSrc src'\n         opts' <-\n             mkOptions $\n             opts\n-                { optWriteInterface = True\n-                , optPackageDbs = projectPackageDatabaseAbs : optPackageDbs opts\n-                , optIfaceDir = Just \"./\"\n+                { optWriteInterface = False\n+                , optPackageDbs = projectPackageDatabase : optPackageDbs opts\n+                , optIfaceDir = Nothing"
  },
  {
    "id" : "82a4dd25-8684-40bb-981b-a0e6652bd9eb",
    "prId" : 3379,
    "comments" : [
      {
        "id" : "1b7ed51c-3bd0-4128-b406-de960dc89908",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We do basically the same thing in `generateAndInstallInstancesPkg` so we should probably fix that one as well (fine to leave that for a separate PR).",
        "createdAt" : "2019-11-07T14:54:03Z",
        "updatedAt" : "2019-11-07T15:06:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a63b2d51d7218279407aef334b68a2efb59dadd2",
    "line" : 32,
    "diffHunk" : "@@ -597,20 +597,18 @@ createProjectPackageDb opts fps = do\n                       createDirectoryIfMissing True workDir\n                       -- write the dalf package\n                       B.writeFile (workDir </> unitIdStr <.> \"dalf\") bs\n-                      -- we change the working dir so that we get correct file paths for the\n-                      -- interface files.\n-                      withCurrentDirectory workDir $\n-                          generateAndInstallIfaceFiles\n-                              dalf\n-                              src\n-                              opts\n-                              dbPathAbs\n-                              projectPackageDatabaseAbs\n-                              unitIdStr\n-                              pkgIdStr\n-                              pkgName\n-                              mbPkgVersion\n-                              deps\n+                      generateAndInstallIfaceFiles\n+                          dalf\n+                          src\n+                          opts\n+                          workDir\n+                          dbPath\n+                          projectPackageDatabase\n+                          unitIdStr\n+                          pkgIdStr\n+                          pkgName\n+                          mbPkgVersion\n+                          deps\n \n                       unless (null templInstSrc) $\n                           generateAndInstallInstancesPkg"
  },
  {
    "id" : "3fd3e68e-d387-4b98-9186-1132f72ed092",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "ebddb4b2-4e12-4b6a-bebc-70d7c312cc44",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t understand this comment.",
        "createdAt" : "2019-11-06T14:33:51Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "71a781da-0eaf-4879-89c3-b08a387f88a2",
        "parentId" : "ebddb4b2-4e12-4b6a-bebc-70d7c312cc44",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "we use two different zip libraries in Damlc. Here we write a zip archive generated with the first to disc and decode it with the second library. I want to just use one zip library in Damlc.hs",
        "createdAt" : "2019-11-06T14:47:18Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "129cb130-8c6d-4067-90a5-77670c0ef929",
        "parentId" : "ebddb4b2-4e12-4b6a-bebc-70d7c312cc44",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Makes sense :+1:",
        "createdAt" : "2019-11-06T15:47:17Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 108,
    "diffHunk" : "@@ -672,6 +690,62 @@ createProjectPackageDb opts fps = do\n             , \"--expand-pkgroot\"\n             ]\n \n+    -- generate a package containing template instances and install it in the package database\n+    generateAndInstallInstancesPkg ::\n+           [(NormalizedFilePath, String)]\n+        -> Options\n+        -> FilePath\n+        -> FilePath\n+        -> String\n+        -> String\n+        -> String\n+        -> Maybe String\n+        -> [String]\n+        -> IO ()\n+    generateAndInstallInstancesPkg templInstSrc opts dbPathAbs projectPackageDatabaseAbs unitIdStr instancesUnitIdStr pkgName mbPkgVersion deps =\n+        withTempDir $ \\tempDir ->\n+            withCurrentDirectory tempDir $ do\n+                loggerH <- getLogger opts \"generate instances package\"\n+                mapM_ writeSrc templInstSrc\n+                sdkVersion <- getSdkVersion\n+                let pkgConfig =\n+                        PackageConfigFields\n+                            { pName = \"instances-\" <> pkgName\n+                            , pSrc = \".\"\n+                            , pExposedModules = Nothing\n+                            , pVersion = mbPkgVersion\n+                            , pDependencies = (unitIdStr <.> \"dalf\") : deps\n+                            , pSdkVersion = sdkVersion\n+                            , cliOpts = Nothing\n+                            }\n+                opts' <-\n+                    mkOptions $\n+                    opts\n+                        { optWriteInterface = True\n+                        , optPackageDbs = projectPackageDatabaseAbs : optPackageDbs opts\n+                        , optIfaceDir = Just \"./\"\n+                        , optIsGenerated = True\n+                        , optDflagCheck = False\n+                        , optMbPackageName = Just instancesUnitIdStr\n+                        , optHideAllPkgs = False\n+                        , optPackageImports = [(unitIdStr, []) | pkgName /= \"daml-stdlib\"]\n+                        }\n+                mbDar <-\n+                    withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+                        buildDar\n+                            ide\n+                            pkgConfig\n+                            (toNormalizedFilePath $\n+                             fromMaybe ifaceDir $ optIfaceDir opts')\n+                            (FromDalf False)\n+                dar <- mbErr \"ERROR: Creation of instances DAR file failed.\" mbDar\n+              -- TODO (drsk) switch to different zip library so we don't have to write"
  },
  {
    "id" : "2399a53a-6647-424b-8b6a-7b980db786ce",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "0dde95f9-d62a-42c0-8658-f8e320f08137",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The description doesn’t make it clear if the `dalf` package is supposed to contain the `Generic` instance or if the generated code will also contain freshly generated `Generic` instances.",
        "createdAt" : "2019-11-05T14:36:52Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1c1c4ede-097a-4f27-80e5-29f7b7e85a48",
        "parentId" : "0dde95f9-d62a-42c0-8658-f8e320f08137",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "It's the later, I'll try to make it clearer.",
        "createdAt" : "2019-11-05T15:37:09Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : null,
    "diffHunk" : "@@ -308,6 +310,16 @@ cmdGenerateSrc =\n   where\n     cmd = execGenerateSrc <$> inputDalfOpt\n \n+cmdGenerateGenSrc :: Mod CommandFields Command\n+cmdGenerateGenSrc =\n+    command \"generate-gen-src\" $\n+    info (helper <*> cmd) $\n+    progDesc\n+        \"Generate DAML source code from a dalf package containing Generic instances\" <>"
  },
  {
    "id" : "092fb096-d9cb-4e75-8326-770fd103740b",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "c9c2c18e-b277-4231-bf65-fedaa036f055",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What happens if I have colliding file names?",
        "createdAt" : "2019-11-05T14:38:10Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2c9ec900-1b11-4d72-b9bd-c7a2af105188",
        "parentId" : "c9c2c18e-b277-4231-bf65-fedaa036f055",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "the zip entries will be different. but you have a point that we have to be careful when we install such a merged dar, as we would end up overwriting entries if we don't prefix them correctly. I'll make sure the `installDar` is safe.",
        "createdAt" : "2019-11-05T17:20:53Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6f86380b-1b94-45f7-9789-d22dd12b8d59",
        "parentId" : "c9c2c18e-b277-4231-bf65-fedaa036f055",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I ended up removing the Monoid instance to be on the safe side.",
        "createdAt" : "2019-11-05T17:35:49Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : null,
    "diffHunk" : "@@ -565,124 +551,237 @@ createProjectPackageDb opts fps = do\n               -- mapping from package id's to unit id's. if the same package is imported with\n               -- different unit id's, we would loose a unit id here.\n               let pkgMap =\n-                      MS.fromList [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n+                      MS.fromList\n+                          [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n               -- order the packages in topological order\n               let (depGraph, vertexToNode, _keyToVertex) =\n                       graphFromEdges $ do\n                           (pkgId, dalf, bs, unitId) <- pkgs\n                           let pkgRefs =\n-                                  [pid | LF.PRImport pid <- toListOf packageRefs dalf]\n-                          let src = generateSrcPkgFromLf pkgId pkgMap dalf\n-                          pure ((src, unitId, dalf, bs), pkgId, pkgRefs)\n+                                  [ pid\n+                                  | LF.PRImport pid <- toListOf packageRefs dalf\n+                                  ]\n+                          let getUid = getUnitId unitId pkgMap\n+                          let src = generateSrcPkgFromLf getUid pkgId dalf\n+                          pure\n+                              ( (src, unitId, dalf, bs)\n+                              , pkgId\n+                              , pkgRefs)\n               let pkgIdsTopoSorted = reverse $ topSort depGraph\n-              ghcPkgPath <- getGhcPkgPath\n               dbPathAbs <- makeAbsolute dbPath\n               projectPackageDatabaseAbs <- makeAbsolute projectPackageDatabase\n               forM_ pkgIdsTopoSorted $ \\vertex -> do\n-                  let ((src, uid, dalf, bs), pkgId, _) = vertexToNode vertex\n+                  let ((src, uid, dalf, bs), pkgId, _) =\n+                          vertexToNode vertex\n                   when (uid /= primUnitId) $ do\n                       let unitIdStr = unitIdString uid\n                       let pkgIdStr = T.unpack $ LF.unPackageId pkgId\n+                      let (pkgName, mbPkgVersion) =\n+                              fromMaybe (unitIdStr, Nothing) $ do\n+                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n+                                  guard $ all (`elem` '.' : ['0' .. '9']) ver\n+                                  Just (uId, Just ver)\n+                      let deps =\n+                              [ unitIdString uId <.> \"dalf\"\n+                              | ((_src, uId, _dalf, _bs), pId, _) <-\n+                                    map vertexToNode $ reachable depGraph vertex\n+                              , pkgId /= pId\n+                              ]\n                       let workDir = dbPath </> unitIdStr <> \"-\" <> pkgIdStr\n                       createDirectoryIfMissing True workDir\n                       -- write the dalf package\n                       B.writeFile (workDir </> unitIdStr <.> \"dalf\") bs\n                       -- we change the working dir so that we get correct file paths for the\n                       -- interface files.\n                       withCurrentDirectory workDir $\n-                       -- typecheck and generate interface files\n-                       do\n-                          forM_ src $ \\(fp, content) -> do\n-                              let path = fromNormalizedFilePath fp\n-                              createDirectoryIfMissing True $ takeDirectory path\n-                              writeFileUTF8 path content\n-                          opts' <-\n-                              mkOptions $\n+                          generateAndInstallIfaceFiles\n+                              dalf\n+                              src\n                               opts\n-                                  { optWriteInterface = True\n-                                  , optPackageDbs =\n-                                        projectPackageDatabaseAbs : optPackageDbs opts\n-                                  , optIfaceDir = Just \"./\"\n-                                  , optIsGenerated = True\n-                                  , optDflagCheck = False\n-                                  , optMbPackageName = Just unitIdStr\n-                                  , optHideAllPkgs = False\n-                                  , optPackageImports = []\n-                                  , optGhcCustomOpts = []\n-                                  }\n-                          withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n-                              runAction ide $\n-                              writeIfacesAndHie\n-                                  (toNormalizedFilePath \"./\")\n-                                  [fp | (fp, _content) <- src]\n-                      let deps =\n-                              [ unitIdString uId <.> \"dalf\"\n-                              | ((_src, uId, _dalf, _bs), pId, _) <-\n-                                    map vertexToNode $ reachable depGraph vertex\n-                              , pkgId /= pId\n-                              ]\n-                      -- write the conf file and refresh the package cache\n-                      let (pkgName, pkgVersion) =\n-                            fromMaybe (unitIdStr, Nothing) $\n-                                do\n-                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n-                                  guard $ all (`elem` '.':['0' .. '9']) ver\n-                                  Just (uId, Just ver)\n-                      let (cfPath, cfBs) =\n-                              mkConfFile\n-                                  PackageConfigFields\n-                                      { pName = pkgName\n-                                      , pSrc = \"\" -- not used\n-                                      , pExposedModules = Nothing\n-                                      , pVersion = pkgVersion\n-                                      , pDependencies = deps\n-                                      , pSdkVersion = \"unknown\"\n-                                      , cliOpts = Nothing\n-                                      }\n-                                  (map T.unpack $ LF.packageModuleNames dalf)\n-                                  pkgIdStr\n-                      B.writeFile (dbPathAbs </> \"package.conf.d\" </> cfPath) cfBs\n-                      callProcess\n-                          (ghcPkgPath </> exe \"ghc-pkg\")\n-                          [ \"recache\"\n-                          -- ghc-pkg insists on using a global package db and will try\n-                          -- to find one automatically if we don’t specify it here.\n-                          , \"--global-package-db=\" ++ (dbPathAbs </> \"package.conf.d\")\n-                          , \"--expand-pkgroot\"\n-                          ]\n-       | length uniqSdkVersions <= 1 ->\n-           do forM_ dalfs $ \\dalf -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath dalf\n-                  createDirectoryIfMissing True (takeDirectory path)\n-                  BSL.writeFile path (ZipArchive.fromEntry dalf)\n-              forM_ confFiles $ \\conf ->\n-                  BSL.writeFile\n-                      (dbPath </> \"package.conf.d\" </>\n-                       (takeFileName $ ZipArchive.eRelativePath conf))\n-                      (ZipArchive.fromEntry conf)\n-              forM_ srcs $ \\src -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath src\n-                  write path (ZipArchive.fromEntry src)\n-              ghcPkgPath <- getGhcPkgPath\n-              callProcess\n-                  (ghcPkgPath </> exe \"ghc-pkg\")\n-                  [ \"recache\"\n-                  -- ghc-pkg insists on using a global package db and will try\n-                  -- to find one automatically if we don’t specify it here.\n-                  , \"--global-package-db=\" ++ (dbPath </> \"package.conf.d\")\n-                  , \"--expand-pkgroot\"\n-                  ]\n+                              dbPathAbs\n+                              projectPackageDatabaseAbs\n+                              unitIdStr\n+                              pkgIdStr\n+                              pkgName\n+                              mbPkgVersion\n+                              deps\n+\n+       | length uniqSdkVersions <= 1 -> installDar dbPath edConfFiles edDalfs edSrcs\n        | otherwise ->\n            fail $\n            \"Package dependencies from different SDK versions: \" ++\n            intercalate \", \" uniqSdkVersions\n   where\n-    write fp bs = createDirectoryIfMissing True (takeDirectory fp) >> BSL.writeFile fp bs\n-    getGhcPkgPath =\n-        if isWindows\n-            then locateRunfiles \"rules_haskell_ghc_windows_amd64/bin\"\n-            else locateRunfiles \"ghc_nix/lib/ghc-8.6.5/bin\"\n+    -- generate interface files and install them in the package database\n+    generateAndInstallIfaceFiles ::\n+           LF.Package\n+        -> [(NormalizedFilePath, String)]\n+        -> Options\n+        -> FilePath\n+        -> FilePath\n+        -> String\n+        -> String\n+        -> String\n+        -> Maybe String\n+        -> [String]\n+        -> IO ()\n+    generateAndInstallIfaceFiles dalf src opts dbPathAbs projectPackageDatabaseAbs unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n+        loggerH <- getLogger opts \"generate interface files\"\n+        mapM_ writeSrc src\n+        opts' <-\n+            mkOptions $\n+            opts\n+                { optWriteInterface = True\n+                , optPackageDbs = projectPackageDatabaseAbs : optPackageDbs opts\n+                , optIfaceDir = Just \"./\"\n+                , optIsGenerated = True\n+                , optDflagCheck = False\n+                , optMbPackageName = Just unitIdStr\n+                , optHideAllPkgs = False\n+                , optGhcCustomOpts = []\n+                , optPackageImports = []\n+                }\n+        withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+            runAction ide $\n+            writeIfacesAndHie\n+                (toNormalizedFilePath \"./\")\n+                [fp | (fp, _content) <- src]\n+        -- write the conf file and refresh the package cache\n+        let (cfPath, cfBs) =\n+                mkConfFile\n+                    PackageConfigFields\n+                        { pName = pkgName\n+                        , pSrc = \"\" -- not used\n+                        , pExposedModules = Nothing\n+                        , pVersion = mbPkgVersion\n+                        , pDependencies = deps\n+                        , pSdkVersion = \"unknown\"\n+                        , cliOpts = Nothing\n+                        }\n+                    (map T.unpack $ LF.packageModuleNames dalf)\n+                    pkgIdStr\n+        B.writeFile (dbPathAbs </> \"package.conf.d\" </> cfPath) cfBs\n+        ghcPkgPath <- getGhcPkgPath\n+        callProcess\n+            (ghcPkgPath </> exe \"ghc-pkg\")\n+            [ \"recache\"\n+            -- ghc-pkg insists on using a global package db and will try\n+            -- to find one automatically if we don’t specify it here.\n+            , \"--global-package-db=\" ++ (dbPathAbs </> \"package.conf.d\")\n+            , \"--expand-pkgroot\"\n+            ]\n+\n+-- | Write generated source files\n+writeSrc :: (NormalizedFilePath, String) -> IO ()\n+writeSrc (fp, content) = do\n+    let path = fromNormalizedFilePath fp\n+    createDirectoryIfMissing True $ takeDirectory path\n+    writeFileUTF8 path content\n+\n+-- | Locate ghc-pkg\n+getGhcPkgPath :: IO FilePath\n+getGhcPkgPath =\n+    if isWindows\n+        then locateRunfiles \"rules_haskell_ghc_windows_amd64/bin\"\n+        else locateRunfiles \"ghc_nix/lib/ghc-8.6.5/bin\"\n+\n+data ExtractedDar = ExtractedDar\n+    { edSdkVersions :: [String]\n+    , edMain :: [ZipArchive.Entry]\n+    , edConfFiles :: [ZipArchive.Entry]\n+    , edDalfs :: [ZipArchive.Entry]\n+    , edSrcs :: [ZipArchive.Entry]\n+    }\n \n+instance Semigroup ExtractedDar where\n+    (<>) d1 d2 ="
  },
  {
    "id" : "1c4fcd18-ec60-4018-a19b-32e205b3f2f4",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "7d8869b6-b62f-40de-bd9a-236cd48c5e5e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This should consult the manifest instead of globbing for files.",
        "createdAt" : "2019-11-05T14:38:39Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "50da2bad-8120-4c8d-b06c-e3183af3aa5a",
        "parentId" : "7d8869b6-b62f-40de-bd9a-236cd48c5e5e",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I don't think we have anything in the manifest describing the .conf files.",
        "createdAt" : "2019-11-05T15:30:04Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "083afcc5-94fa-4d75-8dcc-379dc0158498",
        "parentId" : "7d8869b6-b62f-40de-bd9a-236cd48c5e5e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "But we do have the dalfs.",
        "createdAt" : "2019-11-05T16:09:27Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bfae3049-f8dd-40fe-91b1-95c62be17efd",
        "parentId" : "7d8869b6-b62f-40de-bd9a-236cd48c5e5e",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "that's true, we can change it for the dalfs.",
        "createdAt" : "2019-11-05T16:14:32Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c690c1ac-699c-4471-8d74-5ab5ae135c2a",
        "parentId" : "7d8869b6-b62f-40de-bd9a-236cd48c5e5e",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "done.",
        "createdAt" : "2019-11-05T16:26:54Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : null,
    "diffHunk" : "@@ -565,124 +551,237 @@ createProjectPackageDb opts fps = do\n               -- mapping from package id's to unit id's. if the same package is imported with\n               -- different unit id's, we would loose a unit id here.\n               let pkgMap =\n-                      MS.fromList [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n+                      MS.fromList\n+                          [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n               -- order the packages in topological order\n               let (depGraph, vertexToNode, _keyToVertex) =\n                       graphFromEdges $ do\n                           (pkgId, dalf, bs, unitId) <- pkgs\n                           let pkgRefs =\n-                                  [pid | LF.PRImport pid <- toListOf packageRefs dalf]\n-                          let src = generateSrcPkgFromLf pkgId pkgMap dalf\n-                          pure ((src, unitId, dalf, bs), pkgId, pkgRefs)\n+                                  [ pid\n+                                  | LF.PRImport pid <- toListOf packageRefs dalf\n+                                  ]\n+                          let getUid = getUnitId unitId pkgMap\n+                          let src = generateSrcPkgFromLf getUid pkgId dalf\n+                          pure\n+                              ( (src, unitId, dalf, bs)\n+                              , pkgId\n+                              , pkgRefs)\n               let pkgIdsTopoSorted = reverse $ topSort depGraph\n-              ghcPkgPath <- getGhcPkgPath\n               dbPathAbs <- makeAbsolute dbPath\n               projectPackageDatabaseAbs <- makeAbsolute projectPackageDatabase\n               forM_ pkgIdsTopoSorted $ \\vertex -> do\n-                  let ((src, uid, dalf, bs), pkgId, _) = vertexToNode vertex\n+                  let ((src, uid, dalf, bs), pkgId, _) =\n+                          vertexToNode vertex\n                   when (uid /= primUnitId) $ do\n                       let unitIdStr = unitIdString uid\n                       let pkgIdStr = T.unpack $ LF.unPackageId pkgId\n+                      let (pkgName, mbPkgVersion) =\n+                              fromMaybe (unitIdStr, Nothing) $ do\n+                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n+                                  guard $ all (`elem` '.' : ['0' .. '9']) ver\n+                                  Just (uId, Just ver)\n+                      let deps =\n+                              [ unitIdString uId <.> \"dalf\"\n+                              | ((_src, uId, _dalf, _bs), pId, _) <-\n+                                    map vertexToNode $ reachable depGraph vertex\n+                              , pkgId /= pId\n+                              ]\n                       let workDir = dbPath </> unitIdStr <> \"-\" <> pkgIdStr\n                       createDirectoryIfMissing True workDir\n                       -- write the dalf package\n                       B.writeFile (workDir </> unitIdStr <.> \"dalf\") bs\n                       -- we change the working dir so that we get correct file paths for the\n                       -- interface files.\n                       withCurrentDirectory workDir $\n-                       -- typecheck and generate interface files\n-                       do\n-                          forM_ src $ \\(fp, content) -> do\n-                              let path = fromNormalizedFilePath fp\n-                              createDirectoryIfMissing True $ takeDirectory path\n-                              writeFileUTF8 path content\n-                          opts' <-\n-                              mkOptions $\n+                          generateAndInstallIfaceFiles\n+                              dalf\n+                              src\n                               opts\n-                                  { optWriteInterface = True\n-                                  , optPackageDbs =\n-                                        projectPackageDatabaseAbs : optPackageDbs opts\n-                                  , optIfaceDir = Just \"./\"\n-                                  , optIsGenerated = True\n-                                  , optDflagCheck = False\n-                                  , optMbPackageName = Just unitIdStr\n-                                  , optHideAllPkgs = False\n-                                  , optPackageImports = []\n-                                  , optGhcCustomOpts = []\n-                                  }\n-                          withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n-                              runAction ide $\n-                              writeIfacesAndHie\n-                                  (toNormalizedFilePath \"./\")\n-                                  [fp | (fp, _content) <- src]\n-                      let deps =\n-                              [ unitIdString uId <.> \"dalf\"\n-                              | ((_src, uId, _dalf, _bs), pId, _) <-\n-                                    map vertexToNode $ reachable depGraph vertex\n-                              , pkgId /= pId\n-                              ]\n-                      -- write the conf file and refresh the package cache\n-                      let (pkgName, pkgVersion) =\n-                            fromMaybe (unitIdStr, Nothing) $\n-                                do\n-                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n-                                  guard $ all (`elem` '.':['0' .. '9']) ver\n-                                  Just (uId, Just ver)\n-                      let (cfPath, cfBs) =\n-                              mkConfFile\n-                                  PackageConfigFields\n-                                      { pName = pkgName\n-                                      , pSrc = \"\" -- not used\n-                                      , pExposedModules = Nothing\n-                                      , pVersion = pkgVersion\n-                                      , pDependencies = deps\n-                                      , pSdkVersion = \"unknown\"\n-                                      , cliOpts = Nothing\n-                                      }\n-                                  (map T.unpack $ LF.packageModuleNames dalf)\n-                                  pkgIdStr\n-                      B.writeFile (dbPathAbs </> \"package.conf.d\" </> cfPath) cfBs\n-                      callProcess\n-                          (ghcPkgPath </> exe \"ghc-pkg\")\n-                          [ \"recache\"\n-                          -- ghc-pkg insists on using a global package db and will try\n-                          -- to find one automatically if we don’t specify it here.\n-                          , \"--global-package-db=\" ++ (dbPathAbs </> \"package.conf.d\")\n-                          , \"--expand-pkgroot\"\n-                          ]\n-       | length uniqSdkVersions <= 1 ->\n-           do forM_ dalfs $ \\dalf -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath dalf\n-                  createDirectoryIfMissing True (takeDirectory path)\n-                  BSL.writeFile path (ZipArchive.fromEntry dalf)\n-              forM_ confFiles $ \\conf ->\n-                  BSL.writeFile\n-                      (dbPath </> \"package.conf.d\" </>\n-                       (takeFileName $ ZipArchive.eRelativePath conf))\n-                      (ZipArchive.fromEntry conf)\n-              forM_ srcs $ \\src -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath src\n-                  write path (ZipArchive.fromEntry src)\n-              ghcPkgPath <- getGhcPkgPath\n-              callProcess\n-                  (ghcPkgPath </> exe \"ghc-pkg\")\n-                  [ \"recache\"\n-                  -- ghc-pkg insists on using a global package db and will try\n-                  -- to find one automatically if we don’t specify it here.\n-                  , \"--global-package-db=\" ++ (dbPath </> \"package.conf.d\")\n-                  , \"--expand-pkgroot\"\n-                  ]\n+                              dbPathAbs\n+                              projectPackageDatabaseAbs\n+                              unitIdStr\n+                              pkgIdStr\n+                              pkgName\n+                              mbPkgVersion\n+                              deps\n+\n+       | length uniqSdkVersions <= 1 -> installDar dbPath edConfFiles edDalfs edSrcs\n        | otherwise ->\n            fail $\n            \"Package dependencies from different SDK versions: \" ++\n            intercalate \", \" uniqSdkVersions\n   where\n-    write fp bs = createDirectoryIfMissing True (takeDirectory fp) >> BSL.writeFile fp bs\n-    getGhcPkgPath =\n-        if isWindows\n-            then locateRunfiles \"rules_haskell_ghc_windows_amd64/bin\"\n-            else locateRunfiles \"ghc_nix/lib/ghc-8.6.5/bin\"\n+    -- generate interface files and install them in the package database\n+    generateAndInstallIfaceFiles ::\n+           LF.Package\n+        -> [(NormalizedFilePath, String)]\n+        -> Options\n+        -> FilePath\n+        -> FilePath\n+        -> String\n+        -> String\n+        -> String\n+        -> Maybe String\n+        -> [String]\n+        -> IO ()\n+    generateAndInstallIfaceFiles dalf src opts dbPathAbs projectPackageDatabaseAbs unitIdStr pkgIdStr pkgName mbPkgVersion deps = do\n+        loggerH <- getLogger opts \"generate interface files\"\n+        mapM_ writeSrc src\n+        opts' <-\n+            mkOptions $\n+            opts\n+                { optWriteInterface = True\n+                , optPackageDbs = projectPackageDatabaseAbs : optPackageDbs opts\n+                , optIfaceDir = Just \"./\"\n+                , optIsGenerated = True\n+                , optDflagCheck = False\n+                , optMbPackageName = Just unitIdStr\n+                , optHideAllPkgs = False\n+                , optGhcCustomOpts = []\n+                , optPackageImports = []\n+                }\n+        withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+            runAction ide $\n+            writeIfacesAndHie\n+                (toNormalizedFilePath \"./\")\n+                [fp | (fp, _content) <- src]\n+        -- write the conf file and refresh the package cache\n+        let (cfPath, cfBs) =\n+                mkConfFile\n+                    PackageConfigFields\n+                        { pName = pkgName\n+                        , pSrc = \"\" -- not used\n+                        , pExposedModules = Nothing\n+                        , pVersion = mbPkgVersion\n+                        , pDependencies = deps\n+                        , pSdkVersion = \"unknown\"\n+                        , cliOpts = Nothing\n+                        }\n+                    (map T.unpack $ LF.packageModuleNames dalf)\n+                    pkgIdStr\n+        B.writeFile (dbPathAbs </> \"package.conf.d\" </> cfPath) cfBs\n+        ghcPkgPath <- getGhcPkgPath\n+        callProcess\n+            (ghcPkgPath </> exe \"ghc-pkg\")\n+            [ \"recache\"\n+            -- ghc-pkg insists on using a global package db and will try\n+            -- to find one automatically if we don’t specify it here.\n+            , \"--global-package-db=\" ++ (dbPathAbs </> \"package.conf.d\")\n+            , \"--expand-pkgroot\"\n+            ]\n+\n+-- | Write generated source files\n+writeSrc :: (NormalizedFilePath, String) -> IO ()\n+writeSrc (fp, content) = do\n+    let path = fromNormalizedFilePath fp\n+    createDirectoryIfMissing True $ takeDirectory path\n+    writeFileUTF8 path content\n+\n+-- | Locate ghc-pkg\n+getGhcPkgPath :: IO FilePath\n+getGhcPkgPath =\n+    if isWindows\n+        then locateRunfiles \"rules_haskell_ghc_windows_amd64/bin\"\n+        else locateRunfiles \"ghc_nix/lib/ghc-8.6.5/bin\"\n+\n+data ExtractedDar = ExtractedDar\n+    { edSdkVersions :: [String]\n+    , edMain :: [ZipArchive.Entry]\n+    , edConfFiles :: [ZipArchive.Entry]\n+    , edDalfs :: [ZipArchive.Entry]\n+    , edSrcs :: [ZipArchive.Entry]\n+    }\n \n+instance Semigroup ExtractedDar where\n+    (<>) d1 d2 =\n+        ExtractedDar\n+            { edSdkVersions = edSdkVersions d1 ++ edSdkVersions d2\n+            , edMain = edMain d1 ++ edMain d2\n+            , edConfFiles = edConfFiles d1 ++ edConfFiles d2\n+            , edDalfs = edDalfs d1 ++ edDalfs d2\n+            , edSrcs = edSrcs d1 ++ edSrcs d2\n+            }\n+\n+instance Monoid ExtractedDar where\n+    mempty = ExtractedDar [] [] [] [] []\n+\n+-- | Extract a dar archive\n+extractDar :: FilePath -> IO ExtractedDar\n+extractDar fp = do\n+    bs <- BSL.readFile fp\n+    let archive = ZipArchive.toArchive bs\n+    manifest <- getEntry manifestPath archive\n+    dalfManifest <- either fail pure $ readDalfManifest archive\n+    mainDalfEntry <- getEntry (mainDalfPath dalfManifest) archive\n+    sdkVersion <-\n+        case parseManifestFile $ BSL.toStrict $ ZipArchive.fromEntry manifest of\n+            Left err -> fail err\n+            Right manifest ->\n+                case lookup \"Sdk-Version\" manifest of\n+                    Nothing -> fail \"No Sdk-Version entry in manifest\"\n+                    Just version -> pure $! trim $ BSUTF8.toString version\n+    let confFiles =\n+            [ e\n+            | e <- ZipArchive.zEntries archive\n+            , \".conf\" `isExtensionOf` ZipArchive.eRelativePath e\n+            ]\n+    let dalfs ="
  },
  {
    "id" : "35d80e34-7c23-48a5-bffc-de712f78ad8e",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "9d5374c9-f034-49f9-b0c0-be935262bd62",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a reason why we can’t always go for the first case, even if the SDK versions are different? Either way we should document this in a comment.",
        "createdAt" : "2019-11-05T14:53:11Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "60894777-4de8-418b-85b8-ed4ff5df8bd0",
        "parentId" : "9d5374c9-f034-49f9-b0c0-be935262bd62",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "If we have different sdks we need to allow this with the flag --allow-different-sdks and also import the created instances modules with aliases. If not, we only need aliases for the modules of the two equally named packages. You can't add aliases for the instances modules in the later case, because they are not generated. I'll add a comment.",
        "createdAt" : "2019-11-05T16:10:33Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : 446,
    "diffHunk" : "@@ -861,68 +960,60 @@ execMigrate projectOpts inFile1_ inFile2_ mbDir =\n       withProjectRoot' projectOpts $ \\_relativize\n        -> do\n           -- get the package name and the lf-package\n-          [(pkgName1, pkgId1, lfPkg1, depMap1), (pkgName2, pkgId2, lfPkg2, depMap2)] <-\n+          [(pkgName1, _pkgId1, lfPkg1, sdkVer1), (pkgName2, _pkgId2, lfPkg2, sdkVer2)] <-\n               forM [inFile1, inFile2] $ \\inFile -> do\n                   bytes <- B.readFile inFile\n                   let dar = ZipArchive.toArchive $ BSL.fromStrict bytes\n                   -- get the main pkg\n                   dalfManifest <- either fail pure $ readDalfManifest dar\n                   let pkgName = takeBaseName $ mainDalfPath dalfManifest\n-                  let dalfs = dalfPaths dalfManifest\n-                  deps <-\n-                      forM dalfs $ \\dalfPath -> do\n-                          dalf <- getEntry dalfPath dar\n-                          (pkgId, _pkg) <- decode $ BSL.toStrict $ ZipArchive.fromEntry dalf\n-                          pure (pkgId, stringToUnitId $ takeBaseName dalfPath)\n                   mainDalfEntry <- getEntry (mainDalfPath dalfManifest) dar\n                   (mainPkgId, mainLfPkg) <- decode $ BSL.toStrict $ ZipArchive.fromEntry mainDalfEntry\n-                  pure (pkgName, mainPkgId, mainLfPkg, MS.fromList deps)\n-          let pkgMap = MS.union depMap1 depMap2\n+                  pure (pkgName, mainPkgId, mainLfPkg, sdkVersion dalfManifest)\n           -- generate upgrade modules and instances modules\n           let eqModNames =\n                   (NM.names $ LF.packageModules lfPkg1) `intersect`\n                   (NM.names $ LF.packageModules lfPkg2)\n+          thisSdkVer <- getSdkVersion\n+          let differentSdks = (length $ nubSort [sdkVer1, sdkVer2, thisSdkVer]) /= 1\n           let eqModNamesStr = map (T.unpack . LF.moduleNameString) eqModNames\n-          let buildOptions =\n+          let buildOptions0 =\n                   [ \"--allow-different-sdks\"\n-                  , \"'--package=\" <> show (pkgName1, [(m, m ++ \"A\") | m <- eqModNamesStr]) <> \"'\"\n+                  , \"'--package=\" <> show (\"instances-\" <> pkgName1\n+                                          , [(m', m' ++ \"A\")\n+                                            | m <- eqModNamesStr, let m' = m <> \"Instances\"\n+                                            ]\n+                                          ) <> \"'\"\n+                  , \"'--package=\" <> show (\"instances-\" <> pkgName2\n+                                          , [(m', m' ++ \"B\")\n+                                            | m <- eqModNamesStr, let m' = m <> \"Instances\"\n+                                            ]\n+                                          ) <> \"'\"\n+                  ]\n+          let buildOptions1 =\n+                  [ \"'--package=\" <> show (pkgName1, [(m, m ++ \"A\") | m <- eqModNamesStr]) <> \"'\"\n                   , \"'--package=\" <> show (pkgName2, [(m, m ++ \"B\") | m <- eqModNamesStr]) <> \"'\"\n-                  , \"--ghc-option=-Wno-unrecognised-pragmas\"\n                   ]\n+          let buildOptions\n+                  | differentSdks = buildOptions0 ++ buildOptions1\n+                  | otherwise = buildOptions1"
  },
  {
    "id" : "763d6fd3-7b21-4e2b-a8cd-83dbe9df9512",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "baba96f5-7ff3-4d4f-9c16-005e42ff811d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    command \"generate-generic-src\" $\r\n```",
        "createdAt" : "2019-11-05T14:57:51Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : null,
    "diffHunk" : "@@ -308,6 +310,16 @@ cmdGenerateSrc =\n   where\n     cmd = execGenerateSrc <$> inputDalfOpt\n \n+cmdGenerateGenSrc :: Mod CommandFields Command\n+cmdGenerateGenSrc =\n+    command \"generate-gen-src\" $"
  },
  {
    "id" : "ac781176-5842-4f68-9c2d-9820d16bd285",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "1b4c2b1c-d929-42cd-92fb-79d4f04fbde0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We now have a `generate-src` and a `generate-gen-src` command with `generate-src` accepting a DALF and `generate-gen-src` accepting a DAR. That seems like a rather confusing UX. Can we make them consistent?",
        "createdAt" : "2019-11-05T14:58:36Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "49bdabba-86c9-462c-9be6-2d8e411b22e6",
        "parentId" : "1b4c2b1c-d929-42cd-92fb-79d4f04fbde0",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I was thinking about it. But the use cases are a bit different. You typically will call generate-src if you want to debug something and wonder what source was created from the dalf. While you typically call generate-gen-src when you want generic instances in your migration project for your dars. If I would make the second input option a dalf as well, I'd force the user to unzip his packages.",
        "createdAt" : "2019-11-05T15:33:18Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : 522,
    "diffHunk" : "@@ -979,23 +1070,65 @@ execMergeDars darFp1 darFp2 mbOutFp =\n execGenerateSrc :: FilePath -> Command\n execGenerateSrc dalfFp = Command GenerateSrc effect\n   where\n+    unitId = stringToUnitId $ takeBaseName dalfFp\n     effect = do\n         bytes <- B.readFile dalfFp\n         case Archive.decodeArchive bytes of\n             Left err -> fail $ DA.Pretty.renderPretty err\n             Right (pkgId, pkg) -> do\n                 let genSrcs =\n                         generateSrcPkgFromLf\n+                            (\\pkgRef ->\n+                                 case pkgRef of\n+                                     LF.PRSelf -> unitId\n+                                     LF.PRImport pId\n+                                         | pkgId == pId -> unitId\n+                                         | otherwise ->\n+                                             error $\n+                                             \"Unknown package id: \" <> (T.unpack $ LF.unPackageId pkgId))\n                             pkgId\n-                            (MS.singleton\n-                                 pkgId\n-                                 (stringToUnitId $ takeBaseName dalfFp))\n                             pkg\n                 forM_ genSrcs $ \\(path, src) -> do\n                     let fp = fromNormalizedFilePath path\n                     createDirectoryIfMissing True $ takeDirectory fp\n                     writeFileUTF8 fp src\n \n+-- | Generate daml source files containing generic instances for data types.\n+execGenerateGenSrc :: FilePath -> Maybe String -> Maybe FilePath -> Command\n+execGenerateGenSrc darFp mbQual outDir = Command GenerateGenerics effect"
  },
  {
    "id" : "cee754ec-8fc5-40c1-8112-a87f27062949",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "ef5b614b-7b22-4d71-bfa1-5c9467e9197b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Do we need to change the work dir here? It looks like we can just pass in the directory and prefix the paths in `generateAndInstallIfaceFiles` which would imho be easier to understand and avoids modifying process-global state.",
        "createdAt" : "2019-11-05T15:01:16Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "418cd16d-b2e7-4704-a77b-06038a60296c",
        "parentId" : "ef5b614b-7b22-4d71-bfa1-5c9467e9197b",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I think we could do that but would prefer doing that in a separate PR to keep the noise of this already noisy PR lower.",
        "createdAt" : "2019-11-05T17:04:09Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : 132,
    "diffHunk" : "@@ -565,124 +551,237 @@ createProjectPackageDb opts fps = do\n               -- mapping from package id's to unit id's. if the same package is imported with\n               -- different unit id's, we would loose a unit id here.\n               let pkgMap =\n-                      MS.fromList [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n+                      MS.fromList\n+                          [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n               -- order the packages in topological order\n               let (depGraph, vertexToNode, _keyToVertex) =\n                       graphFromEdges $ do\n                           (pkgId, dalf, bs, unitId) <- pkgs\n                           let pkgRefs =\n-                                  [pid | LF.PRImport pid <- toListOf packageRefs dalf]\n-                          let src = generateSrcPkgFromLf pkgId pkgMap dalf\n-                          pure ((src, unitId, dalf, bs), pkgId, pkgRefs)\n+                                  [ pid\n+                                  | LF.PRImport pid <- toListOf packageRefs dalf\n+                                  ]\n+                          let getUid = getUnitId unitId pkgMap\n+                          let src = generateSrcPkgFromLf getUid pkgId dalf\n+                          pure\n+                              ( (src, unitId, dalf, bs)\n+                              , pkgId\n+                              , pkgRefs)\n               let pkgIdsTopoSorted = reverse $ topSort depGraph\n-              ghcPkgPath <- getGhcPkgPath\n               dbPathAbs <- makeAbsolute dbPath\n               projectPackageDatabaseAbs <- makeAbsolute projectPackageDatabase\n               forM_ pkgIdsTopoSorted $ \\vertex -> do\n-                  let ((src, uid, dalf, bs), pkgId, _) = vertexToNode vertex\n+                  let ((src, uid, dalf, bs), pkgId, _) =\n+                          vertexToNode vertex\n                   when (uid /= primUnitId) $ do\n                       let unitIdStr = unitIdString uid\n                       let pkgIdStr = T.unpack $ LF.unPackageId pkgId\n+                      let (pkgName, mbPkgVersion) =\n+                              fromMaybe (unitIdStr, Nothing) $ do\n+                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n+                                  guard $ all (`elem` '.' : ['0' .. '9']) ver\n+                                  Just (uId, Just ver)\n+                      let deps =\n+                              [ unitIdString uId <.> \"dalf\"\n+                              | ((_src, uId, _dalf, _bs), pId, _) <-\n+                                    map vertexToNode $ reachable depGraph vertex\n+                              , pkgId /= pId\n+                              ]\n                       let workDir = dbPath </> unitIdStr <> \"-\" <> pkgIdStr\n                       createDirectoryIfMissing True workDir\n                       -- write the dalf package\n                       B.writeFile (workDir </> unitIdStr <.> \"dalf\") bs\n                       -- we change the working dir so that we get correct file paths for the\n                       -- interface files.\n                       withCurrentDirectory workDir $"
  },
  {
    "id" : "9b710418-a757-4e36-90ae-61fba43f644a",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "16bbd2fe-7f2c-49e7-9692-be3907148b42",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we compare versions rather than comparing package ids? The latter seems like a more robust solution.",
        "createdAt" : "2019-11-05T15:05:09Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6e9ffc5a-e03f-43ca-8d6f-b77990b59622",
        "parentId" : "16bbd2fe-7f2c-49e7-9692-be3907148b42",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "we are not interested whether we have different package id's for the same package name, we want to know whether we have a mix of packages compiled with different sdks. Comparing package id's wouldn't work I think.",
        "createdAt" : "2019-11-05T15:34:47Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "62b05ce6-82f1-40b5-b4d8-8cdcb656eb5b",
        "parentId" : "16bbd2fe-7f2c-49e7-9692-be3907148b42",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I was thinking of comparing the package id of `daml-stdlib` not the main dalf.",
        "createdAt" : "2019-11-05T16:09:11Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b46004cb-9372-46bb-a4d5-f1322e3f0b17",
        "parentId" : "16bbd2fe-7f2c-49e7-9692-be3907148b42",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "ah I see. so you would want to get the version of the `daml-stdlib` to figure out this sdk version or also of all dependencies (which would fail in the rare case that a a package doesn't depend on the daml-stdlib).",
        "createdAt" : "2019-11-05T16:20:38Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : 422,
    "diffHunk" : "@@ -861,68 +960,60 @@ execMigrate projectOpts inFile1_ inFile2_ mbDir =\n       withProjectRoot' projectOpts $ \\_relativize\n        -> do\n           -- get the package name and the lf-package\n-          [(pkgName1, pkgId1, lfPkg1, depMap1), (pkgName2, pkgId2, lfPkg2, depMap2)] <-\n+          [(pkgName1, _pkgId1, lfPkg1, sdkVer1), (pkgName2, _pkgId2, lfPkg2, sdkVer2)] <-\n               forM [inFile1, inFile2] $ \\inFile -> do\n                   bytes <- B.readFile inFile\n                   let dar = ZipArchive.toArchive $ BSL.fromStrict bytes\n                   -- get the main pkg\n                   dalfManifest <- either fail pure $ readDalfManifest dar\n                   let pkgName = takeBaseName $ mainDalfPath dalfManifest\n-                  let dalfs = dalfPaths dalfManifest\n-                  deps <-\n-                      forM dalfs $ \\dalfPath -> do\n-                          dalf <- getEntry dalfPath dar\n-                          (pkgId, _pkg) <- decode $ BSL.toStrict $ ZipArchive.fromEntry dalf\n-                          pure (pkgId, stringToUnitId $ takeBaseName dalfPath)\n                   mainDalfEntry <- getEntry (mainDalfPath dalfManifest) dar\n                   (mainPkgId, mainLfPkg) <- decode $ BSL.toStrict $ ZipArchive.fromEntry mainDalfEntry\n-                  pure (pkgName, mainPkgId, mainLfPkg, MS.fromList deps)\n-          let pkgMap = MS.union depMap1 depMap2\n+                  pure (pkgName, mainPkgId, mainLfPkg, sdkVersion dalfManifest)\n           -- generate upgrade modules and instances modules\n           let eqModNames =\n                   (NM.names $ LF.packageModules lfPkg1) `intersect`\n                   (NM.names $ LF.packageModules lfPkg2)\n+          thisSdkVer <- getSdkVersion\n+          let differentSdks = (length $ nubSort [sdkVer1, sdkVer2, thisSdkVer]) /= 1"
  },
  {
    "id" : "12ff273d-058f-4704-92da-a7726e2ce204",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "2afca9b9-4b13-409d-b33c-0aa14df6192b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It would be nice to document the different cases. If I’m understanding this correctly we currently have the following.\r\n\r\n1. A single SDK version. In that case we use the interface files from the dar. It isn’t clear to me what happens with additional dalf files. It looks like `fpDalfs` is just ignored? That seems at best really confusing for users. In this case, I will get to data types as well as everything else.\r\n2. We have different SDK versions and this is not allowed (controlled via an option). In this case we will error out.\r\n3. We have different SDK versions and this is allowed. In this case, we will generate src files files and compile them to interface files. In this case I only get access to data types.\r\n\r\nThis seems fairly complex and confusing to users. In particular, 1 and 3 seem like fundamentally different operations. 1 is for importing a library, 3 is for importing data types so I can interact with templates on the ledger. How about we make this explicit, e.g., by having different fields in `daml.yaml` for the two?",
        "createdAt" : "2019-11-05T15:17:29Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3c24c38b-baa2-434b-b6d4-cadbab4384c3",
        "parentId" : "2afca9b9-4b13-409d-b33c-0aa14df6192b",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "If we have dalf imports we always do 3). I also think the different use cases are fairly confusing, in particular since this a DAML only thing. What fields with what semantics would you suggest in `daml.yaml`?",
        "createdAt" : "2019-11-05T17:10:30Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eea459f7-550b-4ce4-ac39-d9749cf15b24",
        "parentId" : "2afca9b9-4b13-409d-b33c-0aa14df6192b",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "we could have a field `imports` that allows only dars of the same sdk,  and one `data-imports` where we allow dalfs and different sdk versions.",
        "createdAt" : "2019-11-05T19:18:31Z",
        "updatedAt" : "2019-11-05T19:18:31Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1fc25d32-c97a-441c-930d-036373dc59e8",
        "parentId" : "2afca9b9-4b13-409d-b33c-0aa14df6192b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Something like that but let’s keep that for a separate PR. I’ll take another quick look tomorrow morning before approving but I think this PR should be good to land now :+1:",
        "createdAt" : "2019-11-05T19:20:57Z",
        "updatedAt" : "2019-11-05T19:20:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : null,
    "diffHunk" : "@@ -565,124 +551,237 @@ createProjectPackageDb opts fps = do\n               -- mapping from package id's to unit id's. if the same package is imported with\n               -- different unit id's, we would loose a unit id here.\n               let pkgMap =\n-                      MS.fromList [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n+                      MS.fromList\n+                          [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]\n               -- order the packages in topological order\n               let (depGraph, vertexToNode, _keyToVertex) =\n                       graphFromEdges $ do\n                           (pkgId, dalf, bs, unitId) <- pkgs\n                           let pkgRefs =\n-                                  [pid | LF.PRImport pid <- toListOf packageRefs dalf]\n-                          let src = generateSrcPkgFromLf pkgId pkgMap dalf\n-                          pure ((src, unitId, dalf, bs), pkgId, pkgRefs)\n+                                  [ pid\n+                                  | LF.PRImport pid <- toListOf packageRefs dalf\n+                                  ]\n+                          let getUid = getUnitId unitId pkgMap\n+                          let src = generateSrcPkgFromLf getUid pkgId dalf\n+                          pure\n+                              ( (src, unitId, dalf, bs)\n+                              , pkgId\n+                              , pkgRefs)\n               let pkgIdsTopoSorted = reverse $ topSort depGraph\n-              ghcPkgPath <- getGhcPkgPath\n               dbPathAbs <- makeAbsolute dbPath\n               projectPackageDatabaseAbs <- makeAbsolute projectPackageDatabase\n               forM_ pkgIdsTopoSorted $ \\vertex -> do\n-                  let ((src, uid, dalf, bs), pkgId, _) = vertexToNode vertex\n+                  let ((src, uid, dalf, bs), pkgId, _) =\n+                          vertexToNode vertex\n                   when (uid /= primUnitId) $ do\n                       let unitIdStr = unitIdString uid\n                       let pkgIdStr = T.unpack $ LF.unPackageId pkgId\n+                      let (pkgName, mbPkgVersion) =\n+                              fromMaybe (unitIdStr, Nothing) $ do\n+                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n+                                  guard $ all (`elem` '.' : ['0' .. '9']) ver\n+                                  Just (uId, Just ver)\n+                      let deps =\n+                              [ unitIdString uId <.> \"dalf\"\n+                              | ((_src, uId, _dalf, _bs), pId, _) <-\n+                                    map vertexToNode $ reachable depGraph vertex\n+                              , pkgId /= pId\n+                              ]\n                       let workDir = dbPath </> unitIdStr <> \"-\" <> pkgIdStr\n                       createDirectoryIfMissing True workDir\n                       -- write the dalf package\n                       B.writeFile (workDir </> unitIdStr <.> \"dalf\") bs\n                       -- we change the working dir so that we get correct file paths for the\n                       -- interface files.\n                       withCurrentDirectory workDir $\n-                       -- typecheck and generate interface files\n-                       do\n-                          forM_ src $ \\(fp, content) -> do\n-                              let path = fromNormalizedFilePath fp\n-                              createDirectoryIfMissing True $ takeDirectory path\n-                              writeFileUTF8 path content\n-                          opts' <-\n-                              mkOptions $\n+                          generateAndInstallIfaceFiles\n+                              dalf\n+                              src\n                               opts\n-                                  { optWriteInterface = True\n-                                  , optPackageDbs =\n-                                        projectPackageDatabaseAbs : optPackageDbs opts\n-                                  , optIfaceDir = Just \"./\"\n-                                  , optIsGenerated = True\n-                                  , optDflagCheck = False\n-                                  , optMbPackageName = Just unitIdStr\n-                                  , optHideAllPkgs = False\n-                                  , optPackageImports = []\n-                                  , optGhcCustomOpts = []\n-                                  }\n-                          withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n-                              runAction ide $\n-                              writeIfacesAndHie\n-                                  (toNormalizedFilePath \"./\")\n-                                  [fp | (fp, _content) <- src]\n-                      let deps =\n-                              [ unitIdString uId <.> \"dalf\"\n-                              | ((_src, uId, _dalf, _bs), pId, _) <-\n-                                    map vertexToNode $ reachable depGraph vertex\n-                              , pkgId /= pId\n-                              ]\n-                      -- write the conf file and refresh the package cache\n-                      let (pkgName, pkgVersion) =\n-                            fromMaybe (unitIdStr, Nothing) $\n-                                do\n-                                  (uId, ver) <- stripInfixEnd \"-\" unitIdStr\n-                                  guard $ all (`elem` '.':['0' .. '9']) ver\n-                                  Just (uId, Just ver)\n-                      let (cfPath, cfBs) =\n-                              mkConfFile\n-                                  PackageConfigFields\n-                                      { pName = pkgName\n-                                      , pSrc = \"\" -- not used\n-                                      , pExposedModules = Nothing\n-                                      , pVersion = pkgVersion\n-                                      , pDependencies = deps\n-                                      , pSdkVersion = \"unknown\"\n-                                      , cliOpts = Nothing\n-                                      }\n-                                  (map T.unpack $ LF.packageModuleNames dalf)\n-                                  pkgIdStr\n-                      B.writeFile (dbPathAbs </> \"package.conf.d\" </> cfPath) cfBs\n-                      callProcess\n-                          (ghcPkgPath </> exe \"ghc-pkg\")\n-                          [ \"recache\"\n-                          -- ghc-pkg insists on using a global package db and will try\n-                          -- to find one automatically if we don’t specify it here.\n-                          , \"--global-package-db=\" ++ (dbPathAbs </> \"package.conf.d\")\n-                          , \"--expand-pkgroot\"\n-                          ]\n-       | length uniqSdkVersions <= 1 ->\n-           do forM_ dalfs $ \\dalf -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath dalf\n-                  createDirectoryIfMissing True (takeDirectory path)\n-                  BSL.writeFile path (ZipArchive.fromEntry dalf)\n-              forM_ confFiles $ \\conf ->\n-                  BSL.writeFile\n-                      (dbPath </> \"package.conf.d\" </>\n-                       (takeFileName $ ZipArchive.eRelativePath conf))\n-                      (ZipArchive.fromEntry conf)\n-              forM_ srcs $ \\src -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath src\n-                  write path (ZipArchive.fromEntry src)\n-              ghcPkgPath <- getGhcPkgPath\n-              callProcess\n-                  (ghcPkgPath </> exe \"ghc-pkg\")\n-                  [ \"recache\"\n-                  -- ghc-pkg insists on using a global package db and will try\n-                  -- to find one automatically if we don’t specify it here.\n-                  , \"--global-package-db=\" ++ (dbPath </> \"package.conf.d\")\n-                  , \"--expand-pkgroot\"\n-                  ]\n+                              dbPathAbs\n+                              projectPackageDatabaseAbs\n+                              unitIdStr\n+                              pkgIdStr\n+                              pkgName\n+                              mbPkgVersion\n+                              deps\n+\n+       | length uniqSdkVersions <= 1 -> installDar dbPath edConfFiles edDalfs edSrcs"
  },
  {
    "id" : "9e680b36-89d8-41a8-a5d5-5772abe70ad4",
    "prId" : 3176,
    "comments" : [
      {
        "id" : "5bf6cf53-5248-4dcd-9365-614a0ab4f961",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I guess deduplication of DALFs with the same package id happens at this step? probably worth pointing out in a comment.",
        "createdAt" : "2019-10-15T12:04:48Z",
        "updatedAt" : "2019-10-15T14:51:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cef4c94d-3a11-4cd9-91a2-2d67c8b1a7b9",
        "parentId" : "5bf6cf53-5248-4dcd-9365-614a0ab4f961",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "added a comment.",
        "createdAt" : "2019-10-15T12:38:41Z",
        "updatedAt" : "2019-10-15T14:51:02Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "45fdc25e48bcb73c44106adba42b01b2161be66a",
    "line" : 85,
    "diffHunk" : "@@ -531,72 +532,51 @@ createProjectPackageDb opts fps = do\n                           [\".daml\", \".hie\", \".hi\"]\n                     ]\n             pure ([sdkVersion], confFiles, dalfs, srcs)\n+\n     let uniqSdkVersions = nubSort sdkVersions\n-    if | length uniqSdkVersions <= 1 ->\n-           do forM_ dalfs $ \\dalf -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath dalf\n-                  createDirectoryIfMissing True (takeDirectory path)\n-                  BSL.writeFile path (ZipArchive.fromEntry dalf)\n-              forM_ confFiles $ \\conf ->\n-                  BSL.writeFile\n-                      (dbPath </> \"package.conf.d\" </>\n-                       (takeFileName $ ZipArchive.eRelativePath conf))\n-                      (ZipArchive.fromEntry conf)\n-              forM_ srcs $ \\src -> do\n-                  let path = dbPath </> ZipArchive.eRelativePath src\n-                  write path (ZipArchive.fromEntry src)\n-              ghcPkgPath <- getGhcPkgPath\n-              callProcess\n-                  (ghcPkgPath </> exe \"ghc-pkg\")\n-                  [ \"recache\"\n-                  -- ghc-pkg insists on using a global package db and will try\n-                  -- to find one automatically if we don’t specify it here.\n-                  , \"--global-package-db=\" ++ (dbPath </> \"package.conf.d\")\n-                  , \"--expand-pkgroot\"\n-                  ]\n-       | length uniqSdkVersions > 1 && optAllowDifferentSdks opts ->\n-            -- when we compile packages with different sdk versions, we need to generate the interface files\n+    if | length uniqSdkVersions > 1 && optAllowDifferentSdks opts || not (null fpDalfs) ->\n+            -- when we compile packages with different sdk versions or with dalf dependencies, we\n+            -- need to generate the interface files\n            do loggerH <- getLogger opts \"generate interface files\"\n+              let dalfsFromDars =\n+                      [ ( dropExtension $ takeFileName $ ZipArchive.eRelativePath e\n+                        , BSL.toStrict $ ZipArchive.fromEntry e)\n+                      | e <- dalfs\n+                      ]\n+              dalfsFromFps <-\n+                  forM fpDalfs $ \\fp -> do\n+                      bs <- B.readFile fp\n+                      pure (dropExtension $ takeFileName fp, bs)\n+              let allDalfs = dalfsFromDars ++ dalfsFromFps\n               pkgs <-\n-                  forM dalfs $ \\dalf -> do\n-                      let dalfBS = BSL.toStrict $ ZipArchive.fromEntry dalf\n+                  forM allDalfs $ \\(name, dalf) -> do\n                       (pkgId, package) <-\n                           either (fail . DA.Pretty.renderPretty) pure $\n-                          Archive.decodeArchive dalfBS\n-                      pure\n-                          ( LF.rewriteSelfReferences pkgId package\n-                          , stringToUnitId $\n-                            dropExtension $\n-                            takeFileName $ ZipArchive.eRelativePath dalf)\n+                          Archive.decodeArchive dalf\n+                      pure (pkgId, package, dalf, stringToUnitId name)\n               let pkgMap =\n-                      MS.fromList\n-                          [ (pkgId, unitId)\n-                          | (LF.ExternalPackage pkgId _pkg, unitId) <- pkgs\n-                          ]\n+                      MS.fromList [(pkgId, unitId) | (pkgId, _pkg, _bs, unitId) <- pkgs]"
  },
  {
    "id" : "d047c3e5-70ef-46fc-b75f-55f599b02ebf",
    "prId" : 3140,
    "comments" : [
      {
        "id" : "450db803-80ca-4a4d-985c-b127fa140b6f",
        "parentId" : null,
        "author" : null,
        "body" : "Would it be better to just have one case to compiling the package db, whether it be with one or multiple SDKs? I guess it would be slower...",
        "createdAt" : "2019-10-09T12:17:57Z",
        "updatedAt" : "2019-10-09T12:26:05Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "7b206a45-d230-4530-a691-9315afb790e5",
        "parentId" : "450db803-80ca-4a4d-985c-b127fa140b6f",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "That would be a lot slower.",
        "createdAt" : "2019-10-09T15:10:40Z",
        "updatedAt" : "2019-10-09T15:10:40Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "344f106a-cd4e-40fe-be70-5de494043270",
        "parentId" : "450db803-80ca-4a4d-985c-b127fa140b6f",
        "author" : null,
        "body" : "Does that mean the \"slow route\" is also taken for packages in the current SDK, as long as there is a single dependency from another SDK?",
        "createdAt" : "2019-10-09T15:23:57Z",
        "updatedAt" : "2019-10-09T15:23:58Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "6bade7e1-0543-4ac1-a173-926ee43a9fbb",
        "parentId" : "450db803-80ca-4a4d-985c-b127fa140b6f",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "currently that would just fail. but yes, as soon as you have cross sdk dependencies, we generate the interface files.",
        "createdAt" : "2019-10-09T15:39:52Z",
        "updatedAt" : "2019-10-09T15:39:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "27bea24afe60cba9068df256b1e821564a3b0450",
    "line" : 269,
    "diffHunk" : "@@ -537,39 +530,144 @@ createProjectPackageDb (AllowDifferentSdkVersions allowDiffSdkVersions) lfVersio\n                     , takeExtension (ZipArchive.eRelativePath e) `elem`\n                           [\".daml\", \".hie\", \".hi\"]\n                     ]\n-            forM_ dalfs $ \\dalf -> do\n-                let path = dbPath </> ZipArchive.eRelativePath dalf\n-                createDirectoryIfMissing True (takeDirectory path)\n-                BSL.writeFile path (ZipArchive.fromEntry dalf)\n-            forM_ confFiles $ \\conf ->\n-                BSL.writeFile\n-                    (dbPath </> \"package.conf.d\" </>\n-                     (takeFileName $ ZipArchive.eRelativePath conf))\n-                    (ZipArchive.fromEntry conf)\n-            forM_ srcs $ \\src -> do\n-                let path = dbPath </> ZipArchive.eRelativePath src\n-                write path (ZipArchive.fromEntry src)\n-            pure sdkVersion\n+            pure ([sdkVersion], confFiles, dalfs, srcs)\n     let uniqSdkVersions = nubSort sdkVersions\n-    -- if there are no package dependencies, sdkVersions will be empty\n-    unless (length uniqSdkVersions <= 1 || allowDiffSdkVersions) $\n-        fail $\n-        \"Package dependencies from different SDK versions: \" ++\n-        intercalate \", \" uniqSdkVersions\n-    ghcPkgPath <-\n-        if isWindows\n-          then locateRunfiles \"rules_haskell_ghc_windows_amd64/bin\"\n-          else locateRunfiles \"ghc_nix/lib/ghc-8.6.5/bin\"\n-    callProcess\n-        (ghcPkgPath </> exe \"ghc-pkg\")\n-        [ \"recache\"\n-        -- ghc-pkg insists on using a global package db and will try\n-        -- to find one automatically if we don’t specify it here.\n-        , \"--global-package-db=\" ++ (dbPath </> \"package.conf.d\")\n-        , \"--expand-pkgroot\"\n-        ]\n+    if | length uniqSdkVersions <= 1 ->\n+           do forM_ dalfs $ \\dalf -> do\n+                  let path = dbPath </> ZipArchive.eRelativePath dalf\n+                  createDirectoryIfMissing True (takeDirectory path)\n+                  BSL.writeFile path (ZipArchive.fromEntry dalf)\n+              forM_ confFiles $ \\conf ->\n+                  BSL.writeFile\n+                      (dbPath </> \"package.conf.d\" </>\n+                       (takeFileName $ ZipArchive.eRelativePath conf))\n+                      (ZipArchive.fromEntry conf)\n+              forM_ srcs $ \\src -> do\n+                  let path = dbPath </> ZipArchive.eRelativePath src\n+                  write path (ZipArchive.fromEntry src)\n+              ghcPkgPath <- getGhcPkgPath\n+              callProcess\n+                  (ghcPkgPath </> exe \"ghc-pkg\")\n+                  [ \"recache\"\n+                  -- ghc-pkg insists on using a global package db and will try\n+                  -- to find one automatically if we don’t specify it here.\n+                  , \"--global-package-db=\" ++ (dbPath </> \"package.conf.d\")\n+                  , \"--expand-pkgroot\"\n+                  ]\n+       | length uniqSdkVersions > 1 && optAllowDifferentSdks opts ->\n+            -- when we compile packages with different sdk versions, we need to generate the interface files"
  },
  {
    "id" : "3422c1ee-c1b8-4650-b6dc-2d784517bf70",
    "prId" : 3129,
    "comments" : [
      {
        "id" : "a3da45a2-d5bf-4b08-b927-ff2bc8f64a43",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`inputDalfOpt` isn’t accurate. `inspect` can also take a `.dar` file and will the inspect the main dalf.",
        "createdAt" : "2019-10-08T13:06:09Z",
        "updatedAt" : "2019-10-08T14:02:37Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cdf13107-14bd-47a6-81f2-3f85451b752f",
        "parentId" : "a3da45a2-d5bf-4b08-b927-ff2bc8f64a43",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "hmm, before it was asking for a DAML file, which is completely off...",
        "createdAt" : "2019-10-08T13:57:55Z",
        "updatedAt" : "2019-10-08T14:02:37Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c5e37998edf3317adac5943b55b47b77ed37b228",
    "line" : null,
    "diffHunk" : "@@ -208,7 +209,7 @@ cmdInspect =\n     detailOpt =\n         fmap (maybe DA.Pretty.prettyNormal DA.Pretty.PrettyLevel) $\n             optional $ option auto $ long \"detail\" <> metavar \"LEVEL\" <> help \"Detail level of the pretty printed output (default: 0)\"\n-    cmd = execInspect <$> inputFileOpt <*> outputFileOpt <*> jsonOpt <*> detailOpt\n+    cmd = execInspect <$> inputDalfOpt <*> outputFileOpt <*> jsonOpt <*> detailOpt"
  },
  {
    "id" : "5b94ce3c-334d-4afe-945a-dbb5d3507acb",
    "prId" : 3129,
    "comments" : [
      {
        "id" : "59383b2e-988d-4c6e-a5c1-6779e42a8bc1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Should we add something like `-o output_directory`?",
        "createdAt" : "2019-10-08T13:09:15Z",
        "updatedAt" : "2019-10-08T14:02:37Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a6729f07-2670-4b43-9996-8ccc8fcdb442",
        "parentId" : "59383b2e-988d-4c6e-a5c1-6779e42a8bc1",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "let's keep it simple for now, I expect you create a directory where you put your dalf into and run this.",
        "createdAt" : "2019-10-08T13:57:22Z",
        "updatedAt" : "2019-10-08T14:02:37Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c5e37998edf3317adac5943b55b47b77ed37b228",
    "line" : 27,
    "diffHunk" : "@@ -303,6 +304,14 @@ cmdMergeDars =\n   where\n     cmd = execMergeDars <$> inputDarOpt <*> inputDarOpt <*> targetFileNameOpt\n \n+cmdGenerateSrc :: Mod CommandFields Command\n+cmdGenerateSrc =\n+    command \"generate-src\" $\n+    info (helper <*> cmd) $\n+    progDesc \"Generate DAML source code from a dalf package\" <> fullDesc\n+  where\n+    cmd = execGenerateSrc <$> inputDalfOpt"
  },
  {
    "id" : "72191dbb-6c36-42cd-8d89-260dc2106596",
    "prId" : 3129,
    "comments" : [
      {
        "id" : "f73ee147-cb18-42c0-9f55-d33af7d5d4cd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n                    writeFileUTF8 fp src\r\n```",
        "createdAt" : "2019-10-08T13:10:02Z",
        "updatedAt" : "2019-10-08T14:02:37Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c5e37998edf3317adac5943b55b47b77ed37b228",
    "line" : null,
    "diffHunk" : "@@ -913,6 +922,27 @@ execMergeDars darFp1 darFp2 mbOutFp =\n         pure $ ZipArchive.toEntry manifestPath 0 $ BSLC.unlines $\n             map (\\(k, v) -> breakAt72Bytes $ BSL.fromStrict $ k <> \": \" <> v) attrs1\n \n+-- | Generate daml source files from a dalf package.\n+execGenerateSrc :: FilePath -> Command\n+execGenerateSrc dalfFp = Command GenerateSrc effect\n+  where\n+    effect = do\n+        bytes <- B.readFile dalfFp\n+        case Archive.decodeArchive bytes of\n+            Left err -> fail $ DA.Pretty.renderPretty err\n+            Right (pkgId, pkg) -> do\n+                let genSrcs =\n+                        generateSrcPkgFromLf\n+                            pkgId\n+                            (MS.singleton\n+                                 (stringToUnitId $ takeBaseName dalfFp)\n+                                 pkgId)\n+                            pkg\n+                forM_ genSrcs $ \\(path, src) -> do\n+                    let fp = fromNormalizedFilePath path\n+                    createDirectoryIfMissing True $ takeDirectory fp\n+                    writeFile fp src"
  },
  {
    "id" : "b47ca581-a65c-4bfb-a230-ecca8b44c462",
    "prId" : 3056,
    "comments" : [
      {
        "id" : "0e68e678-94f5-4436-8772-c2ff9eeff130",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Might be easier to read if you do the case split inside of `expand`.",
        "createdAt" : "2019-09-30T06:50:01Z",
        "updatedAt" : "2019-09-30T08:33:54Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "83712e47-a7f7-4e79-aeb6-28ce157e7115",
        "parentId" : "0e68e678-94f5-4436-8772-c2ff9eeff130",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Agreed that's clearer, I've changed the code.\r\n\r\nI figured lifting the case match outside was probably more efficient. But, that's likely premature optimization and not really necessary.",
        "createdAt" : "2019-09-30T08:25:49Z",
        "updatedAt" : "2019-09-30T08:33:54Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "786a19fe7ad7ea34667648e63e53e9e2cca19fba",
    "line" : null,
    "diffHunk" : "@@ -480,7 +480,28 @@ createProjectPackageDb ::\n createProjectPackageDb (AllowDifferentSdkVersions allowDiffSdkVersions) lfVersion fps = do\n     let dbPath = projectPackageDatabase </> lfVersionString lfVersion\n     createDirectoryIfMissing True $ dbPath </> \"package.conf.d\"\n-    let fps0 = filter (`notElem` basePackages) fps\n+    -- Expand SDK package dependencies using the SDK root path.\n+    -- E.g. `daml-trigger` --> `$DAML_SDK/daml-libs/daml-trigger.dar`\n+    -- Or, fail if not run from DAML assistant.\n+    mbSdkPath <- handleIO (\\_ -> pure Nothing) $ Just <$> getSdkPath\n+    let isSdkPackage fp = takeExtension fp /= \".dar\"\n+        handleSdkPackages :: [FilePath] -> IO [FilePath]\n+        handleSdkPackages = case mbSdkPath of"
  },
  {
    "id" : "32e047f7-7d08-4c8f-8a2a-de07e39cb697",
    "prId" : 2949,
    "comments" : [
      {
        "id" : "fa9d781c-cb3d-4f61-bae0-91a08f04089f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why is this conditional on writing interface files?",
        "createdAt" : "2019-09-18T12:34:13Z",
        "updatedAt" : "2019-09-18T13:22:46Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dae924b5-00e9-40ea-971a-bdb7dc2f3a60",
        "parentId" : "fa9d781c-cb3d-4f61-bae0-91a08f04089f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, this should move outside and before the `when`.",
        "createdAt" : "2019-09-18T12:35:18Z",
        "updatedAt" : "2019-09-18T13:22:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5908785b-3933-4543-8093-780b1748cacf",
        "parentId" : "fa9d781c-cb3d-4f61-bae0-91a08f04089f",
        "author" : null,
        "body" : "On it.",
        "createdAt" : "2019-09-18T13:16:55Z",
        "updatedAt" : "2019-09-18T13:22:46Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "974bfa331c8395b8406d28a2d65853355c09e3c8",
    "line" : null,
    "diffHunk" : "@@ -378,21 +378,22 @@ execCompile inputFile outputFile opts =\n           setFilesOfInterest ide (Set.singleton inputFile)\n           runAction ide $ do\n             when (optWriteInterface opts') $ do\n+\n+                -- Support for '-ddump-parsed', '-ddump-parsed-ast', '-dsource-stats'."
  },
  {
    "id" : "dfb8225d-8249-4521-9d54-6b32db54dd4a",
    "prId" : 2895,
    "comments" : [
      {
        "id" : "b047fba7-4561-44e4-8b2d-1ff0cc65072f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We could wrap this into one `liftIO` black, like\r\n```\r\nliftIO $ do\r\n  ErrUtils.dumpIfSet_dyn ...\r\n  ErrUtils.dumpIfSet_dyn ...\r\n  ...\r\n```\r\nif you like that more.",
        "createdAt" : "2019-09-13T11:35:53Z",
        "updatedAt" : "2019-09-13T12:59:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6ce18157-527d-4572-907f-6a6b49e541bb",
        "parentId" : "b047fba7-4561-44e4-8b2d-1ff0cc65072f",
        "author" : null,
        "body" : "Ooh. Definitely. Will fix.",
        "createdAt" : "2019-09-13T12:09:28Z",
        "updatedAt" : "2019-09-13T12:59:47Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "981342602cdd2731aeae7b31cc887ba8840750aa",
    "line" : null,
    "diffHunk" : "@@ -373,8 +381,17 @@ execCompile inputFile outputFile opts =\n                 files <- nubSort . concatMap transitiveModuleDeps <$> use GetDependencies inputFile\n                 mbIfaces <- writeIfacesAndHie (toNormalizedFilePath $ fromMaybe ifaceDir $ optIfaceDir opts') files\n                 void $ liftIO $ mbErr \"ERROR: Compilation failed.\" mbIfaces\n+\n             mbDalf <- getDalf inputFile\n             dalf <- liftIO $ mbErr \"ERROR: Compilation failed.\" mbDalf\n+\n+            -- Support for '-ddump-parsed', '-ddump-parsed-ast', '-dsource-stats'.\n+            dflags <- hsc_dflags . hscEnv <$> use_ GhcSession inputFile\n+            parsed <- pm_parsed_source <$> use_ GetParsedModule inputFile\n+            liftIO $ ErrUtils.dumpIfSet_dyn dflags Opt_D_dump_parsed \"Parser\" $ GHC.ppr parsed"
  },
  {
    "id" : "49fdcb7b-d8db-4b0b-8200-3eff0cb964e5",
    "prId" : 2772,
    "comments" : [
      {
        "id" : "06049199-7712-4986-84f8-27dfbb431627",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if we really want to allow all arguments here. The issue with that is that `daml build` accepts different options than `daml ide` so you can end up creating a `daml.yaml` that works with `daml build` but not with `daml ide`. In #2676 I suggested only allowing `--ghc-option` initially which avoids this issue and I would probably also make this logic specific to `execIde` and `execBuild` so we avoid issue with commands that don’t accept `--ghc-option`.",
        "createdAt" : "2019-09-05T14:06:16Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "20f86852-893d-47b3-9a0b-268463ce409d",
        "parentId" : "06049199-7712-4986-84f8-27dfbb431627",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "That all seems a lot harder to grasp as a mental model for users. \"Add these to all invocations of damlc\" seems plain enough, and matches the name `damlc-options`; \"Add these to only damlc ide and damlc build, and it only supports a subbset of the options they support, and we may change how this behaves in the future\" would seem a bit harder for me as a user. I would personally prefer the simple, straightforward behaviour even if it sometimes mean I end up cutting myself.",
        "createdAt" : "2019-09-05T16:00:28Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "10be3b32-56ec-4094-b79b-10a1f8efc736",
        "parentId" : "06049199-7712-4986-84f8-27dfbb431627",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m fine with allowing arbitrary flags and expecting users to get this right but I believe that we do at least need to limit the commands affected by this.\r\nThere are some commands that do not support `--ghc-options` (e.g. `damlc visualize`) so you would literally be unable to have a `daml.yaml` that sets `--ghc-options` for `damlc build` and `damlc ide` while not breaking `damlc visualize`.",
        "createdAt" : "2019-09-05T16:15:33Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ccad67cf98292f7fae9420c08748172e68348f0e",
    "line" : 922,
    "diffHunk" : "@@ -982,12 +984,26 @@ parserInfo numProcessors =\n         ])\n     )\n \n+cliArgsFromDamlYaml :: IO [String]\n+cliArgsFromDamlYaml = do\n+    handle (\\(_ :: ConfigError) -> return [])\n+           $ do\n+               project <- readProjectConfig $ ProjectPath \".\"\n+               case parseProjectConfig project of\n+                   Left _ -> return []\n+                   Right pkgConfig -> case cliOpts pkgConfig of\n+                       Nothing -> return []\n+                       Just xs -> return xs\n+\n main :: IO ()\n main = do\n     -- We need this to ensure that logs are flushed on SIGTERM.\n     installSignalHandlers\n     numProcessors <- getNumProcessors\n-    withProgName \"damlc\" $ join $ execParserLax (parserInfo numProcessors)\n+    cliArgs <- Env.getArgs\n+    damlYamlArgs <- cliArgsFromDamlYaml"
  },
  {
    "id" : "2f57c8a3-6363-4ea8-bc49-ddbc8421d391",
    "prId" : 2772,
    "comments" : [
      {
        "id" : "c9f08aba-3c90-4835-9225-129c80ad66ae",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you move this to the next line, i.e., something like\r\n```\r\ndata CommandName\r\n  = Build\r\n  | …\r\n```\r\nyou won’t create large diffs if the length of `CommandName` changes.",
        "createdAt" : "2019-09-10T07:10:53Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ccad67cf98292f7fae9420c08748172e68348f0e",
    "line" : null,
    "diffHunk" : "@@ -90,12 +89,31 @@ import qualified Text.PrettyPrint.ANSI.Leijen      as PP\n -- Commands\n --------------------------------------------------------------------------------\n \n-cmdIde :: Mod CommandFields Command\n+data CommandName = Build"
  },
  {
    "id" : "41ddef2d-bf30-4183-8a57-d07d7f5a200a",
    "prId" : 2772,
    "comments" : [
      {
        "id" : "97229dc9-80a1-4001-8023-11d176d5450a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Newtypes around tuples are a bit weird. Usually you use `newtype` around a single type and if you have multiple fields you use `data`.",
        "createdAt" : "2019-09-10T07:12:14Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ccad67cf98292f7fae9420c08748172e68348f0e",
    "line" : null,
    "diffHunk" : "@@ -90,12 +89,31 @@ import qualified Text.PrettyPrint.ANSI.Leijen      as PP\n -- Commands\n --------------------------------------------------------------------------------\n \n-cmdIde :: Mod CommandFields Command\n+data CommandName = Build\n+                 | Clean\n+                 | Compile\n+                 | DamlDoc\n+                 | DocTest\n+                 | Ide\n+                 | Init\n+                 | Inspect\n+                 | InspectDar\n+                 | License\n+                 | Lint\n+                 | MergeDars\n+                 | Migrate\n+                 | Package\n+                 | Test\n+                 | Visual\n+                 deriving (Ord, Show, Eq)\n+newtype Command = Command (CommandName, IO ())"
  },
  {
    "id" : "a1d643fa-c42d-4233-a0e7-19871813b10d",
    "prId" : 2772,
    "comments" : [
      {
        "id" : "cadfb7c1-3ea7-40a4-b930-a687ed9dd3db",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not a huge fan of importing `optparse-applicative` qualified. I realize that it might be useful for someone new to Haskell but for someone that has a bit more experience it is imho annoying both for writing and for reading code as it adds unnecessary clutter.",
        "createdAt" : "2019-09-10T07:13:37Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ccad67cf98292f7fae9420c08748172e68348f0e",
    "line" : null,
    "diffHunk" : "@@ -90,12 +89,31 @@ import qualified Text.PrettyPrint.ANSI.Leijen      as PP\n -- Commands\n --------------------------------------------------------------------------------\n \n-cmdIde :: Mod CommandFields Command\n+data CommandName = Build\n+                 | Clean\n+                 | Compile\n+                 | DamlDoc\n+                 | DocTest\n+                 | Ide\n+                 | Init\n+                 | Inspect\n+                 | InspectDar\n+                 | License\n+                 | Lint\n+                 | MergeDars\n+                 | Migrate\n+                 | Package\n+                 | Test\n+                 | Visual\n+                 deriving (Ord, Show, Eq)\n+newtype Command = Command (CommandName, IO ())\n+\n+cmdIde :: Opt.Mod Opt.CommandFields Command\n cmdIde =\n-    command \"ide\" $ info (helper <*> cmd) $\n-       progDesc\n+    Opt.command \"ide\" $ Opt.info (Opt.helper <*> cmd) $"
  },
  {
    "id" : "c035a49b-9d09-4d8f-ab96-485663f70689",
    "prId" : 2772,
    "comments" : [
      {
        "id" : "9b61fcd7-c4a1-4a14-8293-ad6ab10c03e6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    let args = if cmd `elem` [Build, Compile, Ide]\r\n```\r\nI don’t see this list ever growing large enough to justify a `Set` over a linear list lookup.",
        "createdAt" : "2019-09-10T07:16:15Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ccad67cf98292f7fae9420c08748172e68348f0e",
    "line" : null,
    "diffHunk" : "@@ -985,23 +1033,46 @@ options numProcessors =\n         <> cmdClean\n       )\n \n-parserInfo :: Int -> ParserInfo Command\n+parserInfo :: Int -> Opt.ParserInfo Command\n parserInfo numProcessors =\n-  info (helper <*> options numProcessors)\n-    (  fullDesc\n-    <> progDesc \"Invoke the DAML compiler. Use -h for help.\"\n-    <> headerDoc (Just $ PP.vcat\n+  Opt.info (Opt.helper <*> options numProcessors)\n+    (  Opt.fullDesc\n+    <> Opt.progDesc \"Invoke the DAML compiler. Use -h for help.\"\n+    <> Opt.headerDoc (Just $ PP.vcat\n         [ \"damlc - Compiler and IDE backend for the Digital Asset Modelling Language\"\n         , buildInfo\n         ])\n     )\n \n+cliArgsFromDamlYaml :: IO [String]\n+cliArgsFromDamlYaml = do\n+    handle (\\(_ :: ConfigError) -> return [])\n+           $ do\n+               project <- readProjectConfig $ ProjectPath \".\"\n+               case parseProjectConfig project of\n+                   Left _ -> return []\n+                   Right pkgConfig -> case cliOpts pkgConfig of\n+                       Nothing -> return []\n+                       Just xs -> return xs\n+\n main :: IO ()\n main = do\n     -- We need this to ensure that logs are flushed on SIGTERM.\n     installSignalHandlers\n     numProcessors <- getNumProcessors\n-    withProgName \"damlc\" $ join $ execParserLax (parserInfo numProcessors)\n+    let parse = ParseArgs.lax (parserInfo numProcessors)\n+    cliArgs <- Env.getArgs\n+    damlYamlArgs <- cliArgsFromDamlYaml\n+    let (_, tempParseResult) = parse cliArgs\n+    Command(cmd, _) <- Opt.handleParseResult tempParseResult\n+    let args = if cmd `Set.member` Set.fromList [Build, Compile, Ide]"
  },
  {
    "id" : "e25e3a42-739f-4119-93d3-5dfc254e7c3a",
    "prId" : 2772,
    "comments" : [
      {
        "id" : "6d1ffef5-4265-47b3-bbad-854f1bc0e944",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Parsing twice looks a bit ugly but I don’t have a better suggetion (if we limit it to `ghc-options` we could do better). Probably worth adding a comment that explains why you parse twice.",
        "createdAt" : "2019-09-10T07:17:24Z",
        "updatedAt" : "2019-09-10T14:38:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ccad67cf98292f7fae9420c08748172e68348f0e",
    "line" : null,
    "diffHunk" : "@@ -985,23 +1033,46 @@ options numProcessors =\n         <> cmdClean\n       )\n \n-parserInfo :: Int -> ParserInfo Command\n+parserInfo :: Int -> Opt.ParserInfo Command\n parserInfo numProcessors =\n-  info (helper <*> options numProcessors)\n-    (  fullDesc\n-    <> progDesc \"Invoke the DAML compiler. Use -h for help.\"\n-    <> headerDoc (Just $ PP.vcat\n+  Opt.info (Opt.helper <*> options numProcessors)\n+    (  Opt.fullDesc\n+    <> Opt.progDesc \"Invoke the DAML compiler. Use -h for help.\"\n+    <> Opt.headerDoc (Just $ PP.vcat\n         [ \"damlc - Compiler and IDE backend for the Digital Asset Modelling Language\"\n         , buildInfo\n         ])\n     )\n \n+cliArgsFromDamlYaml :: IO [String]\n+cliArgsFromDamlYaml = do\n+    handle (\\(_ :: ConfigError) -> return [])\n+           $ do\n+               project <- readProjectConfig $ ProjectPath \".\"\n+               case parseProjectConfig project of\n+                   Left _ -> return []\n+                   Right pkgConfig -> case cliOpts pkgConfig of\n+                       Nothing -> return []\n+                       Just xs -> return xs\n+\n main :: IO ()\n main = do\n     -- We need this to ensure that logs are flushed on SIGTERM.\n     installSignalHandlers\n     numProcessors <- getNumProcessors\n-    withProgName \"damlc\" $ join $ execParserLax (parserInfo numProcessors)\n+    let parse = ParseArgs.lax (parserInfo numProcessors)\n+    cliArgs <- Env.getArgs\n+    damlYamlArgs <- cliArgsFromDamlYaml\n+    let (_, tempParseResult) = parse cliArgs\n+    Command(cmd, _) <- Opt.handleParseResult tempParseResult\n+    let args = if cmd `Set.member` Set.fromList [Build, Compile, Ide]\n+               then cliArgs ++ damlYamlArgs\n+               else cliArgs\n+        (errMsgs, parseResult) = parse args\n+    Command(_, io) <- Opt.handleParseResult parseResult"
  },
  {
    "id" : "aa3770a5-6842-483a-bb63-0dae23f13189",
    "prId" : 2689,
    "comments" : [
      {
        "id" : "3efec595-f832-49a0-a66d-54bd19d09871",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we actually still produce DARs that satisfy this assumption?",
        "createdAt" : "2019-08-28T13:25:20Z",
        "updatedAt" : "2019-08-28T13:40:09Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f085de06-1d7f-47c6-8772-5defe938250a",
        "parentId" : "3efec595-f832-49a0-a66d-54bd19d09871",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I have no idea. Presumably @robin-da tested the merge command at some point :slightly_smiling_face: ",
        "createdAt" : "2019-08-28T13:27:41Z",
        "updatedAt" : "2019-08-28T13:40:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "e16d7577a743e12f1ffc9e47b2bc89c57762d6cc",
    "line" : 27,
    "diffHunk" : "@@ -818,15 +819,14 @@ execMergeDars darFp1 darFp2 mbOutFp = do\n                     ]\n         m1 <- getEntry mfPath dar1\n         let m' = do\n-                l <- lines $ BSC.unpack $ BSL.toStrict $ ZipArchive.fromEntry m1\n-                pure $\n-                    maybe\n-                        l\n-                        (const $\n-                         breakAt72Chars $\n-                         \"Dalfs: \" <> intercalate \", \" dalfNames)\n-                        (stripPrefix \"Dalfs:\" l)\n-        pure $ ZipArchive.toEntry mfPath 0 $ BSL.fromStrict $ BSC.pack $ unlines m'\n+                l <- BSC.lines $ ZipArchive.fromEntry m1\n+                -- TODO This should use the proper manifest reader.\n+                -- At the moment this relies on the fact that the input manifest\n+                -- does not have Dalfs: entries that are split over multiple lines."
  },
  {
    "id" : "5ebd3c4d-961d-46bf-9bbd-a24aa23431d0",
    "prId" : 2629,
    "comments" : [
      {
        "id" : "b6197954-7874-4eb8-8c5b-c6388ccc3722",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is that intended?",
        "createdAt" : "2019-08-22T09:39:22Z",
        "updatedAt" : "2019-08-22T12:39:39Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0a5a5919-28cd-47ff-9ef6-1ac1fe8f1fea",
        "parentId" : "b6197954-7874-4eb8-8c5b-c6388ccc3722",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yes, we broke doctests when we switched the lexing mode to make HLint happy. We have tests but we only changed the options in the tests when they broke :man_facepalming: and not in doctest itself. I’ll look into adding an integration test that runs the actual executable on a failing doctest and verifies that it fails so this doesn’t happen again.",
        "createdAt" : "2019-08-22T09:42:02Z",
        "updatedAt" : "2019-08-22T12:39:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e6a63d7d-e062-4d41-b098-53e7b590df7a",
        "parentId" : "b6197954-7874-4eb8-8c5b-c6388ccc3722",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Thanks for the explanation. Adding a test for this sounds good.",
        "createdAt" : "2019-08-22T09:43:30Z",
        "updatedAt" : "2019-08-22T12:39:39Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d8fe0d5-5036-400a-a5b2-98777311d55a",
        "parentId" : "b6197954-7874-4eb8-8c5b-c6388ccc3722",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Tests added",
        "createdAt" : "2019-08-22T10:52:45Z",
        "updatedAt" : "2019-08-22T12:39:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7103266c3942f479ba4739f42007eef9dd83d308",
    "line" : 5,
    "diffHunk" : "@@ -840,7 +840,7 @@ execDocTest opts files = do\n         -- This is horrible but we do not have a way to change the import paths in a running\n         -- IdeState at the moment.\n         pure $ nubOrd $ mapMaybe moduleImportPaths pmS\n-    opts <- mkOptions opts { optImportPath = importPaths <> optImportPath opts}\n+    opts <- mkOptions opts { optImportPath = importPaths <> optImportPath opts, optHaddock = Haddock True }"
  },
  {
    "id" : "818b0014-6ee3-4820-a259-1918812ac2d5",
    "prId" : 2591,
    "comments" : [
      {
        "id" : "387f250a-fe28-4508-bbe6-c89c5180d47d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we share this logic with the DAR reader? At the very least it would be good to add a comment on why we replace `\\n ` as it took me a while to remember that this is for multiline fields.",
        "createdAt" : "2019-08-19T14:20:07Z",
        "updatedAt" : "2019-08-19T16:02:53Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ce821770-56ca-451b-a1aa-3618cc5fc1d4",
        "parentId" : "387f250a-fe28-4508-bbe6-c89c5180d47d",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I moved the function to the dar reader. I think the dar reader itself might need some rewriting.",
        "createdAt" : "2019-08-19T16:03:15Z",
        "updatedAt" : "2019-08-19T16:03:15Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7ed93a606f08bf35c30a11897476bbdabde7e5f4",
    "line" : null,
    "diffHunk" : "@@ -747,6 +757,18 @@ getEntry fp dar =\n     maybe (fail $ \"Package does not contain \" <> fp) pure $\n     findEntryByPath fp dar\n \n+-- | Parse a manifest field.\n+getManifestField :: Entry -> String -> IO String\n+getManifestField manifest field =\n+    mbErr (\"Missing field in META-INF/MANIFEST.MD: \" ++ field) $\n+    headMay\n+        [ value\n+        | l <-\n+              lines $"
  },
  {
    "id" : "7dd05952-7d21-43c0-9ee8-209f88d33b45",
    "prId" : 2498,
    "comments" : [
      {
        "id" : "ebd6958b-63be-44da-97cc-defd9a0049d3",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Looks like leftover from debugging?",
        "createdAt" : "2019-08-12T17:22:14Z",
        "updatedAt" : "2019-08-13T08:04:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9a80af2d-538c-4205-9699-969e99a738bc",
        "parentId" : "ebd6958b-63be-44da-97cc-defd9a0049d3",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It is. Thanks for catching it.",
        "createdAt" : "2019-08-12T17:24:18Z",
        "updatedAt" : "2019-08-13T08:04:58Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a3d27c3c709973e0b77783dfb0b4fe90b9aba1ba",
    "line" : null,
    "diffHunk" : "@@ -79,6 +79,7 @@ import System.FilePath\n import System.IO.Extra\n import System.Process (callProcess)\n import qualified Text.PrettyPrint.ANSI.Leijen      as PP\n+-- import Text.PrettyPrint.Annotated.HughesPJClass (PrettyLevel (..), prettyNormal)"
  },
  {
    "id" : "1b0c9e7c-41b6-4565-a312-b50440e085e0",
    "prId" : 2498,
    "comments" : [
      {
        "id" : "6c46ed41-9e2b-4c0b-baa3-25ca2147ecec",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "left over?",
        "createdAt" : "2019-08-12T17:23:31Z",
        "updatedAt" : "2019-08-13T08:04:58Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a3d27c3c709973e0b77783dfb0b4fe90b9aba1ba",
    "line" : null,
    "diffHunk" : "@@ -79,6 +79,7 @@ import System.FilePath\n import System.IO.Extra\n import System.Process (callProcess)\n import qualified Text.PrettyPrint.ANSI.Leijen      as PP\n+-- import Text.PrettyPrint.Annotated.HughesPJClass (PrettyLevel (..), prettyNormal)"
  },
  {
    "id" : "82a42a1e-d074-4fbd-be16-95223182787d",
    "prId" : 2392,
    "comments" : [
      {
        "id" : "84786759-1f6a-4f4c-a0bf-4cf526ecbd08",
        "parentId" : null,
        "author" : null,
        "body" : "```suggestion\r\n        -- ghc-pkg insists on using a global package db and will try\r\n```\r\n\r\ncan't tell if incredibly clever pun or subtle typo",
        "createdAt" : "2019-08-05T07:59:12Z",
        "updatedAt" : "2019-08-05T08:01:37Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cc20a1ce-6a3c-408d-bd78-b074690eef42",
        "parentId" : "84786759-1f6a-4f4c-a0bf-4cf526ecbd08",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Sadly only a typo :disappointed: ",
        "createdAt" : "2019-08-05T08:01:54Z",
        "updatedAt" : "2019-08-05T08:01:55Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "15db1dbd30750cdf0e839cca069fa15ac9c7bb96",
    "line" : null,
    "diffHunk" : "@@ -437,15 +437,14 @@ createProjectPackageDb lfVersion fps = do\n             write path (fromEntry src)\n     ghcPkgPath <-\n         locateRunfiles (mainWorkspace </> \"compiler\" </> \"damlc\" </> \"ghc-pkg\")\n-    callCommand $\n-        unwords\n-            [ ghcPkgPath </> exe \"ghc-pkg\"\n-            , \"recache\"\n-            -- ghc-pkg insists on using a global package db and will trie\n-            -- to find one automatically if we don’t specify it here.\n-            , \"--global-package-db=\" ++ (dbPath </> \"package.conf.d\")\n-            , \"--expand-pkgroot\"\n-            ]\n+    callProcess\n+        (ghcPkgPath </> exe \"ghc-pkg\")\n+        [ \"recache\"\n+        -- ghc-pkg insists on using a global package db and will trie"
  },
  {
    "id" : "38f30778-b787-4bfc-b36b-2edfd6aea269",
    "prId" : 2232,
    "comments" : [
      {
        "id" : "9a764040-2d14-4670-87b2-45707cc0dab5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Might be a good idea to add a comment that you rely on the fact that `nubSortOn` keeps the first occurence.",
        "createdAt" : "2019-07-19T16:57:00Z",
        "updatedAt" : "2019-07-22T11:38:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5bcd6518-e4c0-4c2a-ba52-d913f3cd8afd",
        "parentId" : "9a764040-2d14-4670-87b2-45707cc0dab5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "done.",
        "createdAt" : "2019-07-22T11:37:27Z",
        "updatedAt" : "2019-07-22T11:38:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ff79e6096473d1f83a02cf14522304894fdc6fcf",
    "line" : 45,
    "diffHunk" : "@@ -792,15 +799,55 @@ execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n         errorOnLeft\n             \"Cannot decode daml-lf archive\"\n             (Archive.decodeArchive dalf)\n-    getEntry fp dar =\n-        maybe (fail $ \"Package does not contain \" <> fp) pure $\n-        findEntryByPath fp dar\n     getModule modName pkg =\n         maybe\n             (fail $ T.unpack $ \"Can't find module\" <> LF.moduleNameString modName)\n             pure $\n         NM.lookup modName $ LF.packageModules pkg\n \n+-- | Get an entry from a dar or fail.\n+getEntry :: FilePath -> Archive -> IO Entry\n+getEntry fp dar =\n+    maybe (fail $ \"Package does not contain \" <> fp) pure $\n+    findEntryByPath fp dar\n+\n+-- | Merge two dars. The idea is that the second dar is a delta. Hence, we take the main in the\n+-- manifest from the first.\n+execMergeDars :: FilePath -> FilePath -> Maybe FilePath -> IO ()\n+execMergeDars darFp1 darFp2 mbOutFp = do\n+    let outFp = fromMaybe darFp1 mbOutFp\n+    bytes1 <- B.readFile darFp1\n+    bytes2 <- B.readFile darFp2\n+    let dar1 = toArchive $ BSL.fromStrict bytes1\n+    let dar2 = toArchive $ BSL.fromStrict bytes2\n+    mf <- mergeManifests dar1 dar2\n+    let merged =\n+            Archive\n+                (nubSortOn eRelativePath $ mf : zEntries dar1 ++ zEntries dar2)"
  },
  {
    "id" : "2355e1d4-c193-4bbc-b547-d03c5fa2bda9",
    "prId" : 2232,
    "comments" : [
      {
        "id" : "559a4152-3b4c-4806-9195-2a8449380689",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a reason why we deduplicate only based on the filename instead of the full relative path? That seems somewhat weird. I guess we never expect dalfs in subdirectories but then we should probably check for that. I would also only deduplicate once and then only filter the deduplicated list here instead of deduplicating once based on the full path and once on the filename.",
        "createdAt" : "2019-07-19T16:58:35Z",
        "updatedAt" : "2019-07-22T11:38:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9cc174da-f970-464e-990a-c61b4ca37aef",
        "parentId" : "559a4152-3b4c-4806-9195-2a8449380689",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "because only the dalf name will end up in the manifest. we will make sure that the dalf names of two packages are always different if they have different content in the next piece of work.",
        "createdAt" : "2019-07-22T11:35:57Z",
        "updatedAt" : "2019-07-22T11:38:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ff79e6096473d1f83a02cf14522304894fdc6fcf",
    "line" : 55,
    "diffHunk" : "@@ -792,15 +799,55 @@ execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n         errorOnLeft\n             \"Cannot decode daml-lf archive\"\n             (Archive.decodeArchive dalf)\n-    getEntry fp dar =\n-        maybe (fail $ \"Package does not contain \" <> fp) pure $\n-        findEntryByPath fp dar\n     getModule modName pkg =\n         maybe\n             (fail $ T.unpack $ \"Can't find module\" <> LF.moduleNameString modName)\n             pure $\n         NM.lookup modName $ LF.packageModules pkg\n \n+-- | Get an entry from a dar or fail.\n+getEntry :: FilePath -> Archive -> IO Entry\n+getEntry fp dar =\n+    maybe (fail $ \"Package does not contain \" <> fp) pure $\n+    findEntryByPath fp dar\n+\n+-- | Merge two dars. The idea is that the second dar is a delta. Hence, we take the main in the\n+-- manifest from the first.\n+execMergeDars :: FilePath -> FilePath -> Maybe FilePath -> IO ()\n+execMergeDars darFp1 darFp2 mbOutFp = do\n+    let outFp = fromMaybe darFp1 mbOutFp\n+    bytes1 <- B.readFile darFp1\n+    bytes2 <- B.readFile darFp2\n+    let dar1 = toArchive $ BSL.fromStrict bytes1\n+    let dar2 = toArchive $ BSL.fromStrict bytes2\n+    mf <- mergeManifests dar1 dar2\n+    let merged =\n+            Archive\n+                (nubSortOn eRelativePath $ mf : zEntries dar1 ++ zEntries dar2)\n+                Nothing\n+                BSL.empty\n+    BSL.writeFile outFp $ fromArchive merged\n+  where\n+    mergeManifests dar1 dar2 = do\n+        let mfPath = \"META-INF/MANIFEST.MF\"\n+        let dalfNames =\n+                nubSort\n+                    [ takeFileName p"
  },
  {
    "id" : "cb1d4dc1-ce16-4949-bc8e-0a10eff10033",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "ed285ef5-a2d7-4413-8ad7-bb3f7a118d72",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That looks more like debugging output.",
        "createdAt" : "2019-07-19T04:45:33Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f56d10ca-b603-4eef-bf03-b82de7a312d5",
        "parentId" : "ed285ef5-a2d7-4413-8ad7-bb3f7a118d72",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "woops",
        "createdAt" : "2019-07-19T09:34:22Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : null,
    "diffHunk" : "@@ -700,44 +700,43 @@ execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n                         ]\n                     pure (src, iuid, depends pkgInfo)\n         let unitIdsTopoSorted = reverse $ topSort depGraph\n-        createDirectoryIfMissing True genDir\n         projectPkgDb <- makeAbsolute projectPackageDatabase\n-        forM_ unitIdsTopoSorted $ \\vertex -> withCurrentDirectory genDir $ do\n+        forM_ unitIdsTopoSorted $ \\vertex -> do\n             let (src, iuid, _) = vertexToNode vertex\n-            unless\n+            let iuidString = installedUnitIdString iuid\n+            let workDir = genDir </> iuidString\n+            createDirectoryIfMissing True workDir\n+            putStrLn $ \"created workdir: \" <> workDir"
  },
  {
    "id" : "a8188ea3-eed3-4d7a-b795-898ca561db2b",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "7d5f4516-a91f-43be-96b6-bd951e624be5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we add a comment here on why we need to change the directory? It isn’t clear to me why that is required.",
        "createdAt" : "2019-07-19T04:45:57Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "10212858-bba2-4e8c-81d9-5ceed5519f5d",
        "parentId" : "7d5f4516-a91f-43be-96b6-bd951e624be5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "so that you get the right filepath's for the generated interface files.",
        "createdAt" : "2019-07-19T09:42:24Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : 14,
    "diffHunk" : "@@ -700,44 +700,43 @@ execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n                         ]\n                     pure (src, iuid, depends pkgInfo)\n         let unitIdsTopoSorted = reverse $ topSort depGraph\n-        createDirectoryIfMissing True genDir\n         projectPkgDb <- makeAbsolute projectPackageDatabase\n-        forM_ unitIdsTopoSorted $ \\vertex -> withCurrentDirectory genDir $ do\n+        forM_ unitIdsTopoSorted $ \\vertex -> do\n             let (src, iuid, _) = vertexToNode vertex\n-            unless\n+            let iuidString = installedUnitIdString iuid\n+            let workDir = genDir </> iuidString\n+            createDirectoryIfMissing True workDir\n+            putStrLn $ \"created workdir: \" <> workDir\n+            withCurrentDirectory workDir $ do"
  },
  {
    "id" : "d800080f-e677-430a-bb55-00868358dc04",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "caa9644c-ac32-4643-b071-1d7b7835c4cf",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You can use `fail` instead of `ioError . userError`",
        "createdAt" : "2019-07-19T04:47:56Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "93d5d8f5-6dd3-420e-9307-b9dd67cf11d4",
        "parentId" : "caa9644c-ac32-4643-b071-1d7b7835c4cf",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "ah nice, there's many places in damlc where we could change this.",
        "createdAt" : "2019-07-19T09:43:59Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : null,
    "diffHunk" : "@@ -700,44 +700,43 @@ execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n                         ]\n                     pure (src, iuid, depends pkgInfo)\n         let unitIdsTopoSorted = reverse $ topSort depGraph\n-        createDirectoryIfMissing True genDir\n         projectPkgDb <- makeAbsolute projectPackageDatabase\n-        forM_ unitIdsTopoSorted $ \\vertex -> withCurrentDirectory genDir $ do\n+        forM_ unitIdsTopoSorted $ \\vertex -> do\n             let (src, iuid, _) = vertexToNode vertex\n-            unless\n+            let iuidString = installedUnitIdString iuid\n+            let workDir = genDir </> iuidString\n+            createDirectoryIfMissing True workDir\n+            putStrLn $ \"created workdir: \" <> workDir\n+            withCurrentDirectory workDir $ do\n+                unless\n                 -- TODO (drsk) remove this filter\n-                (iuid `elem`\n-                 map stringToInstalledUnitId [\"daml-prim\", \"daml-stdlib\"]) $ do\n+                    (iuid `elem` map stringToInstalledUnitId [\"daml-prim\"]) $\n                   -- typecheck and generate interface files\n-                  forM_ src $ \\(fp, content) -> do\n-                      let path = fromNormalizedFilePath fp\n-                      createDirectoryIfMissing True $ takeDirectory path\n-                      writeFile path content\n-                  opts' <-\n-                      mkOptions $\n-                      opts\n-                          { optWriteInterface = True\n-                          , optPackageDbs = [projectPkgDb]\n-                          , optIfaceDir =\n-                                Just\n-                                    (dbPath </> installedUnitIdString iuid)\n-                          , optIsGenerated = True\n-                          , optMbPackageName =\n-                                Just $ installedUnitIdString iuid\n-                          }\n-                  withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n-                      forM_ src $ \\(fp, _content) -> do\n-                          mbCore <-\n-                              runAction ide $\n-                              getGhcCore fp\n-                          case mbCore of\n-                              Nothing ->\n-                                  ioError $\n-                                  userError $\n-                                  \"Compilation of generated source for \" <>\n-                                  installedUnitIdString iuid <>\n-                                  \" failed.\"\n-                              Just _core -> pure ()\n+                 do\n+                    forM_ src $ \\(fp, content) -> do\n+                        let path = fromNormalizedFilePath fp\n+                        createDirectoryIfMissing True $ takeDirectory path\n+                        writeFile path content\n+                    opts' <-\n+                        mkOptions $\n+                        opts\n+                            { optWriteInterface = True\n+                            , optPackageDbs = [projectPkgDb]\n+                            , optIfaceDir = Just (dbPath </> installedUnitIdString iuid)\n+                            , optIsGenerated = True\n+                            , optMbPackageName = Just $ installedUnitIdString iuid\n+                            }\n+                    withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+                        forM_ src $ \\(fp, _content) -> do\n+                            mbCore <- runAction ide $ getGhcCore fp\n+                            case mbCore of\n+                                Nothing ->\n+                                    ioError $"
  },
  {
    "id" : "8d05c84a-879e-459b-867c-6e2bc70144fa",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "211eaa5e-af39-42ea-a6c5-dc8750a5c5ec",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`when (isNothing mbCore) …` might be more readable.",
        "createdAt" : "2019-07-19T04:48:29Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : null,
    "diffHunk" : "@@ -700,44 +700,43 @@ execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n                         ]\n                     pure (src, iuid, depends pkgInfo)\n         let unitIdsTopoSorted = reverse $ topSort depGraph\n-        createDirectoryIfMissing True genDir\n         projectPkgDb <- makeAbsolute projectPackageDatabase\n-        forM_ unitIdsTopoSorted $ \\vertex -> withCurrentDirectory genDir $ do\n+        forM_ unitIdsTopoSorted $ \\vertex -> do\n             let (src, iuid, _) = vertexToNode vertex\n-            unless\n+            let iuidString = installedUnitIdString iuid\n+            let workDir = genDir </> iuidString\n+            createDirectoryIfMissing True workDir\n+            putStrLn $ \"created workdir: \" <> workDir\n+            withCurrentDirectory workDir $ do\n+                unless\n                 -- TODO (drsk) remove this filter\n-                (iuid `elem`\n-                 map stringToInstalledUnitId [\"daml-prim\", \"daml-stdlib\"]) $ do\n+                    (iuid `elem` map stringToInstalledUnitId [\"daml-prim\"]) $\n                   -- typecheck and generate interface files\n-                  forM_ src $ \\(fp, content) -> do\n-                      let path = fromNormalizedFilePath fp\n-                      createDirectoryIfMissing True $ takeDirectory path\n-                      writeFile path content\n-                  opts' <-\n-                      mkOptions $\n-                      opts\n-                          { optWriteInterface = True\n-                          , optPackageDbs = [projectPkgDb]\n-                          , optIfaceDir =\n-                                Just\n-                                    (dbPath </> installedUnitIdString iuid)\n-                          , optIsGenerated = True\n-                          , optMbPackageName =\n-                                Just $ installedUnitIdString iuid\n-                          }\n-                  withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n-                      forM_ src $ \\(fp, _content) -> do\n-                          mbCore <-\n-                              runAction ide $\n-                              getGhcCore fp\n-                          case mbCore of\n-                              Nothing ->\n-                                  ioError $\n-                                  userError $\n-                                  \"Compilation of generated source for \" <>\n-                                  installedUnitIdString iuid <>\n-                                  \" failed.\"\n-                              Just _core -> pure ()\n+                 do\n+                    forM_ src $ \\(fp, content) -> do\n+                        let path = fromNormalizedFilePath fp\n+                        createDirectoryIfMissing True $ takeDirectory path\n+                        writeFile path content\n+                    opts' <-\n+                        mkOptions $\n+                        opts\n+                            { optWriteInterface = True\n+                            , optPackageDbs = [projectPkgDb]\n+                            , optIfaceDir = Just (dbPath </> installedUnitIdString iuid)\n+                            , optIsGenerated = True\n+                            , optMbPackageName = Just $ installedUnitIdString iuid\n+                            }\n+                    withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+                        forM_ src $ \\(fp, _content) -> do\n+                            mbCore <- runAction ide $ getGhcCore fp\n+                            case mbCore of"
  },
  {
    "id" : "0ada7539-d060-4082-a09d-aa9ff447ff4c",
    "prId" : 2177,
    "comments" : [
      {
        "id" : "1d9c9aef-c4e9-4256-ac3e-8bdfb24c9f52",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This might be easier to read if you shadow `opts` (you’ll have to use `opts <- pure …` here) instead of having both `opts`, `opts'', and `opts''` in scope at the same time.",
        "createdAt" : "2019-07-16T17:35:49Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3855144a-e426-45d8-844c-12d2f7ddea6b",
        "parentId" : "1d9c9aef-c4e9-4256-ac3e-8bdfb24c9f52",
        "author" : null,
        "body" : "Right you are. I'll give it another pass.",
        "createdAt" : "2019-07-16T18:39:32Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb9ad143-8e39-437d-86b4-088588147969",
        "parentId" : "1d9c9aef-c4e9-4256-ac3e-8bdfb24c9f52",
        "author" : null,
        "body" : "✔️ ... pushing this now. @cocreature , may I prevail upon you to have another look?",
        "createdAt" : "2019-07-16T19:13:14Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bc4d6df5136944c7a6a061f4397ddeeda1b10e75",
    "line" : null,
    "diffHunk" : "@@ -317,6 +327,24 @@ execCompile inputFile outputFile opts = withProjectRoot' (ProjectOpts Nothing (P\n         createDirectoryIfMissing True $ takeDirectory outputFile\n         B.writeFile outputFile $ Archive.encodeArchive bs\n \n+execLint :: FilePath -> Options -> Command\n+execLint inputFile opts =\n+  withProjectRoot' (ProjectOpts Nothing (ProjectCheck \"\" False)) $ \\relativize ->\n+  do\n+    loggerH <- getLogger opts \"lint\"\n+    inputFile <- toNormalizedFilePath <$> relativize inputFile\n+    opts' <- mkOptions opts\n+    defaultHlintDataDir <-locateRunfiles $ mainWorkspace </> \"compiler/damlc/daml-ide-core\"\n+    -- If not `--with-hlint path` given on the command line, assume\n+    -- the testing default.\n+    let opts'' ="
  },
  {
    "id" : "20e09b67-00bd-4c3f-b5b5-5b4e0d7f7106",
    "prId" : 2177,
    "comments" : [
      {
        "id" : "dcf0cef2-e05e-414b-9594-20674c10cbc0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We should exit with `exitFailure` if we get diagnostics. An easy solution is probably something like:\r\n```\r\ndiags <- getDiagnostics ide\r\nunless (null diags) exitFailure\r\n```",
        "createdAt" : "2019-07-16T17:37:29Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e36d7c20-7ceb-4e4c-8f84-544b649ad231",
        "parentId" : "dcf0cef2-e05e-414b-9594-20674c10cbc0",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-07-16T18:35:28Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "bc4d6df5136944c7a6a061f4397ddeeda1b10e75",
    "line" : 39,
    "diffHunk" : "@@ -317,6 +327,24 @@ execCompile inputFile outputFile opts = withProjectRoot' (ProjectOpts Nothing (P\n         createDirectoryIfMissing True $ takeDirectory outputFile\n         B.writeFile outputFile $ Archive.encodeArchive bs\n \n+execLint :: FilePath -> Options -> Command\n+execLint inputFile opts =\n+  withProjectRoot' (ProjectOpts Nothing (ProjectCheck \"\" False)) $ \\relativize ->\n+  do\n+    loggerH <- getLogger opts \"lint\"\n+    inputFile <- toNormalizedFilePath <$> relativize inputFile\n+    opts' <- mkOptions opts\n+    defaultHlintDataDir <-locateRunfiles $ mainWorkspace </> \"compiler/damlc/daml-ide-core\"\n+    -- If not `--with-hlint path` given on the command line, assume\n+    -- the testing default.\n+    let opts'' =\n+          case optHlintUsage opts' of\n+            HlintEnabled _ -> opts'\n+            HlintDisabled -> opts'{optHlintUsage=HlintEnabled defaultHlintDataDir}\n+    withDamlIdeState opts'' loggerH diagnosticsLogger $ \\ide -> do\n+        setFilesOfInterest ide (Set.singleton inputFile)\n+        runAction ide $ getHlintIdeas inputFile"
  },
  {
    "id" : "f4220430-51ed-4f50-af98-dbcd00b2391e",
    "prId" : 2177,
    "comments" : [
      {
        "id" : "f8f82632-c5a7-4f6a-a1d9-27a05c923e5f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we hide this? It seems like a useful command that someone might want to add to their CI setup or something like that.",
        "createdAt" : "2019-07-16T17:38:11Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "42e05edd-30e7-46bc-b825-eaa39ec25c2c",
        "parentId" : "f8f82632-c5a7-4f6a-a1d9-27a05c923e5f",
        "author" : null,
        "body" : "What do you mean by hidden? You mean because it's in the `internal` sub-parser? I just blindly copied `cmdCompile`... I should lift it to the same level as `cmdBuild` do you think?",
        "createdAt" : "2019-07-16T18:36:58Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e1df00aa-00a1-4cb8-9d5c-6042d160a5c6",
        "parentId" : "f8f82632-c5a7-4f6a-a1d9-27a05c923e5f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`cmdCompile` is hidden because users are supposed to use `cmdBuild`. Given that there is no alternative to `cmdLint` I would put it on the same level as `cmdBuild`.",
        "createdAt" : "2019-07-16T18:40:58Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "036e7cd3-d754-4c76-9e4d-cd01dfec41a8",
        "parentId" : "f8f82632-c5a7-4f6a-a1d9-27a05c923e5f",
        "author" : null,
        "body" : "Roger roger.",
        "createdAt" : "2019-07-16T18:44:58Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5125de55-b041-4bcb-9e71-249c46b5c722",
        "parentId" : "f8f82632-c5a7-4f6a-a1d9-27a05c923e5f",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-07-16T18:45:29Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bc4d6df5136944c7a6a061f4397ddeeda1b10e75",
    "line" : null,
    "diffHunk" : "@@ -917,6 +945,7 @@ options numProcessors =\n         <> cmdMigrate numProcessors\n         <> cmdInit\n         <> cmdCompile numProcessors\n+        <> cmdLint numProcessors"
  },
  {
    "id" : "73959556-c906-414b-9726-82572e0f1a59",
    "prId" : 2177,
    "comments" : [
      {
        "id" : "4cb858d0-c8ae-456f-8c09-9f1b713d505a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if we’re handling this the right way. We probably want somewhat similar logic for all commands (in particular for the IDE) but then users cannot actually disable HLint fully. Of course for an explicit `lint` command that doesn’t make sense anyway but for the IDE it does. Maybe we want to differentiate between explicitly disabled and not specified? Just a thought, no need to do anything about this as part of this PR.",
        "createdAt" : "2019-07-16T17:40:18Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fe10d295-3b2f-479e-9246-4be1d7f115cd",
        "parentId" : "4cb858d0-c8ae-456f-8c09-9f1b713d505a",
        "author" : null,
        "body" : "Ok.",
        "createdAt" : "2019-07-16T18:39:01Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bc4d6df5136944c7a6a061f4397ddeeda1b10e75",
    "line" : null,
    "diffHunk" : "@@ -317,6 +327,24 @@ execCompile inputFile outputFile opts = withProjectRoot' (ProjectOpts Nothing (P\n         createDirectoryIfMissing True $ takeDirectory outputFile\n         B.writeFile outputFile $ Archive.encodeArchive bs\n \n+execLint :: FilePath -> Options -> Command\n+execLint inputFile opts =\n+  withProjectRoot' (ProjectOpts Nothing (ProjectCheck \"\" False)) $ \\relativize ->\n+  do\n+    loggerH <- getLogger opts \"lint\"\n+    inputFile <- toNormalizedFilePath <$> relativize inputFile\n+    opts' <- mkOptions opts\n+    defaultHlintDataDir <-locateRunfiles $ mainWorkspace </> \"compiler/damlc/daml-ide-core\"\n+    -- If not `--with-hlint path` given on the command line, assume\n+    -- the testing default.\n+    let opts'' =\n+          case optHlintUsage opts' of"
  },
  {
    "id" : "cdbfa7b6-3c3a-45ac-8167-7549a613d8db",
    "prId" : 2177,
    "comments" : [
      {
        "id" : "710bb108-8fc3-4e36-89e7-54d47605d16a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    opts <- setHlintDataDir =<< mkOptions opts\r\n```\r\nmight be a bit more idiomatic but I don’t feel strongly about this at all so your choice :wink: ",
        "createdAt" : "2019-07-16T19:16:35Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c7b82446-1e85-44b1-bb88-be907bd242e1",
        "parentId" : "710bb108-8fc3-4e36-89e7-54d47605d16a",
        "author" : null,
        "body" : "Noted. Thanks!",
        "createdAt" : "2019-07-16T19:18:42Z",
        "updatedAt" : "2019-07-16T19:34:17Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "bc4d6df5136944c7a6a061f4397ddeeda1b10e75",
    "line" : 36,
    "diffHunk" : "@@ -317,6 +327,27 @@ execCompile inputFile outputFile opts = withProjectRoot' (ProjectOpts Nothing (P\n         createDirectoryIfMissing True $ takeDirectory outputFile\n         B.writeFile outputFile $ Archive.encodeArchive bs\n \n+execLint :: FilePath -> Options -> Command\n+execLint inputFile opts =\n+  withProjectRoot' (ProjectOpts Nothing (ProjectCheck \"\" False)) $ \\relativize ->\n+  do\n+    loggerH <- getLogger opts \"lint\"\n+    inputFile <- toNormalizedFilePath <$> relativize inputFile\n+    opts <- (setHlintDataDir <=< mkOptions) opts"
  },
  {
    "id" : "da2350e6-7e87-4e00-8989-f522c033136b",
    "prId" : 2177,
    "comments" : [
      {
        "id" : "3b1643a0-feac-4766-9c59-04d0958e51f4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Instead of\r\n```haskell\r\nwhen x a\r\nunless x b\r\n```\r\nI'd just write\r\n```haskell\r\nif x then a else b\r\n```",
        "createdAt" : "2019-07-17T08:41:37Z",
        "updatedAt" : "2019-07-17T08:42:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bc4d6df5136944c7a6a061f4397ddeeda1b10e75",
    "line" : 42,
    "diffHunk" : "@@ -317,6 +327,28 @@ execCompile inputFile outputFile opts = withProjectRoot' (ProjectOpts Nothing (P\n         createDirectoryIfMissing True $ takeDirectory outputFile\n         B.writeFile outputFile $ Archive.encodeArchive bs\n \n+execLint :: FilePath -> Options -> Command\n+execLint inputFile opts =\n+  withProjectRoot' (ProjectOpts Nothing (ProjectCheck \"\" False)) $ \\relativize ->\n+  do\n+    loggerH <- getLogger opts \"lint\"\n+    inputFile <- toNormalizedFilePath <$> relativize inputFile\n+    opts <- (setHlintDataDir <=< mkOptions) opts\n+    withDamlIdeState opts loggerH diagnosticsLogger $ \\ide -> do\n+        setFilesOfInterest ide (Set.singleton inputFile)\n+        runAction ide $ getHlintIdeas inputFile\n+        diags <- getDiagnostics ide\n+        when (null diags) $ hPutStrLn stderr \"No hints.\"\n+        unless (null diags) exitFailure"
  },
  {
    "id" : "81467893-dc46-405c-9f28-c24b58c0f94f",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "db248adb-5639-494a-ae76-45815f66f4c8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        -- order the packages in topological order\r\n```",
        "createdAt" : "2019-07-15T16:40:12Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : null,
    "diffHunk" : "@@ -603,68 +610,156 @@ execInspectDar inFile = do\n             show (LF.unPackageId pkgId)\n \n execMigrate ::\n-       Options -> FilePath -> FilePath -> Maybe FilePath -> Command\n-execMigrate opts inFile1 inFile2 mbDir = do\n+       ProjectOpts\n+    -> Options\n+    -> FilePath\n+    -> FilePath\n+    -> Maybe FilePath\n+    -> Command\n+execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n+    opts <- mkOptions opts0\n+    inFile1 <- makeAbsolute inFile1_\n+    inFile2 <- makeAbsolute inFile2_\n     loggerH <- getLogger opts \"migrate\"\n-    [(pkgName1, pkgId1, lfPkg1, pkgMap1), (pkgName2, pkgId2, lfPkg2, pkgMap2)] <-\n-        forM [inFile1, inFile2] $ \\inFile -> do\n-            let pkg = takeBaseName inFile\n-            bytes <- B.readFile inFile\n-            let dar = toArchive $ BSL.fromStrict bytes\n-            manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n-            mainDalfPath <-\n-                maybe (ioError $ userError \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\") pure $\n-                headMay\n-                    [ main\n-                    | l <-\n-                          lines $ BSC.unpack $ BSL.toStrict $ fromEntry manifest\n-                    , Just main <- [stripPrefix \"Main-Dalf: \" l]\n-                    ]\n-            mainDalf <- BSL.toStrict . fromEntry <$> getEntry mainDalfPath dar\n-            (pkgId, lfPkg) <-\n-                errorOnLeft\n-                    (\"Cannot decode package \" <> mainDalfPath)\n-                    (Archive.decodeArchive mainDalf)\n-            pkgMap <- generatePkgMap loggerH dar\n-            pure (pkg, pkgId, lfPkg, pkgMap)\n-    let eqModNames =\n-            (NM.names $ LF.packageModules lfPkg1) `intersect`\n-            (NM.names $ LF.packageModules lfPkg2)\n-    forM_ eqModNames $ \\m@(LF.ModuleName modName) -> do\n-        [genSrc1, genSrc2] <-\n-            forM [(pkgId1, lfPkg1, pkgMap1), (pkgId2, lfPkg2, pkgMap2)] $ \\(pkgId, pkg, pkgMap) -> do\n-                generateSrcFromLf pkgId pkgMap <$> getModule m pkg\n-        let upgradeModPath =\n-                (joinPath $ fromMaybe \"\" mbDir : map T.unpack modName) <>\n-                \".daml\"\n-        let instancesModPath1 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesA\"\n-        let instancesModPath2 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesB\"\n-        templateNames <-\n-            map (T.unpack . T.intercalate \".\" . LF.unTypeConName) .\n-            NM.names . LF.moduleTemplates <$>\n-            getModule m lfPkg1\n-        let generatedUpgradeMod =\n-                generateUpgradeModule\n-                    templateNames\n-                    (T.unpack $ LF.moduleNameString m)\n-                    pkgName1\n-                    pkgName2\n-        let generatedInstancesMod1 =\n-                generateGenInstancesModule \"A\" (pkgName1, genSrc1)\n-        let generatedInstancesMod2 =\n-                generateGenInstancesModule \"B\" (pkgName2, genSrc2)\n-        forM_\n-            [ (upgradeModPath, generatedUpgradeMod)\n-            , (instancesModPath1, generatedInstancesMod1)\n-            , (instancesModPath2, generatedInstancesMod2)\n-            ] $ \\(path, mod) -> do\n-            createDirectoryIfMissing True $ takeDirectory path\n-            writeFile path mod\n+    -- initialise the package database\n+    execInit (optDamlLfVersion opts) projectOpts (InitPkgDb True)\n+    withProjectRoot' projectOpts $ \\_relativize\n+     -> do\n+        -- for all contained dalfs, generate source, typecheck and generate interface files and\n+        -- overwrite the existing ones.\n+        dbPath <- makeAbsolute $\n+                projectPackageDatabase </>\n+                lfVersionString (optDamlLfVersion opts)\n+        (diags, pkgMap) <- generatePackageMap [dbPath]\n+        unless (null diags) $ Logger.logWarning loggerH $ showDiagnostics diags\n+        let pkgMap0 = MS.map dalfPackageId pkgMap\n+        let genSrcs =\n+                [ ( unitId\n+                  , generateSrcPkgFromLf (dalfPackageId dalfPkg) pkgMap0 dalf)\n+                | (unitId, dalfPkg) <- MS.toList pkgMap\n+                , LF.ExternalPackage _ dalf <- [dalfPackagePkg dalfPkg]\n+                ]\n+      -- order the packages in topological order"
  },
  {
    "id" : "aac2262b-096f-4cf4-8cfd-88c74d4e767b",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "053b1b04-ecde-4ee0-b287-a976eea0023d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I tend to put this at the end of the previous line.",
        "createdAt" : "2019-07-15T16:40:58Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : 200,
    "diffHunk" : "@@ -603,68 +610,156 @@ execInspectDar inFile = do\n             show (LF.unPackageId pkgId)\n \n execMigrate ::\n-       Options -> FilePath -> FilePath -> Maybe FilePath -> Command\n-execMigrate opts inFile1 inFile2 mbDir = do\n+       ProjectOpts\n+    -> Options\n+    -> FilePath\n+    -> FilePath\n+    -> Maybe FilePath\n+    -> Command\n+execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n+    opts <- mkOptions opts0\n+    inFile1 <- makeAbsolute inFile1_\n+    inFile2 <- makeAbsolute inFile2_\n     loggerH <- getLogger opts \"migrate\"\n-    [(pkgName1, pkgId1, lfPkg1, pkgMap1), (pkgName2, pkgId2, lfPkg2, pkgMap2)] <-\n-        forM [inFile1, inFile2] $ \\inFile -> do\n-            let pkg = takeBaseName inFile\n-            bytes <- B.readFile inFile\n-            let dar = toArchive $ BSL.fromStrict bytes\n-            manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n-            mainDalfPath <-\n-                maybe (ioError $ userError \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\") pure $\n-                headMay\n-                    [ main\n-                    | l <-\n-                          lines $ BSC.unpack $ BSL.toStrict $ fromEntry manifest\n-                    , Just main <- [stripPrefix \"Main-Dalf: \" l]\n-                    ]\n-            mainDalf <- BSL.toStrict . fromEntry <$> getEntry mainDalfPath dar\n-            (pkgId, lfPkg) <-\n-                errorOnLeft\n-                    (\"Cannot decode package \" <> mainDalfPath)\n-                    (Archive.decodeArchive mainDalf)\n-            pkgMap <- generatePkgMap loggerH dar\n-            pure (pkg, pkgId, lfPkg, pkgMap)\n-    let eqModNames =\n-            (NM.names $ LF.packageModules lfPkg1) `intersect`\n-            (NM.names $ LF.packageModules lfPkg2)\n-    forM_ eqModNames $ \\m@(LF.ModuleName modName) -> do\n-        [genSrc1, genSrc2] <-\n-            forM [(pkgId1, lfPkg1, pkgMap1), (pkgId2, lfPkg2, pkgMap2)] $ \\(pkgId, pkg, pkgMap) -> do\n-                generateSrcFromLf pkgId pkgMap <$> getModule m pkg\n-        let upgradeModPath =\n-                (joinPath $ fromMaybe \"\" mbDir : map T.unpack modName) <>\n-                \".daml\"\n-        let instancesModPath1 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesA\"\n-        let instancesModPath2 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesB\"\n-        templateNames <-\n-            map (T.unpack . T.intercalate \".\" . LF.unTypeConName) .\n-            NM.names . LF.moduleTemplates <$>\n-            getModule m lfPkg1\n-        let generatedUpgradeMod =\n-                generateUpgradeModule\n-                    templateNames\n-                    (T.unpack $ LF.moduleNameString m)\n-                    pkgName1\n-                    pkgName2\n-        let generatedInstancesMod1 =\n-                generateGenInstancesModule \"A\" (pkgName1, genSrc1)\n-        let generatedInstancesMod2 =\n-                generateGenInstancesModule \"B\" (pkgName2, genSrc2)\n-        forM_\n-            [ (upgradeModPath, generatedUpgradeMod)\n-            , (instancesModPath1, generatedInstancesMod1)\n-            , (instancesModPath2, generatedInstancesMod2)\n-            ] $ \\(path, mod) -> do\n-            createDirectoryIfMissing True $ takeDirectory path\n-            writeFile path mod\n+    -- initialise the package database\n+    execInit (optDamlLfVersion opts) projectOpts (InitPkgDb True)\n+    withProjectRoot' projectOpts $ \\_relativize\n+     -> do"
  },
  {
    "id" : "74c2edc9-1edc-473c-8247-bcb6e3971f89",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "a118dbf2-b8d6-4d86-bfba-aa8674aa5f01",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        -- generate upgrade modules and instances modules\r\n```",
        "createdAt" : "2019-07-15T16:41:29Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : null,
    "diffHunk" : "@@ -603,68 +610,156 @@ execInspectDar inFile = do\n             show (LF.unPackageId pkgId)\n \n execMigrate ::\n-       Options -> FilePath -> FilePath -> Maybe FilePath -> Command\n-execMigrate opts inFile1 inFile2 mbDir = do\n+       ProjectOpts\n+    -> Options\n+    -> FilePath\n+    -> FilePath\n+    -> Maybe FilePath\n+    -> Command\n+execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n+    opts <- mkOptions opts0\n+    inFile1 <- makeAbsolute inFile1_\n+    inFile2 <- makeAbsolute inFile2_\n     loggerH <- getLogger opts \"migrate\"\n-    [(pkgName1, pkgId1, lfPkg1, pkgMap1), (pkgName2, pkgId2, lfPkg2, pkgMap2)] <-\n-        forM [inFile1, inFile2] $ \\inFile -> do\n-            let pkg = takeBaseName inFile\n-            bytes <- B.readFile inFile\n-            let dar = toArchive $ BSL.fromStrict bytes\n-            manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n-            mainDalfPath <-\n-                maybe (ioError $ userError \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\") pure $\n-                headMay\n-                    [ main\n-                    | l <-\n-                          lines $ BSC.unpack $ BSL.toStrict $ fromEntry manifest\n-                    , Just main <- [stripPrefix \"Main-Dalf: \" l]\n-                    ]\n-            mainDalf <- BSL.toStrict . fromEntry <$> getEntry mainDalfPath dar\n-            (pkgId, lfPkg) <-\n-                errorOnLeft\n-                    (\"Cannot decode package \" <> mainDalfPath)\n-                    (Archive.decodeArchive mainDalf)\n-            pkgMap <- generatePkgMap loggerH dar\n-            pure (pkg, pkgId, lfPkg, pkgMap)\n-    let eqModNames =\n-            (NM.names $ LF.packageModules lfPkg1) `intersect`\n-            (NM.names $ LF.packageModules lfPkg2)\n-    forM_ eqModNames $ \\m@(LF.ModuleName modName) -> do\n-        [genSrc1, genSrc2] <-\n-            forM [(pkgId1, lfPkg1, pkgMap1), (pkgId2, lfPkg2, pkgMap2)] $ \\(pkgId, pkg, pkgMap) -> do\n-                generateSrcFromLf pkgId pkgMap <$> getModule m pkg\n-        let upgradeModPath =\n-                (joinPath $ fromMaybe \"\" mbDir : map T.unpack modName) <>\n-                \".daml\"\n-        let instancesModPath1 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesA\"\n-        let instancesModPath2 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesB\"\n-        templateNames <-\n-            map (T.unpack . T.intercalate \".\" . LF.unTypeConName) .\n-            NM.names . LF.moduleTemplates <$>\n-            getModule m lfPkg1\n-        let generatedUpgradeMod =\n-                generateUpgradeModule\n-                    templateNames\n-                    (T.unpack $ LF.moduleNameString m)\n-                    pkgName1\n-                    pkgName2\n-        let generatedInstancesMod1 =\n-                generateGenInstancesModule \"A\" (pkgName1, genSrc1)\n-        let generatedInstancesMod2 =\n-                generateGenInstancesModule \"B\" (pkgName2, genSrc2)\n-        forM_\n-            [ (upgradeModPath, generatedUpgradeMod)\n-            , (instancesModPath1, generatedInstancesMod1)\n-            , (instancesModPath2, generatedInstancesMod2)\n-            ] $ \\(path, mod) -> do\n-            createDirectoryIfMissing True $ takeDirectory path\n-            writeFile path mod\n+    -- initialise the package database\n+    execInit (optDamlLfVersion opts) projectOpts (InitPkgDb True)\n+    withProjectRoot' projectOpts $ \\_relativize\n+     -> do\n+        -- for all contained dalfs, generate source, typecheck and generate interface files and\n+        -- overwrite the existing ones.\n+        dbPath <- makeAbsolute $\n+                projectPackageDatabase </>\n+                lfVersionString (optDamlLfVersion opts)\n+        (diags, pkgMap) <- generatePackageMap [dbPath]\n+        unless (null diags) $ Logger.logWarning loggerH $ showDiagnostics diags\n+        let pkgMap0 = MS.map dalfPackageId pkgMap\n+        let genSrcs =\n+                [ ( unitId\n+                  , generateSrcPkgFromLf (dalfPackageId dalfPkg) pkgMap0 dalf)\n+                | (unitId, dalfPkg) <- MS.toList pkgMap\n+                , LF.ExternalPackage _ dalf <- [dalfPackagePkg dalfPkg]\n+                ]\n+      -- order the packages in topological order\n+        packageState <-\n+            generatePackageState (dbPath : optPackageDbs opts) False []\n+        let (depGraph, vertexToNode, _keyToVertex) =\n+                graphFromEdges $ do\n+                    (uid, src) <- genSrcs\n+                    let iuid = toInstalledUnitId uid\n+                    Just pkgInfo <-\n+                        [ lookupInstalledPackage\n+                              (fakeDynFlags\n+                                   {pkgState = pdfPkgState packageState})\n+                              iuid\n+                        ]\n+                    pure (src, iuid, depends pkgInfo)\n+        let unitIdsTopoSorted = reverse $ topSort depGraph\n+        createDirectoryIfMissing True genDir\n+        projectPkgDb <- makeAbsolute projectPackageDatabase\n+        forM_ unitIdsTopoSorted $ \\vertex -> withCurrentDirectory genDir $ do\n+            let (src, iuid, _) = vertexToNode vertex\n+            unless\n+                -- TODO (drsk) remove this filter\n+                (iuid `elem`\n+                 map stringToInstalledUnitId [\"daml-prim\", \"daml-stdlib\"]) $ do\n+                  -- typecheck and generate interface files\n+                  forM_ src $ \\(fp, content) -> do\n+                      let path = fromNormalizedFilePath fp\n+                      createDirectoryIfMissing True $ takeDirectory path\n+                      writeFile path content\n+                  opts' <-\n+                      mkOptions $\n+                      opts\n+                          { optWriteInterface = True\n+                          , optPackageDbs = [projectPkgDb]\n+                          , optIfaceDir =\n+                                Just\n+                                    (dbPath </> installedUnitIdString iuid)\n+                          , optIsGenerated = True\n+                          , optMbPackageName =\n+                                Just $ installedUnitIdString iuid\n+                          }\n+                  withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+                      forM_ src $ \\(fp, _content) -> do\n+                          mbCore <-\n+                              runAction ide $\n+                              getGhcCore fp\n+                          case mbCore of\n+                              Nothing ->\n+                                  ioError $\n+                                  userError $\n+                                  \"Compilation of generated source for \" <>\n+                                  installedUnitIdString iuid <>\n+                                  \" failed.\"\n+                              Just _core -> pure ()\n+        -- get the package name and the lf-package\n+        [(pkgName1, pkgId1, lfPkg1), (pkgName2, pkgId2, lfPkg2)] <-\n+            forM [inFile1, inFile2] $ \\inFile -> do\n+                bytes <- B.readFile inFile\n+                let pkgName = takeBaseName inFile\n+                let dar = toArchive $ BSL.fromStrict bytes\n+              -- get the main pkg\n+                manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n+                mainDalfPath <-\n+                    maybe\n+                        (ioError $\n+                         userError\n+                             \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\")\n+                        pure $\n+                    headMay\n+                        [ main\n+                        | l <-\n+                              lines $\n+                              BSC.unpack $ BSL.toStrict $ fromEntry manifest\n+                        , Just main <- [stripPrefix \"Main-Dalf: \" l]\n+                        ]\n+                mainDalfEntry <- getEntry mainDalfPath dar\n+                (mainPkgId, mainLfPkg) <-\n+                    decode $ BSL.toStrict $ fromEntry mainDalfEntry\n+                pure (pkgName, mainPkgId, mainLfPkg)\n+      -- generate upgrade modules and instances modules"
  },
  {
    "id" : "121e2fbc-cea6-4f63-8d54-df5205bb290c",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "5a2bc544-2dc7-4a06-9ac1-f828b98ee88c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                -- get the main pkg\r\n```",
        "createdAt" : "2019-07-15T16:45:24Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : null,
    "diffHunk" : "@@ -603,68 +610,156 @@ execInspectDar inFile = do\n             show (LF.unPackageId pkgId)\n \n execMigrate ::\n-       Options -> FilePath -> FilePath -> Maybe FilePath -> Command\n-execMigrate opts inFile1 inFile2 mbDir = do\n+       ProjectOpts\n+    -> Options\n+    -> FilePath\n+    -> FilePath\n+    -> Maybe FilePath\n+    -> Command\n+execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n+    opts <- mkOptions opts0\n+    inFile1 <- makeAbsolute inFile1_\n+    inFile2 <- makeAbsolute inFile2_\n     loggerH <- getLogger opts \"migrate\"\n-    [(pkgName1, pkgId1, lfPkg1, pkgMap1), (pkgName2, pkgId2, lfPkg2, pkgMap2)] <-\n-        forM [inFile1, inFile2] $ \\inFile -> do\n-            let pkg = takeBaseName inFile\n-            bytes <- B.readFile inFile\n-            let dar = toArchive $ BSL.fromStrict bytes\n-            manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n-            mainDalfPath <-\n-                maybe (ioError $ userError \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\") pure $\n-                headMay\n-                    [ main\n-                    | l <-\n-                          lines $ BSC.unpack $ BSL.toStrict $ fromEntry manifest\n-                    , Just main <- [stripPrefix \"Main-Dalf: \" l]\n-                    ]\n-            mainDalf <- BSL.toStrict . fromEntry <$> getEntry mainDalfPath dar\n-            (pkgId, lfPkg) <-\n-                errorOnLeft\n-                    (\"Cannot decode package \" <> mainDalfPath)\n-                    (Archive.decodeArchive mainDalf)\n-            pkgMap <- generatePkgMap loggerH dar\n-            pure (pkg, pkgId, lfPkg, pkgMap)\n-    let eqModNames =\n-            (NM.names $ LF.packageModules lfPkg1) `intersect`\n-            (NM.names $ LF.packageModules lfPkg2)\n-    forM_ eqModNames $ \\m@(LF.ModuleName modName) -> do\n-        [genSrc1, genSrc2] <-\n-            forM [(pkgId1, lfPkg1, pkgMap1), (pkgId2, lfPkg2, pkgMap2)] $ \\(pkgId, pkg, pkgMap) -> do\n-                generateSrcFromLf pkgId pkgMap <$> getModule m pkg\n-        let upgradeModPath =\n-                (joinPath $ fromMaybe \"\" mbDir : map T.unpack modName) <>\n-                \".daml\"\n-        let instancesModPath1 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesA\"\n-        let instancesModPath2 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesB\"\n-        templateNames <-\n-            map (T.unpack . T.intercalate \".\" . LF.unTypeConName) .\n-            NM.names . LF.moduleTemplates <$>\n-            getModule m lfPkg1\n-        let generatedUpgradeMod =\n-                generateUpgradeModule\n-                    templateNames\n-                    (T.unpack $ LF.moduleNameString m)\n-                    pkgName1\n-                    pkgName2\n-        let generatedInstancesMod1 =\n-                generateGenInstancesModule \"A\" (pkgName1, genSrc1)\n-        let generatedInstancesMod2 =\n-                generateGenInstancesModule \"B\" (pkgName2, genSrc2)\n-        forM_\n-            [ (upgradeModPath, generatedUpgradeMod)\n-            , (instancesModPath1, generatedInstancesMod1)\n-            , (instancesModPath2, generatedInstancesMod2)\n-            ] $ \\(path, mod) -> do\n-            createDirectoryIfMissing True $ takeDirectory path\n-            writeFile path mod\n+    -- initialise the package database\n+    execInit (optDamlLfVersion opts) projectOpts (InitPkgDb True)\n+    withProjectRoot' projectOpts $ \\_relativize\n+     -> do\n+        -- for all contained dalfs, generate source, typecheck and generate interface files and\n+        -- overwrite the existing ones.\n+        dbPath <- makeAbsolute $\n+                projectPackageDatabase </>\n+                lfVersionString (optDamlLfVersion opts)\n+        (diags, pkgMap) <- generatePackageMap [dbPath]\n+        unless (null diags) $ Logger.logWarning loggerH $ showDiagnostics diags\n+        let pkgMap0 = MS.map dalfPackageId pkgMap\n+        let genSrcs =\n+                [ ( unitId\n+                  , generateSrcPkgFromLf (dalfPackageId dalfPkg) pkgMap0 dalf)\n+                | (unitId, dalfPkg) <- MS.toList pkgMap\n+                , LF.ExternalPackage _ dalf <- [dalfPackagePkg dalfPkg]\n+                ]\n+      -- order the packages in topological order\n+        packageState <-\n+            generatePackageState (dbPath : optPackageDbs opts) False []\n+        let (depGraph, vertexToNode, _keyToVertex) =\n+                graphFromEdges $ do\n+                    (uid, src) <- genSrcs\n+                    let iuid = toInstalledUnitId uid\n+                    Just pkgInfo <-\n+                        [ lookupInstalledPackage\n+                              (fakeDynFlags\n+                                   {pkgState = pdfPkgState packageState})\n+                              iuid\n+                        ]\n+                    pure (src, iuid, depends pkgInfo)\n+        let unitIdsTopoSorted = reverse $ topSort depGraph\n+        createDirectoryIfMissing True genDir\n+        projectPkgDb <- makeAbsolute projectPackageDatabase\n+        forM_ unitIdsTopoSorted $ \\vertex -> withCurrentDirectory genDir $ do\n+            let (src, iuid, _) = vertexToNode vertex\n+            unless\n+                -- TODO (drsk) remove this filter\n+                (iuid `elem`\n+                 map stringToInstalledUnitId [\"daml-prim\", \"daml-stdlib\"]) $ do\n+                  -- typecheck and generate interface files\n+                  forM_ src $ \\(fp, content) -> do\n+                      let path = fromNormalizedFilePath fp\n+                      createDirectoryIfMissing True $ takeDirectory path\n+                      writeFile path content\n+                  opts' <-\n+                      mkOptions $\n+                      opts\n+                          { optWriteInterface = True\n+                          , optPackageDbs = [projectPkgDb]\n+                          , optIfaceDir =\n+                                Just\n+                                    (dbPath </> installedUnitIdString iuid)\n+                          , optIsGenerated = True\n+                          , optMbPackageName =\n+                                Just $ installedUnitIdString iuid\n+                          }\n+                  withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+                      forM_ src $ \\(fp, _content) -> do\n+                          mbCore <-\n+                              runAction ide $\n+                              getGhcCore fp\n+                          case mbCore of\n+                              Nothing ->\n+                                  ioError $\n+                                  userError $\n+                                  \"Compilation of generated source for \" <>\n+                                  installedUnitIdString iuid <>\n+                                  \" failed.\"\n+                              Just _core -> pure ()\n+        -- get the package name and the lf-package\n+        [(pkgName1, pkgId1, lfPkg1), (pkgName2, pkgId2, lfPkg2)] <-\n+            forM [inFile1, inFile2] $ \\inFile -> do\n+                bytes <- B.readFile inFile\n+                let pkgName = takeBaseName inFile\n+                let dar = toArchive $ BSL.fromStrict bytes\n+              -- get the main pkg"
  },
  {
    "id" : "b9cc3e09-5a54-4be7-aa61-4d3e280edf20",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "a2a8e9fa-c70b-465b-8c2e-0ca52312f44e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`headNote` or `headDef` might be more appropriate here.",
        "createdAt" : "2019-07-15T16:47:31Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "72c911df-ec5e-4163-851f-29943bacf998",
        "parentId" : "a2a8e9fa-c70b-465b-8c2e-0ca52312f44e",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed to headNote.",
        "createdAt" : "2019-07-16T09:53:16Z",
        "updatedAt" : "2019-07-16T09:53:16Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : null,
    "diffHunk" : "@@ -603,68 +610,156 @@ execInspectDar inFile = do\n             show (LF.unPackageId pkgId)\n \n execMigrate ::\n-       Options -> FilePath -> FilePath -> Maybe FilePath -> Command\n-execMigrate opts inFile1 inFile2 mbDir = do\n+       ProjectOpts\n+    -> Options\n+    -> FilePath\n+    -> FilePath\n+    -> Maybe FilePath\n+    -> Command\n+execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n+    opts <- mkOptions opts0\n+    inFile1 <- makeAbsolute inFile1_\n+    inFile2 <- makeAbsolute inFile2_\n     loggerH <- getLogger opts \"migrate\"\n-    [(pkgName1, pkgId1, lfPkg1, pkgMap1), (pkgName2, pkgId2, lfPkg2, pkgMap2)] <-\n-        forM [inFile1, inFile2] $ \\inFile -> do\n-            let pkg = takeBaseName inFile\n-            bytes <- B.readFile inFile\n-            let dar = toArchive $ BSL.fromStrict bytes\n-            manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n-            mainDalfPath <-\n-                maybe (ioError $ userError \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\") pure $\n-                headMay\n-                    [ main\n-                    | l <-\n-                          lines $ BSC.unpack $ BSL.toStrict $ fromEntry manifest\n-                    , Just main <- [stripPrefix \"Main-Dalf: \" l]\n-                    ]\n-            mainDalf <- BSL.toStrict . fromEntry <$> getEntry mainDalfPath dar\n-            (pkgId, lfPkg) <-\n-                errorOnLeft\n-                    (\"Cannot decode package \" <> mainDalfPath)\n-                    (Archive.decodeArchive mainDalf)\n-            pkgMap <- generatePkgMap loggerH dar\n-            pure (pkg, pkgId, lfPkg, pkgMap)\n-    let eqModNames =\n-            (NM.names $ LF.packageModules lfPkg1) `intersect`\n-            (NM.names $ LF.packageModules lfPkg2)\n-    forM_ eqModNames $ \\m@(LF.ModuleName modName) -> do\n-        [genSrc1, genSrc2] <-\n-            forM [(pkgId1, lfPkg1, pkgMap1), (pkgId2, lfPkg2, pkgMap2)] $ \\(pkgId, pkg, pkgMap) -> do\n-                generateSrcFromLf pkgId pkgMap <$> getModule m pkg\n-        let upgradeModPath =\n-                (joinPath $ fromMaybe \"\" mbDir : map T.unpack modName) <>\n-                \".daml\"\n-        let instancesModPath1 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesA\"\n-        let instancesModPath2 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesB\"\n-        templateNames <-\n-            map (T.unpack . T.intercalate \".\" . LF.unTypeConName) .\n-            NM.names . LF.moduleTemplates <$>\n-            getModule m lfPkg1\n-        let generatedUpgradeMod =\n-                generateUpgradeModule\n-                    templateNames\n-                    (T.unpack $ LF.moduleNameString m)\n-                    pkgName1\n-                    pkgName2\n-        let generatedInstancesMod1 =\n-                generateGenInstancesModule \"A\" (pkgName1, genSrc1)\n-        let generatedInstancesMod2 =\n-                generateGenInstancesModule \"B\" (pkgName2, genSrc2)\n-        forM_\n-            [ (upgradeModPath, generatedUpgradeMod)\n-            , (instancesModPath1, generatedInstancesMod1)\n-            , (instancesModPath2, generatedInstancesMod2)\n-            ] $ \\(path, mod) -> do\n-            createDirectoryIfMissing True $ takeDirectory path\n-            writeFile path mod\n+    -- initialise the package database\n+    execInit (optDamlLfVersion opts) projectOpts (InitPkgDb True)\n+    withProjectRoot' projectOpts $ \\_relativize\n+     -> do\n+        -- for all contained dalfs, generate source, typecheck and generate interface files and\n+        -- overwrite the existing ones.\n+        dbPath <- makeAbsolute $\n+                projectPackageDatabase </>\n+                lfVersionString (optDamlLfVersion opts)\n+        (diags, pkgMap) <- generatePackageMap [dbPath]\n+        unless (null diags) $ Logger.logWarning loggerH $ showDiagnostics diags\n+        let pkgMap0 = MS.map dalfPackageId pkgMap\n+        let genSrcs =\n+                [ ( unitId\n+                  , generateSrcPkgFromLf (dalfPackageId dalfPkg) pkgMap0 dalf)\n+                | (unitId, dalfPkg) <- MS.toList pkgMap\n+                , LF.ExternalPackage _ dalf <- [dalfPackagePkg dalfPkg]\n+                ]\n+      -- order the packages in topological order\n+        packageState <-\n+            generatePackageState (dbPath : optPackageDbs opts) False []\n+        let (depGraph, vertexToNode, _keyToVertex) =\n+                graphFromEdges $ do\n+                    (uid, src) <- genSrcs\n+                    let iuid = toInstalledUnitId uid\n+                    Just pkgInfo <-\n+                        [ lookupInstalledPackage\n+                              (fakeDynFlags\n+                                   {pkgState = pdfPkgState packageState})\n+                              iuid\n+                        ]\n+                    pure (src, iuid, depends pkgInfo)\n+        let unitIdsTopoSorted = reverse $ topSort depGraph\n+        createDirectoryIfMissing True genDir\n+        projectPkgDb <- makeAbsolute projectPackageDatabase\n+        forM_ unitIdsTopoSorted $ \\vertex -> withCurrentDirectory genDir $ do\n+            let (src, iuid, _) = vertexToNode vertex\n+            unless\n+                -- TODO (drsk) remove this filter\n+                (iuid `elem`\n+                 map stringToInstalledUnitId [\"daml-prim\", \"daml-stdlib\"]) $ do\n+                  -- typecheck and generate interface files\n+                  forM_ src $ \\(fp, content) -> do\n+                      let path = fromNormalizedFilePath fp\n+                      createDirectoryIfMissing True $ takeDirectory path\n+                      writeFile path content\n+                  opts' <-\n+                      mkOptions $\n+                      opts\n+                          { optWriteInterface = True\n+                          , optPackageDbs = [projectPkgDb]\n+                          , optIfaceDir =\n+                                Just\n+                                    (dbPath </> installedUnitIdString iuid)\n+                          , optIsGenerated = True\n+                          , optMbPackageName =\n+                                Just $ installedUnitIdString iuid\n+                          }\n+                  withDamlIdeState opts' loggerH diagnosticsLogger $ \\ide ->\n+                      forM_ src $ \\(fp, _content) -> do\n+                          mbCore <-\n+                              runAction ide $\n+                              getGhcCore fp\n+                          case mbCore of\n+                              Nothing ->\n+                                  ioError $\n+                                  userError $\n+                                  \"Compilation of generated source for \" <>\n+                                  installedUnitIdString iuid <>\n+                                  \" failed.\"\n+                              Just _core -> pure ()\n+        -- get the package name and the lf-package\n+        [(pkgName1, pkgId1, lfPkg1), (pkgName2, pkgId2, lfPkg2)] <-\n+            forM [inFile1, inFile2] $ \\inFile -> do\n+                bytes <- B.readFile inFile\n+                let pkgName = takeBaseName inFile\n+                let dar = toArchive $ BSL.fromStrict bytes\n+              -- get the main pkg\n+                manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n+                mainDalfPath <-\n+                    maybe\n+                        (ioError $\n+                         userError\n+                             \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\")\n+                        pure $\n+                    headMay"
  },
  {
    "id" : "aaf5db33-6d1f-4a24-8344-cec8559c57ca",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "43a4aa96-515e-4a03-8594-0e71953597a3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This mix of list comprehensions and `do` notation for lists is slightly odd.",
        "createdAt" : "2019-07-15T16:50:15Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : 219,
    "diffHunk" : "@@ -603,68 +610,156 @@ execInspectDar inFile = do\n             show (LF.unPackageId pkgId)\n \n execMigrate ::\n-       Options -> FilePath -> FilePath -> Maybe FilePath -> Command\n-execMigrate opts inFile1 inFile2 mbDir = do\n+       ProjectOpts\n+    -> Options\n+    -> FilePath\n+    -> FilePath\n+    -> Maybe FilePath\n+    -> Command\n+execMigrate projectOpts opts0 inFile1_ inFile2_ mbDir = do\n+    opts <- mkOptions opts0\n+    inFile1 <- makeAbsolute inFile1_\n+    inFile2 <- makeAbsolute inFile2_\n     loggerH <- getLogger opts \"migrate\"\n-    [(pkgName1, pkgId1, lfPkg1, pkgMap1), (pkgName2, pkgId2, lfPkg2, pkgMap2)] <-\n-        forM [inFile1, inFile2] $ \\inFile -> do\n-            let pkg = takeBaseName inFile\n-            bytes <- B.readFile inFile\n-            let dar = toArchive $ BSL.fromStrict bytes\n-            manifest <- getEntry \"META-INF/MANIFEST.MF\" dar\n-            mainDalfPath <-\n-                maybe (ioError $ userError \"Missing Main-Dalf entry in META-INF/MANIFEST.MF\") pure $\n-                headMay\n-                    [ main\n-                    | l <-\n-                          lines $ BSC.unpack $ BSL.toStrict $ fromEntry manifest\n-                    , Just main <- [stripPrefix \"Main-Dalf: \" l]\n-                    ]\n-            mainDalf <- BSL.toStrict . fromEntry <$> getEntry mainDalfPath dar\n-            (pkgId, lfPkg) <-\n-                errorOnLeft\n-                    (\"Cannot decode package \" <> mainDalfPath)\n-                    (Archive.decodeArchive mainDalf)\n-            pkgMap <- generatePkgMap loggerH dar\n-            pure (pkg, pkgId, lfPkg, pkgMap)\n-    let eqModNames =\n-            (NM.names $ LF.packageModules lfPkg1) `intersect`\n-            (NM.names $ LF.packageModules lfPkg2)\n-    forM_ eqModNames $ \\m@(LF.ModuleName modName) -> do\n-        [genSrc1, genSrc2] <-\n-            forM [(pkgId1, lfPkg1, pkgMap1), (pkgId2, lfPkg2, pkgMap2)] $ \\(pkgId, pkg, pkgMap) -> do\n-                generateSrcFromLf pkgId pkgMap <$> getModule m pkg\n-        let upgradeModPath =\n-                (joinPath $ fromMaybe \"\" mbDir : map T.unpack modName) <>\n-                \".daml\"\n-        let instancesModPath1 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesA\"\n-        let instancesModPath2 =\n-                replaceBaseName upgradeModPath $\n-                takeBaseName upgradeModPath <> \"InstancesB\"\n-        templateNames <-\n-            map (T.unpack . T.intercalate \".\" . LF.unTypeConName) .\n-            NM.names . LF.moduleTemplates <$>\n-            getModule m lfPkg1\n-        let generatedUpgradeMod =\n-                generateUpgradeModule\n-                    templateNames\n-                    (T.unpack $ LF.moduleNameString m)\n-                    pkgName1\n-                    pkgName2\n-        let generatedInstancesMod1 =\n-                generateGenInstancesModule \"A\" (pkgName1, genSrc1)\n-        let generatedInstancesMod2 =\n-                generateGenInstancesModule \"B\" (pkgName2, genSrc2)\n-        forM_\n-            [ (upgradeModPath, generatedUpgradeMod)\n-            , (instancesModPath1, generatedInstancesMod1)\n-            , (instancesModPath2, generatedInstancesMod2)\n-            ] $ \\(path, mod) -> do\n-            createDirectoryIfMissing True $ takeDirectory path\n-            writeFile path mod\n+    -- initialise the package database\n+    execInit (optDamlLfVersion opts) projectOpts (InitPkgDb True)\n+    withProjectRoot' projectOpts $ \\_relativize\n+     -> do\n+        -- for all contained dalfs, generate source, typecheck and generate interface files and\n+        -- overwrite the existing ones.\n+        dbPath <- makeAbsolute $\n+                projectPackageDatabase </>\n+                lfVersionString (optDamlLfVersion opts)\n+        (diags, pkgMap) <- generatePackageMap [dbPath]\n+        unless (null diags) $ Logger.logWarning loggerH $ showDiagnostics diags\n+        let pkgMap0 = MS.map dalfPackageId pkgMap\n+        let genSrcs =\n+                [ ( unitId\n+                  , generateSrcPkgFromLf (dalfPackageId dalfPkg) pkgMap0 dalf)\n+                | (unitId, dalfPkg) <- MS.toList pkgMap\n+                , LF.ExternalPackage _ dalf <- [dalfPackagePkg dalfPkg]\n+                ]\n+      -- order the packages in topological order\n+        packageState <-\n+            generatePackageState (dbPath : optPackageDbs opts) False []\n+        let (depGraph, vertexToNode, _keyToVertex) =\n+                graphFromEdges $ do"
  },
  {
    "id" : "4cf46fb9-cb20-4c4c-a974-08003affd27c",
    "prId" : 2115,
    "comments" : [
      {
        "id" : "f90fbe19-0d79-449d-a5e3-e5d943234549",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    <*> optHlintEnabled\r\n```",
        "createdAt" : "2019-07-12T12:05:57Z",
        "updatedAt" : "2019-07-12T15:42:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "70dbda3a4e6f6e2c8b607e944eb807553787c2c2",
    "line" : 14,
    "diffHunk" : "@@ -709,6 +712,8 @@ optionsParser numProcessors enableScenarioService parsePkgName = Options\n     <*> (concat <$> many optGhcCustomOptions)\n     <*> pure enableScenarioService\n     <*> pure (optScenarioValidation $ defaultOptions Nothing)\n+    <*> optHlintEnable"
  }
]