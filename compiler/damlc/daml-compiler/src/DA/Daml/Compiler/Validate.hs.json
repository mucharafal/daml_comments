[
  {
    "id" : "9d45b822-ce7c-4940-9e9d-5e04b0014bd8",
    "prId" : 4654,
    "comments" : [
      {
        "id" : "baed7efc-8455-46a6-9b51-8f21f1b25d5a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You don’t need this check. Just running the typechecker will enforce this.",
        "createdAt" : "2020-02-21T15:34:11Z",
        "updatedAt" : "2020-02-27T10:23:18Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ffa29f39-78ef-41a3-9b32-36db0d466eb1",
        "parentId" : "baed7efc-8455-46a6-9b51-8f21f1b25d5a",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done",
        "createdAt" : "2020-02-25T19:34:39Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3d3a0f5929bb9828dde33019f7bf542771a8edb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,75 @@\n+-- Copyright (c) 2020 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+module DA.Daml.Compiler.Validate\n+  ( Validation\n+  , runValidation\n+  , validateDar\n+  ) where\n+\n+import Control.Lens (toListOf)\n+import DA.Daml.LF.Ast.Optics (packageRefs)\n+import Data.List.Extra ((\\\\), nubSort)\n+import System.FilePath (isExtensionOf)\n+import qualified \"zip-archive\" Codec.Archive.Zip as ZipArchive\n+import qualified DA.Daml.LF.Ast as LF\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.ByteString.UTF8 as BSUTF8\n+import qualified Data.Text.Extended as T\n+\n+-- | Monad for performing Validation\n+newtype Validation a = Validation (Either ValidationError a) deriving (Functor,Applicative,Monad)\n+\n+data ValidationError\n+  = VeArchiveError FilePath Archive.ArchiveError\n+  | VeUnclosed [LF.PackageId]\n+\n+validationError :: ValidationError -> Validation a\n+validationError = Validation . Left\n+\n+-- | Runs a Validation, throwing an error when the validation fails\n+runValidation :: Validation a -> a\n+runValidation = \\case\n+  Validation (Left e) -> error (show e)\n+  Validation (Right a) -> a\n+\n+instance Show ValidationError where\n+  show = \\case\n+    VeArchiveError fp err -> unlines\n+      [ \"Invalid DAR.\"\n+      , \"DALF entry cannot be decoded: \" <> fp\n+      , show err ]\n+    VeUnclosed pids -> unlines $\n+      [ \"Invalid DAR.\"\n+      , \"The DAR is not closed.\"\n+      , \"The following packages are referenced but not defined:\"]\n+      ++ [\"- \" <> T.unpack (LF.unPackageId pid) | pid <- pids ]\n+\n+-- | Validate the byte string of a loaded DAR: that all DALFs are well-typed and the DAR is closed over packages\n+validateDar :: BSUTF8.ByteString -> Validation Int\n+validateDar bytes = do\n+  let dar = ZipArchive.toArchive $ BSL.fromStrict bytes\n+  let entries = [e | e <- ZipArchive.zEntries dar, \".dalf\" `isExtensionOf` ZipArchive.eRelativePath e]\n+  (definedIds,packages) <- unzip <$> mapM validateEntry entries\n+  -- TODO: validate the main DALF package exists\n+  validateClosedPackages definedIds packages\n+  mapM_ validateWellTyped packages\n+  return (length packages)\n+\n+validateEntry :: ZipArchive.Entry -> Validation (LF.PackageId,LF.Package)\n+validateEntry entry = do\n+  let bs = BSL.toStrict $ ZipArchive.fromEntry entry\n+  case Archive.decodeArchive Archive.DecodeAsMain bs of\n+    Left err -> validationError $ VeArchiveError (ZipArchive.eRelativePath entry) err\n+    Right x -> return x\n+\n+validateClosedPackages :: [LF.PackageId] -> [LF.Package] -> Validation ()"
  },
  {
    "id" : "51a40c13-a53d-4994-aa06-469b957aeea9",
    "prId" : 4654,
    "comments" : [
      {
        "id" : "c047fcc4-3515-4022-9f3b-5e332e0506c8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that you are only calling this in `IO`, this should use `fail` (or maybe even better `errorIO` which has a slightly less stupid error message) and change the return type. That both makes it more explicit that it can fail and it avoids issues due to laziness. e.g. `_ <- return $ error \"foobar\"` is not going to blow up whereas `_ <- errorIO \"foobar\"` will definitely blow up.",
        "createdAt" : "2020-02-26T09:14:26Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dd877338-0eb2-4622-a68f-d6022d2820bb",
        "parentId" : "c047fcc4-3515-4022-9f3b-5e332e0506c8",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`Control.Exception.Extra`, see https://hoogle.haskell.org/?hoogle=errorIO%20is%3Aexact. The reason why `fail` is a bit annoying is that it prefixes the error message with `user error` which always looks a bit awkward.",
        "createdAt" : "2020-02-27T09:15:42Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "df47dfb0-e7d5-4c87-968d-c476cc1915b8",
        "parentId" : "c047fcc4-3515-4022-9f3b-5e332e0506c8",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "using `errorIO` now",
        "createdAt" : "2020-02-27T09:21:02Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3d3a0f5929bb9828dde33019f7bf542771a8edb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,71 @@\n+-- Copyright (c) 2020 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.Compiler.Validate (validateDar) where\n+\n+import Control.Monad (forM_)\n+import qualified \"zip-archive\" Codec.Archive.Zip as ZipArchive\n+import qualified DA.Daml.LF.Ast as LF\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.Compiler.ExtractDar (extractDar,ExtractedDar(..))\n+import DA.Daml.LF.Ast.Version\n+import DA.Daml.LF.Ast.World (initWorld)\n+import DA.Pretty (renderPretty)\n+import qualified DA.Daml.LF.TypeChecker as TC (checkModule)\n+import qualified DA.Daml.LF.TypeChecker.Error as TC\n+\n+-- | Monad for performing Validation\n+newtype Validation a = Validation (Either ValidationError a) deriving (Functor,Applicative,Monad)\n+\n+data ValidationError\n+  = VeArchiveError FilePath Archive.ArchiveError\n+  | VeTypeError TC.Error\n+\n+validationError :: ValidationError -> Validation a\n+validationError = Validation . Left\n+\n+-- | Run a Validation, throwing an error when the validation fails\n+runValidation :: Validation a -> a\n+runValidation = \\case\n+  Validation (Left e) -> error (show e)"
  },
  {
    "id" : "a0dd1520-ab4b-4033-8c1d-1619217168d8",
    "prId" : 4654,
    "comments" : [
      {
        "id" : "bf719257-9449-40ef-a8d0-73558e76b7f0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that this type is only used internally in this module, I would just use  `Either ValidationError` directly. That also avoids confusion with the relatively popular `Validation` type in Haskell.",
        "createdAt" : "2020-02-26T09:15:15Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a42d3942-90b8-4e71-9699-6d38564d178f",
        "parentId" : "bf719257-9449-40ef-a8d0-73558e76b7f0",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I removed the `Validation` type entirely. It was buying almost nothing.",
        "createdAt" : "2020-02-27T09:14:44Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3d3a0f5929bb9828dde33019f7bf542771a8edb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,71 @@\n+-- Copyright (c) 2020 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.Compiler.Validate (validateDar) where\n+\n+import Control.Monad (forM_)\n+import qualified \"zip-archive\" Codec.Archive.Zip as ZipArchive\n+import qualified DA.Daml.LF.Ast as LF\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.Compiler.ExtractDar (extractDar,ExtractedDar(..))\n+import DA.Daml.LF.Ast.Version\n+import DA.Daml.LF.Ast.World (initWorld)\n+import DA.Pretty (renderPretty)\n+import qualified DA.Daml.LF.TypeChecker as TC (checkModule)\n+import qualified DA.Daml.LF.TypeChecker.Error as TC\n+\n+-- | Monad for performing Validation\n+newtype Validation a = Validation (Either ValidationError a) deriving (Functor,Applicative,Monad)"
  },
  {
    "id" : "18860fbb-7a01-4236-b954-72d942cd6fec",
    "prId" : 4654,
    "comments" : [
      {
        "id" : "d0f1ebef-5a51-4287-a7c7-e00897045c88",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you use `Either ValidationError` this just becomes `throwError`.",
        "createdAt" : "2020-02-26T09:16:02Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3d3a0f5929bb9828dde33019f7bf542771a8edb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,71 @@\n+-- Copyright (c) 2020 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.Compiler.Validate (validateDar) where\n+\n+import Control.Monad (forM_)\n+import qualified \"zip-archive\" Codec.Archive.Zip as ZipArchive\n+import qualified DA.Daml.LF.Ast as LF\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.Compiler.ExtractDar (extractDar,ExtractedDar(..))\n+import DA.Daml.LF.Ast.Version\n+import DA.Daml.LF.Ast.World (initWorld)\n+import DA.Pretty (renderPretty)\n+import qualified DA.Daml.LF.TypeChecker as TC (checkModule)\n+import qualified DA.Daml.LF.TypeChecker.Error as TC\n+\n+-- | Monad for performing Validation\n+newtype Validation a = Validation (Either ValidationError a) deriving (Functor,Applicative,Monad)\n+\n+data ValidationError\n+  = VeArchiveError FilePath Archive.ArchiveError\n+  | VeTypeError TC.Error\n+\n+validationError :: ValidationError -> Validation a\n+validationError = Validation . Left"
  },
  {
    "id" : "baad1e37-dc52-4a19-83a2-4ca733fab476",
    "prId" : 4654,
    "comments" : [
      {
        "id" : "a4d84402-c877-4860-a52c-2d4ae744a515",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That might run into the exact laziness problem that I mentioned above (could be that you end up forcing it somehow atm but better be on the safe side and throw an IO exception via `errorIO`).",
        "createdAt" : "2020-02-26T09:32:17Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3d3a0f5929bb9828dde33019f7bf542771a8edb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,71 @@\n+-- Copyright (c) 2020 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.Compiler.Validate (validateDar) where\n+\n+import Control.Monad (forM_)\n+import qualified \"zip-archive\" Codec.Archive.Zip as ZipArchive\n+import qualified DA.Daml.LF.Ast as LF\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.Compiler.ExtractDar (extractDar,ExtractedDar(..))\n+import DA.Daml.LF.Ast.Version\n+import DA.Daml.LF.Ast.World (initWorld)\n+import DA.Pretty (renderPretty)\n+import qualified DA.Daml.LF.TypeChecker as TC (checkModule)\n+import qualified DA.Daml.LF.TypeChecker.Error as TC\n+\n+-- | Monad for performing Validation\n+newtype Validation a = Validation (Either ValidationError a) deriving (Functor,Applicative,Monad)\n+\n+data ValidationError\n+  = VeArchiveError FilePath Archive.ArchiveError\n+  | VeTypeError TC.Error\n+\n+validationError :: ValidationError -> Validation a\n+validationError = Validation . Left\n+\n+-- | Run a Validation, throwing an error when the validation fails\n+runValidation :: Validation a -> a\n+runValidation = \\case\n+  Validation (Left e) -> error (show e)\n+  Validation (Right a) -> a\n+\n+instance Show ValidationError where\n+  show = \\case\n+    VeArchiveError fp err -> unlines\n+      [ \"Invalid DAR.\"\n+      , \"DALF entry cannot be decoded: \" <> fp\n+      , show err ]\n+    VeTypeError err -> unlines\n+      [ \"Invalid DAR.\"\n+      , \"The DAR is not well typed.\"\n+      , renderPretty err ]\n+\n+-- | Validate a loaded DAR: that all DALFs are well-typed and consequently that the DAR is closed\n+validateDar :: FilePath -> IO Int\n+validateDar inFile = do\n+  ExtractedDar{edDalfs} <- extractDar inFile\n+  return $ runValidation $ do"
  },
  {
    "id" : "ce86464c-2bbd-46e4-9774-978738df50a6",
    "prId" : 4654,
    "comments" : [
      {
        "id" : "9df19502-6d9c-4c72-b58b-289ba467a76f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I was trying to see if laziness kicks in here (looks like it doesn’t and it’s forced somehow), however there is a much bigger issue:\r\n\r\n`damlc validate-dar` is unable to validate a DAR created with `daml new foobar && cd foobar && daml build`:\r\n\r\n```\r\ndamlc: Invalid DAR.\r\nThe DAR is not well typed.\r\nerror type checking template Main.Asset precondition:\r\n  type mismatch:\r\n  * expected type:\r\n      c38eb615743a614183ee4a655c2a31dc732269ed50e0c54894d3eab1ade6cb80:Main:Asset\r\n  * found type:\r\n      Main:Asset\r\n  * expression:\r\n      this\r\n\r\nCallStack (from HasCallStack):\r\n  error, called at compiler/damlc/daml-compiler/src/DA/Daml/Compiler/Validate.hs:33:26 in compilerZSdamlcZSdaml-compilerZSdaml-compiler:DA.Daml.Compiler.Validate\r\n```\r\n\r\nIt looks like this is probably caused by the fact that you use `initWorld` which only initializes dependency packages instead of  `initWorldSelf` which also intiializes the current package which is necessary to resolve `PRSelf`. This is probably coming from https://github.com/digital-asset/daml/blob/master/compiler/daml-lf-tools/src/DA/Daml/LF/TypeChecker/Check.hs#L647.\r\n\r\nI believe any code that uses a template will exhibit this so making a testcase should be fairly straightforward hopefully.",
        "createdAt" : "2020-02-26T09:40:55Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1d6495ab-f1de-48d9-8512-19eefb752e8d",
        "parentId" : "9df19502-6d9c-4c72-b58b-289ba467a76f",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "This is now fixed.",
        "createdAt" : "2020-02-27T09:21:37Z",
        "updatedAt" : "2020-02-27T10:23:19Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c3d3a0f5929bb9828dde33019f7bf542771a8edb",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,71 @@\n+-- Copyright (c) 2020 The DAML Authors. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Daml.Compiler.Validate (validateDar) where\n+\n+import Control.Monad (forM_)\n+import qualified \"zip-archive\" Codec.Archive.Zip as ZipArchive\n+import qualified DA.Daml.LF.Ast as LF\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import qualified Data.NameMap as NM\n+\n+import DA.Daml.Compiler.ExtractDar (extractDar,ExtractedDar(..))\n+import DA.Daml.LF.Ast.Version\n+import DA.Daml.LF.Ast.World (initWorld)\n+import DA.Pretty (renderPretty)\n+import qualified DA.Daml.LF.TypeChecker as TC (checkModule)\n+import qualified DA.Daml.LF.TypeChecker.Error as TC\n+\n+-- | Monad for performing Validation\n+newtype Validation a = Validation (Either ValidationError a) deriving (Functor,Applicative,Monad)\n+\n+data ValidationError\n+  = VeArchiveError FilePath Archive.ArchiveError\n+  | VeTypeError TC.Error\n+\n+validationError :: ValidationError -> Validation a\n+validationError = Validation . Left\n+\n+-- | Run a Validation, throwing an error when the validation fails\n+runValidation :: Validation a -> a\n+runValidation = \\case\n+  Validation (Left e) -> error (show e)\n+  Validation (Right a) -> a\n+\n+instance Show ValidationError where\n+  show = \\case\n+    VeArchiveError fp err -> unlines\n+      [ \"Invalid DAR.\"\n+      , \"DALF entry cannot be decoded: \" <> fp\n+      , show err ]\n+    VeTypeError err -> unlines\n+      [ \"Invalid DAR.\"\n+      , \"The DAR is not well typed.\"\n+      , renderPretty err ]\n+\n+-- | Validate a loaded DAR: that all DALFs are well-typed and consequently that the DAR is closed\n+validateDar :: FilePath -> IO Int\n+validateDar inFile = do\n+  ExtractedDar{edDalfs} <- extractDar inFile\n+  return $ runValidation $ do\n+    xps <- mapM (validateEntry Archive.DecodeAsDependency) edDalfs"
  }
]