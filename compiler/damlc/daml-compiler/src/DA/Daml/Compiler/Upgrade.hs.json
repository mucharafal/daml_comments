[
  {
    "id" : "ce27b10f-d09b-41fb-a8ce-7d0a209381f7",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "64c0c39f-3d36-44f7-87bc-834643014fb3",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we filter out `Archive`? Yes, we have an `archive` method in the `Template` typeclass but we also generate `Choice` instances for it and that matters if you want to use code that is polymorphic in a `Choice` constraint so just calling `archive` isn’t a workaround.",
        "createdAt" : "2019-11-15T09:26:17Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dd00d87b-090e-49fb-bcfa-0c8f920be2e4",
        "parentId" : "64c0c39f-3d36-44f7-87bc-834643014fb3",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "no longer filter Archive",
        "createdAt" : "2019-11-18T16:52:55Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -152,6 +153,21 @@ templateInstances env externPkgId =\n   where\n     mod = envMod env\n \n+choiceInstances :: Env -> LF.PackageId -> [HsDecl GhcPs]\n+choiceInstances env externPkgId =\n+    [ generateChoiceInstance env externPkgId templateDT choice\n+    | template <- NM.elems $ LF.moduleTemplates mod\n+    , choice <- NM.elems $ LF.tplChoices template\n+    , not (specialArchiveChoice choice)"
  },
  {
    "id" : "5dd2626d-3c76-48ea-8ebc-4df938139b87",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "a0565bf9-6a6d-4ca8-9ed2-3801b465164a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Currently we will silently discard all choices if this lookup fails. Afaict if this lookup fails it’s a bug somewhere so crashing seems like a better option than silently discarding the choices.",
        "createdAt" : "2019-11-15T09:28:19Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b84db70b-5adf-42d7-ae09-035f3ba7c174",
        "parentId" : "a0565bf9-6a6d-4ca8-9ed2-3801b465164a",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "My defence is I was matching the style of existing code in `templateInstances`, so I assumed it was possible for this lookup to fail. But it does seem unlikely. @robin-da ?",
        "createdAt" : "2019-11-15T13:31:52Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "10b338aa-ef63-41bc-bfe3-5dea7d53808f",
        "parentId" : "a0565bf9-6a6d-4ca8-9ed2-3801b465164a",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "it's fine to drop the choice if it's not present in the dalf, but here you will drop it even if it's present but a later condition will fail. That's different from `templateInstances`, I think this case should be a crash.",
        "createdAt" : "2019-11-15T17:04:08Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "89082d38-7943-4174-8ff1-ad854ec0e0fe",
        "parentId" : "a0565bf9-6a6d-4ca8-9ed2-3801b465164a",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "change to crash if cant find the template datatype def",
        "createdAt" : "2019-11-18T17:08:19Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -152,6 +153,21 @@ templateInstances env externPkgId =\n   where\n     mod = envMod env\n \n+choiceInstances :: Env -> LF.PackageId -> [HsDecl GhcPs]\n+choiceInstances env externPkgId =\n+    [ generateChoiceInstance env externPkgId templateDT choice\n+    | template <- NM.elems $ LF.moduleTemplates mod\n+    , choice <- NM.elems $ LF.tplChoices template\n+    , not (specialArchiveChoice choice)\n+    , Just templateDT <-"
  },
  {
    "id" : "be4a8eae-9a23-49ee-bdb3-870476a9d750",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "abeb980d-9f00-4c4d-9038-8178c1756c5b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The renaming seems slightly confusing in `data X = Y`, `X` is a type constructor and `Y` is a data constructor. I’ve never heard the term datatype constructor. As for `dataParams` this sounds like it might refer to the fields in a data constructor.\r\n\r\nLeaving the naming aside, is there ever a case where `dataParams` is non-empty at the moment? Given that we monomorphize types in DAML-LF, I’m having trouble coming up with a way to hit this. If not, it would be good to document this in a comment (this will most likely change in DAML-LF soonish so no need to remove it completely).",
        "createdAt" : "2019-11-15T09:32:05Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3a83659c-3032-4fd0-9efe-c3eee666c49d",
        "parentId" : "abeb980d-9f00-4c4d-9038-8178c1756c5b",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "The reason for the name change is to match the names used by the only caller of the function.\r\nAnd at this point, the names are bound by the `LF.DefDataType{..}`\r\n`dataTypeCon` and `dataParams` being the field names of `DefDataType`.\r\n\r\nRegarding whether `dataParams` can be non-empty: I'm not sure. This code was pre-existing. So I assume Robin passed this because it could be non-empty.  @robin-da ?",
        "createdAt" : "2019-11-15T13:28:36Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "91499ccb-97e9-45c6-9ddd-9ca05767e169",
        "parentId" : "abeb980d-9f00-4c4d-9038-8178c1756c5b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It makes some sense in the datatype definition due to Haskell’s issues with colliding record field names. I don’t think it makes any sense here.",
        "createdAt" : "2019-11-15T13:31:27Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eb08d944-3f3e-4ac9-a887-4e44a420763d",
        "parentId" : "abeb980d-9f00-4c4d-9038-8178c1756c5b",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "reverted name change",
        "createdAt" : "2019-11-18T17:15:14Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "375be8f6-74db-4e63-9bc3-ee5141da6eba",
        "parentId" : "abeb980d-9f00-4c4d-9038-8178c1756c5b",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "the question about if `dataParams` can be non-empty is still open",
        "createdAt" : "2019-11-18T17:15:49Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a53d4d17-8fa0-48ba-8efa-054cc86646f4",
        "parentId" : "abeb980d-9f00-4c4d-9038-8178c1756c5b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m fine leaving it for now and we can sort it out later.",
        "createdAt" : "2019-11-19T08:07:38Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -234,7 +250,7 @@ generateTemplateInstance ::\n     -> [(LF.TypeVarName, LF.Kind)]\n     -> LF.PackageId\n     -> HsDecl GhcPs\n-generateTemplateInstance env typeCon typeParams externPkgId =\n+generateTemplateInstance env dataTypeCon dataParams externPkgId ="
  },
  {
    "id" : "fd0b5711-3b87-40a4-862b-7cc87ad009d3",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "77165ecb-e025-498d-b348-15938308603b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Isn’t this just `LF.moduleName $ envMod mod`? It looks like you are first intercalating dots via `moduleNameString`, unpacking only to then split on dots and repack.",
        "createdAt" : "2019-11-15T09:44:03Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5685a0af-c4c1-4dc3-9d7a-3ee90970a967",
        "parentId" : "77165ecb-e025-498d-b348-15938308603b",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "simplified to avoid this",
        "createdAt" : "2019-11-18T17:29:10Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -283,86 +307,156 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n         , \"fromAnyTemplate\"\n         , \"_templateTypeRep\"\n         ]\n-    classMethodStub :: LF.TypeConName -> T.Text -> LHsBindLR GhcPs GhcPs\n-    classMethodStub templName funName =\n-        noLoc $\n-        FunBind\n-            { fun_ext = noExt\n-            , fun_id = mkRdrName funName\n-            , fun_matches =\n-                  MG\n-                      { mg_ext = noExt\n-                      , mg_alts =\n-                            noLoc\n-                                [ noLoc $\n-                                  Match\n-                                      { m_ext = noExt\n-                                      , m_ctxt =\n-                                            FunRhs\n-                                                { mc_fun = mkRdrName funName\n-                                                , mc_fixity = Prefix\n-                                                , mc_strictness = NoSrcStrict\n-                                                }\n-                                      , m_pats =\n-                                            [ noLoc $\n-                                            VarPat noExt (mkRdrName \"proxy\")\n-                                            | funName == \"_templateTypeRep\"\n-                                            ] -- NOTE (drsk): we shouldn't need this pattern, but\n-                                              -- somehow ghc insists on it. We want to fix this in ghc.\n-                                      , m_rhs_sig = Nothing\n-                                      , m_grhss =\n-                                            GRHSs\n-                                                { grhssExt = noExt\n-                                                , grhssGRHSs =\n-                                                      [ noLoc $\n-                                                        GRHS\n-                                                            noExt\n-                                                            []\n-                                                            (noLoc $\n-                                                             HsAppType\n-                                                                 noExt\n-                                                                 (noLoc $\n-                                                                  HsVar\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       mkRdrQual\n-                                                                           (mkModuleName\n-                                                                                \"GHC.Types\")\n-                                                                           (mkOccName\n-                                                                                varName\n-                                                                                \"external\")))\n-                                                                 (HsWC\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       HsTyLit noExt $\n-                                                                       HsStrTy\n-                                                                           NoSourceText $\n-                                                                       mkFastString\n-                                                                           ((T.unpack $\n-                                                                             LF.unPackageId\n-                                                                                 externPkgId) <>\n-                                                                            \":\" <>\n-                                                                            moduleNameStr <>\n-                                                                            \":\" <>\n-                                                                            (T.unpack $\n-                                                                             T.intercalate\n-                                                                                 \".\" $\n-                                                                             LF.unTypeConName\n-                                                                                 templName) <>\n-                                                                            \":\" <>\n-                                                                            T.unpack\n-                                                                                funName))))\n-                                                      ]\n-                                                , grhssLocalBinds =\n-                                                      noLoc emptyLocalBinds\n-                                                }\n-                                      }\n-                                ]\n-                      , mg_origin = Generated\n+\n+-- | Generate a single choice instance for a given templateDT/choice\n+generateChoiceInstance ::\n+       Env\n+    -> LF.PackageId\n+    -> LF.DefDataType\n+    -> LF.TemplateChoice\n+    -> HsDecl GhcPs\n+generateChoiceInstance env externPkgId templateDT choice =\n+    InstD noExt $\n+    ClsInstD\n+        noExt\n+        ClsInstDecl\n+            { cid_ext = noExt\n+            , cid_poly_ty =\n+                  HsIB\n+                      { hsib_ext = noExt\n+                      , hsib_body = body\n                       }\n-            , fun_co_fn = WpHole\n-            , fun_tick = []\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n+            , cid_sigs = []\n+            , cid_tyfam_insts = []\n+            , cid_datafam_insts = []\n+            , cid_overlap_mode = Nothing\n             }\n+  where\n+\n+    app :: LHsType GhcPs -> LHsType GhcPs -> LHsType GhcPs\n+    app t1 t2 = noLoc $ HsAppTy noExt t1 t2\n+\n+    body :: LHsType GhcPs =\n+      choiceClass `app` arg1 `app` arg2 `app` arg3\n+\n+    choiceClass :: LHsType GhcPs =\n+        noLoc $\n+        HsTyVar noExt NotPromoted $\n+        noLoc $\n+        mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n+        mkOccName varName \"Choice\" :: LHsType GhcPs\n+\n+    arg1 :: LHsType GhcPs =\n+      noLoc $ convType env lfTemplateType\n+\n+    arg2 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceType\n+\n+    arg3 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceReturnType\n+\n+    moduleNameStr = T.unpack $ LF.moduleNameString $ LF.moduleName $ envMod env\n+    moduleName0 ="
  },
  {
    "id" : "ac538779-dbb2-47f6-aa03-81b2d7abca59",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "924abe80-860e-4039-972f-ab84654449f1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This isn’t quite right:\r\n1. The choice type does not need to be defined in the same module as the template. This matters both for `Archive` (is that why you filtered it out above?) and for generic templates where the monomorphized version will live in the module where you create the instance while the choice type will live in the module where you define the generic template.\r\n2. In DAML-LF the name of the choice type constructor must not match the choice name. There is no good way to represent this in DAML and we never generate such code so I would suggest to error out in that case.\r\n\r\nSo in summary:\r\n* Validate that the choice name and the type constructor name of the choice type match\r\n* Use the choice argument type instead of inventing the choice type based on the choice name.",
        "createdAt" : "2019-11-15T09:48:42Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cd556cc4-575d-426c-901b-2e7c0097cbb2",
        "parentId" : "924abe80-860e-4039-972f-ab84654449f1",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Yes that's why I filtered `Archive`.\r\nI was assuming that for a well-formed DAML the names must match.\r\nIf not, how do we discover from a `TemplateChoice` the corresponding `TypeConName`?",
        "createdAt" : "2019-11-15T13:22:14Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c747700c-fafe-448a-9d3b-41145a2e4fc3",
        "parentId" : "924abe80-860e-4039-972f-ab84654449f1",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "In DAML the names match. In DAML-LF the definition of a template choice includes the name as well as the type as separate fields and no relationship between the two is required.",
        "createdAt" : "2019-11-15T13:29:20Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b165b63e-dd44-42f8-9b22-a47f644a73f3",
        "parentId" : "924abe80-860e-4039-972f-ab84654449f1",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "The type being the 2nd element of the pair `chcArgBinder`, right?",
        "createdAt" : "2019-11-15T16:12:03Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c23fbb55-10b3-4e99-8ff2-5f18e3390a09",
        "parentId" : "924abe80-860e-4039-972f-ab84654449f1",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "There are a couple of different restrictions at different levels so let me try to make them explicit (also responding to the comment below on why we probably don’t want to support mismatches between the choice name and the choice type constructor name).\r\n\r\n1. If you define a template in DAML, we will generate a record type for each choice with the same name as the choice. There are two somewhat special cases here:\r\n    1. The `Archive` record is defined in `daml-stdlib` so there is only one for all templates.\r\n    2. For generic templates, we only defined one choice record that might have type parameters instead of defining one per instance.\r\n\r\n However, even for these cases the choice name is the same as the type constructor name.\r\n2. The `Choice` typeclass in DAML requires the pair `(templateType, choiceArgType)` to uniquely identify a choice on a given template. In particular, that means that we cannot represent two choices with the same argument type in DAML. It does _not_ require that `choiceArgType` is a record and supporting variants should work out nicely and not be confusing. The `Choice` typeclass does also _not_ require that the type constructor name  and the choice name match. However, if that is not the case things get really confusing. For an extreme example consider a choice `Foo` which takes a type called `Bar` as the argument and a choice called `Bar` which takes a type called `Foo` as the argument. To call the `Foo` choice you would now do something like `exercise cid Bar` in DAML which at least to me isn’t intuitive at all. Furthermore, while you could support this case it falls apart if you have a template with two choices (with different names) that take the same choice argument type. Therefore, the most sensible option (at least initially) seems to me to reject choices that have different choice and type constructor names.\r\n3. In DAML-LF the only restriction is that the choice names must unique per template. It is possible to use the same choice argument type for multiple choices, it is possible to use non-record types (e.g., even `()` which we should also reject). As mentioned above the `Choice` typeclass above does not allow us to express this in full generality so we necessarily have to reject some cases and we probably want to reject slightly more than strictly necessary to provide a reasonable UX.",
        "createdAt" : "2019-11-15T16:50:10Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "66b9d29e-71a3-4bff-a91d-df4358daa5ab",
        "parentId" : "924abe80-860e-4039-972f-ab84654449f1",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Fixed code to no longer assume there is a datatype named the same as the choice",
        "createdAt" : "2019-11-18T17:24:50Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -283,86 +307,156 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n         , \"fromAnyTemplate\"\n         , \"_templateTypeRep\"\n         ]\n-    classMethodStub :: LF.TypeConName -> T.Text -> LHsBindLR GhcPs GhcPs\n-    classMethodStub templName funName =\n-        noLoc $\n-        FunBind\n-            { fun_ext = noExt\n-            , fun_id = mkRdrName funName\n-            , fun_matches =\n-                  MG\n-                      { mg_ext = noExt\n-                      , mg_alts =\n-                            noLoc\n-                                [ noLoc $\n-                                  Match\n-                                      { m_ext = noExt\n-                                      , m_ctxt =\n-                                            FunRhs\n-                                                { mc_fun = mkRdrName funName\n-                                                , mc_fixity = Prefix\n-                                                , mc_strictness = NoSrcStrict\n-                                                }\n-                                      , m_pats =\n-                                            [ noLoc $\n-                                            VarPat noExt (mkRdrName \"proxy\")\n-                                            | funName == \"_templateTypeRep\"\n-                                            ] -- NOTE (drsk): we shouldn't need this pattern, but\n-                                              -- somehow ghc insists on it. We want to fix this in ghc.\n-                                      , m_rhs_sig = Nothing\n-                                      , m_grhss =\n-                                            GRHSs\n-                                                { grhssExt = noExt\n-                                                , grhssGRHSs =\n-                                                      [ noLoc $\n-                                                        GRHS\n-                                                            noExt\n-                                                            []\n-                                                            (noLoc $\n-                                                             HsAppType\n-                                                                 noExt\n-                                                                 (noLoc $\n-                                                                  HsVar\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       mkRdrQual\n-                                                                           (mkModuleName\n-                                                                                \"GHC.Types\")\n-                                                                           (mkOccName\n-                                                                                varName\n-                                                                                \"external\")))\n-                                                                 (HsWC\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       HsTyLit noExt $\n-                                                                       HsStrTy\n-                                                                           NoSourceText $\n-                                                                       mkFastString\n-                                                                           ((T.unpack $\n-                                                                             LF.unPackageId\n-                                                                                 externPkgId) <>\n-                                                                            \":\" <>\n-                                                                            moduleNameStr <>\n-                                                                            \":\" <>\n-                                                                            (T.unpack $\n-                                                                             T.intercalate\n-                                                                                 \".\" $\n-                                                                             LF.unTypeConName\n-                                                                                 templName) <>\n-                                                                            \":\" <>\n-                                                                            T.unpack\n-                                                                                funName))))\n-                                                      ]\n-                                                , grhssLocalBinds =\n-                                                      noLoc emptyLocalBinds\n-                                                }\n-                                      }\n-                                ]\n-                      , mg_origin = Generated\n+\n+-- | Generate a single choice instance for a given templateDT/choice\n+generateChoiceInstance ::\n+       Env\n+    -> LF.PackageId\n+    -> LF.DefDataType\n+    -> LF.TemplateChoice\n+    -> HsDecl GhcPs\n+generateChoiceInstance env externPkgId templateDT choice =\n+    InstD noExt $\n+    ClsInstD\n+        noExt\n+        ClsInstDecl\n+            { cid_ext = noExt\n+            , cid_poly_ty =\n+                  HsIB\n+                      { hsib_ext = noExt\n+                      , hsib_body = body\n                       }\n-            , fun_co_fn = WpHole\n-            , fun_tick = []\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n+            , cid_sigs = []\n+            , cid_tyfam_insts = []\n+            , cid_datafam_insts = []\n+            , cid_overlap_mode = Nothing\n             }\n+  where\n+\n+    app :: LHsType GhcPs -> LHsType GhcPs -> LHsType GhcPs\n+    app t1 t2 = noLoc $ HsAppTy noExt t1 t2\n+\n+    body :: LHsType GhcPs =\n+      choiceClass `app` arg1 `app` arg2 `app` arg3\n+\n+    choiceClass :: LHsType GhcPs =\n+        noLoc $\n+        HsTyVar noExt NotPromoted $\n+        noLoc $\n+        mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n+        mkOccName varName \"Choice\" :: LHsType GhcPs\n+\n+    arg1 :: LHsType GhcPs =\n+      noLoc $ convType env lfTemplateType\n+\n+    arg2 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceType\n+\n+    arg3 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceReturnType\n+\n+    moduleNameStr = T.unpack $ LF.moduleNameString $ LF.moduleName $ envMod env\n+    moduleName0 =\n+        LF.ModuleName $\n+        map T.pack $\n+        splitOn \".\" moduleNameStr\n+\n+    lfTemplateType :: LF.Type =\n+        LF.mkTApps\n+          (LF.TCon (LF.Qualified LF.PRSelf moduleName0 dataTypeCon))\n+          (map (LF.TVar . fst) dataParams)\n+\n+    lfChoiceType :: LF.Type ="
  },
  {
    "id" : "b59e891c-5fa1-448a-8f1f-073005fb67ab",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "599b1cc6-7e9e-4188-b84e-ca813a2d9175",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "btw, in case you’re still looking for what to work on next, we also need `TemplateKey` instances.",
        "createdAt" : "2019-11-19T08:04:24Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c98ac9d9-7e35-4985-9751-749ed42965d0",
        "parentId" : "599b1cc6-7e9e-4188-b84e-ca813a2d9175",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I'll discuss with Robin who is best placed to work on these.",
        "createdAt" : "2019-11-19T09:19:54Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 6,
    "diffHunk" : "@@ -112,8 +112,7 @@ generateTemplateInstanceModule env externPkgId\n               map (showSDocForUser fakeDynFlags alwaysQualify . ppr) instances)\n     | otherwise = Nothing\n   where\n-    instances = templInstances\n-    templInstances = templateInstances env externPkgId\n+    instances = templateInstances env externPkgId ++ choiceInstances env externPkgId"
  },
  {
    "id" : "52dcc934-6e51-454b-a882-ad21f122e482",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "9646e320-e583-4dbb-a922-6752082f7c8a",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "You will have to import these now as `Sdk.DA.Internal.Prelude` and expose the modules with this alias in `generateAndInstallInstancesPackage` in Packaging.hs.",
        "createdAt" : "2019-11-19T12:22:47Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8a524e4b-2d41-4d46-98eb-4342c32c547d",
        "parentId" : "9646e320-e583-4dbb-a922-6752082f7c8a",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I dont understand what is special about the 2 imports I added. \r\nMany cases of `DA.Internal.`... without an `Sdk.` prefix were already present in this file.\r\n\r\nPlease feel free to make the change you think is necessary in this PR.\r\n",
        "createdAt" : "2019-11-19T16:17:21Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4556c807-2d96-460a-a02b-78c2921f0582",
        "parentId" : "9646e320-e583-4dbb-a922-6752082f7c8a",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Now I understand. This change is necessary after rebasing on master.",
        "createdAt" : "2019-11-19T16:30:14Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 15,
    "diffHunk" : "@@ -138,6 +137,8 @@ generateTemplateInstanceModule env externPkgId\n           modName <>\n           \" as X\"\n         , \"import \\\"\" <> packageName <> \"\\\" \" <> modName\n+        , \"import qualified DA.Internal.LF\"\n+        , \"import qualified DA.Internal.Prelude\""
  },
  {
    "id" : "7be18c82-ba90-48a9-b08e-eede4e385025",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "f9815e4b-0205-47b2-8c07-ad4a75a44d6f",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "we have copies of `lfTemplateType`, `mkExternalString` and `methodMapping` in `generateChoiceInstance` and `generateTemplateInstance`. We should factor these out.",
        "createdAt" : "2019-11-19T12:31:13Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "30066380-457a-4b44-9f36-42c28b97b688",
        "parentId" : "f9815e4b-0205-47b2-8c07-ad4a75a44d6f",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done, except for `mkExternalString` which varies",
        "createdAt" : "2019-11-19T16:09:22Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : 71,
    "diffHunk" : "@@ -247,31 +257,36 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n                             noLoc $\n                             HsAppTy noExt templateTy $\n                             noLoc $\n-                            convType env $ lfTemplateType typeCon typeParams\n+                            convType env lfTemplateType\n                       }\n-            , cid_binds = listToBag $ map (classMethodStub typeCon) templateMethodNames\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n             , cid_sigs = []\n             , cid_tyfam_insts = []\n             , cid_datafam_insts = []\n             , cid_overlap_mode = Nothing\n             }\n   where\n     moduleNameStr = T.unpack $ LF.moduleNameString $ LF.moduleName $ envMod env\n-    moduleName0 =\n-        LF.ModuleName $\n-        map T.pack $\n-        splitOn \".\" moduleNameStr\n+    moduleName0 = LF.moduleName $ envMod env\n     templateTy =\n         noLoc $\n         HsTyVar noExt NotPromoted $\n         noLoc $\n         mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n         mkOccName varName \"Template\" :: LHsType GhcPs\n-    lfTemplateType dataTypeCon dataParams =\n+    lfTemplateType =\n         LF.mkTApps\n-            (LF.TCon (LF.Qualified LF.PRSelf moduleName0 dataTypeCon))\n-            (map (LF.TVar . fst) dataParams)\n-    templateMethodNames =\n+            (LF.TCon (LF.Qualified LF.PRSelf moduleName0 typeCon))\n+            (map (LF.TVar . fst) typeParams)\n+    methodMapping =\n+        map (\\funName -> (funName, mkExternalString funName)) methodNames\n+    mkExternalString :: T.Text -> String\n+    mkExternalString funName ="
  },
  {
    "id" : "dbea7996-0ecd-46c0-9a6c-03328e2b911c",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "c97a309e-e096-4415-b3bf-f763c1e83fa8",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "this is already present in ghc-lib as `mkHsAppTy`.",
        "createdAt" : "2019-11-19T12:36:39Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "481b53f4-59db-4390-aa72-0ef46cfd090c",
        "parentId" : "c97a309e-e096-4415-b3bf-f763c1e83fa8",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "changed to use `mkHsAppTy",
        "createdAt" : "2019-11-19T16:09:41Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -283,86 +298,153 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n         , \"fromAnyTemplate\"\n         , \"_templateTypeRep\"\n         ]\n-    classMethodStub :: LF.TypeConName -> T.Text -> LHsBindLR GhcPs GhcPs\n-    classMethodStub templName funName =\n-        noLoc $\n-        FunBind\n-            { fun_ext = noExt\n-            , fun_id = mkRdrName funName\n-            , fun_matches =\n-                  MG\n-                      { mg_ext = noExt\n-                      , mg_alts =\n-                            noLoc\n-                                [ noLoc $\n-                                  Match\n-                                      { m_ext = noExt\n-                                      , m_ctxt =\n-                                            FunRhs\n-                                                { mc_fun = mkRdrName funName\n-                                                , mc_fixity = Prefix\n-                                                , mc_strictness = NoSrcStrict\n-                                                }\n-                                      , m_pats =\n-                                            [ noLoc $\n-                                            VarPat noExt (mkRdrName \"proxy\")\n-                                            | funName == \"_templateTypeRep\"\n-                                            ] -- NOTE (drsk): we shouldn't need this pattern, but\n-                                              -- somehow ghc insists on it. We want to fix this in ghc.\n-                                      , m_rhs_sig = Nothing\n-                                      , m_grhss =\n-                                            GRHSs\n-                                                { grhssExt = noExt\n-                                                , grhssGRHSs =\n-                                                      [ noLoc $\n-                                                        GRHS\n-                                                            noExt\n-                                                            []\n-                                                            (noLoc $\n-                                                             HsAppType\n-                                                                 noExt\n-                                                                 (noLoc $\n-                                                                  HsVar\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       mkRdrQual\n-                                                                           (mkModuleName\n-                                                                                \"GHC.Types\")\n-                                                                           (mkOccName\n-                                                                                varName\n-                                                                                \"external\")))\n-                                                                 (HsWC\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       HsTyLit noExt $\n-                                                                       HsStrTy\n-                                                                           NoSourceText $\n-                                                                       mkFastString\n-                                                                           ((T.unpack $\n-                                                                             LF.unPackageId\n-                                                                                 externPkgId) <>\n-                                                                            \":\" <>\n-                                                                            moduleNameStr <>\n-                                                                            \":\" <>\n-                                                                            (T.unpack $\n-                                                                             T.intercalate\n-                                                                                 \".\" $\n-                                                                             LF.unTypeConName\n-                                                                                 templName) <>\n-                                                                            \":\" <>\n-                                                                            T.unpack\n-                                                                                funName))))\n-                                                      ]\n-                                                , grhssLocalBinds =\n-                                                      noLoc emptyLocalBinds\n-                                                }\n-                                      }\n-                                ]\n-                      , mg_origin = Generated\n+\n+-- | Generate a single choice instance for a given template/choice\n+generateChoiceInstance ::\n+       Env\n+    -> LF.PackageId\n+    -> LF.Template\n+    -> LF.TemplateChoice\n+    -> HsDecl GhcPs\n+generateChoiceInstance env externPkgId template choice =\n+    InstD noExt $\n+    ClsInstD\n+        noExt\n+        ClsInstDecl\n+            { cid_ext = noExt\n+            , cid_poly_ty =\n+                  HsIB\n+                      { hsib_ext = noExt\n+                      , hsib_body = body\n                       }\n-            , fun_co_fn = WpHole\n-            , fun_tick = []\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n+            , cid_sigs = []\n+            , cid_tyfam_insts = []\n+            , cid_datafam_insts = []\n+            , cid_overlap_mode = Nothing\n             }\n+  where\n+    app :: LHsType GhcPs -> LHsType GhcPs -> LHsType GhcPs\n+    app t1 t2 = noLoc $ HsAppTy noExt t1 t2"
  },
  {
    "id" : "d30f6c86-d1b3-4f29-867a-5f6b5d8adae0",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "0117e593-628e-4458-b03b-81d1d1a703eb",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "You'll also need to qualify this as `Sdk.DA.Internal.Template`.",
        "createdAt" : "2019-11-19T12:37:41Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4733d594-4c60-44f8-bfc0-8839b5c8b1ad",
        "parentId" : "0117e593-628e-4458-b03b-81d1d1a703eb",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "same as above",
        "createdAt" : "2019-11-19T16:17:34Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -283,86 +298,153 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n         , \"fromAnyTemplate\"\n         , \"_templateTypeRep\"\n         ]\n-    classMethodStub :: LF.TypeConName -> T.Text -> LHsBindLR GhcPs GhcPs\n-    classMethodStub templName funName =\n-        noLoc $\n-        FunBind\n-            { fun_ext = noExt\n-            , fun_id = mkRdrName funName\n-            , fun_matches =\n-                  MG\n-                      { mg_ext = noExt\n-                      , mg_alts =\n-                            noLoc\n-                                [ noLoc $\n-                                  Match\n-                                      { m_ext = noExt\n-                                      , m_ctxt =\n-                                            FunRhs\n-                                                { mc_fun = mkRdrName funName\n-                                                , mc_fixity = Prefix\n-                                                , mc_strictness = NoSrcStrict\n-                                                }\n-                                      , m_pats =\n-                                            [ noLoc $\n-                                            VarPat noExt (mkRdrName \"proxy\")\n-                                            | funName == \"_templateTypeRep\"\n-                                            ] -- NOTE (drsk): we shouldn't need this pattern, but\n-                                              -- somehow ghc insists on it. We want to fix this in ghc.\n-                                      , m_rhs_sig = Nothing\n-                                      , m_grhss =\n-                                            GRHSs\n-                                                { grhssExt = noExt\n-                                                , grhssGRHSs =\n-                                                      [ noLoc $\n-                                                        GRHS\n-                                                            noExt\n-                                                            []\n-                                                            (noLoc $\n-                                                             HsAppType\n-                                                                 noExt\n-                                                                 (noLoc $\n-                                                                  HsVar\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       mkRdrQual\n-                                                                           (mkModuleName\n-                                                                                \"GHC.Types\")\n-                                                                           (mkOccName\n-                                                                                varName\n-                                                                                \"external\")))\n-                                                                 (HsWC\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       HsTyLit noExt $\n-                                                                       HsStrTy\n-                                                                           NoSourceText $\n-                                                                       mkFastString\n-                                                                           ((T.unpack $\n-                                                                             LF.unPackageId\n-                                                                                 externPkgId) <>\n-                                                                            \":\" <>\n-                                                                            moduleNameStr <>\n-                                                                            \":\" <>\n-                                                                            (T.unpack $\n-                                                                             T.intercalate\n-                                                                                 \".\" $\n-                                                                             LF.unTypeConName\n-                                                                                 templName) <>\n-                                                                            \":\" <>\n-                                                                            T.unpack\n-                                                                                funName))))\n-                                                      ]\n-                                                , grhssLocalBinds =\n-                                                      noLoc emptyLocalBinds\n-                                                }\n-                                      }\n-                                ]\n-                      , mg_origin = Generated\n+\n+-- | Generate a single choice instance for a given template/choice\n+generateChoiceInstance ::\n+       Env\n+    -> LF.PackageId\n+    -> LF.Template\n+    -> LF.TemplateChoice\n+    -> HsDecl GhcPs\n+generateChoiceInstance env externPkgId template choice =\n+    InstD noExt $\n+    ClsInstD\n+        noExt\n+        ClsInstDecl\n+            { cid_ext = noExt\n+            , cid_poly_ty =\n+                  HsIB\n+                      { hsib_ext = noExt\n+                      , hsib_body = body\n                       }\n-            , fun_co_fn = WpHole\n-            , fun_tick = []\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n+            , cid_sigs = []\n+            , cid_tyfam_insts = []\n+            , cid_datafam_insts = []\n+            , cid_overlap_mode = Nothing\n             }\n+  where\n+    app :: LHsType GhcPs -> LHsType GhcPs -> LHsType GhcPs\n+    app t1 t2 = noLoc $ HsAppTy noExt t1 t2\n+\n+    body :: LHsType GhcPs =\n+      choiceClass `app` arg1 `app` arg2 `app` arg3\n+\n+    choiceClass :: LHsType GhcPs =\n+        noLoc $\n+        HsTyVar noExt NotPromoted $\n+        noLoc $\n+        mkRdrQual (mkModuleName \"DA.Internal.Template\") $"
  },
  {
    "id" : "54922c0a-447b-47ab-9a4d-1f10e6ed6e74",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "70670504-2c03-4da9-be79-bc407485e5cd",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "you can reuse moduleName0 here.",
        "createdAt" : "2019-11-19T12:39:30Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8301899b-3d34-4b46-9862-43a34661ead3",
        "parentId" : "70670504-2c03-4da9-be79-bc407485e5cd",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "ok",
        "createdAt" : "2019-11-19T16:09:53Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -283,86 +298,153 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n         , \"fromAnyTemplate\"\n         , \"_templateTypeRep\"\n         ]\n-    classMethodStub :: LF.TypeConName -> T.Text -> LHsBindLR GhcPs GhcPs\n-    classMethodStub templName funName =\n-        noLoc $\n-        FunBind\n-            { fun_ext = noExt\n-            , fun_id = mkRdrName funName\n-            , fun_matches =\n-                  MG\n-                      { mg_ext = noExt\n-                      , mg_alts =\n-                            noLoc\n-                                [ noLoc $\n-                                  Match\n-                                      { m_ext = noExt\n-                                      , m_ctxt =\n-                                            FunRhs\n-                                                { mc_fun = mkRdrName funName\n-                                                , mc_fixity = Prefix\n-                                                , mc_strictness = NoSrcStrict\n-                                                }\n-                                      , m_pats =\n-                                            [ noLoc $\n-                                            VarPat noExt (mkRdrName \"proxy\")\n-                                            | funName == \"_templateTypeRep\"\n-                                            ] -- NOTE (drsk): we shouldn't need this pattern, but\n-                                              -- somehow ghc insists on it. We want to fix this in ghc.\n-                                      , m_rhs_sig = Nothing\n-                                      , m_grhss =\n-                                            GRHSs\n-                                                { grhssExt = noExt\n-                                                , grhssGRHSs =\n-                                                      [ noLoc $\n-                                                        GRHS\n-                                                            noExt\n-                                                            []\n-                                                            (noLoc $\n-                                                             HsAppType\n-                                                                 noExt\n-                                                                 (noLoc $\n-                                                                  HsVar\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       mkRdrQual\n-                                                                           (mkModuleName\n-                                                                                \"GHC.Types\")\n-                                                                           (mkOccName\n-                                                                                varName\n-                                                                                \"external\")))\n-                                                                 (HsWC\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       HsTyLit noExt $\n-                                                                       HsStrTy\n-                                                                           NoSourceText $\n-                                                                       mkFastString\n-                                                                           ((T.unpack $\n-                                                                             LF.unPackageId\n-                                                                                 externPkgId) <>\n-                                                                            \":\" <>\n-                                                                            moduleNameStr <>\n-                                                                            \":\" <>\n-                                                                            (T.unpack $\n-                                                                             T.intercalate\n-                                                                                 \".\" $\n-                                                                             LF.unTypeConName\n-                                                                                 templName) <>\n-                                                                            \":\" <>\n-                                                                            T.unpack\n-                                                                                funName))))\n-                                                      ]\n-                                                , grhssLocalBinds =\n-                                                      noLoc emptyLocalBinds\n-                                                }\n-                                      }\n-                                ]\n-                      , mg_origin = Generated\n+\n+-- | Generate a single choice instance for a given template/choice\n+generateChoiceInstance ::\n+       Env\n+    -> LF.PackageId\n+    -> LF.Template\n+    -> LF.TemplateChoice\n+    -> HsDecl GhcPs\n+generateChoiceInstance env externPkgId template choice =\n+    InstD noExt $\n+    ClsInstD\n+        noExt\n+        ClsInstDecl\n+            { cid_ext = noExt\n+            , cid_poly_ty =\n+                  HsIB\n+                      { hsib_ext = noExt\n+                      , hsib_body = body\n                       }\n-            , fun_co_fn = WpHole\n-            , fun_tick = []\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n+            , cid_sigs = []\n+            , cid_tyfam_insts = []\n+            , cid_datafam_insts = []\n+            , cid_overlap_mode = Nothing\n             }\n+  where\n+    app :: LHsType GhcPs -> LHsType GhcPs -> LHsType GhcPs\n+    app t1 t2 = noLoc $ HsAppTy noExt t1 t2\n+\n+    body :: LHsType GhcPs =\n+      choiceClass `app` arg1 `app` arg2 `app` arg3\n+\n+    choiceClass :: LHsType GhcPs =\n+        noLoc $\n+        HsTyVar noExt NotPromoted $\n+        noLoc $\n+        mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n+        mkOccName varName \"Choice\" :: LHsType GhcPs\n+\n+    arg1 :: LHsType GhcPs =\n+      noLoc $ convType env lfTemplateType\n+\n+    arg2 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceType\n+\n+    arg3 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceReturnType\n+\n+    moduleNameStr = T.unpack $ LF.moduleNameString $ LF.moduleName $ envMod env"
  },
  {
    "id" : "d9c59c00-4222-45f6-b639-4bf79cb3711e",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "5f51337f-a9c3-494e-b664-8dd07c78a8e5",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I changed this to match with the style above.",
        "createdAt" : "2019-11-19T12:40:55Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -283,86 +298,153 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n         , \"fromAnyTemplate\"\n         , \"_templateTypeRep\"\n         ]\n-    classMethodStub :: LF.TypeConName -> T.Text -> LHsBindLR GhcPs GhcPs\n-    classMethodStub templName funName =\n-        noLoc $\n-        FunBind\n-            { fun_ext = noExt\n-            , fun_id = mkRdrName funName\n-            , fun_matches =\n-                  MG\n-                      { mg_ext = noExt\n-                      , mg_alts =\n-                            noLoc\n-                                [ noLoc $\n-                                  Match\n-                                      { m_ext = noExt\n-                                      , m_ctxt =\n-                                            FunRhs\n-                                                { mc_fun = mkRdrName funName\n-                                                , mc_fixity = Prefix\n-                                                , mc_strictness = NoSrcStrict\n-                                                }\n-                                      , m_pats =\n-                                            [ noLoc $\n-                                            VarPat noExt (mkRdrName \"proxy\")\n-                                            | funName == \"_templateTypeRep\"\n-                                            ] -- NOTE (drsk): we shouldn't need this pattern, but\n-                                              -- somehow ghc insists on it. We want to fix this in ghc.\n-                                      , m_rhs_sig = Nothing\n-                                      , m_grhss =\n-                                            GRHSs\n-                                                { grhssExt = noExt\n-                                                , grhssGRHSs =\n-                                                      [ noLoc $\n-                                                        GRHS\n-                                                            noExt\n-                                                            []\n-                                                            (noLoc $\n-                                                             HsAppType\n-                                                                 noExt\n-                                                                 (noLoc $\n-                                                                  HsVar\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       mkRdrQual\n-                                                                           (mkModuleName\n-                                                                                \"GHC.Types\")\n-                                                                           (mkOccName\n-                                                                                varName\n-                                                                                \"external\")))\n-                                                                 (HsWC\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       HsTyLit noExt $\n-                                                                       HsStrTy\n-                                                                           NoSourceText $\n-                                                                       mkFastString\n-                                                                           ((T.unpack $\n-                                                                             LF.unPackageId\n-                                                                                 externPkgId) <>\n-                                                                            \":\" <>\n-                                                                            moduleNameStr <>\n-                                                                            \":\" <>\n-                                                                            (T.unpack $\n-                                                                             T.intercalate\n-                                                                                 \".\" $\n-                                                                             LF.unTypeConName\n-                                                                                 templName) <>\n-                                                                            \":\" <>\n-                                                                            T.unpack\n-                                                                                funName))))\n-                                                      ]\n-                                                , grhssLocalBinds =\n-                                                      noLoc emptyLocalBinds\n-                                                }\n-                                      }\n-                                ]\n-                      , mg_origin = Generated\n+\n+-- | Generate a single choice instance for a given template/choice\n+generateChoiceInstance ::\n+       Env\n+    -> LF.PackageId\n+    -> LF.Template\n+    -> LF.TemplateChoice\n+    -> HsDecl GhcPs\n+generateChoiceInstance env externPkgId template choice =\n+    InstD noExt $\n+    ClsInstD\n+        noExt\n+        ClsInstDecl\n+            { cid_ext = noExt\n+            , cid_poly_ty =\n+                  HsIB\n+                      { hsib_ext = noExt\n+                      , hsib_body = body\n                       }\n-            , fun_co_fn = WpHole\n-            , fun_tick = []\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n+            , cid_sigs = []\n+            , cid_tyfam_insts = []\n+            , cid_datafam_insts = []\n+            , cid_overlap_mode = Nothing\n             }\n+  where\n+    app :: LHsType GhcPs -> LHsType GhcPs -> LHsType GhcPs\n+    app t1 t2 = noLoc $ HsAppTy noExt t1 t2\n+\n+    body :: LHsType GhcPs =\n+      choiceClass `app` arg1 `app` arg2 `app` arg3\n+\n+    choiceClass :: LHsType GhcPs =\n+        noLoc $\n+        HsTyVar noExt NotPromoted $\n+        noLoc $\n+        mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n+        mkOccName varName \"Choice\" :: LHsType GhcPs\n+\n+    arg1 :: LHsType GhcPs =\n+      noLoc $ convType env lfTemplateType\n+\n+    arg2 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceType\n+\n+    arg3 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceReturnType\n+\n+    moduleNameStr = T.unpack $ LF.moduleNameString $ LF.moduleName $ envMod env\n+    moduleName0 = LF.moduleName $ envMod env\n+\n+    lfTemplateType :: LF.Type =\n+        LF.mkTApps\n+          (LF.TCon (LF.Qualified LF.PRSelf moduleName0 dataTypeCon))\n+          (map (LF.TVar . fst) dataParams)\n+\n+    tycon :: LF.TypeConName = LF.tplTypeCon template"
  },
  {
    "id" : "4545ac8a-9b1e-4449-be08-484c87b5e721",
    "prId" : 3477,
    "comments" : [
      {
        "id" : "69fee39e-b501-4d54-bf30-dee47e8678b4",
        "parentId" : null,
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I allowed myself  to reformat this, I found it hard to read.",
        "createdAt" : "2019-11-19T12:42:33Z",
        "updatedAt" : "2019-11-19T22:40:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "df46a0c0ece38f03f22149c7964ffc4d607dc43b",
    "line" : null,
    "diffHunk" : "@@ -283,86 +298,153 @@ generateTemplateInstance env typeCon typeParams externPkgId =\n         , \"fromAnyTemplate\"\n         , \"_templateTypeRep\"\n         ]\n-    classMethodStub :: LF.TypeConName -> T.Text -> LHsBindLR GhcPs GhcPs\n-    classMethodStub templName funName =\n-        noLoc $\n-        FunBind\n-            { fun_ext = noExt\n-            , fun_id = mkRdrName funName\n-            , fun_matches =\n-                  MG\n-                      { mg_ext = noExt\n-                      , mg_alts =\n-                            noLoc\n-                                [ noLoc $\n-                                  Match\n-                                      { m_ext = noExt\n-                                      , m_ctxt =\n-                                            FunRhs\n-                                                { mc_fun = mkRdrName funName\n-                                                , mc_fixity = Prefix\n-                                                , mc_strictness = NoSrcStrict\n-                                                }\n-                                      , m_pats =\n-                                            [ noLoc $\n-                                            VarPat noExt (mkRdrName \"proxy\")\n-                                            | funName == \"_templateTypeRep\"\n-                                            ] -- NOTE (drsk): we shouldn't need this pattern, but\n-                                              -- somehow ghc insists on it. We want to fix this in ghc.\n-                                      , m_rhs_sig = Nothing\n-                                      , m_grhss =\n-                                            GRHSs\n-                                                { grhssExt = noExt\n-                                                , grhssGRHSs =\n-                                                      [ noLoc $\n-                                                        GRHS\n-                                                            noExt\n-                                                            []\n-                                                            (noLoc $\n-                                                             HsAppType\n-                                                                 noExt\n-                                                                 (noLoc $\n-                                                                  HsVar\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       mkRdrQual\n-                                                                           (mkModuleName\n-                                                                                \"GHC.Types\")\n-                                                                           (mkOccName\n-                                                                                varName\n-                                                                                \"external\")))\n-                                                                 (HsWC\n-                                                                      noExt\n-                                                                      (noLoc $\n-                                                                       HsTyLit noExt $\n-                                                                       HsStrTy\n-                                                                           NoSourceText $\n-                                                                       mkFastString\n-                                                                           ((T.unpack $\n-                                                                             LF.unPackageId\n-                                                                                 externPkgId) <>\n-                                                                            \":\" <>\n-                                                                            moduleNameStr <>\n-                                                                            \":\" <>\n-                                                                            (T.unpack $\n-                                                                             T.intercalate\n-                                                                                 \".\" $\n-                                                                             LF.unTypeConName\n-                                                                                 templName) <>\n-                                                                            \":\" <>\n-                                                                            T.unpack\n-                                                                                funName))))\n-                                                      ]\n-                                                , grhssLocalBinds =\n-                                                      noLoc emptyLocalBinds\n-                                                }\n-                                      }\n-                                ]\n-                      , mg_origin = Generated\n+\n+-- | Generate a single choice instance for a given template/choice\n+generateChoiceInstance ::\n+       Env\n+    -> LF.PackageId\n+    -> LF.Template\n+    -> LF.TemplateChoice\n+    -> HsDecl GhcPs\n+generateChoiceInstance env externPkgId template choice =\n+    InstD noExt $\n+    ClsInstD\n+        noExt\n+        ClsInstDecl\n+            { cid_ext = noExt\n+            , cid_poly_ty =\n+                  HsIB\n+                      { hsib_ext = noExt\n+                      , hsib_body = body\n                       }\n-            , fun_co_fn = WpHole\n-            , fun_tick = []\n+            , cid_binds = listToBag $ map classMethodStub methodMapping\n+            , cid_sigs = []\n+            , cid_tyfam_insts = []\n+            , cid_datafam_insts = []\n+            , cid_overlap_mode = Nothing\n             }\n+  where\n+    app :: LHsType GhcPs -> LHsType GhcPs -> LHsType GhcPs\n+    app t1 t2 = noLoc $ HsAppTy noExt t1 t2\n+\n+    body :: LHsType GhcPs =\n+      choiceClass `app` arg1 `app` arg2 `app` arg3\n+\n+    choiceClass :: LHsType GhcPs =\n+        noLoc $\n+        HsTyVar noExt NotPromoted $\n+        noLoc $\n+        mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n+        mkOccName varName \"Choice\" :: LHsType GhcPs\n+\n+    arg1 :: LHsType GhcPs =\n+      noLoc $ convType env lfTemplateType\n+\n+    arg2 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceType\n+\n+    arg3 :: LHsType GhcPs =\n+      noLoc $ convType env lfChoiceReturnType\n+\n+    moduleNameStr = T.unpack $ LF.moduleNameString $ LF.moduleName $ envMod env\n+    moduleName0 = LF.moduleName $ envMod env\n+\n+    lfTemplateType :: LF.Type =\n+        LF.mkTApps\n+          (LF.TCon (LF.Qualified LF.PRSelf moduleName0 dataTypeCon))\n+          (map (LF.TVar . fst) dataParams)\n+\n+    tycon :: LF.TypeConName = LF.tplTypeCon template\n+    templateDT = case NM.lookup tycon (LF.moduleDataTypes (envMod env)) of\n+      Just x -> x\n+      Nothing -> error $ \"Internal error: Could not find template definition for: \" <> show tycon\n+\n+    LF.DefDataType{dataTypeCon,dataParams} = templateDT\n+    LF.TemplateChoice{chcArgBinder=(_,lfChoiceType),chcName,chcReturnType=lfChoiceReturnType} = choice"
  },
  {
    "id" : "56bbfd85-5b1f-4260-9741-bf3c01fb46b1",
    "prId" : 3449,
    "comments" : [
      {
        "id" : "4b88f271-6a1c-4e8a-a235-e727776525c8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : ":heart_eyes_cat: ",
        "createdAt" : "2019-11-13T19:42:42Z",
        "updatedAt" : "2019-11-14T13:05:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5a096e9dffa2db78ef38611797efc533c90d574a",
    "line" : null,
    "diffHunk" : "@@ -684,8 +681,13 @@ convType env =\n     \\case\n         LF.TVar tyVarName ->\n             HsTyVar noExt NotPromoted $ mkRdrName $ LF.unTypeVarName tyVarName\n+        LF.TCon LF.Qualified {..}\n+          | qualModule == LF.ModuleName [\"DA\", \"Types\"]\n+          , [name] <- LF.unTypeConName qualObject\n+          , Just n <- stripPrefix \"Tuple\" $ T.unpack name\n+          , Just i <- readMay n -> mkTuple i"
  },
  {
    "id" : "d89bc872-718f-417c-814a-4ee327f7f208",
    "prId" : 3437,
    "comments" : [
      {
        "id" : "83d93ac9-4680-4faa-b028-e282b89ffecc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we get a ticket for this and link it here, please? Same below.",
        "createdAt" : "2019-11-12T19:05:43Z",
        "updatedAt" : "2019-11-13T10:15:23Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "20f265a7-ce57-48f2-a146-2c9bf777f5dc",
        "parentId" : "83d93ac9-4680-4faa-b028-e282b89ffecc",
        "author" : null,
        "body" : "Sure! 👍 I'll add the map ticket #2256.",
        "createdAt" : "2019-11-13T10:14:05Z",
        "updatedAt" : "2019-11-13T10:15:23Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2687a7b32b981b95bbe4f511bdbce97d15c432ca",
    "line" : null,
    "diffHunk" : "@@ -666,6 +666,8 @@ generateSrcFromLf env thisPkgId = noLoc mod\n             LF.BTContractId -> (damlStdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n             LF.BTOptional -> (damlStdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"Prelude\"])\n             LF.BTMap -> (damlStdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTGenMap -> (damlStdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+                -- GENMAP TODO: Verify module name once GenMap implemented in stdlib."
  },
  {
    "id" : "5aac2be8-1e90-4cc4-9751-1ed5cc7fda3c",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "329abb42-78eb-45b4-83ce-6d7eab550c3a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This generates source containing _only_ the instances but not the datatype stubs right? Is the input to this the original DALF or the stub package containing the data type? Would be good to record this in a comment.",
        "createdAt" : "2019-11-06T13:52:14Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "182dd690-9b01-4721-975c-fc1503599fb9",
        "parentId" : "329abb42-78eb-45b4-83ce-6d7eab550c3a",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Yes, and yes. I'll add a comment to make it clear.",
        "createdAt" : "2019-11-06T14:52:24Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bb0281d8-05cb-493d-a670-2460cfbefdca",
        "parentId" : "329abb42-78eb-45b4-83ce-6d7eab550c3a",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Actually, just for the stub you don't need the DALF, only when you convert to daml-lf.",
        "createdAt" : "2019-11-06T15:00:28Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 12,
    "diffHunk" : "@@ -85,6 +86,64 @@ upgradeTemplates n =\n     , \"    convert B.\" <> n <> \"{..} = A.\" <> n <> \" {..}\"\n     ]\n \n+-- | Generate the source for a package containing template instances for all templates defined in a"
  },
  {
    "id" : "496f2ef1-dfcf-47fc-ae79-58b81234172c",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "e79243c5-c670-4148-bea3-3e4dad324e45",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is this case just an optimization? I don’t see what goes wrong if we try to generate a module with no instances here. Would be good to document this.",
        "createdAt" : "2019-11-06T14:07:52Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3f71b56e-c90d-42a3-8f38-13fd0862386a",
        "parentId" : "e79243c5-c670-4148-bea3-3e4dad324e45",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "it's optimization, I'll add a comment.",
        "createdAt" : "2019-11-06T15:24:28Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 45,
    "diffHunk" : "@@ -85,6 +86,64 @@ upgradeTemplates n =\n     , \"    convert B.\" <> n <> \"{..} = A.\" <> n <> \" {..}\"\n     ]\n \n+-- | Generate the source for a package containing template instances for all templates defined in a\n+-- package.\n+generateInstancesPkgFromLf ::\n+       (LF.PackageRef -> UnitId)\n+    -> LF.PackageId\n+    -> LF.Package\n+    -> [(NormalizedFilePath, String)]\n+generateInstancesPkgFromLf getUnitId pkgId pkg =\n+    catMaybes\n+        [ generateInstanceModule\n+            Env\n+                { envGetUnitId = getUnitId\n+                , envQualify = False\n+                , envMod = mod\n+                }\n+            pkgId\n+        | mod <- NM.toList $ LF.packageModules pkg\n+        ]\n+\n+-- | Generate a module containing template/generic instances for all the contained templates.\n+generateInstanceModule ::\n+       Env -> LF.PackageId -> Maybe (NormalizedFilePath, String)\n+generateInstanceModule env externPkgId\n+    | not $ null instances =\n+        Just\n+            ( toNormalizedFilePath modFilePath\n+            , unlines $\n+              header ++\n+              nubSort imports ++\n+              map (showSDocForUser fakeDynFlags alwaysQualify . ppr) instances)\n+    | otherwise = Nothing"
  },
  {
    "id" : "fd2f866f-20bc-4b3b-9f81-c289b1e8108d",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "f2b4bffe-b1d1-4314-b8e2-7b431be6adb6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\ngenerateTemplateInstanceModule ::\r\n```\r\nWe already have `generateGenInstanceModule` so let’s make it clear what the difference is.",
        "createdAt" : "2019-11-06T14:09:07Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : null,
    "diffHunk" : "@@ -85,6 +86,64 @@ upgradeTemplates n =\n     , \"    convert B.\" <> n <> \"{..} = A.\" <> n <> \" {..}\"\n     ]\n \n+-- | Generate the source for a package containing template instances for all templates defined in a\n+-- package.\n+generateInstancesPkgFromLf ::\n+       (LF.PackageRef -> UnitId)\n+    -> LF.PackageId\n+    -> LF.Package\n+    -> [(NormalizedFilePath, String)]\n+generateInstancesPkgFromLf getUnitId pkgId pkg =\n+    catMaybes\n+        [ generateInstanceModule\n+            Env\n+                { envGetUnitId = getUnitId\n+                , envQualify = False\n+                , envMod = mod\n+                }\n+            pkgId\n+        | mod <- NM.toList $ LF.packageModules pkg\n+        ]\n+\n+-- | Generate a module containing template/generic instances for all the contained templates.\n+generateInstanceModule ::"
  },
  {
    "id" : "514c1248-59cf-4d24-baee-1f24fac4705d",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "c9c28ca7-3d07-47c0-8589-ebb24eda0368",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This whole function is almost identical to `generateGenInstanceModule` apart from the actual generation of the instances which is a separate function anyway. Can we factor out the common code?",
        "createdAt" : "2019-11-06T14:10:13Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "782e40e7-be5f-4870-9656-44acc9dc6207",
        "parentId" : "c9c28ca7-3d07-47c0-8589-ebb24eda0368",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "They are also slightly different in the qualification. I find harder to read and understand when I factor it out.",
        "createdAt" : "2019-11-06T16:18:08Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : 36,
    "diffHunk" : "@@ -85,6 +86,64 @@ upgradeTemplates n =\n     , \"    convert B.\" <> n <> \"{..} = A.\" <> n <> \" {..}\"\n     ]\n \n+-- | Generate the source for a package containing template instances for all templates defined in a\n+-- package.\n+generateInstancesPkgFromLf ::\n+       (LF.PackageRef -> UnitId)\n+    -> LF.PackageId\n+    -> LF.Package\n+    -> [(NormalizedFilePath, String)]\n+generateInstancesPkgFromLf getUnitId pkgId pkg =\n+    catMaybes\n+        [ generateInstanceModule\n+            Env\n+                { envGetUnitId = getUnitId\n+                , envQualify = False\n+                , envMod = mod\n+                }\n+            pkgId\n+        | mod <- NM.toList $ LF.packageModules pkg\n+        ]\n+\n+-- | Generate a module containing template/generic instances for all the contained templates.\n+generateInstanceModule ::\n+       Env -> LF.PackageId -> Maybe (NormalizedFilePath, String)"
  },
  {
    "id" : "9f40d156-0c5a-4ee1-b5f9-7bb808db2d0f",
    "prId" : 3358,
    "comments" : [
      {
        "id" : "35a7a893-dc19-4336-8a37-f9e9f64792a2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Rather than iterating over all data types and filtering out templates, you can go over the templates and do a lookup in the data types.",
        "createdAt" : "2019-11-06T14:11:44Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1db8882f-e695-407a-9d67-328eda18b0bc",
        "parentId" : "35a7a893-dc19-4336-8a37-f9e9f64792a2",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "good idea, changed.",
        "createdAt" : "2019-11-06T16:25:01Z",
        "updatedAt" : "2019-11-06T17:52:03Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b0aeb99ed4d3a42210e8653d7873d2ba828d51d",
    "line" : null,
    "diffHunk" : "@@ -85,6 +86,64 @@ upgradeTemplates n =\n     , \"    convert B.\" <> n <> \"{..} = A.\" <> n <> \" {..}\"\n     ]\n \n+-- | Generate the source for a package containing template instances for all templates defined in a\n+-- package.\n+generateInstancesPkgFromLf ::\n+       (LF.PackageRef -> UnitId)\n+    -> LF.PackageId\n+    -> LF.Package\n+    -> [(NormalizedFilePath, String)]\n+generateInstancesPkgFromLf getUnitId pkgId pkg =\n+    catMaybes\n+        [ generateInstanceModule\n+            Env\n+                { envGetUnitId = getUnitId\n+                , envQualify = False\n+                , envMod = mod\n+                }\n+            pkgId\n+        | mod <- NM.toList $ LF.packageModules pkg\n+        ]\n+\n+-- | Generate a module containing template/generic instances for all the contained templates.\n+generateInstanceModule ::\n+       Env -> LF.PackageId -> Maybe (NormalizedFilePath, String)\n+generateInstanceModule env externPkgId\n+    | not $ null instances =\n+        Just\n+            ( toNormalizedFilePath modFilePath\n+            , unlines $\n+              header ++\n+              nubSort imports ++\n+              map (showSDocForUser fakeDynFlags alwaysQualify . ppr) instances)\n+    | otherwise = Nothing\n+  where\n+    instances = templInstances\n+    templInstances = templateInstances env externPkgId\n+\n+    mod = envMod env\n+    modFilePath = (joinPath $ splitOn \".\" modName) ++ \"Instances\" ++ \".daml\"\n+    modName = T.unpack $ LF.moduleNameString $ LF.moduleName mod\n+    header =\n+        [ \"{-# LANGUAGE NoDamlSyntax #-}\"\n+        , \"{-# LANGUAGE EmptyCase #-}\"\n+        , \"module \" <> modName <> \"Instances\" <> \" where\"\n+        ]\n+    imports =\n+        [ \"import qualified \" <> modName\n+        , \"import qualified DA.Internal.Template\"\n+        , \"import qualified GHC.Types\"\n+        ]\n+\n+templateInstances :: Env -> LF.PackageId -> [HsDecl GhcPs]\n+templateInstances env externPkgId =\n+    [ generateTemplateInstance env dataTypeCon dataParams externPkgId\n+    | LF.DefDataType {..} <- NM.toList $ LF.moduleDataTypes mod"
  },
  {
    "id" : "fed10bb8-61e8-4058-876d-ec10ca2398cb",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "3c93d0bd-a47d-4d95-8372-f214d99704e2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    modFilePath = (joinPath $ splitOn \".\" modName) ++ qual ++ \"GenInstances\" ++ \".daml\"\r\n```",
        "createdAt" : "2019-11-05T14:46:41Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dd871b92-8d91-4246-9378-558c77621654",
        "parentId" : "3c93d0bd-a47d-4d95-8372-f214d99704e2",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you don’t call `moduleNameString` on the module name you already have a list of components so no need to split here.",
        "createdAt" : "2019-11-05T14:47:26Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : null,
    "diffHunk" : "@@ -22,87 +26,282 @@ import qualified Data.NameMap as NM\n import qualified Data.Text as T\n import Development.IDE.GHC.Util\n import Development.IDE.Types.Location\n+import \"ghc-lib-parser\" FastString\n import \"ghc-lib\" GHC\n import \"ghc-lib-parser\" Module\n import \"ghc-lib-parser\" Name\n-import \"ghc-lib-parser\" Outputable (ppr, showSDoc, showSDocForUser, alwaysQualify)\n+import \"ghc-lib-parser\" Outputable\n+    ( alwaysQualify\n+    , ppr\n+    , showSDocForUser\n+    )\n import \"ghc-lib-parser\" PrelNames\n import \"ghc-lib-parser\" RdrName\n+import SdkVersion\n import System.FilePath.Posix\n+import \"ghc-lib-parser\" TcEvidence (HsWrapper(..))\n import \"ghc-lib-parser\" TysPrim\n import \"ghc-lib-parser\" TysWiredIn\n-import \"ghc-lib-parser\" FastString\n-import \"ghc-lib-parser\" Bag\n-import \"ghc-lib-parser\" TcEvidence (HsWrapper(..))\n-import Control.Monad\n-import SdkVersion\n \n--- | Generate a module containing generic instances for data types that don't have them already.\n-generateGenInstancesModule :: String -> (String, ParsedSource) -> String\n-generateGenInstancesModule qual (pkg, L _l src) =\n-    unlines $ header ++ map (showSDoc fakeDynFlags . ppr) genericInstances\n-  where\n-    modName =\n-        (moduleNameString $\n-         unLoc $ fromMaybe (error \"missing module name\") $ hsmodName src) ++\n-        qual\n-    header =\n-        [ \"{-# LANGUAGE EmptyCase #-}\"\n-        , \"{-# LANGUAGE NoDamlSyntax #-}\"\n-        , \"module \" <> modName <> \"Instances\" <> \" where\"\n-        , \"import \" <> modName\n-        , \"import DA.Generics\"\n-        ]\n-    genericInstances =\n-        [ generateGenericInstanceFor\n-            (nameOccName genClassName)\n-            tcdLName\n-            pkg\n-            (fromMaybe (error \"Missing module name\") $ hsmodName src)\n-            tcdTyVars\n-            tcdDataDefn\n-        | L _ (TyClD _x DataDecl {..}) <- hsmodDecls src\n-        , not $ hasGenDerivation tcdDataDefn\n-        ]\n-    hasGenDerivation :: HsDataDefn GhcPs -> Bool\n-    hasGenDerivation HsDataDefn {..} =\n-        or [ name `elem` map nameOccName genericClassNames\n-            | d <- unLoc dd_derivs\n-            , (HsIB _ (L _ (HsTyVar _ _ (L _ (Unqual name))))) <-\n-                  unLoc $ deriv_clause_tys $ unLoc d\n-            ]\n-    hasGenDerivation XHsDataDefn{} = False\n+data Env = Env\n+    { envGetUnitId :: LF.PackageRef -> UnitId\n+    , envQualify :: Bool\n+    , envMod :: LF.Module\n+    }\n+\n+newtype DiffSdkVers = DiffSdkVers Bool\n \n -- | Generate non-consuming choices to upgrade all templates defined in the module.\n-generateUpgradeModule :: [String] -> String -> String -> String -> String\n-generateUpgradeModule templateNames modName qualA qualB =\n+generateUpgradeModule :: DiffSdkVers -> [String] -> String -> String -> String -> String\n+generateUpgradeModule (DiffSdkVers diffSdks) templateNames modName qualA qualB =\n     unlines $ header ++ concatMap upgradeTemplates templateNames\n   where\n-    header =\n+    header\n+      | diffSdks = header0 ++ header1 ++ header2\n+      | otherwise = header0 ++ header2\n+    header0 =\n         [ \"daml 1.2\"\n         , \"module \" <> modName <> \" where\"\n         , \"import \" <> modName <> qualA <> \" qualified as A\"\n         , \"import \" <> modName <> qualB <> \" qualified as B\"\n-        , \"import \" <> modName <> \"AInstances()\"\n-        , \"import \" <> modName <> \"BInstances()\"\n-        , \"import DA.Upgrade\"\n+        ]\n+    header1 =\n+        [ \"import \" <> modName <> \"Instances()\"\n+        , \"import \" <> modName <> \"Instances()\"\n+        ]\n+    header2 = [\n+        \"import DA.Upgrade\"\n         ]\n \n upgradeTemplates :: String -> [String]\n upgradeTemplates n =\n     [ \"template instance \" <> n <> \"Upgrade = Upgrade A.\" <> n <> \" B.\" <> n\n     , \"template instance \" <> n <> \"Rollback = Rollback A.\" <> n <> \" B.\" <> n\n-    , \"instance Convertible A.\" <> n <> \" B.\" <> n\n-    , \"instance Convertible B.\" <> n <> \" A.\" <> n\n+    , \"instance Convertible A.\" <> n <> \" B.\" <> n <> \" where\"\n+    , \"    convert A.\" <> n <> \"{..} = B.\" <> n <> \" {..}\"\n+    , \"instance Convertible B.\" <> n <> \" A.\" <> n <> \" where\"\n+    , \"    convert B.\" <> n <> \"{..} = A.\" <> n <> \" {..}\"\n     ]\n \n+generateGenInstancesPkgFromLf ::\n+       (LF.PackageRef -> UnitId)\n+    -> LF.PackageId\n+    -> LF.Package\n+    -> String\n+    -> [(NormalizedFilePath, String)]\n+generateGenInstancesPkgFromLf getUnitId pkgId pkg qual =\n+    catMaybes\n+        [ generateGenInstanceModule\n+            Env\n+                { envGetUnitId = getUnitId\n+                , envQualify = False\n+                , envMod = mod\n+                }\n+            pkgId\n+            qual\n+        | mod <- NM.toList $ LF.packageModules pkg\n+        ]\n+\n+generateGenInstanceModule ::\n+       Env -> LF.PackageId -> String -> Maybe (NormalizedFilePath, String)\n+generateGenInstanceModule env externPkgId qual\n+    | not $ null instances =\n+        Just\n+            ( toNormalizedFilePath modFilePath\n+            , unlines $\n+              header ++\n+              nubSort imports ++\n+              map (showSDocForUser fakeDynFlags alwaysQualify . ppr) genImports ++\n+              [ replace (modName <> \".\") (modNameQual <> \".\") $\n+                 unlines $\n+                 map\n+                     (showSDocForUser fakeDynFlags alwaysQualify . ppr)\n+                     instances\n+              ])\n+    | otherwise = Nothing\n+  where\n+    instances = genInstances\n+    genImportsAndInstances = genericInstances env externPkgId\n+    genImports = [idecl{ideclQualified = True} | idecl <- fst genImportsAndInstances]\n+    genInstances = snd genImportsAndInstances\n+\n+    mod = envMod env\n+    modFilePath = (foldr1 (</>) $ splitOn \".\" modName) ++ qual ++ \"GenInstances\" ++ \".daml\""
  },
  {
    "id" : "e67935da-fedb-4e50-8e26-676baff7cad5",
    "prId" : 3342,
    "comments" : [
      {
        "id" : "02b7827a-b2d9-4abb-a471-858d45fa4d05",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same question as below: Why can’t we always use the first case?",
        "createdAt" : "2019-11-05T15:03:37Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3aefb746-ffdd-4e13-8b97-1c825fe4e698",
        "parentId" : "02b7827a-b2d9-4abb-a471-858d45fa4d05",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Same answer, because if you're compiling with the same sdk the instances modules will not be there. I'll add a comment.",
        "createdAt" : "2019-11-05T16:35:20Z",
        "updatedAt" : "2019-11-05T18:46:21Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "272818c92a48fbaf19707d743912199fcaf709f7",
    "line" : 100,
    "diffHunk" : "@@ -22,87 +26,282 @@ import qualified Data.NameMap as NM\n import qualified Data.Text as T\n import Development.IDE.GHC.Util\n import Development.IDE.Types.Location\n+import \"ghc-lib-parser\" FastString\n import \"ghc-lib\" GHC\n import \"ghc-lib-parser\" Module\n import \"ghc-lib-parser\" Name\n-import \"ghc-lib-parser\" Outputable (ppr, showSDoc, showSDocForUser, alwaysQualify)\n+import \"ghc-lib-parser\" Outputable\n+    ( alwaysQualify\n+    , ppr\n+    , showSDocForUser\n+    )\n import \"ghc-lib-parser\" PrelNames\n import \"ghc-lib-parser\" RdrName\n+import SdkVersion\n import System.FilePath.Posix\n+import \"ghc-lib-parser\" TcEvidence (HsWrapper(..))\n import \"ghc-lib-parser\" TysPrim\n import \"ghc-lib-parser\" TysWiredIn\n-import \"ghc-lib-parser\" FastString\n-import \"ghc-lib-parser\" Bag\n-import \"ghc-lib-parser\" TcEvidence (HsWrapper(..))\n-import Control.Monad\n-import SdkVersion\n \n--- | Generate a module containing generic instances for data types that don't have them already.\n-generateGenInstancesModule :: String -> (String, ParsedSource) -> String\n-generateGenInstancesModule qual (pkg, L _l src) =\n-    unlines $ header ++ map (showSDoc fakeDynFlags . ppr) genericInstances\n-  where\n-    modName =\n-        (moduleNameString $\n-         unLoc $ fromMaybe (error \"missing module name\") $ hsmodName src) ++\n-        qual\n-    header =\n-        [ \"{-# LANGUAGE EmptyCase #-}\"\n-        , \"{-# LANGUAGE NoDamlSyntax #-}\"\n-        , \"module \" <> modName <> \"Instances\" <> \" where\"\n-        , \"import \" <> modName\n-        , \"import DA.Generics\"\n-        ]\n-    genericInstances =\n-        [ generateGenericInstanceFor\n-            (nameOccName genClassName)\n-            tcdLName\n-            pkg\n-            (fromMaybe (error \"Missing module name\") $ hsmodName src)\n-            tcdTyVars\n-            tcdDataDefn\n-        | L _ (TyClD _x DataDecl {..}) <- hsmodDecls src\n-        , not $ hasGenDerivation tcdDataDefn\n-        ]\n-    hasGenDerivation :: HsDataDefn GhcPs -> Bool\n-    hasGenDerivation HsDataDefn {..} =\n-        or [ name `elem` map nameOccName genericClassNames\n-            | d <- unLoc dd_derivs\n-            , (HsIB _ (L _ (HsTyVar _ _ (L _ (Unqual name))))) <-\n-                  unLoc $ deriv_clause_tys $ unLoc d\n-            ]\n-    hasGenDerivation XHsDataDefn{} = False\n+data Env = Env\n+    { envGetUnitId :: LF.PackageRef -> UnitId\n+    , envQualify :: Bool\n+    , envMod :: LF.Module\n+    }\n+\n+newtype DiffSdkVers = DiffSdkVers Bool\n \n -- | Generate non-consuming choices to upgrade all templates defined in the module.\n-generateUpgradeModule :: [String] -> String -> String -> String -> String\n-generateUpgradeModule templateNames modName qualA qualB =\n+generateUpgradeModule :: DiffSdkVers -> [String] -> String -> String -> String -> String\n+generateUpgradeModule (DiffSdkVers diffSdks) templateNames modName qualA qualB =\n     unlines $ header ++ concatMap upgradeTemplates templateNames\n   where\n-    header =\n+    header\n+      | diffSdks = header0 ++ header1 ++ header2"
  },
  {
    "id" : "228d60dc-cb62-4dd2-90b3-89dcb94c3e09",
    "prId" : 2884,
    "comments" : [
      {
        "id" : "7d88ea60-cef3-4d4f-911d-41ac82141ea9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We really need better tests to catch this!",
        "createdAt" : "2019-09-11T13:15:10Z",
        "updatedAt" : "2019-09-11T13:15:20Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3e6f5451fffaf6994c322999fe6012b0e159c9df",
    "line" : 6,
    "diffHunk" : "@@ -92,9 +92,10 @@ generateUpgradeModule templateNames modName qualA qualB =\n \n upgradeTemplates :: String -> [String]\n upgradeTemplates n =\n-    [ \"type \" <> n <> \"Upgrade = Upgrade A.\" <> n <> \" B.\" <> n\n-    , \"type \" <> n <> \"Rollback = Rollback A.\" <> n <> \" B.\" <> n\n+    [ \"template instance \" <> n <> \"Upgrade = Upgrade A.\" <> n <> \" B.\" <> n"
  },
  {
    "id" : "a34ad764-9d34-4e91-a3a7-f25563f4bd94",
    "prId" : 2228,
    "comments" : [
      {
        "id" : "288bf7b8-18b9-4683-a45c-c985f590eba4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'd mention that some of them are converted to types built into DAML-LF.",
        "createdAt" : "2019-07-19T17:00:06Z",
        "updatedAt" : "2019-07-19T17:02:02Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c9709b97d4d4b0beadf6ec27f63d90b1f4c16595",
    "line" : 35,
    "diffHunk" : "@@ -116,22 +116,36 @@ generateSrcPkgFromLf ::\n     -> [(NormalizedFilePath, String)]\n generateSrcPkgFromLf thisPkgId pkgMap pkg = do\n     mod <- NM.toList $ LF.packageModules pkg\n+    guard $ (LF.unModuleName $ LF.moduleName mod) /= [\"GHC\", \"Prim\"]\n     let fp =\n             toNormalizedFilePath $\n             (joinPath $ map T.unpack $ LF.unModuleName $ LF.moduleName mod) <.>\n             \".daml\"\n     pure\n         ( fp\n-        , unlines header ++\n+        , unlines (header mod) ++\n           (showSDocForUser fakeDynFlags alwaysQualify $\n            ppr $ generateSrcFromLf (DontQualify False) thisPkgId pkgMap mod) ++\n           unlines (builtins mod))\n   where\n-    header =\n-        [ \"{-# LANGUAGE NoDamlSyntax #-}\"\n-        , \"{-# LANGUAGE NoImplicitPrelude #-}\"\n-        , \"{-# LANGUAGE TypeOperators #-}\"\n-        ]\n+    modName = LF.unModuleName . LF.moduleName\n+    header m = header0 ++ header1 m\n+    header0 =\n+        [\"{-# LANGUAGE NoDamlSyntax #-}\", \"{-# LANGUAGE NoImplicitPrelude #-}\"]\n+    header1 m\n+        | modName m == [\"DA\", \"Generics\"] =\n+            [\"\", \"{-# LANGUAGE TypeOperators #-}\"]\n+        | modName m == [\"GHC\", \"Types\"] = [\"\", \"{-# LANGUAGE MagicHash #-}\"]\n+        | otherwise = []\n+    --\n+    -- IMPORTANT\n+    -- =========\n+    --\n+    -- The following are datatypes that are not compiled to daml-lf, they will not show up in any"
  },
  {
    "id" : "ce7c9708-42c4-43a0-be2f-e1ea59518a9d",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "34c8c074-426b-41f1-b42d-7e1b45d6296f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "we should probably have a newtype for this `Bool`.",
        "createdAt" : "2019-07-19T04:35:05Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : null,
    "diffHunk" : "@@ -119,24 +119,48 @@ generateSrcPkgFromLf thisPkgId pkgMap pkg = do\n             toNormalizedFilePath $\n             (joinPath $ map T.unpack $ LF.unModuleName $ LF.moduleName mod) <.>\n             \".daml\"\n-    pure ( fp\n-         , unlines header ++\n-           (showSDocForUser fakeDynFlags alwaysQualify $\n-            ppr $ generateSrcFromLf thisPkgId pkgMap mod))\n+    pure\n+        ( fp\n+        , unlines header ++\n+          (showSDocForUser fakeDynFlags alwaysQualify $\n+           ppr $ generateSrcFromLf False thisPkgId pkgMap mod) ++\n+          unlines (builtins mod))\n   where\n-    header = [\"{-# LANGUAGE NoDamlSyntax #-}\", \"{-# LANGUAGE NoImplicitPrelude #-}\"]\n+    header =\n+        [ \"{-# LANGUAGE NoDamlSyntax #-}\"\n+        , \"{-# LANGUAGE NoImplicitPrelude #-}\"\n+        , \"{-# LANGUAGE TypeOperators #-}\"\n+        ]\n+    builtins m\n+        | LF.unModuleName (LF.moduleName m) == [\"DA\", \"Internal\", \"LF\"] =\n+            [ \"\"\n+            , \"data TextMap a = TextMap GHC.Types.Opaque\"\n+            , \"data Time = Time GHC.Types.Opaque\"\n+            , \"data Date = Date GHC.Types.Opaque\"\n+            , \"data ContractId a = ContractId GHC.Types.Opaque\"\n+            , \"data Update a = Update GHC.Types.Opaque\"\n+            , \"data Scenario a = Scenario GHC.Types.Opaque\"\n+            , \"data Party = Party GHC.Types.Opaque\"\n+            ]\n+        | LF.unModuleName (LF.moduleName m) == [\"DA\", \"Internal\", \"Template\"] =\n+            [ \"\"\n+            , \"class Template c where\"\n+            , \"   signatory :: c -> [DA.Internal.LF.Party]\"\n+            ]\n+        | otherwise = []\n \n -- | Extract all data defintions from a daml-lf module and generate a haskell source file from it.\n generateSrcFromLf ::\n-       LF.PackageId\n+       Bool"
  },
  {
    "id" : "118dfd2a-2be5-4015-a5d3-0ade59101eb1",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "670695ff-677d-4483-a3b6-fe68bdb2c122",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It might be helpful to factor this into a helper function to make it easy to see which fields of the import decl are different between different imports and to capture the pattern of filtering out the import on the module itself.",
        "createdAt" : "2019-07-19T04:41:09Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "84c2701e-ab4b-43bb-b648-abf2c25b222e",
        "parentId" : "670695ff-677d-4483-a3b6-fe68bdb2c122",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I agree.",
        "createdAt" : "2019-07-19T16:34:47Z",
        "updatedAt" : "2019-07-19T16:51:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : 315,
    "diffHunk" : "@@ -479,49 +516,106 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n         noLoc .\n         mkOrig (mkModule damlStdlibUnitId $ mkModuleName \"DA.Internal.Prelude\") .\n         mkOccName varName\n-    mkTyConType :: TyCon -> HsType GhcPs\n-    mkTyConType tyCon =\n-        let name = getName tyCon\n-         in HsTyVar NoExt NotPromoted . noLoc $\n-            mkOrig (nameModule name) (occName name)\n-    mkGhcPrimImport :: Bool -> String -> LImportDecl GhcPs\n-    mkGhcPrimImport qualified  modName =  noLoc $\n-           ImportDecl\n-               { ideclExt = NoExt\n-               , ideclSourceSrc = NoSourceText\n-               , ideclName = noLoc $ mkModuleName modName\n-               , ideclPkgQual =\n-                     Just $ StringLiteral NoSourceText $ mkFastString \"daml-prim\"\n-               , ideclSource = False\n-               , ideclSafe = False\n-               , ideclImplicit = False\n-               , ideclQualified = qualified\n-               , ideclAs = Nothing\n-               , ideclHiding = Nothing\n-               }\n-    imports =\n-        -- first, imports that we need in any case\n-        map (mkGhcPrimImport True) [\"GHC.Types\", \"GHC.Err\"] ++\n-        -- qualified imports from daml-prim\n-        map (mkGhcPrimImport False) [\"Data.String\"] ++\n-        -- unqualified importts from daml-prim\n+    mkTyConType = mkTyConType' dontQualify\n+    mkTyConTypeUnqual = mkTyConType' True\n+    mkTyConType' :: Bool -> TyCon -> HsType GhcPs\n+    mkTyConType' dontQualify tyCon\n+        | dontQualify = HsTyVar noExt NotPromoted . noLoc $ mkRdrUnqual (occName name)\n+        | otherwise =\n+            HsTyVar noExt NotPromoted . noLoc $\n+            mkRdrQual (moduleName $ nameModule name) (occName name)\n+      where\n+        name = getName tyCon\n+    imports = declImports ++ additionalImports\n+    additionalImports =\n+        [ noLoc $\n+        ImportDecl"
  },
  {
    "id" : "a1c81b27-5fcd-4289-9fc9-66b7e52afc23",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "07d96c91-0c3e-4522-adbe-aa649bfa44c5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think that is the same as `primUnitId` from `ghc-lib`?",
        "createdAt" : "2019-07-19T04:42:34Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "02fcc0e7-e00f-4f6e-b444-c7e2ed724043",
        "parentId" : "07d96c91-0c3e-4522-adbe-aa649bfa44c5",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "you're right, changed.",
        "createdAt" : "2019-07-19T09:38:04Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : null,
    "diffHunk" : "@@ -479,49 +516,106 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n         noLoc .\n         mkOrig (mkModule damlStdlibUnitId $ mkModuleName \"DA.Internal.Prelude\") .\n         mkOccName varName\n-    mkTyConType :: TyCon -> HsType GhcPs\n-    mkTyConType tyCon =\n-        let name = getName tyCon\n-         in HsTyVar NoExt NotPromoted . noLoc $\n-            mkOrig (nameModule name) (occName name)\n-    mkGhcPrimImport :: Bool -> String -> LImportDecl GhcPs\n-    mkGhcPrimImport qualified  modName =  noLoc $\n-           ImportDecl\n-               { ideclExt = NoExt\n-               , ideclSourceSrc = NoSourceText\n-               , ideclName = noLoc $ mkModuleName modName\n-               , ideclPkgQual =\n-                     Just $ StringLiteral NoSourceText $ mkFastString \"daml-prim\"\n-               , ideclSource = False\n-               , ideclSafe = False\n-               , ideclImplicit = False\n-               , ideclQualified = qualified\n-               , ideclAs = Nothing\n-               , ideclHiding = Nothing\n-               }\n-    imports =\n-        -- first, imports that we need in any case\n-        map (mkGhcPrimImport True) [\"GHC.Types\", \"GHC.Err\"] ++\n-        -- qualified imports from daml-prim\n-        map (mkGhcPrimImport False) [\"Data.String\"] ++\n-        -- unqualified importts from daml-prim\n+    mkTyConType = mkTyConType' dontQualify\n+    mkTyConTypeUnqual = mkTyConType' True\n+    mkTyConType' :: Bool -> TyCon -> HsType GhcPs\n+    mkTyConType' dontQualify tyCon\n+        | dontQualify = HsTyVar noExt NotPromoted . noLoc $ mkRdrUnqual (occName name)\n+        | otherwise =\n+            HsTyVar noExt NotPromoted . noLoc $\n+            mkRdrQual (moduleName $ nameModule name) (occName name)\n+      where\n+        name = getName tyCon\n+    imports = declImports ++ additionalImports\n+    additionalImports =\n+        [ noLoc $\n+        ImportDecl\n+            { ideclExt = noExt\n+            , ideclSourceSrc = NoSourceText\n+            , ideclName = noLoc $ mkModuleName \"GHC.Err\"\n+            , ideclPkgQual = Nothing\n+            , ideclSource = False\n+            , ideclSafe = False\n+            , ideclImplicit = False\n+            , ideclQualified = True\n+            , ideclAs = Nothing\n+            , ideclHiding = Nothing\n+            } :: LImportDecl GhcPs\n+        | LF.unModuleName (LF.moduleName m) /= [\"GHC\", \"Err\"]\n+        ]\n+        ++\n         [ noLoc $\n         ImportDecl\n-            { ideclExt = NoExt\n+            { ideclExt = noExt\n+            , ideclSourceSrc = NoSourceText\n+            , ideclName = noLoc $ mkModuleName \"GHC.CString\"\n+            , ideclPkgQual = Nothing\n+            , ideclSource = False\n+            , ideclSafe = False\n+            , ideclImplicit = False\n+            , ideclQualified = False\n+            , ideclAs = Nothing\n+            , ideclHiding = Nothing\n+            } :: LImportDecl GhcPs\n+        | LF.unModuleName (LF.moduleName m) /= [\"GHC\", \"CString\"]\n+        ]\n+    -- imports needed by the module declarations\n+    declImports\n+     =\n+        [ noLoc $\n+        ImportDecl\n+            { ideclExt = noExt\n             , ideclSourceSrc = NoSourceText\n             , ideclName =\n                   noLoc $ mkModuleName $ T.unpack $ LF.moduleNameString modRef\n-            , ideclPkgQual =\n-                  Just $ StringLiteral NoSourceText $ unitIdFS $ getUnitId pkgRef\n+            , ideclPkgQual = Nothing\n             , ideclSource = False\n             , ideclSafe = False\n             , ideclImplicit = False\n             , ideclQualified = True\n             , ideclAs = Nothing\n             , ideclHiding = Nothing\n             } :: LImportDecl GhcPs\n-        | (pkgRef@(LF.PRImport pkgId), modRef) <-\n-              nubSort $ toListOf moduleModuleRef m\n-        , pkgId /= thisPkgId\n+        | (_unitId, modRef) <- modRefs\n+        , modRef /= LF.moduleName m\n+        , LF.unModuleName modRef /= [\"GHC\", \"Prim\"]\n         ]\n-        -- imports needed by the module declarations\n+    modRefs =\n+        nubSort $\n+        [ (getUnitId pkg, modRef)\n+        | (pkg, modRef) <- toListOf moduleModuleRef m\n+        ] ++\n+        (map builtinToModuleRef $\n+         concat $ do\n+             dataTy <- NM.toList $ LF.moduleDataTypes m\n+             case LF.dataCons dataTy of\n+                 LF.DataRecord fs -> map (toListOf builtinType . snd) fs\n+                 LF.DataVariant vs -> map (toListOf builtinType . snd) vs\n+                 LF.DataEnum _es -> pure [])\n+    builtinToModuleRef = \\case\n+            LF.BTInt64 -> (damlPrimUnitId, translateModName intTyCon)\n+            LF.BTDecimal -> (damlPrimUnitId, LF.ModuleName [\"GHC\", \"Types\"])\n+            LF.BTText -> (damlPrimUnitId, LF.ModuleName [\"GHC\", \"Types\"])\n+            LF.BTTimestamp -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTDate -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTParty -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTUnit -> (damlPrimUnitId, translateModName unitTyCon)\n+            LF.BTBool -> (damlPrimUnitId, translateModName boolTyCon)\n+            LF.BTList -> (damlPrimUnitId, translateModName listTyCon)\n+            LF.BTUpdate -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTScenario -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTContractId -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTOptional -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"Prelude\"])\n+            LF.BTMap -> (stdlibUnitId, LF.ModuleName [\"DA\", \"Internal\", \"LF\"])\n+            LF.BTArrow -> (damlPrimUnitId, translateModName funTyCon)\n+\n+    damlPrimUnitId = stringToUnitId \"daml-prim\""
  },
  {
    "id" : "c2f43a2d-e6f8-4e45-a1b6-ec11622d2b34",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "47676246-5c62-47d0-bc98-83cef8c35b41",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why can’t we use qualified imports when generating the source for a package?",
        "createdAt" : "2019-07-19T04:49:42Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "395928fb-827f-4ecd-aad9-d0541469d2b1",
        "parentId" : "47676246-5c62-47d0-bc98-83cef8c35b41",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Right now it works with unqualified imports for the module we're generating instances for. But we might want to change this in the future.",
        "createdAt" : "2019-07-19T09:48:30Z",
        "updatedAt" : "2019-07-19T09:48:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : null,
    "diffHunk" : "@@ -119,24 +119,48 @@ generateSrcPkgFromLf thisPkgId pkgMap pkg = do\n             toNormalizedFilePath $\n             (joinPath $ map T.unpack $ LF.unModuleName $ LF.moduleName mod) <.>\n             \".daml\"\n-    pure ( fp\n-         , unlines header ++\n-           (showSDocForUser fakeDynFlags alwaysQualify $\n-            ppr $ generateSrcFromLf thisPkgId pkgMap mod))\n+    pure\n+        ( fp\n+        , unlines header ++\n+          (showSDocForUser fakeDynFlags alwaysQualify $\n+           ppr $ generateSrcFromLf False thisPkgId pkgMap mod) ++"
  },
  {
    "id" : "ec4b422a-d505-4ecd-bc64-7bea0247cfdf",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "dda764d1-b93b-4d41-8445-39001e48b663",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Double negations like `DontQualify False` make my brain explode. :)\r\nWe should consider renaming this to `Qualify` and negate all the payloads in the future.",
        "createdAt" : "2019-07-19T16:24:07Z",
        "updatedAt" : "2019-07-19T16:51:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : 47,
    "diffHunk" : "@@ -119,24 +120,50 @@ generateSrcPkgFromLf thisPkgId pkgMap pkg = do\n             toNormalizedFilePath $\n             (joinPath $ map T.unpack $ LF.unModuleName $ LF.moduleName mod) <.>\n             \".daml\"\n-    pure ( fp\n-         , unlines header ++\n-           (showSDocForUser fakeDynFlags alwaysQualify $\n-            ppr $ generateSrcFromLf thisPkgId pkgMap mod))\n+    pure\n+        ( fp\n+        , unlines header ++\n+          (showSDocForUser fakeDynFlags alwaysQualify $\n+           ppr $ generateSrcFromLf (DontQualify False) thisPkgId pkgMap mod) ++\n+          unlines (builtins mod))\n   where\n-    header = [\"{-# LANGUAGE NoDamlSyntax #-}\", \"{-# LANGUAGE NoImplicitPrelude #-}\"]\n+    header =\n+        [ \"{-# LANGUAGE NoDamlSyntax #-}\"\n+        , \"{-# LANGUAGE NoImplicitPrelude #-}\"\n+        , \"{-# LANGUAGE TypeOperators #-}\"\n+        ]\n+    builtins m\n+        | LF.unModuleName (LF.moduleName m) == [\"DA\", \"Internal\", \"LF\"] =\n+            [ \"\"\n+            , \"data TextMap a = TextMap GHC.Types.Opaque\"\n+            , \"data Time = Time GHC.Types.Opaque\"\n+            , \"data Date = Date GHC.Types.Opaque\"\n+            , \"data ContractId a = ContractId GHC.Types.Opaque\"\n+            , \"data Update a = Update GHC.Types.Opaque\"\n+            , \"data Scenario a = Scenario GHC.Types.Opaque\"\n+            , \"data Party = Party GHC.Types.Opaque\"\n+            ]\n+        | LF.unModuleName (LF.moduleName m) == [\"DA\", \"Internal\", \"Template\"] =\n+            [ \"\"\n+            , \"class Template c where\"\n+            , \"   signatory :: c -> [DA.Internal.LF.Party]\"\n+            ]\n+        | otherwise = []\n+\n+newtype DontQualify = DontQualify Bool"
  },
  {
    "id" : "5a8581ef-9f9f-4e09-b3f1-d8ffe0f42c9e",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "66dfcbf2-a70f-402e-8ed0-4a93787c631e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we have an idea how this plays out if we add another builtin type to DAML-LF at some point in the future?",
        "createdAt" : "2019-07-19T16:25:04Z",
        "updatedAt" : "2019-07-19T16:51:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "246dc233-7146-42ba-aaf4-0b02cd1f8cb5",
        "parentId" : "66dfcbf2-a70f-402e-8ed0-4a93787c631e",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Adding should be unproblematic, you would just add it here.",
        "createdAt" : "2019-07-22T09:35:36Z",
        "updatedAt" : "2019-07-22T09:35:37Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : 38,
    "diffHunk" : "@@ -119,24 +120,50 @@ generateSrcPkgFromLf thisPkgId pkgMap pkg = do\n             toNormalizedFilePath $\n             (joinPath $ map T.unpack $ LF.unModuleName $ LF.moduleName mod) <.>\n             \".daml\"\n-    pure ( fp\n-         , unlines header ++\n-           (showSDocForUser fakeDynFlags alwaysQualify $\n-            ppr $ generateSrcFromLf thisPkgId pkgMap mod))\n+    pure\n+        ( fp\n+        , unlines header ++\n+          (showSDocForUser fakeDynFlags alwaysQualify $\n+           ppr $ generateSrcFromLf (DontQualify False) thisPkgId pkgMap mod) ++\n+          unlines (builtins mod))\n   where\n-    header = [\"{-# LANGUAGE NoDamlSyntax #-}\", \"{-# LANGUAGE NoImplicitPrelude #-}\"]\n+    header =\n+        [ \"{-# LANGUAGE NoDamlSyntax #-}\"\n+        , \"{-# LANGUAGE NoImplicitPrelude #-}\"\n+        , \"{-# LANGUAGE TypeOperators #-}\"\n+        ]\n+    builtins m\n+        | LF.unModuleName (LF.moduleName m) == [\"DA\", \"Internal\", \"LF\"] =\n+            [ \"\"\n+            , \"data TextMap a = TextMap GHC.Types.Opaque\"\n+            , \"data Time = Time GHC.Types.Opaque\"\n+            , \"data Date = Date GHC.Types.Opaque\"\n+            , \"data ContractId a = ContractId GHC.Types.Opaque\"\n+            , \"data Update a = Update GHC.Types.Opaque\"\n+            , \"data Scenario a = Scenario GHC.Types.Opaque\"\n+            , \"data Party = Party GHC.Types.Opaque\""
  },
  {
    "id" : "a23a869e-2e90-4275-9069-75b533fa7a19",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "c34e49f1-d1ff-4868-98a5-3e3ada0ef93f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's only deal with serializable types. They can be spotted using https://github.com/digital-asset/daml/blob/98a8135cb58b76ad7203cba723c3484077099efe/compiler/daml-lf-ast/src/DA/Daml/LF/Ast/Base.hs#L613",
        "createdAt" : "2019-07-19T16:34:00Z",
        "updatedAt" : "2019-07-19T16:51:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "39517252-6629-450d-b4f1-51a44f7461f6",
        "parentId" : "c34e49f1-d1ff-4868-98a5-3e3ada0ef93f",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2019-07-22T10:00:52Z",
        "updatedAt" : "2019-07-22T10:00:52Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : 80,
    "diffHunk" : "@@ -178,6 +205,7 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n     decls =\n         concat $ do\n             LF.DefDataType {..} <- NM.toList $ LF.moduleDataTypes m\n+            guard $ not $ isTypeClass dataCons"
  },
  {
    "id" : "3918f23a-c180-43fe-a38c-ccfc99831c7e",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "4701643d-d4a1-4762-8473-92dcc9049cf4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Let's use `dataConsType` here:\r\nhttps://github.com/digital-asset/daml/blob/b641ba495b34c9b03fe14c916ee55318e2c2d800/compiler/daml-lf-ast/src/DA/Daml/LF/Ast/Optics.hs#L94",
        "createdAt" : "2019-07-19T16:48:40Z",
        "updatedAt" : "2019-07-19T16:51:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6f050327-8d95-4989-a9de-cd13abd203c8",
        "parentId" : "4701643d-d4a1-4762-8473-92dcc9049cf4",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2019-07-22T09:56:25Z",
        "updatedAt" : "2019-07-22T09:56:25Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : 381,
    "diffHunk" : "@@ -456,72 +498,128 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n             LF.BTTimestamp -> mkLfInternalType \"Time\"\n             LF.BTDate -> mkLfInternalType \"Date\"\n             LF.BTParty -> mkLfInternalType \"Party\"\n-            LF.BTUnit -> mkTyConType unitTyCon\n+            LF.BTUnit -> mkTyConTypeUnqual unitTyCon\n             LF.BTBool -> mkTyConType boolTyCon\n-            LF.BTList -> mkTyConType listTyCon\n+            LF.BTList -> mkTyConTypeUnqual listTyCon\n             LF.BTUpdate -> mkLfInternalType \"Update\"\n             LF.BTScenario -> mkLfInternalType \"Scenario\"\n             LF.BTContractId -> mkLfInternalType \"ContractId\"\n             LF.BTOptional -> mkLfInternalPrelude \"Optional\"\n             LF.BTMap -> mkLfInternalType \"TextMap\"\n-            LF.BTArrow -> mkTyConType funTyCon\n+            LF.BTArrow -> mkTyConTypeUnqual funTyCon\n     mkGhcType =\n-        HsTyVar NoExt NotPromoted .\n+        HsTyVar noExt NotPromoted .\n         noLoc . mkOrig gHC_TYPES . mkOccName varName\n     damlStdlibUnitId = stringToUnitId \"daml-stdlib\"\n     mkLfInternalType =\n-        HsTyVar NoExt NotPromoted .\n+        HsTyVar noExt NotPromoted .\n         noLoc .\n         mkOrig (mkModule damlStdlibUnitId $ mkModuleName \"DA.Internal.LF\") .\n         mkOccName varName\n     mkLfInternalPrelude =\n-        HsTyVar NoExt NotPromoted .\n+        HsTyVar noExt NotPromoted .\n         noLoc .\n         mkOrig (mkModule damlStdlibUnitId $ mkModuleName \"DA.Internal.Prelude\") .\n         mkOccName varName\n-    mkTyConType :: TyCon -> HsType GhcPs\n-    mkTyConType tyCon =\n-        let name = getName tyCon\n-         in HsTyVar NoExt NotPromoted . noLoc $\n-            mkOrig (nameModule name) (occName name)\n-    mkGhcPrimImport :: Bool -> String -> LImportDecl GhcPs\n-    mkGhcPrimImport qualified  modName =  noLoc $\n-           ImportDecl\n-               { ideclExt = NoExt\n-               , ideclSourceSrc = NoSourceText\n-               , ideclName = noLoc $ mkModuleName modName\n-               , ideclPkgQual =\n-                     Just $ StringLiteral NoSourceText $ mkFastString \"daml-prim\"\n-               , ideclSource = False\n-               , ideclSafe = False\n-               , ideclImplicit = False\n-               , ideclQualified = qualified\n-               , ideclAs = Nothing\n-               , ideclHiding = Nothing\n-               }\n-    imports =\n-        -- first, imports that we need in any case\n-        map (mkGhcPrimImport True) [\"GHC.Types\", \"GHC.Err\"] ++\n-        -- qualified imports from daml-prim\n-        map (mkGhcPrimImport False) [\"Data.String\"] ++\n-        -- unqualified importts from daml-prim\n+    mkTyConType = mkTyConType' dontQualify\n+    mkTyConTypeUnqual = mkTyConType' True\n+    mkTyConType' :: Bool -> TyCon -> HsType GhcPs\n+    mkTyConType' dontQualify tyCon\n+        | dontQualify = HsTyVar noExt NotPromoted . noLoc $ mkRdrUnqual (occName name)\n+        | otherwise =\n+            HsTyVar noExt NotPromoted . noLoc $\n+            mkRdrQual (moduleName $ nameModule name) (occName name)\n+      where\n+        name = getName tyCon\n+    imports = declImports ++ additionalImports\n+    additionalImports =\n+        [ noLoc $\n+        ImportDecl\n+            { ideclExt = noExt\n+            , ideclSourceSrc = NoSourceText\n+            , ideclName = noLoc $ mkModuleName \"GHC.Err\"\n+            , ideclPkgQual = Nothing\n+            , ideclSource = False\n+            , ideclSafe = False\n+            , ideclImplicit = False\n+            , ideclQualified = True\n+            , ideclAs = Nothing\n+            , ideclHiding = Nothing\n+            } :: LImportDecl GhcPs\n+        | LF.unModuleName (LF.moduleName m) /= [\"GHC\", \"Err\"]\n+        ]\n+        ++\n         [ noLoc $\n         ImportDecl\n-            { ideclExt = NoExt\n+            { ideclExt = noExt\n+            , ideclSourceSrc = NoSourceText\n+            , ideclName = noLoc $ mkModuleName \"GHC.CString\"\n+            , ideclPkgQual = Nothing\n+            , ideclSource = False\n+            , ideclSafe = False\n+            , ideclImplicit = False\n+            , ideclQualified = False\n+            , ideclAs = Nothing\n+            , ideclHiding = Nothing\n+            } :: LImportDecl GhcPs\n+        | LF.unModuleName (LF.moduleName m) /= [\"GHC\", \"CString\"]\n+        ]\n+    -- imports needed by the module declarations\n+    declImports\n+     =\n+        [ noLoc $\n+        ImportDecl\n+            { ideclExt = noExt\n             , ideclSourceSrc = NoSourceText\n             , ideclName =\n                   noLoc $ mkModuleName $ T.unpack $ LF.moduleNameString modRef\n-            , ideclPkgQual =\n-                  Just $ StringLiteral NoSourceText $ unitIdFS $ getUnitId pkgRef\n+            , ideclPkgQual = Nothing\n             , ideclSource = False\n             , ideclSafe = False\n             , ideclImplicit = False\n             , ideclQualified = True\n             , ideclAs = Nothing\n             , ideclHiding = Nothing\n             } :: LImportDecl GhcPs\n-        | (pkgRef@(LF.PRImport pkgId), modRef) <-\n-              nubSort $ toListOf moduleModuleRef m\n-        , pkgId /= thisPkgId\n+        | (_unitId, modRef) <- modRefs\n+        , modRef /= LF.moduleName m\n+        , LF.unModuleName modRef /= [\"GHC\", \"Prim\"]\n         ]\n-        -- imports needed by the module declarations\n+    modRefs =\n+        nubSort $\n+        [ (getUnitId pkg, modRef)\n+        | (pkg, modRef) <- toListOf moduleModuleRef m\n+        ] ++\n+        (map builtinToModuleRef $\n+         concat $ do\n+             dataTy <- NM.toList $ LF.moduleDataTypes m\n+             case LF.dataCons dataTy of"
  },
  {
    "id" : "f7481bfd-5870-42ed-80e8-a2ceaf5d0de5",
    "prId" : 2222,
    "comments" : [
      {
        "id" : "c6d7749c-1109-4f7f-b1a8-3d392ba50f68",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```haskell\r\nmodRef `notElem` [LF.moduleName m, LF.ModuleName [\"GHC\", \"Prim\"]]\r\n```",
        "createdAt" : "2019-07-19T16:50:40Z",
        "updatedAt" : "2019-07-19T16:51:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "23b8632e-d2b1-41ec-aef7-2c0e59bb5b3f",
        "parentId" : "c6d7749c-1109-4f7f-b1a8-3d392ba50f68",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2019-07-22T09:46:26Z",
        "updatedAt" : "2019-07-22T09:46:41Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0ef5f6898797fc761099139830f38d6ac6b6952e",
    "line" : 369,
    "diffHunk" : "@@ -456,72 +498,128 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n             LF.BTTimestamp -> mkLfInternalType \"Time\"\n             LF.BTDate -> mkLfInternalType \"Date\"\n             LF.BTParty -> mkLfInternalType \"Party\"\n-            LF.BTUnit -> mkTyConType unitTyCon\n+            LF.BTUnit -> mkTyConTypeUnqual unitTyCon\n             LF.BTBool -> mkTyConType boolTyCon\n-            LF.BTList -> mkTyConType listTyCon\n+            LF.BTList -> mkTyConTypeUnqual listTyCon\n             LF.BTUpdate -> mkLfInternalType \"Update\"\n             LF.BTScenario -> mkLfInternalType \"Scenario\"\n             LF.BTContractId -> mkLfInternalType \"ContractId\"\n             LF.BTOptional -> mkLfInternalPrelude \"Optional\"\n             LF.BTMap -> mkLfInternalType \"TextMap\"\n-            LF.BTArrow -> mkTyConType funTyCon\n+            LF.BTArrow -> mkTyConTypeUnqual funTyCon\n     mkGhcType =\n-        HsTyVar NoExt NotPromoted .\n+        HsTyVar noExt NotPromoted .\n         noLoc . mkOrig gHC_TYPES . mkOccName varName\n     damlStdlibUnitId = stringToUnitId \"daml-stdlib\"\n     mkLfInternalType =\n-        HsTyVar NoExt NotPromoted .\n+        HsTyVar noExt NotPromoted .\n         noLoc .\n         mkOrig (mkModule damlStdlibUnitId $ mkModuleName \"DA.Internal.LF\") .\n         mkOccName varName\n     mkLfInternalPrelude =\n-        HsTyVar NoExt NotPromoted .\n+        HsTyVar noExt NotPromoted .\n         noLoc .\n         mkOrig (mkModule damlStdlibUnitId $ mkModuleName \"DA.Internal.Prelude\") .\n         mkOccName varName\n-    mkTyConType :: TyCon -> HsType GhcPs\n-    mkTyConType tyCon =\n-        let name = getName tyCon\n-         in HsTyVar NoExt NotPromoted . noLoc $\n-            mkOrig (nameModule name) (occName name)\n-    mkGhcPrimImport :: Bool -> String -> LImportDecl GhcPs\n-    mkGhcPrimImport qualified  modName =  noLoc $\n-           ImportDecl\n-               { ideclExt = NoExt\n-               , ideclSourceSrc = NoSourceText\n-               , ideclName = noLoc $ mkModuleName modName\n-               , ideclPkgQual =\n-                     Just $ StringLiteral NoSourceText $ mkFastString \"daml-prim\"\n-               , ideclSource = False\n-               , ideclSafe = False\n-               , ideclImplicit = False\n-               , ideclQualified = qualified\n-               , ideclAs = Nothing\n-               , ideclHiding = Nothing\n-               }\n-    imports =\n-        -- first, imports that we need in any case\n-        map (mkGhcPrimImport True) [\"GHC.Types\", \"GHC.Err\"] ++\n-        -- qualified imports from daml-prim\n-        map (mkGhcPrimImport False) [\"Data.String\"] ++\n-        -- unqualified importts from daml-prim\n+    mkTyConType = mkTyConType' dontQualify\n+    mkTyConTypeUnqual = mkTyConType' True\n+    mkTyConType' :: Bool -> TyCon -> HsType GhcPs\n+    mkTyConType' dontQualify tyCon\n+        | dontQualify = HsTyVar noExt NotPromoted . noLoc $ mkRdrUnqual (occName name)\n+        | otherwise =\n+            HsTyVar noExt NotPromoted . noLoc $\n+            mkRdrQual (moduleName $ nameModule name) (occName name)\n+      where\n+        name = getName tyCon\n+    imports = declImports ++ additionalImports\n+    additionalImports =\n+        [ noLoc $\n+        ImportDecl\n+            { ideclExt = noExt\n+            , ideclSourceSrc = NoSourceText\n+            , ideclName = noLoc $ mkModuleName \"GHC.Err\"\n+            , ideclPkgQual = Nothing\n+            , ideclSource = False\n+            , ideclSafe = False\n+            , ideclImplicit = False\n+            , ideclQualified = True\n+            , ideclAs = Nothing\n+            , ideclHiding = Nothing\n+            } :: LImportDecl GhcPs\n+        | LF.unModuleName (LF.moduleName m) /= [\"GHC\", \"Err\"]\n+        ]\n+        ++\n         [ noLoc $\n         ImportDecl\n-            { ideclExt = NoExt\n+            { ideclExt = noExt\n+            , ideclSourceSrc = NoSourceText\n+            , ideclName = noLoc $ mkModuleName \"GHC.CString\"\n+            , ideclPkgQual = Nothing\n+            , ideclSource = False\n+            , ideclSafe = False\n+            , ideclImplicit = False\n+            , ideclQualified = False\n+            , ideclAs = Nothing\n+            , ideclHiding = Nothing\n+            } :: LImportDecl GhcPs\n+        | LF.unModuleName (LF.moduleName m) /= [\"GHC\", \"CString\"]\n+        ]\n+    -- imports needed by the module declarations\n+    declImports\n+     =\n+        [ noLoc $\n+        ImportDecl\n+            { ideclExt = noExt\n             , ideclSourceSrc = NoSourceText\n             , ideclName =\n                   noLoc $ mkModuleName $ T.unpack $ LF.moduleNameString modRef\n-            , ideclPkgQual =\n-                  Just $ StringLiteral NoSourceText $ unitIdFS $ getUnitId pkgRef\n+            , ideclPkgQual = Nothing\n             , ideclSource = False\n             , ideclSafe = False\n             , ideclImplicit = False\n             , ideclQualified = True\n             , ideclAs = Nothing\n             , ideclHiding = Nothing\n             } :: LImportDecl GhcPs\n-        | (pkgRef@(LF.PRImport pkgId), modRef) <-\n-              nubSort $ toListOf moduleModuleRef m\n-        , pkgId /= thisPkgId\n+        | (_unitId, modRef) <- modRefs\n+        , modRef /= LF.moduleName m"
  },
  {
    "id" : "ee6d9e4b-51bb-4939-b364-4000e12169e5",
    "prId" : 2169,
    "comments" : [
      {
        "id" : "cbb19b92-ab74-4306-80a5-b01c7434f93f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        \"Internal error: Dalf contains type constructors with more than two name components: \" <>\r\n```",
        "createdAt" : "2019-07-16T16:19:49Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "96796cb792561955bd36fd86c2aa7d64862d4762",
    "line" : null,
    "diffHunk" : "@@ -162,18 +163,33 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n         mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n         mkOccName varName \"Template\" :: LHsType GhcPs\n     sigRdrName = noLoc $ mkRdrUnqual $ mkOccName varName \"signatory\"\n+    errTooManyNameComponents cs =\n+        error $\n+        \"Internal error: Dalf contains data constructors with more than two name components: \" <>"
  },
  {
    "id" : "5e187604-8159-440d-a49e-23fc9512c05e",
    "prId" : 2169,
    "comments" : [
      {
        "id" : "7b59e5f9-ea6b-4f51-8ea9-a3b85607abb8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                                  in case (t :: HsType GhcPs) of\r\n```",
        "createdAt" : "2019-07-16T16:24:48Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "96796cb792561955bd36fd86c2aa7d64862d4762",
    "line" : 107,
    "diffHunk" : "@@ -346,12 +359,10 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n                           case ty of\n                               LF.TBuiltin LF.BTUnit -> PrefixCon []\n                               otherTy ->\n-                                  PrefixCon\n-                                      [ noLoc $\n-                                        HsParTy\n-                                            NoExt\n-                                            (noLoc $ convType otherTy)\n-                                      ]\n+                                  let t = convType otherTy\n+                                   in case (t :: HsType GhcPs) of"
  },
  {
    "id" : "b80c393f-b4ec-4cff-8e73-198f70c2c813",
    "prId" : 2169,
    "comments" : [
      {
        "id" : "cf75159a-e328-4e76-8a3e-7e54bb62d168",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`findWithDefault` might be your friend:\r\nhttps://www.stackage.org/haddock/lts-13.28/containers-0.6.0.1/Data-Map-Strict.html#v:findWithDefault",
        "createdAt" : "2019-07-16T16:26:50Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d68be4b8-0106-422f-8bf8-11919da2594c",
        "parentId" : "cf75159a-e328-4e76-8a3e-7e54bb62d168",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2019-07-16T16:52:21Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "96796cb792561955bd36fd86c2aa7d64862d4762",
    "line" : null,
    "diffHunk" : "@@ -381,20 +392,47 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n     convType =\n         \\case\n             LF.TVar tyVarName ->\n-                HsTyVar NoExt NotPromoted $\n-                mkRdrName $ LF.unTypeVarName tyVarName\n-            LF.TCon LF.Qualified {..} ->\n-                HsTyVar NoExt NotPromoted $\n-                noLoc $\n-                mkOrig\n-                    (mkModule\n-                         (getUnitId qualPackage)\n-                         (mkModuleName $\n-                          T.unpack $ LF.moduleNameString qualModule))\n-                    (mkOccName varName $\n-                     T.unpack $ T.intercalate \".\" $ LF.unTypeConName qualObject)\n+                HsTyVar NoExt NotPromoted $ mkRdrName $ LF.unTypeVarName tyVarName\n+            LF.TCon LF.Qualified {..}\n+                | [name] <- LF.unTypeConName qualObject ->\n+                    HsTyVar NoExt NotPromoted $\n+                    noLoc $\n+                    mkOrig\n+                        (mkModule\n+                             (getUnitId qualPackage)\n+                             (mkModuleName $\n+                              T.unpack $ LF.moduleNameString qualModule))\n+                        (mkOccName varName $ T.unpack name)\n+                | n@[_name0, _name1] <- LF.unTypeConName qualObject ->\n+                    let fs =\n+                            fromMaybe\n+                                (error $\n+                                 \"Internal error: Could not find generated record type: \" <>\n+                                 (T.unpack $ T.intercalate \".\" n)) $\n+                            MS.lookup n sumProdRecords"
  },
  {
    "id" : "0448e8be-0a95-49b9-ae81-a95f260d361f",
    "prId" : 2169,
    "comments" : [
      {
        "id" : "78189518-3647-4f5d-8103-e638e94709e0",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'd prefer a big `case LF.unTypeConName qualObject of` and then cases `[name]`, `n@[_, _]`, etc.",
        "createdAt" : "2019-07-16T16:28:15Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f5bd40aa-f63f-4df3-bd6b-0321006907f6",
        "parentId" : "78189518-3647-4f5d-8103-e638e94709e0",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "done.",
        "createdAt" : "2019-07-16T16:57:30Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "96796cb792561955bd36fd86c2aa7d64862d4762",
    "line" : null,
    "diffHunk" : "@@ -381,20 +392,47 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n     convType =\n         \\case\n             LF.TVar tyVarName ->\n-                HsTyVar NoExt NotPromoted $\n-                mkRdrName $ LF.unTypeVarName tyVarName\n-            LF.TCon LF.Qualified {..} ->\n-                HsTyVar NoExt NotPromoted $\n-                noLoc $\n-                mkOrig\n-                    (mkModule\n-                         (getUnitId qualPackage)\n-                         (mkModuleName $\n-                          T.unpack $ LF.moduleNameString qualModule))\n-                    (mkOccName varName $\n-                     T.unpack $ T.intercalate \".\" $ LF.unTypeConName qualObject)\n+                HsTyVar NoExt NotPromoted $ mkRdrName $ LF.unTypeVarName tyVarName\n+            LF.TCon LF.Qualified {..}"
  },
  {
    "id" : "6171daa6-5013-4bf8-9b91-926d7d81ae27",
    "prId" : 2169,
    "comments" : [
      {
        "id" : "3ed5c325-5afe-4a8b-aea5-734d4a739505",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What's the difference between `NoExt` and `noExt`?",
        "createdAt" : "2019-07-16T16:28:50Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5dd52e44-e857-4972-9c14-44a4296ad263",
        "parentId" : "3ed5c325-5afe-4a8b-aea5-734d4a739505",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "none I think.",
        "createdAt" : "2019-07-16T16:49:37Z",
        "updatedAt" : "2019-07-16T16:59:20Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "96796cb792561955bd36fd86c2aa7d64862d4762",
    "line" : 170,
    "diffHunk" : "@@ -381,20 +392,47 @@ generateSrcFromLf thisPkgId pkgMap m = noLoc mod\n     convType =\n         \\case\n             LF.TVar tyVarName ->\n-                HsTyVar NoExt NotPromoted $\n-                mkRdrName $ LF.unTypeVarName tyVarName\n-            LF.TCon LF.Qualified {..} ->\n-                HsTyVar NoExt NotPromoted $\n-                noLoc $\n-                mkOrig\n-                    (mkModule\n-                         (getUnitId qualPackage)\n-                         (mkModuleName $\n-                          T.unpack $ LF.moduleNameString qualModule))\n-                    (mkOccName varName $\n-                     T.unpack $ T.intercalate \".\" $ LF.unTypeConName qualObject)\n+                HsTyVar NoExt NotPromoted $ mkRdrName $ LF.unTypeVarName tyVarName\n+            LF.TCon LF.Qualified {..}\n+                | [name] <- LF.unTypeConName qualObject ->\n+                    HsTyVar NoExt NotPromoted $\n+                    noLoc $\n+                    mkOrig\n+                        (mkModule\n+                             (getUnitId qualPackage)\n+                             (mkModuleName $\n+                              T.unpack $ LF.moduleNameString qualModule))\n+                        (mkOccName varName $ T.unpack name)\n+                | n@[_name0, _name1] <- LF.unTypeConName qualObject ->\n+                    let fs =\n+                            fromMaybe\n+                                (error $\n+                                 \"Internal error: Could not find generated record type: \" <>\n+                                 (T.unpack $ T.intercalate \".\" n)) $\n+                            MS.lookup n sumProdRecords\n+                     in HsRecTy\n+                            NoExt\n+                            [ noLoc $\n+                            ConDeclField\n+                                { cd_fld_ext = noExt\n+                                , cd_fld_names =\n+                                      [ noLoc $\n+                                        FieldOcc\n+                                            { extFieldOcc = noExt\n+                                            , rdrNameFieldOcc =\n+                                                  mkRdrName $\n+                                                  LF.unFieldName fieldName\n+                                            }\n+                                      ]\n+                                , cd_fld_type = noLoc $ convType fieldTy\n+                                , cd_fld_doc = Nothing\n+                                }\n+                            | (fieldName, fieldTy) <- fs\n+                            ]\n+                | cs <- LF.unTypeConName qualObject -> errTooManyNameComponents cs\n             LF.TApp ty1 ty2 ->\n-                HsAppTy NoExt (noLoc $ convType ty1) (noLoc $ convType ty2)\n+                HsParTy noExt $"
  },
  {
    "id" : "a2439e89-d293-463b-83a6-2d4df6309cea",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "0ef6a76b-5a36-4491-9c9b-d045615a2183",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should fail hard if the type constructor name has more than one component, unless it's coming from a sum-of-products type.",
        "createdAt" : "2019-07-15T16:38:28Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4128f089-dd7a-46ac-88ce-e53da402311d",
        "parentId" : "0ef6a76b-5a36-4491-9c9b-d045615a2183",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I'll do that in the next PR, where I fix the sum of products translation.",
        "createdAt" : "2019-07-16T09:45:14Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "52145fc1-f618-4193-b7d1-51ffd951c113",
        "parentId" : "0ef6a76b-5a36-4491-9c9b-d045615a2183",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Makes sense.",
        "createdAt" : "2019-07-16T09:49:41Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : 165,
    "diffHunk" : "@@ -150,97 +147,198 @@ generateSrcFromLf thisPkgId pkgMap m = mkNoLoc mod\n             { hsmodImports = imports\n             , hsmodName =\n                   Just\n-                      (mkNoLoc $\n+                      (noLoc $\n                        mkModuleName $\n                        T.unpack $ LF.moduleNameString $ LF.moduleName m)\n             , hsmodDecls = decls\n             , hsmodDeprecMessage = Nothing\n             , hsmodHaddockModHeader = Nothing\n             , hsmodExports = Nothing\n             }\n+    templateTy =\n+        noLoc $\n+        HsTyVar NoExt NotPromoted $\n+        noLoc $\n+        mkRdrQual (mkModuleName \"DA.Internal.Template\") $\n+        mkOccName varName \"Template\" :: LHsType GhcPs\n+    sigRdrName = noLoc $ mkRdrUnqual $ mkOccName varName \"signatory\"\n     decls =\n-        [ mkNoLoc $\n-        TyClD NoExt $\n-        DataDecl\n-            { tcdDExt = NoExt\n-            , tcdLName =\n-                  mkNoLoc $\n-                  mkRdrUnqual $\n-                  mkOccName varName $\n-                  T.unpack $\n-                  sanitize $ T.intercalate \".\" $ LF.unTypeConName dataTypeCon\n-            , tcdTyVars =\n-                  HsQTvs\n-                      { hsq_ext = NoExt\n-                      , hsq_explicit =\n-                            [ mkUserTyVar $ LF.unTypeVarName tyVarName\n-                            | (tyVarName, _kind) <- dataParams\n-                            ]\n-                      }\n-            , tcdFixity = Prefix\n-            , tcdDataDefn =\n-                  HsDataDefn\n-                      { dd_ext = NoExt\n-                      , dd_ND = DataType\n-                      , dd_ctxt = mkNoLoc []\n-                      , dd_cType = Nothing\n-                      , dd_kindSig = Nothing\n-                      , dd_cons = convDataCons dataTypeCon dataCons\n-                      , dd_derivs = mkNoLoc []\n-                      }\n-            }\n-        | LF.DefDataType {..} <- NM.toList $ LF.moduleDataTypes m\n-        ]\n+        concat $ do\n+            LF.DefDataType {..} <- NM.toList $ LF.moduleDataTypes m\n+            let templType =\n+                    LF.mkTApps\n+                        (LF.TCon\n+                             (LF.Qualified LF.PRSelf (LF.moduleName m) dataTypeCon))\n+                        (map (LF.TVar . fst) dataParams)\n+            let occName =\n+                    mkOccName varName $\n+                    T.unpack $\n+                    sanitize $ T.intercalate \".\" $ LF.unTypeConName dataTypeCon"
  },
  {
    "id" : "601cb7ad-548a-4977-8bf3-0b29c49b42ce",
    "prId" : 2151,
    "comments" : [
      {
        "id" : "17b40fa0-66c6-4a5a-b28f-372acc49a2cd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n            (joinPath $ map T.unpack $ LF.unModuleName $ LF.moduleName mod) <.>\r\n```\r\nwhere `joinPath` is from `System.FilePath`.",
        "createdAt" : "2019-07-15T16:45:04Z",
        "updatedAt" : "2019-07-16T09:53:08Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0a3d126b7a3f438fd5aeab809b4352d28723ba26",
    "line" : null,
    "diffHunk" : "@@ -119,22 +118,20 @@ generateSrcPkgFromLf thisPkgId pkgMap pkg = do\n             toNormalizedFilePath $\n             (T.unpack $ T.intercalate \"/\" $ LF.unModuleName $ LF.moduleName mod) <.>"
  },
  {
    "id" : "e1d65561-3ab1-41a4-a337-aea7ee82634d",
    "prId" : 2124,
    "comments" : [
      {
        "id" : "55c3e4fb-9016-4410-9cb6-b030ea356791",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Looks like a reasonable function to factor out into `daml-lf-tools`.",
        "createdAt" : "2019-07-12T14:08:59Z",
        "updatedAt" : "2019-07-12T14:10:29Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "da34fc2b-1657-403a-92f3-bcaf0fc9a23b",
        "parentId" : "55c3e4fb-9016-4410-9cb6-b030ea356791",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I'll do a bigger refactoring of everything once everything works smoothly.",
        "createdAt" : "2019-07-12T14:42:20Z",
        "updatedAt" : "2019-07-12T14:42:20Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "14f7dff5cdd0d0f492cab84fcc091650c2a50aec",
    "line" : 60,
    "diffHunk" : "@@ -102,21 +107,44 @@ upgradeTemplate n =\n   , \"                    create $ conv d\"\n   ]\n \n+-- | Generate the full source for a daml-lf package.\n+generateSrcPkgFromLf ::\n+       LF.PackageId\n+    -> MS.Map GHC.UnitId LF.PackageId\n+    -> LF.Package\n+    -> [(NormalizedFilePath, String)]\n+generateSrcPkgFromLf thisPkgId pkgMap pkg = do\n+    mod <- NM.toList $ LF.packageModules pkg\n+    let fp =\n+            toNormalizedFilePath $"
  }
]