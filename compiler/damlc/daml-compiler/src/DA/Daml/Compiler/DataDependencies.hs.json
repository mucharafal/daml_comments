[
  {
    "id" : "ee40cfdf-501f-4c24-9e23-cd258d1ac9d8",
    "prId" : 7770,
    "comments" : [
      {
        "id" : "8a9991de-b325-4d14-b8c8-61a2c441dd67",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":scream_cat: ",
        "createdAt" : "2020-10-21T12:56:42Z",
        "updatedAt" : "2020-10-21T13:14:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9c58cc20-eacf-486e-bccb-6c78f5baea09",
        "parentId" : "8a9991de-b325-4d14-b8c8-61a2c441dd67",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "👻 ",
        "createdAt" : "2020-10-21T13:26:17Z",
        "updatedAt" : "2020-10-21T13:26:18Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "99fdd79e-a8fb-4086-b767-cf210446926f",
        "parentId" : "8a9991de-b325-4d14-b8c8-61a2c441dd67",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It feels like we're giving people a giant foot gun here. I mean it's more of a foot gun than in Haskell but still. Let's not tell people about it.",
        "createdAt" : "2020-10-22T13:24:10Z",
        "updatedAt" : "2020-10-22T13:25:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "99bf8b3526af4baa9252a090ef4cde7af0cb8a7c",
    "line" : 25,
    "diffHunk" : "@@ -471,6 +471,21 @@ generateSrcFromLf env = noLoc mod\n                 (intR,tagR) = T.span isDigit (T.reverse name)\n             in (T.reverse tagR, readMay (T.unpack (T.reverse intR)))\n \n+        getOverlapMode :: LF.ExprValName -> Maybe (Located OverlapMode)\n+        getOverlapMode (LF.ExprValName name) = do\n+            dval <- NM.lookup (overlapModeName name) (LF.moduleValues (envMod env))\n+            LF.EBuiltin (LF.BEText mode) <- Just (LF.dvalBody dval)\n+            modeFn <- MS.lookup mode overlapModeFns\n+            Just (noLoc (modeFn NoSourceText))\n+\n+        overlapModeFns :: MS.Map T.Text (SourceText -> OverlapMode)\n+        overlapModeFns = MS.fromList\n+            [ (\"OVERLAPPING\", Overlapping)\n+            , (\"OVERLAPPABLE\", Overlappable)\n+            , (\"OVERLAPS\", Overlaps)\n+            , (\"INCOHERENT\", Incoherent)"
  },
  {
    "id" : "d71f2764-d528-41db-9b89-eba2a54cd98e",
    "prId" : 7770,
    "comments" : [
      {
        "id" : "92c91f8a-4ae6-40a5-944f-c69accea7148",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe worth defining the mapping here and the one in the LF conversion somewhere close to each other or at least add a comment that the two must stay in sync.",
        "createdAt" : "2020-10-21T13:09:34Z",
        "updatedAt" : "2020-10-21T13:14:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "884b3008-0f1b-41a1-9c7d-b3d7ef11b5b3",
        "parentId" : "92c91f8a-4ae6-40a5-944f-c69accea7148",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "A roundtrip test might also be a good idea and avoids the need to write four tests just to make sure we translate strings correctly :slightly_smiling_face: ",
        "createdAt" : "2020-10-21T13:14:37Z",
        "updatedAt" : "2020-10-21T13:14:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0b8eaa0e-e7f3-4adc-a1db-654b9ced274c",
        "parentId" : "92c91f8a-4ae6-40a5-944f-c69accea7148",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "That's a good idea. (I think I'll do that as a separate refactoring PR since it involves touching more code.)",
        "createdAt" : "2020-10-21T14:06:46Z",
        "updatedAt" : "2020-10-21T14:06:47Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "99bf8b3526af4baa9252a090ef4cde7af0cb8a7c",
    "line" : 21,
    "diffHunk" : "@@ -471,6 +471,21 @@ generateSrcFromLf env = noLoc mod\n                 (intR,tagR) = T.span isDigit (T.reverse name)\n             in (T.reverse tagR, readMay (T.unpack (T.reverse intR)))\n \n+        getOverlapMode :: LF.ExprValName -> Maybe (Located OverlapMode)\n+        getOverlapMode (LF.ExprValName name) = do\n+            dval <- NM.lookup (overlapModeName name) (LF.moduleValues (envMod env))\n+            LF.EBuiltin (LF.BEText mode) <- Just (LF.dvalBody dval)\n+            modeFn <- MS.lookup mode overlapModeFns\n+            Just (noLoc (modeFn NoSourceText))\n+\n+        overlapModeFns :: MS.Map T.Text (SourceText -> OverlapMode)\n+        overlapModeFns = MS.fromList"
  },
  {
    "id" : "68144d93-c8db-445f-bbb3-b9c53540fcb6",
    "prId" : 7539,
    "comments" : [
      {
        "id" : "ad4b84d5-e88e-42c0-a6d8-e7200b1d8eed",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        dval@LF.DefValue {..} <- sortOn (Down . nameKey) $ NM.toList $ LF.moduleValues $ envMod env\r\n```",
        "createdAt" : "2020-10-01T10:47:32Z",
        "updatedAt" : "2020-10-01T11:30:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "794347bb-98ad-4130-9fb0-9a9a8deb11b1",
        "parentId" : "ad4b84d5-e88e-42c0-a6d8-e7200b1d8eed",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It's kind of surprising that you have to sort them in descending order. Strange...",
        "createdAt" : "2020-10-01T10:48:20Z",
        "updatedAt" : "2020-10-01T11:30:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6d9da2da895f51fee2ab302864d36b6c137d48e6",
    "line" : null,
    "diffHunk" : "@@ -383,7 +384,7 @@ generateSrcFromLf env = noLoc mod\n     -- | Generate instance declarations from dictionary functions.\n     instanceDecls :: [Gen (Maybe (LHsDecl GhcPs))]\n     instanceDecls = do\n-        dval@LF.DefValue {..} <- NM.toList $ LF.moduleValues $ envMod env\n+        dval@LF.DefValue {..} <- reverse . sortOn nameKey $ NM.toList $ LF.moduleValues $ envMod env"
  },
  {
    "id" : "f6065e37-0528-4975-ab90-ed94506567a3",
    "prId" : 7539,
    "comments" : [
      {
        "id" : "c05ee963-2c5c-4227-a55f-ab9ef0fc87f7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It's a bit sad that `Data.Text` doesn't have `spanEnd`, unlike `Data.Bytestring`. 😿 ",
        "createdAt" : "2020-10-01T10:53:15Z",
        "updatedAt" : "2020-10-01T11:30:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6d9da2da895f51fee2ab302864d36b6c137d48e6",
    "line" : 41,
    "diffHunk" : "@@ -404,6 +405,21 @@ generateSrcFromLf env = noLoc mod\n                     , cid_datafam_insts = []\n                     , cid_overlap_mode = Nothing\n                     }\n+      where\n+        -- Split a DefValue's name, into the lexical part and the numeric part\n+        -- if it exists. For example, the name \"$dFooBar123\" is split into a\n+        -- pair (\"$dFooBar\", Just 123), and the name \"$dFooBar\" would be turned\n+        -- into (\"$dFooBar\", Nothing). This gives us the correct (or, close\n+        -- enough) order for recreating dictionary function names in GHC without\n+        -- mismatches.\n+        --\n+        -- See issue #7362, and the corresponding regression test in the\n+        -- packaging test suite.\n+        nameKey :: LF.DefValue -> (T.Text, Maybe Int)\n+        nameKey dval =\n+            let name = LF.unExprValName (fst (LF.dvalBinder dval))\n+                (intR,tagR) = T.span isDigit (T.reverse name)\n+            in (T.reverse tagR, readMay (T.unpack (T.reverse intR)))"
  },
  {
    "id" : "e2ba682d-959d-4002-989a-301a40b66a9f",
    "prId" : 7303,
    "comments" : [
      {
        "id" : "2d8469bc-d708-49f3-bd95-6aa92e6805e0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This means that a variant where I explicilty specify a Unit argument will also be decompiled to a Prefix con right? I think that’s perfectly reasonable but probably worth documenting in a comment and perhaps warning on in the preprocessor.",
        "createdAt" : "2020-09-02T11:55:35Z",
        "updatedAt" : "2020-09-02T14:30:40Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d05c7665-e93f-4926-8107-8dba22dd8eec",
        "parentId" : "2d8469bc-d708-49f3-bd95-6aa92e6805e0",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Yes, that's what we decided on in the issue and I'm preparing the warning in a separate PR.",
        "createdAt" : "2020-09-02T12:05:27Z",
        "updatedAt" : "2020-09-02T14:30:40Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "59926babb9e698dbaa9e85ecabacd3d575c25df0",
    "line" : null,
    "diffHunk" : "@@ -479,6 +479,9 @@ generateSrcFromLf env = noLoc mod\n \n         convConDetails :: LF.Type -> Gen (HsConDeclDetails GhcPs)\n         convConDetails = \\case\n+            -- empty variant constructor (see issue #7207)\n+            LF.TUnit ->"
  },
  {
    "id" : "9e0f6ab1-9754-430b-ab77-d5edf15faa2b",
    "prId" : 7303,
    "comments" : [
      {
        "id" : "1a6bc069-49a8-497f-af9f-f293fbe43815",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "\"Empty\" is such an overloaded word:\r\n```suggestion\r\n            -- variant constructor without argument (see issue #7207)\r\n```\r\nOr \"payload\" instead of \"argument\".",
        "createdAt" : "2020-09-02T12:33:55Z",
        "updatedAt" : "2020-09-02T14:30:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f4f2e09d-12c6-4953-85ec-39cf628c27b5",
        "parentId" : "1a6bc069-49a8-497f-af9f-f293fbe43815",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "Right, but \"variant constructor without argument\" is such a clumsy phrase, and what else could \"empty variant constructor\" mean?",
        "createdAt" : "2020-09-02T13:01:47Z",
        "updatedAt" : "2020-09-02T14:30:40Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2bb49af7-27dc-422b-a46c-3de0c68c95ab",
        "parentId" : "1a6bc069-49a8-497f-af9f-f293fbe43815",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "I guess the right answer here is \"nullary variant constructor\".",
        "createdAt" : "2020-09-02T13:02:50Z",
        "updatedAt" : "2020-09-02T14:30:40Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3ce9186b-ac3d-4e5a-97a2-ef368cc4aed1",
        "parentId" : "1a6bc069-49a8-497f-af9f-f293fbe43815",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I like \"nullary variant constructor\". 👍 ",
        "createdAt" : "2020-09-02T13:32:50Z",
        "updatedAt" : "2020-09-02T14:30:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "59926babb9e698dbaa9e85ecabacd3d575c25df0",
    "line" : null,
    "diffHunk" : "@@ -479,6 +479,9 @@ generateSrcFromLf env = noLoc mod\n \n         convConDetails :: LF.Type -> Gen (HsConDeclDetails GhcPs)\n         convConDetails = \\case\n+            -- empty variant constructor (see issue #7207)"
  },
  {
    "id" : "d3320e7d-e76d-4cca-9e52-1eeddbe07830",
    "prId" : 4881,
    "comments" : [
      {
        "id" : "5c4c6e52-7656-46df-8958-a0efdec988fb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that this follows references across packages afaict, would it make sense to call it once for all packages instead of once per package? (Happy to not do this as part of this PR even if it does make sense).",
        "createdAt" : "2020-03-06T14:59:59Z",
        "updatedAt" : "2020-03-06T15:32:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "206e5d3d-686f-4b10-aab3-4906014db497",
        "parentId" : "5c4c6e52-7656-46df-8958-a0efdec988fb",
        "author" : null,
        "body" : "Yes! I think that should be the next experiment :)",
        "createdAt" : "2020-03-06T15:03:11Z",
        "updatedAt" : "2020-03-06T15:32:00Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "253dffa6-8219-4b2f-9b8d-0f411b4a9f3d",
        "parentId" : "5c4c6e52-7656-46df-8958-a0efdec988fb",
        "author" : null,
        "body" : "Wait, it shouldn't make a difference unless you have multiple data-dependencies with lots of packages in common.",
        "createdAt" : "2020-03-06T15:39:39Z",
        "updatedAt" : "2020-03-06T15:39:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "2c69fe1c-3aa3-47db-9263-8eedb5ee859e",
        "parentId" : "5c4c6e52-7656-46df-8958-a0efdec988fb",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Right but having multiple data-dependencies that are interlinked doesn’t sound that unreasonable.",
        "createdAt" : "2020-03-06T15:41:29Z",
        "updatedAt" : "2020-03-06T15:41:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "795964ba-8a18-4e93-b6fc-10f7a655d8c2",
        "parentId" : "5c4c6e52-7656-46df-8958-a0efdec988fb",
        "author" : null,
        "body" : "Yes, but perhaps that change can be made if/when it becomes relevant, and/or as part of a larger refactoring of packaging rules.",
        "createdAt" : "2020-03-06T15:53:35Z",
        "updatedAt" : "2020-03-06T15:53:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "07cfa5e8-ec57-4f86-8c48-ec0cef734225",
        "parentId" : "5c4c6e52-7656-46df-8958-a0efdec988fb",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":+1:",
        "createdAt" : "2020-03-06T15:58:06Z",
        "updatedAt" : "2020-03-06T15:58:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ae157cc4063eef409e90f907834d5c5d2150e7f1",
    "line" : 101,
    "diffHunk" : "@@ -833,8 +840,8 @@ refModule = \\case\n type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n \n -- | Calculate the set of all references that should be hidden.\n-buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n-buildHiddenRefMap env =\n+buildHiddenRefMap :: Config -> LF.World -> HMS.HashMap Ref Bool"
  },
  {
    "id" : "f23e962a-f28c-466b-86df-6f4daeec60b1",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "188d163f-a8fd-4ea3-8aa1-daf283573851",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    refGraph = foldl' visitRef HMS.empty (rootRefs env)\r\n```",
        "createdAt" : "2020-03-05T13:33:13Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : null,
    "diffHunk" : "@@ -794,23 +805,193 @@ generateSrcPkgFromLf config pkg = do\n         , \"{-# OPTIONS_GHC -Wno-unused-imports -Wno-missing-methods #-}\"\n         ]\n \n--- | Returns 'True' if an LF type contains a reference to an\n--- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n-typeHasOldTypeclass :: Env -> LF.Type -> Bool\n-typeHasOldTypeclass env = \\case\n-    LF.TVar _ -> False\n-    LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n-        -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so we can assume there are no old-style\n-        -- typeclasses being referenced.\n-    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n-    LF.TBuiltin _ -> False\n-    LF.TForall _ b -> typeHasOldTypeclass env b\n-    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n-    LF.TNat _ -> False\n-\n--- | Determine whether a typecon refers to an old-style\n+-- | A reference that can appear in a type or expression. We need to track\n+-- all of these in order to control what gets hidden in data-dependencies.\n+data Ref\n+    = RTypeCon (LF.Qualified LF.TypeConName)\n+        -- ^ necessary to track hidden types and old-style typeclasses\n+    | RTypeSyn (LF.Qualified LF.TypeSynName)\n+        -- ^ necessary to track hidden new-style typeclasses\n+    | RValue (LF.Qualified LF.ExprValName)\n+        -- ^ necessary to track hidden typeclass instances\n+    deriving (Eq, Ord, Show, Generic)\n+\n+instance Hashable Ref\n+\n+refPackage :: Ref -> LF.PackageRef\n+refPackage = \\case\n+    RTypeCon q -> LF.qualPackage q\n+    RTypeSyn q -> LF.qualPackage q\n+    RValue q -> LF.qualPackage q\n+\n+refModule :: Ref -> LF.ModuleName\n+refModule = \\case\n+    RTypeCon q -> LF.qualModule q\n+    RTypeSyn q -> LF.qualModule q\n+    RValue q -> LF.qualModule q\n+\n+type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n+\n+-- | Calculate the set of all references that should be hidden.\n+buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n+buildHiddenRefMap env =\n+    case leastFixedPointBy (||) refGraphList of\n+        Left ref -> error\n+            (\"Internal error: missing reference in RefGraph \"\n+            <> show ref)\n+        Right m -> m\n+  where\n+    refGraphList :: [(Ref, Bool, [Ref])]\n+    refGraphList =\n+        [ (ref, hidden, deps)\n+        | (ref, (hidden, deps)) <- HMS.toList refGraph\n+        ]\n+\n+    refGraph :: RefGraph\n+    refGraph = foldl visitRef HMS.empty (rootRefs env)"
  },
  {
    "id" : "9ffe03bb-4938-4f26-89db-df4689d2593a",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "14927c58-d664-4a3b-b4dc-d1c429660482",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n            = foldl' visitRef refGraph' refs\r\n```",
        "createdAt" : "2020-03-05T13:38:51Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : null,
    "diffHunk" : "@@ -794,23 +805,192 @@ generateSrcPkgFromLf config pkg = do\n         , \"{-# OPTIONS_GHC -Wno-unused-imports -Wno-missing-methods #-}\"\n         ]\n \n--- | Returns 'True' if an LF type contains a reference to an\n--- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n-typeHasOldTypeclass :: Env -> LF.Type -> Bool\n-typeHasOldTypeclass env = \\case\n-    LF.TVar _ -> False\n-    LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n-        -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so we can assume there are no old-style\n-        -- typeclasses being referenced.\n-    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n-    LF.TBuiltin _ -> False\n-    LF.TForall _ b -> typeHasOldTypeclass env b\n-    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n-    LF.TNat _ -> False\n-\n--- | Determine whether a typecon refers to an old-style\n+-- | A reference that can appear in a type or expression. We need to track\n+-- all of these in order to control what gets hidden in data-dependencies.\n+data Ref\n+    = RTypeCon (LF.Qualified LF.TypeConName)\n+        -- ^ necessary to track hidden types and old-style typeclasses\n+    | RTypeSyn (LF.Qualified LF.TypeSynName)\n+        -- ^ necessary to track hidden new-style typeclasses\n+    | RValue (LF.Qualified LF.ExprValName)\n+        -- ^ necessary to track hidden typeclass instances\n+    deriving (Eq, Ord, Show, Generic)\n+\n+instance Hashable Ref\n+\n+refPackage :: Ref -> LF.PackageRef\n+refPackage = \\case\n+    RTypeCon q -> LF.qualPackage q\n+    RTypeSyn q -> LF.qualPackage q\n+    RValue q -> LF.qualPackage q\n+\n+refModule :: Ref -> LF.ModuleName\n+refModule = \\case\n+    RTypeCon q -> LF.qualModule q\n+    RTypeSyn q -> LF.qualModule q\n+    RValue q -> LF.qualModule q\n+\n+type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n+\n+-- | Calculate the set of all references that should be hidden.\n+buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n+buildHiddenRefMap env =\n+    case leastFixedPointBy (||) refGraphList of\n+        Left ref -> error\n+            (\"Internal error: missing reference in RefGraph \"\n+            <> show ref)\n+        Right m -> m\n+  where\n+    refGraphList :: [(Ref, Bool, [Ref])]\n+    refGraphList =\n+        [ (ref, hidden, deps)\n+        | (ref, (hidden, deps)) <- HMS.toList refGraph\n+        ]\n+\n+    refGraph :: RefGraph\n+    refGraph = foldl visitRef HMS.empty (rootRefs env)\n+\n+    visitRef :: RefGraph -> Ref -> RefGraph\n+    visitRef !refGraph ref\n+        | HMS.member ref refGraph\n+            = refGraph -- already in the map\n+        | ref == RTypeCon erasedTCon\n+            = HMS.insert ref (True, []) refGraph -- Erased is always erased\n+        | refModule ref == LF.ModuleName [\"DA\", \"Generics\"]\n+            = HMS.insert ref (True, []) refGraph -- DA.Generics is not supported\n+        | LF.PRImport pkgId <- refPackage ref\n+        , Set.member pkgId (configDependencyPackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- dependencies are always available\n+        | LF.PRImport pkgId <- refPackage ref\n+        , MS.member pkgId (configStablePackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- stable pkgs are always available\n+\n+        | RTypeCon tcon <- ref\n+        , Just defDataType <- envLookupDataType tcon env\n+        , refs <- DL.toList (refsFromDefDataType defDataType)\n+        , hidden <- defDataTypeIsOldTypeClass defDataType\n+        , refGraph' <- HMS.insert ref (hidden, refs) refGraph\n+            = foldl visitRef refGraph' refs"
  },
  {
    "id" : "12e35220-0ddc-414a-b4a9-6747a5d4570f",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "eae560a5-54ea-4bd1-9297-afb022eec7f4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n            = foldl' visitRef refGraph' refs\r\n```\r\nwe need an HLint hint :slightly_smiling_face: ",
        "createdAt" : "2020-03-05T13:40:14Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b39833b3-15f9-489e-84e9-1e1eaa5d48e3",
        "parentId" : "eae560a5-54ea-4bd1-9297-afb022eec7f4",
        "author" : null,
        "body" : "Ahahah, yes, absolutely. :) ",
        "createdAt" : "2020-03-05T15:07:30Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : null,
    "diffHunk" : "@@ -794,23 +805,192 @@ generateSrcPkgFromLf config pkg = do\n         , \"{-# OPTIONS_GHC -Wno-unused-imports -Wno-missing-methods #-}\"\n         ]\n \n--- | Returns 'True' if an LF type contains a reference to an\n--- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n-typeHasOldTypeclass :: Env -> LF.Type -> Bool\n-typeHasOldTypeclass env = \\case\n-    LF.TVar _ -> False\n-    LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n-        -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so we can assume there are no old-style\n-        -- typeclasses being referenced.\n-    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n-    LF.TBuiltin _ -> False\n-    LF.TForall _ b -> typeHasOldTypeclass env b\n-    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n-    LF.TNat _ -> False\n-\n--- | Determine whether a typecon refers to an old-style\n+-- | A reference that can appear in a type or expression. We need to track\n+-- all of these in order to control what gets hidden in data-dependencies.\n+data Ref\n+    = RTypeCon (LF.Qualified LF.TypeConName)\n+        -- ^ necessary to track hidden types and old-style typeclasses\n+    | RTypeSyn (LF.Qualified LF.TypeSynName)\n+        -- ^ necessary to track hidden new-style typeclasses\n+    | RValue (LF.Qualified LF.ExprValName)\n+        -- ^ necessary to track hidden typeclass instances\n+    deriving (Eq, Ord, Show, Generic)\n+\n+instance Hashable Ref\n+\n+refPackage :: Ref -> LF.PackageRef\n+refPackage = \\case\n+    RTypeCon q -> LF.qualPackage q\n+    RTypeSyn q -> LF.qualPackage q\n+    RValue q -> LF.qualPackage q\n+\n+refModule :: Ref -> LF.ModuleName\n+refModule = \\case\n+    RTypeCon q -> LF.qualModule q\n+    RTypeSyn q -> LF.qualModule q\n+    RValue q -> LF.qualModule q\n+\n+type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n+\n+-- | Calculate the set of all references that should be hidden.\n+buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n+buildHiddenRefMap env =\n+    case leastFixedPointBy (||) refGraphList of\n+        Left ref -> error\n+            (\"Internal error: missing reference in RefGraph \"\n+            <> show ref)\n+        Right m -> m\n+  where\n+    refGraphList :: [(Ref, Bool, [Ref])]\n+    refGraphList =\n+        [ (ref, hidden, deps)\n+        | (ref, (hidden, deps)) <- HMS.toList refGraph\n+        ]\n+\n+    refGraph :: RefGraph\n+    refGraph = foldl visitRef HMS.empty (rootRefs env)\n+\n+    visitRef :: RefGraph -> Ref -> RefGraph\n+    visitRef !refGraph ref\n+        | HMS.member ref refGraph\n+            = refGraph -- already in the map\n+        | ref == RTypeCon erasedTCon\n+            = HMS.insert ref (True, []) refGraph -- Erased is always erased\n+        | refModule ref == LF.ModuleName [\"DA\", \"Generics\"]\n+            = HMS.insert ref (True, []) refGraph -- DA.Generics is not supported\n+        | LF.PRImport pkgId <- refPackage ref\n+        , Set.member pkgId (configDependencyPackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- dependencies are always available\n+        | LF.PRImport pkgId <- refPackage ref\n+        , MS.member pkgId (configStablePackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- stable pkgs are always available\n+\n+        | RTypeCon tcon <- ref\n+        , Just defDataType <- envLookupDataType tcon env\n+        , refs <- DL.toList (refsFromDefDataType defDataType)\n+        , hidden <- defDataTypeIsOldTypeClass defDataType\n+        , refGraph' <- HMS.insert ref (hidden, refs) refGraph\n+            = foldl visitRef refGraph' refs\n+\n+        | RTypeSyn tsyn <- ref\n+        , Just defTypeSyn <- envLookupSynonym tsyn env\n+        , refs <- DL.toList (refsFromDefTypeSyn defTypeSyn)\n+        , refGraph' <- HMS.insert ref (False, refs) refGraph\n+            = foldl visitRef refGraph' refs"
  },
  {
    "id" : "050b9a32-0e96-43ba-9edb-7b1612dad2ff",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "11f6ddb3-e34f-4fe6-ad28-8f613cdf448e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n            = foldl' visitRef refGraph' refs\r\n```",
        "createdAt" : "2020-03-05T13:40:25Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : null,
    "diffHunk" : "@@ -794,23 +805,192 @@ generateSrcPkgFromLf config pkg = do\n         , \"{-# OPTIONS_GHC -Wno-unused-imports -Wno-missing-methods #-}\"\n         ]\n \n--- | Returns 'True' if an LF type contains a reference to an\n--- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n-typeHasOldTypeclass :: Env -> LF.Type -> Bool\n-typeHasOldTypeclass env = \\case\n-    LF.TVar _ -> False\n-    LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n-        -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so we can assume there are no old-style\n-        -- typeclasses being referenced.\n-    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n-    LF.TBuiltin _ -> False\n-    LF.TForall _ b -> typeHasOldTypeclass env b\n-    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n-    LF.TNat _ -> False\n-\n--- | Determine whether a typecon refers to an old-style\n+-- | A reference that can appear in a type or expression. We need to track\n+-- all of these in order to control what gets hidden in data-dependencies.\n+data Ref\n+    = RTypeCon (LF.Qualified LF.TypeConName)\n+        -- ^ necessary to track hidden types and old-style typeclasses\n+    | RTypeSyn (LF.Qualified LF.TypeSynName)\n+        -- ^ necessary to track hidden new-style typeclasses\n+    | RValue (LF.Qualified LF.ExprValName)\n+        -- ^ necessary to track hidden typeclass instances\n+    deriving (Eq, Ord, Show, Generic)\n+\n+instance Hashable Ref\n+\n+refPackage :: Ref -> LF.PackageRef\n+refPackage = \\case\n+    RTypeCon q -> LF.qualPackage q\n+    RTypeSyn q -> LF.qualPackage q\n+    RValue q -> LF.qualPackage q\n+\n+refModule :: Ref -> LF.ModuleName\n+refModule = \\case\n+    RTypeCon q -> LF.qualModule q\n+    RTypeSyn q -> LF.qualModule q\n+    RValue q -> LF.qualModule q\n+\n+type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n+\n+-- | Calculate the set of all references that should be hidden.\n+buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n+buildHiddenRefMap env =\n+    case leastFixedPointBy (||) refGraphList of\n+        Left ref -> error\n+            (\"Internal error: missing reference in RefGraph \"\n+            <> show ref)\n+        Right m -> m\n+  where\n+    refGraphList :: [(Ref, Bool, [Ref])]\n+    refGraphList =\n+        [ (ref, hidden, deps)\n+        | (ref, (hidden, deps)) <- HMS.toList refGraph\n+        ]\n+\n+    refGraph :: RefGraph\n+    refGraph = foldl visitRef HMS.empty (rootRefs env)\n+\n+    visitRef :: RefGraph -> Ref -> RefGraph\n+    visitRef !refGraph ref\n+        | HMS.member ref refGraph\n+            = refGraph -- already in the map\n+        | ref == RTypeCon erasedTCon\n+            = HMS.insert ref (True, []) refGraph -- Erased is always erased\n+        | refModule ref == LF.ModuleName [\"DA\", \"Generics\"]\n+            = HMS.insert ref (True, []) refGraph -- DA.Generics is not supported\n+        | LF.PRImport pkgId <- refPackage ref\n+        , Set.member pkgId (configDependencyPackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- dependencies are always available\n+        | LF.PRImport pkgId <- refPackage ref\n+        , MS.member pkgId (configStablePackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- stable pkgs are always available\n+\n+        | RTypeCon tcon <- ref\n+        , Just defDataType <- envLookupDataType tcon env\n+        , refs <- DL.toList (refsFromDefDataType defDataType)\n+        , hidden <- defDataTypeIsOldTypeClass defDataType\n+        , refGraph' <- HMS.insert ref (hidden, refs) refGraph\n+            = foldl visitRef refGraph' refs\n+\n+        | RTypeSyn tsyn <- ref\n+        , Just defTypeSyn <- envLookupSynonym tsyn env\n+        , refs <- DL.toList (refsFromDefTypeSyn defTypeSyn)\n+        , refGraph' <- HMS.insert ref (False, refs) refGraph\n+            = foldl visitRef refGraph' refs\n+\n+        | RValue val <- ref\n+        , Just dval@LF.DefValue{..} <- envLookupValue val env\n+        , refs <- if hasDFunSig dvalBinder -- we only care about typeclass instances\n+            then DL.toList (refsFromDFun dval)\n+            else mempty\n+        , refGraph' <- HMS.insert ref (False, refs) refGraph\n+            = foldl visitRef refGraph' refs"
  },
  {
    "id" : "8ca08af2-d1f3-4393-b621-fae7b2fa2793",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "b43d00cf-be48-4d85-a861-047381cea339",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Will we ever look up a reference to a `dependency`? Presumably the case where this matters is for reexported typeclasses. Do we check if the original typeclass is hidden or if the new typeclass is hidden? I think I don’t really understand why we need to “white-list” this so maybe it would be good to expand on this in a comment.",
        "createdAt" : "2020-03-05T13:41:57Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f091c8df-82a8-44ac-8431-c18476998882",
        "parentId" : "b43d00cf-be48-4d85-a861-047381cea339",
        "author" : null,
        "body" : "I didn't check to see if it made a significant difference, but this whitelist is for the case where the data-dependency shares a dependency with the package being built. It doesn't check re-exports, it's just a check for actual references to the same dependencies.\r\n\r\nThe only case where this is logically relevant is if both the package being built & the data-dependencies depend on the same package, and that package contains something that would otherwise be erased. That's pretty rare. OTOH, this check prevents us from building up the a complicated dependency graph for daml-stdlib / daml-prim modules each time, on the assumption that the SDK hasn't changed.\r\n\r\nGiven that the case where it matters is quite rare, I can try removing this and see if it makes a difference to compile times. If removing it makes it significantly worse, I'll keep the whitelist and add a comment, and then see if we can just eat the cost once we start building this map once per package instead of once per module.",
        "createdAt" : "2020-03-05T15:29:07Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "ededc41d-c12f-43cf-a65c-c781805166f6",
        "parentId" : "b43d00cf-be48-4d85-a861-047381cea339",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thanks for the explanation! Happy to keep it for this PR if we add a comment.",
        "createdAt" : "2020-03-05T15:30:13Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : 194,
    "diffHunk" : "@@ -794,23 +805,192 @@ generateSrcPkgFromLf config pkg = do\n         , \"{-# OPTIONS_GHC -Wno-unused-imports -Wno-missing-methods #-}\"\n         ]\n \n--- | Returns 'True' if an LF type contains a reference to an\n--- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n-typeHasOldTypeclass :: Env -> LF.Type -> Bool\n-typeHasOldTypeclass env = \\case\n-    LF.TVar _ -> False\n-    LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n-        -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so we can assume there are no old-style\n-        -- typeclasses being referenced.\n-    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n-    LF.TBuiltin _ -> False\n-    LF.TForall _ b -> typeHasOldTypeclass env b\n-    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n-    LF.TNat _ -> False\n-\n--- | Determine whether a typecon refers to an old-style\n+-- | A reference that can appear in a type or expression. We need to track\n+-- all of these in order to control what gets hidden in data-dependencies.\n+data Ref\n+    = RTypeCon (LF.Qualified LF.TypeConName)\n+        -- ^ necessary to track hidden types and old-style typeclasses\n+    | RTypeSyn (LF.Qualified LF.TypeSynName)\n+        -- ^ necessary to track hidden new-style typeclasses\n+    | RValue (LF.Qualified LF.ExprValName)\n+        -- ^ necessary to track hidden typeclass instances\n+    deriving (Eq, Ord, Show, Generic)\n+\n+instance Hashable Ref\n+\n+refPackage :: Ref -> LF.PackageRef\n+refPackage = \\case\n+    RTypeCon q -> LF.qualPackage q\n+    RTypeSyn q -> LF.qualPackage q\n+    RValue q -> LF.qualPackage q\n+\n+refModule :: Ref -> LF.ModuleName\n+refModule = \\case\n+    RTypeCon q -> LF.qualModule q\n+    RTypeSyn q -> LF.qualModule q\n+    RValue q -> LF.qualModule q\n+\n+type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n+\n+-- | Calculate the set of all references that should be hidden.\n+buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n+buildHiddenRefMap env =\n+    case leastFixedPointBy (||) refGraphList of\n+        Left ref -> error\n+            (\"Internal error: missing reference in RefGraph \"\n+            <> show ref)\n+        Right m -> m\n+  where\n+    refGraphList :: [(Ref, Bool, [Ref])]\n+    refGraphList =\n+        [ (ref, hidden, deps)\n+        | (ref, (hidden, deps)) <- HMS.toList refGraph\n+        ]\n+\n+    refGraph :: RefGraph\n+    refGraph = foldl visitRef HMS.empty (rootRefs env)\n+\n+    visitRef :: RefGraph -> Ref -> RefGraph\n+    visitRef !refGraph ref\n+        | HMS.member ref refGraph\n+            = refGraph -- already in the map\n+        | ref == RTypeCon erasedTCon\n+            = HMS.insert ref (True, []) refGraph -- Erased is always erased\n+        | refModule ref == LF.ModuleName [\"DA\", \"Generics\"]\n+            = HMS.insert ref (True, []) refGraph -- DA.Generics is not supported\n+        | LF.PRImport pkgId <- refPackage ref\n+        , Set.member pkgId (configDependencyPackages (envConfig env))"
  },
  {
    "id" : "8d67f580-5d0b-415e-9753-e56d2f1df8bb",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "1578e253-3f67-4814-b903-4f8eac9d3da7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we add a comment why `Erased` is not sufficient to throw out the problematic stuff from `DA.Generics`?",
        "createdAt" : "2020-03-05T13:42:24Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2d3adb4e-e164-4910-ae1c-492a57aa6365",
        "parentId" : "1578e253-3f67-4814-b903-4f8eac9d3da7",
        "author" : null,
        "body" : "I'll add a comment. It's because `GenConvertible` causes kind errors in the back and forth translation, without actual  references to `Erased`.",
        "createdAt" : "2020-03-05T15:16:11Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "47d0c2c1-97c7-4b2d-a110-ee3a41fdfe90",
        "parentId" : "1578e253-3f67-4814-b903-4f8eac9d3da7",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "FWIW, `GenConvertible` is killed in https://github.com/digital-asset/daml/pull/4839. Although I don’t really understand why `GenConvertible` causes issues here since it’s not used in the project you tested on afaik and we have other tests that use `daml-stdlib`. Either way, happy to keep this code if we add a comment.",
        "createdAt" : "2020-03-05T15:27:16Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : 188,
    "diffHunk" : "@@ -794,23 +805,192 @@ generateSrcPkgFromLf config pkg = do\n         , \"{-# OPTIONS_GHC -Wno-unused-imports -Wno-missing-methods #-}\"\n         ]\n \n--- | Returns 'True' if an LF type contains a reference to an\n--- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n-typeHasOldTypeclass :: Env -> LF.Type -> Bool\n-typeHasOldTypeclass env = \\case\n-    LF.TVar _ -> False\n-    LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n-        -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so we can assume there are no old-style\n-        -- typeclasses being referenced.\n-    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n-    LF.TBuiltin _ -> False\n-    LF.TForall _ b -> typeHasOldTypeclass env b\n-    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n-    LF.TNat _ -> False\n-\n--- | Determine whether a typecon refers to an old-style\n+-- | A reference that can appear in a type or expression. We need to track\n+-- all of these in order to control what gets hidden in data-dependencies.\n+data Ref\n+    = RTypeCon (LF.Qualified LF.TypeConName)\n+        -- ^ necessary to track hidden types and old-style typeclasses\n+    | RTypeSyn (LF.Qualified LF.TypeSynName)\n+        -- ^ necessary to track hidden new-style typeclasses\n+    | RValue (LF.Qualified LF.ExprValName)\n+        -- ^ necessary to track hidden typeclass instances\n+    deriving (Eq, Ord, Show, Generic)\n+\n+instance Hashable Ref\n+\n+refPackage :: Ref -> LF.PackageRef\n+refPackage = \\case\n+    RTypeCon q -> LF.qualPackage q\n+    RTypeSyn q -> LF.qualPackage q\n+    RValue q -> LF.qualPackage q\n+\n+refModule :: Ref -> LF.ModuleName\n+refModule = \\case\n+    RTypeCon q -> LF.qualModule q\n+    RTypeSyn q -> LF.qualModule q\n+    RValue q -> LF.qualModule q\n+\n+type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n+\n+-- | Calculate the set of all references that should be hidden.\n+buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n+buildHiddenRefMap env =\n+    case leastFixedPointBy (||) refGraphList of\n+        Left ref -> error\n+            (\"Internal error: missing reference in RefGraph \"\n+            <> show ref)\n+        Right m -> m\n+  where\n+    refGraphList :: [(Ref, Bool, [Ref])]\n+    refGraphList =\n+        [ (ref, hidden, deps)\n+        | (ref, (hidden, deps)) <- HMS.toList refGraph\n+        ]\n+\n+    refGraph :: RefGraph\n+    refGraph = foldl visitRef HMS.empty (rootRefs env)\n+\n+    visitRef :: RefGraph -> Ref -> RefGraph\n+    visitRef !refGraph ref\n+        | HMS.member ref refGraph\n+            = refGraph -- already in the map\n+        | ref == RTypeCon erasedTCon\n+            = HMS.insert ref (True, []) refGraph -- Erased is always erased\n+        | refModule ref == LF.ModuleName [\"DA\", \"Generics\"]"
  },
  {
    "id" : "ef64dbda-a0b5-42f4-b341-a1d8d4760660",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "2ed26f1a-c6c5-48e5-952c-d4f2257f27a4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Similar question here, why do we need to whitelist this?",
        "createdAt" : "2020-03-05T13:46:09Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7e965203-ffc8-46e7-9335-c3047391a266",
        "parentId" : "2ed26f1a-c6c5-48e5-952c-d4f2257f27a4",
        "author" : null,
        "body" : "Same as above. I can probably just remove it though.",
        "createdAt" : "2020-03-05T15:29:55Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : 201,
    "diffHunk" : "@@ -794,23 +805,192 @@ generateSrcPkgFromLf config pkg = do\n         , \"{-# OPTIONS_GHC -Wno-unused-imports -Wno-missing-methods #-}\"\n         ]\n \n--- | Returns 'True' if an LF type contains a reference to an\n--- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n-typeHasOldTypeclass :: Env -> LF.Type -> Bool\n-typeHasOldTypeclass env = \\case\n-    LF.TVar _ -> False\n-    LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n-        -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so we can assume there are no old-style\n-        -- typeclasses being referenced.\n-    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n-    LF.TBuiltin _ -> False\n-    LF.TForall _ b -> typeHasOldTypeclass env b\n-    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n-    LF.TNat _ -> False\n-\n--- | Determine whether a typecon refers to an old-style\n+-- | A reference that can appear in a type or expression. We need to track\n+-- all of these in order to control what gets hidden in data-dependencies.\n+data Ref\n+    = RTypeCon (LF.Qualified LF.TypeConName)\n+        -- ^ necessary to track hidden types and old-style typeclasses\n+    | RTypeSyn (LF.Qualified LF.TypeSynName)\n+        -- ^ necessary to track hidden new-style typeclasses\n+    | RValue (LF.Qualified LF.ExprValName)\n+        -- ^ necessary to track hidden typeclass instances\n+    deriving (Eq, Ord, Show, Generic)\n+\n+instance Hashable Ref\n+\n+refPackage :: Ref -> LF.PackageRef\n+refPackage = \\case\n+    RTypeCon q -> LF.qualPackage q\n+    RTypeSyn q -> LF.qualPackage q\n+    RValue q -> LF.qualPackage q\n+\n+refModule :: Ref -> LF.ModuleName\n+refModule = \\case\n+    RTypeCon q -> LF.qualModule q\n+    RTypeSyn q -> LF.qualModule q\n+    RValue q -> LF.qualModule q\n+\n+type RefGraph = HMS.HashMap Ref (Bool, [Ref])\n+\n+-- | Calculate the set of all references that should be hidden.\n+buildHiddenRefMap :: Env -> HMS.HashMap Ref Bool\n+buildHiddenRefMap env =\n+    case leastFixedPointBy (||) refGraphList of\n+        Left ref -> error\n+            (\"Internal error: missing reference in RefGraph \"\n+            <> show ref)\n+        Right m -> m\n+  where\n+    refGraphList :: [(Ref, Bool, [Ref])]\n+    refGraphList =\n+        [ (ref, hidden, deps)\n+        | (ref, (hidden, deps)) <- HMS.toList refGraph\n+        ]\n+\n+    refGraph :: RefGraph\n+    refGraph = foldl visitRef HMS.empty (rootRefs env)\n+\n+    visitRef :: RefGraph -> Ref -> RefGraph\n+    visitRef !refGraph ref\n+        | HMS.member ref refGraph\n+            = refGraph -- already in the map\n+        | ref == RTypeCon erasedTCon\n+            = HMS.insert ref (True, []) refGraph -- Erased is always erased\n+        | refModule ref == LF.ModuleName [\"DA\", \"Generics\"]\n+            = HMS.insert ref (True, []) refGraph -- DA.Generics is not supported\n+        | LF.PRImport pkgId <- refPackage ref\n+        , Set.member pkgId (configDependencyPackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- dependencies are always available\n+        | LF.PRImport pkgId <- refPackage ref\n+        , MS.member pkgId (configStablePackages (envConfig env))\n+            = HMS.insert ref (False, []) refGraph -- stable pkgs are always available"
  },
  {
    "id" : "cd3e703c-ccc5-47b3-9692-31b3c492a253",
    "prId" : 4571,
    "comments" : [
      {
        "id" : "9ff5bc92-a1f2-4edf-b5fb-5ee452f703dc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Should we error out if it is not a struct of the form that we expect instead of falling into the next case?",
        "createdAt" : "2020-02-18T14:03:40Z",
        "updatedAt" : "2020-02-19T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "54145b2a-a10a-4018-adb3-aae76470d673",
        "parentId" : "9ff5bc92-a1f2-4edf-b5fb-5ee452f703dc",
        "author" : null,
        "body" : "Done!",
        "createdAt" : "2020-02-18T14:54:29Z",
        "updatedAt" : "2020-02-19T11:42:48Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d843761f574e6f6796a82fcbc8421cbc5dd367e9",
    "line" : null,
    "diffHunk" : "@@ -589,12 +589,20 @@ convType env reexported =\n             args <- mapM (convType env reexported) lfArgs\n             pure $ HsParTy noExt (noLoc $ foldl (HsAppTy noExt . noLoc) tyvar (map noLoc args))\n \n+        LF.TApp (LF.TCon LF.Qualified {..}) (LF.TStruct fields)\n+            | qualModule == LF.ModuleName [\"DA\", \"Internal\", \"PromotedText\"]\n+            , [\"PromotedText\"] <- LF.unTypeConName qualObject\n+            , [(LF.FieldName text, LF.TUnit)] <- fields"
  },
  {
    "id" : "29eca33c-0846-4a08-87d3-164e2b7ae63e",
    "prId" : 4571,
    "comments" : [
      {
        "id" : "6f25c142-4858-49c3-8ea8-0004c2faa0ad",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that we have this in a stable package, why nto check the package id?",
        "createdAt" : "2020-02-18T14:03:58Z",
        "updatedAt" : "2020-02-19T11:42:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bcb7962f-76af-4c40-8b0f-b1a66b5f1d53",
        "parentId" : "6f25c142-4858-49c3-8ea8-0004c2faa0ad",
        "author" : null,
        "body" : "Good idea :)",
        "createdAt" : "2020-02-18T14:08:03Z",
        "updatedAt" : "2020-02-19T11:42:48Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "206a34a6-80e7-4d85-9cf1-43fe1d6b6408",
        "parentId" : "6f25c142-4858-49c3-8ea8-0004c2faa0ad",
        "author" : null,
        "body" : "Done!",
        "createdAt" : "2020-02-18T14:54:33Z",
        "updatedAt" : "2020-02-19T11:42:48Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d843761f574e6f6796a82fcbc8421cbc5dd367e9",
    "line" : null,
    "diffHunk" : "@@ -589,12 +589,20 @@ convType env reexported =\n             args <- mapM (convType env reexported) lfArgs\n             pure $ HsParTy noExt (noLoc $ foldl (HsAppTy noExt . noLoc) tyvar (map noLoc args))\n \n+        LF.TApp (LF.TCon LF.Qualified {..}) (LF.TStruct fields)\n+            | qualModule == LF.ModuleName [\"DA\", \"Internal\", \"PromotedText\"]"
  },
  {
    "id" : "109c04d4-32e2-4f22-80f3-5a4bfc46d695",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "92530c4f-d6b6-47ea-8f64-94988ec943c3",
        "parentId" : null,
        "author" : null,
        "body" : "This makes sense to me. If I knew then what I know now about package IDs vs unit IDs, I probably would have done it like this to begin with.",
        "createdAt" : "2020-02-14T12:41:11Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 18,
    "diffHunk" : "@@ -45,9 +47,9 @@ import DA.Daml.Preprocessor.Generics\n import SdkVersion\n \n data Config = Config\n-    { configPackages :: MS.Map UnitId LF.Package\n-        -- ^ maps unit ids to packages, and contain all package dependencies,\n-        -- including stable packages and data dependencies.\n+    { configPackages :: MS.Map LF.PackageId LF.Package"
  },
  {
    "id" : "1f683a2a-5e01-417c-92fe-ae0c0a221fbb",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "29b587f6-efcb-44d7-9831-fd61dd05a8ef",
        "parentId" : null,
        "author" : null,
        "body" : "I see, this map conflates different classes with the same name, but it's ok because this is only an optimization and the real collision check in `isDuplicate` tests that the types are equal. It might be nice to add a comment.",
        "createdAt" : "2020-02-14T13:20:51Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "01c38980-c47c-46df-a39f-aecbb58678fb",
        "parentId" : "29b587f6-efcb-44d7-9831-fd61dd05a8ef",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, I’ve added a comment.",
        "createdAt" : "2020-02-14T13:58:03Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 71,
    "diffHunk" : "@@ -105,12 +108,22 @@ buildDepClassMap :: Config -> DepClassMap\n buildDepClassMap Config{..} = DepClassMap $ MS.fromList\n     [ ((moduleName, synName), (packageId, dsyn))\n     | packageId <- Set.toList configDependencyPackages\n-    , let unitId = configGetUnitId (LF.PRImport packageId)\n-    , Just LF.Package{..} <- [MS.lookup unitId configPackages]\n+    , Just LF.Package{..} <- [MS.lookup packageId configPackages]\n     , LF.Module{..} <- NM.toList packageModules\n     , dsyn@LF.DefTypeSyn{..} <- NM.toList moduleSynonyms\n     ]\n \n+buildDepInstances :: Config -> MS.Map LF.TypeSynName [LF.Type]\n+buildDepInstances Config{..} = MS.fromListWith (<>)\n+    [ (clsName, [snd dvalBinder])\n+    | packageId <- Set.toList configDependencyPackages\n+    , Just LF.Package{..} <- [MS.lookup packageId configPackages]\n+    , LF.Module{..} <- NM.toList packageModules\n+    , LF.DefValue{..} <- NM.toList moduleValues\n+    , Just dfun <- [getDFunSig dvalBinder]\n+    , let clsName = LF.qualObject $ dfhName $ dfsHead dfun"
  },
  {
    "id" : "402e5c3e-74ce-4ddb-befc-2fecc3d1d772",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "2441760b-23e9-4dc4-9059-d1dcdb6f818f",
        "parentId" : null,
        "author" : null,
        "body" : "🤔 it's the same, isn't it?",
        "createdAt" : "2020-02-14T13:22:18Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d3eaf8f7-4be0-451c-82cd-f65d0f5a2aed",
        "parentId" : "2441760b-23e9-4dc4-9059-d1dcdb6f818f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point, I initially thought I need to match on `TUnit` here and forgot to undo the change.",
        "createdAt" : "2020-02-14T14:00:36Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : null,
    "diffHunk" : "@@ -193,8 +219,9 @@ generateSrcFromLf env = noLoc mod\n     classMethodNames = Set.fromList\n         [ methodName\n         | LF.DefTypeSyn{..} <- NM.toList . LF.moduleSynonyms $ envMod env\n-        , LF.TStruct fields <- [synType]\n-        , (fieldName, _) <- fields\n+        , (fieldName, _) <- case synType of\n+                LF.TStruct fields -> fields\n+                _ -> []"
  },
  {
    "id" : "52f67968-7a3e-4bbd-8bbb-b6ebc08c11f7",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "168167d3-3081-47ab-a31e-8e2f902fdbf4",
        "parentId" : null,
        "author" : null,
        "body" : "It might be good to add a small comment explaining when this happens.",
        "createdAt" : "2020-02-14T13:25:29Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "5e7f642c-48ca-4ff1-9684-b934fc2ae8f5",
        "parentId" : "168167d3-3081-47ab-a31e-8e2f902fdbf4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, I added a comment.",
        "createdAt" : "2020-02-14T14:01:29Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 127,
    "diffHunk" : "@@ -203,37 +230,46 @@ generateSrcFromLf env = noLoc mod\n         IEModuleContents noExt (noLoc ghcModName)\n \n     classReexports :: [Gen (LIE GhcPs)]\n-    classReexports = map snd (MS.toList classReexportMap)\n+    classReexports = map snd (MS.elems classReexportMap)\n \n-    classReexportMap :: MS.Map LF.TypeSynName (Gen (LIE GhcPs))\n+    classReexportMap :: MS.Map LF.TypeSynName (LF.PackageId, Gen (LIE GhcPs))\n     classReexportMap = MS.fromList $ do\n         synDef@LF.DefTypeSyn{..} <- NM.toList . LF.moduleSynonyms $ envMod env\n-        LF.TStruct _ <- [synType]\n+        guard $ case synType of\n+            LF.TStruct _ -> True\n+            LF.TUnit -> True"
  },
  {
    "id" : "eeac1c65-c810-4b2b-aa8f-cef3ad693254",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "da6f11f0-c9f0-4d5c-804d-7a0f9ef79e22",
        "parentId" : null,
        "author" : null,
        "body" : "Please update the doc, now that we are generating error calls. :)",
        "createdAt" : "2020-02-14T13:31:44Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "19c70e63-db7e-41ae-8dd4-4b8d5b645636",
        "parentId" : "da6f11f0-c9f0-4d5c-804d-7a0f9ef79e22",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "good idea, updated",
        "createdAt" : "2020-02-14T14:02:16Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : null,
    "diffHunk" : "@@ -432,21 +475,34 @@ mkDataDecl env thisModule occName tyVars cons = do\n -- | Make a binding of the form \"x = x\". If a qualified name is passed,"
  },
  {
    "id" : "ad9f6e94-d6cf-4459-b537-f1ba8efed46e",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "0c46142e-5371-46b0-8e76-3785f7070341",
        "parentId" : null,
        "author" : null,
        "body" : "1) Is this necessary? Shouldn't the fact that the typeclass is being re-exported explicitly, allow us to use the fully qualified name of the module that re-exports it, instead of the module being re-exported? (This is why we re-export typeclasses in the first place.)\r\n\r\n2) If it is necessary, won't this check conflate two typeclasses with the same name? One may be re-exported and the other not. Granted, this is an edge case, but perhaps we should be looking up by qualModule as well.",
        "createdAt" : "2020-02-14T13:37:14Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5c9f8e78-0e47-428b-ae69-2e58a5b0673c",
        "parentId" : "0c46142e-5371-46b0-8e76-3785f7070341",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "1. It is necessary for typeclasses reexported from the current module (those are the only ones in `reexported`). You cannot refer to them qualified using the current module name. I’ve added a comment and factored it out into a separate definition. Does that sounds sensible?\r\n\r\n2. Good point, I’ve added more checks.",
        "createdAt" : "2020-02-14T14:39:59Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cb83f879-adbf-428b-af40-ac9443aa65d2",
        "parentId" : "0c46142e-5371-46b0-8e76-3785f7070341",
        "author" : null,
        "body" : "👍 Ok, I suspected that might be the case, but I really wasn't sure. That also explains why it wasn't an issue in the tests I wrote (they didn't test same module reexports). The `rewriteClassReexport` looks good. Thank you :)",
        "createdAt" : "2020-02-14T14:50:11Z",
        "updatedAt" : "2020-02-14T14:50:25Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : null,
    "diffHunk" : "@@ -467,48 +523,53 @@ isConstraint = \\case\n genModule :: Env -> LF.PackageRef -> LF.ModuleName -> Gen Module\n genModule env pkgRef modName = do\n     let Config{..} = envConfig env\n-        isStable\n-            | LF.PRSelf <- pkgRef = False\n-            | LF.PRImport pkgId <- pkgRef =\n-                pkgId `Set.member` configStablePackages\n+        (packageQualified, modName') = case pkgRef of\n+            LF.PRImport pkgId\n+                | pkgId `Set.member` configDependencyPackages -> (False, prefixDependencyModule pkgId modName)\n+                | pkgId `Set.member` configStablePackages -> (False, prefixModuleName configSdkPrefix modName)\n+            _ -> (True, modName)\n         unitId = configGetUnitId pkgRef\n-    genModuleAux env isStable unitId modName\n+    genModuleAux packageQualified unitId modName'\n \n genStableModule :: Env -> UnitId -> LF.ModuleName -> Gen Module\n-genStableModule env = genModuleAux env True\n-\n-genModuleAux :: Env -> Bool -> UnitId -> LF.ModuleName -> Gen Module\n-genModuleAux env isStable unitId modName = do\n-    let sdkPrefix = configSdkPrefix (envConfig env)\n-        newModName\n-            | isStable = LF.ModuleName (sdkPrefix ++ LF.unModuleName modName)\n-            | otherwise = modName\n-        ghcModName = mkModuleName . T.unpack $ LF.moduleNameString newModName\n-        modRef = ModRef isStable unitId newModName\n+genStableModule env unitId = genModuleAux False unitId . prefixModuleName (configSdkPrefix $ envConfig env)\n+\n+prefixModuleName :: [T.Text] -> LF.ModuleName -> LF.ModuleName\n+prefixModuleName prefix (LF.ModuleName mod) = LF.ModuleName (prefix <> mod)\n+\n+prefixDependencyModule :: LF.PackageId -> LF.ModuleName -> LF.ModuleName\n+prefixDependencyModule (LF.PackageId pkgId) = prefixModuleName [\"Pkg_\" <> pkgId]\n+\n+genModuleAux :: Bool -> UnitId -> LF.ModuleName -> Gen Module\n+genModuleAux isQualified unitId modName = do\n+    let ghcModName = mkModuleName . T.unpack $ LF.moduleNameString modName\n+        modRef = ModRef isQualified unitId modName\n     emitModRef modRef\n     pure $ mkModule unitId ghcModName\n \n-convType :: Env -> LF.Type -> Gen (HsType GhcPs)\n-convType env =\n+convType :: Env -> MS.Map LF.TypeSynName LF.PackageId -> LF.Type -> Gen (HsType GhcPs)\n+convType env reexported =\n     \\case\n         LF.TVar tyVarName -> pure $\n             HsTyVar noExt NotPromoted $ mkRdrName $ LF.unTypeVarName tyVarName\n \n         ty1 LF.:-> ty2 -> do\n-            ty1' <- convType env ty1\n-            ty2' <- convType env ty2\n+            ty1' <- convType env reexported ty1\n+            ty2' <- convType env reexported ty2\n             pure $ if isConstraint ty1\n                 then HsQualTy noExt (noLoc [noLoc ty1']) (noLoc ty2')\n                 else HsParTy noExt (noLoc $ HsFunTy noExt (noLoc ty1') (noLoc ty2'))\n \n         LF.TSynApp LF.Qualified{..} lfArgs -> do\n-            ghcMod <- genModule env qualPackage qualModule\n+            let pkg | Just pkgId <- MS.lookup qualObject reexported = LF.PRImport pkgId"
  },
  {
    "id" : "475507db-1fe5-43bd-b032-13a747ce92de",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "6d06ddc5-cb92-4ce2-8bdc-1b8fc11eafb0",
        "parentId" : null,
        "author" : null,
        "body" : "Happy leave it for a future PR, but I think it makes sense to pass `reexported` inside `env` at this point.",
        "createdAt" : "2020-02-14T13:37:58Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "3a6f521b-9aeb-4caa-ab36-fea20271dbdb",
        "parentId" : "6d06ddc5-cb92-4ce2-8bdc-1b8fc11eafb0",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "good idea, I’ll leave it for a separate PR.",
        "createdAt" : "2020-02-14T14:02:35Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 326,
    "diffHunk" : "@@ -467,48 +523,53 @@ isConstraint = \\case\n genModule :: Env -> LF.PackageRef -> LF.ModuleName -> Gen Module\n genModule env pkgRef modName = do\n     let Config{..} = envConfig env\n-        isStable\n-            | LF.PRSelf <- pkgRef = False\n-            | LF.PRImport pkgId <- pkgRef =\n-                pkgId `Set.member` configStablePackages\n+        (packageQualified, modName') = case pkgRef of\n+            LF.PRImport pkgId\n+                | pkgId `Set.member` configDependencyPackages -> (False, prefixDependencyModule pkgId modName)\n+                | pkgId `Set.member` configStablePackages -> (False, prefixModuleName configSdkPrefix modName)\n+            _ -> (True, modName)\n         unitId = configGetUnitId pkgRef\n-    genModuleAux env isStable unitId modName\n+    genModuleAux packageQualified unitId modName'\n \n genStableModule :: Env -> UnitId -> LF.ModuleName -> Gen Module\n-genStableModule env = genModuleAux env True\n-\n-genModuleAux :: Env -> Bool -> UnitId -> LF.ModuleName -> Gen Module\n-genModuleAux env isStable unitId modName = do\n-    let sdkPrefix = configSdkPrefix (envConfig env)\n-        newModName\n-            | isStable = LF.ModuleName (sdkPrefix ++ LF.unModuleName modName)\n-            | otherwise = modName\n-        ghcModName = mkModuleName . T.unpack $ LF.moduleNameString newModName\n-        modRef = ModRef isStable unitId newModName\n+genStableModule env unitId = genModuleAux False unitId . prefixModuleName (configSdkPrefix $ envConfig env)\n+\n+prefixModuleName :: [T.Text] -> LF.ModuleName -> LF.ModuleName\n+prefixModuleName prefix (LF.ModuleName mod) = LF.ModuleName (prefix <> mod)\n+\n+prefixDependencyModule :: LF.PackageId -> LF.ModuleName -> LF.ModuleName\n+prefixDependencyModule (LF.PackageId pkgId) = prefixModuleName [\"Pkg_\" <> pkgId]\n+\n+genModuleAux :: Bool -> UnitId -> LF.ModuleName -> Gen Module\n+genModuleAux isQualified unitId modName = do\n+    let ghcModName = mkModuleName . T.unpack $ LF.moduleNameString modName\n+        modRef = ModRef isQualified unitId modName\n     emitModRef modRef\n     pure $ mkModule unitId ghcModName\n \n-convType :: Env -> LF.Type -> Gen (HsType GhcPs)\n-convType env =\n+convType :: Env -> MS.Map LF.TypeSynName LF.PackageId -> LF.Type -> Gen (HsType GhcPs)\n+convType env reexported ="
  },
  {
    "id" : "9279a9c2-8198-4a64-b790-b344caf26be9",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "6b783724-f7ec-42ad-bb17-a07991589aa0",
        "parentId" : null,
        "author" : null,
        "body" : "Same issue here -- is it necessary?",
        "createdAt" : "2020-02-14T13:44:34Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ef37e832-bf83-45a1-a77f-5e7187b137d9",
        "parentId" : "6b783724-f7ec-42ad-bb17-a07991589aa0",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "See comment above.",
        "createdAt" : "2020-02-14T14:40:52Z",
        "updatedAt" : "2020-02-14T14:40:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : null,
    "diffHunk" : "@@ -904,21 +972,24 @@ getDFunSig (valName, valType) = do\n         Just $ fst (T.breakOn \"\\\"\" name')\n \n -- | Convert dictionary function signature into a DAML type.\n-convDFunSig :: Env -> DFunSig -> Gen (HsType GhcPs)\n-convDFunSig env DFunSig{..} = do\n+convDFunSig :: Env -> MS.Map LF.TypeSynName LF.PackageId -> DFunSig -> Gen (HsType GhcPs)\n+convDFunSig env reexported DFunSig{..} = do\n     binders <- mapM (convTyVarBinder env) dfsBinders\n-    context <- mapM (convType env) dfsContext\n+    context <- mapM (convType env reexported) dfsContext\n     let headName = dfhName dfsHead\n-    ghcMod <- genModule env (LF.qualPackage headName) (LF.qualModule headName)\n+    let pkg = case MS.lookup (LF.qualObject headName) reexported of"
  },
  {
    "id" : "0e6febb8-4446-4ffd-a743-bbc38775502b",
    "prId" : 4490,
    "comments" : [
      {
        "id" : "3e2a1e8a-9f4c-4b2d-85f2-cf3d6e2dc2bf",
        "parentId" : null,
        "author" : null,
        "body" : "Might be nice to rename these fields to `dfhName`, etc",
        "createdAt" : "2020-02-12T13:16:46Z",
        "updatedAt" : "2020-02-12T13:22:17Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "27c70b65-de9e-43f2-a1d5-7b3c148868c1",
        "parentId" : "3e2a1e8a-9f4c-4b2d-85f2-cf3d6e2dc2bf",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point, thanks!",
        "createdAt" : "2020-02-12T13:22:29Z",
        "updatedAt" : "2020-02-12T13:22:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fde4d6ef7846ceab3d5b529fd4990a4e1d83cf91",
    "line" : null,
    "diffHunk" : "@@ -838,25 +838,31 @@ isSuperClassField (LF.FieldName fieldName) =\n     \"s_\" `T.isPrefixOf` fieldName\n \n -- | Signature data for a dictionary function.\n-data DFunSig\n-    = DFunSigNormal -- ^ signature for a normal dictionary function\n-        { dfsType :: !LF.Type -- ^ LF type signature for the dictionary function\n-        }\n-    | DFunSigHasField -- ^ signature for a HasField dictionary function\n-        { dfsBinders :: ![(LF.TypeVarName, LF.Kind)] -- ^ foralls\n-        , dfsContext :: ![LF.Type] -- ^ constraints\n-        , dfsName :: LF.Qualified LF.TypeSynName -- ^ name of type synonym\n-        , dfsField :: !T.Text -- ^ first arg (a type level string)\n-        , dfsArgs :: ![LF.Type] -- ^ rest of the args\n-        }\n+data DFunSig = DFunSig\n+    { dfsBinders :: ![(LF.TypeVarName, LF.Kind)] -- ^ foralls\n+    , dfsContext :: ![LF.Type] -- ^ constraints\n+    , dfsHead :: !DFunHead\n+    }\n+\n+-- | Instance declaration head\n+data DFunHead\n+    = DFunHeadHasField -- ^ HasField instance\n+          { dfsName :: LF.Qualified LF.TypeSynName -- ^ name of type synonym\n+          , dfsField :: !T.Text -- ^ first arg (a type level string)\n+          , dfsArgs :: [LF.Type] -- ^ rest of the args\n+          }\n+    | DFunHeadNormal -- ^ Normal, i.e., non-HasField, instance\n+          { dfsName :: LF.Qualified LF.TypeSynName -- ^ name of type synonym\n+          , dfsArgs :: [LF.Type] -- ^ arguments"
  },
  {
    "id" : "001b1641-1e03-48c2-a441-19853bf05b10",
    "prId" : 4488,
    "comments" : [
      {
        "id" : "6b1163e6-5d4c-4bff-b3a3-e476c62e2b45",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not entirely sure this is necessary given the context where typeclasses appear but `HsAppTy` definitely needs parentheses in some cases so I’d rather just always add them.",
        "createdAt" : "2020-02-12T11:00:24Z",
        "updatedAt" : "2020-02-12T11:00:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d6827196-b651-40ba-8c53-3184eed5e5dc",
        "parentId" : "6b1163e6-5d4c-4bff-b3a3-e476c62e2b45",
        "author" : null,
        "body" : "Sounds good, & might as well.",
        "createdAt" : "2020-02-12T12:55:13Z",
        "updatedAt" : "2020-02-12T12:55:14Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "217240b0f8df55e5dab2736f7148a4685ee8949c",
    "line" : 14,
    "diffHunk" : "@@ -509,7 +509,7 @@ convType env =\n                 tyvar = HsTyVar noExt NotPromoted . noLoc\n                     . mkOrig ghcMod . mkOccName clsName $ T.unpack tyname\n             args <- mapM (convType env) lfArgs\n-            pure $ foldl (HsAppTy noExt . noLoc) tyvar (map noLoc args)\n+            pure $ HsParTy noExt (noLoc $ foldl (HsAppTy noExt . noLoc) tyvar (map noLoc args))"
  },
  {
    "id" : "029410ee-4bf7-4250-a2e7-83ebcedd60cf",
    "prId" : 4474,
    "comments" : [
      {
        "id" : "2a39b8ec-faad-400e-9edc-689ea8fc00ad",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n            -- We handle both the old state where symbol was translated to unit\r\n```",
        "createdAt" : "2020-02-11T21:26:32Z",
        "updatedAt" : "2020-02-11T21:57:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9ada9a757fbb117d5c645e777b7623f8be5b1cd5",
    "line" : null,
    "diffHunk" : "@@ -856,7 +856,13 @@ getDFunSig (valName, valType) = do\n     (dfsBinders, dfsContext, dfsName, args) <- go valType\n     if isHasField dfsName\n         then do\n-            (LF.TUnit : dfsArgs) <- Just args\n+            (symbolTy : dfsArgs) <- Just args\n+            -- We handle both the old state where symbol was translated to True"
  },
  {
    "id" : "edb77c08-adcb-4245-8dca-d7886deabff4",
    "prId" : 4377,
    "comments" : [
      {
        "id" : "545e4961-e34b-4a65-bcda-8affdb752cda",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if it might be slightly less hacky to search for a record selector in the body? Don’t really have a strong opinion here so happy to go with this for now.",
        "createdAt" : "2020-02-04T14:41:10Z",
        "updatedAt" : "2020-02-04T14:44:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0812c58c-f9b4-4a11-9fbc-d9ff5cd5944b",
        "parentId" : "545e4961-e34b-4a65-bcda-8affdb752cda",
        "author" : null,
        "body" : "I think either way is fine, but this seems a little bit simpler, and should handle custom `HasField` instances better. (Not that I suggest anybody write those, but you never know.)",
        "createdAt" : "2020-02-04T15:01:38Z",
        "updatedAt" : "2020-02-04T15:01:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "11ace7345f8f6eed774640514b8e9f30ebc621d8",
    "line" : 111,
    "diffHunk" : "@@ -860,3 +836,81 @@ getClassMethodName (LF.FieldName fieldName) =\n isSuperClassField :: LF.FieldName -> Bool\n isSuperClassField (LF.FieldName fieldName) =\n     \"s_\" `T.isPrefixOf` fieldName\n+\n+-- | Signature data for a dictionary function.\n+data DFunSig\n+    = DFunSigNormal -- ^ signature for a normal dictionary function\n+        { dfsType :: !LF.Type -- ^ LF type signature for the dictionary function\n+        }\n+    | DFunSigHasField -- ^ signature for a HasField dictionary function\n+        { dfsBinders :: ![(LF.TypeVarName, LF.Kind)] -- ^ foralls\n+        , dfsContext :: ![LF.Type] -- ^ constraints\n+        , dfsName :: LF.Qualified LF.TypeSynName -- ^ name of type synonym\n+        , dfsField :: !T.Text -- ^ first arg (a type level string)\n+        , dfsArgs :: ![LF.Type] -- ^ rest of the args\n+        }\n+\n+-- | Break a value type signature down into a dictionary function signature.\n+getDFunSig :: (LF.ExprValName, LF.Type) -> Maybe DFunSig\n+getDFunSig (valName, valType) = do\n+    (dfsBinders, dfsContext, dfsName, args) <- go valType\n+    if isHasField dfsName\n+        then do\n+            (LF.TUnit : dfsArgs) <- Just args\n+            dfsField <- getFieldArg valName\n+            guard (not $ T.null dfsField)\n+            Just DFunSigHasField {..}\n+        else\n+            Just DFunSigNormal { dfsType = valType }\n+  where\n+    -- | Break a dictionary function type down into a tuple\n+    -- (foralls, constraints, synonym name, args).\n+    go = \\case\n+        LF.TForall b rest -> do\n+            (bs, cs, name, args) <- go rest\n+            Just (b:bs, cs, name, args)\n+        (LF.:->) c rest -> do\n+            guard (isConstraint c)\n+            (bs, cs, name, args) <- go rest\n+            Just (bs, c:cs, name, args)\n+        LF.TSynApp name args -> do\n+            Just ([], [], name, args)\n+        _ ->\n+            Nothing\n+\n+    -- | Is this an instance of the HasField typeclass?\n+    isHasField :: LF.Qualified LF.TypeSynName -> Bool\n+    isHasField LF.Qualified{..} =\n+        qualModule == LF.ModuleName [\"DA\", \"Internal\", \"Record\"]\n+        && qualObject == LF.TypeSynName [\"HasField\"]\n+\n+    -- | Get the first arg of HasField (the name of the field) from\n+    -- the name of the binding.\n+    getFieldArg :: LF.ExprValName -> Maybe T.Text\n+    getFieldArg (LF.ExprValName name) = do\n+        name' <- T.stripPrefix \"$fHasField\\\"\" name"
  },
  {
    "id" : "0140a96b-dd8c-4170-ba4f-b8f601b12b0e",
    "prId" : 4353,
    "comments" : [
      {
        "id" : "08100281-78b7-4a8f-adbd-9ba1883a5a1f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    closedType LF.DefTypeSyn{..} = mkTForalls synParams synType\r\n```",
        "createdAt" : "2020-02-03T15:12:07Z",
        "updatedAt" : "2020-02-03T15:31:16Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9b358a27-d154-4d15-9209-a966903d58be",
        "parentId" : "08100281-78b7-4a8f-adbd-9ba1883a5a1f",
        "author" : null,
        "body" : "Nice, thank you :)",
        "createdAt" : "2020-02-03T15:22:32Z",
        "updatedAt" : "2020-02-03T15:31:16Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "361ed88af36c91eeb1f3dbd93a4494d9e8408437",
    "line" : null,
    "diffHunk" : "@@ -88,19 +118,20 @@ envLookupDepClass synName env =\n     in MS.lookup (modName, synName) classMap\n \n -- | Determine whether two type synonym definitions are similar enough to\n--- reexport one as the other. Theoretically what is needed here is alpha\n--- equivalence after expanding all type synonyms. This is quite involved,\n--- so for now we're going to assume that if the list of parameters is the\n--- same length, and the list of field names is the same, then it's safe to\n--- re-export. This is an over-approximation, so this may cause re-exports\n--- that aren't actually safe. (TODO: Move to type-synonym expanding alpha\n--- equivalence).\n-safeToReexport :: LF.DefTypeSyn -> LF.DefTypeSyn -> Bool\n-safeToReexport syn1 syn2 = fromMaybe False $ do\n-    LF.TStruct fields1 <- pure (LF.synType syn1)\n-    LF.TStruct fields2 <- pure (LF.synType syn2)\n-    pure $ length (LF.synParams syn1) == length (LF.synParams syn2)\n-        && map fst fields1 == map fst fields2\n+-- reexport one as the other. This is done by computing alpha equivalence\n+-- after expanding all type synonyms.\n+safeToReexport :: Env -> LF.DefTypeSyn -> LF.DefTypeSyn -> Bool\n+safeToReexport env syn1 syn2 =\n+    fromRight False $ do\n+        LF.runGamma (envWorld env) (envLfVersion env) $ do\n+            esyn1 <- LF.expandTypeSynonyms (closedType syn1)\n+            esyn2 <- LF.expandTypeSynonyms (closedType syn2)\n+            pure (LF.alphaEquiv esyn1 esyn2)\n+\n+  where\n+    -- | Turn a type synonym definition into a closed type.\n+    closedType :: LF.DefTypeSyn -> LF.Type\n+    closedType LF.DefTypeSyn{..} = foldr LF.TForall synType synParams"
  },
  {
    "id" : "f81a311b-9934-449a-9538-b9e2ddca0017",
    "prId" : 4336,
    "comments" : [
      {
        "id" : "dc636009-9731-43d6-96c9-a87b9364edc8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n-- name pair to a corresponding dependency package id and the definition of the synonym.\r\n```",
        "createdAt" : "2020-02-03T08:05:50Z",
        "updatedAt" : "2020-02-03T11:00:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cc03943c-e619-40ad-a552-2c59f340d3b0",
        "parentId" : "dc636009-9731-43d6-96c9-a87b9364edc8",
        "author" : null,
        "body" : "Thanks for catching this!",
        "createdAt" : "2020-02-03T10:12:25Z",
        "updatedAt" : "2020-02-03T11:00:51Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f7a75365b89d256e55bf0795b4284729c3b038de",
    "line" : null,
    "diffHunk" : "@@ -38,15 +39,60 @@ import qualified DA.Daml.LF.Ast as LF\n import DA.Daml.Preprocessor.Generics\n import SdkVersion\n \n+data Config = Config\n+    { configPackages :: MS.Map UnitId LF.Package\n+    , configGetUnitId :: LF.PackageRef -> UnitId\n+    , configStablePackages :: Set LF.PackageId\n+    , configDependencyPackages :: Set LF.PackageId\n+    , configSdkPrefix :: [T.Text]\n+    }\n+\n data Env = Env\n-    { envPkgs :: MS.Map UnitId LF.Package\n-    , envGetUnitId :: LF.PackageRef -> UnitId\n-    , envStablePackages :: Set LF.PackageId\n+    { envConfig :: Config\n     , envQualify :: Bool\n-    , envSdkPrefix :: Maybe String\n+    , envDepClassMap :: DepClassMap\n     , envMod :: LF.Module\n     }\n \n+-- | Type classes coming from dependencies. This maps a (module, synonym)\n+-- name pair to a corresponding dependency package id and list of fields."
  },
  {
    "id" : "b890c0cc-2a9f-4121-b1ee-8e0120f27b4a",
    "prId" : 4336,
    "comments" : [
      {
        "id" : "0b2b4fe6-d0c6-46f2-ad73-62048ec9dc8b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Might be nice to add a comment here explaining the relationship between `configPackages`, `configStablePackages` and `configDependencyPackages`. I guess `configPackages` includes stable packages, dependencies and data-dependencies?",
        "createdAt" : "2020-02-03T08:08:48Z",
        "updatedAt" : "2020-02-03T11:00:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3eb60a98-55ea-422b-9daa-e2b0237edd0b",
        "parentId" : "0b2b4fe6-d0c6-46f2-ad73-62048ec9dc8b",
        "author" : null,
        "body" : "Improved the docs here. I also switched gave `envQualify` a more explicit name and switched it (`True -> False`) since it was confusing to me.",
        "createdAt" : "2020-02-03T10:13:19Z",
        "updatedAt" : "2020-02-03T11:00:51Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "f7a75365b89d256e55bf0795b4284729c3b038de",
    "line" : 22,
    "diffHunk" : "@@ -38,15 +39,60 @@ import qualified DA.Daml.LF.Ast as LF\n import DA.Daml.Preprocessor.Generics\n import SdkVersion\n \n+data Config = Config\n+    { configPackages :: MS.Map UnitId LF.Package\n+    , configGetUnitId :: LF.PackageRef -> UnitId\n+    , configStablePackages :: Set LF.PackageId\n+    , configDependencyPackages :: Set LF.PackageId"
  },
  {
    "id" : "c450626f-007d-40e3-87e0-18c52f4c4e97",
    "prId" : 4326,
    "comments" : [
      {
        "id" : "d3feb21d-d92b-4564-911c-13992a2f7a2b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe `mkStubBind` would be a better name?",
        "createdAt" : "2020-01-31T13:38:26Z",
        "updatedAt" : "2020-01-31T13:49:22Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b33ee3a8-80a6-4b69-917c-26d8a9d2046e",
        "parentId" : "d3feb21d-d92b-4564-911c-13992a2f7a2b",
        "author" : null,
        "body" : "I'll change it in the next PR, thanks!",
        "createdAt" : "2020-01-31T14:20:02Z",
        "updatedAt" : "2020-01-31T14:20:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c598bf91f25a67ef3aef8f21d597e8bdf4aa0f5c",
    "line" : 96,
    "diffHunk" : "@@ -288,6 +342,21 @@ mkDataDecl env thisModule occName tyVars cons = do\n                 }\n         }\n \n+-- | Make a binding of the form \"x = x\". If a qualified name is passed,\n+-- we turn the left-hand side into the unqualified form of that name (LHS\n+-- must always be unqualified), and the right-hand side remains qualified.\n+mkTrivialBind :: Located RdrName -> HsBind GhcPs"
  },
  {
    "id" : "76e8054a-4434-4ddf-8816-3444923d77b9",
    "prId" : 4326,
    "comments" : [
      {
        "id" : "ea3b0f33-0e95-4669-852c-a10f4845aa79",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a reason why we don’t just generate an empty instance?",
        "createdAt" : "2020-01-31T13:45:26Z",
        "updatedAt" : "2020-01-31T13:49:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "96d6f7ba-e3df-474f-8e92-f1df087662cb",
        "parentId" : "ea3b0f33-0e95-4669-852c-a10f4845aa79",
        "author" : null,
        "body" : "Ah, I just assumed that wouldn't work. I'll try it out.",
        "createdAt" : "2020-01-31T14:02:20Z",
        "updatedAt" : "2020-01-31T14:02:21Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a46bd1aa-bf9f-480a-b07b-49e761a6a8e6",
        "parentId" : "ea3b0f33-0e95-4669-852c-a10f4845aa79",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We probably want to silence the warning but apart from that I don’t see why it shouldn’t work.",
        "createdAt" : "2020-01-31T14:04:41Z",
        "updatedAt" : "2020-01-31T14:04:41Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c598bf91f25a67ef3aef8f21d597e8bdf4aa0f5c",
    "line" : 43,
    "diffHunk" : "@@ -163,16 +166,67 @@ generateSrcFromLf env = noLoc mod\n             lname = mkRdrName (LF.unExprValName lfName) :: Located RdrName\n             sig = TypeSig noExt [lname] . HsWC noExt . HsIB noExt <$> ltype\n             lsigD = noLoc . SigD noExt <$> sig :: Gen (LHsDecl GhcPs)\n-            lexpr = noLoc $ HsPar noExt $ noLoc $ HsVar noExt lname :: LHsExpr GhcPs\n-            lgrhs = noLoc $ GRHS noExt [] lexpr :: LGRHS GhcPs (LHsExpr GhcPs)\n-            grhss = GRHSs noExt [lgrhs] (noLoc $ EmptyLocalBinds noExt)\n-            matchContext = FunRhs lname Prefix NoSrcStrict\n-            lmatch = noLoc $ Match noExt matchContext [] Nothing grhss\n-            lalts = noLoc [lmatch]\n-            bind = FunBind noExt lname (MG noExt lalts Generated) WpHole []\n+            bind = mkTrivialBind lname\n             lvalD = noLoc $ ValD noExt bind :: LHsDecl GhcPs\n         [ lsigD, pure lvalD ]\n \n+    -- | Generate instance declarations from dictionary functions.\n+    instanceDecls :: [Gen (LHsDecl GhcPs)]\n+    instanceDecls = do\n+        LF.DefValue {..} <- NM.toList $ LF.moduleValues $ envMod env\n+        let dvalType = snd dvalBinder\n+        Just qname@LF.Qualified{..} <- [getDFunClassName dvalType]\n+        Just fieldNames <- [getDFunFieldNames dvalBody]\n+        guard (not (isHasField qname))\n+        pure $ do\n+            polyTy <- HsIB noExt . noLoc <$> convType env dvalType\n+            ghcMod <- genModule env qualPackage qualModule\n+            pure . noLoc . InstD noExt . ClsInstD noExt $ ClsInstDecl\n+                { cid_ext = noExt\n+                , cid_poly_ty = polyTy\n+                , cid_binds = listToBag (mapMaybe (mkBind ghcMod) fieldNames)"
  },
  {
    "id" : "84bcc922-d7be-45b1-9400-2cbe772a41ef",
    "prId" : 4326,
    "comments" : [
      {
        "id" : "59d74463-50b1-4486-ad1c-a4bca2d4ef13",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Where are they generated? I thought we don’t run the preprocessor on generated sources. Might be good to add a test for this (if it doesn’t work, let’s do it in a separate PR).\r\n\r\nReconstructing those instances from DAML-LF is a bit tricky since the type-level strings are lost. For `HasField` we can probably get the field name fairly easily from the body. A bit gross but probably fairly reasonable. The only other instance that I remember that relies heavily on type-level stuff that is lost in the translation to LF is `Generic` and for now, I would just ignore that (but probably also good to have a testcase for this, happy to do it in a separate PR)",
        "createdAt" : "2020-01-31T13:46:37Z",
        "updatedAt" : "2020-01-31T13:49:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "41a80270-4b17-41d8-a0e6-7ba221270c44",
        "parentId" : "59d74463-50b1-4486-ad1c-a4bca2d4ef13",
        "author" : null,
        "body" : "We could just run the daml-preprocessor step for records, rather than recreating that. Since we'll (soon) re-export the typeclasses, we don't even need to change the prefix.\r\n\r\n(We should also be able to drop the `CurrentSdk` prefix logic from the enum type preprocessor as well.)\r\n\r\nI'll handle this in a separate PR.",
        "createdAt" : "2020-01-31T14:12:16Z",
        "updatedAt" : "2020-01-31T14:12:31Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f3215563-67fc-47ab-ad99-5a8ed90d1ce8",
        "parentId" : "59d74463-50b1-4486-ad1c-a4bca2d4ef13",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The problem with that is that then you will get the stub instances even if the DALF does not contain the instances. Probably not a huge deal in practice but it feels a bit fragile.",
        "createdAt" : "2020-01-31T14:14:26Z",
        "updatedAt" : "2020-01-31T14:14:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6024f012-33b9-4be1-8250-a042bf5c875b",
        "parentId" : "59d74463-50b1-4486-ad1c-a4bca2d4ef13",
        "author" : null,
        "body" : "Hmm, I see. I guess the safer thing is to make the stub instance by reconstructing the field name from the body of the HasField instance. That's definitely a separate PR.",
        "createdAt" : "2020-01-31T14:18:57Z",
        "updatedAt" : "2020-01-31T14:18:57Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c598bf91f25a67ef3aef8f21d597e8bdf4aa0f5c",
    "line" : 53,
    "diffHunk" : "@@ -163,16 +166,67 @@ generateSrcFromLf env = noLoc mod\n             lname = mkRdrName (LF.unExprValName lfName) :: Located RdrName\n             sig = TypeSig noExt [lname] . HsWC noExt . HsIB noExt <$> ltype\n             lsigD = noLoc . SigD noExt <$> sig :: Gen (LHsDecl GhcPs)\n-            lexpr = noLoc $ HsPar noExt $ noLoc $ HsVar noExt lname :: LHsExpr GhcPs\n-            lgrhs = noLoc $ GRHS noExt [] lexpr :: LGRHS GhcPs (LHsExpr GhcPs)\n-            grhss = GRHSs noExt [lgrhs] (noLoc $ EmptyLocalBinds noExt)\n-            matchContext = FunRhs lname Prefix NoSrcStrict\n-            lmatch = noLoc $ Match noExt matchContext [] Nothing grhss\n-            lalts = noLoc [lmatch]\n-            bind = FunBind noExt lname (MG noExt lalts Generated) WpHole []\n+            bind = mkTrivialBind lname\n             lvalD = noLoc $ ValD noExt bind :: LHsDecl GhcPs\n         [ lsigD, pure lvalD ]\n \n+    -- | Generate instance declarations from dictionary functions.\n+    instanceDecls :: [Gen (LHsDecl GhcPs)]\n+    instanceDecls = do\n+        LF.DefValue {..} <- NM.toList $ LF.moduleValues $ envMod env\n+        let dvalType = snd dvalBinder\n+        Just qname@LF.Qualified{..} <- [getDFunClassName dvalType]\n+        Just fieldNames <- [getDFunFieldNames dvalBody]\n+        guard (not (isHasField qname))\n+        pure $ do\n+            polyTy <- HsIB noExt . noLoc <$> convType env dvalType\n+            ghcMod <- genModule env qualPackage qualModule\n+            pure . noLoc . InstD noExt . ClsInstD noExt $ ClsInstDecl\n+                { cid_ext = noExt\n+                , cid_poly_ty = polyTy\n+                , cid_binds = listToBag (mapMaybe (mkBind ghcMod) fieldNames)\n+                , cid_sigs = []\n+                , cid_tyfam_insts = []\n+                , cid_datafam_insts = []\n+                , cid_overlap_mode = Nothing\n+                }\n+\n+      where\n+\n+        -- | Filter out HasField instances, since they are generated separately.\n+        isHasField :: LF.Qualified LF.TypeSynName -> Bool"
  },
  {
    "id" : "490ec370-6e44-4a94-8f4c-c8ac341f9ef0",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "448e690e-15a0-409e-9e14-02d0a9b93dd9",
        "parentId" : null,
        "author" : null,
        "body" : "By the way, this is 100% a module reference we weren't tracking before, but since GHC.Types is pretty commonly depended on, it didn't cause problems in practice.",
        "createdAt" : "2020-01-29T19:17:42Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "23e1cfb4-f491-4028-b4a5-e4bb3c637354",
        "parentId" : "448e690e-15a0-409e-9e14-02d0a9b93dd9",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yeah, the new approach is a lot less fragile :+1:",
        "createdAt" : "2020-01-30T08:27:07Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : 579,
    "diffHunk" : "@@ -468,18 +424,21 @@ errTooManyNameComponents cs =\n     \"Internal error: Dalf contains type constructors with more than two name components: \" <>\n     (T.unpack $ T.intercalate \".\" cs)\n \n-convKind :: Env -> LF.Kind -> LHsKind GhcPs\n+convKind :: Env -> LF.Kind -> Gen (LHsKind GhcPs)\n convKind env = \\case\n-    LF.KStar -> noLoc $ HsStarTy noExt False\n-    LF.KNat -> noLoc $ mkGhcType \"Nat\"\n-    LF.KArrow k1 k2 -> noLoc $ HsFunTy noExt (convKind env k1) (convKind env k2)\n-\n-convTyVarBinder :: Env -> (LF.TypeVarName, LF.Kind) -> LHsTyVarBndr GhcPs\n+    LF.KStar -> pure . noLoc $ HsStarTy noExt False\n+    LF.KNat -> noLoc <$> mkGhcType env \"Nat\""
  },
  {
    "id" : "a3067bc6-5f5f-4092-bcd0-4ff0c028379c",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "6373f9d9-057d-4cee-92ca-4ede4a335323",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We probably want `Control.Monad.Trans.Writer.CPS` from `transformers` to avoid the spaceleak of the standard one. Not sure it makes much of a difference here but it should be a drop-in replacement.",
        "createdAt" : "2020-01-30T06:04:04Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d3391a3e-1789-4288-944f-67bc046c6710",
        "parentId" : "6373f9d9-057d-4cee-92ca-4ede4a335323",
        "author" : null,
        "body" : "Not quite a drop-in replacement (it doesn't implement `MonadWriter` ... which is a bad typeclass in any case), but that does seem better. I made the switch.",
        "createdAt" : "2020-01-30T12:25:57Z",
        "updatedAt" : "2020-01-31T11:44:01Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : null,
    "diffHunk" : "@@ -7,9 +7,8 @@ module DA.Daml.Compiler.DataDependencies\n     , splitUnitId\n     ) where\n \n-import Control.Lens (toListOf)\n-import Control.Lens.MonoTraversal (monoTraverse)\n import Control.Monad\n+import Control.Monad.Writer"
  },
  {
    "id" : "46f0b37c-5569-4244-a8a9-75229b2f4af3",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "d4c50c81-f2e0-416b-a530-ec989915abf8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not partiuclarly important here since `secondM` is a fairly descriptive name but as a general guideline, I prefer to avoid GHC’s utility modules since they’re not something that people are very familiar with (at least I’m not). Annoyingly, `Data.Bitraversable` does not have these here so you would need `bitraverse pure`, `traverse` or a lensy `traverseOf _2` none of which really seem better, so happy to keep it :)",
        "createdAt" : "2020-01-30T06:10:23Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ead5a81-2caa-40f5-993f-a074629b50fd",
        "parentId" : "d4c50c81-f2e0-416b-a530-ec989915abf8",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I assume `secondM = \\f (x, y) -> (x ,) <$> f y`. That seems short enough to inline it, like below.",
        "createdAt" : "2020-01-30T10:06:56Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e43bdf2b-c3e3-477a-aa94-8368317257f8",
        "parentId" : "d4c50c81-f2e0-416b-a530-ec989915abf8",
        "author" : null,
        "body" : "I'll get rid of `secondM`, I just thought it made the code more tidy.\r\n\r\nIt feels like `secondM` should really be in `Data.Tuple.Extra`, but I digress.",
        "createdAt" : "2020-01-30T11:30:50Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3083a06f-3903-446a-a3a1-b7a539e0e4a3",
        "parentId" : "d4c50c81-f2e0-416b-a530-ec989915abf8",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "@ndmitchell seems to be very liberal with accepting contributions to `extra`. It should probably be `secondA` (or `secondF`?) though.",
        "createdAt" : "2020-01-30T12:02:09Z",
        "updatedAt" : "2020-01-31T11:44:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : null,
    "diffHunk" : "@@ -34,9 +33,9 @@ import \"ghc-lib-parser\" RdrName\n import \"ghc-lib-parser\" TcEvidence (HsWrapper (WpHole))\n import \"ghc-lib-parser\" TysPrim\n import \"ghc-lib-parser\" TysWiredIn\n+import \"ghc-lib-parser\" Util (secondM)"
  },
  {
    "id" : "062ab17e-eef2-4a21-869d-b1f22cab60a8",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "5deca470-532d-41fa-b4ea-1f42cb7e3eca",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I thought `ghc-mod` is dead :trollface: ",
        "createdAt" : "2020-01-30T08:28:21Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : 623,
    "diffHunk" : "@@ -507,39 +465,27 @@ sumProdRecords m =\n         , LF.DataRecord fs <- [dataCons]\n         ]\n \n-mkTyConType :: Bool -> TyCon -> HsType GhcPs\n-mkTyConType qualify tyCon\n-    | qualify =\n-        HsTyVar noExt NotPromoted . noLoc $\n-        mkRdrQual (moduleName $ nameModule name) (occName name)\n-    | otherwise = HsTyVar noExt NotPromoted . noLoc $ mkRdrUnqual (occName name)\n-  where\n-    name = getName tyCon\n+mkStableType :: Env -> UnitId -> LF.ModuleName -> String -> Gen (HsType GhcPs)\n+mkStableType env unitId modName tyName = do\n+    ghcMod <- genStableModule env unitId modName"
  },
  {
    "id" : "c23bebbc-99e4-4cae-89a3-1e30e2a86f6a",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "045a76dc-b58a-4903-923f-a24e005767e2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I really hate that GHC’s `Module` type is not a module but just a reference to it. This makes the names here a bit confusing since it sounds like we are generating the source for a module. But I don’t really have a less confusing suggestion sadly :disappointed: ",
        "createdAt" : "2020-01-30T08:31:15Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "99026068-3c5e-4ca7-ad26-4cc063afb7a8",
        "parentId" : "045a76dc-b58a-4903-923f-a24e005767e2",
        "author" : null,
        "body" : "I agree, `Module` is very counterintuitive name for a module reference.",
        "createdAt" : "2020-01-30T11:34:07Z",
        "updatedAt" : "2020-01-31T11:44:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : 387,
    "diffHunk" : "@@ -355,29 +306,53 @@ isConstraint = \\case\n         ]\n     _ -> False\n \n-convType :: Env -> LF.Type -> HsType GhcPs\n+genModule :: Env -> LF.PackageRef -> LF.ModuleName -> Gen Module"
  },
  {
    "id" : "99b8edd5-a1f9-41f5-8345-92ab9cbc0454",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "68713d50-c96e-44c9-bbba-6dd0d5b8d8db",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                sequence [ (methodName,) <$> convTyp env fieldType\r\n```",
        "createdAt" : "2020-01-30T10:07:52Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "58913a96-e877-4257-bef5-7b2998eb858c",
        "parentId" : "68713d50-c96e-44c9-bbba-6dd0d5b8d8db",
        "author" : null,
        "body" : "that was my first version of this code, hehe :-) ",
        "createdAt" : "2020-01-30T11:31:21Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : null,
    "diffHunk" : "@@ -86,44 +97,45 @@ generateSrcFromLf env = noLoc mod\n         , Just methodName <- [getClassMethodName fieldName]\n         ]\n \n-    classDecls :: [LHsDecl GhcPs]\n+    classDecls :: [Gen (LHsDecl GhcPs)]\n     classDecls = do\n         LF.DefTypeSyn{..} <- NM.toList . LF.moduleSynonyms $ envMod env\n         LF.TStruct fields <- [synType]\n         LF.TypeSynName [name] <- [synName]\n \n-        let supers =\n-                [ convType env fieldType\n+        let occName = mkOccName clsName . T.unpack $ sanitize name\n+        pure $ do\n+            supers <- mapM (convType env)\n+                [ fieldType\n                 | (fieldName, LF.TUnit LF.:-> fieldType) <- fields\n                 , isSuperClassField fieldName\n                 ]\n-\n-            methods =\n-                [ (methodName, convType env fieldType)\n+            methods <- mapM (secondM (convType env))\n+                [ (methodName,fieldType)"
  },
  {
    "id" : "79c8f10b-f5a3-4ead-bdb2-2f965d87a34d",
    "prId" : 4251,
    "comments" : [
      {
        "id" : "2b34b75e-cfbb-408a-af6e-1cac48fe9ccd",
        "parentId" : null,
        "author" : null,
        "body" : "I *think* this is an unrelated bugfix.",
        "createdAt" : "2020-01-28T17:37:55Z",
        "updatedAt" : "2020-01-28T17:43:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "63f579c9-edbf-4fe2-8ec2-c1e182fa7524",
        "parentId" : "2b34b75e-cfbb-408a-af6e-1cac48fe9ccd",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This really should be in HLint :slightly_smiling_face: ",
        "createdAt" : "2020-01-28T17:41:30Z",
        "updatedAt" : "2020-01-28T17:43:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "60062de322cb4c820a5af20895251bc92fd8e88e",
    "line" : 46,
    "diffHunk" : "@@ -193,94 +199,94 @@ generateSrcFromLf env = noLoc mod\n             { ideclExt = noExt\n             , ideclSourceSrc = NoSourceText\n             , ideclName =\n-                  noLoc $ mkModuleName $ T.unpack $ LF.moduleNameString modRef\n-            , ideclPkgQual =\n-              if isStable\n-                then Nothing -- we don’t do package qualified imports for modules that should come from the current SDK.\n-                else Just $ StringLiteral NoSourceText $ mkFastString $\n-                  -- Package qualified imports for the current package need to use \"this\" instead\n-                  -- of the package id.\n-                  if refUnitId == unitId then \"this\" else fst (splitUnitId $ unitIdString refUnitId)\n+                  noLoc $ mkModuleName $ T.unpack $ LF.moduleNameString modRefModule\n+            , ideclPkgQual = do\n+                guard modRefIsStable -- we don’t do package qualified imports\n+                    -- for modules that should come from the current SDK.\n+                Just $ StringLiteral NoSourceText $ mkFastString $\n+                    -- Package qualified imports for the current package\n+                    -- need to use \"this\" instead of the package id.\n+                    if modRefUnitId == unitId\n+                        then \"this\"\n+                        else fst (splitUnitId $ unitIdString modRefUnitId)\n             , ideclSource = False\n             , ideclSafe = False\n             , ideclImplicit = False\n             , ideclQualified = True\n             , ideclAs = Nothing\n             , ideclHiding = Nothing\n             } :: LImportDecl GhcPs\n-        | (isStable, refUnitId, modRef) <- modRefs\n+        | ModRef{..} <- Set.toList modRefs\n          -- don’t import ourselves\n-        , not (modRef == lfModName && unitId == unitId)\n+        , not (modRefModule == lfModName && modRefUnitId == unitId)"
  },
  {
    "id" : "74d05a5d-8dc7-4f07-8c5b-d213bb90252e",
    "prId" : 4251,
    "comments" : [
      {
        "id" : "4331be8b-c1d9-4516-a0a4-726d7c554632",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n                guard $ not modRefIsStable -- we don’t do package qualified imports\r\n```",
        "createdAt" : "2020-01-28T17:42:03Z",
        "updatedAt" : "2020-01-28T17:43:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "094845c5-1193-4f67-ad78-cc759323334d",
        "parentId" : "4331be8b-c1d9-4516-a0a4-726d7c554632",
        "author" : null,
        "body" : "oops",
        "createdAt" : "2020-01-28T17:45:59Z",
        "updatedAt" : "2020-01-28T17:45:59Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "60062de322cb4c820a5af20895251bc92fd8e88e",
    "line" : null,
    "diffHunk" : "@@ -193,94 +199,94 @@ generateSrcFromLf env = noLoc mod\n             { ideclExt = noExt\n             , ideclSourceSrc = NoSourceText\n             , ideclName =\n-                  noLoc $ mkModuleName $ T.unpack $ LF.moduleNameString modRef\n-            , ideclPkgQual =\n-              if isStable\n-                then Nothing -- we don’t do package qualified imports for modules that should come from the current SDK.\n-                else Just $ StringLiteral NoSourceText $ mkFastString $\n-                  -- Package qualified imports for the current package need to use \"this\" instead\n-                  -- of the package id.\n-                  if refUnitId == unitId then \"this\" else fst (splitUnitId $ unitIdString refUnitId)\n+                  noLoc $ mkModuleName $ T.unpack $ LF.moduleNameString modRefModule\n+            , ideclPkgQual = do\n+                guard modRefIsStable -- we don’t do package qualified imports"
  },
  {
    "id" : "f14d431b-84b6-4d01-8fe5-e812ceadd698",
    "prId" : 4222,
    "comments" : [
      {
        "id" : "1a68cf21-b296-41af-9d43-ee32da4c4f9c",
        "parentId" : null,
        "author" : null,
        "body" : "nice :-)",
        "createdAt" : "2020-01-27T13:25:25Z",
        "updatedAt" : "2020-01-27T13:32:44Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "8d1b7759c43720ed16a58242f1f8878b29c70516",
    "line" : 13,
    "diffHunk" : "@@ -40,7 +42,7 @@ import SdkVersion\n data Env = Env\n     { envPkgs :: MS.Map UnitId LF.Package\n     , envGetUnitId :: LF.PackageRef -> UnitId\n-    , envStablePackages :: MS.Map LF.PackageId (UnitId, LF.ModuleName)"
  },
  {
    "id" : "0f41022b-efc3-4348-aa57-37764e9bffc1",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "2d6a47e2-3f25-426c-948a-9efa55496cdc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Judging from CI this seems to break probably due to `OverloadedStrings`, maybe try generating `{-# LANGUAGE NoOverloadedStrings #-}` or whatever the extension is called to disable this.",
        "createdAt" : "2020-01-23T14:48:41Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "262cca83-d435-428c-86cf-b9e914f2aa19",
        "parentId" : "2d6a47e2-3f25-426c-948a-9efa55496cdc",
        "author" : null,
        "body" : "Trying it out. I spent way too much time looking for where to add this extension in `HsModule` ... turns out there was a plaintext header being added with the list of extensions. 😅 ",
        "createdAt" : "2020-01-24T09:03:44Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : null,
    "diffHunk" : "@@ -318,6 +343,15 @@ mkUserTyVar =\n mkRdrName :: T.Text -> Located RdrName\n mkRdrName = noLoc . mkRdrUnqual . mkOccName varName . T.unpack\n \n+mkError :: T.Text -> LHsExpr GhcPs\n+mkError msg = noLoc $ HsApp noExt\n+    (noLoc $ HsVar noExt (mkRdrName \"error\"))\n+    (mkStringLit msg)\n+\n+mkStringLit :: T.Text -> LHsExpr GhcPs"
  },
  {
    "id" : "b438058e-300e-4510-b6cf-2a15985c28dc",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "9e5026f5-c5f1-4084-aaac-61d26eb17f47",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Do we actually generate definitions with an empty name? I thought that wasn’t even allowed in DAML-LF.",
        "createdAt" : "2020-01-24T12:32:27Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "26ba8596-9a73-4fb8-b56c-ddf2a951b9f8",
        "parentId" : "9e5026f5-c5f1-4084-aaac-61d26eb17f47",
        "author" : null,
        "body" : "I removed this check anyway :) It's back to being\r\n\r\n```Haskell\r\nnot (\"$\" `T.isPrefixOf` LF.unExprValName lfName)\r\n```",
        "createdAt" : "2020-01-24T12:55:39Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : null,
    "diffHunk" : "@@ -77,6 +83,42 @@ generateSrcFromLf env = noLoc mod\n         let occName = mkOccName varName $ T.unpack $ sanitize dataTypeCon0\n         pure $ mkDataDecl env thisModule occName dataParams (convDataCons dataTypeCon0 dataCons)\n \n+    valueDecls = do\n+        dval@LF.DefValue {..} <- NM.toList $ LF.moduleValues $ envMod env\n+        guard $ shouldExposeDefValue dval\n+        let (lfName, lfType) = dvalBinder\n+            ltype = noLoc $ convType env lfType :: LHsType GhcPs\n+            lname = mkRdrName (LF.unExprValName lfName) :: Located RdrName\n+            sig = TypeSig noExt [lname] (HsWC noExt $ HsIB noExt ltype)\n+            lsigD = noLoc $ SigD noExt sig :: LHsDecl GhcPs\n+            lexpr = noLoc $ HsPar noExt $ noLoc $ HsVar noExt lname :: LHsExpr GhcPs\n+            lgrhs = noLoc $ GRHS noExt [] lexpr :: LGRHS GhcPs (LHsExpr GhcPs)\n+            grhss = GRHSs noExt [lgrhs] (noLoc $ EmptyLocalBinds noExt)\n+            matchContext = FunRhs lname Prefix NoSrcStrict\n+            lmatch = noLoc $ Match noExt matchContext [] Nothing grhss\n+            lalts = noLoc [lmatch]\n+            bind = FunBind noExt lname (MG noExt lalts Generated) WpHole []\n+            lvalD = noLoc $ ValD noExt bind :: LHsDecl GhcPs\n+        [ lsigD, lvalD ]\n+\n+    shouldExposeDefDataType :: LF.DefDataType -> Bool\n+    shouldExposeDefDataType LF.DefDataType{..}\n+        = LF.getIsSerializable dataSerializable\n+        || not (LF.moduleNameString lfModName == \"GHC.Prim\")\n+\n+    shouldExposeDefValue :: LF.DefValue -> Bool\n+    shouldExposeDefValue LF.DefValue{..}\n+        | (lfName, lfType) <- dvalBinder\n+        , lfNameText <- LF.unExprValName lfName\n+        = not (LF.getIsTest dvalIsTest)\n+        && not (T.null lfNameText)"
  },
  {
    "id" : "275a56aa-efad-403c-a3f2-5ce835ccdb0d",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "36fc40c9-004d-46ba-8d92-c8179a55829e",
        "parentId" : null,
        "author" : null,
        "body" : "Changing the line above to `True` causes us to not expose functions that rely on new-style typeclass constraints, as well. This is a temporary measure, and once we support new-style typeclasses in data-dependencies (in a separate PR) we can change it back to `False`.",
        "createdAt" : "2020-01-24T15:40:10Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 181,
    "diffHunk" : "@@ -546,10 +546,12 @@ typeHasOldTypeclass :: Env -> LF.Type -> Bool\n typeHasOldTypeclass env = \\case\n     LF.TVar _ -> False\n     LF.TCon tcon -> tconIsOldTypeclass env tcon\n-    LF.TSynApp _ _ -> False\n+    LF.TSynApp _ _ -> True\n         -- Type synonyms came after the switch to new-style\n-        -- typeclasses, so let's assume there are no old-style\n-        -- typeclasses being referenced.\n+        -- typeclasses, so we can assume there are no old-style\n+        -- typeclasses being referenced. HOWEVER, we don't support\n+        -- type synonyms here yet. TODO: Fix this, and change\n+        -- the above to False."
  },
  {
    "id" : "aad0d427-5415-4b91-b221-7486ffc24fb1",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "38b3b115-7fca-47db-a5f2-3fe3125dcb5e",
        "parentId" : null,
        "author" : null,
        "body" : "(See relevant PR #4143) ",
        "createdAt" : "2020-01-25T13:32:57Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 109,
    "diffHunk" : "@@ -132,19 +167,40 @@ generateSrcFromLf env = noLoc mod\n         ]\n     isStable LF.PRSelf = False\n     isStable (LF.PRImport pkgId) = pkgId `MS.member` envStablePackages env\n-    modRefs =\n-        nubSort $\n-        [ (isStable pkg, envGetUnitId env pkg, LF.ModuleName ([\"CurrentSdk\" | isStable pkg] <> LF.unModuleName modRef))\n-        | typeDef <- NM.toList $ LF.moduleDataTypes $ envMod env\n-        -- We only care about references from serializable types\n-        -- since those are the only ones that we reconstruct.\n-        , LF.getIsSerializable (LF.dataSerializable typeDef)\n-        , (pkg, modRef) <- toListOf monoTraverse typeDef\n-        ] ++\n-        (map (\\t -> (\\(a,b) -> (True,a,b)) $ builtinToModuleRef t) $\n-         concat $ do\n-             dataTy <- NM.toList $ LF.moduleDataTypes $ envMod env\n-             pure $ toListOf (dataConsType . builtinType) $ LF.dataCons dataTy)\n+\n+    modRefs :: [(Bool, GHC.UnitId, LF.ModuleName)]\n+    modRefs = nubSort . concat . concat $\n+        [ [ modRefsFromDefDataType typeDef\n+          | typeDef <- NM.toList (LF.moduleDataTypes (envMod env))\n+          , shouldExposeDefDataType typeDef ]\n+        , [ modRefsFromDefValue valueDef\n+          | valueDef <- NM.toList (LF.moduleValues (envMod env))\n+          , shouldExposeDefValue valueDef ]\n+        ]\n+\n+    modRefsFromDefDataType :: LF.DefDataType -> [(Bool, GHC.UnitId, LF.ModuleName)]\n+    modRefsFromDefDataType typeDef = concat\n+        [ [ (isStable pkg, envGetUnitId env pkg, modRef)\n+          | (pkg, modRef) <- toListOf monoTraverse typeDef ]\n+        , [ (True, pkg, modRef)\n+          | b <- toListOf (dataConsType . builtinType) (LF.dataCons typeDef)\n+          , (pkg, modRef) <- [builtinToModuleRef b] ]\n+        , [ (True, primUnitId, sdkGhcTypes)\n+          | LF.DataEnum [_] <- [LF.dataCons typeDef]\n+          ] -- ^ single constructor enums spawn a reference to\n+            -- CurrentSdk.GHC.Types.DamlEnum in the daml-preprocessor."
  },
  {
    "id" : "e80f06c4-2cda-4f6c-9500-758b6a63a880",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "ac2501c5-89b0-4e87-a9f6-8bb6e3546067",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there actually a problem with exposing scenarios? I could see it being useful, e.g., if you have some function to initialize the state in scenarios you might want to use it across upgrades.",
        "createdAt" : "2020-01-27T09:27:37Z",
        "updatedAt" : "2020-01-27T09:37:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b4ad18d9-c2bd-4fee-bd11-6ab6b77ba8b5",
        "parentId" : "ac2501c5-89b0-4e87-a9f6-8bb6e3546067",
        "author" : null,
        "body" : "I'll expose them in a separate PR :)",
        "createdAt" : "2020-01-27T10:04:25Z",
        "updatedAt" : "2020-01-27T10:04:25Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 63,
    "diffHunk" : "@@ -77,6 +82,36 @@ generateSrcFromLf env = noLoc mod\n         let occName = mkOccName varName $ T.unpack $ sanitize dataTypeCon0\n         pure $ mkDataDecl env thisModule occName dataParams (convDataCons dataTypeCon0 dataCons)\n \n+    valueDecls = do\n+        dval@LF.DefValue {..} <- NM.toList $ LF.moduleValues $ envMod env\n+        guard $ shouldExposeDefValue dval\n+        let (lfName, lfType) = dvalBinder\n+            ltype = noLoc $ convType env lfType :: LHsType GhcPs\n+            lname = mkRdrName (LF.unExprValName lfName) :: Located RdrName\n+            sig = TypeSig noExt [lname] (HsWC noExt $ HsIB noExt ltype)\n+            lsigD = noLoc $ SigD noExt sig :: LHsDecl GhcPs\n+            lexpr = noLoc $ HsPar noExt $ noLoc $ HsVar noExt lname :: LHsExpr GhcPs\n+            lgrhs = noLoc $ GRHS noExt [] lexpr :: LGRHS GhcPs (LHsExpr GhcPs)\n+            grhss = GRHSs noExt [lgrhs] (noLoc $ EmptyLocalBinds noExt)\n+            matchContext = FunRhs lname Prefix NoSrcStrict\n+            lmatch = noLoc $ Match noExt matchContext [] Nothing grhss\n+            lalts = noLoc [lmatch]\n+            bind = FunBind noExt lname (MG noExt lalts Generated) WpHole []\n+            lvalD = noLoc $ ValD noExt bind :: LHsDecl GhcPs\n+        [ lsigD, lvalD ]\n+\n+    shouldExposeDefDataType :: LF.DefDataType -> Bool\n+    shouldExposeDefDataType typeDef\n+        = not (defDataTypeIsOldTypeClass typeDef)\n+\n+    shouldExposeDefValue :: LF.DefValue -> Bool\n+    shouldExposeDefValue LF.DefValue{..}\n+        | (lfName, lfType) <- dvalBinder\n+        = not (LF.getIsTest dvalIsTest)"
  },
  {
    "id" : "4e728994-8943-44be-93a4-8418aa482d27",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "17c5e8f6-1269-43a1-a7fc-44872a233845",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Fun fact: We have typeclasses with no methods in `daml-stdlib` which this will not hit but it should be fine to not handle that and I don’t see a reasonable way of detecting those.",
        "createdAt" : "2020-01-27T09:33:54Z",
        "updatedAt" : "2020-01-27T09:37:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 214,
    "diffHunk" : "@@ -480,3 +539,75 @@ splitUnitId unitId = fromMaybe (unitId, Nothing) $ do\n     (name, ver) <- stripInfixEnd \"-\" unitId\n     guard $ all (`elem` '.' : ['0' .. '9']) ver\n     pure (name, Just ver)\n+\n+-- | Returns 'True' if an LF type contains a reference to an\n+-- old-style typeclass. See 'tconIsOldTypeclass' for more details.\n+typeHasOldTypeclass :: Env -> LF.Type -> Bool\n+typeHasOldTypeclass env = \\case\n+    LF.TVar _ -> False\n+    LF.TCon tcon -> tconIsOldTypeclass env tcon\n+    LF.TSynApp _ _ -> True\n+        -- Type synonyms came after the switch to new-style\n+        -- typeclasses, so we can assume there are no old-style\n+        -- typeclasses being referenced. HOWEVER, we don't support\n+        -- type synonyms here yet. TODO: Fix this, and change\n+        -- the above to False.\n+    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n+    LF.TBuiltin _ -> False\n+    LF.TForall _ b -> typeHasOldTypeclass env b\n+    LF.TStruct fields -> any (typeHasOldTypeclass env . snd) fields\n+    LF.TNat _ -> False\n+\n+-- | Determine whether a typecon refers to an old-style\n+-- typeclass. By \"old-style\" I mean a typeclass based on\n+-- nominal LF record types. There's no foolproof way of\n+-- determining this, but we can approximate it by taking\n+-- advantage of the typeclass sanitization that is introduced\n+-- during LF conversion: every field in a typeclass dictionary\n+-- is represented by a type @() -> _@ due to sanitization.\n+-- Thus, if a type is given by a record, and the record has\n+-- at least one field, and every field in the record is a\n+-- function from unit, then there's a good chance this\n+-- record represents an old-style typeclass.\n+--\n+-- The caveat here is that if a user creates a record that\n+-- matches these criteria, it will be treated as an old-style\n+-- typeclass and therefore any functions that use this type\n+-- will not be exposed via the data-dependency mechanism,\n+-- (see 'generateSrcFromLf').\n+tconIsOldTypeclass :: Env -> LF.Qualified LF.TypeConName -> Bool\n+tconIsOldTypeclass env tcon =\n+    case envLookupDataType tcon env of\n+        Nothing -> error (\"Unknown reference to type \" <> show tcon)\n+        Just dtype -> defDataTypeIsOldTypeClass dtype\n+\n+defDataTypeIsOldTypeClass :: LF.DefDataType -> Bool\n+defDataTypeIsOldTypeClass LF.DefDataType{..}\n+    | LF.DataRecord fields <- dataCons\n+    = notNull fields && all isDesugarField fields"
  },
  {
    "id" : "48b5a061-83c5-4d83-b95c-2d88cc217504",
    "prId" : 4042,
    "comments" : [
      {
        "id" : "b469d03f-9cdf-4ff5-8419-20a9b513cbe3",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "it doesn’t really make sense to warn about unused imports in autogenerated code and it makes the build very noisy.",
        "createdAt" : "2020-01-14T13:50:27Z",
        "updatedAt" : "2020-01-14T13:50:28Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1581ef74cd1df1f3390a1a3986fe2c587490a68e",
    "line" : 269,
    "diffHunk" : "@@ -727,6 +679,7 @@ generateSrcPkgFromLf getUnitId mbSdkPrefix pkg = do\n         [\"{-# LANGUAGE NoDamlSyntax #-}\"\n         , \"{-# LANGUAGE NoImplicitPrelude #-}\"\n         , \"{-# LANGUAGE TypeOperators #-}\"\n+        , \"{-# OPTIONS_GHC -Wno-unused-imports #-}\""
  },
  {
    "id" : "97100054-6ab4-4322-9ec3-c658c0b200f4",
    "prId" : 3703,
    "comments" : [
      {
        "id" : "3d62c11e-7590-42aa-845f-81a6525614d0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "At least according to our current plans, we don’t want to create Haskell type synonyms. For now, we only intend to use DAML-LF type synonyms for type classes so we also need to map them back to type classes.",
        "createdAt" : "2019-12-03T07:45:22Z",
        "updatedAt" : "2019-12-03T12:40:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8e10f3d85f2547f8c6f1968d814c0ffeba77445b",
    "line" : 5,
    "diffHunk" : "@@ -108,6 +108,9 @@ generateSrcFromLf env = noLoc mod\n \n     convDataCons :: T.Text -> LF.DataCons -> [LConDecl GhcPs]\n     convDataCons dataTypeCon0 = \\case\n+            LF.DataSynonym _ ->\n+              [] -- TODO(NICK) write the Haskell type synonym"
  },
  {
    "id" : "2e5d9041-6948-4d6a-a2ad-0e5503b14131",
    "prId" : 3703,
    "comments" : [
      {
        "id" : "0bcfb08a-a371-4fae-abd6-feefccd53483",
        "parentId" : null,
        "author" : null,
        "body" : "In theory, it will (usually? / always?) be a (DAML) typeclass actually. This is something I'm pretty unclear about at the moment  -- how we will be able to recover the typeclass definition from the synonym definition.",
        "createdAt" : "2019-12-03T08:00:05Z",
        "updatedAt" : "2019-12-03T12:40:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "8e10f3d85f2547f8c6f1968d814c0ffeba77445b",
    "line" : 5,
    "diffHunk" : "@@ -108,6 +108,9 @@ generateSrcFromLf env = noLoc mod\n \n     convDataCons :: T.Text -> LF.DataCons -> [LConDecl GhcPs]\n     convDataCons dataTypeCon0 = \\case\n+            LF.DataSynonym _ ->\n+              [] -- TODO(NICK) write the Haskell type synonym"
  },
  {
    "id" : "ae9d3b26-f6df-4ba3-accc-7cb146dd320f",
    "prId" : 3633,
    "comments" : [
      {
        "id" : "0c66727a-42ef-4be2-9b8a-623720a81950",
        "parentId" : null,
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "(just curious) why these `additionalImports` are no longer needed?",
        "createdAt" : "2019-11-26T16:06:21Z",
        "updatedAt" : "2019-11-26T16:19:26Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ea4f7336-0143-4650-a984-ffcf187e8aab",
        "parentId" : "0c66727a-42ef-4be2-9b8a-623720a81950",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "we used to lift daml-prim and daml-stdlib data types, now we just always point it at the compiling sdk libraries.",
        "createdAt" : "2019-11-26T17:03:26Z",
        "updatedAt" : "2019-11-26T17:03:26Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8db0a3656e6463846bbf7e0e4f7962b02bda3c26",
    "line" : 40,
    "diffHunk" : "@@ -180,41 +180,8 @@ generateSrcFromLf env thisPkgId = noLoc mod\n                 | conName <- cons\n                 ]\n \n-    imports = declImports ++ additionalImports\n-    mkImport :: Bool -> String -> [LImportDecl GhcPs]\n-    mkImport pred modName = [ noLoc $\n-        ImportDecl\n-            { ideclExt = noExt\n-            , ideclSourceSrc = NoSourceText\n-            , ideclName = noLoc $ mkModuleName modName\n-            , ideclPkgQual = Nothing\n-            , ideclSource = False\n-            , ideclSafe = False\n-            , ideclImplicit = False\n-            , ideclQualified = False\n-            , ideclAs = Nothing\n-            , ideclHiding = Nothing\n-            } :: LImportDecl GhcPs\n-        | pred\n-        ]\n-    -- additional imports needed for typechecking\n-    additionalImports ="
  }
]