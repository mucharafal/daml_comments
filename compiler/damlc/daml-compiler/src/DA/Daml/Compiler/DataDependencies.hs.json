[
  {
    "id" : "29309081-0798-44fe-8d95-5253597fb199",
    "prId" : 7770,
    "comments" : [
      {
        "id" : "40296dd3-6308-48e9-bf63-499b5cafeb1d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":scream_cat: ",
        "createdAt" : "2020-10-21T12:56:42Z",
        "updatedAt" : "2020-10-21T13:14:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f618867a-004c-4627-823c-aef36cde5173",
        "parentId" : "40296dd3-6308-48e9-bf63-499b5cafeb1d",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "👻 ",
        "createdAt" : "2020-10-21T13:26:17Z",
        "updatedAt" : "2020-10-21T13:26:18Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8c76f568-35d8-49e3-b8b3-556e002f3506",
        "parentId" : "40296dd3-6308-48e9-bf63-499b5cafeb1d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It feels like we're giving people a giant foot gun here. I mean it's more of a foot gun than in Haskell but still. Let's not tell people about it.",
        "createdAt" : "2020-10-22T13:24:10Z",
        "updatedAt" : "2020-10-22T13:25:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "99bf8b3526af4baa9252a090ef4cde7af0cb8a7c",
    "line" : 25,
    "diffHunk" : "@@ -1,1 +484,488 @@            , (\"OVERLAPPABLE\", Overlappable)\n            , (\"OVERLAPS\", Overlaps)\n            , (\"INCOHERENT\", Incoherent)\n            ]\n"
  },
  {
    "id" : "9f280bd6-0790-4ca4-99d2-c3230c438087",
    "prId" : 7770,
    "comments" : [
      {
        "id" : "c7dfac5f-c220-4c69-bc16-df0d88cd554e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe worth defining the mapping here and the one in the LF conversion somewhere close to each other or at least add a comment that the two must stay in sync.",
        "createdAt" : "2020-10-21T13:09:34Z",
        "updatedAt" : "2020-10-21T13:14:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "62f76ad9-0d61-4518-a5d7-250091f8b8c6",
        "parentId" : "c7dfac5f-c220-4c69-bc16-df0d88cd554e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "A roundtrip test might also be a good idea and avoids the need to write four tests just to make sure we translate strings correctly :slightly_smiling_face: ",
        "createdAt" : "2020-10-21T13:14:37Z",
        "updatedAt" : "2020-10-21T13:14:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "78b718b3-b2fa-4a25-9348-d60986ad8cc3",
        "parentId" : "c7dfac5f-c220-4c69-bc16-df0d88cd554e",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "That's a good idea. (I think I'll do that as a separate refactoring PR since it involves touching more code.)",
        "createdAt" : "2020-10-21T14:06:46Z",
        "updatedAt" : "2020-10-21T14:06:47Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "99bf8b3526af4baa9252a090ef4cde7af0cb8a7c",
    "line" : 21,
    "diffHunk" : "@@ -1,1 +480,484 @@\n        overlapModeFns :: MS.Map T.Text (SourceText -> OverlapMode)\n        overlapModeFns = MS.fromList\n            [ (\"OVERLAPPING\", Overlapping)\n            , (\"OVERLAPPABLE\", Overlappable)"
  },
  {
    "id" : "6d96d3ef-977f-494b-a78a-c5cd67b102a1",
    "prId" : 7539,
    "comments" : [
      {
        "id" : "efc2d37a-c306-418d-af60-5ff9af4cbeaf",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It's a bit sad that `Data.Text` doesn't have `spanEnd`, unlike `Data.Bytestring`. 😿 ",
        "createdAt" : "2020-10-01T10:53:15Z",
        "updatedAt" : "2020-10-01T11:30:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6d9da2da895f51fee2ab302864d36b6c137d48e6",
    "line" : 41,
    "diffHunk" : "@@ -1,1 +421,425 @@            let name = LF.unExprValName (fst (LF.dvalBinder dval))\n                (intR,tagR) = T.span isDigit (T.reverse name)\n            in (T.reverse tagR, readMay (T.unpack (T.reverse intR)))\n\n    hiddenRefMap :: HMS.HashMap Ref Bool"
  },
  {
    "id" : "8b11a336-745f-4673-baff-f56ab3f2d9bb",
    "prId" : 4881,
    "comments" : [
      {
        "id" : "63a47177-4f86-48e0-bf03-f6d35bdb71be",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that this follows references across packages afaict, would it make sense to call it once for all packages instead of once per package? (Happy to not do this as part of this PR even if it does make sense).",
        "createdAt" : "2020-03-06T14:59:59Z",
        "updatedAt" : "2020-03-06T15:32:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d296567d-bece-4b75-9af8-4994a44979b3",
        "parentId" : "63a47177-4f86-48e0-bf03-f6d35bdb71be",
        "author" : null,
        "body" : "Yes! I think that should be the next experiment :)",
        "createdAt" : "2020-03-06T15:03:11Z",
        "updatedAt" : "2020-03-06T15:32:00Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "4a366fd7-4101-4bc3-928c-8109b2f65da2",
        "parentId" : "63a47177-4f86-48e0-bf03-f6d35bdb71be",
        "author" : null,
        "body" : "Wait, it shouldn't make a difference unless you have multiple data-dependencies with lots of packages in common.",
        "createdAt" : "2020-03-06T15:39:39Z",
        "updatedAt" : "2020-03-06T15:39:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "74092a5d-92c0-4477-8ed4-8a4b1a3d3140",
        "parentId" : "63a47177-4f86-48e0-bf03-f6d35bdb71be",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Right but having multiple data-dependencies that are interlinked doesn’t sound that unreasonable.",
        "createdAt" : "2020-03-06T15:41:29Z",
        "updatedAt" : "2020-03-06T15:41:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4046bd6e-3e6e-46a5-958e-09c569388fc7",
        "parentId" : "63a47177-4f86-48e0-bf03-f6d35bdb71be",
        "author" : null,
        "body" : "Yes, but perhaps that change can be made if/when it becomes relevant, and/or as part of a larger refactoring of packaging rules.",
        "createdAt" : "2020-03-06T15:53:35Z",
        "updatedAt" : "2020-03-06T15:53:35Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "1e59fa61-c76e-4cfe-a9a4-bad0b3803343",
        "parentId" : "63a47177-4f86-48e0-bf03-f6d35bdb71be",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":+1:",
        "createdAt" : "2020-03-06T15:58:06Z",
        "updatedAt" : "2020-03-06T15:58:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ae157cc4063eef409e90f907834d5c5d2150e7f1",
    "line" : 101,
    "diffHunk" : "@@ -1,1 +829,833 @@\n-- | Calculate the set of all references that should be hidden.\nbuildHiddenRefMap :: Config -> LF.World -> HMS.HashMap Ref Bool\nbuildHiddenRefMap config world =\n    case leastFixedPointBy (||) refGraphList of"
  },
  {
    "id" : "7ab5040b-ad89-456c-9e3a-358760b9aa7f",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "6bfa268a-547b-4159-9613-18d8cb13f8d1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Will we ever look up a reference to a `dependency`? Presumably the case where this matters is for reexported typeclasses. Do we check if the original typeclass is hidden or if the new typeclass is hidden? I think I don’t really understand why we need to “white-list” this so maybe it would be good to expand on this in a comment.",
        "createdAt" : "2020-03-05T13:41:57Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "32a30d73-2409-496c-bbb1-0df052c9eeb5",
        "parentId" : "6bfa268a-547b-4159-9613-18d8cb13f8d1",
        "author" : null,
        "body" : "I didn't check to see if it made a significant difference, but this whitelist is for the case where the data-dependency shares a dependency with the package being built. It doesn't check re-exports, it's just a check for actual references to the same dependencies.\r\n\r\nThe only case where this is logically relevant is if both the package being built & the data-dependencies depend on the same package, and that package contains something that would otherwise be erased. That's pretty rare. OTOH, this check prevents us from building up the a complicated dependency graph for daml-stdlib / daml-prim modules each time, on the assumption that the SDK hasn't changed.\r\n\r\nGiven that the case where it matters is quite rare, I can try removing this and see if it makes a difference to compile times. If removing it makes it significantly worse, I'll keep the whitelist and add a comment, and then see if we can just eat the cost once we start building this map once per package instead of once per module.",
        "createdAt" : "2020-03-05T15:29:07Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "b646af3d-6a4f-414c-8002-6894d4976d85",
        "parentId" : "6bfa268a-547b-4159-9613-18d8cb13f8d1",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thanks for the explanation! Happy to keep it for this PR if we add a comment.",
        "createdAt" : "2020-03-05T15:30:13Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : 194,
    "diffHunk" : "@@ -1,1 +863,867 @@            -- from daml-stdlib.\n        | LF.PRImport pkgId <- refPackage ref\n        , Set.member pkgId (configDependencyPackages (envConfig env))\n            = HMS.insert ref (False, []) refGraph\n            -- Dependencies are always available. This is a mostly a small optimization."
  },
  {
    "id" : "34b9ead5-ffa2-4858-8a57-e006a1d02d1a",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "cbd174b7-a1e2-4f6a-b08c-7a270f7c9ef5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Can we add a comment why `Erased` is not sufficient to throw out the problematic stuff from `DA.Generics`?",
        "createdAt" : "2020-03-05T13:42:24Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d055d2ef-5f86-4094-848d-3ac56eb141b7",
        "parentId" : "cbd174b7-a1e2-4f6a-b08c-7a270f7c9ef5",
        "author" : null,
        "body" : "I'll add a comment. It's because `GenConvertible` causes kind errors in the back and forth translation, without actual  references to `Erased`.",
        "createdAt" : "2020-03-05T15:16:11Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "cdd0aa4c-1cce-44d7-9d21-233784888c2b",
        "parentId" : "cbd174b7-a1e2-4f6a-b08c-7a270f7c9ef5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "FWIW, `GenConvertible` is killed in https://github.com/digital-asset/daml/pull/4839. Although I don’t really understand why `GenConvertible` causes issues here since it’s not used in the project you tested on afaik and we have other tests that use `daml-stdlib`. Either way, happy to keep this code if we add a comment.",
        "createdAt" : "2020-03-05T15:27:16Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : 188,
    "diffHunk" : "@@ -1,1 +857,861 @@        | ref == RTypeCon erasedTCon\n            = HMS.insert ref (True, []) refGraph -- Erased is always erased\n        | refModule ref == LF.ModuleName [\"DA\", \"Generics\"]\n            = HMS.insert ref (True, []) refGraph\n            -- DA.Generics is not supported. This prevents issues with GenConvertible."
  },
  {
    "id" : "d0099bb7-9d0a-472f-82cc-3b2a24123a02",
    "prId" : 4833,
    "comments" : [
      {
        "id" : "7e518181-6a2f-4022-9fb6-6c5d81ee4b70",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Similar question here, why do we need to whitelist this?",
        "createdAt" : "2020-03-05T13:46:09Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8da84f95-ee74-421f-97fe-97661f6962bf",
        "parentId" : "7e518181-6a2f-4022-9fb6-6c5d81ee4b70",
        "author" : null,
        "body" : "Same as above. I can probably just remove it though.",
        "createdAt" : "2020-03-05T15:29:55Z",
        "updatedAt" : "2020-03-05T17:07:10Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "26882d77e73f48422434c0913d230f50575a20f7",
    "line" : 201,
    "diffHunk" : "@@ -1,1 +870,874 @@        | LF.PRImport pkgId <- refPackage ref\n        , MS.member pkgId (configStablePackages (envConfig env))\n            = HMS.insert ref (False, []) refGraph -- stable pkgs are always available\n            -- TODO (SF): Check if we really need this after we move to running the\n            -- erased tracker once per package."
  },
  {
    "id" : "f1d3d049-c1cb-4c9e-b0a0-59a46c78abd1",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "44dc2105-94df-42ea-8c3e-ff3ef08aba19",
        "parentId" : null,
        "author" : null,
        "body" : "This makes sense to me. If I knew then what I know now about package IDs vs unit IDs, I probably would have done it like this to begin with.",
        "createdAt" : "2020-02-14T12:41:11Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 18,
    "diffHunk" : "@@ -1,1 +48,52 @@\ndata Config = Config\n    { configPackages :: MS.Map LF.PackageId LF.Package\n     -- ^ All packages we know about, i.e., dependencies,\n     -- data-dependencies and stable packages."
  },
  {
    "id" : "e72d5e7c-1c61-4aaf-93db-556ce95692a4",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "87740ae9-300a-4459-8f10-a6b61be37ce9",
        "parentId" : null,
        "author" : null,
        "body" : "I see, this map conflates different classes with the same name, but it's ok because this is only an optimization and the real collision check in `isDuplicate` tests that the types are equal. It might be nice to add a comment.",
        "createdAt" : "2020-02-14T13:20:51Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "7f18251a-8cc3-490c-bd03-677f2cb9fe65",
        "parentId" : "87740ae9-300a-4459-8f10-a6b61be37ce9",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, I’ve added a comment.",
        "createdAt" : "2020-02-14T13:58:03Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 71,
    "diffHunk" : "@@ -1,1 +124,128 @@    , LF.DefValue{..} <- NM.toList moduleValues\n    , Just dfun <- [getDFunSig dvalBinder]\n    , let clsName = LF.qualObject $ dfhName $ dfsHead dfun\n    ]\n"
  },
  {
    "id" : "8f88ca48-0817-4139-a152-1162b6d89f84",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "575ab2c3-e5ec-4638-8ccc-d506f1f2a5ef",
        "parentId" : null,
        "author" : null,
        "body" : "It might be good to add a small comment explaining when this happens.",
        "createdAt" : "2020-02-14T13:25:29Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "bf051688-4d83-48b5-bea5-88b3bd20c0f8",
        "parentId" : "575ab2c3-e5ec-4638-8ccc-d506f1f2a5ef",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, I added a comment.",
        "createdAt" : "2020-02-14T14:01:29Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 127,
    "diffHunk" : "@@ -1,1 +242,246 @@            -- since LF structs need to have a non-zero number of\n            -- fields.\n            LF.TUnit -> True\n            _ -> False\n        LF.TypeSynName [name] <- [synName]"
  },
  {
    "id" : "06ee5351-789b-44e9-a462-40159f10bf28",
    "prId" : 4517,
    "comments" : [
      {
        "id" : "6b61102b-ce5c-4658-9ed1-37a72e62a021",
        "parentId" : null,
        "author" : null,
        "body" : "Happy leave it for a future PR, but I think it makes sense to pass `reexported` inside `env` at this point.",
        "createdAt" : "2020-02-14T13:37:58Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a48e8e63-0d65-4e2a-91fe-4884d26904df",
        "parentId" : "6b61102b-ce5c-4658-9ed1-37a72e62a021",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "good idea, I’ll leave it for a separate PR.",
        "createdAt" : "2020-02-14T14:02:35Z",
        "updatedAt" : "2020-02-14T14:40:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4f1b089c2ff3d47e403e999827eb32b9cf999c6d",
    "line" : 326,
    "diffHunk" : "@@ -1,1 +568,572 @@\nconvType :: Env -> MS.Map LF.TypeSynName LF.PackageId -> LF.Type -> Gen (HsType GhcPs)\nconvType env reexported =\n    \\case\n        LF.TVar tyVarName -> pure $"
  },
  {
    "id" : "876d9634-72b0-48e3-ac59-5d0ed0ddca5b",
    "prId" : 4488,
    "comments" : [
      {
        "id" : "33d89957-4335-4ece-b2c5-8706a52b04b5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not entirely sure this is necessary given the context where typeclasses appear but `HsAppTy` definitely needs parentheses in some cases so I’d rather just always add them.",
        "createdAt" : "2020-02-12T11:00:24Z",
        "updatedAt" : "2020-02-12T11:00:25Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "670b2c26-74f9-4af9-b450-453b4e49b704",
        "parentId" : "33d89957-4335-4ece-b2c5-8706a52b04b5",
        "author" : null,
        "body" : "Sounds good, & might as well.",
        "createdAt" : "2020-02-12T12:55:13Z",
        "updatedAt" : "2020-02-12T12:55:14Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "217240b0f8df55e5dab2736f7148a4685ee8949c",
    "line" : 14,
    "diffHunk" : "@@ -1,1 +510,514 @@                    . mkOrig ghcMod . mkOccName clsName $ T.unpack tyname\n            args <- mapM (convType env) lfArgs\n            pure $ HsParTy noExt (noLoc $ foldl (HsAppTy noExt . noLoc) tyvar (map noLoc args))\n\n        LF.TCon LF.Qualified {..}"
  },
  {
    "id" : "a537681b-66e0-4305-b11e-c4e3b27926e3",
    "prId" : 4377,
    "comments" : [
      {
        "id" : "760cc56e-67ba-414e-af86-37199df67a35",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if it might be slightly less hacky to search for a record selector in the body? Don’t really have a strong opinion here so happy to go with this for now.",
        "createdAt" : "2020-02-04T14:41:10Z",
        "updatedAt" : "2020-02-04T14:44:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "087a4442-56d4-41a9-99c3-4ef6c1add130",
        "parentId" : "760cc56e-67ba-414e-af86-37199df67a35",
        "author" : null,
        "body" : "I think either way is fine, but this seems a little bit simpler, and should handle custom `HasField` instances better. (Not that I suggest anybody write those, but you never know.)",
        "createdAt" : "2020-02-04T15:01:38Z",
        "updatedAt" : "2020-02-04T15:01:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "11ace7345f8f6eed774640514b8e9f30ebc621d8",
    "line" : 111,
    "diffHunk" : "@@ -1,1 +889,893 @@    getFieldArg :: LF.ExprValName -> Maybe T.Text\n    getFieldArg (LF.ExprValName name) = do\n        name' <- T.stripPrefix \"$fHasField\\\"\" name\n        Just $ fst (T.breakOn \"\\\"\" name')\n"
  },
  {
    "id" : "f91cb85f-25ec-4465-b3a3-5b3e1326e5a0",
    "prId" : 4336,
    "comments" : [
      {
        "id" : "83802ad5-a1d4-4601-be75-a4f81eed08a6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Might be nice to add a comment here explaining the relationship between `configPackages`, `configStablePackages` and `configDependencyPackages`. I guess `configPackages` includes stable packages, dependencies and data-dependencies?",
        "createdAt" : "2020-02-03T08:08:48Z",
        "updatedAt" : "2020-02-03T11:00:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ebe9f65d-31c3-4057-8e65-0a3291be97e3",
        "parentId" : "83802ad5-a1d4-4601-be75-a4f81eed08a6",
        "author" : null,
        "body" : "Improved the docs here. I also switched gave `envQualify` a more explicit name and switched it (`True -> False`) since it was confusing to me.",
        "createdAt" : "2020-02-03T10:13:19Z",
        "updatedAt" : "2020-02-03T11:00:51Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "f7a75365b89d256e55bf0795b4284729c3b038de",
    "line" : 22,
    "diffHunk" : "@@ -1,1 +48,52 @@    , configStablePackages :: Set LF.PackageId\n        -- ^ set of package ids for stable packages\n    , configDependencyPackages :: Set LF.PackageId\n        -- ^ set of package ids for dependencies (not data-dependencies)\n    , configSdkPrefix :: [T.Text]"
  },
  {
    "id" : "e1eddb01-2d3f-48b1-99f8-66cd3dfe157d",
    "prId" : 4326,
    "comments" : [
      {
        "id" : "d0a28fe0-a4fe-444b-aec0-3774bb010817",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe `mkStubBind` would be a better name?",
        "createdAt" : "2020-01-31T13:38:26Z",
        "updatedAt" : "2020-01-31T13:49:22Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8437b20a-0e19-40a5-9a2d-34fbe280f83b",
        "parentId" : "d0a28fe0-a4fe-444b-aec0-3774bb010817",
        "author" : null,
        "body" : "I'll change it in the next PR, thanks!",
        "createdAt" : "2020-01-31T14:20:02Z",
        "updatedAt" : "2020-01-31T14:20:02Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c598bf91f25a67ef3aef8f21d597e8bdf4aa0f5c",
    "line" : 96,
    "diffHunk" : "@@ -1,1 +346,350 @@-- we turn the left-hand side into the unqualified form of that name (LHS\n-- must always be unqualified), and the right-hand side remains qualified.\nmkTrivialBind :: Located RdrName -> HsBind GhcPs\nmkTrivialBind lname =\n    let lexpr = noLoc $ HsPar noExt $ noLoc $ HsVar noExt lname :: LHsExpr GhcPs"
  },
  {
    "id" : "e074cff0-3a77-415e-a985-7e5035096577",
    "prId" : 4326,
    "comments" : [
      {
        "id" : "6cb8efe9-a1d1-4ea0-ae38-b75d76b9f782",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there a reason why we don’t just generate an empty instance?",
        "createdAt" : "2020-01-31T13:45:26Z",
        "updatedAt" : "2020-01-31T13:49:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "39799ee0-ef44-4e43-adae-7149521ccf4d",
        "parentId" : "6cb8efe9-a1d1-4ea0-ae38-b75d76b9f782",
        "author" : null,
        "body" : "Ah, I just assumed that wouldn't work. I'll try it out.",
        "createdAt" : "2020-01-31T14:02:20Z",
        "updatedAt" : "2020-01-31T14:02:21Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a7900841-25a2-443d-8d36-7a741f556792",
        "parentId" : "6cb8efe9-a1d1-4ea0-ae38-b75d76b9f782",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We probably want to silence the warning but apart from that I don’t see why it shouldn’t work.",
        "createdAt" : "2020-01-31T14:04:41Z",
        "updatedAt" : "2020-01-31T14:04:41Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c598bf91f25a67ef3aef8f21d597e8bdf4aa0f5c",
    "line" : 43,
    "diffHunk" : "@@ -1,1 +185,189 @@                { cid_ext = noExt\n                , cid_poly_ty = polyTy\n                , cid_binds = listToBag (mapMaybe (mkBind ghcMod) fieldNames)\n                , cid_sigs = []\n                , cid_tyfam_insts = []"
  },
  {
    "id" : "b9320f71-1623-4386-ab9f-b578cd28c32a",
    "prId" : 4326,
    "comments" : [
      {
        "id" : "f7fd46ff-bcce-484e-b38f-ea12e6a0b71f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Where are they generated? I thought we don’t run the preprocessor on generated sources. Might be good to add a test for this (if it doesn’t work, let’s do it in a separate PR).\r\n\r\nReconstructing those instances from DAML-LF is a bit tricky since the type-level strings are lost. For `HasField` we can probably get the field name fairly easily from the body. A bit gross but probably fairly reasonable. The only other instance that I remember that relies heavily on type-level stuff that is lost in the translation to LF is `Generic` and for now, I would just ignore that (but probably also good to have a testcase for this, happy to do it in a separate PR)",
        "createdAt" : "2020-01-31T13:46:37Z",
        "updatedAt" : "2020-01-31T13:49:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1ee58ffb-f81d-4c1f-9b39-9258ccc31fcd",
        "parentId" : "f7fd46ff-bcce-484e-b38f-ea12e6a0b71f",
        "author" : null,
        "body" : "We could just run the daml-preprocessor step for records, rather than recreating that. Since we'll (soon) re-export the typeclasses, we don't even need to change the prefix.\r\n\r\n(We should also be able to drop the `CurrentSdk` prefix logic from the enum type preprocessor as well.)\r\n\r\nI'll handle this in a separate PR.",
        "createdAt" : "2020-01-31T14:12:16Z",
        "updatedAt" : "2020-01-31T14:12:31Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "cdce3eb9-c4f5-423a-b75a-1fe39ec5e9c3",
        "parentId" : "f7fd46ff-bcce-484e-b38f-ea12e6a0b71f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The problem with that is that then you will get the stub instances even if the DALF does not contain the instances. Probably not a huge deal in practice but it feels a bit fragile.",
        "createdAt" : "2020-01-31T14:14:26Z",
        "updatedAt" : "2020-01-31T14:14:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e85758f2-059f-40a1-ab99-8c7f043aeb37",
        "parentId" : "f7fd46ff-bcce-484e-b38f-ea12e6a0b71f",
        "author" : null,
        "body" : "Hmm, I see. I guess the safer thing is to make the stub instance by reconstructing the field name from the body of the HasField instance. That's definitely a separate PR.",
        "createdAt" : "2020-01-31T14:18:57Z",
        "updatedAt" : "2020-01-31T14:18:57Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c598bf91f25a67ef3aef8f21d597e8bdf4aa0f5c",
    "line" : 53,
    "diffHunk" : "@@ -1,1 +195,199 @@\n        -- | Filter out HasField instances, since they are generated separately.\n        isHasField :: LF.Qualified LF.TypeSynName -> Bool\n        isHasField LF.Qualified{..} =\n            qualModule == LF.ModuleName [\"DA\", \"Internal\", \"Record\"]"
  },
  {
    "id" : "c9786594-9ec6-4225-a059-39aa5e08c25e",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "c9db2ed6-f2d2-45b1-80f9-4e035ed265f4",
        "parentId" : null,
        "author" : null,
        "body" : "By the way, this is 100% a module reference we weren't tracking before, but since GHC.Types is pretty commonly depended on, it didn't cause problems in practice.",
        "createdAt" : "2020-01-29T19:17:42Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "db87e371-e513-45f3-aca3-1a6cc018a414",
        "parentId" : "c9db2ed6-f2d2-45b1-80f9-4e035ed265f4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yeah, the new approach is a lot less fragile :+1:",
        "createdAt" : "2020-01-30T08:27:07Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : 579,
    "diffHunk" : "@@ -1,1 +430,434 @@convKind env = \\case\n    LF.KStar -> pure . noLoc $ HsStarTy noExt False\n    LF.KNat -> noLoc <$> mkGhcType env \"Nat\"\n    LF.KArrow k1 k2 -> do\n        k1' <- convKind env k1"
  },
  {
    "id" : "6938a8d1-1c6d-4074-bc28-8f3d053154fb",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "0205df03-dc43-48d7-8919-7dd43befa2dd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I thought `ghc-mod` is dead :trollface: ",
        "createdAt" : "2020-01-30T08:28:21Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : 623,
    "diffHunk" : "@@ -1,1 +470,474 @@mkStableType :: Env -> UnitId -> LF.ModuleName -> String -> Gen (HsType GhcPs)\nmkStableType env unitId modName tyName = do\n    ghcMod <- genStableModule env unitId modName\n    pure . HsTyVar noExt NotPromoted . noLoc\n        . mkOrig ghcMod $ mkOccName varName tyName"
  },
  {
    "id" : "39da70db-4eac-42a0-a439-fb3f4cfe0102",
    "prId" : 4274,
    "comments" : [
      {
        "id" : "145cfcab-a7b9-4be3-aa6a-a6efbf9a6ef8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I really hate that GHC’s `Module` type is not a module but just a reference to it. This makes the names here a bit confusing since it sounds like we are generating the source for a module. But I don’t really have a less confusing suggestion sadly :disappointed: ",
        "createdAt" : "2020-01-30T08:31:15Z",
        "updatedAt" : "2020-01-31T11:44:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ec16b623-c700-4347-b123-f56683603e5f",
        "parentId" : "145cfcab-a7b9-4be3-aa6a-a6efbf9a6ef8",
        "author" : null,
        "body" : "I agree, `Module` is very counterintuitive name for a module reference.",
        "createdAt" : "2020-01-30T11:34:07Z",
        "updatedAt" : "2020-01-31T11:44:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "a4bb033d06d9248fab9ca5ebf41c23a505d8d123",
    "line" : 387,
    "diffHunk" : "@@ -1,1 +309,313 @@    _ -> False\n\ngenModule :: Env -> LF.PackageRef -> LF.ModuleName -> Gen Module\ngenModule env pkgRef modName = do\n    let isStable"
  },
  {
    "id" : "91935da2-5b97-4996-9dcd-de124850fc4e",
    "prId" : 4251,
    "comments" : [
      {
        "id" : "6dd1659c-8a61-436c-b6f3-72502628f5bc",
        "parentId" : null,
        "author" : null,
        "body" : "I *think* this is an unrelated bugfix.",
        "createdAt" : "2020-01-28T17:37:55Z",
        "updatedAt" : "2020-01-28T17:43:23Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "fc978a75-d7b3-49bc-9810-eb0c50e17385",
        "parentId" : "6dd1659c-8a61-436c-b6f3-72502628f5bc",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This really should be in HLint :slightly_smiling_face: ",
        "createdAt" : "2020-01-28T17:41:30Z",
        "updatedAt" : "2020-01-28T17:43:23Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "60062de322cb4c820a5af20895251bc92fd8e88e",
    "line" : 46,
    "diffHunk" : "@@ -1,1 +219,223 @@        | ModRef{..} <- Set.toList modRefs\n         -- don’t import ourselves\n        , not (modRefModule == lfModName && modRefUnitId == unitId)\n        -- GHC.Prim doesn’t need to and cannot be explicitly imported (it is not exposed since the interface file is black magic\n        -- hardcoded in GHC)."
  },
  {
    "id" : "0110a8fe-ac60-4f60-b3c8-9e3149c868a8",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "7cebaa09-9178-4d1e-a650-5c10458e98f4",
        "parentId" : null,
        "author" : null,
        "body" : "Changing the line above to `True` causes us to not expose functions that rely on new-style typeclass constraints, as well. This is a temporary measure, and once we support new-style typeclasses in data-dependencies (in a separate PR) we can change it back to `False`.",
        "createdAt" : "2020-01-24T15:40:10Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 181,
    "diffHunk" : "@@ -1,1 +552,556 @@        -- typeclasses being referenced. HOWEVER, we don't support\n        -- type synonyms here yet. TODO: Fix this, and change\n        -- the above to False.\n    LF.TApp a b -> typeHasOldTypeclass env a || typeHasOldTypeclass env b\n    LF.TBuiltin _ -> False"
  },
  {
    "id" : "f528a504-5c4d-4e4a-9362-69b294bbdec9",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "c5bd2750-34d0-421e-b2f9-a903443d90ee",
        "parentId" : null,
        "author" : null,
        "body" : "(See relevant PR #4143) ",
        "createdAt" : "2020-01-25T13:32:57Z",
        "updatedAt" : "2020-01-25T14:42:26Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 109,
    "diffHunk" : "@@ -1,1 +189,193 @@          | LF.DataEnum [_] <- [LF.dataCons typeDef]\n          ] -- ^ single constructor enums spawn a reference to\n            -- CurrentSdk.GHC.Types.DamlEnum in the daml-preprocessor.\n        ]\n"
  },
  {
    "id" : "ca15f36a-b86b-4969-8362-7a800e16ea6d",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "71ac7b04-9807-45c1-ae5b-c90044bee02b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Is there actually a problem with exposing scenarios? I could see it being useful, e.g., if you have some function to initialize the state in scenarios you might want to use it across upgrades.",
        "createdAt" : "2020-01-27T09:27:37Z",
        "updatedAt" : "2020-01-27T09:37:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "34c2572a-2b79-424b-a2cf-9573ae15f12b",
        "parentId" : "71ac7b04-9807-45c1-ae5b-c90044bee02b",
        "author" : null,
        "body" : "I'll expose them in a separate PR :)",
        "createdAt" : "2020-01-27T10:04:25Z",
        "updatedAt" : "2020-01-27T10:04:25Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 63,
    "diffHunk" : "@@ -1,1 +108,112 @@    shouldExposeDefValue LF.DefValue{..}\n        | (lfName, lfType) <- dvalBinder\n        = not (LF.getIsTest dvalIsTest)\n        && not (\"$\" `T.isPrefixOf` LF.unExprValName lfName)\n        && not (typeHasOldTypeclass env lfType)"
  },
  {
    "id" : "0f3c332c-3bd5-4523-bae8-e232c597221c",
    "prId" : 4182,
    "comments" : [
      {
        "id" : "00cf0fe5-8389-4ba4-b716-0e3bc1d0e9ad",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Fun fact: We have typeclasses with no methods in `daml-stdlib` which this will not hit but it should be fine to not handle that and I don’t see a reasonable way of detecting those.",
        "createdAt" : "2020-01-27T09:33:54Z",
        "updatedAt" : "2020-01-27T09:37:26Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "06a85e217d7504649cf6665d6b337fcafda3e85b",
    "line" : 214,
    "diffHunk" : "@@ -1,1 +585,589 @@defDataTypeIsOldTypeClass LF.DefDataType{..}\n    | LF.DataRecord fields <- dataCons\n    = notNull fields && all isDesugarField fields\n\n    | otherwise"
  },
  {
    "id" : "acba6808-9b63-4282-ad08-40508b8dc7f4",
    "prId" : 4042,
    "comments" : [
      {
        "id" : "4acc0d58-5dcf-4544-a20c-a7011ab50bdc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "it doesn’t really make sense to warn about unused imports in autogenerated code and it makes the build very noisy.",
        "createdAt" : "2020-01-14T13:50:27Z",
        "updatedAt" : "2020-01-14T13:50:28Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1581ef74cd1df1f3390a1a3986fe2c587490a68e",
    "line" : 269,
    "diffHunk" : "@@ -1,1 +680,684 @@        , \"{-# LANGUAGE NoImplicitPrelude #-}\"\n        , \"{-# LANGUAGE TypeOperators #-}\"\n        , \"{-# OPTIONS_GHC -Wno-unused-imports #-}\"\n        ]\n"
  },
  {
    "id" : "5430aaae-1ddd-484c-83c4-5c4b05cf2d1a",
    "prId" : 3703,
    "comments" : [
      {
        "id" : "dfc99f9f-3530-4834-ab36-5a7ee3db1057",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "At least according to our current plans, we don’t want to create Haskell type synonyms. For now, we only intend to use DAML-LF type synonyms for type classes so we also need to map them back to type classes.",
        "createdAt" : "2019-12-03T07:45:22Z",
        "updatedAt" : "2019-12-03T12:40:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8e10f3d85f2547f8c6f1968d814c0ffeba77445b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +110,114 @@    convDataCons dataTypeCon0 = \\case\n            LF.DataSynonym _ ->\n              [] -- TODO(NICK) write the Haskell type synonym\n\n            LF.DataRecord fields ->"
  },
  {
    "id" : "13617146-235f-4d9c-ac74-08217b30c16e",
    "prId" : 3703,
    "comments" : [
      {
        "id" : "385f7440-7da6-4dba-ba43-cca9728fe528",
        "parentId" : null,
        "author" : null,
        "body" : "In theory, it will (usually? / always?) be a (DAML) typeclass actually. This is something I'm pretty unclear about at the moment  -- how we will be able to recover the typeclass definition from the synonym definition.",
        "createdAt" : "2019-12-03T08:00:05Z",
        "updatedAt" : "2019-12-03T12:40:39Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "8e10f3d85f2547f8c6f1968d814c0ffeba77445b",
    "line" : 5,
    "diffHunk" : "@@ -1,1 +110,114 @@    convDataCons dataTypeCon0 = \\case\n            LF.DataSynonym _ ->\n              [] -- TODO(NICK) write the Haskell type synonym\n\n            LF.DataRecord fields ->"
  }
]