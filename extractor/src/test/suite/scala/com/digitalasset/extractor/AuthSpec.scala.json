[
  {
    "id" : "48f9903f-d038-4788-b52a-1212efc14bb9",
    "prId" : 3514,
    "comments" : [
      {
        "id" : "456e684d-076c-4064-92ef-3be396403dc7",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Why is the token file wrapped in an `Option` if it's always `Some` (and cannot be changed)?",
        "createdAt" : "2019-11-19T06:52:59Z",
        "updatedAt" : "2019-11-19T14:49:56Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "77868d9c-f5b4-47e3-aa31-42df59eb237a",
        "parentId" : "456e684d-076c-4064-92ef-3be396403dc7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Mostly to match the signature of the methods taking a token, but I can push it to the call site.",
        "createdAt" : "2019-11-19T10:06:46Z",
        "updatedAt" : "2019-11-19T14:49:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2ee4b7f0-5913-4173-88ba-3790a10407a2",
        "parentId" : "456e684d-076c-4064-92ef-3be396403dc7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3514/commits/27fe3b2aa9a340c4a5d07cfab375ce877b8c2c73",
        "createdAt" : "2019-11-19T13:32:00Z",
        "updatedAt" : "2019-11-19T14:49:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bf2fcd17a4a975d9c4508a4a2d5777b00841ee76",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,167 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.extractor\n+\n+import java.nio.file.Files\n+import java.time.temporal.ChronoUnit\n+import java.time.{Duration, Instant}\n+\n+import com.digitalasset.daml.lf.data.Ref.Party\n+import com.digitalasset.extractor.config.{ExtractorConfig, SnapshotEndSetting}\n+import com.digitalasset.extractor.targets.TextPrintTarget\n+import com.digitalasset.grpc.{GrpcException, GrpcStatus}\n+import com.digitalasset.jwt.domain.DecodedJwt\n+import com.digitalasset.jwt.{HMAC256Verifier, JwtSigner}\n+import com.digitalasset.ledger.api.auth.{AuthServiceJWT, AuthServiceJWTCodec, AuthServiceJWTPayload}\n+import com.digitalasset.ledger.api.testing.utils.SuiteResourceManagementAroundAll\n+import com.digitalasset.ledger.api.tls.TlsConfiguration\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.client.services.commands.SynchronousCommandClient\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.digitalasset.platform.sandbox.services.{SandboxFixture, TestCommands}\n+import com.digitalasset.timer.Delayed\n+import com.google.protobuf.timestamp.Timestamp\n+import io.grpc.Status.Code.PERMISSION_DENIED\n+import org.scalatest.{AsyncFlatSpec, Matchers}\n+import org.slf4j.LoggerFactory\n+import scalaz.OneAnd\n+\n+import scala.concurrent.duration.DurationInt\n+import scala.util.control.NonFatal\n+\n+final class AuthSpec\n+    extends AsyncFlatSpec\n+    with SandboxFixture\n+    with SuiteResourceManagementAroundAll\n+    with Matchers\n+    with TestCommands {\n+\n+  private val jwtHeader = \"\"\"{\"alg\": \"HS256\", \"typ\": \"JWT\"}\"\"\"\n+  private val jwtSecret = \"com.digitalasset.extractor.AuthSpec\"\n+\n+  private def newSyncClient = new SynchronousCommandClient(CommandServiceGrpc.stub(channel))\n+\n+  lazy val dummyRequest = {\n+    // we need to adjust the time of the request because we pass 10\n+    // days in the test scenario.\n+    val letInstant = Instant.EPOCH.plus(10, ChronoUnit.DAYS)\n+    val let = Timestamp(letInstant.getEpochSecond, letInstant.getNano)\n+    val mrt = Timestamp(let.seconds + 30L, let.nanos)\n+    dummyCommands(ledgerId, \"commandId1\").update(\n+      _.commands.ledgerEffectiveTime := let,\n+      _.commands.maximumRecordTime := mrt\n+    )\n+  }\n+\n+  implicit class AuthServiceJWTPayloadExtensions(payload: AuthServiceJWTPayload) {\n+    def expiresIn(t: java.time.Duration): AuthServiceJWTPayload =\n+      payload.copy(exp = Some(Instant.now.plus(t)))\n+    def expiresInFiveSeconds: AuthServiceJWTPayload = expiresIn(Duration.ofSeconds(5))\n+    def expiresTomorrow: AuthServiceJWTPayload = expiresIn(Duration.ofDays(1))\n+    def expired: AuthServiceJWTPayload = expiresIn(Duration.ofDays(-1))\n+\n+    def signed(secret: String): String =\n+      JwtSigner.HMAC256\n+        .sign(DecodedJwt(jwtHeader, AuthServiceJWTCodec.compactPrint(payload)), secret)\n+        .getOrElse(sys.error(\"Failed to generate token\"))\n+        .value\n+\n+    def asHeader(secret: String = jwtSecret) = s\"Bearer ${signed(secret)}\"\n+  }\n+\n+  override protected def config: SandboxConfig =\n+    super.config.copy(\n+      authService = Some(\n+        AuthServiceJWT(\n+          HMAC256Verifier(jwtSecret).getOrElse(sys.error(\"Failed to create HMAC256 verifier\")))))\n+\n+  private val operator = \"OPERATOR\"\n+  private val operatorPayload = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = true,\n+    actAs = List(operator),\n+    readAs = List(operator)\n+  )\n+\n+  private val token = Some(Files.createTempFile(\"Extractor\", \"AuthSpec\"))"
  },
  {
    "id" : "71062c00-2e30-4ce1-b07c-8d4d2b379c12",
    "prId" : 3514,
    "comments" : [
      {
        "id" : "577569c1-f5fe-4779-947a-43102db0f8c1",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should we check here that the transaction/contracts were actually persisted?",
        "createdAt" : "2019-11-19T06:56:24Z",
        "updatedAt" : "2019-11-19T14:49:56Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9fc5989b-255c-4bea-958c-ea7d6a0f21b9",
        "parentId" : "577569c1-f5fe-4779-947a-43102db0f8c1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Yes. In exploring this point I realized that the tests were *completely* broken. I was not issuing commands with the access tokens set, I didn't event call `process.run()` and was relying on the outcome of `process.shutdown()` (which simply returns a success when the process is shut down - that is, always). I've re-written the last two tests as a single one, using an ad-hoc writer to inspect the state of what's written there. It's a bit complex and I'd ask you to double check it for correctness. :pray:",
        "createdAt" : "2019-11-19T13:25:32Z",
        "updatedAt" : "2019-11-19T14:49:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "afb96c04-7803-4415-86e0-73d37d119fa6",
        "parentId" : "577569c1-f5fe-4779-947a-43102db0f8c1",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/3514/commits/e33087cc49371ab4073af90395ca9e2c59142654",
        "createdAt" : "2019-11-19T13:32:28Z",
        "updatedAt" : "2019-11-19T14:49:56Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bf2fcd17a4a975d9c4508a4a2d5777b00841ee76",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,167 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.extractor\n+\n+import java.nio.file.Files\n+import java.time.temporal.ChronoUnit\n+import java.time.{Duration, Instant}\n+\n+import com.digitalasset.daml.lf.data.Ref.Party\n+import com.digitalasset.extractor.config.{ExtractorConfig, SnapshotEndSetting}\n+import com.digitalasset.extractor.targets.TextPrintTarget\n+import com.digitalasset.grpc.{GrpcException, GrpcStatus}\n+import com.digitalasset.jwt.domain.DecodedJwt\n+import com.digitalasset.jwt.{HMAC256Verifier, JwtSigner}\n+import com.digitalasset.ledger.api.auth.{AuthServiceJWT, AuthServiceJWTCodec, AuthServiceJWTPayload}\n+import com.digitalasset.ledger.api.testing.utils.SuiteResourceManagementAroundAll\n+import com.digitalasset.ledger.api.tls.TlsConfiguration\n+import com.digitalasset.ledger.api.v1.command_service.{CommandServiceGrpc, SubmitAndWaitRequest}\n+import com.digitalasset.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.digitalasset.ledger.client.services.commands.SynchronousCommandClient\n+import com.digitalasset.platform.sandbox.config.SandboxConfig\n+import com.digitalasset.platform.sandbox.services.{SandboxFixture, TestCommands}\n+import com.digitalasset.timer.Delayed\n+import com.google.protobuf.timestamp.Timestamp\n+import io.grpc.Status.Code.PERMISSION_DENIED\n+import org.scalatest.{AsyncFlatSpec, Matchers}\n+import org.slf4j.LoggerFactory\n+import scalaz.OneAnd\n+\n+import scala.concurrent.duration.DurationInt\n+import scala.util.control.NonFatal\n+\n+final class AuthSpec\n+    extends AsyncFlatSpec\n+    with SandboxFixture\n+    with SuiteResourceManagementAroundAll\n+    with Matchers\n+    with TestCommands {\n+\n+  private val jwtHeader = \"\"\"{\"alg\": \"HS256\", \"typ\": \"JWT\"}\"\"\"\n+  private val jwtSecret = \"com.digitalasset.extractor.AuthSpec\"\n+\n+  private def newSyncClient = new SynchronousCommandClient(CommandServiceGrpc.stub(channel))\n+\n+  lazy val dummyRequest = {\n+    // we need to adjust the time of the request because we pass 10\n+    // days in the test scenario.\n+    val letInstant = Instant.EPOCH.plus(10, ChronoUnit.DAYS)\n+    val let = Timestamp(letInstant.getEpochSecond, letInstant.getNano)\n+    val mrt = Timestamp(let.seconds + 30L, let.nanos)\n+    dummyCommands(ledgerId, \"commandId1\").update(\n+      _.commands.ledgerEffectiveTime := let,\n+      _.commands.maximumRecordTime := mrt\n+    )\n+  }\n+\n+  implicit class AuthServiceJWTPayloadExtensions(payload: AuthServiceJWTPayload) {\n+    def expiresIn(t: java.time.Duration): AuthServiceJWTPayload =\n+      payload.copy(exp = Some(Instant.now.plus(t)))\n+    def expiresInFiveSeconds: AuthServiceJWTPayload = expiresIn(Duration.ofSeconds(5))\n+    def expiresTomorrow: AuthServiceJWTPayload = expiresIn(Duration.ofDays(1))\n+    def expired: AuthServiceJWTPayload = expiresIn(Duration.ofDays(-1))\n+\n+    def signed(secret: String): String =\n+      JwtSigner.HMAC256\n+        .sign(DecodedJwt(jwtHeader, AuthServiceJWTCodec.compactPrint(payload)), secret)\n+        .getOrElse(sys.error(\"Failed to generate token\"))\n+        .value\n+\n+    def asHeader(secret: String = jwtSecret) = s\"Bearer ${signed(secret)}\"\n+  }\n+\n+  override protected def config: SandboxConfig =\n+    super.config.copy(\n+      authService = Some(\n+        AuthServiceJWT(\n+          HMAC256Verifier(jwtSecret).getOrElse(sys.error(\"Failed to create HMAC256 verifier\")))))\n+\n+  private val operator = \"OPERATOR\"\n+  private val operatorPayload = AuthServiceJWTPayload(\n+    ledgerId = None,\n+    participantId = None,\n+    applicationId = None,\n+    exp = None,\n+    admin = true,\n+    actAs = List(operator),\n+    readAs = List(operator)\n+  )\n+\n+  private val token = Some(Files.createTempFile(\"Extractor\", \"AuthSpec\"))\n+\n+  private def setToken(string: String): Unit =\n+    token.foreach(path => Files.write(path, string.getBytes()))\n+\n+  override protected def afterAll(): Unit = {\n+    super.afterAll()\n+    try {\n+      token.foreach(Files.delete)\n+    } catch {\n+      case NonFatal(e) =>\n+        LoggerFactory.getLogger(classOf[AuthSpec]).warn(\"Unable to delete temporary token file\", e)\n+    }\n+  }\n+\n+  private def extractor(config: ExtractorConfig) =\n+    new Extractor(config, TextPrintTarget)()\n+\n+  private def noAuth =\n+    ExtractorConfig(\n+      \"127.0.0.1\",\n+      ledgerPort = getSandboxPort,\n+      ledgerInboundMessageSizeMax = 50 * 1024 * 1024,\n+      LedgerOffset(LedgerOffset.Value.Boundary(LedgerOffset.LedgerBoundary.LEDGER_BEGIN)),\n+      SnapshotEndSetting.Head,\n+      OneAnd(Party.assertFromString(operator), List.empty),\n+      Set.empty,\n+      TlsConfiguration(\n+        enabled = false,\n+        None,\n+        None,\n+        None,\n+      ),\n+      None,\n+    )\n+\n+  private def withAuth = noAuth.copy(accessTokenFile = token)\n+\n+  private def tailWithAuth = withAuth.copy(to = SnapshotEndSetting.Follow)\n+\n+  behavior of \"Extractor against a Ledger API protected by authentication\"\n+\n+  it should \"fail immediately with a PERMISSION_DENIED if no token is provided\" in {\n+    extractor(noAuth).run().failed.collect {\n+      case GrpcException(GrpcStatus(`PERMISSION_DENIED`, _), _) => succeed\n+    }\n+  }\n+\n+  it should \"succeed if the proper token is provided\" in {\n+    setToken(operatorPayload.asHeader())\n+    extractor(withAuth).run().map(_ => succeed)\n+  }\n+\n+  it should \"eventually fail if a token expires while the stream is in flight\" in {\n+    val process = extractor(tailWithAuth)\n+    setToken(operatorPayload.expiresInFiveSeconds.asHeader())\n+    Delayed.Future.by(10.seconds) {\n+      newSyncClient.submitAndWait(SubmitAndWaitRequest(commands = dummyRequest.commands))\n+    }\n+    Delayed.by(10.seconds)(setToken(operatorPayload.asHeader()))\n+    Delayed.Future.by(15.seconds)(process.shutdown().map(_ => succeed))\n+  }\n+\n+  it should \"eventually succeed if an invalid token is replaced\" in {\n+    val process = extractor(tailWithAuth)\n+    setToken(operatorPayload.expiresInFiveSeconds.asHeader())\n+    Delayed.Future.by(10.seconds) {\n+      newSyncClient.submitAndWait(SubmitAndWaitRequest(commands = dummyRequest.commands))\n+    }\n+    Delayed.by(15.seconds)(setToken(operatorPayload.asHeader()))\n+    Delayed.Future.by(20.seconds) {\n+      newSyncClient.submitAndWait(SubmitAndWaitRequest(commands = dummyRequest.commands))\n+    }\n+    Delayed.Future.by(25.seconds)(process.shutdown().map(_ => succeed))"
  }
]