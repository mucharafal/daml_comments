[
  {
    "id" : "057f0f5b-a868-4316-ba37-294b15dd15ff",
    "prId" : 4888,
    "comments" : [
      {
        "id" : "47b9bf14-489d-42e6-8b30-dc733f5aee98",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This is subsumed by `GetParties`. Do we really need 2 endpoints for this?",
        "createdAt" : "2020-03-09T09:40:05Z",
        "updatedAt" : "2020-03-09T10:13:12Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b3a73df5-924b-476a-b62f-b6893c45c215",
        "parentId" : "47b9bf14-489d-42e6-8b30-dc733f5aee98",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Makes sense. I added the first one first and then realized it might be helpful to have both. For implicit party allocation, though it doesn't use the endpoints, it does need to request multiple party details at once.\r\n\r\nWhich endpoint does it make sense to keep?",
        "createdAt" : "2020-03-09T09:47:27Z",
        "updatedAt" : "2020-03-09T10:13:12Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "03a9d674-ffed-4337-bd56-43bcce9efd90",
        "parentId" : "47b9bf14-489d-42e6-8b30-dc733f5aee98",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Spoke to @gerolf-da offline and decided to keep `GetParties`. I've removed `GetParty` and the whole query path associated with it.",
        "createdAt" : "2020-03-09T10:13:30Z",
        "updatedAt" : "2020-03-09T10:13:31Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c25b99df1b0987de8a65e6b62a47340266547bbd",
    "line" : null,
    "diffHunk" : "@@ -31,15 +31,22 @@ service PartyManagementService {\n   // daml-on-sql: returns an identifier supplied on command line at launch time\n   // daml-on-kv-ledger: as above\n   // canton: returns globally unique identifier of the backing participant\n-  rpc GetParticipantId (GetParticipantIdRequest) returns\n-    (GetParticipantIdResponse);\n+  rpc GetParticipantId (GetParticipantIdRequest) returns (GetParticipantIdResponse);\n+\n+  // Get the party details of the given party, or a ``NOT_FOUND`` error if the\n+  // requested party is unknown.\n+  rpc GetParty (GetPartyRequest) returns (GetPartyResponse);"
  },
  {
    "id" : "2ecb6b8c-b83a-4948-8c3b-e730b4493651",
    "prId" : 1264,
    "comments" : [
      {
        "id" : "bb3464d9-9968-4583-8ac6-c50c40dc4a26",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Having read https://support.dnsimple.com/articles/what-is-common-name/ I believe \"common_name\" gives too much of an impression of uniqueness or validatedness. I'd rather be on the safe side and use\r\n\r\n```\r\n// Human readable name. Might not be unique.\r\nstring display_name\r\n```",
        "createdAt" : "2019-05-23T16:17:22Z",
        "updatedAt" : "2019-05-23T20:06:44Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "949c69703c60436cb3be1de6cb82043c45186fbf",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,133 @@\n+\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+syntax = \"proto3\";\n+\n+package com.digitalasset.ledger.api.v1.admin;\n+\n+option java_outer_classname = \"PartyManagementServiceOuterClass\";\n+option java_package = \"com.digitalasset.ledger.api.v1.admin\";\n+\n+// Status: experimental interface, will change before it is deemed production\n+// ready\n+\n+// Inspect the party management state of a ledger participant and modify the\n+// parts that are modifiable. We use 'backing participant' to refer to this\n+// specific participant in the methods of this API.\n+// When the participant is run in mode requiring authentication, all the calls \n+// in this interface will respond with UNAUTHENTICATED, if the caller fails\n+// to provide a valid access token, and will respond with PERMISSION_DENIED, if\n+// the claims in the token are insufficient to perform a given operation.\n+// Subsequently, only specific errors of individual calls not related to \n+// authorization will be described.\n+service PartyManagementService {\n+\n+  // Return the identifier of the backing participant.\n+  // All horizontally scaled replicas should return the same id.\n+  // This method is expected to succeed provided the backing participant is \n+  // healthy, otherwise it responds with INTERNAL grpc error.\n+  // daml-on-sql: returns an identifier supplied on command line at launch time\n+  // daml-on-kv-ledger: as above\n+  // canton: returns globally unique identifier of the backing participant\n+  rpc GetParticipantId (GetParticipantIdRequest) returns\n+    (GetParticipantIdResponse);\n+\n+  // List the parties known by the backing participant.\n+  // The list returned contains parties whose ledger access is facilitated by\n+  // backing participant and the ones maintained elsewhere.\n+  // This request will always succeed.\n+  // TODO: Check what the use case is for listing non-local parties\n+  rpc ListKnownParties (ListKnownPartiesRequest) returns\n+    (ListKnownPartiesResponse);\n+\n+  // Adds a new party to the set managed by the backing participant.\n+  // Caller specifies a party identifier suggestion, the actual identifier\n+  // allocated might be different and is implementation specific.\n+  // This call will either succeed or respond with ALREADY_EXISTS if given party\n+  // already exists and the party allocation scheme uses only request data to \n+  // generate new stable identifiers.\n+  // daml-on-sql: suggestion's uniqueness is checked and call rejected if the\n+  // identifier is already present\n+  // daml-on-kv-ledger: suggestion's uniqueness is checked bby the validators in\n+  // the consensus layer and call rejected if the identifier is already present.\n+  // canton: completely different globally unique identifier is allocated.\n+  // Behind the scenes calls to an internal protocol are made. As that protocol\n+  // is richer than the the surface protocol, the arguments take implicit values\n+  rpc AllocateParty (AllocatePartyRequest) returns (AllocatePartyResponse);\n+}\n+\n+message GetParticipantIdRequest {\n+\n+  // Must correspond to the ledger ID reported by the Ledger Identification\n+  // Service.\n+  // Required\n+  string ledger_id = 1;\n+}\n+\n+message GetParticipantIdResponse {\n+\n+  // Identifier of the participant, which SHOULD be globally unique.\n+  string participant_id = 2;\n+}\n+\n+message ListKnownPartiesRequest {\n+\n+  // Must correspond to the ledger ID reported by the Ledger Identification\n+  // Service.\n+  // Required\n+  string ledger_id = 1;\n+}\n+\n+message ListKnownPartiesResponse {\n+\n+  // The details of all DAML parties hosted by the participant.\n+  // Required\n+  repeated PartyDetails party_details = 1;\n+}\n+\n+message PartyDetails {\n+\n+  // The stable unique identifier of a DAML party.\n+  // Required\n+  string party = 1;\n+\n+  // Common name associated with the party.\n+  // Optional\n+  string common_name = 2;\n+\n+  // id of the participant that this party is hosted on\n+  // Required\n+  string participant_id = 3;\n+\n+  // Future extension: include metadata fields. There will be two categories\n+  // of such fields: common and implementation specific.\n+  // CommonMetadata common_metadata = 2;\n+  // bytes implementation_metadata = 3;\n+  \n+  // Canton-specific meta-data would contain the following:\n+  // string domain = 2;\n+  // string participant = 3;\n+  // com.digitalasset.canton.identity.v0.ParticipantPrivilege privilege = 4;\n+  // com.digitalasset.canton.identity.v0.TrustLevel trustLevel = 5;\n+}\n+\n+message AllocatePartyRequest {\n+\n+  // Must correspond to the ledger ID reported by the Ledger Identification\n+  // Service.\n+  // Required\n+  string ledger_id = 1;\n+\n+  // Common name of the party to be added to the participant.\n+  // Required\n+  string common_name = 2;"
  },
  {
    "id" : "54ce352e-f411-4759-9256-43fa8ed3f27f",
    "prId" : 1264,
    "comments" : [
      {
        "id" : "8ee20566-dc90-459a-b591-78690640c620",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Not for all parties the hosting participant is known.\r\n\r\nI'd suggest\r\n```\r\n// True if the backing participant hosts this party.\r\nbool locally_hosted\r\n```",
        "createdAt" : "2019-05-23T16:18:26Z",
        "updatedAt" : "2019-05-23T20:06:44Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "949c69703c60436cb3be1de6cb82043c45186fbf",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,133 @@\n+\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+syntax = \"proto3\";\n+\n+package com.digitalasset.ledger.api.v1.admin;\n+\n+option java_outer_classname = \"PartyManagementServiceOuterClass\";\n+option java_package = \"com.digitalasset.ledger.api.v1.admin\";\n+\n+// Status: experimental interface, will change before it is deemed production\n+// ready\n+\n+// Inspect the party management state of a ledger participant and modify the\n+// parts that are modifiable. We use 'backing participant' to refer to this\n+// specific participant in the methods of this API.\n+// When the participant is run in mode requiring authentication, all the calls \n+// in this interface will respond with UNAUTHENTICATED, if the caller fails\n+// to provide a valid access token, and will respond with PERMISSION_DENIED, if\n+// the claims in the token are insufficient to perform a given operation.\n+// Subsequently, only specific errors of individual calls not related to \n+// authorization will be described.\n+service PartyManagementService {\n+\n+  // Return the identifier of the backing participant.\n+  // All horizontally scaled replicas should return the same id.\n+  // This method is expected to succeed provided the backing participant is \n+  // healthy, otherwise it responds with INTERNAL grpc error.\n+  // daml-on-sql: returns an identifier supplied on command line at launch time\n+  // daml-on-kv-ledger: as above\n+  // canton: returns globally unique identifier of the backing participant\n+  rpc GetParticipantId (GetParticipantIdRequest) returns\n+    (GetParticipantIdResponse);\n+\n+  // List the parties known by the backing participant.\n+  // The list returned contains parties whose ledger access is facilitated by\n+  // backing participant and the ones maintained elsewhere.\n+  // This request will always succeed.\n+  // TODO: Check what the use case is for listing non-local parties\n+  rpc ListKnownParties (ListKnownPartiesRequest) returns\n+    (ListKnownPartiesResponse);\n+\n+  // Adds a new party to the set managed by the backing participant.\n+  // Caller specifies a party identifier suggestion, the actual identifier\n+  // allocated might be different and is implementation specific.\n+  // This call will either succeed or respond with ALREADY_EXISTS if given party\n+  // already exists and the party allocation scheme uses only request data to \n+  // generate new stable identifiers.\n+  // daml-on-sql: suggestion's uniqueness is checked and call rejected if the\n+  // identifier is already present\n+  // daml-on-kv-ledger: suggestion's uniqueness is checked bby the validators in\n+  // the consensus layer and call rejected if the identifier is already present.\n+  // canton: completely different globally unique identifier is allocated.\n+  // Behind the scenes calls to an internal protocol are made. As that protocol\n+  // is richer than the the surface protocol, the arguments take implicit values\n+  rpc AllocateParty (AllocatePartyRequest) returns (AllocatePartyResponse);\n+}\n+\n+message GetParticipantIdRequest {\n+\n+  // Must correspond to the ledger ID reported by the Ledger Identification\n+  // Service.\n+  // Required\n+  string ledger_id = 1;\n+}\n+\n+message GetParticipantIdResponse {\n+\n+  // Identifier of the participant, which SHOULD be globally unique.\n+  string participant_id = 2;\n+}\n+\n+message ListKnownPartiesRequest {\n+\n+  // Must correspond to the ledger ID reported by the Ledger Identification\n+  // Service.\n+  // Required\n+  string ledger_id = 1;\n+}\n+\n+message ListKnownPartiesResponse {\n+\n+  // The details of all DAML parties hosted by the participant.\n+  // Required\n+  repeated PartyDetails party_details = 1;\n+}\n+\n+message PartyDetails {\n+\n+  // The stable unique identifier of a DAML party.\n+  // Required\n+  string party = 1;\n+\n+  // Common name associated with the party.\n+  // Optional\n+  string common_name = 2;\n+\n+  // id of the participant that this party is hosted on\n+  // Required\n+  string participant_id = 3;"
  },
  {
    "id" : "4c1e19b9-ca44-46cd-95d8-666ce4ea4933",
    "prId" : 1264,
    "comments" : [
      {
        "id" : "c8dcfa7e-4ef4-4496-bf20-a367907c78da",
        "parentId" : null,
        "author" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "body" : "Why no proposal for party_id?",
        "createdAt" : "2019-05-23T16:18:41Z",
        "updatedAt" : "2019-05-23T20:06:44Z",
        "lastEditedBy" : {
          "login" : "meiersi-da",
          "name" : "Simon Meier",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/13766136?u=a00dd223b1cde8578fe208ebbb7cccd4db41eb9a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "949c69703c60436cb3be1de6cb82043c45186fbf",
    "line" : 93,
    "diffHunk" : "@@ -0,0 +1,133 @@\n+\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+syntax = \"proto3\";\n+\n+package com.digitalasset.ledger.api.v1.admin;\n+\n+option java_outer_classname = \"PartyManagementServiceOuterClass\";\n+option java_package = \"com.digitalasset.ledger.api.v1.admin\";\n+\n+// Status: experimental interface, will change before it is deemed production\n+// ready\n+\n+// Inspect the party management state of a ledger participant and modify the\n+// parts that are modifiable. We use 'backing participant' to refer to this\n+// specific participant in the methods of this API.\n+// When the participant is run in mode requiring authentication, all the calls \n+// in this interface will respond with UNAUTHENTICATED, if the caller fails\n+// to provide a valid access token, and will respond with PERMISSION_DENIED, if\n+// the claims in the token are insufficient to perform a given operation.\n+// Subsequently, only specific errors of individual calls not related to \n+// authorization will be described.\n+service PartyManagementService {\n+\n+  // Return the identifier of the backing participant.\n+  // All horizontally scaled replicas should return the same id.\n+  // This method is expected to succeed provided the backing participant is \n+  // healthy, otherwise it responds with INTERNAL grpc error.\n+  // daml-on-sql: returns an identifier supplied on command line at launch time\n+  // daml-on-kv-ledger: as above\n+  // canton: returns globally unique identifier of the backing participant\n+  rpc GetParticipantId (GetParticipantIdRequest) returns\n+    (GetParticipantIdResponse);\n+\n+  // List the parties known by the backing participant.\n+  // The list returned contains parties whose ledger access is facilitated by\n+  // backing participant and the ones maintained elsewhere.\n+  // This request will always succeed.\n+  // TODO: Check what the use case is for listing non-local parties\n+  rpc ListKnownParties (ListKnownPartiesRequest) returns\n+    (ListKnownPartiesResponse);\n+\n+  // Adds a new party to the set managed by the backing participant.\n+  // Caller specifies a party identifier suggestion, the actual identifier\n+  // allocated might be different and is implementation specific.\n+  // This call will either succeed or respond with ALREADY_EXISTS if given party\n+  // already exists and the party allocation scheme uses only request data to \n+  // generate new stable identifiers.\n+  // daml-on-sql: suggestion's uniqueness is checked and call rejected if the\n+  // identifier is already present\n+  // daml-on-kv-ledger: suggestion's uniqueness is checked bby the validators in\n+  // the consensus layer and call rejected if the identifier is already present.\n+  // canton: completely different globally unique identifier is allocated.\n+  // Behind the scenes calls to an internal protocol are made. As that protocol\n+  // is richer than the the surface protocol, the arguments take implicit values\n+  rpc AllocateParty (AllocatePartyRequest) returns (AllocatePartyResponse);\n+}\n+\n+message GetParticipantIdRequest {\n+\n+  // Must correspond to the ledger ID reported by the Ledger Identification\n+  // Service.\n+  // Required\n+  string ledger_id = 1;\n+}\n+\n+message GetParticipantIdResponse {\n+\n+  // Identifier of the participant, which SHOULD be globally unique.\n+  string participant_id = 2;\n+}\n+\n+message ListKnownPartiesRequest {\n+\n+  // Must correspond to the ledger ID reported by the Ledger Identification\n+  // Service.\n+  // Required\n+  string ledger_id = 1;\n+}\n+\n+message ListKnownPartiesResponse {\n+\n+  // The details of all DAML parties hosted by the participant.\n+  // Required\n+  repeated PartyDetails party_details = 1;\n+}\n+\n+message PartyDetails {\n+\n+  // The stable unique identifier of a DAML party.\n+  // Required\n+  string party = 1;\n+\n+  // Common name associated with the party.\n+  // Optional\n+  string common_name = 2;\n+\n+  // id of the participant that this party is hosted on\n+  // Required\n+  string participant_id = 3;\n+\n+  // Future extension: include metadata fields. There will be two categories\n+  // of such fields: common and implementation specific.\n+  // CommonMetadata common_metadata = 2;\n+  // bytes implementation_metadata = 3;\n+  \n+  // Canton-specific meta-data would contain the following:\n+  // string domain = 2;\n+  // string participant = 3;\n+  // com.digitalasset.canton.identity.v0.ParticipantPrivilege privilege = 4;\n+  // com.digitalasset.canton.identity.v0.TrustLevel trustLevel = 5;\n+}\n+\n+message AllocatePartyRequest {"
  },
  {
    "id" : "34d12466-7f35-4126-bb34-352a4b2291b4",
    "prId" : 1264,
    "comments" : [
      {
        "id" : "d7649462-6888-459a-b42b-8d47f64942bd",
        "parentId" : null,
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "2?",
        "createdAt" : "2019-05-23T19:59:46Z",
        "updatedAt" : "2019-05-23T20:06:44Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi Mäki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c9b513b4-5d6b-4724-84c8-95f5f8397249",
        "parentId" : "d7649462-6888-459a-b42b-8d47f64942bd",
        "author" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-05-23T20:07:00Z",
        "updatedAt" : "2019-05-23T20:07:00Z",
        "lastEditedBy" : {
          "login" : "mziolekda",
          "name" : "mziolekda",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/28315767?u=bfa7fd34d88616828ab02abda54fea595b0fde29&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "949c69703c60436cb3be1de6cb82043c45186fbf",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,109 @@\n+\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+syntax = \"proto3\";\n+\n+package com.digitalasset.ledger.api.v1.admin;\n+\n+option java_outer_classname = \"PartyManagementServiceOuterClass\";\n+option java_package = \"com.digitalasset.ledger.api.v1.admin\";\n+\n+// Status: experimental interface, will change before it is deemed production\n+// ready\n+\n+// Inspect the party management state of a ledger participant and modify the\n+// parts that are modifiable. We use 'backing participant' to refer to this\n+// specific participant in the methods of this API.\n+// When the participant is run in mode requiring authentication, all the calls \n+// in this interface will respond with UNAUTHENTICATED, if the caller fails\n+// to provide a valid access token, and will respond with PERMISSION_DENIED, if\n+// the claims in the token are insufficient to perform a given operation.\n+// Subsequently, only specific errors of individual calls not related to \n+// authorization will be described.\n+service PartyManagementService {\n+\n+  // Return the identifier of the backing participant.\n+  // All horizontally scaled replicas should return the same id.\n+  // This method is expected to succeed provided the backing participant is \n+  // healthy, otherwise it responds with INTERNAL grpc error.\n+  // daml-on-sql: returns an identifier supplied on command line at launch time\n+  // daml-on-kv-ledger: as above\n+  // canton: returns globally unique identifier of the backing participant\n+  rpc GetParticipantId (GetParticipantIdRequest) returns\n+    (GetParticipantIdResponse);\n+\n+  // List the parties known by the backing participant.\n+  // The list returned contains parties whose ledger access is facilitated by\n+  // backing participant and the ones maintained elsewhere.\n+  // This request will always succeed.\n+  rpc ListKnownParties (ListKnownPartiesRequest) returns\n+    (ListKnownPartiesResponse);\n+\n+  // Adds a new party to the set managed by the backing participant.\n+  // Caller specifies a party identifier suggestion, the actual identifier\n+  // allocated might be different and is implementation specific.\n+  // This call will either succeed or respond with UNIMPLEMENTED if synchronous\n+  // party allocation is not supported by the backing participant.\n+  // daml-on-sql: suggestion's uniqueness is checked and call rejected if the\n+  // identifier is already present\n+  // daml-on-kv-ledger: suggestion's uniqueness is checked bby the validators in\n+  // the consensus layer and call rejected if the identifier is already present.\n+  // canton: completely different globally unique identifier is allocated.\n+  // Behind the scenes calls to an internal protocol are made. As that protocol\n+  // is richer than the the surface protocol, the arguments take implicit values\n+  rpc AllocateParty (AllocatePartyRequest) returns (AllocatePartyResponse);\n+}\n+\n+message GetParticipantIdRequest {\n+}\n+\n+message GetParticipantIdResponse {\n+\n+  // Identifier of the participant, which SHOULD be globally unique.\n+  string participant_id = 2;"
  }
]