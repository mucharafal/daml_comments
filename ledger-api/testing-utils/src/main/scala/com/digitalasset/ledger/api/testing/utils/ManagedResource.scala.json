[
  {
    "id" : "95f3041f-6d47-4efc-9b91-9b0679e8bbfb",
    "prId" : 5388,
    "comments" : [
      {
        "id" : "29f0b6f9-22f6-4062-b596-fbba6fc063c1",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Minor: maybe synchronizing on `resource` is enough.",
        "createdAt" : "2020-04-02T17:38:17Z",
        "updatedAt" : "2020-04-02T17:38:47Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "be51fe70-077f-4062-94e5-7bc48ef376c2",
        "parentId" : "29f0b6f9-22f6-4062-b596-fbba6fc063c1",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Synchronizing on mutable variables is dangerous; you're overwriting it, so the next thing will sync on something else.",
        "createdAt" : "2020-04-03T07:18:54Z",
        "updatedAt" : "2020-04-03T07:18:54Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec0961a41bf39430b81d0bc7280e8139c47f56fd",
    "line" : 57,
    "diffHunk" : "@@ -3,43 +3,34 @@\n \n package com.digitalasset.ledger.api.testing.utils\n \n-import java.util.concurrent.atomic.AtomicReference\n-\n import scala.reflect.ClassTag\n \n abstract class ManagedResource[Value: ClassTag] extends Resource[Value] {\n-\n-  private val resourceRef = new AtomicReference[Value]()\n+  private var resource: Option[Value] = None\n \n   protected def construct(): Value\n \n   protected def destruct(resource: Value): Unit\n \n-  final override def value: Value = {\n-    val res = resourceRef.get()\n-    if (res != null) res\n-    else\n+  final override def value: Value =\n+    resource.getOrElse {\n       throw new IllegalStateException(\n-        s\"Attempted to read non-initialized resource of class ${implicitly[ClassTag[Value]].runtimeClass.getName}\")\n-  }\n-\n-  final override def setup(): Unit = {\n-    resourceRef.updateAndGet(\n-      (resource: Value) =>\n-        if (resource == null) construct()\n-        else throw new IllegalStateException(s\"Resource $resource is already set up\"))\n-    ()\n-  }\n-\n-  final override def close(): Unit = {\n-    resourceRef.updateAndGet { (resource: Value) =>\n-      if (resource != null) {\n-        destruct(resource)\n-        null.asInstanceOf[Value]\n-      } else {\n-        resource\n+        s\"Attempted to read non-initialized resource of ${implicitly[ClassTag[Value]].runtimeClass}\")\n+    }\n+\n+  final override def setup(): Unit =\n+    synchronized {\n+      if (resource.isEmpty) {\n+        resource = Some(construct())\n+      }\n+    }\n+\n+  final override def close(): Unit =\n+    synchronized {\n+      if (resource.isDefined) {\n+        destruct(resource.get)\n+        resource = None\n+        ()"
  }
]