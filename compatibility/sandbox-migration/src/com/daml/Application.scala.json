[
  {
    "id" : "b6b4d739-12ca-45e2-9df1-aeae50e28dd0",
    "prId" : 6244,
    "comments" : [
      {
        "id" : "2bfa45a3-f848-4864-9118-015ebc5a9205",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "fwiw, in general choice arguments are not records in DAML-LF. However, you cannot produce one that is not a record in DAML atm so this should be fine.",
        "createdAt" : "2020-06-05T18:57:03Z",
        "updatedAt" : "2020-06-08T06:33:11Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3cb4040d-826f-4c34-a5be-1fde76744ae4",
        "parentId" : "2bfa45a3-f848-4864-9118-015ebc5a9205",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Yeah, there are many arbitrary decisions here, I mostly wanted to split the concerns, I'm sure there are (and will be) multiple possible improvements.",
        "createdAt" : "2020-06-08T06:27:09Z",
        "updatedAt" : "2020-06-08T06:33:11Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8845557ef5ed5b9a5a9f48108ed16ca00f178d35",
    "line" : 77,
    "diffHunk" : "@@ -0,0 +1,121 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml\n+\n+import java.util.UUID\n+\n+import akka.stream.Materializer\n+import akka.stream.scaladsl.Sink\n+import com.daml.ledger.api.v1.command_service.SubmitAndWaitRequest\n+import com.daml.ledger.api.v1.commands.{Command, Commands, CreateCommand, ExerciseCommand}\n+import com.daml.ledger.api.v1.event.CreatedEvent\n+import com.daml.ledger.api.v1.ledger_offset.LedgerOffset\n+import com.daml.ledger.api.v1.transaction.{Transaction, TransactionTree}\n+import com.daml.ledger.api.v1.transaction_filter.{Filters, InclusiveFilters, TransactionFilter}\n+import com.daml.ledger.api.v1.value.{Identifier, Record, Value}\n+import com.daml.ledger.client.LedgerClient\n+import com.daml.platform.participant.util.ValueConversions._\n+import scalaz.syntax.tag._\n+\n+import scala.concurrent.{ExecutionContext, Future}\n+\n+object Application {\n+\n+  final case class Contract(identifier: String) extends AnyVal\n+  final case class Template(identifier: Identifier) extends AnyVal\n+\n+  final case class Choice(template: Template, name: String)\n+\n+  final class Party(\n+      val name: String,\n+      client: LedgerClient,\n+      applicationId: String,\n+  )(implicit ec: ExecutionContext, mat: Materializer) {\n+\n+    private def submitAndWait(commands: Commands): Future[TransactionTree] =\n+      client.commandServiceClient\n+        .submitAndWaitForTransactionTree(SubmitAndWaitRequest(Some(commands)))\n+        .map(_.getTransaction)\n+\n+    def create(template: Template, arguments: (String, Value)*): Future[Contract] = {\n+      val argument = Record(\n+        Some(template.identifier),\n+        arguments.asRecordFields,\n+      )\n+      val commands = Commands(\n+        party = name,\n+        commands = List(\n+          Command().withCreate(\n+            CreateCommand(\n+              Some(template.identifier),\n+              Some(argument)\n+            )\n+          )\n+        ),\n+        ledgerId = client.ledgerId.unwrap,\n+        applicationId = applicationId,\n+        commandId = UUID.randomUUID.toString\n+      )\n+      for {\n+        tree <- submitAndWait(commands)\n+      } yield {\n+        assert(tree.eventsById.size == 1)\n+        Contract(tree.eventsById.head._2.getCreated.contractId)\n+      }\n+    }\n+\n+    def exercise(choice: Choice, contract: Contract, arguments: (String, Value)*): Future[Value] = {\n+      val commands = Commands(\n+        party = name,\n+        commands = List(\n+          Command().withExercise(\n+            ExerciseCommand(\n+              Some(choice.template.identifier),\n+              contract.identifier,\n+              choice.name,\n+              Some(arguments.asRecordValue),"
  }
]