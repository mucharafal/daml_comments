[
  {
    "id" : "ea15e77d-62dc-44ae-8f75-bc4912076ef8",
    "prId" : 6360,
    "comments" : [
      {
        "id" : "9beccc84-680a-44f1-aa8a-2d559d053df7",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Is `pattern` a GHC-specific feature?",
        "createdAt" : "2020-06-16T08:37:50Z",
        "updatedAt" : "2020-06-16T08:47:33Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d4f5f455-6eb6-435d-8f8d-30b8a114b78d",
        "parentId" : "9beccc84-680a-44f1-aa8a-2d559d053df7",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "GHC-specific as in not supported in DAML? No! You can use pattern synonyms in DAML as well (that’s how `Just` works as a synonym for `Some`). However, it can potentially slow your code down over inlining it since our optimizer is shit. For GHC, the optimizer will usually optimize it to the same code.",
        "createdAt" : "2020-06-16T08:49:44Z",
        "updatedAt" : "2020-06-16T08:49:44Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d26855e-c4ef-4de2-a5f9-a64dc8183d5c",
        "parentId" : "9beccc84-680a-44f1-aa8a-2d559d053df7",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "> GHC-specific as in not supported in DAML?\r\n\r\nNo, as in, part of the extension GHC has on top of standard Haskell.\r\n\r\nJust asking, I never saw this. :slightly_smiling_face: ",
        "createdAt" : "2020-06-16T10:11:04Z",
        "updatedAt" : "2020-06-16T10:11:04Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "286afecd-9043-4510-ab55-311813141c54",
        "parentId" : "9beccc84-680a-44f1-aa8a-2d559d053df7",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Ah yes it is. I don’t differentiate between GHC and standard Haskell. Given that GHC is the only usable Haskell implementation the standard is pretty much irrelevant and it matters much more what GHC does.",
        "createdAt" : "2020-06-16T10:15:06Z",
        "updatedAt" : "2020-06-16T10:15:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5cff7dd79662c53b0d2c9d94af645e4ff856f3a8",
    "line" : 69,
    "diffHunk" : "@@ -104,46 +105,26 @@ data ProposeDeal = ProposeDeal\n \n instance A.FromJSON ProposeDeal\n \n-data Event\n-  = CreatedDeal (ContractId Deal) Deal\n-  | ArchivedDeal (ContractId Deal)\n-  | CreatedProposeDeal (ContractId ProposeDeal) ProposeDeal\n-  | ArchivedProposeDeal (ContractId ProposeDeal)\n-  deriving (Eq, Show)\n-\n-instance A.FromJSON Event where\n-    parseJSON = A.withObject \"Event\" $ \\o -> do\n-        ty <- o A..: \"type\"\n-        moduleName <- o A..: \"moduleName\"\n-        entityName <- o A..: \"entityName\"\n-        case moduleName of\n-            \"ProposeAccept\" -> case ty of\n-                \"created\" -> case entityName of\n-                    \"Deal\" -> CreatedDeal <$> o A..: \"contractId\" <*> o A..: \"argument\"\n-                    \"ProposeDeal\" -> CreatedProposeDeal <$> o A..: \"contractId\" <*> o A..: \"argument\"\n-                    _ -> fail (\"Invalid entity: \" <> entityName)\n-                \"archived\" -> case entityName of\n-                    \"Deal\" -> ArchivedDeal <$> o A..: \"contractId\"\n-                    \"ProposeDeal\" -> ArchivedProposeDeal <$> o A..: \"contractId\"\n-                    _ -> fail (\"Invalid entity: \" <> entityName)\n-                _ -> fail (\"Invalid event type: \" <> ty)\n-            _ -> fail (\"Invalid module: \" <> moduleName)\n-\n-data Transaction = Transaction\n-  { transactionId :: T.Text\n-  , events :: [Event]\n-  } deriving (Generic, Eq, Show)\n-\n-instance A.FromJSON Transaction\n-\n data Result = Result\n-  { oldProposeDeals :: [Tuple2 (ContractId ProposeDeal) ProposeDeal]\n-  , newProposeDeals :: [Tuple2 (ContractId ProposeDeal) ProposeDeal]\n-  , oldDeals :: [Tuple2 (ContractId Deal) Deal]\n-  , newDeals :: [Tuple2 (ContractId Deal) Deal]\n+  { oldProposeDeals :: [Tuple2 ContractId ProposeDeal]\n+  , newProposeDeals :: [Tuple2 ContractId ProposeDeal]\n+  , oldDeals :: [Tuple2 ContractId Deal]\n+  , newDeals :: [Tuple2 ContractId Deal]\n   , oldTransactions :: [Transaction]\n   , newTransactions :: [Transaction]\n   } deriving Generic\n \n instance A.FromJSON Result\n \n+\n+pattern CreatedProposeDeal :: ContractId -> ProposeDeal -> Event"
  }
]