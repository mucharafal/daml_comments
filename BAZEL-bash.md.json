[
  {
    "id" : "c295f901-644b-4788-ac92-df179a5e9cb1",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "8e417b09-ac8b-426b-b46c-b44f5022c74b",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\nThere are a number of limitations in the way Bazel will set up the environment\r\n```",
        "createdAt" : "2019-07-18T15:40:12Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment"
  },
  {
    "id" : "d04d425a-9432-436a-9cf8-cf881bd94fbf",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "5cc7f504-6809-40ac-88ba-f03fa0be1f3d",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "```suggestion\r\nrather than rely on the specific directory structure it has created for you on\r\n```",
        "createdAt" : "2019-07-18T15:45:29Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on"
  },
  {
    "id" : "569ab609-1333-46be-840d-f429db83efdf",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "3897ac5c-0855-441f-8a7d-cc8eda18f9b7",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "At least on Linux the sandbox also watches file access and complains if undeclared dependencies where accessed. There are generally whitelisted directories though. ",
        "createdAt" : "2019-07-18T15:46:49Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : 19,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder."
  },
  {
    "id" : "4067bd98-41af-42dc-91cb-9e39467ac5e3",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "5b8fbc7c-fa8f-4975-8cd6-c512603c3f07",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "Yeah, there isn't much of a compile time. For the binary/test rules `srcs` is the script itself and should just be a singleton. For the library rules it's more of a logical distinction. `srcs` is for bash sources to be sourced, `data` is for other kinds of runtime data files.",
        "createdAt" : "2019-07-18T16:03:28Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me."
  },
  {
    "id" : "a2994abf-f82d-48d5-a278-b2fd5728933f",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "037b9b86-b014-43f2-9e7e-48ecb20a57d7",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "[`select`](https://docs.bazel.build/versions/master/be/functions.html#select) is another way to put conditionals into BUILD files. More complex expressions can to be extracted into `.bzl` files and loaded as macros.",
        "createdAt" : "2019-07-18T16:08:24Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : 73,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me.\n+\n+## `genrule`: substitutions\n+\n+The code of a `genrule` directive is the `cmd` attribute, which is a multiline\n+string embedding a Bash script. Within that script, you need to use `$$` to\n+produce a single `$` in the Bash script itself, as `$()` will be expanded by\n+Bazel's own string interpolation. You can use the `location` and `locations`\n+functions to get at file paths. You should note that the paths these returns is\n+relative to the starting `$PWD` of the script, so if your Bash script `cd`s\n+somwhere, you have to take that into account.\n+\n+Note that the script will start running from (virtually) the root of the\n+project, regardless of where in the tree your package sits, in that if you\n+include local files they will be under your package's path. Only the files you\n+have explicitly specified as depencencies will be present.\n+\n+`srcs` files will generally be placed by Bazel at their current place in the\n+workdir, e.g. if you specify `//:VERSION` you will get the `VERSION` file in\n+your current directory when the script starts executing, but if you specify\n+local targets they will be under the same path as your current `BUILD.bazel`\n+file. Try to prefer using `location` entries when possible. I do not know how\n+to do that for local files, though.\n+\n+You can specify local files (that are not Bazel rule results) using the `glob`\n+function in the `srcs` attribute, e.g.\n+```\n+    srcs = glob([\n+        \"*.c\"\n+    ])\n+```\n+This function returns a Bazel array, which can be concatenated with another\n+using `+` (typically a literal array to combine the list of local files with a\n+list of Bazel targets).\n+\n+Note that tools and data dependencies will also be given as relative (to the\n+script's starting directory) paths through the `location` function.\n+\n+## Conditionals\n+\n+Bazel supports simple conditionals in its rules, though I have not found a way\n+to use them in string substitutions. As some rules have different names under\n+Windows, this creates a bit of a problem. Aliases provide a way around that;\n+for example:\n+```\n+alias(\n+    name = \"yarn\",\n+    actual = \"@nodejs//:bin/yarn.cmd\" if is_windows else \"@nodejs//:bin/yarn\","
  },
  {
    "id" : "dc2c88a5-4b21-4eb2-ad07-78e15792b201",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "5d7b6462-634a-4c06-9235-9c137f2a0977",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "`args` is documented with the [common attributes](https://docs.bazel.build/versions/master/be/common-definitions.html#common-attributes-tests)",
        "createdAt" : "2019-07-18T16:13:12Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me.\n+\n+## `genrule`: substitutions\n+\n+The code of a `genrule` directive is the `cmd` attribute, which is a multiline\n+string embedding a Bash script. Within that script, you need to use `$$` to\n+produce a single `$` in the Bash script itself, as `$()` will be expanded by\n+Bazel's own string interpolation. You can use the `location` and `locations`\n+functions to get at file paths. You should note that the paths these returns is\n+relative to the starting `$PWD` of the script, so if your Bash script `cd`s\n+somwhere, you have to take that into account.\n+\n+Note that the script will start running from (virtually) the root of the\n+project, regardless of where in the tree your package sits, in that if you\n+include local files they will be under your package's path. Only the files you\n+have explicitly specified as depencencies will be present.\n+\n+`srcs` files will generally be placed by Bazel at their current place in the\n+workdir, e.g. if you specify `//:VERSION` you will get the `VERSION` file in\n+your current directory when the script starts executing, but if you specify\n+local targets they will be under the same path as your current `BUILD.bazel`\n+file. Try to prefer using `location` entries when possible. I do not know how\n+to do that for local files, though.\n+\n+You can specify local files (that are not Bazel rule results) using the `glob`\n+function in the `srcs` attribute, e.g.\n+```\n+    srcs = glob([\n+        \"*.c\"\n+    ])\n+```\n+This function returns a Bazel array, which can be concatenated with another\n+using `+` (typically a literal array to combine the list of local files with a\n+list of Bazel targets).\n+\n+Note that tools and data dependencies will also be given as relative (to the\n+script's starting directory) paths through the `location` function.\n+\n+## Conditionals\n+\n+Bazel supports simple conditionals in its rules, though I have not found a way\n+to use them in string substitutions. As some rules have different names under\n+Windows, this creates a bit of a problem. Aliases provide a way around that;\n+for example:\n+```\n+alias(\n+    name = \"yarn\",\n+    actual = \"@nodejs//:bin/yarn.cmd\" if is_windows else \"@nodejs//:bin/yarn\",\n+)\n+```\n+would let you use, in the `cmd` entry of a script:\n+```\n+        $$DIR/$(location :yarn)\n+```\n+to invoke the correct `yarn` executable regardless of platform.\n+\n+## Links and speed\n+\n+Bazel relies a lot on symbolic links to provide what should appear like a new,\n+isolated environment to each build rule without having to pay the cost of\n+copying files over each time. However, this means that\n+1. Everything path-related is different on Windows, because symlinks there are\n+   not well-supported, and\n+1. While Bazel can claim some nice speed for creating the environment, every\n+   read your rule does from a Bazel-provided file takes the hit of going\n+   through the symlink indirection.\n+That second point can be very costly when you have to read many small files\n+(e.g. node dependencies).\n+\n+## `sh_test`: \"runfiles\"\n+\n+Life would be boring if all of the above applied to all invocations of Bash\n+through Bazel, regardless of context. Composability is apparently a non-goal\n+for a build system. In order to write a test in Bash, rather than having an\n+embedded Bash script with Bazel-provided substitutions as in the case of\n+`genrule`, the `sh_test` rule takes as argument a Bash script that must exist\n+as a separate file.\n+\n+A useful feature of `sh_test` that happens to not be documented on [its"
  },
  {
    "id" : "7f1d6c41-d365-4a56-a5f5-70994cc0e937",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "6e1b92ec-f84f-44d3-8811-a0e218c9279f",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "It's documentation seems to be spread about a bit. There's the [examples](https://github.com/bazelbuild/bazel/blob/1186ceccd13efaada5693933f41faa52c77645d3/examples/shell/BUILD). Sadly, they still use the old boilerplate. And the [`runfiles` library itself](https://github.com/bazelbuild/bazel/blob/1186ceccd13efaada5693933f41faa52c77645d3/tools/bash/runfiles/runfiles.bash#L39). The latter includes the boilerplate and a very brief usage example.",
        "createdAt" : "2019-07-18T16:18:10Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me.\n+\n+## `genrule`: substitutions\n+\n+The code of a `genrule` directive is the `cmd` attribute, which is a multiline\n+string embedding a Bash script. Within that script, you need to use `$$` to\n+produce a single `$` in the Bash script itself, as `$()` will be expanded by\n+Bazel's own string interpolation. You can use the `location` and `locations`\n+functions to get at file paths. You should note that the paths these returns is\n+relative to the starting `$PWD` of the script, so if your Bash script `cd`s\n+somwhere, you have to take that into account.\n+\n+Note that the script will start running from (virtually) the root of the\n+project, regardless of where in the tree your package sits, in that if you\n+include local files they will be under your package's path. Only the files you\n+have explicitly specified as depencencies will be present.\n+\n+`srcs` files will generally be placed by Bazel at their current place in the\n+workdir, e.g. if you specify `//:VERSION` you will get the `VERSION` file in\n+your current directory when the script starts executing, but if you specify\n+local targets they will be under the same path as your current `BUILD.bazel`\n+file. Try to prefer using `location` entries when possible. I do not know how\n+to do that for local files, though.\n+\n+You can specify local files (that are not Bazel rule results) using the `glob`\n+function in the `srcs` attribute, e.g.\n+```\n+    srcs = glob([\n+        \"*.c\"\n+    ])\n+```\n+This function returns a Bazel array, which can be concatenated with another\n+using `+` (typically a literal array to combine the list of local files with a\n+list of Bazel targets).\n+\n+Note that tools and data dependencies will also be given as relative (to the\n+script's starting directory) paths through the `location` function.\n+\n+## Conditionals\n+\n+Bazel supports simple conditionals in its rules, though I have not found a way\n+to use them in string substitutions. As some rules have different names under\n+Windows, this creates a bit of a problem. Aliases provide a way around that;\n+for example:\n+```\n+alias(\n+    name = \"yarn\",\n+    actual = \"@nodejs//:bin/yarn.cmd\" if is_windows else \"@nodejs//:bin/yarn\",\n+)\n+```\n+would let you use, in the `cmd` entry of a script:\n+```\n+        $$DIR/$(location :yarn)\n+```\n+to invoke the correct `yarn` executable regardless of platform.\n+\n+## Links and speed\n+\n+Bazel relies a lot on symbolic links to provide what should appear like a new,\n+isolated environment to each build rule without having to pay the cost of\n+copying files over each time. However, this means that\n+1. Everything path-related is different on Windows, because symlinks there are\n+   not well-supported, and\n+1. While Bazel can claim some nice speed for creating the environment, every\n+   read your rule does from a Bazel-provided file takes the hit of going\n+   through the symlink indirection.\n+That second point can be very costly when you have to read many small files\n+(e.g. node dependencies).\n+\n+## `sh_test`: \"runfiles\"\n+\n+Life would be boring if all of the above applied to all invocations of Bash\n+through Bazel, regardless of context. Composability is apparently a non-goal\n+for a build system. In order to write a test in Bash, rather than having an\n+embedded Bash script with Bazel-provided substitutions as in the case of\n+`genrule`, the `sh_test` rule takes as argument a Bash script that must exist\n+as a separate file.\n+\n+A useful feature of `sh_test` that happens to not be documented on [its\n+official documentation\n+page](https://docs.bazel.build/versions/master/be/shell.html#sh_test) is that\n+you can pass it an `args` attribute, which gives you a way to pass in some\n+Bazel-provided `location`s.\n+\n+Another interesting feature that happens to not be documented anywhere in the"
  },
  {
    "id" : "a0e26c82-c481-4424-9876-74a1b3889118",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "1b6d203f-50c6-4ff1-b6be-0ace13e22db4",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "filenames are valid targets. They may need appropriate visibility using [`exports_files`](https://docs.bazel.build/versions/master/be/functions.html#exports_files) though.",
        "createdAt" : "2019-07-18T16:21:14Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : 147,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me.\n+\n+## `genrule`: substitutions\n+\n+The code of a `genrule` directive is the `cmd` attribute, which is a multiline\n+string embedding a Bash script. Within that script, you need to use `$$` to\n+produce a single `$` in the Bash script itself, as `$()` will be expanded by\n+Bazel's own string interpolation. You can use the `location` and `locations`\n+functions to get at file paths. You should note that the paths these returns is\n+relative to the starting `$PWD` of the script, so if your Bash script `cd`s\n+somwhere, you have to take that into account.\n+\n+Note that the script will start running from (virtually) the root of the\n+project, regardless of where in the tree your package sits, in that if you\n+include local files they will be under your package's path. Only the files you\n+have explicitly specified as depencencies will be present.\n+\n+`srcs` files will generally be placed by Bazel at their current place in the\n+workdir, e.g. if you specify `//:VERSION` you will get the `VERSION` file in\n+your current directory when the script starts executing, but if you specify\n+local targets they will be under the same path as your current `BUILD.bazel`\n+file. Try to prefer using `location` entries when possible. I do not know how\n+to do that for local files, though.\n+\n+You can specify local files (that are not Bazel rule results) using the `glob`\n+function in the `srcs` attribute, e.g.\n+```\n+    srcs = glob([\n+        \"*.c\"\n+    ])\n+```\n+This function returns a Bazel array, which can be concatenated with another\n+using `+` (typically a literal array to combine the list of local files with a\n+list of Bazel targets).\n+\n+Note that tools and data dependencies will also be given as relative (to the\n+script's starting directory) paths through the `location` function.\n+\n+## Conditionals\n+\n+Bazel supports simple conditionals in its rules, though I have not found a way\n+to use them in string substitutions. As some rules have different names under\n+Windows, this creates a bit of a problem. Aliases provide a way around that;\n+for example:\n+```\n+alias(\n+    name = \"yarn\",\n+    actual = \"@nodejs//:bin/yarn.cmd\" if is_windows else \"@nodejs//:bin/yarn\",\n+)\n+```\n+would let you use, in the `cmd` entry of a script:\n+```\n+        $$DIR/$(location :yarn)\n+```\n+to invoke the correct `yarn` executable regardless of platform.\n+\n+## Links and speed\n+\n+Bazel relies a lot on symbolic links to provide what should appear like a new,\n+isolated environment to each build rule without having to pay the cost of\n+copying files over each time. However, this means that\n+1. Everything path-related is different on Windows, because symlinks there are\n+   not well-supported, and\n+1. While Bazel can claim some nice speed for creating the environment, every\n+   read your rule does from a Bazel-provided file takes the hit of going\n+   through the symlink indirection.\n+That second point can be very costly when you have to read many small files\n+(e.g. node dependencies).\n+\n+## `sh_test`: \"runfiles\"\n+\n+Life would be boring if all of the above applied to all invocations of Bash\n+through Bazel, regardless of context. Composability is apparently a non-goal\n+for a build system. In order to write a test in Bash, rather than having an\n+embedded Bash script with Bazel-provided substitutions as in the case of\n+`genrule`, the `sh_test` rule takes as argument a Bash script that must exist\n+as a separate file.\n+\n+A useful feature of `sh_test` that happens to not be documented on [its\n+official documentation\n+page](https://docs.bazel.build/versions/master/be/shell.html#sh_test) is that\n+you can pass it an `args` attribute, which gives you a way to pass in some\n+Bazel-provided `location`s.\n+\n+Another interesting feature that happens to not be documented anywhere in the\n+official documentation as far as I could find (though there are notes about it\n+in comments in the Bazel source code) is that your test script will not run on\n+Windows unless you add a lot of Bazel-specific bits to it.\n+\n+For starters, you script needs to take this additional dependency:\n+```\n+deps = [\"@bazel_tools//tools/bash/runfiles\"],\n+```\n+You cannot do anything without it, but it is not provided by default.\n+\n+Then, anything your script needs access to, including executables, needs to be\n+passed in as arguments (using `location`). In the script itself, near the start\n+(and definitely before you try using any argument), you have to paste [the\n+following snippet from the Bazel runfiles]():\n+```\n+    # Copy-pasted from the Bazel Bash runfiles library v2.\n+    set -uo pipefail; f=bazel_tools/tools/bash/runfiles/runfiles.bash\n+    source \"${RUNFILES_DIR:-/dev/null}/$f\" 2>/dev/null || \\\n+      source \"$(grep -sm1 \"^$f \" \"${RUNFILES_MANIFEST_FILE:-/dev/null}\" | cut -f2- -d' ')\" 2>/dev/null || \\\n+      source \"$0.runfiles/$f\" 2>/dev/null || \\\n+      source \"$(grep -sm1 \"^$f \" \"$0.runfiles_manifest\" | cut -f2- -d' ')\" 2>/dev/null || \\\n+      source \"$(grep -sm1 \"^$f \" \"$0.exe.runfiles_manifest\" | cut -f2- -d' ')\" 2>/dev/null || \\\n+      { echo>&2 \"ERROR: cannot find $f\"; exit 1; }; f=; set -e\n+    # --- end runfiles.bash initialization v2 ---\n+```\n+After that, in your Bash script, you can construct the paths to your actual\n+arguments by taking the values Bazel gave you and expanding them like:\n+```\n+MY_FIRST_ARG=\"$(rlocation \"$TEST_WORKSPACE/$1\")\"\n+```\n+The `TEST_WORKSPACE` variable is set by Bazel. Note that the \"documentation\"\n+for the above snippet may make you think that, when constructing the argument\n+to `rlocation`, you should use the workspace of the path you're trying to reach\n+(when using rules from external workspaces); as far as I can tell you should\n+always use `$TEST_WORKSPACE`. Also note that `$1` in this case is a path Bazel\n+passed in as argument, as the result of a `$(location ...)` substitution in the\n+corresponding `BUILD.bazel` file.\n+\n+Note that you should jump through the above hopps for _all_ of your\n+dependencies, _including_ files from the same package as the `sh_test`. Trying\n+to access those files directly by their expected path, as you can do in\n+`genrule`s, will not work with `sh_test` on Windows. You may have to wrap your\n+local files in a `filegroup` to have a valid target for the `$(location ...)`"
  },
  {
    "id" : "cd569fd7-c234-4b84-bef6-7f422e8bb74f",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "6ff13b38-de93-4a6a-ba01-94ede46212e8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nThere are a number of limitations in the way Bazel will set up the environment\r\n```",
        "createdAt" : "2019-07-19T06:54:51Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment"
  },
  {
    "id" : "087a3855-0629-4a1d-bb0c-3ea11f50b190",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "9e16027d-f5ef-440c-b4b9-b3756e1b75e1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not entirely sure this section is super helpful. It is definitely not true that rules working on Windows will also work on Linux. One reason for that is the lack of sandboxing on Windows.",
        "createdAt" : "2019-07-19T06:56:36Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9c92a347-9bb7-4dbf-8935-4deb2a30adfd",
        "parentId" : "9e16027d-f5ef-440c-b4b9-b3756e1b75e1",
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "For macOS the reason is that we use nixpkgs provided coreutils. I.e. we get GNU coreutils instead of BSD coreutils on macOS.",
        "createdAt" : "2019-07-19T07:21:56Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my"
  },
  {
    "id" : "33fc958c-b1ab-4bf0-a97a-d3732131d58f",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "65b1d03e-2e98-41b3-afbb-319d9beb7ac1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nrather than rely on the specific directory structure it has created for you on\r\n```",
        "createdAt" : "2019-07-19T06:56:49Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on"
  },
  {
    "id" : "25b1e9ff-1bfd-4216-bcd0-d6dd09f92b24",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "cfabe82f-f043-4c9e-bc0c-ce8c6c6925be",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`genrule` doesnâ€™t have `data` at all. For `sh_test` the Bazel documentation states\r\n```\r\nThis attribute (`srcs`) must be a singleton list, whose element is the shell script. This script must be executable, and may be a source file or a generated file. All other files required at runtime (whether scripts or data) belong in the data attribute. \r\n```\r\nwhich should hopefully make clear what should go in `data` and in `srcs`.",
        "createdAt" : "2019-07-19T07:01:05Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If"
  },
  {
    "id" : "40f017e5-ca4d-46d9-a1c9-b2467225561f",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "a26f8091-f2a0-413e-9bda-53e2a84fa413",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What do you mean by `local files` here?",
        "createdAt" : "2019-07-19T07:02:24Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me.\n+\n+## `genrule`: substitutions\n+\n+The code of a `genrule` directive is the `cmd` attribute, which is a multiline\n+string embedding a Bash script. Within that script, you need to use `$$` to\n+produce a single `$` in the Bash script itself, as `$()` will be expanded by\n+Bazel's own string interpolation. You can use the `location` and `locations`\n+functions to get at file paths. You should note that the paths these returns is\n+relative to the starting `$PWD` of the script, so if your Bash script `cd`s\n+somwhere, you have to take that into account.\n+\n+Note that the script will start running from (virtually) the root of the\n+project, regardless of where in the tree your package sits, in that if you\n+include local files they will be under your package's path. Only the files you\n+have explicitly specified as depencencies will be present.\n+\n+`srcs` files will generally be placed by Bazel at their current place in the\n+workdir, e.g. if you specify `//:VERSION` you will get the `VERSION` file in\n+your current directory when the script starts executing, but if you specify\n+local targets they will be under the same path as your current `BUILD.bazel`\n+file. Try to prefer using `location` entries when possible. I do not know how\n+to do that for local files, though."
  },
  {
    "id" : "fcbf5e43-00b7-4aae-a90a-16d2efda4cda",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "ec2648ab-2e0a-47c7-878e-7c5895c80718",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "While I emphasize with your pain, I would prefer to limit those docs to the content that is actually helpful. This is already a fairly long document and adding more â€œproseâ€ to it only makes it harder to find what you are looking for.",
        "createdAt" : "2019-07-19T07:04:52Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me.\n+\n+## `genrule`: substitutions\n+\n+The code of a `genrule` directive is the `cmd` attribute, which is a multiline\n+string embedding a Bash script. Within that script, you need to use `$$` to\n+produce a single `$` in the Bash script itself, as `$()` will be expanded by\n+Bazel's own string interpolation. You can use the `location` and `locations`\n+functions to get at file paths. You should note that the paths these returns is\n+relative to the starting `$PWD` of the script, so if your Bash script `cd`s\n+somwhere, you have to take that into account.\n+\n+Note that the script will start running from (virtually) the root of the\n+project, regardless of where in the tree your package sits, in that if you\n+include local files they will be under your package's path. Only the files you\n+have explicitly specified as depencencies will be present.\n+\n+`srcs` files will generally be placed by Bazel at their current place in the\n+workdir, e.g. if you specify `//:VERSION` you will get the `VERSION` file in\n+your current directory when the script starts executing, but if you specify\n+local targets they will be under the same path as your current `BUILD.bazel`\n+file. Try to prefer using `location` entries when possible. I do not know how\n+to do that for local files, though.\n+\n+You can specify local files (that are not Bazel rule results) using the `glob`\n+function in the `srcs` attribute, e.g.\n+```\n+    srcs = glob([\n+        \"*.c\"\n+    ])\n+```\n+This function returns a Bazel array, which can be concatenated with another\n+using `+` (typically a literal array to combine the list of local files with a\n+list of Bazel targets).\n+\n+Note that tools and data dependencies will also be given as relative (to the\n+script's starting directory) paths through the `location` function.\n+\n+## Conditionals\n+\n+Bazel supports simple conditionals in its rules, though I have not found a way\n+to use them in string substitutions. As some rules have different names under\n+Windows, this creates a bit of a problem. Aliases provide a way around that;\n+for example:\n+```\n+alias(\n+    name = \"yarn\",\n+    actual = \"@nodejs//:bin/yarn.cmd\" if is_windows else \"@nodejs//:bin/yarn\",\n+)\n+```\n+would let you use, in the `cmd` entry of a script:\n+```\n+        $$DIR/$(location :yarn)\n+```\n+to invoke the correct `yarn` executable regardless of platform.\n+\n+## Links and speed\n+\n+Bazel relies a lot on symbolic links to provide what should appear like a new,\n+isolated environment to each build rule without having to pay the cost of\n+copying files over each time. However, this means that\n+1. Everything path-related is different on Windows, because symlinks there are\n+   not well-supported, and\n+1. While Bazel can claim some nice speed for creating the environment, every\n+   read your rule does from a Bazel-provided file takes the hit of going\n+   through the symlink indirection.\n+That second point can be very costly when you have to read many small files\n+(e.g. node dependencies).\n+\n+## `sh_test`: \"runfiles\"\n+\n+Life would be boring if all of the above applied to all invocations of Bash"
  },
  {
    "id" : "17715813-bd83-4f54-8239-730e86eef863",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "6d55bdde-b108-4b49-bfad-0306caeed171",
        "parentId" : null,
        "author" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "body" : "By string substitution you mean `$(location)` expansion? It's syntax is fairly limited. The details are documented [here](https://docs.bazel.build/versions/master/be/make-variables.html#predefined_label_variables).",
        "createdAt" : "2019-07-19T07:24:51Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "aherrmann-da",
          "name" : "Andreas Herrmann",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/42969706?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "078a135c-1d48-46d3-ac4d-177e268879e9",
        "parentId" : "6d55bdde-b108-4b49-bfad-0306caeed171",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "TIL:\r\n\r\n> `location`: A synonym for either `execpath` or `rootpath`, depending on the attribute being expanded. This is legacy pre-Starlark behavior and **not recommended** unless you really know what it does for a particular rule. See #2475 for details.\r\n\r\nI'm not going to go back to fix it now, but this is definitely something I'll dig into next time I have to touch Bazel.",
        "createdAt" : "2019-07-19T14:04:32Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : 67,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set uo the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on th specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder.\n+\n+As such, in order to get all of your dependencies available, you need to\n+specify them in the relevant attributes: `srcs` for files required during\n+build, `data` for files required at run time, and `tools` for executables. If\n+you're wondering what the distinction is between run time and build time for\n+Bash scripts, well, don't ask me.\n+\n+## `genrule`: substitutions\n+\n+The code of a `genrule` directive is the `cmd` attribute, which is a multiline\n+string embedding a Bash script. Within that script, you need to use `$$` to\n+produce a single `$` in the Bash script itself, as `$()` will be expanded by\n+Bazel's own string interpolation. You can use the `location` and `locations`\n+functions to get at file paths. You should note that the paths these returns is\n+relative to the starting `$PWD` of the script, so if your Bash script `cd`s\n+somwhere, you have to take that into account.\n+\n+Note that the script will start running from (virtually) the root of the\n+project, regardless of where in the tree your package sits, in that if you\n+include local files they will be under your package's path. Only the files you\n+have explicitly specified as depencencies will be present.\n+\n+`srcs` files will generally be placed by Bazel at their current place in the\n+workdir, e.g. if you specify `//:VERSION` you will get the `VERSION` file in\n+your current directory when the script starts executing, but if you specify\n+local targets they will be under the same path as your current `BUILD.bazel`\n+file. Try to prefer using `location` entries when possible. I do not know how\n+to do that for local files, though.\n+\n+You can specify local files (that are not Bazel rule results) using the `glob`\n+function in the `srcs` attribute, e.g.\n+```\n+    srcs = glob([\n+        \"*.c\"\n+    ])\n+```\n+This function returns a Bazel array, which can be concatenated with another\n+using `+` (typically a literal array to combine the list of local files with a\n+list of Bazel targets).\n+\n+Note that tools and data dependencies will also be given as relative (to the\n+script's starting directory) paths through the `location` function.\n+\n+## Conditionals\n+\n+Bazel supports simple conditionals in its rules, though I have not found a way\n+to use them in string substitutions. As some rules have different names under"
  },
  {
    "id" : "9dc34478-38cb-4eb9-a4c9-70441a68763f",
    "prId" : 2223,
    "comments" : [
      {
        "id" : "068405cf-33a6-42b4-a65f-5281c379f34f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\na specially set up folder.\r\n```",
        "createdAt" : "2019-07-19T07:50:46Z",
        "updatedAt" : "2019-07-19T14:08:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d89bfbad4ef7c0169b2a8a068c81bc9b631bc270",
    "line" : 19,
    "diffHunk" : "@@ -0,0 +1,162 @@\n+# Working with Bash in Bazel\n+\n+Bazel has two out-of-the-box rules, `sh_test` and `genrule`, that can be used\n+for one-shot custom build targets. If there is some reusable logic behind your\n+target, consider building a new rule in Skylark instead.\n+\n+## Platform\n+\n+There are a number of limitations in the way Bazel will set up the environment\n+for these Bash scripts when running them, and they differ based on the OS. The\n+Windows setup is the most constraining and the macOS one is the most\n+permissive, i.e. when writing a new rule, the rule working on macOS does not\n+give any guarantee that it will also run on either Linux or Windows, and the\n+rule working on Linux does not guaranteee it will run on Windows. In my\n+experience, it does seem like rules working on Windows will also work on Linux\n+and macOS.\n+\n+Some of the default paths Bazel creates for you seem to depend on the platform,\n+so be sure to always access dependencies through Bazel's `location` mechanism\n+rather than rely on the specific directory structure it has created for you on\n+your machine.\n+\n+## Dependencies\n+\n+Bazel promises hermeticity, but Bash scripts have access to whatever they want.\n+As far as I can tell they are not run in any kind of chroot or container (at\n+least on macOS), although they are run with a restricted PATH (on Linux) and in\n+a specially set-up folder."
  }
]