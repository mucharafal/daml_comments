[
  {
    "id" : "38a4a5e5-f328-43f3-add0-e0cd5f59f417",
    "prId" : 6834,
    "comments" : [
      {
        "id" : "c753e547-cb2a-46cb-96d6-4b20a3704de4",
        "parentId" : null,
        "author" : {
          "login" : "RobinKrom",
          "name" : "drsk",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/827698?v=4"
        },
        "body" : "Where is the `DecoderLazy` actually constructed in the codegen?",
        "createdAt" : "2020-07-22T17:53:45Z",
        "updatedAt" : "2020-07-22T17:53:45Z",
        "lastEditedBy" : {
          "login" : "RobinKrom",
          "name" : "drsk",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/827698?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3d78b0e1-600c-458e-941c-5745d9c4d82c",
        "parentId" : "c753e547-cb2a-46cb-96d6-4b20a3704de4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "For variants, that part is fine. The problem is that variants are not the only way to write recursive (terminating) types `Optional`, `List` and `TextMap` give you the same issues and therefore need to be lazy as well. This just seemed like the most appropriate place to document what needs to be lazy.",
        "createdAt" : "2020-07-22T17:54:59Z",
        "updatedAt" : "2020-07-22T17:54:59Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e0128720-25bd-4014-a20d-431a8833cd60",
        "parentId" : "c753e547-cb2a-46cb-96d6-4b20a3704de4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The other option would be to make all record fields lazy but I’m not quite sure around the performance implications of making things lazy so limiting it to where we need it to break recursion seemed like a better choice.",
        "createdAt" : "2020-07-22T17:58:53Z",
        "updatedAt" : "2020-07-22T17:58:54Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "85d26b83-f357-46cc-b9bb-4d83ac78b9c8",
        "parentId" : "c753e547-cb2a-46cb-96d6-4b20a3704de4",
        "author" : {
          "login" : "RobinKrom",
          "name" : "drsk",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/827698?v=4"
        },
        "body" : "makes sense, thanks!",
        "createdAt" : "2020-07-23T08:48:17Z",
        "updatedAt" : "2020-07-23T08:48:18Z",
        "lastEditedBy" : {
          "login" : "RobinKrom",
          "name" : "drsk",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/827698?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6665127fa528a85209f8a213aa3865360858ad44",
    "line" : 5,
    "diffHunk" : "@@ -478,7 +478,9 @@ data Decoder\n     | DecoderObject [(T.Text, Decoder)]\n     | DecoderConstant DecoderConstant\n     | DecoderRef TypeRef -- ^ Reference to an object with a .decoder() method\n-    | DecoderLazy Decoder\n+    | DecoderLazy Decoder -- ^ Lazy decoder, we need this to avoid infinite loops"
  },
  {
    "id" : "afa64f8b-f6ae-42f5-b12e-4aaaba8af824",
    "prId" : 6834,
    "comments" : [
      {
        "id" : "f165b0e0-8c0d-4652-a35b-c87520ab1bd7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I assume with \"terminating recursive types\" you meant recursive types that are inhabited. Is that correct?",
        "createdAt" : "2020-07-22T20:44:57Z",
        "updatedAt" : "2020-07-22T21:00:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6665127fa528a85209f8a213aa3865360858ad44",
    "line" : 7,
    "diffHunk" : "@@ -478,7 +478,9 @@ data Decoder\n     | DecoderObject [(T.Text, Decoder)]\n     | DecoderConstant DecoderConstant\n     | DecoderRef TypeRef -- ^ Reference to an object with a .decoder() method\n-    | DecoderLazy Decoder\n+    | DecoderLazy Decoder -- ^ Lazy decoder, we need this to avoid infinite loops\n+    -- on recursive types. We insert this in every variant, Optional, List and TextMap\n+    -- which are the only ways to construct terminating recursive types."
  },
  {
    "id" : "243e1a13-d65e-45c6-9d39-121bf847c11e",
    "prId" : 6657,
    "comments" : [
      {
        "id" : "c2c0ceac-9366-440d-8ec2-86f904a5a5cc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n          -- Where the source files of this package are written e.g. '/path/to/daml2js/davl-0.0.4/lib'.\r\n```\r\nor maybe delete this comment completely.",
        "createdAt" : "2020-07-09T19:12:08Z",
        "updatedAt" : "2020-07-09T19:31:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "381ee9cd524fb450ded324f1f48f4cc97a2cf7cb",
    "line" : null,
    "diffHunk" : "@@ -163,14 +153,14 @@ data Daml2jsParams = Daml2jsParams\n   }\n \n -- Write the files for a single package.\n-daml2js :: Daml2jsParams -> IO (T.Text, [Dependency])\n+daml2js :: Daml2jsParams -> IO ()\n daml2js Daml2jsParams {..} = do\n     let Options {..} = opts\n         scopeDir = optOutputDir\n           -- The directory into which we generate packages e.g. '/path/to/daml2js'.\n         packageDir = scopeDir </> T.unpack pkgName\n           -- The directory into which we write this package e.g. '/path/to/daml2js/davl-0.0.4'.\n-        packageSrcDir = packageDir </> \"src\"\n+        packageSrcDir = packageDir </> \"lib\"\n           -- Where the source files of this package are written e.g. '/path/to/daml2js/davl-0.0.4/src'."
  },
  {
    "id" : "ef8e5c8d-4a04-495a-a4a2-a8f50f1d709b",
    "prId" : 6657,
    "comments" : [
      {
        "id" : "bc20d9c4-0cd9-41d1-9a4d-928660bff358",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I just learnt that `const` was only introduced in ES6. 😞",
        "createdAt" : "2020-07-09T19:15:49Z",
        "updatedAt" : "2020-07-09T19:31:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d4e5abff-8802-4055-b9ae-9dfa7105ffa8",
        "parentId" : "bc20d9c4-0cd9-41d1-9a4d-928660bff358",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Yeah all the good stuff is only in ES6 :cry: But given that this is generated code it luckily isn’t a big deal (and I believe the typescript typechecker might still yell at you although I haven’t verified that (should be the same as before)).",
        "createdAt" : "2020-07-09T19:32:58Z",
        "updatedAt" : "2020-07-09T19:32:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "381ee9cd524fb450ded324f1f48f4cc97a2cf7cb",
    "line" : 131,
    "diffHunk" : "@@ -209,18 +199,28 @@ genModule pkgMap (Scope scope) curPkgId mod\n         imports = (PRSelf, modName) `Set.delete` Set.unions refs\n         (internalImports, externalImports) = splitImports imports\n         rootPath = map (const \"..\") (unModuleName modName)\n-        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $\n-          modHeader\n-          : map (externalImportDecl pkgMap) (Set.toList externalImports)\n-          : map (internalImportDecl rootPath) internalImports\n-          : map (map renderTsDecl) decls\n+        makeMod jsSyntax body = T.unlines $ intercalate [\"\"] $ filter (not . null) $\n+          modHeader jsSyntax\n+          : map (externalImportDecl jsSyntax pkgMap) (Set.toList externalImports)\n+          : map (internalImportDecl jsSyntax rootPath) internalImports\n+          : body\n+\n+        (jsBody, tsDeclsBody) = unzip $ map (unzip . map renderTsDecl) decls\n         depends = Set.map (Dependency . pkgRefStr pkgMap) externalImports\n-   in Just (modText, depends)\n+   in Just ((makeMod ES5 jsBody, makeMod ES6 tsDeclsBody), depends)\n   where\n     modName = moduleName mod\n     tpls = moduleTemplates mod\n     serDefs = defDataTypes mod\n-    modHeader =\n+    modHeader ES5 = commonjsPrefix ++\n+      [ \"/* eslint-disable-next-line no-unused-vars */\"\n+      , \"var jtv = require('@mojotech/json-type-validation');\""
  },
  {
    "id" : "6750379a-01b1-4052-8eba-d2f223e50bfd",
    "prId" : 6657,
    "comments" : [
      {
        "id" : "e5c2cb0f-3f3b-4e1f-b684-029c755c09c0",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Damn OCD:\r\n```suggestion\r\n            , [ \"  }\"\r\n```",
        "createdAt" : "2020-07-09T19:22:05Z",
        "updatedAt" : "2020-07-09T19:31:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "381ee9cd524fb450ded324f1f48f4cc97a2cf7cb",
    "line" : null,
    "diffHunk" : "@@ -394,55 +407,75 @@ data SerializableDef = SerializableDef\n   -- ^ For sums of products, e.g., `data X = Y { a : Int }\n   }\n \n-renderSerializableDef :: SerializableDef -> T.Text\n+renderSerializableDef :: SerializableDef -> (T.Text, T.Text)\n renderSerializableDef SerializableDef{..}\n-  | null serParams = T.unlines $ concat\n-      [ [ \"export const \" <> serName <> \":\"\n-        , \"  damlTypes.Serializable<\" <> serName <> \"> & {\"\n-        ]\n-      , [ \"  \" <> n <> \": damlTypes.Serializable<\" <> serName <.> n <> \">;\" | (n, _) <- serNestedDecoders ]\n-      , [ \"  } \"\n-        ]\n-      , [ \"& { readonly keys: \" <> serName <> \"[] } & { readonly [e in \" <> serName <> \"]: e }\" | notNull serKeys ]\n-      , [ \"  = ({\" ]\n-      , [ \"  \" <> k <> \":\" <> \"'\" <> k <> \"',\" | k <- serKeys ]\n-      , [ \"  keys: [\" <> T.concat (map (\\s -> \"'\" <> s <> \"',\") serKeys) <> \"],\" | notNull serKeys ]\n-      , [ \"  decoder: () => \" <> renderDecoder serDecoder <> \",\"\n-        ]\n-      , concat $\n-        [ [ \"  \" <> n <> \":({\"\n-          , \"    decoder: () => \" <> renderDecoder d <> \",\"\n-          , \"  }),\"\n+  | null serParams =\n+    let tsDecl = T.unlines $ concat\n+            [ [ \"export declare const \" <> serName <> \":\"\n+              , \"  damlTypes.Serializable<\" <> serName <> \"> & {\"\n+              ]\n+            , [ \"  \" <> n <> \": damlTypes.Serializable<\" <> serName <.> n <> \">;\" | (n, _) <- serNestedDecoders ]\n+            , [ \"  } \""
  },
  {
    "id" : "d2b0047f-8e40-4b97-9cca-f6d161379059",
    "prId" : 6615,
    "comments" : [
      {
        "id" : "0190d890-e3fb-4280-b5d8-e9ba9bbefdf5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Shouldn't we treat the case when `args` is empty different?",
        "createdAt" : "2020-07-08T07:56:04Z",
        "updatedAt" : "2020-07-08T07:58:11Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "184bb308-0f15-4079-94d7-6925def1747d",
        "parentId" : "0190d890-e3fb-4280-b5d8-e9ba9bbefdf5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I realized that on my branch where I change it to emit declaration files but it doesn’t actually make a difference. Typescript seems to be perfectly happy with `<>`. (I’ll still fix it).",
        "createdAt" : "2020-07-08T07:59:43Z",
        "updatedAt" : "2020-07-08T07:59:44Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "36330525b73a099b3fc48a30be0c9792ca20c8e5",
    "line" : 271,
    "diffHunk" : "@@ -259,91 +258,335 @@ genModule pkgMap (Scope scope) curPkgId mod\n defDataTypes :: Module -> [DefDataType]\n defDataTypes mod = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n \n-genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> ([TsDecl], Set.Set ModuleRef)\n genDataDef curPkgId mod tpls def = case unTypeConName (dataTypeCon def) of\n     [] -> error \"IMPOSSIBLE: empty type constructor name\"\n     _: _: _: _ -> error \"IMPOSSIBLE: multi-part type constructor of more than two names\"\n \n     [conName] -> genDefDataType curPkgId conName mod tpls def\n-    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, []), refs)\n+    [c1, c2] -> ([DeclNamespace c1 tyDecls], refs)\n       where\n-        ((typs, _), refs) = genDefDataType curPkgId c2 mod tpls def\n-        makeNamespace stuff =\n-          [\"export namespace \" <> c1 <> \" {\"] ++ stuff ++ [\"} //namespace \" <> c1]\n+        (decls, refs) = genDefDataType curPkgId c2 mod tpls def\n+        tyDecls = [d | d@DeclTypeDef{} <- decls]\n+\n+-- | The typescript declarations we produce.\n+data TsDecl\n+    = DeclTemplateDef TemplateDef\n+    | DeclSerializableDef SerializableDef\n+    | DeclTypeDef TypeDef\n+    | DeclTemplateNamespace TemplateNamespace\n+    | DeclTemplateRegistration TemplateRegistration\n+    | DeclNamespace T.Text [TsDecl]\n+    -- ^ Note that we special-case some namespaces, e.g., the template namespace\n+    -- that always have fixed contents. This constructor is only used for the namespace\n+    -- for sums of products.\n+\n+renderTsDecl :: TsDecl -> T.Text\n+renderTsDecl = \\case\n+    DeclTemplateDef t -> renderTemplateDef t\n+    DeclSerializableDef t -> renderSerializableDef t\n+    DeclTypeDef t -> renderTypeDef t\n+    DeclTemplateNamespace t -> renderTemplateNamespace t\n+    DeclTemplateRegistration t -> renderTemplateRegistration t\n+    DeclNamespace t decls -> T.unlines $ concat\n+        [ [ \"export namespace \" <> t <> \" {\" ]\n+        , [ \"  \" <> l | d <- decls, l <- T.lines (renderTsDecl d) ]\n+        , [ \"} //namespace \" <> t ]\n+        ]\n+\n+\n+-- | Namespace containing type synonyms for Key, CreatedEvent, ArchivedEvent and Event\n+-- for the given template.\n+data TemplateNamespace = TemplateNamespace\n+  { tnsName :: T.Text\n+  , tnsMbKeyDef :: Maybe T.Text\n+  }\n+\n+renderTemplateNamespace :: TemplateNamespace -> T.Text\n+renderTemplateNamespace TemplateNamespace{..} = T.unlines $ concat\n+    [ [ \"export namespace \" <> tnsName <> \" {\" ]\n+    , [ \"  export type Key = \" <> keyDef | Just keyDef <- [tnsMbKeyDef] ]\n+    , [ \"  export type CreateEvent = damlLedger.CreateEvent\" <> tParams [tnsName, tK, tI]\n+      , \"  export type ArchiveEvent = damlLedger.ArchiveEvent\" <> tParams [tnsName, tI]\n+      , \"  export type Event = damlLedger.Event\" <> tParams [tnsName, tK, tI]\n+      , \"}\"\n+      ]\n+    ]\n+  where\n+    tK = maybe \"undefined\" (const (tnsName <.> \"Key\")) tnsMbKeyDef\n+    tI = \"typeof \" <> tnsName <.> \"templateId\"\n+    tParams xs = \"<\" <> T.intercalate \", \" xs <> \">\"\n+\n+data TemplateRegistration = TemplateRegistration T.Text\n+\n+renderTemplateRegistration :: TemplateRegistration -> T.Text\n+renderTemplateRegistration (TemplateRegistration t) = T.unlines\n+  [ \"damlTypes.registerTemplate(\" <> t <> \");\" ]\n+\n+data TemplateDef = TemplateDef\n+  { tplName :: T.Text\n+  , tplPkgId :: PackageId\n+  , tplModule :: ModuleName\n+  , tplDecoder :: Decoder\n+  , tplKeyDecoder :: Maybe Decoder\n+  -- ^ Nothing if we do not have a key.\n+  , tplChoices' :: [ChoiceDef]\n+  }\n+\n+renderTemplateDef :: TemplateDef -> T.Text\n+renderTemplateDef TemplateDef{..} = T.unlines $ concat\n+    [ [ \"export const \" <> tplName <> \":\"\n+      , \"  damlTypes.Template<\" <> tplName <> \", \" <> keyTy <> \", '\" <> templateId <> \"'> & {\"\n+      ]\n+    , [ \"  \" <> chcName' <> \": damlTypes.Choice<\" <>\n+        tplName <> \", \" <>\n+        chcArgTy <> \", \" <>\n+        chcRetTy <> \", \" <>\n+        keyTy <> \">;\" | ChoiceDef{..} <- tplChoices' ]\n+    , [ \"} = {\"\n+      , \"  templateId: '\" <> templateId <> \"',\"\n+      , \"  keyDecoder: \" <> keyDec <> \",\"\n+      , \"  decoder: () => \" <> renderDecoder tplDecoder <> \",\"\n+      ]\n+    , concat\n+      [ [ \"  \" <> chcName' <> \": {\"\n+        , \"    template: () => \" <> tplName <> \",\"\n+        , \"    choiceName: '\" <> chcName' <> \"',\"\n+        , \"    argumentDecoder: \" <> chcArgTy <> \".decoder,\"\n+        , \"    resultDecoder: () => \" <> chcRetSerTy <> \".decoder(),\"\n+        , \"  },\"\n+        ]\n+      | ChoiceDef{..} <- tplChoices'\n+      ]\n+    , [ \"};\" ]\n+    ]\n+  where (keyTy, keyDec) = case tplKeyDecoder of\n+            Nothing -> (\"undefined\", \"() => \" <> renderDecoder (DecoderConstant ConstantUndefined))\n+            Just d -> (tplName <> \".Key\", \"() => \" <> renderDecoder d)\n+        templateId =\n+            unPackageId tplPkgId <> \":\" <>\n+            T.intercalate \".\" (unModuleName tplModule) <> \":\" <>\n+            tplName\n+\n+data ChoiceDef = ChoiceDef\n+  { chcName' :: T.Text\n+  , chcArgTy :: T.Text\n+  , chcRetTy :: T.Text\n+  -- ^ Return type in typescript, e.g., `{}` for `()`\n+  , chcRetSerTy :: T.Text\n+  -- ^ Type that has the serializability definition, e.g., `damlTypes.Unit` for `()`.\n+  }\n+\n+data SerializableDef = SerializableDef\n+  { serName :: T.Text\n+  , serParams :: [T.Text]\n+  -- ^ Type parameters.\n+  , serKeys :: [T.Text]\n+  -- ^ Keys for enums. Note that enums never have type parameters\n+  -- but for simplicity we do not express this in this type.\n+  , serDecoder :: Decoder\n+  , serNestedDecoders :: [(T.Text, Decoder)]\n+  -- ^ For sums of products, e.g., `data X = Y { a : Int }\n+  }\n+\n+renderSerializableDef :: SerializableDef -> T.Text\n+renderSerializableDef SerializableDef{..}\n+  | null serParams = T.unlines $ concat\n+      [ [ \"export const \" <> serName <> \":\"\n+        , \"  damlTypes.Serializable<\" <> serName <> \"> & {\"\n+        ]\n+      , [ \"  \" <> n <> \": damlTypes.Serializable<\" <> serName <.> n <> \">;\" | (n, _) <- serNestedDecoders ]\n+      , [ \"  } \"\n+        ]\n+      , [ \"& { readonly keys: \" <> serName <> \"[] } & { readonly [e in \" <> serName <> \"]: e }\" | notNull serKeys ]\n+      , [ \"  = ({\" ]\n+      , [ \"  \" <> k <> \":\" <> \"'\" <> k <> \"',\" | k <- serKeys ]\n+      , [ \"  keys: [\" <> T.concat (map (\\s -> \"'\" <> s <> \"',\") serKeys) <> \"],\" | notNull serKeys ]\n+      , [ \"  decoder: () => \" <> renderDecoder serDecoder <> \",\"\n+        ]\n+      , concat $\n+        [ [ \"  \" <> n <> \":({\"\n+          , \"    decoder: () => \" <> renderDecoder d <> \",\"\n+          , \"  }),\"\n+          ]\n+        | (n, d) <- serNestedDecoders\n+        ]\n+      , [ \"});\" ]\n+      ]\n+  | otherwise = assert (null serKeys) $ T.unlines $\n+  -- If we have type parameters, the serializable definition is\n+  -- a function and we generate extra properties on that function\n+  -- for each nested decoder.\n+      [ \"export const \" <> serName <> \" = \" <> tyArgs <> \":\"\n+      , \"  damlTypes.Serializable<\" <> serName <> tyParams <> \"> => ({\"\n+      , \"  decoder: () => \" <> renderDecoder serDecoder <> \",\"\n+      , \"});\"\n+      ] <> concat\n+      [ [ serName <.> n <> \" = \" <> tyArgs <> \":\"\n+        , \"  damlTypes.Serializable<\" <> serName <.> n <> tyParams <> \"> => ({\"\n+        , \"  decoder: () => \" <> renderDecoder d <> \",\"\n+        , \"});\"\n+        ]\n+      | (n, d) <- serNestedDecoders\n+      ]\n+  where tyParams = \"<\" <> T.intercalate \", \" serParams <> \">\"\n+        tyArgs = tyParams <> \"(\" <> T.intercalate \", \" (map (\\name -> name <> \": damlTypes.Serializable<\" <> name <> \">\") serParams) <> \")\"\n+\n+\n+data Decoder\n+    = DecoderOneOf T.Text [Decoder]\n+    | DecoderObject [(T.Text, Decoder)]\n+    | DecoderConstant DecoderConstant\n+    | DecoderRef T.Text -- ^ Reference to an object with a .decoder() method\n+    | DecoderLazy Decoder\n+\n+data DecoderConstant\n+    = ConstantUndefined\n+    | ConstantString T.Text -- ^ String literal\n+    | ConstantRef T.Text -- ^ Variable reference\n+\n+renderDecoderConstant :: DecoderConstant -> T.Text\n+renderDecoderConstant = \\case\n+    ConstantUndefined -> \"undefined\"\n+    ConstantString s -> \"'\" <> s <> \"'\"\n+    ConstantRef v -> v\n+\n+renderDecoder :: Decoder -> T.Text\n+renderDecoder = \\case\n+    DecoderOneOf constr branches ->\n+        \"jtv.oneOf<\" <> constr <> \">(\" <>\n+        T.concat (map (\\b -> renderDecoder b <> \",\") branches) <>\n+        \")\"\n+    DecoderObject fields ->\n+        \"jtv.object({\" <>\n+        T.concat (map (\\(name, d) -> name <> \":\" <> renderDecoder d <> \",\") fields) <>\n+        \"})\"\n+    DecoderConstant c -> \"jtv.constant(\" <> renderDecoderConstant c <> \")\"\n+    DecoderRef n -> n <> \".decoder()\"\n+    DecoderLazy d -> \"jtv.lazy(() => \" <> renderDecoder d <> \")\"\n+\n+data TypeDef\n+    = UnionDef T.Text [T.Text] [(T.Text, T.Text)]\n+    | ObjectDef T.Text [T.Text] [(T.Text, T.Text)]\n+    | EnumDef T.Text [T.Text] [T.Text]\n+\n+renderTypeDef :: TypeDef -> T.Text\n+renderTypeDef = \\case\n+    UnionDef t args bs -> T.unlines $ concat\n+        [ [ \"export type \" <> ty t args <> \" =\" ]\n+        , [ \"  |  { tag: '\" <> k <> \"'; value: \" <> v <> \" }\" | (k, v) <- bs ]\n+        ]\n+    ObjectDef t args fs -> T.unlines $ concat\n+        [ [ \"export type \" <> ty t args <> \" = {\" ]\n+        , [ \"  \" <> k <> \": \" <> v <> \";\" | (k, v) <- fs ]\n+        , [ \"}\" ]\n+        ]\n+    EnumDef t args fs -> T.unlines $ concat\n+        [ [ \"export type \" <> ty t args <> \" =\" ]\n+        , [ \"  | '\" <> f <> \"'\" | f <- fs ]\n+        ]\n+  where ty t args = t <> \"<\" <> T.intercalate \", \" args <> \">\""
  },
  {
    "id" : "361b2a4f-e3cb-423f-9046-bc597683e708",
    "prId" : 5587,
    "comments" : [
      {
        "id" : "4fc4408c-499a-4634-b8dc-d5a17d17ce73",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Shouldn’t this be `undefined`instead of `unknown`? Also is there any downside to simply always setting this to `keyDef` instead of going via the `.Key` indirection?",
        "createdAt" : "2020-04-16T16:21:00Z",
        "updatedAt" : "2020-04-16T17:00:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3933ecdd-eb07-4266-9e63-841eb4a66811",
        "parentId" : "4fc4408c-499a-4634-b8dc-d5a17d17ce73",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "> Shouldn’t this be `undefined`instead of `unknown`?\r\n\r\nI agree this is formally more correct. Switching to `undefined`.\r\n\r\n> Also is there any downside to simply always setting this to `keyDef` instead of going via the `.Key` indirection?\r\n\r\nNo technical downside. The `.Key` approach leads to prettier generated code is all.\r\n\r\n",
        "createdAt" : "2020-04-16T16:51:48Z",
        "updatedAt" : "2020-04-16T17:00:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9c49bde3c90377c04ba63a6b08ba6367fe9c5618",
    "line" : null,
    "diffHunk" : "@@ -388,12 +388,13 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          let tT = conName\n-                              tK = tT <> \".Key\"\n+                          let keyDef = maybe \"unknown\" (fst . genType (moduleName mod) . tplKeyType) (tplKey tpl)\n+                              tT = conName\n+                              tK = if keyDef == \"unknown\" then keyDef else tT <> \".Key\""
  },
  {
    "id" : "70471c2e-20cd-457c-8683-bb83ecb0c9d6",
    "prId" : 5587,
    "comments" : [
      {
        "id" : "8f866d90-45c7-4405-8f8d-c26537ec6d4f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Matching on the string here seems a bit hacky, can we make `keyDef` a `Maybe` and then do something like `[ \" … \" <> keyDef | Just keyDef <- [ mbKeyDef ]]`?",
        "createdAt" : "2020-04-16T16:21:58Z",
        "updatedAt" : "2020-04-16T17:00:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "579f7dd0-c33f-492f-8288-59cb81c6557e",
        "parentId" : "8f866d90-45c7-4405-8f8d-c26537ec6d4f",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-04-16T16:52:06Z",
        "updatedAt" : "2020-04-16T17:00:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9c49bde3c90377c04ba63a6b08ba6367fe9c5618",
    "line" : null,
    "diffHunk" : "@@ -388,12 +388,13 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          let tT = conName\n-                              tK = tT <> \".Key\"\n+                          let keyDef = maybe \"unknown\" (fst . genType (moduleName mod) . tplKeyType) (tplKey tpl)\n+                              tT = conName\n+                              tK = if keyDef == \"unknown\" then keyDef else tT <> \".Key\"\n                               tI = \"typeof \" <> tT <> \".templateId\" in\n-                          [ \"export namespace \" <> tT <> \" {\"\n-                          , \"  export type Key = \" <> maybe \"unknown\" (fst . genType (moduleName mod) . tplKeyType) (tplKey tpl)\n-                          , \"  export type CreateEvent = damlLedger.CreateEvent\" <> \"<\" <> tparams [tT, tK, tI] <> \">\"\n+                          [ \"export namespace \" <> tT <> \" {\" ] ++\n+                          [ \"  export type Key = \" <> keyDef | keyDef /= \"unknown\" ] ++"
  },
  {
    "id" : "c8de3917-47b2-4bb6-be7d-08dfdfb97a42",
    "prId" : 5587,
    "comments" : [
      {
        "id" : "6454caa4-8cf4-4e2b-a10c-23171411e077",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Just out of curiosity, have you tried using just `Key` instead of `T.Key`? Did that work?",
        "createdAt" : "2020-04-16T19:50:24Z",
        "updatedAt" : "2020-04-16T20:00:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "34e0ec54-8917-4c65-b592-5388eca4d7e8",
        "parentId" : "6454caa4-8cf4-4e2b-a10c-23171411e077",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Somebody seems to love the magic weapons for point-free code, `maybe` & `const`... 😃\r\nI would have gone for\r\n```suggestion\r\n                              tK = if isJust mbKeyDef then tT <> \".Key\" else \"undefined\"\r\n```",
        "createdAt" : "2020-04-16T19:51:29Z",
        "updatedAt" : "2020-04-16T20:00:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "17e685df-e834-43c3-be2f-83daf6ce42e0",
        "parentId" : "6454caa4-8cf4-4e2b-a10c-23171411e077",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "> Just out of curiosity, have you tried using just `Key` instead of `T.Key`? Did that work?\r\n\r\nI have as a matter of fact. Yes, that works fine.",
        "createdAt" : "2020-04-16T21:07:14Z",
        "updatedAt" : "2020-04-16T21:07:15Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9c49bde3c90377c04ba63a6b08ba6367fe9c5618",
    "line" : 8,
    "diffHunk" : "@@ -388,12 +388,13 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          let tT = conName\n-                              tK = tT <> \".Key\"\n+                          let mbKeyDef = fst . genType (moduleName mod) . tplKeyType <$> tplKey tpl\n+                              tT = conName\n+                              tK = maybe \"undefined\" (const (tT <> \".Key\")) mbKeyDef"
  },
  {
    "id" : "669e7ab0-9a50-4196-a621-b72fd8ff4994",
    "prId" : 5571,
    "comments" : [
      {
        "id" : "adfac316-8a1d-4f0e-98be-c2b02798b8eb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t understand this, why do we not want these synonyms if there is no contract key? Surely I can still get events for a template without contract keys?",
        "createdAt" : "2020-04-16T06:31:32Z",
        "updatedAt" : "2020-04-16T13:08:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "82acae94-2aba-4eb7-9f59-3ca07af449e7",
        "parentId" : "adfac316-8a1d-4f0e-98be-c2b02798b8eb",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "No you are absolutely right. Dumb mistake. Will fix.",
        "createdAt" : "2020-04-16T07:20:00Z",
        "updatedAt" : "2020-04-16T13:08:48Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72535d45c1b8ec7a43d469e44a1e26622b509de6",
    "line" : null,
    "diffHunk" : "@@ -386,11 +388,20 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          maybe [] (\\key ->\n-                              [ \"export namespace \" <> conName <> \" {\"\n-                              , \"  export type Key = \" <> fst (genType (moduleName mod) (tplKeyType key)) <> \"\"\n+                          case tplKey tpl of\n+                            Nothing -> []"
  },
  {
    "id" : "4ef4a19f-bb66-4707-ba42-93a3728ae0b1",
    "prId" : 5571,
    "comments" : [
      {
        "id" : "8b2292f6-6cd9-4f7d-bbf1-6f428a3d0d9e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There's no big gain from writing `T.Query` instead of `Query<T>`. Thus, let's drop this type synonym.",
        "createdAt" : "2020-04-16T08:17:45Z",
        "updatedAt" : "2020-04-16T13:08:48Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9fa464f9-acea-411c-8582-9f939655c421",
        "parentId" : "8b2292f6-6cd9-4f7d-bbf1-6f428a3d0d9e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-04-16T13:07:12Z",
        "updatedAt" : "2020-04-16T13:08:48Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "72535d45c1b8ec7a43d469e44a1e26622b509de6",
    "line" : null,
    "diffHunk" : "@@ -386,11 +388,20 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          maybe [] (\\key ->\n-                              [ \"export namespace \" <> conName <> \" {\"\n-                              , \"  export type Key = \" <> fst (genType (moduleName mod) (tplKeyType key)) <> \"\"\n+                          case tplKey tpl of\n+                            Nothing -> []\n+                            Just key ->\n+                              let tT = conName\n+                                  tK = tT <> \".Key\"\n+                                  tI = \"typeof \" <> tT <> \".templateId\" in\n+                              [ \"export namespace \" <> tT <> \" {\"\n+                              , \"  export type Key = \" <> fst (genType (moduleName mod) (tplKeyType key))\n+                              , \"  export type CreateEvent = damlLedger.CreateEvent\" <> \"<\" <> tT <> \", \" <> tK <> \", \" <> tI <> \">\"\n+                              , \"  export type ArchiveEvent = damlLedger.ArchiveEvent\" <> \"<\" <>  tT <> \", \" <> tI <> \">\"\n+                              , \"  export type Event = damlLedger.Event\"  <> \"<\" <>  tT <> \", \" <> tK <> \", \" <> tI <> \">\"\n+                              , \"  export type Query = damlLedger.Query\"  <> \"<\" <>  tT <> \">\""
  },
  {
    "id" : "74ad0aef-734f-4e85-aae0-895a510d6d6f",
    "prId" : 5571,
    "comments" : [
      {
        "id" : "d85362e6-39f4-43d1-9126-94ceedfe8390",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I assume this will just be undefined if we do not have a key? Is this tested?",
        "createdAt" : "2020-04-16T14:11:55Z",
        "updatedAt" : "2020-04-16T14:12:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b66566e8-1ae7-4fa5-9a5d-ed06ae95bfc8",
        "parentId" : "d85362e6-39f4-43d1-9126-94ceedfe8390",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "In the event there is no key, then the definition in play is `export type Key = unknown` which is consistent with the definitions of `Event<>` and `CreateEvent<>`. Yes, tested.",
        "createdAt" : "2020-04-16T14:18:46Z",
        "updatedAt" : "2020-04-16T14:18:47Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "72535d45c1b8ec7a43d469e44a1e26622b509de6",
    "line" : 19,
    "diffHunk" : "@@ -386,11 +388,17 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          maybe [] (\\key ->\n-                              [ \"export namespace \" <> conName <> \" {\"\n-                              , \"  export type Key = \" <> fst (genType (moduleName mod) (tplKeyType key)) <> \"\"\n-                              , \"}\"\n-                              ]) (tplKey tpl)\n+                          let tT = conName\n+                              tK = tT <> \".Key\""
  },
  {
    "id" : "f16261a7-fc26-48cc-9d4a-771fd2415e94",
    "prId" : 5571,
    "comments" : [
      {
        "id" : "be87372b-e89b-4f84-a1d5-4685601a5f82",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would prefer if there was no `Key` type synonym when there's no contract key for the template. Let's use `Key` for `tK` when there is a key and `undefined` when there's no key.",
        "createdAt" : "2020-04-16T15:26:47Z",
        "updatedAt" : "2020-04-16T15:26:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "64531738-61ae-4aac-84ba-3be9d6454bb7",
        "parentId" : "be87372b-e89b-4f84-a1d5-4685601a5f82",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "PR https://github.com/digital-asset/daml/pull/5587.",
        "createdAt" : "2020-04-16T16:08:30Z",
        "updatedAt" : "2020-04-16T16:08:31Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "72535d45c1b8ec7a43d469e44a1e26622b509de6",
    "line" : 22,
    "diffHunk" : "@@ -386,11 +388,17 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          maybe [] (\\key ->\n-                              [ \"export namespace \" <> conName <> \" {\"\n-                              , \"  export type Key = \" <> fst (genType (moduleName mod) (tplKeyType key)) <> \"\"\n-                              , \"}\"\n-                              ]) (tplKey tpl)\n+                          let tT = conName\n+                              tK = tT <> \".Key\"\n+                              tI = \"typeof \" <> tT <> \".templateId\" in\n+                          [ \"export namespace \" <> tT <> \" {\"\n+                          , \"  export type Key = \" <> maybe \"unknown\" (fst . genType (moduleName mod) . tplKeyType) (tplKey tpl)"
  },
  {
    "id" : "2b7bc321-0076-4567-b94c-5988a6d911e1",
    "prId" : 5323,
    "comments" : [
      {
        "id" : "90e134b0-760b-4b4e-a740-9a7980bc0ded",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why are you not using `callProcessSilent` here?",
        "createdAt" : "2020-04-01T06:24:50Z",
        "updatedAt" : "2020-04-01T11:02:41Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2e0511ca-bae7-4f78-9ce4-f8977202ab65",
        "parentId" : "90e134b0-760b-4b4e-a740-9a7980bc0ded",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Didn't feel right having this executable depend on a test utility library",
        "createdAt" : "2020-04-01T10:53:57Z",
        "updatedAt" : "2020-04-01T11:02:41Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0bebcde2-9dad-4e40-8c3d-1190f801a419",
        "parentId" : "90e134b0-760b-4b4e-a740-9a7980bc0ded",
        "author" : null,
        "body" : "Maybe `callProcessSilent` (etc) should be in da-hs-base.",
        "createdAt" : "2020-04-01T11:00:42Z",
        "updatedAt" : "2020-04-01T11:02:41Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "4ee28c1d-608a-4eea-932b-c447dd3b80f6",
        "parentId" : "90e134b0-760b-4b4e-a740-9a7980bc0ded",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Not ~sufficiently~ currently motivated (enough) to do it for this one case today but my arm can be twisted if you feel strongly about it 😉  Do you? ",
        "createdAt" : "2020-04-01T11:08:34Z",
        "updatedAt" : "2020-04-01T11:12:33Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5ffba0a9-b25d-4655-88a8-bdc73c3e34c7",
        "parentId" : "90e134b0-760b-4b4e-a740-9a7980bc0ded",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "@associahedron ",
        "createdAt" : "2020-04-01T11:10:00Z",
        "updatedAt" : "2020-04-01T11:10:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a01b1aa8-dde4-4830-8f4e-36b26848057d",
        "parentId" : "90e134b0-760b-4b4e-a740-9a7980bc0ded",
        "author" : null,
        "body" : "Not strongly, no :) ",
        "createdAt" : "2020-04-01T11:10:05Z",
        "updatedAt" : "2020-04-01T11:10:05Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "ab6d9d1a-4fcc-447b-91ab-75e5f45d08f7",
        "parentId" : "90e134b0-760b-4b4e-a740-9a7980bc0ded",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I do agree though, just inclined to do it down the road when a more motivating circumstance arises.",
        "createdAt" : "2020-04-01T11:11:19Z",
        "updatedAt" : "2020-04-01T11:11:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "910d8cde2a20dfa2ec955c1f660b07062bec4b51",
    "line" : 20,
    "diffHunk" : "@@ -607,14 +607,14 @@ buildPackages sdkVersion optScope optOutputDir dependencies = do\n     build :: String -> IO ()\n     build pkg = do\n       putStrLn $ \"Building \" <> pkg\n-      callProcessSilent \"yarn\" [\"run\", \"tsc\", \"--project\", pkg </> \"tsconfig.json\"]\n+      yarn [\"run\", \"tsc\", \"--project\", pkg </> \"tsconfig.json\"]\n       copyDirectory pkg $ \"node_modules\" </> scope </> pkg\n \n-    callProcessSilent :: FilePath -> [String] -> IO ()\n-    callProcessSilent cmd args = do\n-      (exitCode, _, err) <- readProcessWithExitCode cmd args \"\"\n+    yarn :: [String] -> IO ()"
  },
  {
    "id" : "441a2a49-e561-4940-b43a-2c29a65bd4ed",
    "prId" : 5218,
    "comments" : [
      {
        "id" : "d7b7a534-eaef-4dcb-a5bb-a475f9d47330",
        "parentId" : null,
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "We remove this.",
        "createdAt" : "2020-03-26T16:39:38Z",
        "updatedAt" : "2020-03-26T18:18:26Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "0abe93a6fc31745849983ecd333eea94a1ba62f5",
    "line" : 51,
    "diffHunk" : "@@ -632,27 +625,6 @@ writeTsConfig dir =\n       , \"include\" .= ([\"src/**/*.ts\"] :: [T.Text])\n       ]\n \n-writeEsLintConfig :: FilePath -> IO ()"
  },
  {
    "id" : "d09fa987-e961-4127-8446-7ab796811351",
    "prId" : 5209,
    "comments" : [
      {
        "id" : "5c7fb8e6-dc8a-4c32-bab2-eb2065d902da",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We don't want `/` on all platforms in filenames. We don't use `</>` to calculate paths in import statements.",
        "createdAt" : "2020-03-26T10:14:06Z",
        "updatedAt" : "2020-03-26T14:23:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9db69c46-fb03-4a21-b53a-11adf9cbac50",
        "parentId" : "5c7fb8e6-dc8a-4c32-bab2-eb2065d902da",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-26T10:18:08Z",
        "updatedAt" : "2020-03-26T14:23:18Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7009aff7cd6ec3595cab8af0ca8deff007a84e3e",
    "line" : 5,
    "diffHunk" : "@@ -32,9 +32,7 @@ import Data.Maybe\n import Data.Bifoldable\n import Options.Applicative\n import System.Directory\n-import System.FilePath hiding ((<.>), (</>))\n-import System.FilePath.Posix((</>)) -- Make sure we generate / on all platforms."
  },
  {
    "id" : "94a4c36e-39a8-42d9-86e9-1c3f7a49ab53",
    "prId" : 5209,
    "comments" : [
      {
        "id" : "e52288b2-1680-428b-9705-cb1049340763",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This is because `A/B/C/module.ts` file sits one level deeper than `A/B/C.ts`.",
        "createdAt" : "2020-03-26T10:15:01Z",
        "updatedAt" : "2020-03-26T14:23:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7009aff7cd6ec3595cab8af0ca8deff007a84e3e",
    "line" : 27,
    "diffHunk" : "@@ -230,9 +228,7 @@ genModule pkgMap (Scope scope) curPkgId mod\n     let (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n         imports = (PRSelf, modName) `Set.delete` Set.unions refs\n         (internalImports, externalImports) = splitImports imports\n-        rootPath =\n-          let lenModName = length (unModuleName modName)\n-          in if lenModName == 1 then [\".\"] else replicate (lenModName - 1) \"..\"\n+        rootPath = map (const \"..\") (unModuleName modName)"
  },
  {
    "id" : "25425152-ca57-4401-a533-9b20747492fe",
    "prId" : 5197,
    "comments" : [
      {
        "id" : "a9d138b5-1937-4ed5-9fe0-a8e996b402d4",
        "parentId" : null,
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Do we still need this after the recent change?",
        "createdAt" : "2020-03-25T20:06:28Z",
        "updatedAt" : "2020-03-25T20:37:25Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "03e89923-0eb5-4da3-81c0-91267599c7fa",
        "parentId" : "a9d138b5-1937-4ed5-9fe0-a8e996b402d4",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do you mean the camelcase exception? We still produce names like `DA_Template_Internal` which might trigger a warning.",
        "createdAt" : "2020-03-25T20:17:42Z",
        "updatedAt" : "2020-03-25T20:37:25Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d4b67d7a-637a-402b-9414-0e6e7af94f33",
        "parentId" : "a9d138b5-1937-4ed5-9fe0-a8e996b402d4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I did. Ok!",
        "createdAt" : "2020-03-25T20:18:36Z",
        "updatedAt" : "2020-03-25T20:37:25Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "48bdeaa24d48feb9788fb193e93d3158496d3125",
    "line" : 67,
    "diffHunk" : "@@ -233,25 +234,27 @@ daml2ts Daml2TsParams {..} = do\n \n -- Generate the .ts content for a single module.\n genModule :: Map.Map PackageId (Maybe PackageName, Package) ->\n-     Scope -> PackageId -> Module -> Maybe (T.Text, [Dependency])\n+     Scope -> PackageId -> Module -> Maybe (T.Text, Set.Set Dependency)\n genModule pkgMap (Scope scope) curPkgId mod\n   | null serDefs =\n     Nothing -- If no serializable types, nothing to do.\n   | otherwise =\n     let (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n-        imports = [ importDecl pkgMap modRef rootPath\n-                  | modRef@(pkgRef, _) <- modRefs refs\n-                  , let rootPath = pkgRootPath modName pkgRef ]\n+        imports = Set.toList ((PRSelf, modName) `Set.delete` Set.unions refs)\n+        (internalImports, externalImports) = splitImports imports\n         defs = map biconcat defSers\n-        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $ modHeader : imports : defs\n-        depends = [ Dependency $ pkgRefStr pkgMap pkgRef\n-                  | (pkgRef, _) <- modRefs refs, pkgRef /= PRSelf ]\n+        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $\n+          modHeader\n+          : map (externalImportDecl pkgMap) externalImports\n+          : map internalImportDecl internalImports\n+          : defs\n+        depends = Set.fromList [ Dependency $ pkgRefStr pkgMap pkgRef\n+                  | (pkgRef, _) <- imports, pkgRef /= PRSelf ]\n    in Just (modText, depends)\n   where\n     modName = moduleName mod\n     tpls = moduleTemplates mod\n     serDefs = defDataTypes mod\n-    modRefs refs = Set.toList ((PRSelf, modName) `Set.delete` Set.unions refs)\n     modHeader =\n       [ \"// Generated from \" <> modPath (unModuleName modName) <> \".daml\"\n       , \"/* eslint-disable @typescript-eslint/camelcase */\""
  },
  {
    "id" : "4d7e9462-88e9-40c8-9757-7cfa5aba3532",
    "prId" : 5171,
    "comments" : [
      {
        "id" : "1b83e683-095c-4545-b168-b4ae04186ebb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can you please create an issue to make sure we remove this flag after the next release.",
        "createdAt" : "2020-03-25T17:32:18Z",
        "updatedAt" : "2020-03-25T17:50:50Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "77de514b-6c55-46f1-97b7-21a4c9cc1487",
        "parentId" : "1b83e683-095c-4545-b168-b4ae04186ebb",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/issues/5194",
        "createdAt" : "2020-03-25T18:34:58Z",
        "updatedAt" : "2020-03-25T18:34:59Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ede39c0bc7b73401d689c75f3f46feb6f2c5843f",
    "line" : 47,
    "diffHunk" : "@@ -80,7 +78,7 @@ newtype Script = Script {unScript :: T.Text}\n data Options = Options\n     { optInputDars :: [FilePath]\n     , optOutputDir :: FilePath\n-    , optInputPackageJson :: FilePath\n+    , optInputPackageJson :: Maybe FilePath -- Deprecated."
  },
  {
    "id" : "af6c07e2-3104-4964-93fb-317955235088",
    "prId" : 5098,
    "comments" : [
      {
        "id" : "3c185ba7-0e96-43da-8cb5-498178d3b2b1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "You've apparently done too much OCaml in your life. Nobody else would leave a space between \"Error\" and the colon afterwards. 😉",
        "createdAt" : "2020-03-20T08:35:25Z",
        "updatedAt" : "2020-03-20T08:35:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "89312882f256fc1cc54ac6d03a1692bcf561dfb2",
    "line" : 9,
    "diffHunk" : "@@ -743,9 +743,10 @@ setupWorkspace optInputPackageJson optOutputDir dependencies = do\n     (Just <$> BSL.readFile optInputPackageJson) (const $ pure Nothing)\n   packageJson <- case mbBytes of\n     Nothing -> pure mempty\n-    Just bytes -> case decode @PackageJson bytes of\n-      Nothing -> fail $ \"Error decoding JSON from '\" <> optInputPackageJson <> \"'\"\n-      Just packageJson -> pure packageJson\n+    Just bytes ->\n+      case eitherDecode @PackageJson bytes of\n+        Left msg -> fail $ \"Error : '\" <> optInputPackageJson <> \"' : \" <> msg"
  },
  {
    "id" : "8857faa2-ae0c-4126-8371-538cd5fd0c20",
    "prId" : 5088,
    "comments" : [
      {
        "id" : "43500fd3-aeae-4f7d-ba59-7394f9b9a57c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Shadowing `id` is a bit confusing.",
        "createdAt" : "2020-03-19T16:17:22Z",
        "updatedAt" : "2020-03-19T16:17:33Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3c185af4-51cc-4e3b-b708-dea0ff80239c",
        "parentId" : "43500fd3-aeae-4f7d-ba59-7394f9b9a57c",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm innocent. 🤷‍♂",
        "createdAt" : "2020-03-19T17:05:51Z",
        "updatedAt" : "2020-03-19T17:05:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d1d173aa884ccf973a78aba176065c91d09572af",
    "line" : 7,
    "diffHunk" : "@@ -172,8 +172,10 @@ main = do\n             \\(pkgId, (mbPkgName, pkg)) -> do\n                  let id = unPackageId pkgId\n                      pkgName = packageNameText pkgId mbPkgName\n-                     asName = if pkgName == id then \"itself\" else pkgName\n-                 T.putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 let pkgDesc = case mbPkgName of\n+                       Nothing -> id"
  },
  {
    "id" : "b66bc9d9-2a5f-4290-80bb-93d650f11ac1",
    "prId" : 5081,
    "comments" : [
      {
        "id" : "cc803b84-12a5-41e9-b3db-606dda98c00a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you use `eiherDecode` you can get an error message on parse failures.",
        "createdAt" : "2020-03-19T07:54:20Z",
        "updatedAt" : "2020-03-19T07:54:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "51aafb49-40e6-4da5-8d2c-45869e0ef1b1",
        "parentId" : "cc803b84-12a5-41e9-b3db-606dda98c00a",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Excellent idea. Would be `eitherDecode @PackageJson` then I guess.",
        "createdAt" : "2020-03-19T08:05:55Z",
        "updatedAt" : "2020-03-19T08:05:56Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f9d1f78c-954f-4e43-be04-2463c31c585f",
        "parentId" : "cc803b84-12a5-41e9-b3db-606dda98c00a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I'll get another PR going for that.",
        "createdAt" : "2020-03-19T10:52:35Z",
        "updatedAt" : "2020-03-19T10:52:35Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0fc0ed26-4038-4d0b-84a6-537bf82c397b",
        "parentId" : "cc803b84-12a5-41e9-b3db-606dda98c00a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I've had a look at the error messages it produces. They don't look helpful to be honest. For example, with a stray ',' the resulting error message is:\r\n```\r\nError in $: Failed reading: satisfy. Expecting object value\r\n```\r\nI recommend we do not switch from `decode` to `eitherDecode`.",
        "createdAt" : "2020-03-19T18:20:43Z",
        "updatedAt" : "2020-03-19T18:20:43Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b2b68477-2091-4f3c-8262-53c4bcbf7df8",
        "parentId" : "cc803b84-12a5-41e9-b3db-606dda98c00a",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It depends on the error and the kind of code you write. E.g. for a missing key you can often get fairly decent errors. Using things like `withObject`, `<?>` you can improve errors. I wouldn’t use one bad error message as an indicator that not showing the error at all is better.",
        "createdAt" : "2020-03-19T18:27:10Z",
        "updatedAt" : "2020-03-19T18:27:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "efa41ac9-df36-4c00-bbf5-9d28e54b7c7d",
        "parentId" : "cc803b84-12a5-41e9-b3db-606dda98c00a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok, sounds reasonable. In which case I offer https://github.com/digital-asset/daml/pull/5098 😃  ",
        "createdAt" : "2020-03-19T18:31:28Z",
        "updatedAt" : "2020-03-19T18:31:28Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7f4693b184a4cd1682837e9ac4ddf2d48ab7fada",
    "line" : 5,
    "diffHunk" : "@@ -743,7 +743,7 @@ setupWorkspace optInputPackageJson optOutputDir dependencies = do\n     (Just <$> BSL.readFile optInputPackageJson) (const $ pure Nothing)\n   packageJson <- case mbBytes of\n     Nothing -> pure mempty\n-    Just bytes -> case decode bytes :: Maybe PackageJson of\n+    Just bytes -> case decode @PackageJson bytes of"
  },
  {
    "id" : "797723b0-20b0-421f-b024-005e40badf46",
    "prId" : 5005,
    "comments" : [
      {
        "id" : "d7247d7e-378f-4d88-a8cf-5d669989e966",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n```suggestion\r\n  mbBytes <- catchJust (guard . isDoesNotExistError) (Just <$> BSL.readFile optInputPackageJson) (const $ pure Nothing)\r\n```",
        "createdAt" : "2020-03-14T05:25:26Z",
        "updatedAt" : "2020-03-14T21:18:38Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "40d1d057-6f5d-46f7-acd7-421cda32be64",
        "parentId" : "d7247d7e-378f-4d88-a8cf-5d669989e966",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Nice.",
        "createdAt" : "2020-03-14T20:56:34Z",
        "updatedAt" : "2020-03-14T21:18:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9640f962003330d691482ffa2c1b07dfa5e06655",
    "line" : null,
    "diffHunk" : "@@ -730,32 +731,27 @@ instance ToJSON PackageJson where\n -- provided workspaces; write it back to disk.\n setupWorkspace :: FilePath -> FilePath -> [(T.Text, [Dependency])] -> IO ()\n setupWorkspace optInputPackageJson optOutputDir dependencies = do\n-  -- If the file designated by 'optInputPackageJson' doesn't yet\n-  -- exist, create it.\n-  packageJsonExists <- doesFileExist optInputPackageJson\n-  when (not packageJsonExists) $ do\n-    BSL.writeFile optInputPackageJson $\n-      encodePretty (object\n-                    [ \"private\" .= True\n-                    , \"workspaces\" .= ([] :: [T.Text])\n-                    ])\n   let (g, nodeFromVertex) = graphFromEdges'\n         (map (\\(a, ds) -> (a, a, map unDependency ds)) dependencies)\n       ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n         -- Topologically order our packages.\n       outBaseDir = T.pack $ takeFileName optOutputDir\n         -- The leaf directory of the output directory (e.g. often 'daml2ts').\n   let ourWorkspaces = map ((outBaseDir <> \"/\") <>) ps\n-  bytes <- BSL.readFile optInputPackageJson\n-  case decode bytes :: Maybe PackageJson of\n-    Nothing -> fail $ \"Error decoding JSON from '\" <> optInputPackageJson <> \"'\"\n-    Just oldPackageJson -> transformAndWrite ourWorkspaces outBaseDir oldPackageJson\n+  mbBytes <- catch (Just <$> BSL.readFile optInputPackageJson)\n+             (const (pure Nothing) :: IOException -> IO (Maybe BSL.ByteString))"
  },
  {
    "id" : "7e90f3c6-0b4a-4de3-a0a9-ee87cccf0014",
    "prId" : 5005,
    "comments" : [
      {
        "id" : "29836f21-8690-4abe-a590-c3f951d913f3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I think the following is easier to read (and shorter):\r\n```suggestion\r\n    Just bytes -> case decode @PackageJson bytes of\r\n```",
        "createdAt" : "2020-03-16T09:21:48Z",
        "updatedAt" : "2020-03-16T09:25:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9640f962003330d691482ffa2c1b07dfa5e06655",
    "line" : 58,
    "diffHunk" : "@@ -730,32 +737,27 @@ instance ToJSON PackageJson where\n -- provided workspaces; write it back to disk.\n setupWorkspace :: FilePath -> FilePath -> [(T.Text, [Dependency])] -> IO ()\n setupWorkspace optInputPackageJson optOutputDir dependencies = do\n-  -- If the file designated by 'optInputPackageJson' doesn't yet\n-  -- exist, create it.\n-  packageJsonExists <- doesFileExist optInputPackageJson\n-  when (not packageJsonExists) $ do\n-    BSL.writeFile optInputPackageJson $\n-      encodePretty (object\n-                    [ \"private\" .= True\n-                    , \"workspaces\" .= ([] :: [T.Text])\n-                    ])\n   let (g, nodeFromVertex) = graphFromEdges'\n         (map (\\(a, ds) -> (a, a, map unDependency ds)) dependencies)\n       ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n         -- Topologically order our packages.\n       outBaseDir = T.pack $ takeFileName optOutputDir\n         -- The leaf directory of the output directory (e.g. often 'daml2ts').\n   let ourWorkspaces = map ((outBaseDir <> \"/\") <>) ps\n-  bytes <- BSL.readFile optInputPackageJson\n-  case decode bytes :: Maybe PackageJson of\n-    Nothing -> fail $ \"Error decoding JSON from '\" <> optInputPackageJson <> \"'\"\n-    Just oldPackageJson -> transformAndWrite ourWorkspaces outBaseDir oldPackageJson\n+  mbBytes <- catchJust (guard . isDoesNotExistError)\n+    (Just <$> BSL.readFile optInputPackageJson) (const $ pure Nothing)\n+  packageJson <- case mbBytes of\n+    Nothing -> pure mempty\n+    Just bytes -> case decode bytes :: Maybe PackageJson of"
  },
  {
    "id" : "0c5dd30a-8a84-4a37-820a-0a9b99281b47",
    "prId" : 5005,
    "comments" : [
      {
        "id" : "d19c1359-ecb1-479a-8665-789d354ed57f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not a big fan of using (highly) polymorphic constants in monomorphic code. What is `mempty` here? Is it `[]` or `Sum 0` or `Endo id`? I _guess_ it's an empty string of some sort. If so, I'd prefer to have the following for the sake of legibility:\r\n```suggestion\r\n    Nothing -> pure \"\"\r\n```",
        "createdAt" : "2020-03-16T09:25:33Z",
        "updatedAt" : "2020-03-16T09:25:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9640f962003330d691482ffa2c1b07dfa5e06655",
    "line" : 57,
    "diffHunk" : "@@ -730,32 +737,27 @@ instance ToJSON PackageJson where\n -- provided workspaces; write it back to disk.\n setupWorkspace :: FilePath -> FilePath -> [(T.Text, [Dependency])] -> IO ()\n setupWorkspace optInputPackageJson optOutputDir dependencies = do\n-  -- If the file designated by 'optInputPackageJson' doesn't yet\n-  -- exist, create it.\n-  packageJsonExists <- doesFileExist optInputPackageJson\n-  when (not packageJsonExists) $ do\n-    BSL.writeFile optInputPackageJson $\n-      encodePretty (object\n-                    [ \"private\" .= True\n-                    , \"workspaces\" .= ([] :: [T.Text])\n-                    ])\n   let (g, nodeFromVertex) = graphFromEdges'\n         (map (\\(a, ds) -> (a, a, map unDependency ds)) dependencies)\n       ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n         -- Topologically order our packages.\n       outBaseDir = T.pack $ takeFileName optOutputDir\n         -- The leaf directory of the output directory (e.g. often 'daml2ts').\n   let ourWorkspaces = map ((outBaseDir <> \"/\") <>) ps\n-  bytes <- BSL.readFile optInputPackageJson\n-  case decode bytes :: Maybe PackageJson of\n-    Nothing -> fail $ \"Error decoding JSON from '\" <> optInputPackageJson <> \"'\"\n-    Just oldPackageJson -> transformAndWrite ourWorkspaces outBaseDir oldPackageJson\n+  mbBytes <- catchJust (guard . isDoesNotExistError)\n+    (Just <$> BSL.readFile optInputPackageJson) (const $ pure Nothing)\n+  packageJson <- case mbBytes of\n+    Nothing -> pure mempty"
  },
  {
    "id" : "17ce80be-9cd0-4b58-aee9-c1f42cee4ed4",
    "prId" : 5001,
    "comments" : [
      {
        "id" : "712a8c69-7ecc-4aa0-b86b-566bb38c93bb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "How reasonable would it be to default this to `package.json`?",
        "createdAt" : "2020-03-13T19:57:48Z",
        "updatedAt" : "2020-03-13T20:44:57Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e38db610-d670-4efb-b182-60b1b2f3591f",
        "parentId" : "712a8c69-7ecc-4aa0-b86b-566bb38c93bb",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Very reasonable I expect. I'll do that.",
        "createdAt" : "2020-03-13T20:03:35Z",
        "updatedAt" : "2020-03-13T20:44:57Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "fd62e20b94f00b0592230f520a91b0f57ca3096f",
    "line" : 14,
    "diffHunk" : "@@ -93,11 +93,11 @@ optionsParser = Options\n         <> metavar \"DIR\"\n         <> help \"Output directory for the generated packages\"\n         )\n-    <*> optional (strOption\n+    <*> strOption"
  },
  {
    "id" : "4b3c1997-6988-4c5c-9e94-6e4c28db3059",
    "prId" : 5001,
    "comments" : [
      {
        "id" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The docs are not right, you will never update this file now. This raises the question whether this is really the behavior we want. We definitely do not want to overwrite a file if the user has specified nothing. However, if I specify the flag explicitly it does seem weird that it’s ignored if the file already exists.\r\n\r\nHow about the following:\r\n1. Make the flag optional. If it is not specified, create `package.json` if it does not already exist.\r\n2. If the flag is passed explicitly keep the current behavior of overwriting the config.",
        "createdAt" : "2020-03-13T20:02:13Z",
        "updatedAt" : "2020-03-13T20:44:57Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "49f3f3fc-5bc6-4a6b-91b2-b7aa7f1f3a57",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "> The docs are not right, you will never update this file now\r\n\r\nI'm not seeing that?\r\n\r\nI do agree with the rest.",
        "createdAt" : "2020-03-13T20:06:10Z",
        "updatedAt" : "2020-03-13T20:44:58Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1a185381-fb22-4e00-95ac-9ba63f1c50f6",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "> Path to an existing package.json to update\r\n\r\nYou check if the file exists and ignore it in that case. So you might create a new file but you will never update it.",
        "createdAt" : "2020-03-13T20:07:21Z",
        "updatedAt" : "2020-03-13T20:44:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5cefea05-6803-4a6f-814a-80ef14622e56",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Oh these docs : \"Path to an existing 'package.json' to update\"\"?\r\n",
        "createdAt" : "2020-03-13T20:07:59Z",
        "updatedAt" : "2020-03-13T20:44:58Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "33d66d1e-8245-4d87-99a6-c6482dad3913",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "How about this:\r\n```\r\n    <*> strOption\r\n        (  short 'p'\r\n        <> metavar \"PACKAGE-JSON\"\r\n        <> value \"package.json\"\r\n        <> help \"Path to a 'package.json' to create/update\"\r\n        )\r\n```\r\nand otherwise the logic is as it is now - creating the file if doesn't exist and regardless, updating the file when packages have been generated.",
        "createdAt" : "2020-03-13T20:09:15Z",
        "updatedAt" : "2020-03-13T20:44:58Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c1913903-55a7-4fa9-a354-5f9f47a040c1",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "So to recap with this approach:\r\n  - if there is no flag, if \"package.json\" doesn't exist it will be created and later in the program updated;\r\n  - if there is a flag and that package.json doesn't exist it will be created and later in the program updated;\r\n - if there is a flag and the package.json exists, it will not be recreated but will later in the program updated.\r\n",
        "createdAt" : "2020-03-13T20:16:43Z",
        "updatedAt" : "2020-03-13T20:44:58Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cec25c57-0cd5-44c8-a2be-19f7214a7e64",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "> You check if the file exists and ignore it in that case. So you might create a new file but you will never update it.\r\n\r\nI think that's where the confusion lies. The file `optInputPackage` is read from and written to in `setupWorkspace`.  Now we just make sure that if it didn't exist before calling daml2ts, it is sure to exist before `setupWorkspace`.",
        "createdAt" : "2020-03-13T20:18:38Z",
        "updatedAt" : "2020-03-13T20:44:58Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5431741e-d363-4a0c-9f5f-810303a938fe",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh I see, I didn’t realize that.",
        "createdAt" : "2020-03-13T20:19:50Z",
        "updatedAt" : "2020-03-13T20:44:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "af8d152b-bc20-43e9-8212-91353ef2710c",
        "parentId" : "4c59bb18-4895-495c-ba6c-b13b94a3f624",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "The new phrasing moves the creation into `setupWorkspace` itself so hopefully that won't confuse anyone again.",
        "createdAt" : "2020-03-13T20:46:25Z",
        "updatedAt" : "2020-03-13T20:46:25Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fd62e20b94f00b0592230f520a91b0f57ca3096f",
    "line" : null,
    "diffHunk" : "@@ -93,11 +93,11 @@ optionsParser = Options\n         <> metavar \"DIR\"\n         <> help \"Output directory for the generated packages\"\n         )\n-    <*> optional (strOption\n+    <*> strOption\n         (  short 'p'\n         <> metavar \"PACKAGE-JSON\"\n         <> help \"Path to an existing 'package.json' to update\""
  },
  {
    "id" : "9ddfa45f-c2bb-43a3-a57a-d878bffeaf66",
    "prId" : 5001,
    "comments" : [
      {
        "id" : "c5dd6a03-0983-4288-a57d-7ab2758d2288",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe catch the error when reading the file and default it to this instead of explicitly creating it here?",
        "createdAt" : "2020-03-13T20:48:34Z",
        "updatedAt" : "2020-03-13T20:49:53Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "fd62e20b94f00b0592230f520a91b0f57ca3096f",
    "line" : 45,
    "diffHunk" : "@@ -727,18 +728,27 @@ instance ToJSON PackageJson where\n \n -- Read the provided 'package.json'; transform it to include the\n -- provided workspaces; write it back to disk.\n-setupWorkspace :: FilePath -> [(T.Text, [Dependency])] -> FilePath -> IO ()\n-setupWorkspace optOutputDir dependencies file = do\n+setupWorkspace :: FilePath -> FilePath -> [(T.Text, [Dependency])] -> IO ()\n+setupWorkspace optInputPackageJson optOutputDir dependencies = do\n+  -- If the file designated by 'optInputPackageJson' doesn't yet\n+  -- exist, create it.\n+  packageJsonExists <- doesFileExist optInputPackageJson\n+  when (not packageJsonExists) $ do"
  },
  {
    "id" : "5fdd913e-6fcd-4451-8b6b-78881ba6a9cf",
    "prId" : 4975,
    "comments" : [
      {
        "id" : "5e738646-5f4e-4982-9baa-a6726f94d481",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n                \"\" : [\"  | '\" <> cons <> \"'\" | cons <- cs]\r\n```\r\nTypeScript seems to be perfectly happy to put a `|` at the beginning as well and that’s even used in the docs for unions and it makes your code much more readable.",
        "createdAt" : "2020-03-12T20:15:39Z",
        "updatedAt" : "2020-03-12T21:11:40Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8eda1667-84b2-4db7-9614-57cfcea6741f",
        "parentId" : "5e738646-5f4e-4982-9baa-a6726f94d481",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Very well spotted. Thanks.",
        "createdAt" : "2020-03-12T20:53:38Z",
        "updatedAt" : "2020-03-12T21:11:40Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f6f10a59e79f234fa88ceca81c572c611a97f7d",
    "line" : null,
    "diffHunk" : "@@ -347,20 +347,24 @@ genDefDataType curPkgId conName mod tpls def =\n                      [\"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"]\n             in ((typeDesc, serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n         DataEnum enumCons ->\n-          let\n-            typeDesc =\n-                [ \"export enum \" <> conName <> \" {\"] ++\n-                [ \"  \" <> cons <> \" = \" <> \"\\'\" <> cons <> \"\\'\" <> \",\"\n-                | VariantConName cons <- enumCons] ++\n-                [ \"}\"\n-                , \"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"\n-                ]\n-            serDesc =\n-                [\"() => jtv.oneOf<\" <> conName <> \">\" <> \"(\"] ++\n-                [\"  jtv.constant(\" <> conName <> \".\" <> cons <> \"),\" | VariantConName cons <- enumCons] ++\n-                [\");\"]\n+          let cs = map unVariantConName enumCons\n+              typeDesc =\n+                let td = [\"  \" <> \"'\" <> cons <> \"'\" | cons <- cs]\n+                    td' = reverse td\n+                in [\"\"] <> reverse (head td' : map (<> \" | \") (tail td'))"
  },
  {
    "id" : "8bd59392-8ddf-4367-b9bc-fb06e73e3100",
    "prId" : 4975,
    "comments" : [
      {
        "id" : "10af61ca-e196-4cc3-b139-70c970f845f6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Side note: The whole code in this module seems to become increasingly messy. I hope it won’t grow much anymore so this is probably not a huge issue but if it does, we should use a pretty printing library and maybe consider introducing some intermediate types or at least lots of helper functions instead of converting directly to strings.",
        "createdAt" : "2020-03-12T20:16:55Z",
        "updatedAt" : "2020-03-12T21:11:40Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2deb6902-19a7-4a9a-86b3-6c32fd6ce10c",
        "parentId" : "10af61ca-e196-4cc3-b139-70c970f845f6",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Captured in issue https://github.com/digital-asset/daml/issues/5047.",
        "createdAt" : "2020-03-17T16:40:55Z",
        "updatedAt" : "2020-03-17T16:40:56Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3f6f10a59e79f234fa88ceca81c572c611a97f7d",
    "line" : 20,
    "diffHunk" : "@@ -347,20 +347,24 @@ genDefDataType curPkgId conName mod tpls def =\n                      [\"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"]\n             in ((typeDesc, serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n         DataEnum enumCons ->\n-          let\n-            typeDesc =\n-                [ \"export enum \" <> conName <> \" {\"] ++\n-                [ \"  \" <> cons <> \" = \" <> \"\\'\" <> cons <> \"\\'\" <> \",\"\n-                | VariantConName cons <- enumCons] ++\n-                [ \"}\"\n-                , \"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"\n-                ]\n-            serDesc =\n-                [\"() => jtv.oneOf<\" <> conName <> \">\" <> \"(\"] ++\n-                [\"  jtv.constant(\" <> conName <> \".\" <> cons <> \"),\" | VariantConName cons <- enumCons] ++\n-                [\");\"]\n+          let cs = map unVariantConName enumCons\n+              typeDesc =\n+                let td = [\"  \" <> \"'\" <> cons <> \"'\" | cons <- cs]\n+                    td' = reverse td\n+                in [\"\"] <> reverse (head td' : map (<> \" | \") (tail td'))\n+              -- The complete definition of the companion object.\n+              serDesc =\n+                [ \"export const \" <> conName <> \": daml.Serializable<\" <> conName <> \"> & {\"] <>"
  },
  {
    "id" : "ba402831-be32-4e00-b45c-ff52d10633ed",
    "prId" : 4975,
    "comments" : [
      {
        "id" : "9737965c-03c5-4ca7-926b-7881fe4a932e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "One thing that has come up in the past I believe is the need to enumerate enum values (e.g., let’s say you have a dropdown or something like that). If my understanding and my google searches are correct this is easy to do with an enum but not with a union. However, given that we have the companion object, we can probably add the enumeration on that, e.g. `Color.keys = [\"Red\", …]`. I would suggest to leave this out of this PR and do some research if there is a common pattern for this in typescript that we can steal.",
        "createdAt" : "2020-03-12T20:25:58Z",
        "updatedAt" : "2020-03-12T21:11:40Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fcc2ab29-d5be-4bbd-bfd8-692303f03636",
        "parentId" : "9737965c-03c5-4ca7-926b-7881fe4a932e",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Yes, we should definitely do something like this. If it wasn't for the `decoder` method, we could use `Object.keys(Color)`. But it's there anyway. So, having `Color.keys` would be great.",
        "createdAt" : "2020-03-16T09:33:32Z",
        "updatedAt" : "2020-03-16T09:33:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4991451f-b610-4abb-afac-f3b804346366",
        "parentId" : "9737965c-03c5-4ca7-926b-7881fe4a932e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/5044",
        "createdAt" : "2020-03-17T15:37:06Z",
        "updatedAt" : "2020-03-17T15:37:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3f6f10a59e79f234fa88ceca81c572c611a97f7d",
    "line" : 23,
    "diffHunk" : "@@ -347,20 +347,24 @@ genDefDataType curPkgId conName mod tpls def =\n                      [\"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"]\n             in ((typeDesc, serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n         DataEnum enumCons ->\n-          let\n-            typeDesc =\n-                [ \"export enum \" <> conName <> \" {\"] ++\n-                [ \"  \" <> cons <> \" = \" <> \"\\'\" <> cons <> \"\\'\" <> \",\"\n-                | VariantConName cons <- enumCons] ++\n-                [ \"}\"\n-                , \"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"\n-                ]\n-            serDesc =\n-                [\"() => jtv.oneOf<\" <> conName <> \">\" <> \"(\"] ++\n-                [\"  jtv.constant(\" <> conName <> \".\" <> cons <> \"),\" | VariantConName cons <- enumCons] ++\n-                [\");\"]\n+          let cs = map unVariantConName enumCons\n+              typeDesc =\n+                let td = [\"  \" <> \"'\" <> cons <> \"'\" | cons <- cs]\n+                    td' = reverse td\n+                in [\"\"] <> reverse (head td' : map (<> \" | \") (tail td'))\n+              -- The complete definition of the companion object.\n+              serDesc =\n+                [ \"export const \" <> conName <> \": daml.Serializable<\" <> conName <> \"> & {\"] <>\n+                [ \"  readonly \" <> cons <> \": \" <> conName <> \";\" | cons <- cs ] ++\n+                [\"} = {\"] ++\n+                [\"  \" <> cons <> \": '\" <> cons <> \"',\" | cons <- cs] ++"
  },
  {
    "id" : "256c056f-fbe8-4ab9-b1d6-71bd90fd2edd",
    "prId" : 4975,
    "comments" : [
      {
        "id" : "1b24de43-4f5e-4cb9-857f-b5c00e7b006c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Declaring that `Color.X` has type `Color` renders the pattern match exhaustiveness checker for `Color` useless. Instead, we want to declare the type as `\"X\"`. The easiest way to get this is to intersect with the type\r\n```\r\n{readonly [c in Color]: c}\r\n```\r\ninstead of the record were constructing here.",
        "createdAt" : "2020-03-16T09:53:00Z",
        "updatedAt" : "2020-03-16T09:54:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "31718324-025e-4192-8941-75c3b36da2e4",
        "parentId" : "1b24de43-4f5e-4cb9-857f-b5c00e7b006c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "For reference https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types.",
        "createdAt" : "2020-03-17T14:22:03Z",
        "updatedAt" : "2020-03-17T14:22:04Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "09e656ed-d671-4614-8d8f-c53f58ecc67c",
        "parentId" : "1b24de43-4f5e-4cb9-857f-b5c00e7b006c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/5044",
        "createdAt" : "2020-03-17T14:48:51Z",
        "updatedAt" : "2020-03-17T14:48:52Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3f6f10a59e79f234fa88ceca81c572c611a97f7d",
    "line" : 21,
    "diffHunk" : "@@ -347,20 +347,21 @@ genDefDataType curPkgId conName mod tpls def =\n                      [\"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"]\n             in ((typeDesc, serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n         DataEnum enumCons ->\n-          let\n-            typeDesc =\n-                [ \"export enum \" <> conName <> \" {\"] ++\n-                [ \"  \" <> cons <> \" = \" <> \"\\'\" <> cons <> \"\\'\" <> \",\"\n-                | VariantConName cons <- enumCons] ++\n-                [ \"}\"\n-                , \"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"\n-                ]\n-            serDesc =\n-                [\"() => jtv.oneOf<\" <> conName <> \">\" <> \"(\"] ++\n-                [\"  jtv.constant(\" <> conName <> \".\" <> cons <> \"),\" | VariantConName cons <- enumCons] ++\n-                [\");\"]\n+          let cs = map unVariantConName enumCons\n+              typeDesc = \"\" : [\"  | '\" <> cons <> \"'\" | cons <- cs]\n+              -- The complete definition of the companion object.\n+              serDesc =\n+                [ \"export const \" <> conName <> \": daml.Serializable<\" <> conName <> \"> & {\"] <>\n+                [ \"  readonly \" <> cons <> \": \" <> conName <> \";\" | cons <- cs ] ++"
  },
  {
    "id" : "1b941451-1189-40e4-8db5-f96308303b60",
    "prId" : 4975,
    "comments" : [
      {
        "id" : "ca2104d2-f7a3-4c89-b1f7-74fdcd2a25fa",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We already state that `Color` has type `daml.Serializable<Color>` (intersected with more stuff) above. Thus, we can drop this check. If that's the last occurrence of this check (hopfully!), then we can remove the whole `STATIC_IMPLEMENTS_SERIALIZABLE_CHECK` from our libraries.",
        "createdAt" : "2020-03-16T09:54:50Z",
        "updatedAt" : "2020-03-16T09:54:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1873234e-dde8-479a-8f1b-45bf5a121600",
        "parentId" : "ca2104d2-f7a3-4c89-b1f7-74fdcd2a25fa",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/5044. Unfortunately, not the last occurence.",
        "createdAt" : "2020-03-17T14:49:17Z",
        "updatedAt" : "2020-03-17T14:49:17Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "88ce1fe6-ea09-40e8-beac-c0077bc1bc3d",
        "parentId" : "ca2104d2-f7a3-4c89-b1f7-74fdcd2a25fa",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "although the last occurrence is silly in the same way that this one became. will remove it in this PR freeing the way to delete it from @daml/types. ",
        "createdAt" : "2020-03-17T14:50:24Z",
        "updatedAt" : "2020-03-17T14:50:24Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1c169519-a3e8-4e24-8915-19f1074e8fa0",
        "parentId" : "ca2104d2-f7a3-4c89-b1f7-74fdcd2a25fa",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Done in https://github.com/digital-asset/daml/pull/5044 including removal of the definition of the check from `daml-types`.",
        "createdAt" : "2020-03-17T15:00:54Z",
        "updatedAt" : "2020-03-17T15:00:54Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3f6f10a59e79f234fa88ceca81c572c611a97f7d",
    "line" : 28,
    "diffHunk" : "@@ -347,20 +347,21 @@ genDefDataType curPkgId conName mod tpls def =\n                      [\"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"]\n             in ((typeDesc, serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n         DataEnum enumCons ->\n-          let\n-            typeDesc =\n-                [ \"export enum \" <> conName <> \" {\"] ++\n-                [ \"  \" <> cons <> \" = \" <> \"\\'\" <> cons <> \"\\'\" <> \",\"\n-                | VariantConName cons <- enumCons] ++\n-                [ \"}\"\n-                , \"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"\n-                ]\n-            serDesc =\n-                [\"() => jtv.oneOf<\" <> conName <> \">\" <> \"(\"] ++\n-                [\"  jtv.constant(\" <> conName <> \".\" <> cons <> \"),\" | VariantConName cons <- enumCons] ++\n-                [\");\"]\n+          let cs = map unVariantConName enumCons\n+              typeDesc = \"\" : [\"  | '\" <> cons <> \"'\" | cons <- cs]\n+              -- The complete definition of the companion object.\n+              serDesc =\n+                [ \"export const \" <> conName <> \": daml.Serializable<\" <> conName <> \"> & {\"] <>\n+                [ \"  readonly \" <> cons <> \": \" <> conName <> \";\" | cons <- cs ] ++\n+                [\"} = {\"] ++\n+                [\"  \" <> cons <> \": '\" <> cons <> \"',\" | cons <- cs] ++\n+                [\"  decoder: () => jtv.oneOf<\" <> conName <> \">\" <> \"(\"] ++\n+                [\"      jtv.constant(\" <> conName <> \".\" <> cons <> \"),\" | cons <- cs] ++\n+                [\"  ),\"] ++\n+                [\"} as const;\"] ++\n+                [\"daml.STATIC_IMPLEMENTS_SERIALIZABLE_CHECK<\" <> conName <> \">(\" <> conName <> \")\"]"
  },
  {
    "id" : "fd7ddc98-f52b-4861-a9c5-0c7b0bbfaa0f",
    "prId" : 4951,
    "comments" : [
      {
        "id" : "7a0dfcb9-bb6c-4215-a065-d4cb42a476d2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This changes behavior: `joinPath` is platform dependent. On Windows it will produce backslashes, i.e., `joinPath [\"a\", \"b\"] == \"a\\\\b\"`. Does that still work?  If it does, did it work before, i.e., do both `/` and `\\` work on Windows? If so, would it be better to use `/` consistently everywhere so the generated typescript code is platform independent?",
        "createdAt" : "2020-03-11T18:25:36Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1f35ce6c-582a-490f-9a61-7a91fe3758b9",
        "parentId" : "7a0dfcb9-bb6c-4215-a065-d4cb42a476d2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "the approach we've taken in ghc-lib scripts is to use '/' even on windows.\r\n- i'll change the implementation of `modPath` to use `intercalate` rather than `joinPath`\r\n- `import System.FilePath.Posix((</>)) -- Make sure we generate / on all platforms.`\r\n\r\nthe change to `modPath`  has the additional benefit of cutting down on more `T.unpack`'s too. ",
        "createdAt" : "2020-03-11T18:33:02Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f9815080-6385-4ae2-8546-33824bcd3265",
        "parentId" : "7a0dfcb9-bb6c-4215-a065-d4cb42a476d2",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I know how it works for ghc-lib. What I don’t know if javascript import syntax imposes special restrictions. From looking around, I couldn’t find a clear answer to this.",
        "createdAt" : "2020-03-11T18:34:25Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3d78cf9d-ec71-4f81-a0b5-51f16b6f5c9f",
        "parentId" : "7a0dfcb9-bb6c-4215-a065-d4cb42a476d2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "it would seem according to https://shapeshed.com/writing-cross-platform-node/ that forward slashes will work on windows.",
        "createdAt" : "2020-03-11T18:41:28Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2eb7d156-e182-43c8-9c48-6a62d4e79f34",
        "parentId" : "7a0dfcb9-bb6c-4215-a065-d4cb42a476d2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i expect the two suggested changes above is a good idea so as to negate the possibility of future maintainers wondering about it all over.",
        "createdAt" : "2020-03-11T18:42:44Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9ff3db25-5e88-4182-9625-10d89540c4ec",
        "parentId" : "7a0dfcb9-bb6c-4215-a065-d4cb42a476d2",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That doesn’t talk about imports which is the thing I’m worried about. Anyway, given that basically all examples I can find use forward slashes that seems like a safe choice and it is platform independent which makes me happy since I like reproducible builds across platforms.",
        "createdAt" : "2020-03-11T18:43:12Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6fcf295d-deef-4096-849a-2c7170894d5d",
        "parentId" : "7a0dfcb9-bb6c-4215-a065-d4cb42a476d2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "> basically all examples I can find use forward slashes that seems like a safe choice \r\n\r\nagreed. have pushed a revision. good to go?",
        "createdAt" : "2020-03-11T18:46:21Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d0292d1964bcdf22d58064a0fe8dc136cec7f4f1",
    "line" : 33,
    "diffHunk" : "@@ -260,7 +260,7 @@ genModule pkgMap (Scope scope) curPkgId mod\n                       (PackageRef, ModuleName) -> T.Text -> T.Text\n     importDecl pkgMap modRef@(pkgRef, modName) rootPath =\n       \"import * as \" <>  genModuleRef modRef <> \" from '\" <>\n-      T.intercalate \"/\" ((rootPath : pkgRefStr pkgMap pkgRef : [\"lib\" | pkgRef /= PRSelf]) ++ unModuleName modName) <>\n+      modPath ((rootPath : pkgRefStr pkgMap pkgRef : [\"lib\" | pkgRef /= PRSelf]) ++ unModuleName modName) <>"
  },
  {
    "id" : "2ba4bd22-e121-4f2c-a9a1-bd7338c8e08a",
    "prId" : 4951,
    "comments" : [
      {
        "id" : "db071eb8-f179-4955-9579-068d928c3789",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that you already import `System.FilePath.Posix`, maybe just use `joinPath` from there?",
        "createdAt" : "2020-03-11T18:45:57Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7e2c2059-950f-45e0-996c-65e88df311cd",
        "parentId" : "db071eb8-f179-4955-9579-068d928c3789",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "we could, i like that this approach allows us to avoid unpacks.",
        "createdAt" : "2020-03-11T18:46:51Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "124beb4c-04a9-4026-bf49-ea9b7615b7fc",
        "parentId" : "db071eb8-f179-4955-9579-068d928c3789",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Makes sense :+1:",
        "createdAt" : "2020-03-11T18:47:42Z",
        "updatedAt" : "2020-03-11T18:52:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d0292d1964bcdf22d58064a0fe8dc136cec7f4f1",
    "line" : 60,
    "diffHunk" : "@@ -559,7 +560,7 @@ modVar prefix parts = prefix <> T.intercalate \"_\" parts\n -- Calculate a filepath from a module name e.g. 'modPath [\".\", \"A\",\n -- \"B\"]' is \"./A/B\".\n modPath :: [T.Text] -> T.Text\n-modPath parts = T.pack (joinPath $ map T.unpack parts)\n+modPath parts = T.intercalate \"/\" parts"
  },
  {
    "id" : "d25dc2fc-c887-45c7-b025-ec2158544754",
    "prId" : 4951,
    "comments" : [
      {
        "id" : "b8c18274-3627-45b9-9b65-cbad81248b44",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can't we just import `System.FilePath.Posix` _instead_ of `System.FilePath`.",
        "createdAt" : "2020-03-12T10:09:59Z",
        "updatedAt" : "2020-03-12T10:13:26Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d7c6a464-7584-4d76-bf77-6cca342e6576",
        "parentId" : "b8c18274-3627-45b9-9b65-cbad81248b44",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i agree it seems sensible. see https://github.com/digital-asset/daml/pull/4963.",
        "createdAt" : "2020-03-12T11:54:18Z",
        "updatedAt" : "2020-03-12T11:54:19Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d95fdca3-f69d-455e-b6c5-320f89528917",
        "parentId" : "b8c18274-3627-45b9-9b65-cbad81248b44",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Update : after discussion, it seems the safer choice is to not replace `FilePath` with `FilePath.Posix` so, it was decided to not land https://github.com/digital-asset/daml/pull/4963.",
        "createdAt" : "2020-03-12T12:57:25Z",
        "updatedAt" : "2020-03-12T12:57:25Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d0292d1964bcdf22d58064a0fe8dc136cec7f4f1",
    "line" : 6,
    "diffHunk" : "@@ -30,7 +30,8 @@ import Data.Maybe\n import Data.Bifoldable\n import Options.Applicative\n import System.Directory\n-import System.FilePath hiding ((<.>))\n+import System.FilePath hiding ((<.>), (</>))\n+import System.FilePath.Posix((</>)) -- Make sure we generate / on all platforms."
  },
  {
    "id" : "a5d15e92-bc1e-4eba-b82e-8d9e1149a8c4",
    "prId" : 4926,
    "comments" : [
      {
        "id" : "4e636caa-e99c-4765-815a-19b7834a9543",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This looks confusing. If you want to call this `lines` it should be of type `[T.Text]` and the call site should call `T.unlines`. Otherwise just call it `content` or something like this.",
        "createdAt" : "2020-03-11T07:17:21Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d18812de-9f09-4ec3-abf9-124c0f9a1512",
        "parentId" : "4e636caa-e99c-4765-815a-19b7834a9543",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-03-11T12:07:15Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13e89ec71941cba02bae6952b66d10827cea0610",
    "line" : null,
    "diffHunk" : "@@ -565,6 +567,52 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+writeIndexTs :: FilePath -> [Module] -> IO ()\n+writeIndexTs packageSrcDir modules =\n+  T.writeFileUtf8 (packageSrcDir </> \"index.ts\") lines\n+  where\n+    lines :: T.Text"
  },
  {
    "id" : "1f581ca2-7337-4937-80cd-1ef2c8a3482a",
    "prId" : 4926,
    "comments" : [
      {
        "id" : "be73a4a1-ce93-4e0a-a2b0-824b5069818c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You already have the same logic for turning a module name into a file name in `genModuleRef`. Let’s factor this out into a function.",
        "createdAt" : "2020-03-11T07:28:03Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "22390f49-792f-4020-91a4-334aa6d80c29",
        "parentId" : "be73a4a1-ce93-4e0a-a2b0-824b5069818c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-03-11T12:07:21Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5c069d41-96ab-492d-8c11-301850bc57c7",
        "parentId" : "be73a4a1-ce93-4e0a-a2b0-824b5069818c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Found further uses for this function in https://github.com/digital-asset/daml/pull/4951.",
        "createdAt" : "2020-03-11T18:01:37Z",
        "updatedAt" : "2020-03-11T18:01:37Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13e89ec71941cba02bae6952b66d10827cea0610",
    "line" : null,
    "diffHunk" : "@@ -565,6 +567,52 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+writeIndexTs :: FilePath -> [Module] -> IO ()\n+writeIndexTs packageSrcDir modules =\n+  T.writeFileUtf8 (packageSrcDir </> \"index.ts\") lines\n+  where\n+    lines :: T.Text\n+    lines = T.unlines $ header <> concatMap entry modules\n+\n+    header :: [T.Text]\n+    header =\n+      [ \"import {default as __packageId} from \\\"./packageId\\\"\"\n+      , \"export const packageId = __packageId\"\n+      ]\n+\n+    entry :: Module -> [T.Text]\n+    entry mod\n+      | null $ defDataTypes mod = []\n+      | otherwise = importDecl var path <> exportDecl var parts\n+      where\n+        parts = unModuleName (moduleName mod)\n+        var = \"__\" <> T.intercalate \"_\" parts"
  },
  {
    "id" : "0f0316ea-13af-46e3-b0de-18019d5e74e3",
    "prId" : 4926,
    "comments" : [
      {
        "id" : "cf3f5284-793b-45b5-bfe3-48b0452bef1f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This might be showing my ignorance of typescript but why do we use namespaces instead of ES2015 module syntax? All the docs I can find on this claim that this is outdated and legacy stuff and ES2015 module syntax should be preferered.",
        "createdAt" : "2020-03-11T07:39:22Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d2a1bd3-85ba-4071-807b-03ceeaaf96ee",
        "parentId" : "cf3f5284-793b-45b5-bfe3-48b0452bef1f",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Each ES2015 module has to go into its own file, which is exactly the opposite of what we're trying to do here. However, _I think_ we can use proper `const`s and nested objects for the value level and `declare namspace` for the type level to achieve what we want. Let's try that in a separate PR though.",
        "createdAt" : "2020-03-11T10:07:10Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "84ac5225-9834-4681-ae0a-f877ac5d695d",
        "parentId" : "cf3f5284-793b-45b5-bfe3-48b0452bef1f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh I see, I didn’t think of the type-level stuff so I thought a simple object would be sufficient.",
        "createdAt" : "2020-03-11T16:40:02Z",
        "updatedAt" : "2020-03-11T16:40:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "13e89ec71941cba02bae6952b66d10827cea0610",
    "line" : 86,
    "diffHunk" : "@@ -565,6 +567,52 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+writeIndexTs :: FilePath -> [Module] -> IO ()\n+writeIndexTs packageSrcDir modules =\n+  T.writeFileUtf8 (packageSrcDir </> \"index.ts\") lines\n+  where\n+    lines :: T.Text\n+    lines = T.unlines $ header <> concatMap entry modules\n+\n+    header :: [T.Text]\n+    header =\n+      [ \"import {default as __packageId} from \\\"./packageId\\\"\"\n+      , \"export const packageId = __packageId\"\n+      ]\n+\n+    entry :: Module -> [T.Text]\n+    entry mod\n+      | null $ defDataTypes mod = []\n+      | otherwise = importDecl var path <> exportDecl var parts\n+      where\n+        parts = unModuleName (moduleName mod)\n+        var = \"__\" <> T.intercalate \"_\" parts\n+        path =  \"\\\"./\" <> T.intercalate \"/\" parts <> \"\\\"\"\n+\n+    importDecl :: T.Text -> T.Text -> [T.Text]\n+    importDecl var path =\n+      [ \"/* eslint-disable @typescript-eslint/camelcase */\"\n+      , \"import * as \" <> var <> \" from \"  <> path\n+      ]\n+\n+    exportDecl :: T.Text -> [T.Text] -> [T.Text]\n+    exportDecl = go 0\n+      where\n+        spaces i = T.pack $ replicate i ' '\n+\n+        go :: Int -> T.Text -> [T.Text] -> [T.Text]\n+        go indent var [m] = let ws = spaces indent in\n+          [ ws <> \"/* eslint-disable @typescript-eslint/no-unused-vars */\"\n+          , ws <> \"export import \" <> m <> \" = \" <> var\n+          ]\n+        go indent var (m : parts) = let ws = spaces indent in\n+          [ ws <> \"/* eslint-disable @typescript-eslint/no-namespace */\""
  },
  {
    "id" : "c14f2f37-3a94-445f-8a2b-ad8212475568",
    "prId" : 4926,
    "comments" : [
      {
        "id" : "05345501-1f1d-4dda-90b2-f12fc4eaef80",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t understand this. Why is the variable unused if it’s exported? https://eslint.org/docs/2.0.0/rules/no-unused-vars#exporting-variables claims that this is only required if you use `var` which doesn’t seem to be the case.",
        "createdAt" : "2020-03-11T07:41:34Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "97a473f5-f901-466f-a1e7-734258f9a9cf",
        "parentId" : "05345501-1f1d-4dda-90b2-f12fc4eaef80",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i don't know. i can tell you though that in practice lint warnings are generated.\r\n```\r\n$ eslint --ext .ts --max-warnings 0 src/\r\n\r\n/private/var/folders/kc/bjk2hzwx6bv07jz_s80wjh7w0000gn/T/extra-dir-43326669297/daml2ts/057eed1fd48c238491b8ea06b9b5bf85a5d4c9275dd3f6183e0e6b01730cc2ba/src/index.ts\r\n  9:19  warning  'Down' is defined but never used  @typescript-eslint/no-unused-vars\r\n```\r\n",
        "createdAt" : "2020-03-11T10:57:04Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13e89ec71941cba02bae6952b66d10827cea0610",
    "line" : null,
    "diffHunk" : "@@ -565,6 +567,52 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+writeIndexTs :: FilePath -> [Module] -> IO ()\n+writeIndexTs packageSrcDir modules =\n+  T.writeFileUtf8 (packageSrcDir </> \"index.ts\") lines\n+  where\n+    lines :: T.Text\n+    lines = T.unlines $ header <> concatMap entry modules\n+\n+    header :: [T.Text]\n+    header =\n+      [ \"import {default as __packageId} from \\\"./packageId\\\"\"\n+      , \"export const packageId = __packageId\"\n+      ]\n+\n+    entry :: Module -> [T.Text]\n+    entry mod\n+      | null $ defDataTypes mod = []\n+      | otherwise = importDecl var path <> exportDecl var parts\n+      where\n+        parts = unModuleName (moduleName mod)\n+        var = \"__\" <> T.intercalate \"_\" parts\n+        path =  \"\\\"./\" <> T.intercalate \"/\" parts <> \"\\\"\"\n+\n+    importDecl :: T.Text -> T.Text -> [T.Text]\n+    importDecl var path =\n+      [ \"/* eslint-disable @typescript-eslint/camelcase */\"\n+      , \"import * as \" <> var <> \" from \"  <> path\n+      ]\n+\n+    exportDecl :: T.Text -> [T.Text] -> [T.Text]\n+    exportDecl = go 0\n+      where\n+        spaces i = T.pack $ replicate i ' '\n+\n+        go :: Int -> T.Text -> [T.Text] -> [T.Text]\n+        go indent var [m] = let ws = spaces indent in\n+          [ ws <> \"/* eslint-disable @typescript-eslint/no-unused-vars */\"\n+          , ws <> \"export import \" <> m <> \" = \" <> var"
  },
  {
    "id" : "d7faebaf-1793-4e21-bd57-30d694852b49",
    "prId" : 4926,
    "comments" : [
      {
        "id" : "3abb4033-75d1-4a75-a397-4fcfbcb0d9c5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I find the inlined pretty printing quite hard to read. Do we actually need this? Maybe leave it out for now and replace it by a proper pretty printing library at some point?",
        "createdAt" : "2020-03-11T07:44:23Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "13e89ec71941cba02bae6952b66d10827cea0610",
    "line" : 89,
    "diffHunk" : "@@ -565,6 +567,52 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+writeIndexTs :: FilePath -> [Module] -> IO ()\n+writeIndexTs packageSrcDir modules =\n+  T.writeFileUtf8 (packageSrcDir </> \"index.ts\") lines\n+  where\n+    lines :: T.Text\n+    lines = T.unlines $ header <> concatMap entry modules\n+\n+    header :: [T.Text]\n+    header =\n+      [ \"import {default as __packageId} from \\\"./packageId\\\"\"\n+      , \"export const packageId = __packageId\"\n+      ]\n+\n+    entry :: Module -> [T.Text]\n+    entry mod\n+      | null $ defDataTypes mod = []\n+      | otherwise = importDecl var path <> exportDecl var parts\n+      where\n+        parts = unModuleName (moduleName mod)\n+        var = \"__\" <> T.intercalate \"_\" parts\n+        path =  \"\\\"./\" <> T.intercalate \"/\" parts <> \"\\\"\"\n+\n+    importDecl :: T.Text -> T.Text -> [T.Text]\n+    importDecl var path =\n+      [ \"/* eslint-disable @typescript-eslint/camelcase */\"\n+      , \"import * as \" <> var <> \" from \"  <> path\n+      ]\n+\n+    exportDecl :: T.Text -> [T.Text] -> [T.Text]\n+    exportDecl = go 0\n+      where\n+        spaces i = T.pack $ replicate i ' '\n+\n+        go :: Int -> T.Text -> [T.Text] -> [T.Text]\n+        go indent var [m] = let ws = spaces indent in\n+          [ ws <> \"/* eslint-disable @typescript-eslint/no-unused-vars */\"\n+          , ws <> \"export import \" <> m <> \" = \" <> var\n+          ]\n+        go indent var (m : parts) = let ws = spaces indent in\n+          [ ws <> \"/* eslint-disable @typescript-eslint/no-namespace */\"\n+          , ws <> \"export namespace \" <> m <> \" {\"\n+          ] <>\n+          go (indent + 2) var parts <>"
  },
  {
    "id" : "9c26d7e1-e7b3-4141-8452-15e1675de93d",
    "prId" : 4926,
    "comments" : [
      {
        "id" : "753715ba-5953-4f3b-ba71-1bb4c3eecab9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n      [ \"import __packageId from \\\"./packageId\\\"\"\r\n```\r\nshould do the same.\r\n\r\nWe should also add semicolons to the ends of lines.",
        "createdAt" : "2020-03-11T09:58:06Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0be16a41-1b75-4abd-a500-8194ad72cda3",
        "parentId" : "753715ba-5953-4f3b-ba71-1bb4c3eecab9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "adding semis to `import * as .... ;` and `export import m = n;`",
        "createdAt" : "2020-03-11T11:00:20Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5a7cbb88-82dc-4a13-876a-b6f714bf71c1",
        "parentId" : "753715ba-5953-4f3b-ba71-1bb4c3eecab9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-03-11T12:07:36Z",
        "updatedAt" : "2020-03-11T12:08:32Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13e89ec71941cba02bae6952b66d10827cea0610",
    "line" : null,
    "diffHunk" : "@@ -565,6 +567,52 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+writeIndexTs :: FilePath -> [Module] -> IO ()\n+writeIndexTs packageSrcDir modules =\n+  T.writeFileUtf8 (packageSrcDir </> \"index.ts\") lines\n+  where\n+    lines :: T.Text\n+    lines = T.unlines $ header <> concatMap entry modules\n+\n+    header :: [T.Text]\n+    header =\n+      [ \"import {default as __packageId} from \\\"./packageId\\\"\""
  },
  {
    "id" : "5eeac4e3-b3d4-47c4-be00-e1eeb6962c15",
    "prId" : 4908,
    "comments" : [
      {
        "id" : "c93637e1-dc76-4311-93d6-42c4f0763c31",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What’s the point of including the `@` here? Can a scope ever not contain an `@`? My understanding was that the `@` sign is not part of the scope name but just syntax to differentiate the scope from the name. So it seems more sensible to not include it here.",
        "createdAt" : "2020-03-09T19:04:44Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8b688468-fef4-43a1-a57c-c4dea7306c0f",
        "parentId" : "c93637e1-dc76-4311-93d6-42c4f0763c31",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "@cocreature in https://github.com/digital-asset/daml/pull/4818#discussion_r388145444, @hurryabit indicated that he'd prefer to see the '@'. i'm easy on this point.",
        "createdAt" : "2020-03-09T19:15:55Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8700475b-7188-4dbd-ae33-f9421d65b2ce",
        "parentId" : "c93637e1-dc76-4311-93d6-42c4f0763c31",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "That was about the internals not the UX for the CLI argument afaict. Either way, if @hurryabit prefers this I don’t feel too strongly about this.",
        "createdAt" : "2020-03-09T19:18:17Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2aed2fec-97e0-4c11-925d-2f694d461a13",
        "parentId" : "c93637e1-dc76-4311-93d6-42c4f0763c31",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "As @cocreature said, I preferred it for the internals. If we required our users to pass the `@` to the CLI argument, we also need to check that they actually do it, which we currently don't. That said, I prefer if our would not need to pass in the `@` symbol but just `daml.js`.",
        "createdAt" : "2020-03-11T09:48:29Z",
        "updatedAt" : "2020-03-11T09:48:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4df609b2-d005-4d5e-ba0c-cffb59d9e351",
        "parentId" : "c93637e1-dc76-4311-93d6-42c4f0763c31",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4939",
        "createdAt" : "2020-03-11T13:24:43Z",
        "updatedAt" : "2020-03-11T13:24:43Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2cfd59b9df6a3b375874b3c10ce37b23477f8af0",
    "line" : 23,
    "diffHunk" : "@@ -89,13 +90,19 @@ optionsParser = Options\n     <*> strOption\n         (  short 'o'\n         <> metavar \"DIR\"\n-        <> help \"Output directory for the generated TypeScript files\"\n+        <> help \"Output directory for the generated packages\"\n         )\n     <*> optional (strOption\n         (  short 'p'\n         <> metavar \"PACKAGE-JSON\"\n         <> help \"Path to an existing 'package.json' to update\"\n         ))\n+    <*> (Scope <$> strOption\n+        (  short 's'\n+        <> metavar \"SCOPE\"\n+        <> value \"@daml.js\""
  },
  {
    "id" : "b544bbe4-beba-4dda-b561-40cd175828fa",
    "prId" : 4908,
    "comments" : [
      {
        "id" : "e288146b-ba27-4f11-a430-a841e93be7a4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Does anything break if I set `optOutputDir` to something different than the scope? Maybe a good idea to have a testcase for that?",
        "createdAt" : "2020-03-09T19:08:01Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6ff99462-3715-42b2-8458-c111a8a9086b",
        "parentId" : "e288146b-ba27-4f11-a430-a841e93be7a4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "There is no relationship between scope and the output directory. For example, the DAVL unit test defaults the scope to `@daml.js` but the output directory is `daml2ts`.",
        "createdAt" : "2020-03-09T19:17:12Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "faf71746-0dc8-43b8-ab3c-ff8968fbc1c9",
        "parentId" : "e288146b-ba27-4f11-a430-a841e93be7a4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Then maybe this should not be called `scopeDir` given that it’s completely independent of the scope?",
        "createdAt" : "2020-03-09T19:18:40Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3254ba86-00f4-4cfa-b604-60a42c990892",
        "parentId" : "e288146b-ba27-4f11-a430-a841e93be7a4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "well, it's the scope dir in that it's the directory that contains all the packages that are associated with the scope",
        "createdAt" : "2020-03-09T19:28:26Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9397f9a0-0509-4bb9-8008-99a17cbde73d",
        "parentId" : "e288146b-ba27-4f11-a430-a841e93be7a4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i could rename it to say, `leafDir` or `outDir` or something if you think it confusing?",
        "createdAt" : "2020-03-09T19:31:38Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "319e5d0a-566d-4ffe-b1ba-e88cae4ffe80",
        "parentId" : "e288146b-ba27-4f11-a430-a841e93be7a4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe `outBaseName` or something like that?",
        "createdAt" : "2020-03-09T19:34:32Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9056e76d-6369-433f-985c-76ac7c8c7d0d",
        "parentId" : "e288146b-ba27-4f11-a430-a841e93be7a4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok. will do.",
        "createdAt" : "2020-03-09T19:39:13Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2cfd59b9df6a3b375874b3c10ce37b23477f8af0",
    "line" : null,
    "diffHunk" : "@@ -661,22 +661,22 @@ instance ToJSON PackageJson where\n -- Read the provided 'package.json'; transform it to include the\n -- provided workspaces; write it back to disk.\n setupWorkspace :: FilePath -> [(T.Text, [Dependency])] -> FilePath -> IO ()\n-setupWorkspace optOutputDir dependencies file = do\n+setupWorkspace optOuputDir dependencies file = do\n   let (g, nodeFromVertex) = graphFromEdges'\n         (map (\\(a, ds) -> (a, a, map unDependency ds)) dependencies)\n       ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n         -- Topologically order our packages.\n-      scope = scopeOfScopeDir optOutputDir\n-        -- 'scope' we expect to be something like \"daml2ts\".\n-  let ourWorkspaces = map ((unScope scope <> \"/\") <>) ps\n+      scopeDir = T.pack $ takeFileName optOuputDir"
  },
  {
    "id" : "3728f271-fe73-4a65-8e02-1b58ab8a69b7",
    "prId" : 4908,
    "comments" : [
      {
        "id" : "94601ddf-27c5-4e59-b136-ffcf18dcc323",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It looks like this is the root not the leaf. Am I missing something?",
        "createdAt" : "2020-03-09T19:12:28Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a15fabc7-5c10-4e18-a3e2-e55ac1ab465b",
        "parentId" : "94601ddf-27c5-4e59-b136-ffcf18dcc323",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "No it's the leaf. We take the filename of `/some/long/path/to/here` giving 'here'.",
        "createdAt" : "2020-03-09T19:18:04Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d0daf0ca-6bad-4b6d-9083-684425e82ec6",
        "parentId" : "94601ddf-27c5-4e59-b136-ffcf18dcc323",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Wow. Is it really spelled `optOuputDir` in the code? Better fix that :)\r\n",
        "createdAt" : "2020-03-09T19:18:54Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a1bd4071-9635-45e7-88fe-df178b702945",
        "parentId" : "94601ddf-27c5-4e59-b136-ffcf18dcc323",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Fixed.",
        "createdAt" : "2020-03-09T19:20:04Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5cf0527b-8ca2-43fe-ae20-3daaff4c1414",
        "parentId" : "94601ddf-27c5-4e59-b136-ffcf18dcc323",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "oh i see, I misread the code. Thanks for the explanation!",
        "createdAt" : "2020-03-09T19:20:06Z",
        "updatedAt" : "2020-03-09T19:46:36Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2cfd59b9df6a3b375874b3c10ce37b23477f8af0",
    "line" : 92,
    "diffHunk" : "@@ -661,22 +661,22 @@ instance ToJSON PackageJson where\n -- Read the provided 'package.json'; transform it to include the\n -- provided workspaces; write it back to disk.\n setupWorkspace :: FilePath -> [(T.Text, [Dependency])] -> FilePath -> IO ()\n-setupWorkspace optOutputDir dependencies file = do\n+setupWorkspace optOuputDir dependencies file = do\n   let (g, nodeFromVertex) = graphFromEdges'\n         (map (\\(a, ds) -> (a, a, map unDependency ds)) dependencies)\n       ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n         -- Topologically order our packages.\n-      scope = scopeOfScopeDir optOutputDir\n-        -- 'scope' we expect to be something like \"daml2ts\".\n-  let ourWorkspaces = map ((unScope scope <> \"/\") <>) ps\n+      scopeDir = T.pack $ takeFileName optOuputDir\n+        -- The leaf directory of the output directory (e.g. often 'daml2ts')."
  },
  {
    "id" : "bc11bf3f-7a4f-454f-ad2f-d86aee22f592",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "699a91d6-106d-431b-9b34-11fbc94f1785",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`[(T.Text, T.Text)]` doesn’t give much information to the reader. `HashMap NpmPackageName NpmPackageVersion` on the other hand would make it very clear and you can just call `toJSON` on it and throw away `fields`.",
        "createdAt" : "2020-03-07T18:19:28Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -37,6 +38,31 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: [(T.Text, T.Text)]"
  },
  {
    "id" : "23c0e25f-815a-49de-9c99-57d45bee8825",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "f7f8940a-fe9e-4437-81e6-42ff9b8d0567",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This is unrelated to this PR but why would our users want to lint the code generated by `daml2ts`? I would argue that it’s a bug in `daml2ts` if we produce code with lint warnings.",
        "createdAt" : "2020-03-07T18:20:56Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "54da94c8-1898-4fde-be0a-28ce8682f30f",
        "parentId" : "f7f8940a-fe9e-4437-81e6-42ff9b8d0567",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "we think so too and test for that. the presence of this rule is needed for those tests to succeed.",
        "createdAt" : "2020-03-07T21:19:43Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -37,6 +38,31 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: [(T.Text, T.Text)]\n+  , pkgDevDependencies :: [(T.Text, T.Text)]\n+  , pkgScripts :: [(T.Text, T.Text)]\n+  }\n+configConsts :: T.Text -> ConfigConsts\n+configConsts sdkVersion = ConfigConsts\n+  { pkgDependencies =\n+      [ (\"@mojotech/json-type-validation\", \"^3.1.0\")\n+      , (\"@daml/types\", sdkVersion)\n+      ]\n+  , pkgDevDependencies =\n+      [ (\"@typescript-eslint/eslint-plugin\", \"2.11.0\")\n+      , (\"@typescript-eslint/parser\", \"2.11.0\")\n+      , (\"eslint\", \"^6.7.2\")\n+      , (\"typescript\", \"~3.7.3\")\n+      ]\n+  , pkgScripts =\n+    [ (\"build\", \"tsc --build\")\n+    , (\"lint\", \"eslint --ext .ts src/ --max-warnings 0\")"
  },
  {
    "id" : "e604e2d8-2940-4cd9-a691-e89d1acd7fd9",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "fbd54abd-287e-4811-9198-fddcbb7c04e4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "As mentioned above, this can go away if you switch to a hashmap and call `toJSON` on it.",
        "createdAt" : "2020-03-07T18:21:23Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -527,93 +553,84 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+-- List of texts to vector of Json strings.\n+array :: [T.Text] -> Vec.Vector Json.Value\n+array = Vec.fromList . map Json.String\n+\n+-- List of pairs of texts to a hash map of Json strings.\n+fields :: [(T.Text, T.Text)] -> HMS.HashMap T.Text Json.Value"
  },
  {
    "id" : "baa6a270-3122-4fe4-8948-3580e61177c8",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "73ec46c7-51ad-43ae-83b4-bf3698cee1d4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This can also go away, see comments below on the use site.",
        "createdAt" : "2020-03-07T18:21:50Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -527,93 +553,84 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+-- List of texts to vector of Json strings.\n+array :: [T.Text] -> Vec.Vector Json.Value"
  },
  {
    "id" : "464a4476-3c5f-4189-a125-d949dc3415af",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "077da9c2-990e-4b93-86d2-43af1a8d40d6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    tsConfig = Json.object\r\n      [ \"compilerOptions\" Json..= Json.object\r\n          [ \"target\" .= \"es5\"\r\n          , \"lib\" .= [\"dom\", \"es2015\"]\r\n          , \"strict\" .= True\r\n          , \"noUnusedLocals\" .= True\r\n          , \"noImplicitReturns\" .= True\r\n          , \"noFailthroughCasesInSwitch\" .= True\r\n          , \"outDir\" .= \"lib\"\r\n          , \"module\" .= \"commonjs\"\r\n          , \"declaration\" .= True\r\n          , \"sourceMap\" .= True\r\n          ]\r\n        , \"include\" .= [\"src/**/*.ts\"]\r\n      ]\r\n```\r\nAeson provides a bunch of helpers for making this kind of code more convenient, in particular `object` and `.=`.",
        "createdAt" : "2020-03-07T18:29:19Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -527,93 +553,84 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+-- List of texts to vector of Json strings.\n+array :: [T.Text] -> Vec.Vector Json.Value\n+array = Vec.fromList . map Json.String\n+\n+-- List of pairs of texts to a hash map of Json strings.\n+fields :: [(T.Text, T.Text)] -> HMS.HashMap T.Text Json.Value\n+fields fs = HMS.fromList [(a, Json.String b) | (a, b) <- fs]\n+\n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Json.Value\n+    tsConfig = Json.Object $\n+      HMS.fromList [\n+        (\"compilerOptions\", Json.Object(HMS.fromList [\n+           (\"target\", Json.String \"es5\")\n+         , (\"lib\", Json.Array (array [\"dom\", \"es2015\"]))\n+         , (\"strict\", Json.Bool True)\n+         , (\"noUnusedLocals\", Json.Bool True)\n+         , (\"noImplicitReturns\", Json.Bool True)\n+         , (\"noFallthroughCasesInSwitch\", Json.Bool True)\n+         , (\"outDir\", Json.String \"lib\")\n+         , (\"module\", Json.String \"commonjs\")\n+         , (\"declaration\", Json.Bool True)\n+         , (\"sourceMap\", Json.Bool True)]))\n+      , (\"include\", Json.Array (array [\"src/**/*.ts\"]))\n+      ]"
  },
  {
    "id" : "931e4850-9ef2-4408-a7f0-f4888beea0f6",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "8f085724-12e8-467c-9428-6ccad51ed0b2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This should also be using `object` and `.=`.",
        "createdAt" : "2020-03-07T18:29:41Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -527,93 +553,84 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+-- List of texts to vector of Json strings.\n+array :: [T.Text] -> Vec.Vector Json.Value\n+array = Vec.fromList . map Json.String\n+\n+-- List of pairs of texts to a hash map of Json strings.\n+fields :: [(T.Text, T.Text)] -> HMS.HashMap T.Text Json.Value\n+fields fs = HMS.fromList [(a, Json.String b) | (a, b) <- fs]\n+\n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Json.Value\n+    tsConfig = Json.Object $\n+      HMS.fromList [\n+        (\"compilerOptions\", Json.Object(HMS.fromList [\n+           (\"target\", Json.String \"es5\")\n+         , (\"lib\", Json.Array (array [\"dom\", \"es2015\"]))\n+         , (\"strict\", Json.Bool True)\n+         , (\"noUnusedLocals\", Json.Bool True)\n+         , (\"noImplicitReturns\", Json.Bool True)\n+         , (\"noFallthroughCasesInSwitch\", Json.Bool True)\n+         , (\"outDir\", Json.String \"lib\")\n+         , (\"module\", Json.String \"commonjs\")\n+         , (\"declaration\", Json.Bool True)\n+         , (\"sourceMap\", Json.Bool True)]))\n+      , (\"include\", Json.Array (array [\"src/**/*.ts\"]))\n+      ]\n \n writeEsLintConfig :: FilePath -> IO ()\n-writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n-  [ \"{\"\n-  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n-  , \"  \\\"parserOptions\\\": {\"\n-  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n-  , \"  },\"\n-  , \"  \\\"plugins\\\": [\"\n-  , \"    \\\"@typescript-eslint\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"extends\\\": [\"\n-  , \"    \\\"eslint:recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"rules\\\": {\"\n-  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n-  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n-  , \"  }\"\n-  , \"}\"\n-  ]\n+writeEsLintConfig dir =\n+  BSL.writeFile (dir </> \".eslintrc.json\") $ encodePretty esLintConfig\n+  where\n+    esLintConfig :: Json.Value\n+    esLintConfig = Json.Object $ HMS.fromList ["
  },
  {
    "id" : "ce4b10f4-8871-40a3-89a2-bb95a14cd357",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "0cb6bf3d-e1ce-452c-8ecd-6b732efa706c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here.",
        "createdAt" : "2020-03-07T18:29:50Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -527,93 +553,84 @@ writePackageIdTs dir pkgId =\n     T.writeFileUtf8 (dir </> \"packageId.ts\") $ T.unlines\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n+-- List of texts to vector of Json strings.\n+array :: [T.Text] -> Vec.Vector Json.Value\n+array = Vec.fromList . map Json.String\n+\n+-- List of pairs of texts to a hash map of Json strings.\n+fields :: [(T.Text, T.Text)] -> HMS.HashMap T.Text Json.Value\n+fields fs = HMS.fromList [(a, Json.String b) | (a, b) <- fs]\n+\n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Json.Value\n+    tsConfig = Json.Object $\n+      HMS.fromList [\n+        (\"compilerOptions\", Json.Object(HMS.fromList [\n+           (\"target\", Json.String \"es5\")\n+         , (\"lib\", Json.Array (array [\"dom\", \"es2015\"]))\n+         , (\"strict\", Json.Bool True)\n+         , (\"noUnusedLocals\", Json.Bool True)\n+         , (\"noImplicitReturns\", Json.Bool True)\n+         , (\"noFallthroughCasesInSwitch\", Json.Bool True)\n+         , (\"outDir\", Json.String \"lib\")\n+         , (\"module\", Json.String \"commonjs\")\n+         , (\"declaration\", Json.Bool True)\n+         , (\"sourceMap\", Json.Bool True)]))\n+      , (\"include\", Json.Array (array [\"src/**/*.ts\"]))\n+      ]\n \n writeEsLintConfig :: FilePath -> IO ()\n-writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n-  [ \"{\"\n-  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n-  , \"  \\\"parserOptions\\\": {\"\n-  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n-  , \"  },\"\n-  , \"  \\\"plugins\\\": [\"\n-  , \"    \\\"@typescript-eslint\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"extends\\\": [\"\n-  , \"    \\\"eslint:recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"rules\\\": {\"\n-  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n-  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n-  , \"  }\"\n-  , \"}\"\n-  ]\n+writeEsLintConfig dir =\n+  BSL.writeFile (dir </> \".eslintrc.json\") $ encodePretty esLintConfig\n+  where\n+    esLintConfig :: Json.Value\n+    esLintConfig = Json.Object $ HMS.fromList [\n+        (\"parser\", Json.String \"@typescript-eslint/parser\")\n+      , (\"parserOptions\", Json.Object (fields [(\"project\", \"./tsconfig.json\")]))\n+      , (\"plugins\", Json.Array (array [\"@typescript-eslint\"]))\n+      , (\"extends\", Json.Array (array [\n+                  \"eslint:recommended\"\n+                , \"plugin:@typescript-eslint/eslint-recommended\"\n+                , \"plugin:@typescript-eslint/recommended\"\n+                , \"plugin:@typescript-eslint/recommended-requiring-type-checking\"]))\n+      , (\"rules\", Json.Object (fields [\n+                  (\"@typescript-eslint/explicit-function-return-type\", \"off\")\n+                , (\"@typescript-eslint/no-inferrable-types\", \"off\")]))\n+      ]\n \n writePackageJson :: FilePath -> SdkVersion -> Scope -> [Dependency] -> IO ()\n writePackageJson packageDir sdkVersion (Scope scope) depends =\n-  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n-  ([\"{\"\n-   , \"  \\\"private\\\": true,\"\n-   , \"  \\\"name\\\": \\\"\" <> name <> \"\\\",\"\n-   , \"  \\\"version\\\": \\\"\" <> version <> \"\\\",\"\n-   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n-   , \"  \\\"dependencies\\\": {\"\n-   , \"    \\\"@daml/types\\\": \\\"\" <> version <> \"\\\",\"\n-   ] ++ dependencies ++\n-   [ \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\"\n-    , \"  },\"\n-    , \"  \\\"scripts\\\": {\"\n-    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n-    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n-    , \"  },\"\n-    , \"  \\\"devDependencies\\\": {\"\n-    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n-    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n-    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n-    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n-    , \"  }\"\n-    , \"}\"\n-    ])\n+  BSL.writeFile (packageDir </> \"package.json\") $\n+    encodePretty (packageJson name version dependencies)\n   where\n-    version = versionToString sdkVersion\n+    version = versionToText sdkVersion\n     name = packageNameOfPackageDir packageDir\n-    dependencies = [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> version <> \"\\\",\"\n-                   | d <- depends\n-                   , let pkg = \"@\" ++ scope ++ \"/\" ++ T.unpack (undependency d)\n-                   ]\n-\n-    -- From the path to a package like '/path/to/daml2ts/d14e08'\n-    -- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n-    -- of a 'package.json'.\n-    packageNameOfPackageDir :: FilePath -> String\n+    dependencies = [ (pkg, version)\n+       | d <- depends\n+       , let pkg = \"@\" <> scope <> \"/\" <> undependency d\n+       ]\n+    packageNameOfPackageDir :: FilePath -> T.Text\n     packageNameOfPackageDir packageDir = \"@\" <> scope <> \"/\" <> package\n       where\n         scope = unscope $ scopeOfScopeDir (takeDirectory packageDir)\n-        package = takeFileName packageDir\n+        package = T.pack $ takeFileName packageDir\n+\n+    packageJson :: T.Text -> T.Text -> [(T.Text, T.Text)] -> Json.Value\n+    packageJson name version dependencies ="
  },
  {
    "id" : "ac30fc0a-3610-41d8-9621-f14cc5a77078",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "2db33d69-26c4-4284-b5f2-c629d4c53e2f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If we enable the `GeneralizeNewtypeDeriving` language extension, all these instances can be derived. Same below.",
        "createdAt" : "2020-03-09T10:38:58Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a5c6590a-f1c1-4933-aaf4-4f5f32b74771",
        "parentId" : "2db33d69-26c4-4284-b5f2-c629d4c53e2f",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-09T11:00:18Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -37,6 +37,48 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgDevDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgScripts :: HMS.HashMap ScriptAlias Script\n+  }\n+configConsts :: T.Text -> ConfigConsts\n+configConsts sdkVersion = ConfigConsts\n+  { pkgDependencies = HMS.fromList\n+      [ (NpmPackageName \"@mojotech/json-type-validation\", NpmPackageVersion \"^3.1.0\")\n+      , (NpmPackageName \"@daml/types\", NpmPackageVersion sdkVersion)\n+      ]\n+  , pkgDevDependencies = HMS.fromList\n+      [ (NpmPackageName \"@typescript-eslint/eslint-plugin\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"@typescript-eslint/parser\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"eslint\", NpmPackageVersion \"^6.7.2\")\n+      , (NpmPackageName \"typescript\", NpmPackageVersion \"~3.7.3\")\n+      ]\n+  , pkgScripts = HMS.fromList\n+      [ (ScriptAlias \"build\", Script \"tsc --build\")\n+      , (ScriptAlias \"lint\", Script \"eslint --ext .ts src/ --max-warnings 0\")\n+      ]\n+  }\n+newtype NpmPackageName = NpmPackageName {unNpmPackageName :: T.Text} deriving (Eq, Show, Hashable)\n+instance FromJSON NpmPackageName where parseJSON = fmap NpmPackageName . parseJSON\n+instance ToJSON NpmPackageName where toJSON = toJSON . unNpmPackageName\n+instance ToJSONKey NpmPackageName where toJSONKey = ToJSONKeyText unNpmPackageName (text . unNpmPackageName)"
  },
  {
    "id" : "ad289fbf-06af-48ba-9c06-d660a15c8cad",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "084f612b-e8be-404d-9bd5-d64ef0b44765",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This order just feels better:\r\n```suggestion\r\n      , (ScriptAlias \"lint\", Script \"eslint --ext .ts --max-warnings 0 src/\")\r\n```",
        "createdAt" : "2020-03-09T10:39:40Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3f0ddf12-272c-4b58-9e3a-ccbc76ad94b1",
        "parentId" : "084f612b-e8be-404d-9bd5-d64ef0b44765",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-09T11:00:54Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -37,6 +37,48 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgDevDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgScripts :: HMS.HashMap ScriptAlias Script\n+  }\n+configConsts :: T.Text -> ConfigConsts\n+configConsts sdkVersion = ConfigConsts\n+  { pkgDependencies = HMS.fromList\n+      [ (NpmPackageName \"@mojotech/json-type-validation\", NpmPackageVersion \"^3.1.0\")\n+      , (NpmPackageName \"@daml/types\", NpmPackageVersion sdkVersion)\n+      ]\n+  , pkgDevDependencies = HMS.fromList\n+      [ (NpmPackageName \"@typescript-eslint/eslint-plugin\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"@typescript-eslint/parser\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"eslint\", NpmPackageVersion \"^6.7.2\")\n+      , (NpmPackageName \"typescript\", NpmPackageVersion \"~3.7.3\")\n+      ]\n+  , pkgScripts = HMS.fromList\n+      [ (ScriptAlias \"build\", Script \"tsc --build\")\n+      , (ScriptAlias \"lint\", Script \"eslint --ext .ts src/ --max-warnings 0\")"
  },
  {
    "id" : "684503ac-7504-4fc5-a30e-e096f9e26072",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "36701850-8b4d-4fad-87bd-540e65411be3",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You can just throw GND at these, e.g.,\r\n```\r\nnewtype NpmPackageName = NpmPackageName {unNpmPackageName :: T.Text}\r\n  deriving stock (Eq, Show, Hashable)\r\n  deriving newtype (FromJSON, ToJSON, ToJSONKey)\r\n```",
        "createdAt" : "2020-03-09T10:40:10Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e2e86b36-0463-45e4-a92b-8dde129d7019",
        "parentId" : "36701850-8b4d-4fad-87bd-540e65411be3",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-09T11:00:04Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -37,6 +37,48 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgDevDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgScripts :: HMS.HashMap ScriptAlias Script\n+  }\n+configConsts :: T.Text -> ConfigConsts\n+configConsts sdkVersion = ConfigConsts\n+  { pkgDependencies = HMS.fromList\n+      [ (NpmPackageName \"@mojotech/json-type-validation\", NpmPackageVersion \"^3.1.0\")\n+      , (NpmPackageName \"@daml/types\", NpmPackageVersion sdkVersion)\n+      ]\n+  , pkgDevDependencies = HMS.fromList\n+      [ (NpmPackageName \"@typescript-eslint/eslint-plugin\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"@typescript-eslint/parser\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"eslint\", NpmPackageVersion \"^6.7.2\")\n+      , (NpmPackageName \"typescript\", NpmPackageVersion \"~3.7.3\")\n+      ]\n+  , pkgScripts = HMS.fromList\n+      [ (ScriptAlias \"build\", Script \"tsc --build\")\n+      , (ScriptAlias \"lint\", Script \"eslint --ext .ts src/ --max-warnings 0\")\n+      ]\n+  }\n+newtype NpmPackageName = NpmPackageName {unNpmPackageName :: T.Text} deriving (Eq, Show, Hashable)"
  },
  {
    "id" : "1b59bb8b-eba1-4cb1-8744-9a5b428836a1",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "8c6ec768-99c8-4404-aaf5-6fc85de00540",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here",
        "createdAt" : "2020-03-09T10:40:26Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d1af4988-b2cc-4d45-bbfb-4f855a5569b6",
        "parentId" : "8c6ec768-99c8-4404-aaf5-6fc85de00540",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-09T11:00:07Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -37,6 +37,48 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgDevDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgScripts :: HMS.HashMap ScriptAlias Script\n+  }\n+configConsts :: T.Text -> ConfigConsts\n+configConsts sdkVersion = ConfigConsts\n+  { pkgDependencies = HMS.fromList\n+      [ (NpmPackageName \"@mojotech/json-type-validation\", NpmPackageVersion \"^3.1.0\")\n+      , (NpmPackageName \"@daml/types\", NpmPackageVersion sdkVersion)\n+      ]\n+  , pkgDevDependencies = HMS.fromList\n+      [ (NpmPackageName \"@typescript-eslint/eslint-plugin\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"@typescript-eslint/parser\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"eslint\", NpmPackageVersion \"^6.7.2\")\n+      , (NpmPackageName \"typescript\", NpmPackageVersion \"~3.7.3\")\n+      ]\n+  , pkgScripts = HMS.fromList\n+      [ (ScriptAlias \"build\", Script \"tsc --build\")\n+      , (ScriptAlias \"lint\", Script \"eslint --ext .ts src/ --max-warnings 0\")\n+      ]\n+  }\n+newtype NpmPackageName = NpmPackageName {unNpmPackageName :: T.Text} deriving (Eq, Show, Hashable)\n+instance FromJSON NpmPackageName where parseJSON = fmap NpmPackageName . parseJSON\n+instance ToJSON NpmPackageName where toJSON = toJSON . unNpmPackageName\n+instance ToJSONKey NpmPackageName where toJSONKey = ToJSONKeyText unNpmPackageName (text . unNpmPackageName)\n+\n+newtype NpmPackageVersion = NpmPackageVersion {unNpmPackageVersion :: T.Text} deriving (Eq, Show, Hashable)"
  },
  {
    "id" : "d9e66976-d0d1-4ef6-98d5-eb6207b32945",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "d5c4322c-406f-423f-9a54-32362cde6b02",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Alias sounds like it already has a name whereas you are defining the name here. So maybe `ScriptName` would be a better name or `ScriptId`.",
        "createdAt" : "2020-03-09T10:41:38Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c6506147-6eeb-4c8c-bbf6-6ad27f0733e1",
        "parentId" : "d5c4322c-406f-423f-9a54-32362cde6b02",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-09T11:00:11Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -37,6 +37,48 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgDevDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgScripts :: HMS.HashMap ScriptAlias Script\n+  }\n+configConsts :: T.Text -> ConfigConsts\n+configConsts sdkVersion = ConfigConsts\n+  { pkgDependencies = HMS.fromList\n+      [ (NpmPackageName \"@mojotech/json-type-validation\", NpmPackageVersion \"^3.1.0\")\n+      , (NpmPackageName \"@daml/types\", NpmPackageVersion sdkVersion)\n+      ]\n+  , pkgDevDependencies = HMS.fromList\n+      [ (NpmPackageName \"@typescript-eslint/eslint-plugin\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"@typescript-eslint/parser\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"eslint\", NpmPackageVersion \"^6.7.2\")\n+      , (NpmPackageName \"typescript\", NpmPackageVersion \"~3.7.3\")\n+      ]\n+  , pkgScripts = HMS.fromList\n+      [ (ScriptAlias \"build\", Script \"tsc --build\")\n+      , (ScriptAlias \"lint\", Script \"eslint --ext .ts src/ --max-warnings 0\")\n+      ]\n+  }\n+newtype NpmPackageName = NpmPackageName {unNpmPackageName :: T.Text} deriving (Eq, Show, Hashable)\n+instance FromJSON NpmPackageName where parseJSON = fmap NpmPackageName . parseJSON\n+instance ToJSON NpmPackageName where toJSON = toJSON . unNpmPackageName\n+instance ToJSONKey NpmPackageName where toJSONKey = ToJSONKeyText unNpmPackageName (text . unNpmPackageName)\n+\n+newtype NpmPackageVersion = NpmPackageVersion {unNpmPackageVersion :: T.Text} deriving (Eq, Show, Hashable)\n+instance FromJSON NpmPackageVersion where parseJSON = fmap NpmPackageVersion . parseJSON\n+instance ToJSON NpmPackageVersion where toJSON = toJSON . unNpmPackageVersion\n+\n+newtype ScriptAlias = ScriptAlias {unScriptAlias :: T.Text} deriving (Eq, Show, Hashable)"
  },
  {
    "id" : "82ea5c17-f315-4dab-a879-619118a1c9cd",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "56d266d8-a476-4976-b51d-51ac492acb85",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "For the sake of consistency:\r\n```suggestion\r\n        , \"sourceMap\" .= True\r\n        ]\r\n```",
        "createdAt" : "2020-03-09T10:41:58Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "69e9bcc3-5e20-4a79-bf89-1befa1c0d8e4",
        "parentId" : "56d266d8-a476-4976-b51d-51ac492acb85",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-09T11:01:20Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -528,92 +570,74 @@ writePackageIdTs dir pkgId =\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Value\n+    tsConfig = object\n+      [ \"compilerOptions\" .= object\n+        [ \"target\" .= (\"es5\" :: T.Text)\n+        , \"lib\" .= ([\"dom\", \"es2015\"] :: [T.Text])\n+        , \"strict\" .= True\n+        , \"noUnusedLocals\" .= True\n+        , \"noImplicitReturns\" .= True\n+        , \"noFallthroughCasesInSwitch\" .= True\n+        , \"outDir\" .= (\"lib\" :: T.Text)\n+        , \"module\" .= (\"commonjs\" :: T.Text)\n+        , \"declaration\" .= True\n+        , \"sourceMap\" .= True ]"
  },
  {
    "id" : "50d0e214-7cba-4970-965a-026c8741cb6a",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "9f4888d2-8a07-4c8c-b927-1543dbeafdf3",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we really need to mark this a `T.Text`? Isn't `\"es5\"` just fine? That will give us a `String` and the right thing.\r\n```suggestion\r\n        [ \"target\" .= \"es5\"\r\n```\r\nSame in many places below.",
        "createdAt" : "2020-03-09T10:43:27Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "944a610b-3edb-4988-8ef9-1e932af1e5c6",
        "parentId" : "9f4888d2-8a07-4c8c-b927-1543dbeafdf3",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "It really needs to be marked as Text.",
        "createdAt" : "2020-03-09T11:01:56Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "24d73ebf-f801-44ff-9d96-79e661aa6f98",
        "parentId" : "9f4888d2-8a07-4c8c-b927-1543dbeafdf3",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Ah right, because we have `OverloadedStrings` turned on to be able to get `Text` literals. 😦",
        "createdAt" : "2020-03-09T12:02:30Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : 126,
    "diffHunk" : "@@ -528,92 +570,74 @@ writePackageIdTs dir pkgId =\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Value\n+    tsConfig = object\n+      [ \"compilerOptions\" .= object\n+        [ \"target\" .= (\"es5\" :: T.Text)"
  },
  {
    "id" : "d5c58696-247f-4f36-a205-e342cec95795",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "ed727edb-cd84-4012-8ee2-866e511ffdbd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There's no need for a type annotation since the function is completely monomorphic.\r\n```suggestion\r\n    version = versionToText sdkVersion\r\n```",
        "createdAt" : "2020-03-09T10:45:07Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1500794c-638e-4816-8b36-126a2ebfd633",
        "parentId" : "ed727edb-cd84-4012-8ee2-866e511ffdbd",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "must have been left over from debugging",
        "createdAt" : "2020-03-09T11:03:00Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -528,92 +570,74 @@ writePackageIdTs dir pkgId =\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Value\n+    tsConfig = object\n+      [ \"compilerOptions\" .= object\n+        [ \"target\" .= (\"es5\" :: T.Text)\n+        , \"lib\" .= ([\"dom\", \"es2015\"] :: [T.Text])\n+        , \"strict\" .= True\n+        , \"noUnusedLocals\" .= True\n+        , \"noImplicitReturns\" .= True\n+        , \"noFallthroughCasesInSwitch\" .= True\n+        , \"outDir\" .= (\"lib\" :: T.Text)\n+        , \"module\" .= (\"commonjs\" :: T.Text)\n+        , \"declaration\" .= True\n+        , \"sourceMap\" .= True ]\n+      , \"include\" .= ([\"src/**/*.ts\"] :: [T.Text])\n+      ]\n \n writeEsLintConfig :: FilePath -> IO ()\n-writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n-  [ \"{\"\n-  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n-  , \"  \\\"parserOptions\\\": {\"\n-  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n-  , \"  },\"\n-  , \"  \\\"plugins\\\": [\"\n-  , \"    \\\"@typescript-eslint\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"extends\\\": [\"\n-  , \"    \\\"eslint:recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"rules\\\": {\"\n-  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n-  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n-  , \"  }\"\n-  , \"}\"\n-  ]\n+writeEsLintConfig dir =\n+  BSL.writeFile (dir </> \".eslintrc.json\") $ encodePretty esLintConfig\n+  where\n+    esLintConfig :: Value\n+    esLintConfig = object [\n+        \"parser\" .= (\"@typescript-eslint/parser\" :: T.Text)\n+      , \"parserOptions\" .= object [(\"project\", \"./tsconfig.json\")]\n+      , \"plugins\" .= ([\"@typescript-eslint\"] :: [T.Text])\n+      , \"extends\" .= ([\n+             \"eslint:recommended\"\n+           , \"plugin:@typescript-eslint/eslint-recommended\"\n+           , \"plugin:@typescript-eslint/recommended\"\n+           , \"plugin:@typescript-eslint/recommended-requiring-type-checking\"\n+           ] :: [T.Text])\n+      , \"rules\" .= object [\n+            (\"@typescript-eslint/explicit-function-return-type\", \"off\")\n+          , (\"@typescript-eslint/no-inferrable-types\", \"off\") ]\n+      ]\n \n writePackageJson :: FilePath -> SdkVersion -> Scope -> [Dependency] -> IO ()\n writePackageJson packageDir sdkVersion (Scope scope) depends =\n-  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n-  ([\"{\"\n-   , \"  \\\"private\\\": true,\"\n-   , \"  \\\"name\\\": \\\"\" <> name <> \"\\\",\"\n-   , \"  \\\"version\\\": \\\"\" <> version <> \"\\\",\"\n-   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n-   , \"  \\\"dependencies\\\": {\"\n-   , \"    \\\"@daml/types\\\": \\\"\" <> version <> \"\\\",\"\n-   ] ++ dependencies ++\n-   [ \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\"\n-    , \"  },\"\n-    , \"  \\\"scripts\\\": {\"\n-    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n-    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n-    , \"  },\"\n-    , \"  \\\"devDependencies\\\": {\"\n-    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n-    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n-    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n-    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n-    , \"  }\"\n-    , \"}\"\n-    ])\n+  BSL.writeFile (packageDir </> \"package.json\") $\n+    encodePretty (packageJson (NpmPackageName name) (NpmPackageVersion version) dependencies)\n   where\n-    version = versionToString sdkVersion\n+    version = versionToText sdkVersion :: T.Text"
  },
  {
    "id" : "66f73ae6-47f3-47bd-9003-1cb51504d8a1",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "1daf0fe7-d5a5-4386-bc3d-6f55ebefc2f4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not convinced that newtyping around record fields is really necessary.",
        "createdAt" : "2020-03-09T10:46:58Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7d1b0bc1-8f7e-457b-830e-dafc246ea72d",
        "parentId" : "1daf0fe7-d5a5-4386-bc3d-6f55ebefc2f4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i undid this one.",
        "createdAt" : "2020-03-09T11:03:09Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -625,8 +649,9 @@ writePackageJson packageDir sdkVersion (Scope scope) depends =\n --   ],\n --   ... perhaps other stuff ...\n -- }\n+\n data PackageJson = PackageJson\n-  { workspaces :: [T.Text]\n+  { workspaces :: [Workspace]"
  },
  {
    "id" : "27da0c34-d45e-4474-9f06-e80fec438ce5",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "b4a28451-5646-45a1-be88-47f5d15a02fc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The idiomatic Haskell style with leading commas also puts the bracket at the beginning of the line.\r\n```suggestion\r\n    packageJson name version@(NpmPackageVersion sdkVersion) dependencies = object\r\n      [ \"private\" .= True\r\n```\r\nIf you want the bracket at the end of the previous lines, then it's more like\r\n```haskell\r\nfoo = [\r\n  bar,\r\n  baz\r\n]\r\n```",
        "createdAt" : "2020-03-09T10:50:40Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f0c3e89e-6b62-4450-8713-ba5b3304daed",
        "parentId" : "b4a28451-5646-45a1-be88-47f5d15a02fc",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-03-09T11:04:23Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -528,92 +570,74 @@ writePackageIdTs dir pkgId =\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Value\n+    tsConfig = object\n+      [ \"compilerOptions\" .= object\n+        [ \"target\" .= (\"es5\" :: T.Text)\n+        , \"lib\" .= ([\"dom\", \"es2015\"] :: [T.Text])\n+        , \"strict\" .= True\n+        , \"noUnusedLocals\" .= True\n+        , \"noImplicitReturns\" .= True\n+        , \"noFallthroughCasesInSwitch\" .= True\n+        , \"outDir\" .= (\"lib\" :: T.Text)\n+        , \"module\" .= (\"commonjs\" :: T.Text)\n+        , \"declaration\" .= True\n+        , \"sourceMap\" .= True ]\n+      , \"include\" .= ([\"src/**/*.ts\"] :: [T.Text])\n+      ]\n \n writeEsLintConfig :: FilePath -> IO ()\n-writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n-  [ \"{\"\n-  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n-  , \"  \\\"parserOptions\\\": {\"\n-  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n-  , \"  },\"\n-  , \"  \\\"plugins\\\": [\"\n-  , \"    \\\"@typescript-eslint\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"extends\\\": [\"\n-  , \"    \\\"eslint:recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n-  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n-  , \"  ],\"\n-  , \"  \\\"rules\\\": {\"\n-  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n-  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n-  , \"  }\"\n-  , \"}\"\n-  ]\n+writeEsLintConfig dir =\n+  BSL.writeFile (dir </> \".eslintrc.json\") $ encodePretty esLintConfig\n+  where\n+    esLintConfig :: Value\n+    esLintConfig = object [\n+        \"parser\" .= (\"@typescript-eslint/parser\" :: T.Text)\n+      , \"parserOptions\" .= object [(\"project\", \"./tsconfig.json\")]\n+      , \"plugins\" .= ([\"@typescript-eslint\"] :: [T.Text])\n+      , \"extends\" .= ([\n+             \"eslint:recommended\"\n+           , \"plugin:@typescript-eslint/eslint-recommended\"\n+           , \"plugin:@typescript-eslint/recommended\"\n+           , \"plugin:@typescript-eslint/recommended-requiring-type-checking\"\n+           ] :: [T.Text])\n+      , \"rules\" .= object [\n+            (\"@typescript-eslint/explicit-function-return-type\", \"off\")\n+          , (\"@typescript-eslint/no-inferrable-types\", \"off\") ]\n+      ]\n \n writePackageJson :: FilePath -> SdkVersion -> Scope -> [Dependency] -> IO ()\n writePackageJson packageDir sdkVersion (Scope scope) depends =\n-  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n-  ([\"{\"\n-   , \"  \\\"private\\\": true,\"\n-   , \"  \\\"name\\\": \\\"\" <> name <> \"\\\",\"\n-   , \"  \\\"version\\\": \\\"\" <> version <> \"\\\",\"\n-   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n-   , \"  \\\"dependencies\\\": {\"\n-   , \"    \\\"@daml/types\\\": \\\"\" <> version <> \"\\\",\"\n-   ] ++ dependencies ++\n-   [ \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\"\n-    , \"  },\"\n-    , \"  \\\"scripts\\\": {\"\n-    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n-    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n-    , \"  },\"\n-    , \"  \\\"devDependencies\\\": {\"\n-    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n-    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n-    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n-    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n-    , \"  }\"\n-    , \"}\"\n-    ])\n+  BSL.writeFile (packageDir </> \"package.json\") $\n+    encodePretty (packageJson (NpmPackageName name) (NpmPackageVersion version) dependencies)\n   where\n-    version = versionToString sdkVersion\n+    version = versionToText sdkVersion :: T.Text\n     name = packageNameOfPackageDir packageDir\n-    dependencies = [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> version <> \"\\\",\"\n-                   | d <- depends\n-                   , let pkg = \"@\" ++ scope ++ \"/\" ++ T.unpack (undependency d)\n-                   ]\n-\n-    -- From the path to a package like '/path/to/daml2ts/d14e08'\n-    -- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n-    -- of a 'package.json'.\n-    packageNameOfPackageDir :: FilePath -> String\n+    dependencies = HMS.fromList [ (NpmPackageName pkg, NpmPackageVersion version)\n+       | d <- depends\n+       , let pkg = \"@\" <> scope <> \"/\" <> unDependency d\n+       ]\n+    packageNameOfPackageDir :: FilePath -> T.Text\n     packageNameOfPackageDir packageDir = \"@\" <> scope <> \"/\" <> package\n       where\n-        scope = unscope $ scopeOfScopeDir (takeDirectory packageDir)\n-        package = takeFileName packageDir\n+        scope = unScope $ scopeOfScopeDir (takeDirectory packageDir)\n+        package = T.pack $ takeFileName packageDir\n+\n+    packageJson :: NpmPackageName -> NpmPackageVersion -> HMS.HashMap NpmPackageName NpmPackageVersion -> Value\n+    packageJson name version@(NpmPackageVersion sdkVersion) dependencies = object [\n+        \"private\" .= True"
  },
  {
    "id" : "a3c114b8-4809-4d23-b4ec-a9191e22c8ef",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "a48a94a8-4ddf-40e5-b036-c00ce2554781",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Phantom type parameters will produce unused locals. That's why it was `false` before.\r\n```suggestion\r\n        , \"noUnusedLocals\" .= False\r\n```",
        "createdAt" : "2020-03-09T10:52:00Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dc06871e-c3c3-414a-8a55-9c416436618c",
        "parentId" : "a48a94a8-4ddf-40e5-b036-c00ce2554781",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "genuine bug.",
        "createdAt" : "2020-03-09T11:04:49Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -528,92 +570,74 @@ writePackageIdTs dir pkgId =\n       [\"export default '\" <> unPackageId pkgId <> \"';\"]\n \n writeTsConfig :: FilePath -> IO ()\n-writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n-    [ \"{\"\n-    , \"  \\\"compilerOptions\\\": {\"\n-    , \"    \\\"target\\\": \\\"es5\\\",\"\n-    , \"    \\\"lib\\\": [\"\n-    , \"      \\\"dom\\\",\"\n-    , \"      \\\"es2015\\\"\"\n-    , \"     ],\"\n-    , \"    \\\"strict\\\": true,\"\n-    , \"    \\\"noUnusedLocals\\\": true,\"\n-    , \"    \\\"noUnusedParameters\\\": false,\"\n-    , \"    \\\"noImplicitReturns\\\": true,\"\n-    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n-    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n-    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n-    , \"    \\\"declaration\\\": true,\"\n-    , \"    \\\"sourceMap\\\": true\"\n-    , \"  },\"\n-    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n-    , \"}\"\n-    ]\n+writeTsConfig dir =\n+  BSL.writeFile (dir </> \"tsconfig.json\") $ encodePretty tsConfig\n+  where\n+    tsConfig :: Value\n+    tsConfig = object\n+      [ \"compilerOptions\" .= object\n+        [ \"target\" .= (\"es5\" :: T.Text)\n+        , \"lib\" .= ([\"dom\", \"es2015\"] :: [T.Text])\n+        , \"strict\" .= True\n+        , \"noUnusedLocals\" .= True"
  },
  {
    "id" : "3f61b7aa-0656-4321-89c4-1d256baae1d2",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "b5b388ae-877b-43f5-832d-c8e781cbb826",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Good idea to make it explicit! Very fancy though. 😃\r\n\r\n",
        "createdAt" : "2020-03-09T11:54:56Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : 54,
    "diffHunk" : "@@ -37,6 +37,43 @@ import DA.Daml.Project.Consts\n import DA.Daml.Project.Types\n import qualified DA.Daml.Project.Types as DATypes\n \n+-- Referenced from 'writePackageJson'. Lifted here for easy\n+-- maintenance.\n+data ConfigConsts = ConfigConsts\n+  { pkgDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgDevDependencies :: HMS.HashMap NpmPackageName NpmPackageVersion\n+  , pkgScripts :: HMS.HashMap ScriptName Script\n+  }\n+configConsts :: T.Text -> ConfigConsts\n+configConsts sdkVersion = ConfigConsts\n+  { pkgDependencies = HMS.fromList\n+      [ (NpmPackageName \"@mojotech/json-type-validation\", NpmPackageVersion \"^3.1.0\")\n+      , (NpmPackageName \"@daml/types\", NpmPackageVersion sdkVersion)\n+      ]\n+  , pkgDevDependencies = HMS.fromList\n+      [ (NpmPackageName \"@typescript-eslint/eslint-plugin\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"@typescript-eslint/parser\", NpmPackageVersion \"2.11.0\")\n+      , (NpmPackageName \"eslint\", NpmPackageVersion \"^6.7.2\")\n+      , (NpmPackageName \"typescript\", NpmPackageVersion \"~3.7.3\")\n+      ]\n+  , pkgScripts = HMS.fromList\n+      [ (ScriptName \"build\", Script \"tsc --build\")\n+      , (ScriptName \"lint\", Script \"eslint --ext .ts --max-warnings 0 src/\")\n+      ]\n+  }\n+newtype NpmPackageName = NpmPackageName {unNpmPackageName :: T.Text}\n+  deriving stock (Eq, Show)\n+  deriving newtype (Hashable, FromJSON, ToJSON, ToJSONKey)"
  },
  {
    "id" : "6ec8519d-dc2e-4742-8834-187f531daaa6",
    "prId" : 4887,
    "comments" : [
      {
        "id" : "e9319279-9aea-46d8-8e74-0d86c3da8754",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This is not necessary anymore.",
        "createdAt" : "2020-03-09T12:03:46Z",
        "updatedAt" : "2020-03-09T12:13:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "671273b87d011dd24ccc205355b414e47eec088f",
    "line" : null,
    "diffHunk" : "@@ -635,29 +656,29 @@ instance FromJSON PackageJson where\n       <*> pure (HMS.delete \"workspaces\" v)\n   parseJSON _ = mzero\n instance ToJSON PackageJson where\n-  toJSON PackageJson{..} = Object (HMS.insert \"workspaces\" (toJSON workspaces) otherFields)\n+  toJSON PackageJson{..} = toJSON (HMS.insert \"workspaces\" (toJSON workspaces) otherFields)"
  },
  {
    "id" : "7c79873c-9b86-4b16-a1fa-80630a572c6f",
    "prId" : 4859,
    "comments" : [
      {
        "id" : "37431b6e-9a34-493f-9b9c-b5d3d76b46fa",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What happened here? 😉 ",
        "createdAt" : "2020-03-05T22:03:36Z",
        "updatedAt" : "2020-03-05T22:22:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bfe13fbc-2f74-488e-b5cf-e185702a779c",
        "parentId" : "37431b6e-9a34-493f-9b9c-b5d3d76b46fa",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I will fix it. At this point it's just pure desperation due to a broken Windows cache. I haven't been able to overcome it and I'm ready to give up.",
        "createdAt" : "2020-03-05T22:15:24Z",
        "updatedAt" : "2020-03-05T22:22:05Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fba981b3-eb96-4223-b541-408125014ee5",
        "parentId" : "37431b6e-9a34-493f-9b9c-b5d3d76b46fa",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I've fixed the blank lines and it looks like 🤞, after yet another *k* runs I might finally get a Windows build through.",
        "createdAt" : "2020-03-05T22:44:47Z",
        "updatedAt" : "2020-03-05T22:44:47Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "80811b66d63d994e2c5e722c9d353baac1a267e3",
    "line" : null,
    "diffHunk" : "@@ -107,6 +107,8 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+\n+"
  },
  {
    "id" : "b70b410f-a9bf-479c-9d5c-e84f2e6ffee3",
    "prId" : 4858,
    "comments" : [
      {
        "id" : "cfa1efae-9f41-4fdb-86c0-1509a1671be4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't understand why returning this text here is better than what we had before. Could you please shed some light on this?",
        "createdAt" : "2020-03-05T22:08:20Z",
        "updatedAt" : "2020-03-05T22:21:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4a7edd95-5441-4023-9d33-84c86fd48625",
        "parentId" : "cfa1efae-9f41-4fdb-86c0-1509a1671be4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I'm struggling now to find the reference (update : https://github.com/digital-asset/daml/pull/4818#discussion_r388146306) but at the end of the day it is so that we can write this:\r\n```\r\n  let (g, nodeFromVertex) = graphFromEdges'\r\n        (map (\\(a, ds) -> (a, a, map undependency ds)) dependencies)\r\n```\r\nIn that call to `graphFromEdges'` either everything needs to be strings or everything needs to be `Text`. Switching to `Text` makes sense because dependencies are naturally text:\r\n```\r\n        depends = [ Dependency $ pkgRefStr pkgMap pkgRef\r\n                  | (pkgRef, _) <- modRefs refs, pkgRef /= PRSelf ]\r\n```\r\nPackage names are naturally text:\r\n```\r\npackageNameText :: PackageId -> Maybe PackageName -> T.Text\r\npackageNameText pkgId mbPkgIdent = maybe (unPackageId pkgId) unPackageName mbPkgIdent\r\n```\r\nSo with this formulation there are no calls to `T.pack`, `T.unpack`.",
        "createdAt" : "2020-03-05T22:13:56Z",
        "updatedAt" : "2020-03-05T22:27:51Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4c3565a1-52e7-4222-b751-0e887c4b7c35",
        "parentId" : "cfa1efae-9f41-4fdb-86c0-1509a1671be4",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What I meant is that before this change we computed the value of the `pkgName` we're returning hat at the call site of `daml2ts`, i.e., in line 126 above. Now, we compute it twice, there and in the `where` clause below.",
        "createdAt" : "2020-03-06T09:32:48Z",
        "updatedAt" : "2020-03-06T09:32:53Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "473fedd7-0f33-4b06-a900-c7d9acf783db",
        "parentId" : "cfa1efae-9f41-4fdb-86c0-1509a1671be4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Oh I see. Yes you are right. Well spotted. I'll eliminate the redundancy.",
        "createdAt" : "2020-03-06T11:29:49Z",
        "updatedAt" : "2020-03-06T11:29:50Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec2e540da0e90de0063b280ce57f1a4a794bf3a9",
    "line" : 15,
    "diffHunk" : "@@ -152,12 +152,12 @@ data Daml2TsParams = Daml2TsParams\n   }\n \n -- Write the files for a single package.\n-daml2ts :: Daml2TsParams -> IO [Dependency]\n+daml2ts :: Daml2TsParams -> IO (T.Text, [Dependency])"
  },
  {
    "id" : "3d6b5f65-911e-4675-bccc-ccb08f41ef32",
    "prId" : 4852,
    "comments" : [
      {
        "id" : "a6fc674e-a0e6-4341-94ae-6a0fcacfa4b2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "maybe just call this `packageMap`? `pm` seems a bit too generic and having worked with LLVM, I always things of `PassManager`.",
        "createdAt" : "2020-03-05T16:08:20Z",
        "updatedAt" : "2020-03-05T16:30:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4e970ce1-2ab7-48b9-a0e8-92396871a682",
        "parentId" : "a6fc674e-a0e6-4341-94ae-6a0fcacfa4b2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Going with `pkgMap` (consistency with other parameters).",
        "createdAt" : "2020-03-05T16:24:43Z",
        "updatedAt" : "2020-03-05T16:30:52Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1af3f577028e08b742a81ae3abbd42d04f4f41b3",
    "line" : null,
    "diffHunk" : "@@ -130,18 +130,28 @@ packageNameText pkgId mbPkgIdent = maybe (unPackageId pkgId) unPackageName mbPkg\n \n newtype Scope = Scope {unscope :: String}\n newtype Dependency = Dependency {undependency :: T.Text}  deriving (Eq, Ord)\n+newtype SdkVersion = SdkVersion String\n \n -- Gives the scope 'foo' given a directory path like '/path/to/foo'.\n -- The scope 'foo' is the '@foo' part of a package name in an import\n -- declaration.\n scopeOfScopeDir :: FilePath -> Scope\n scopeOfScopeDir = Scope . takeFileName\n \n+data Daml2TsParams = Daml2TsParams\n+  { opts :: Options  -- cli args\n+  , pm :: Map.Map PackageId (Maybe PackageName, Package)"
  },
  {
    "id" : "7940fddc-6157-4a13-9128-496e679f95a7",
    "prId" : 4852,
    "comments" : [
      {
        "id" : "e6fc46a7-31de-4855-9336-9dc2ed8de51c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "No need to introduce your own newtype, you can use `DA.Daml.Project.Types.SdkVersion`.",
        "createdAt" : "2020-03-05T16:08:48Z",
        "updatedAt" : "2020-03-05T16:30:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ab0102d1-ad05-447b-a3df-5372571ebca9",
        "parentId" : "e6fc46a7-31de-4855-9336-9dc2ed8de51c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok!",
        "createdAt" : "2020-03-05T16:10:06Z",
        "updatedAt" : "2020-03-05T16:30:52Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1af3f577028e08b742a81ae3abbd42d04f4f41b3",
    "line" : null,
    "diffHunk" : "@@ -130,18 +130,28 @@ packageNameText pkgId mbPkgIdent = maybe (unPackageId pkgId) unPackageName mbPkg\n \n newtype Scope = Scope {unscope :: String}\n newtype Dependency = Dependency {undependency :: T.Text}  deriving (Eq, Ord)\n+newtype SdkVersion = SdkVersion String"
  },
  {
    "id" : "d64d1dee-36ab-4238-812f-0cc12eb8f33e",
    "prId" : 4852,
    "comments" : [
      {
        "id" : "1d3e38c6-fc43-4ff8-a5fe-4cb7f88fb2eb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    sdkVersionOrErr <- DATypes.parseVersion . T.pack . fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\r\n```\r\nI find the name `version` bit too generic given that its pretty much the same as `sdkVersion` below.",
        "createdAt" : "2020-03-05T22:13:35Z",
        "updatedAt" : "2020-03-05T22:14:11Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "1cc74e3e-8778-4fae-b83f-3ae080566332",
        "parentId" : "1d3e38c6-fc43-4ff8-a5fe-4cb7f88fb2eb",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4861",
        "createdAt" : "2020-03-06T01:16:50Z",
        "updatedAt" : "2020-03-06T01:16:51Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1af3f577028e08b742a81ae3abbd42d04f4f41b3",
    "line" : 16,
    "diffHunk" : "@@ -109,19 +111,22 @@ mergePackageMap ps = foldM merge Map.empty ps\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n-    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n-    ps <- readPackages optInputDars\n-    case mergePackageMap ps of\n+    version <- DATypes.parseVersion . T.pack . fromMaybe \"0.0.0\" <$> getSdkVersionMaybe"
  },
  {
    "id" : "130be00b-32a3-4819-a5f1-3c3b7a33f119",
    "prId" : 4818,
    "comments" : [
      {
        "id" : "37c86619-7e11-4f88-9ac8-b8af75c86f5e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nimport qualified Data.Text.IO as T\r\n```",
        "createdAt" : "2020-03-05T08:38:13Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "56b09059-c868-4623-90c1-58228b834c28",
        "parentId" : "37c86619-7e11-4f88-9ac8-b8af75c86f5e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-03-05T11:42:14Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "00d45cb44007659545cda3a4ccf31a12b4c88fbe",
    "line" : null,
    "diffHunk" : "@@ -13,6 +13,7 @@ import qualified Data.NameMap as NM\n import qualified Data.Set as Set\n import qualified Data.Set.Lens as Set\n import qualified Data.Text.Extended as T\n+import qualified Data.Text.IO"
  },
  {
    "id" : "45530865-8985-4b06-ad7e-1045039da483",
    "prId" : 4818,
    "comments" : [
      {
        "id" : "2a936d89-e403-49ea-9b12-7428722ac8e2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                 T.putStrLn $ \"Generating \" <> id <> \" as \" <> asName\r\n```",
        "createdAt" : "2020-03-05T08:38:38Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "82c8c45e-00fc-46d3-9054-0044a9cf2e3e",
        "parentId" : "2a936d89-e403-49ea-9b12-7428722ac8e2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-03-05T11:42:01Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "00d45cb44007659545cda3a4ccf31a12b4c88fbe",
    "line" : null,
    "diffHunk" : "@@ -129,49 +130,39 @@ main = do\n         dependencies <-\n           forM (Map.toList pm) $\n             \\(pkgId, (mbPkgName, pkg)) -> do\n-                 let id = T.unpack $ unPackageId pkgId\n-                     name = packageNameStr pkgId mbPkgName\n+                 let id = unPackageId pkgId\n+                     name = packageNameText pkgId mbPkgName\n                      asName = if name == id then \"itself\" else name\n-                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 Data.Text.IO.putStrLn $ \"Generating \" <> id <> \" as \" <> asName"
  },
  {
    "id" : "f1a6770a-0076-480b-a718-c1322d44e10a",
    "prId" : 4818,
    "comments" : [
      {
        "id" : "dd5b43ac-8c94-406c-97b9-d653d72e691a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I found it easier to understand with the leading `@`. Here and below.",
        "createdAt" : "2020-03-05T08:40:08Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "158e05be-668e-4d03-8011-1c6f62ea7f2d",
        "parentId" : "dd5b43ac-8c94-406c-97b9-d653d72e691a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I like it too but understand why the presence of `fromJust . stripPrefix` causes a maintainer to be concerned.",
        "createdAt" : "2020-03-05T11:41:48Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c5e3564d-a0a7-4f41-b62a-08dd288b851d",
        "parentId" : "dd5b43ac-8c94-406c-97b9-d653d72e691a",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That makes sense. Thanks for the explanation.\r\n\r\nIt could help if the comment explained very briefly that the scope `foo` is the `@foo` in a package name.",
        "createdAt" : "2020-03-05T12:15:03Z",
        "updatedAt" : "2020-03-05T12:15:03Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c34a9289-dc50-404e-9f2d-1010c2005708",
        "parentId" : "dd5b43ac-8c94-406c-97b9-d653d72e691a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-03-05T14:01:16Z",
        "updatedAt" : "2020-03-05T14:01:16Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a48eac2a-4a6e-4bb6-9064-9e4cf63f044e",
        "parentId" : "dd5b43ac-8c94-406c-97b9-d653d72e691a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "This comment is going into https://github.com/digital-asset/daml/pull/4837. When `scope` becomes a command line argument, I'll be sure to move the comment along with it.",
        "createdAt" : "2020-03-05T14:04:16Z",
        "updatedAt" : "2020-03-05T14:04:17Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "20bd37bb-0c0f-4d74-af04-540c1129bed5",
        "parentId" : "dd5b43ac-8c94-406c-97b9-d653d72e691a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "This went back to the way we want it in https://github.com/digital-asset/daml/pull/4908 (making scope an optional command line argument).",
        "createdAt" : "2020-03-09T16:08:34Z",
        "updatedAt" : "2020-03-09T16:08:35Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "00d45cb44007659545cda3a4ccf31a12b4c88fbe",
    "line" : 35,
    "diffHunk" : "@@ -129,49 +130,39 @@ main = do\n         dependencies <-\n           forM (Map.toList pm) $\n             \\(pkgId, (mbPkgName, pkg)) -> do\n-                 let id = T.unpack $ unPackageId pkgId\n-                     name = packageNameStr pkgId mbPkgName\n+                 let id = unPackageId pkgId\n+                     name = packageNameText pkgId mbPkgName\n                      asName = if name == id then \"itself\" else name\n-                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 Data.Text.IO.putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n                  deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n                  pure (name, name, deps)\n         whenJust optInputPackageJson $\n           writeTopLevelPackageJson optOutputDir dependencies\n \n-packageNameStr :: PackageId -> Maybe PackageName -> String\n-packageNameStr pkgId mbPkgIdent =\n-  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n+packageNameText :: PackageId -> Maybe PackageName -> T.Text\n+packageNameText pkgId mbPkgIdent = maybe (unPackageId pkgId) unPackageName mbPkgIdent\n \n newtype Scope = Scope {unscope :: String}\n newtype Dependency = Dependency {undependency :: String}  deriving (Eq, Ord)\n \n--- Gives the scope '@foo' given a directory path like '/path/to/foo'.\n+-- Gives the scope 'foo' given a directory path like '/path/to/foo'."
  },
  {
    "id" : "271bd539-1562-40aa-b237-71de50595253",
    "prId" : 4818,
    "comments" : [
      {
        "id" : "fcf18937-068a-4fcf-a6cf-b68d754451d6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why do we need to unpack here? Can't the vertex names also be `Text`s?",
        "createdAt" : "2020-03-05T08:41:48Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f30ac7d1-9370-4f5e-8435-5a247f674110",
        "parentId" : "fcf18937-068a-4fcf-a6cf-b68d754451d6",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yes!  So, changing this\r\n```\r\nnewtype Dependency = Dependency {undependency :: T.Text}  deriving (Eq, Ord)\r\n```\r\nenables us to lose more pack/unpacks and recover this:\r\n```\r\n        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\r\n```",
        "createdAt" : "2020-03-05T11:40:10Z",
        "updatedAt" : "2020-03-05T12:00:20Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "00d45cb44007659545cda3a4ccf31a12b4c88fbe",
    "line" : null,
    "diffHunk" : "@@ -643,14 +643,14 @@ instance ToJSON PackageJson where\n \n -- Read the provided 'package.json'; transform it to include the\n -- provided workspaces; write it back to disk.\n-writeTopLevelPackageJson :: FilePath -> [(String, String, [Dependency])] -> FilePath -> IO ()\n+writeTopLevelPackageJson :: FilePath -> [(T.Text, T.Text, [Dependency])] -> FilePath -> IO ()\n writeTopLevelPackageJson optOutputDir dependencies file = do\n   let (g, nodeFromVertex) = graphFromEdges'\n-        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\n+        (map (\\(a, b, ds) -> (T.unpack a, T.unpack b, map undependency ds)) dependencies)"
  },
  {
    "id" : "89ea01d8-3aeb-4e27-bdcd-159b5be0c466",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "41f7adab-9b3d-4984-83be-5d7b03e5d5d4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If it’s internal add `<> internal` which hides it from `--help`.",
        "createdAt" : "2020-03-04T08:10:29Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8153dda0-959d-41fb-bb28-cac4f463ebd9",
        "parentId" : "41f7adab-9b3d-4984-83be-5d7b03e5d5d4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "thanks",
        "createdAt" : "2020-03-04T13:58:39Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -40,18 +54,32 @@ optionsParser = Options\n         <> metavar \"DIR\"\n         <> help \"Output directory for the generated TypeScript files\"\n         )\n+    <*> optional (strOption\n+        (  long \"daml-types-version\"\n+        <> help \"The version of '@daml/types' to depend on (warning : not a user-configuration parameter; for SDK internal use)\""
  },
  {
    "id" : "e99b023a-e985-4160-ba3e-c766ced8d32b",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "99e10e7c-cecf-4e7f-9d34-095c8da0a4c8",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here.",
        "createdAt" : "2020-03-04T08:10:36Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -40,18 +54,32 @@ optionsParser = Options\n         <> metavar \"DIR\"\n         <> help \"Output directory for the generated TypeScript files\"\n         )\n+    <*> optional (strOption\n+        (  long \"daml-types-version\"\n+        <> help \"The version of '@daml/types' to depend on (warning : not a user-configuration parameter; for SDK internal use)\"\n+        ))\n+    <*> optional (strOption\n+        (  long \"package-version\""
  },
  {
    "id" : "8bd8ec45-5671-4a4a-85a5-58f511153049",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "101d3786-e0a8-4a00-ba52-5800ff48538c",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "When would I want to override this?",
        "createdAt" : "2020-03-04T08:10:48Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "000ddaf4-747d-45be-8a31-3b473e9f6c03",
        "parentId" : "101d3786-e0a8-4a00-ba52-5800ff48538c",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh I see, this is the path where the `package.json` file will be written to. The `help` text is confusing. I thought I pass in the `package.json` myself.",
        "createdAt" : "2020-03-04T08:30:46Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6435d75e-ea6c-44a6-b118-58de74ea6dd4",
        "parentId" : "101d3786-e0a8-4a00-ba52-5800ff48538c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i'll do something with the help text",
        "createdAt" : "2020-03-04T14:10:34Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -40,18 +54,32 @@ optionsParser = Options\n         <> metavar \"DIR\"\n         <> help \"Output directory for the generated TypeScript files\"\n         )\n+    <*> optional (strOption\n+        (  long \"daml-types-version\"\n+        <> help \"The version of '@daml/types' to depend on (warning : not a user-configuration parameter; for SDK internal use)\"\n+        ))\n+    <*> optional (strOption\n+        (  long \"package-version\"\n+        <> help \"The version string to use for output packages (warning : not a user-configuration parameter; for SDK internal use)\"\n+        ))\n+    <*> optional (strOption\n+        (  short 'p'\n+        <> metavar \"PACKAGE-JSON\"\n+        <> help \"A 'package.json' of workspaces\""
  },
  {
    "id" : "29e9a387-77c4-444f-88c4-cb93ea0124d5",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "87a45cea-bbf6-4a3c-9374-a4eafa7c64a2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Rather than defaulting to `0.0.0`, I would call `getSdkVersion` here and remove the logic from `daml-helper` as mentioned above.",
        "createdAt" : "2020-03-04T08:13:15Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "985c1131-6229-4939-ab93-b607d3a0e9ee",
        "parentId" : "87a45cea-bbf6-4a3c-9374-a4eafa7c64a2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yep.",
        "createdAt" : "2020-03-04T15:31:33Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion"
  },
  {
    "id" : "b08da8ae-fc8f-4aef-a9e3-3aa64b01268e",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "3cab9b18-c299-41b5-a8c5-20bea50e6cb2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "As mentioned elsewhere, I believe this really should be the version of the DALF not the SDK version. Fine to leave it for this PR (although I would like to see the logic move here instead of in `daml-helper`) but maybe add a TODO.\r\n\r\nThis also means that you need different versions for each package so you need to change the CLI flags to allow passing a version for a specific package.",
        "createdAt" : "2020-03-04T08:15:04Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "249ff59d-b71f-429e-8951-44454d7d2fa3",
        "parentId" : "3cab9b18-c299-41b5-a8c5-20bea50e6cb2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Actually removing the package argument from the command line entirely. Noted regarding the rest but let's get @hurryabit to chime in with his approval on that strategy too.",
        "createdAt" : "2020-03-04T15:32:53Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion"
  },
  {
    "id" : "94c6c9c1-dc74-4979-8219-f93d45168aa8",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "530a11ba-d5b1-41a3-8fd8-86762a8312fa",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I would recommend to switch this to a `mapM` and then `fmap concat` afterwards. The actions really don’t depend on each other but if you use a `foldM` I have to inspect the code to see that.",
        "createdAt" : "2020-03-04T08:18:34Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b631da6a-a25e-4c0d-a037-1f3836f3fc40",
        "parentId" : "530a11ba-d5b1-41a3-8fd8-86762a8312fa",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "bit of a rabbit hole - was working by good fortune rather than good mgt - but we got there 😉 ",
        "createdAt" : "2020-03-04T16:18:42Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir\n+          -- The package set name e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd <$> foldM (writeModuleTs packageSrcDir packageSetName) [] (packageModules pkg)"
  },
  {
    "id" : "a24aa3df-da27-4d8d-95b9-5320878a47e0",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "790366b9-8923-4a59-9379-34f58e13dd57",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I would recommend to throw a few newtypes at this. E.g. `writeModuleTs :: FilePath -> PackageName -> Module -> IO [Dependency]`.",
        "createdAt" : "2020-03-04T08:19:55Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eb5bd566-cc09-4b89-b432-165e94ca6ba4",
        "parentId" : "790366b9-8923-4a59-9379-34f58e13dd57",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-03-04T17:06:58Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir\n+          -- The package set name e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd <$> foldM (writeModuleTs packageSrcDir packageSetName) [] (packageModules pkg)\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion dependencies\n+    -- Dependencies have the form '@daml2ts/d14e08'. We want to return\n+    -- just the 'd14e08' parts.\n+    pure $ mapMaybe (stripPrefix (packageSetName ++ \"/\")) dependencies\n+    where\n+      -- Write the .ts file for a single DAML-LF module.\n+      writeModuleTs :: FilePath -> String -> [String] -> Module -> IO [String]"
  },
  {
    "id" : "58618930-c004-44a3-b22b-4d099ed1278e",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "b5622919-ac05-4eac-aa7b-34e4685979e7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I believe what you are calling `set` here is called `scope` in NPM terminology see https://docs.npmjs.com/misc/scope. I would recommend to use the established terminology here.",
        "createdAt" : "2020-03-04T08:21:38Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7f90c449-a827-4048-ade9-eb079d6c6f94",
        "parentId" : "b5622919-ac05-4eac-aa7b-34e4685979e7",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "nice. yes, will do. thanks!",
        "createdAt" : "2020-03-04T15:33:37Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir"
  },
  {
    "id" : "6cce4f88-1a8b-4ca9-b6d1-b793c7e3dc30",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "7a21a284-7186-4a1c-bb26-3bacc533951e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You first add the prefix in `genModule` only to then strip it away again here (silently ignoring packages without that prefix which I think should never happen?). I would recommend to have `genModule` return only the name without the scope and then add the scope in `writePackageJson`.",
        "createdAt" : "2020-03-04T08:23:28Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eda72ebb-e251-48a4-b780-90e3c71158a8",
        "parentId" : "7a21a284-7186-4a1c-bb26-3bacc533951e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok",
        "createdAt" : "2020-03-04T16:28:43Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir\n+          -- The package set name e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd <$> foldM (writeModuleTs packageSrcDir packageSetName) [] (packageModules pkg)\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion dependencies\n+    -- Dependencies have the form '@daml2ts/d14e08'. We want to return\n+    -- just the 'd14e08' parts.\n+    pure $ mapMaybe (stripPrefix (packageSetName ++ \"/\")) dependencies"
  },
  {
    "id" : "75dfafd7-0b69-42f6-966a-c0963b13645d",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "6efabeba-f5f1-4cd2-a4e5-5153cca45a25",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The logic for defaulting the package name seems to be duplicated in several places. Given that things will almost certainly go wrong if this gets inconsistent,  I would recommend to factor this out.",
        "createdAt" : "2020-03-04T08:43:40Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7ef2965a-a4d6-4807-905f-4a510413b346",
        "parentId" : "6efabeba-f5f1-4cd2-a4e5-5153cca45a25",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "this seems to be the only occurrence.",
        "createdAt" : "2020-03-04T17:18:56Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c9344673-1d1e-4ea9-9210-d328e70602c7",
        "parentId" : "6efabeba-f5f1-4cd2-a4e5-5153cca45a25",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It’s not, you have the same logic in https://github.com/digital-asset/daml/pull/4799/files/15ab9be7d4e1eb9a5b08d2634568b83f348e0b6d#diff-0709c0764255ab5d7e9b66b5ca7bf9c4R138",
        "createdAt" : "2020-03-04T17:52:38Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "48f83cd1-eaa3-43ef-a884-e86b999cea23",
        "parentId" : "6efabeba-f5f1-4cd2-a4e5-5153cca45a25",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i'm so sorry man, i don't know where the link is trying to point me at :( can you give me a source file reference?",
        "createdAt" : "2020-03-04T18:32:36Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e25e2d9b-c9df-480a-ac5d-a5d5b43435de",
        "parentId" : "6efabeba-f5f1-4cd2-a4e5-5153cca45a25",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "ok, think i've got it now. thanks for your patience.",
        "createdAt" : "2020-03-04T18:51:46Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir\n+          -- The package set name e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd <$> foldM (writeModuleTs packageSrcDir packageSetName) [] (packageModules pkg)\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion dependencies\n+    -- Dependencies have the form '@daml2ts/d14e08'. We want to return\n+    -- just the 'd14e08' parts.\n+    pure $ mapMaybe (stripPrefix (packageSetName ++ \"/\")) dependencies\n+    where\n+      -- Write the .ts file for a single DAML-LF module.\n+      writeModuleTs :: FilePath -> String -> [String] -> Module -> IO [String]\n+      writeModuleTs packageSrcDir packageSetName dependencies mod = do\n+        case genModule pm (T.pack packageSetName) pkgId mod of\n+           Just (modTxt, ds) -> do\n+             let outputFile = packageSrcDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n+             createDirectoryIfMissing True (takeDirectory outputFile)\n+             T.writeFileUtf8 outputFile modTxt\n+             pure $ ds ++ dependencies\n+           Nothing -> pure dependencies\n+\n+-- Generate the .ts content for a single module.\n+genModule :: Map.Map PackageId (Maybe PackageName, Package) ->\n+     T.Text -> PackageId -> Module -> Maybe (T.Text, [String])\n+genModule pm packageSetName curPkgId mod\n+  | null serDefs =\n+    Nothing -- If no serializable types, nothing to do.\n   | otherwise =\n-    let curModName = moduleName mod\n-        pkgRootPath\n-          | lenModName == 1 = \".\"\n-          | otherwise = T.intercalate \"/\" (replicate (lenModName - 1) \"..\")\n-          where\n-            lenModName = length (unModuleName curModName)\n-        tpls = moduleTemplates mod\n-        (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n-        header =\n-            [\"// Generated from \" <> T.intercalate \"/\" (unModuleName curModName) <> \".daml\"\n-            ,\"/* eslint-disable @typescript-eslint/camelcase */\"\n-            ,\"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n-            ,\"import * as jtv from '@mojotech/json-type-validation';\"\n-            ,\"import * as daml from '@daml/types';\"\n-            ]\n-        imports =\n-            [\"import * as \" <> modNameStr <> \" from '\" <> pkgRootPath <> \"/\" <> pkgRefStr <> T.intercalate \"/\" (unModuleName modName) <> \"';\"\n-            | modRef@(pkgRef, modName) <- Set.toList ((PRSelf, curModName) `Set.delete` Set.unions refs)\n-            , let pkgRefStr = case pkgRef of\n-                    PRSelf -> \"\"\n-                    PRImport pkgId ->\n-                      -- If the imported package has a symbolic name,\n-                      -- then we need to use it in the package path.\n-                      \"../\" <> (case Map.lookup pkgId pm of\n-                                   Just (Just name, _) -> unPackageName name\n-                                   Just (Nothing, _) -> unPackageId pkgId\n-                                   Nothing -> error \"IMPOSSIBLE : package map malformed\"\n-                               ) <> \"/\"\n-            , let modNameStr = genModuleRef modRef\n-            ]\n-        defs = map (\\(def, ser) -> def ++ ser) defSers\n-    in\n-    Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n+    let (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n+        imports = [ importDecl pm modRef rootPath\n+                  | modRef@(pkgRef, _) <- modRefs refs\n+                  , let rootPath = pkgRootPath modName pkgRef ]\n+        defs = map biconcat defSers\n+        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $ modHeader : imports : defs\n+        depends = [ T.unpack $ packageSetName <> \"/\" <> pkgRefStr pm pkgRef\n+                  | (pkgRef, _) <- modRefs refs, isPkgRefNotSelf pkgRef ]\n+   in Just (modText, depends)\n   where\n+    modName = moduleName mod\n+    tpls = moduleTemplates mod\n     serDefs = defDataTypes mod\n+    modRefs refs = Set.toList ((PRSelf, modName) `Set.delete` Set.unions refs)\n+    modHeader =\n+      [ \"// Generated from \" <> T.intercalate \"/\" (unModuleName modName) <> \".daml\"\n+      , \"/* eslint-disable @typescript-eslint/camelcase */\"\n+      , \"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n+      , \"import * as jtv from '@mojotech/json-type-validation';\"\n+      , \"import * as daml from '@daml/types';\"\n+      ]\n+\n+    -- Calculate an import declaration.\n+    importDecl :: Map.Map PackageId (Maybe PackageName, Package) ->\n+                       (PackageRef, ModuleName) -> T.Text -> T.Text\n+    importDecl pm modRef@(pkgRef, modName) rootPath =\n+      \"import * as \" <>  genModuleRef modRef <> \" from '\" <>\n+      (if isPkgRefNotSelf pkgRef\n+         then rootPath <> \"/\" <> pkgRefStr pm pkgRef <> \"/lib/\"\n+         else rootPath <> \"/\" <> pkgRefStr pm pkgRef\n+      ) <> T.intercalate \"/\" (unModuleName modName) <> \"';\"\n+\n+    -- Check if a package ref is a foreign import.\n+    isPkgRefNotSelf :: PackageRef -> Bool\n+    isPkgRefNotSelf = \\case PRSelf -> False; PRImport _ -> True\n+\n+    -- Produce a package name for a package ref.\n+    pkgRefStr :: Map.Map PackageId (Maybe PackageName, Package) ->\n+                                              PackageRef -> T.Text\n+    pkgRefStr pm = \\case\n+      PRSelf -> \"\"\n+      PRImport pkgId ->\n+        case Map.lookup pkgId pm of\n+            Just (Just name, _) -> unPackageName name\n+            Just (Nothing, _) -> unPackageId pkgId"
  },
  {
    "id" : "c5cf4e3e-836b-431d-ac95-8354cd3998bd",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "56db659a-3935-4982-8093-a1693d1cfbbb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n                  | (pkgRef, _) <- modRefs refs, pkgRef /= PRSelf]\r\n```",
        "createdAt" : "2020-03-04T08:45:07Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9d7d632f-f6cb-49cf-ab09-5314fe38c5a7",
        "parentId" : "56db659a-3935-4982-8093-a1693d1cfbbb",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i don't know why i didn't think of this :)",
        "createdAt" : "2020-03-04T13:59:12Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir\n+          -- The package set name e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd <$> foldM (writeModuleTs packageSrcDir packageSetName) [] (packageModules pkg)\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion dependencies\n+    -- Dependencies have the form '@daml2ts/d14e08'. We want to return\n+    -- just the 'd14e08' parts.\n+    pure $ mapMaybe (stripPrefix (packageSetName ++ \"/\")) dependencies\n+    where\n+      -- Write the .ts file for a single DAML-LF module.\n+      writeModuleTs :: FilePath -> String -> [String] -> Module -> IO [String]\n+      writeModuleTs packageSrcDir packageSetName dependencies mod = do\n+        case genModule pm (T.pack packageSetName) pkgId mod of\n+           Just (modTxt, ds) -> do\n+             let outputFile = packageSrcDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n+             createDirectoryIfMissing True (takeDirectory outputFile)\n+             T.writeFileUtf8 outputFile modTxt\n+             pure $ ds ++ dependencies\n+           Nothing -> pure dependencies\n+\n+-- Generate the .ts content for a single module.\n+genModule :: Map.Map PackageId (Maybe PackageName, Package) ->\n+     T.Text -> PackageId -> Module -> Maybe (T.Text, [String])\n+genModule pm packageSetName curPkgId mod\n+  | null serDefs =\n+    Nothing -- If no serializable types, nothing to do.\n   | otherwise =\n-    let curModName = moduleName mod\n-        pkgRootPath\n-          | lenModName == 1 = \".\"\n-          | otherwise = T.intercalate \"/\" (replicate (lenModName - 1) \"..\")\n-          where\n-            lenModName = length (unModuleName curModName)\n-        tpls = moduleTemplates mod\n-        (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n-        header =\n-            [\"// Generated from \" <> T.intercalate \"/\" (unModuleName curModName) <> \".daml\"\n-            ,\"/* eslint-disable @typescript-eslint/camelcase */\"\n-            ,\"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n-            ,\"import * as jtv from '@mojotech/json-type-validation';\"\n-            ,\"import * as daml from '@daml/types';\"\n-            ]\n-        imports =\n-            [\"import * as \" <> modNameStr <> \" from '\" <> pkgRootPath <> \"/\" <> pkgRefStr <> T.intercalate \"/\" (unModuleName modName) <> \"';\"\n-            | modRef@(pkgRef, modName) <- Set.toList ((PRSelf, curModName) `Set.delete` Set.unions refs)\n-            , let pkgRefStr = case pkgRef of\n-                    PRSelf -> \"\"\n-                    PRImport pkgId ->\n-                      -- If the imported package has a symbolic name,\n-                      -- then we need to use it in the package path.\n-                      \"../\" <> (case Map.lookup pkgId pm of\n-                                   Just (Just name, _) -> unPackageName name\n-                                   Just (Nothing, _) -> unPackageId pkgId\n-                                   Nothing -> error \"IMPOSSIBLE : package map malformed\"\n-                               ) <> \"/\"\n-            , let modNameStr = genModuleRef modRef\n-            ]\n-        defs = map (\\(def, ser) -> def ++ ser) defSers\n-    in\n-    Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n+    let (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n+        imports = [ importDecl pm modRef rootPath\n+                  | modRef@(pkgRef, _) <- modRefs refs\n+                  , let rootPath = pkgRootPath modName pkgRef ]\n+        defs = map biconcat defSers\n+        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $ modHeader : imports : defs\n+        depends = [ T.unpack $ packageSetName <> \"/\" <> pkgRefStr pm pkgRef\n+                  | (pkgRef, _) <- modRefs refs, isPkgRefNotSelf pkgRef ]"
  },
  {
    "id" : "30a81674-9532-4872-aae1-89f97ae98511",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "91f9e533-6f38-4d7a-a5cc-5e5f9a1540c7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n      (intercalate \"/\" (rootPath : pkgRefStr pm pkgRef : [\"lib\" | pkgRef /= PRSelf])\r\n```",
        "createdAt" : "2020-03-04T08:48:02Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9fe7096d-09b0-4b50-ae36-d2f1223b6806",
        "parentId" : "91f9e533-6f38-4d7a-a5cc-5e5f9a1540c7",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "or this, given i managed to think this way recently in the daml assistant part of the patch :)",
        "createdAt" : "2020-03-04T13:59:36Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir\n+          -- The package set name e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd <$> foldM (writeModuleTs packageSrcDir packageSetName) [] (packageModules pkg)\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion dependencies\n+    -- Dependencies have the form '@daml2ts/d14e08'. We want to return\n+    -- just the 'd14e08' parts.\n+    pure $ mapMaybe (stripPrefix (packageSetName ++ \"/\")) dependencies\n+    where\n+      -- Write the .ts file for a single DAML-LF module.\n+      writeModuleTs :: FilePath -> String -> [String] -> Module -> IO [String]\n+      writeModuleTs packageSrcDir packageSetName dependencies mod = do\n+        case genModule pm (T.pack packageSetName) pkgId mod of\n+           Just (modTxt, ds) -> do\n+             let outputFile = packageSrcDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n+             createDirectoryIfMissing True (takeDirectory outputFile)\n+             T.writeFileUtf8 outputFile modTxt\n+             pure $ ds ++ dependencies\n+           Nothing -> pure dependencies\n+\n+-- Generate the .ts content for a single module.\n+genModule :: Map.Map PackageId (Maybe PackageName, Package) ->\n+     T.Text -> PackageId -> Module -> Maybe (T.Text, [String])\n+genModule pm packageSetName curPkgId mod\n+  | null serDefs =\n+    Nothing -- If no serializable types, nothing to do.\n   | otherwise =\n-    let curModName = moduleName mod\n-        pkgRootPath\n-          | lenModName == 1 = \".\"\n-          | otherwise = T.intercalate \"/\" (replicate (lenModName - 1) \"..\")\n-          where\n-            lenModName = length (unModuleName curModName)\n-        tpls = moduleTemplates mod\n-        (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n-        header =\n-            [\"// Generated from \" <> T.intercalate \"/\" (unModuleName curModName) <> \".daml\"\n-            ,\"/* eslint-disable @typescript-eslint/camelcase */\"\n-            ,\"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n-            ,\"import * as jtv from '@mojotech/json-type-validation';\"\n-            ,\"import * as daml from '@daml/types';\"\n-            ]\n-        imports =\n-            [\"import * as \" <> modNameStr <> \" from '\" <> pkgRootPath <> \"/\" <> pkgRefStr <> T.intercalate \"/\" (unModuleName modName) <> \"';\"\n-            | modRef@(pkgRef, modName) <- Set.toList ((PRSelf, curModName) `Set.delete` Set.unions refs)\n-            , let pkgRefStr = case pkgRef of\n-                    PRSelf -> \"\"\n-                    PRImport pkgId ->\n-                      -- If the imported package has a symbolic name,\n-                      -- then we need to use it in the package path.\n-                      \"../\" <> (case Map.lookup pkgId pm of\n-                                   Just (Just name, _) -> unPackageName name\n-                                   Just (Nothing, _) -> unPackageId pkgId\n-                                   Nothing -> error \"IMPOSSIBLE : package map malformed\"\n-                               ) <> \"/\"\n-            , let modNameStr = genModuleRef modRef\n-            ]\n-        defs = map (\\(def, ser) -> def ++ ser) defSers\n-    in\n-    Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n+    let (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n+        imports = [ importDecl pm modRef rootPath\n+                  | modRef@(pkgRef, _) <- modRefs refs\n+                  , let rootPath = pkgRootPath modName pkgRef ]\n+        defs = map biconcat defSers\n+        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $ modHeader : imports : defs\n+        depends = [ T.unpack $ packageSetName <> \"/\" <> pkgRefStr pm pkgRef\n+                  | (pkgRef, _) <- modRefs refs, isPkgRefNotSelf pkgRef ]\n+   in Just (modText, depends)\n   where\n+    modName = moduleName mod\n+    tpls = moduleTemplates mod\n     serDefs = defDataTypes mod\n+    modRefs refs = Set.toList ((PRSelf, modName) `Set.delete` Set.unions refs)\n+    modHeader =\n+      [ \"// Generated from \" <> T.intercalate \"/\" (unModuleName modName) <> \".daml\"\n+      , \"/* eslint-disable @typescript-eslint/camelcase */\"\n+      , \"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n+      , \"import * as jtv from '@mojotech/json-type-validation';\"\n+      , \"import * as daml from '@daml/types';\"\n+      ]\n+\n+    -- Calculate an import declaration.\n+    importDecl :: Map.Map PackageId (Maybe PackageName, Package) ->\n+                       (PackageRef, ModuleName) -> T.Text -> T.Text\n+    importDecl pm modRef@(pkgRef, modName) rootPath =\n+      \"import * as \" <>  genModuleRef modRef <> \" from '\" <>\n+      (if isPkgRefNotSelf pkgRef\n+         then rootPath <> \"/\" <> pkgRefStr pm pkgRef <> \"/lib/\"\n+         else rootPath <> \"/\" <> pkgRefStr pm pkgRef"
  },
  {
    "id" : "a5dd9d06-a29f-465f-92f8-f011984489bf",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "3b34abcf-0db7-4555-89d1-7f48d8392866",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    pkgRefStr :: Map.Map PackageId (Maybe PackageName, Package) -> PackageRef -> T.Text\r\n```\r\nThe indentation here looks very odd.",
        "createdAt" : "2020-03-04T08:50:08Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b9b0dc60-eebd-4646-bf09-131e8eccc2c3",
        "parentId" : "3b34abcf-0db7-4555-89d1-7f48d8392866",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "thought that would get flagged :) i have peculiar tastes. i'll normalize it as you suggest.",
        "createdAt" : "2020-03-04T14:00:01Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +115,154 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    let damlTypesVersion = fromMaybe \"0.0.0\" optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    let packageVersion   = fromMaybe \"0.0.0\" optPackageVersion\n+       -- The version string for pacakges we write.\n+\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    putStrLn $ \"Generated packages to have version string : \\\"\" <> packageVersion <> \"\\\"\"\n+\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = maybe id (T.unpack . unPackageName) mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+-- Gives the string '@foo' given a directory path like '/path/to/foo'.\n+packageSetNameOfPackageSetDir :: FilePath -> String\n+packageSetNameOfPackageSetDir = (\"@\" <>) . takeFileName\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = packageSet <> \"/\" <> package\n+  where\n+    packageSet = packageSetNameOfPackageSetDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [String]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let packageSetDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = packageSetDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        packageSetName = packageSetNameOfPackageSetDir packageSetDir\n+          -- The package set name e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd <$> foldM (writeModuleTs packageSrcDir packageSetName) [] (packageModules pkg)\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion dependencies\n+    -- Dependencies have the form '@daml2ts/d14e08'. We want to return\n+    -- just the 'd14e08' parts.\n+    pure $ mapMaybe (stripPrefix (packageSetName ++ \"/\")) dependencies\n+    where\n+      -- Write the .ts file for a single DAML-LF module.\n+      writeModuleTs :: FilePath -> String -> [String] -> Module -> IO [String]\n+      writeModuleTs packageSrcDir packageSetName dependencies mod = do\n+        case genModule pm (T.pack packageSetName) pkgId mod of\n+           Just (modTxt, ds) -> do\n+             let outputFile = packageSrcDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n+             createDirectoryIfMissing True (takeDirectory outputFile)\n+             T.writeFileUtf8 outputFile modTxt\n+             pure $ ds ++ dependencies\n+           Nothing -> pure dependencies\n+\n+-- Generate the .ts content for a single module.\n+genModule :: Map.Map PackageId (Maybe PackageName, Package) ->\n+     T.Text -> PackageId -> Module -> Maybe (T.Text, [String])\n+genModule pm packageSetName curPkgId mod\n+  | null serDefs =\n+    Nothing -- If no serializable types, nothing to do.\n   | otherwise =\n-    let curModName = moduleName mod\n-        pkgRootPath\n-          | lenModName == 1 = \".\"\n-          | otherwise = T.intercalate \"/\" (replicate (lenModName - 1) \"..\")\n-          where\n-            lenModName = length (unModuleName curModName)\n-        tpls = moduleTemplates mod\n-        (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n-        header =\n-            [\"// Generated from \" <> T.intercalate \"/\" (unModuleName curModName) <> \".daml\"\n-            ,\"/* eslint-disable @typescript-eslint/camelcase */\"\n-            ,\"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n-            ,\"import * as jtv from '@mojotech/json-type-validation';\"\n-            ,\"import * as daml from '@daml/types';\"\n-            ]\n-        imports =\n-            [\"import * as \" <> modNameStr <> \" from '\" <> pkgRootPath <> \"/\" <> pkgRefStr <> T.intercalate \"/\" (unModuleName modName) <> \"';\"\n-            | modRef@(pkgRef, modName) <- Set.toList ((PRSelf, curModName) `Set.delete` Set.unions refs)\n-            , let pkgRefStr = case pkgRef of\n-                    PRSelf -> \"\"\n-                    PRImport pkgId ->\n-                      -- If the imported package has a symbolic name,\n-                      -- then we need to use it in the package path.\n-                      \"../\" <> (case Map.lookup pkgId pm of\n-                                   Just (Just name, _) -> unPackageName name\n-                                   Just (Nothing, _) -> unPackageId pkgId\n-                                   Nothing -> error \"IMPOSSIBLE : package map malformed\"\n-                               ) <> \"/\"\n-            , let modNameStr = genModuleRef modRef\n-            ]\n-        defs = map (\\(def, ser) -> def ++ ser) defSers\n-    in\n-    Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n+    let (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n+        imports = [ importDecl pm modRef rootPath\n+                  | modRef@(pkgRef, _) <- modRefs refs\n+                  , let rootPath = pkgRootPath modName pkgRef ]\n+        defs = map biconcat defSers\n+        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $ modHeader : imports : defs\n+        depends = [ T.unpack $ packageSetName <> \"/\" <> pkgRefStr pm pkgRef\n+                  | (pkgRef, _) <- modRefs refs, isPkgRefNotSelf pkgRef ]\n+   in Just (modText, depends)\n   where\n+    modName = moduleName mod\n+    tpls = moduleTemplates mod\n     serDefs = defDataTypes mod\n+    modRefs refs = Set.toList ((PRSelf, modName) `Set.delete` Set.unions refs)\n+    modHeader =\n+      [ \"// Generated from \" <> T.intercalate \"/\" (unModuleName modName) <> \".daml\"\n+      , \"/* eslint-disable @typescript-eslint/camelcase */\"\n+      , \"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n+      , \"import * as jtv from '@mojotech/json-type-validation';\"\n+      , \"import * as daml from '@daml/types';\"\n+      ]\n+\n+    -- Calculate an import declaration.\n+    importDecl :: Map.Map PackageId (Maybe PackageName, Package) ->\n+                       (PackageRef, ModuleName) -> T.Text -> T.Text\n+    importDecl pm modRef@(pkgRef, modName) rootPath =\n+      \"import * as \" <>  genModuleRef modRef <> \" from '\" <>\n+      (if isPkgRefNotSelf pkgRef\n+         then rootPath <> \"/\" <> pkgRefStr pm pkgRef <> \"/lib/\"\n+         else rootPath <> \"/\" <> pkgRefStr pm pkgRef\n+      ) <> T.intercalate \"/\" (unModuleName modName) <> \"';\"\n+\n+    -- Check if a package ref is a foreign import.\n+    isPkgRefNotSelf :: PackageRef -> Bool\n+    isPkgRefNotSelf = \\case PRSelf -> False; PRImport _ -> True\n+\n+    -- Produce a package name for a package ref.\n+    pkgRefStr :: Map.Map PackageId (Maybe PackageName, Package) ->\n+                                              PackageRef -> T.Text"
  },
  {
    "id" : "def2fe2f-456c-4e43-a33e-66fb124ae339",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "cfb49ffc-22d8-40e6-b94b-9d593492f8dc",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\nnewtype Dependency = Dependency { undependency : String } deriving (Eq, Ord)\r\n```",
        "createdAt" : "2020-03-04T19:06:36Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c7729d6b-3ad3-4db9-a5f9-b852958d7373",
        "parentId" : "cfb49ffc-22d8-40e6-b94b-9d593492f8dc",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-03-04T19:13:55Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : null,
    "diffHunk" : "@@ -82,79 +111,155 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+packageNameStr :: PackageId -> Maybe PackageName -> String\n+packageNameStr pkgId mbPkgIdent =\n+  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+newtype Scope = Scope String\n+unscope :: Scope -> String\n+unscope (Scope s) = s\n+\n+newtype Dependency = Dependency String deriving (Eq, Ord)"
  },
  {
    "id" : "bb7b4dda-6d0c-4a3f-b43f-94a9940ebe78",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "ba71b586-d460-4ac7-8473-e5de34998fff",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Let’s leave it for a separate PR but the `stripPrefix` stuff here looks similar to the other `stripPrefix` stuff. Rather than stripping it here, it shouldn’t be added in the first place.",
        "createdAt" : "2020-03-04T19:09:01Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "945df914-01a7-45d0-af4f-d229a373e7da",
        "parentId" : "ba71b586-d460-4ac7-8473-e5de34998fff",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "i'll work on a follow up for this today.",
        "createdAt" : "2020-03-04T19:22:26Z",
        "updatedAt" : "2020-03-04T19:22:27Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e96bbb46-7725-425d-bb56-e30a67e0e159",
        "parentId" : "ba71b586-d460-4ac7-8473-e5de34998fff",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4818",
        "createdAt" : "2020-03-04T21:04:27Z",
        "updatedAt" : "2020-03-04T21:04:28Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 485,
    "diffHunk" : "@@ -421,10 +530,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++\n+    [\"  },\"\n+    , \"  \\\"scripts\\\": {\"\n+    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n+    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n+    , \"  },\"\n+    , \"  \\\"devDependencies\\\": {\"\n+    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n+    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n+    , \"  }\"\n+    , \"}\"\n+    ])\n+  where\n+    packageName =  packageNameOfPackageDir packageDir\n+    dependencies = withCommas [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> packageVersion <> \"\\\"\"\n+                              | d <- depends\n+                              , let pkg = scope ++ \"/\" ++ undependency d\n+                              ]\n+\n+    withCommas :: [String] -> [String]\n+    withCommas [] = []\n+    withCommas ms = reverse (head ms' : map (++\",\") (tail ms')) where ms' = reverse ms\n+\n+-- This type describes the format of a \"top-level\" 'package.json'. We\n+-- expect such files to have the format\n+-- {\n+--   \"private\": true,\n+--   \"workspaces: [\n+--      \"path/to/foo\",\n+--      \"path/to/bar\",\n+--      ...\n+--   ]\n+-- }\n+data PackageJson = PackageJson\n+  {  private :: Bool\n+  ,  workspaces :: [T.Text]\n+  } deriving Show\n+-- Explicitly provide instances to avoid relying on restricted\n+-- extension 'DeriveGeneric'.\n+instance FromJSON PackageJson where\n+  parseJSON (Object v) = PackageJson\n+      <$> v .: \"private\"\n+      <*> v .: \"workspaces\"\n+  parseJSON _ = mzero\n+instance ToJSON PackageJson where\n+  toJSON (PackageJson private workspaces) =\n+    object [ \"private\" .= private\n+           , \"workspaces\" .= workspaces\n+           ]\n+\n+-- Read the provided 'package.json'; transform it to include the\n+-- provided workspaces; write it back to disk.\n+writeTopLevelPackageJson :: FilePath -> [(String, String, [Dependency])] -> FilePath -> IO ()\n+writeTopLevelPackageJson optOutputDir dependencies file = do\n+  let (g, nodeFromVertex) = graphFromEdges'\n+        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\n+      ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n+        -- Topologically order our packages.\n+      ldr = fromJust (stripPrefix \"@\" (unscope (scopeOfScopeDir optOutputDir)))"
  },
  {
    "id" : "dd1b710e-9b29-4a00-94b2-b9528977cd43",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "b5015a50-0997-4a32-a8af-56eb7bf74555",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This looks somewhat dangerous. You are throwing away every field apart from the two you modify. Additional fields should probably stay intact. Let’s tackle that in a separate PR.",
        "createdAt" : "2020-03-04T19:10:14Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d0c98a60-bb34-4a73-9e5d-d20ccffdbc9f",
        "parentId" : "b5015a50-0997-4a32-a8af-56eb7bf74555",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "sounds good. yes, i am a newbie with this library and would like to learn how to better here in this respect.",
        "createdAt" : "2020-03-04T19:15:03Z",
        "updatedAt" : "2020-03-04T19:19:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0713af5e-413d-4e40-933a-3d4b0f2c7423",
        "parentId" : "b5015a50-0997-4a32-a8af-56eb7bf74555",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "@hurryabit addresses this (along with other niggles) in https://github.com/digital-asset/daml/pull/4820.",
        "createdAt" : "2020-03-05T00:22:41Z",
        "updatedAt" : "2020-03-05T00:22:42Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2317f449-469d-4e52-b019-ab401d0fe1b9",
        "parentId" : "b5015a50-0997-4a32-a8af-56eb7bf74555",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This is fixed in https://github.com/digital-asset/daml/pull/4820.",
        "createdAt" : "2020-03-05T00:24:27Z",
        "updatedAt" : "2020-03-05T00:24:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 492,
    "diffHunk" : "@@ -421,10 +530,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++\n+    [\"  },\"\n+    , \"  \\\"scripts\\\": {\"\n+    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n+    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n+    , \"  },\"\n+    , \"  \\\"devDependencies\\\": {\"\n+    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n+    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n+    , \"  }\"\n+    , \"}\"\n+    ])\n+  where\n+    packageName =  packageNameOfPackageDir packageDir\n+    dependencies = withCommas [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> packageVersion <> \"\\\"\"\n+                              | d <- depends\n+                              , let pkg = scope ++ \"/\" ++ undependency d\n+                              ]\n+\n+    withCommas :: [String] -> [String]\n+    withCommas [] = []\n+    withCommas ms = reverse (head ms' : map (++\",\") (tail ms')) where ms' = reverse ms\n+\n+-- This type describes the format of a \"top-level\" 'package.json'. We\n+-- expect such files to have the format\n+-- {\n+--   \"private\": true,\n+--   \"workspaces: [\n+--      \"path/to/foo\",\n+--      \"path/to/bar\",\n+--      ...\n+--   ]\n+-- }\n+data PackageJson = PackageJson\n+  {  private :: Bool\n+  ,  workspaces :: [T.Text]\n+  } deriving Show\n+-- Explicitly provide instances to avoid relying on restricted\n+-- extension 'DeriveGeneric'.\n+instance FromJSON PackageJson where\n+  parseJSON (Object v) = PackageJson\n+      <$> v .: \"private\"\n+      <*> v .: \"workspaces\"\n+  parseJSON _ = mzero\n+instance ToJSON PackageJson where\n+  toJSON (PackageJson private workspaces) =\n+    object [ \"private\" .= private\n+           , \"workspaces\" .= workspaces\n+           ]\n+\n+-- Read the provided 'package.json'; transform it to include the\n+-- provided workspaces; write it back to disk.\n+writeTopLevelPackageJson :: FilePath -> [(String, String, [Dependency])] -> FilePath -> IO ()\n+writeTopLevelPackageJson optOutputDir dependencies file = do\n+  let (g, nodeFromVertex) = graphFromEdges'\n+        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\n+      ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n+        -- Topologically order our packages.\n+      ldr = fromJust (stripPrefix \"@\" (unscope (scopeOfScopeDir optOutputDir)))\n+        -- 'ldr' we expect to be something like \"daml2ts/\".\n+  let ourPackages = map (T.pack . ((ldr ++ \"/\") ++)) ps\n+  bytes <- BSL.readFile file\n+  maybe\n+    (fail $ \"Error decoding JSON from '\" <> file <> \"'\")\n+    (transformAndWrite ourPackages ldr)\n+    (decode bytes :: Maybe PackageJson)"
  },
  {
    "id" : "e2d910c0-4b6f-4ac2-bfd1-dd9f99e94b9b",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "3805f4a6-856b-4265-9e09-b64da2122e6e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The number of parameters to this function is slowly getting out of hands. Can we please change it to a single record in a follow-up PR.",
        "createdAt" : "2020-03-04T19:26:18Z",
        "updatedAt" : "2020-03-04T19:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "87b940dd-f283-4075-b82a-69a3b1defa1e",
        "parentId" : "3805f4a6-856b-4265-9e09-b64da2122e6e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yes, will do.",
        "createdAt" : "2020-03-04T21:15:23Z",
        "updatedAt" : "2020-03-04T21:15:24Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a38d3aed-1c52-442d-a778-d38fb0e58361",
        "parentId" : "3805f4a6-856b-4265-9e09-b64da2122e6e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4852",
        "createdAt" : "2020-03-05T15:44:21Z",
        "updatedAt" : "2020-03-05T15:44:21Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 137,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion"
  },
  {
    "id" : "165bf15a-6b64-4a7a-9923-c9cdb682715d",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "5b2a2793-6ad2-4381-9daf-ce5c89294ad9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does it make sense to return the same thing twice?",
        "createdAt" : "2020-03-04T19:26:29Z",
        "updatedAt" : "2020-03-04T19:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "192c58c1-8a15-44cc-8d49-fb3227db4170",
        "parentId" : "5b2a2793-6ad2-4381-9daf-ce5c89294ad9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "It's setting up the call to `Graph.topSort` that requires the tuples in roughly that format. It is possible to not do this here and return `(name, deps)` and do the \"dup\" at the call site to `topSort`. I'll put in the PR with the parameter pack enhancement of the comment above.",
        "createdAt" : "2020-03-04T21:16:48Z",
        "updatedAt" : "2020-03-04T21:16:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "42006262-7566-4c24-8686-62a90eb207d3",
        "parentId" : "5b2a2793-6ad2-4381-9daf-ce5c89294ad9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-03-05T15:15:27Z",
        "updatedAt" : "2020-03-05T15:15:27Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9fa7e691-0515-42c8-a2c7-aa7afba7af0a",
        "parentId" : "5b2a2793-6ad2-4381-9daf-ce5c89294ad9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4847",
        "createdAt" : "2020-03-05T15:23:27Z",
        "updatedAt" : "2020-03-05T15:23:28Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 138,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)"
  },
  {
    "id" : "2342bdfb-f7b4-46c4-895e-c83537405bc1",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "e4b79242-8c31-48e4-9b12-f575388a49bd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should make the scope configurable via a command line argument rather than infer it from some path. I suggest we use `@daml.js` as the default for that argument.",
        "createdAt" : "2020-03-04T19:29:30Z",
        "updatedAt" : "2020-03-04T19:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9dd5ee13-b7b2-4d1f-873f-9245aac48415",
        "parentId" : "e4b79242-8c31-48e4-9b12-f575388a49bd",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-03-04T21:17:16Z",
        "updatedAt" : "2020-03-04T21:17:17Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d470142-1e46-4552-82e0-de60faf8d0e2",
        "parentId" : "e4b79242-8c31-48e4-9b12-f575388a49bd",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4908",
        "createdAt" : "2020-03-09T16:00:52Z",
        "updatedAt" : "2020-03-09T16:00:53Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 158,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+packageNameStr :: PackageId -> Maybe PackageName -> String\n+packageNameStr pkgId mbPkgIdent =\n+  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+newtype Scope = Scope {unscope :: String}\n+newtype Dependency = Dependency {undependency :: String}  deriving (Eq, Ord)\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Gives the scope '@foo' given a directory path like '/path/to/foo'.\n+scopeOfScopeDir :: FilePath -> Scope"
  },
  {
    "id" : "cd110261-9d52-42b4-95f1-78a140f10a85",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "7fe10bc4-24a0-42c9-99a3-4cdb071f5a8e",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n          --   import * as pkgd14e08_DA_Internal_Template from '@daml2ts/d14e08/lib/DA/Internal/Template';\r\n```",
        "createdAt" : "2020-03-04T19:30:57Z",
        "updatedAt" : "2020-03-04T19:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "aa8e54ef-3a37-442d-b195-9ce59a8738dc",
        "parentId" : "7fe10bc4-24a0-42c9-99a3-4cdb071f5a8e",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I have a PR here https://github.com/digital-asset/daml/pull/4818 with other cosmetic changes. I'll add this to that.",
        "createdAt" : "2020-03-04T21:18:05Z",
        "updatedAt" : "2020-03-04T21:18:05Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 183,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+packageNameStr :: PackageId -> Maybe PackageName -> String\n+packageNameStr pkgId mbPkgIdent =\n+  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+newtype Scope = Scope {unscope :: String}\n+newtype Dependency = Dependency {undependency :: String}  deriving (Eq, Ord)\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Gives the scope '@foo' given a directory path like '/path/to/foo'.\n+scopeOfScopeDir :: FilePath -> Scope\n+scopeOfScopeDir = Scope . (\"@\" <>) . takeFileName\n+\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = scope <> \"/\" <> package\n+  where\n+    scope = unscope $ scopeOfScopeDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n+\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [Dependency]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let scopeDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = scopeDir </> packageNameStr pkgId mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        scope = scopeOfScopeDir scopeDir\n+          -- The scope e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'"
  },
  {
    "id" : "6359d28a-06b7-42a6-9ba0-196470c48a28",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "460d6d28-6d1c-4ee6-9588-75f6c7781b9b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That comment should probably go a few lines deeper. There are no references to be harvested from `packageId.ts`.",
        "createdAt" : "2020-03-04T19:32:09Z",
        "updatedAt" : "2020-03-04T19:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6646e370-a7b1-46c9-aa11-76fe3a4f4e9b",
        "parentId" : "460d6d28-6d1c-4ee6-9588-75f6c7781b9b",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-03-04T21:19:20Z",
        "updatedAt" : "2020-03-04T21:19:21Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6671d37a-ae56-447c-b84a-78dcb2dfe1d2",
        "parentId" : "460d6d28-6d1c-4ee6-9588-75f6c7781b9b",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4858",
        "createdAt" : "2020-03-05T18:07:12Z",
        "updatedAt" : "2020-03-05T18:07:12Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 185,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+packageNameStr :: PackageId -> Maybe PackageName -> String\n+packageNameStr pkgId mbPkgIdent =\n+  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+newtype Scope = Scope {unscope :: String}\n+newtype Dependency = Dependency {undependency :: String}  deriving (Eq, Ord)\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Gives the scope '@foo' given a directory path like '/path/to/foo'.\n+scopeOfScopeDir :: FilePath -> Scope\n+scopeOfScopeDir = Scope . (\"@\" <>) . takeFileName\n+\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = scope <> \"/\" <> package\n+  where\n+    scope = unscope $ scopeOfScopeDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n+\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [Dependency]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let scopeDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = scopeDir </> packageNameStr pkgId mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        scope = scopeOfScopeDir scopeDir\n+          -- The scope e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to"
  },
  {
    "id" : "41147594-b2db-4284-a0a3-30d68810e096",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "a9c639ba-1ce8-4301-a31f-f2fc38466f3c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'd suggest to write the `packageId.ts` file here, together with the other \"meta data\".",
        "createdAt" : "2020-03-04T19:34:04Z",
        "updatedAt" : "2020-03-04T19:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7a0ec7b1-8bef-41d2-b932-4d09743fbb1f",
        "parentId" : "a9c639ba-1ce8-4301-a31f-f2fc38466f3c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-03-04T21:19:43Z",
        "updatedAt" : "2020-03-04T21:19:43Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2031308e-df83-48a0-9b2c-481c2bf86c52",
        "parentId" : "a9c639ba-1ce8-4301-a31f-f2fc38466f3c",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4858",
        "createdAt" : "2020-03-05T18:07:17Z",
        "updatedAt" : "2020-03-05T18:07:17Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 192,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+packageNameStr :: PackageId -> Maybe PackageName -> String\n+packageNameStr pkgId mbPkgIdent =\n+  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+newtype Scope = Scope {unscope :: String}\n+newtype Dependency = Dependency {undependency :: String}  deriving (Eq, Ord)\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Gives the scope '@foo' given a directory path like '/path/to/foo'.\n+scopeOfScopeDir :: FilePath -> Scope\n+scopeOfScopeDir = Scope . (\"@\" <>) . takeFileName\n+\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = scope <> \"/\" <> package\n+  where\n+    scope = unscope $ scopeOfScopeDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n+\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [Dependency]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let scopeDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = scopeDir </> packageNameStr pkgId mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        scope = scopeOfScopeDir scopeDir\n+          -- The scope e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd . concat <$> mapM (writeModuleTs packageSrcDir scope) (NM.toList (packageModules pkg))\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies."
  },
  {
    "id" : "6b01f30d-0378-49e4-a899-43377c2792a8",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "11b2b879-fe5b-4c63-bc70-d35aeb316350",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "You seem to love the `maybe` function. I'd say a simple `case ... of` is almost always easier to read when the function you pass as the second argument is a syntactic lambda.",
        "createdAt" : "2020-03-04T19:35:22Z",
        "updatedAt" : "2020-03-04T19:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6ed3e57c-42c8-4547-b085-5f029ee1f0ad",
        "parentId" : "11b2b879-fe5b-4c63-bc70-d35aeb316350",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok. You want it changed in this instance?",
        "createdAt" : "2020-03-04T21:20:49Z",
        "updatedAt" : "2020-03-04T21:20:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "331d032f-ee05-49ce-a3c8-3f3c072920e6",
        "parentId" : "11b2b879-fe5b-4c63-bc70-d35aeb316350",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Preferably yes. I like easy to read code.",
        "createdAt" : "2020-03-05T00:23:35Z",
        "updatedAt" : "2020-03-05T00:23:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2a240947-1be8-4c49-989c-b63dcb5c8fbf",
        "parentId" : "11b2b879-fe5b-4c63-bc70-d35aeb316350",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-03-05T13:47:37Z",
        "updatedAt" : "2020-03-05T13:47:38Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 201,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+packageNameStr :: PackageId -> Maybe PackageName -> String\n+packageNameStr pkgId mbPkgIdent =\n+  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+newtype Scope = Scope {unscope :: String}\n+newtype Dependency = Dependency {undependency :: String}  deriving (Eq, Ord)\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Gives the scope '@foo' given a directory path like '/path/to/foo'.\n+scopeOfScopeDir :: FilePath -> Scope\n+scopeOfScopeDir = Scope . (\"@\" <>) . takeFileName\n+\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = scope <> \"/\" <> package\n+  where\n+    scope = unscope $ scopeOfScopeDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n+\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [Dependency]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let scopeDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = scopeDir </> packageNameStr pkgId mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        scope = scopeOfScopeDir scopeDir\n+          -- The scope e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd . concat <$> mapM (writeModuleTs packageSrcDir scope) (NM.toList (packageModules pkg))\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion scope dependencies\n+    pure dependencies\n+    where\n+      -- Write the .ts file for a single DAML-LF module.\n+      writeModuleTs :: FilePath -> Scope -> Module -> IO [Dependency]\n+      writeModuleTs packageSrcDir scope mod = do\n+         maybe (pure [])"
  },
  {
    "id" : "4acb3c43-df3a-48c3-b4e5-ba68df5025f0",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "5f135ddf-c343-4e22-b42f-d2e468cb5990",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "IMO, the only point of `maybe` is to allow for point-free style:\r\n```suggestion\r\n        (T.pack . packageNameStr pkgId . fst)\r\n```\r\nI still prefer a `case ... of` expression though. It would cover the same number of lines and be easier to read.",
        "createdAt" : "2020-03-04T19:39:54Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "db22c7a7-e3dc-4dbd-925d-7758bd1dd9da",
        "parentId" : "5f135ddf-c343-4e22-b42f-d2e468cb5990",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "What you've written there is nice. Sorry I missed that. Given your comments about my use of maybes in general here I guess I'll eschew it though in favor of a case.",
        "createdAt" : "2020-03-04T21:22:07Z",
        "updatedAt" : "2020-03-04T21:22:08Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "79165586-25cf-43b3-a3ff-03c46228a8a4",
        "parentId" : "5f135ddf-c343-4e22-b42f-d2e468cb5990",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-03-05T13:48:09Z",
        "updatedAt" : "2020-03-05T13:48:09Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 286,
    "diffHunk" : "@@ -82,79 +111,150 @@ mergePackageMap ps = foldM merge Map.empty ps\n                     pure (Just (mbOldPkgName <|> mbPkgName, pkg))\n         Map.alterF update pkgId pkgs\n \n+-- Write packages for all the DALFs in all the DARs.\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n+    sdkVersion <- fromMaybe \"0.0.0\" <$> getSdkVersionMaybe\n+    let damlTypesVersion = fromMaybe sdkVersion optDamlTypesVersion\n+       -- The '@daml/types' version that the packages we write should depend on.\n+    putStrLn $ \"Referencing '@daml/types' : \\\"\" <> damlTypesVersion <> \"\\\"\"\n+    let packageVersion   = sdkVersion\n+       -- The version string for packages we write.\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n       Left err -> fail . T.unpack $ err\n-      Right pm ->\n-        forM_ (Map.toList pm) $\n-        \\(pkgId, (mbPkgName, pkg)) -> do\n-          let id = show $ unPackageId pkgId\n-              name = maybe id (T.unpack . unPackageName) mbPkgName\n-              asName = if name == id then \"itself\" else name\n-          putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n-          daml2ts opts pm pkgId pkg mbPkgName\n-\n-daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Package -> Maybe PackageName -> IO ()\n-daml2ts Options{..} pm pkgId pkg mbPkgName = do\n-    let outputDir = optOutputDir </> (T.unpack . maybe (unPackageId pkgId) unPackageName) mbPkgName\n-    createDirectoryIfMissing True outputDir\n-    T.writeFileUtf8 (outputDir </> \"packageId.ts\") $ T.unlines\n-        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n-    forM_ (packageModules pkg) $ \\mod -> do\n-        whenJust (genModule pm pkgId mod) $ \\modTxt -> do\n-            let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            createDirectoryIfMissing True (takeDirectory outputFile)\n-            T.writeFileUtf8 outputFile modTxt\n+      Right pm -> do\n+        dependencies <-\n+          forM (Map.toList pm) $\n+            \\(pkgId, (mbPkgName, pkg)) -> do\n+                 let id = T.unpack $ unPackageId pkgId\n+                     name = packageNameStr pkgId mbPkgName\n+                     asName = if name == id then \"itself\" else name\n+                 putStrLn $ \"Generating \" <> id <> \" as \" <> asName\n+                 deps <- daml2ts opts pm pkgId pkg mbPkgName damlTypesVersion packageVersion\n+                 pure (name, name, deps)\n+        whenJust optInputPackageJson $\n+          writeTopLevelPackageJson optOutputDir dependencies\n \n-dup :: a -> (a, a)\n-dup x = (x, x)\n+packageNameStr :: PackageId -> Maybe PackageName -> String\n+packageNameStr pkgId mbPkgIdent =\n+  T.unpack (maybe (unPackageId pkgId) unPackageName mbPkgIdent)\n \n-infixr 6 <.> -- This is the same fixity as '<>'.\n-(<.>) :: T.Text -> T.Text -> T.Text\n-(<.>) u v = u <> \".\" <> v\n+newtype Scope = Scope {unscope :: String}\n+newtype Dependency = Dependency {undependency :: String}  deriving (Eq, Ord)\n \n-genModule :: Map.Map PackageId (Maybe PackageName, Package) -> PackageId -> Module -> Maybe T.Text\n-genModule pm curPkgId mod\n-  | null serDefs = Nothing\n+-- Gives the scope '@foo' given a directory path like '/path/to/foo'.\n+scopeOfScopeDir :: FilePath -> Scope\n+scopeOfScopeDir = Scope . (\"@\" <>) . takeFileName\n+\n+-- From the path to a package like '/path/to/daml2ts/d14e08'\n+-- calculates '@daml2ts/d14e08' suitable for use as the \"name\" field\n+-- of a 'package.json'.\n+packageNameOfPackageDir :: FilePath -> String\n+packageNameOfPackageDir packageDir = scope <> \"/\" <> package\n+  where\n+    scope = unscope $ scopeOfScopeDir (takeDirectory packageDir)\n+    package = takeFileName packageDir\n+\n+-- Write the files for a single package.\n+daml2ts :: Options -> Map.Map PackageId (Maybe PackageName, Package) ->\n+    PackageId -> Package -> Maybe PackageName -> String -> String -> IO [Dependency]\n+daml2ts Options{..} pm pkgId pkg mbPkgName damlTypesVersion packageVersion = do\n+    let scopeDir = optOutputDir\n+          -- The directory into which we generate packages e.g. '/path/to/daml2ts'.\n+        packageDir = scopeDir </> packageNameStr pkgId mbPkgName\n+          -- The directory into which we write this package e.g. '/path/to/daml2ts/davl-0.0.4'.\n+        packageSrcDir = packageDir </> \"src\"\n+          -- Where the source files of this package are written e.g. '/path/to/daml2ts/davl-0.0.4/src'.\n+        scope = scopeOfScopeDir scopeDir\n+          -- The scope e.g. '@daml2ts'.\n+          -- We use this, for example, when generating import declarations e.g.\n+          --   'import * as pkgd14e08_DA_Internal_Template from @daml2ts/d14e08/lib/DA/Internal/Template';'\n+    createDirectoryIfMissing True packageSrcDir\n+    -- Write .ts files for the package and harvest references to\n+    -- foreign packages as we do.\n+    T.writeFileUtf8 (packageSrcDir </> \"packageId.ts\") $ T.unlines\n+        [\"export default '\" <> unPackageId pkgId <> \"';\"]\n+    dependencies <- nubOrd . concat <$> mapM (writeModuleTs packageSrcDir scope) (NM.toList (packageModules pkg))\n+    -- Now write 'package.json', 'tsconfig.json' and '.eslint.rc.json'\n+    -- files into the package dir. The 'package.json' needs the\n+    -- dependencies.\n+    writeTsConfig packageDir\n+    writeEsLintConfig packageDir\n+    writePackageJson packageDir damlTypesVersion packageVersion scope dependencies\n+    pure dependencies\n+    where\n+      -- Write the .ts file for a single DAML-LF module.\n+      writeModuleTs :: FilePath -> Scope -> Module -> IO [Dependency]\n+      writeModuleTs packageSrcDir scope mod = do\n+         maybe (pure [])\n+           (\\(modTxt, ds) -> do\n+             let outputFile = packageSrcDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n+             createDirectoryIfMissing True (takeDirectory outputFile)\n+             T.writeFileUtf8 outputFile modTxt\n+             pure ds\n+           )\n+           (genModule pm scope pkgId mod)\n+\n+-- Generate the .ts content for a single module.\n+genModule :: Map.Map PackageId (Maybe PackageName, Package) ->\n+     Scope -> PackageId -> Module -> Maybe (T.Text, [Dependency])\n+genModule pm (Scope scope) curPkgId mod\n+  | null serDefs =\n+    Nothing -- If no serializable types, nothing to do.\n   | otherwise =\n-    let curModName = moduleName mod\n-        pkgRootPath\n-          | lenModName == 1 = \".\"\n-          | otherwise = T.intercalate \"/\" (replicate (lenModName - 1) \"..\")\n-          where\n-            lenModName = length (unModuleName curModName)\n-        tpls = moduleTemplates mod\n-        (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n-        header =\n-            [\"// Generated from \" <> T.intercalate \"/\" (unModuleName curModName) <> \".daml\"\n-            ,\"/* eslint-disable @typescript-eslint/camelcase */\"\n-            ,\"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n-            ,\"import * as jtv from '@mojotech/json-type-validation';\"\n-            ,\"import * as daml from '@daml/types';\"\n-            ]\n-        imports =\n-            [\"import * as \" <> modNameStr <> \" from '\" <> pkgRootPath <> \"/\" <> pkgRefStr <> T.intercalate \"/\" (unModuleName modName) <> \"';\"\n-            | modRef@(pkgRef, modName) <- Set.toList ((PRSelf, curModName) `Set.delete` Set.unions refs)\n-            , let pkgRefStr = case pkgRef of\n-                    PRSelf -> \"\"\n-                    PRImport pkgId ->\n-                      -- If the imported package has a symbolic name,\n-                      -- then we need to use it in the package path.\n-                      \"../\" <> (case Map.lookup pkgId pm of\n-                                   Just (Just name, _) -> unPackageName name\n-                                   Just (Nothing, _) -> unPackageId pkgId\n-                                   Nothing -> error \"IMPOSSIBLE : package map malformed\"\n-                               ) <> \"/\"\n-            , let modNameStr = genModuleRef modRef\n-            ]\n-        defs = map (\\(def, ser) -> def ++ ser) defSers\n-    in\n-    Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n+    let (defSers, refs) = unzip (map (genDataDef curPkgId mod tpls) serDefs)\n+        imports = [ importDecl pm modRef rootPath\n+                  | modRef@(pkgRef, _) <- modRefs refs\n+                  , let rootPath = pkgRootPath modName pkgRef ]\n+        defs = map biconcat defSers\n+        modText = T.unlines $ intercalate [\"\"] $ filter (not . null) $ modHeader : imports : defs\n+        depends = [ Dependency . T.unpack $ pkgRefStr pm pkgRef\n+                  | (pkgRef, _) <- modRefs refs, pkgRef /= PRSelf ]\n+   in Just (modText, depends)\n   where\n+    modName = moduleName mod\n+    tpls = moduleTemplates mod\n     serDefs = defDataTypes mod\n+    modRefs refs = Set.toList ((PRSelf, modName) `Set.delete` Set.unions refs)\n+    modHeader =\n+      [ \"// Generated from \" <> T.intercalate \"/\" (unModuleName modName) <> \".daml\"\n+      , \"/* eslint-disable @typescript-eslint/camelcase */\"\n+      , \"/* eslint-disable @typescript-eslint/no-use-before-define */\"\n+      , \"import * as jtv from '@mojotech/json-type-validation';\"\n+      , \"import * as daml from '@daml/types';\"\n+      ]\n+\n+    -- Calculate an import declaration.\n+    importDecl :: Map.Map PackageId (Maybe PackageName, Package) ->\n+                      (PackageRef, ModuleName) -> T.Text -> T.Text\n+    importDecl pm modRef@(pkgRef, modName) rootPath =\n+      \"import * as \" <>  genModuleRef modRef <> \" from '\" <>\n+      T.intercalate \"/\" ((rootPath : pkgRefStr pm pkgRef : [\"lib\" | pkgRef /= PRSelf]) ++ unModuleName modName) <>\n+      \"';\"\n+\n+    -- Produce a package name for a package ref.\n+    pkgRefStr :: Map.Map PackageId (Maybe PackageName, Package) -> PackageRef -> T.Text\n+    pkgRefStr pm = \\case\n+      PRSelf -> \"\"\n+      PRImport pkgId ->\n+        maybe (error \"IMPOSSIBLE : package map malformed\")\n+        (\\(mbPkgName, _) -> T.pack $ packageNameStr pkgId mbPkgName)"
  },
  {
    "id" : "b04a0b85-080d-49ec-b0bf-c6ec9bb7a032",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "7aac386c-5e44-446b-bbfd-6cce706a83c4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Renamings like this in such a big PR make the PR even harder to review. 😓 ",
        "createdAt" : "2020-03-04T19:42:00Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a6542ac5-03c0-42cb-b790-f866a63153aa",
        "parentId" : "7aac386c-5e44-446b-bbfd-6cce706a83c4",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok. I'm sorry.",
        "createdAt" : "2020-03-04T21:23:18Z",
        "updatedAt" : "2020-03-04T21:23:18Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 317,
    "diffHunk" : "@@ -344,23 +444,27 @@ genDefDataType curPkgId conName mod tpls def =\n         -- definition.\n         serFromDef f c2 = f . snd . fst . genDefDataType curPkgId (conName <.> c2) mod tpls\n \n+infixr 6 <.> -- This is the same fixity as '<>'.\n+(<.>) :: T.Text -> T.Text -> T.Text\n+(<.>) u v = u <> \".\" <> v\n+\n genType :: ModuleName -> Type -> (T.Text, T.Text)\n genType curModName = go\n   where\n     go = \\case\n-        TVar v -> dup (unTypeVarName v)\n+        TVar v -> dupe (unTypeVarName v)"
  },
  {
    "id" : "b00c61a2-8fb5-41dd-afc6-28af11c72007",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "dabafb44-5f5a-4f61-9523-f3c445822a8a",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That's indented too deep:\r\n```suggestion\r\n    , \"  },\"\r\n```",
        "createdAt" : "2020-03-04T19:42:45Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e3de2b34-506e-4d83-bafd-073f129ce631",
        "parentId" : "dabafb44-5f5a-4f61-9523-f3c445822a8a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Noted. Will fix.",
        "createdAt" : "2020-03-04T21:23:31Z",
        "updatedAt" : "2020-03-04T21:23:31Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e55a2a08-7044-4363-91dd-6878e58af93e",
        "parentId" : "dabafb44-5f5a-4f61-9523-f3c445822a8a",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Fixed in https://github.com/digital-asset/daml/pull/4818.",
        "createdAt" : "2020-03-04T21:37:00Z",
        "updatedAt" : "2020-03-04T21:37:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 385,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\""
  },
  {
    "id" : "13e05df1-0a15-45c8-b559-e3a9a7cbc618",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "18163c95-f896-4d54-b57a-719281ffa5f6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It's not clear to me that this is the right thing to do. For now, I would leave the `license` field out until we have a better idea.",
        "createdAt" : "2020-03-04T19:44:00Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8c9f2aab-6fda-4e00-9436-9503946f015d",
        "parentId" : "18163c95-f896-4d54-b57a-719281ffa5f6",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-03-04T21:23:49Z",
        "updatedAt" : "2020-03-04T21:23:49Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 421,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\""
  },
  {
    "id" : "cd01cd45-d9af-49be-bde7-0caed8f03b47",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "f229f4b8-46c8-434b-bf87-06eec9020c51",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We need to make these version numbers easier configurable. I suggest to put constants somewhere close to the top of the file.",
        "createdAt" : "2020-03-04T19:44:53Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cd184e7b-483a-41f3-8d5f-28af91911930",
        "parentId" : "f229f4b8-46c8-434b-bf87-06eec9020c51",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-03-04T21:24:01Z",
        "updatedAt" : "2020-03-04T21:24:02Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4b5f2c3e-6450-4807-89d1-7e445519a3d7",
        "parentId" : "f229f4b8-46c8-434b-bf87-06eec9020c51",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4878",
        "createdAt" : "2020-03-06T14:10:31Z",
        "updatedAt" : "2020-03-06T14:10:31Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 432,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++\n+    [\"  },\"\n+    , \"  \\\"scripts\\\": {\"\n+    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n+    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n+    , \"  },\"\n+    , \"  \\\"devDependencies\\\": {\"\n+    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\""
  },
  {
    "id" : "9906efa5-a964-4de4-83cf-bfaa9a2db9f8",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "9a6713db-6689-44e8-941f-5e66ad91f598",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If you put `json-type-validation` as the last dependency, you'd get out of the business of figuring out where the commas go and remove complexity.",
        "createdAt" : "2020-03-04T19:47:03Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "75fa4338-bcb6-4606-80c4-00df1f5d98cf",
        "parentId" : "9a6713db-6689-44e8-941f-5e66ad91f598",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Fair enough. Will fix.",
        "createdAt" : "2020-03-04T21:24:40Z",
        "updatedAt" : "2020-03-04T21:24:41Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "41859c08-d48b-469a-ab7f-7957b92e5385",
        "parentId" : "9a6713db-6689-44e8-941f-5e66ad91f598",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4859",
        "createdAt" : "2020-03-05T18:34:00Z",
        "updatedAt" : "2020-03-05T18:34:00Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 425,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++"
  },
  {
    "id" : "3bcb9f6b-e62f-4279-919c-534ae98ca91c",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "6b6a1784-7470-40c4-aad7-4b5a902298ba",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I have no clue what `ldr` stands for. Can we please give this variable a more descriptive name?",
        "createdAt" : "2020-03-04T19:50:46Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "081923cd-a94b-4a07-9515-c03b0ae0d730",
        "parentId" : "6b6a1784-7470-40c4-aad7-4b5a902298ba",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "\"Leader\". Yes.",
        "createdAt" : "2020-03-04T21:24:55Z",
        "updatedAt" : "2020-03-04T21:24:56Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "eb83a01d-be83-4f9a-b86d-35f0c81f8516",
        "parentId" : "6b6a1784-7470-40c4-aad7-4b5a902298ba",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Changed in https://github.com/digital-asset/daml/pull/4818 to `scope`.",
        "createdAt" : "2020-03-05T13:49:17Z",
        "updatedAt" : "2020-03-05T13:49:17Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 485,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++\n+    [\"  },\"\n+    , \"  \\\"scripts\\\": {\"\n+    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n+    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n+    , \"  },\"\n+    , \"  \\\"devDependencies\\\": {\"\n+    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n+    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n+    , \"  }\"\n+    , \"}\"\n+    ])\n+  where\n+    packageName =  packageNameOfPackageDir packageDir\n+    dependencies = withCommas [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> packageVersion <> \"\\\"\"\n+                              | d <- depends\n+                              , let pkg = scope ++ \"/\" ++ undependency d\n+                              ]\n+\n+    withCommas :: [String] -> [String]\n+    withCommas [] = []\n+    withCommas ms = reverse (head ms' : map (++\",\") (tail ms')) where ms' = reverse ms\n+\n+-- This type describes the format of a \"top-level\" 'package.json'. We\n+-- expect such files to have the format\n+-- {\n+--   \"private\": true,\n+--   \"workspaces: [\n+--      \"path/to/foo\",\n+--      \"path/to/bar\",\n+--      ...\n+--   ]\n+-- }\n+data PackageJson = PackageJson\n+  {  private :: Bool\n+  ,  workspaces :: [T.Text]\n+  } deriving Show\n+-- Explicitly provide instances to avoid relying on restricted\n+-- extension 'DeriveGeneric'.\n+instance FromJSON PackageJson where\n+  parseJSON (Object v) = PackageJson\n+      <$> v .: \"private\"\n+      <*> v .: \"workspaces\"\n+  parseJSON _ = mzero\n+instance ToJSON PackageJson where\n+  toJSON (PackageJson private workspaces) =\n+    object [ \"private\" .= private\n+           , \"workspaces\" .= workspaces\n+           ]\n+\n+-- Read the provided 'package.json'; transform it to include the\n+-- provided workspaces; write it back to disk.\n+writeTopLevelPackageJson :: FilePath -> [(String, String, [Dependency])] -> FilePath -> IO ()\n+writeTopLevelPackageJson optOutputDir dependencies file = do\n+  let (g, nodeFromVertex) = graphFromEdges'\n+        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\n+      ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n+        -- Topologically order our packages.\n+      ldr = fromJust (stripPrefix \"@\" (unscope (scopeOfScopeDir optOutputDir)))"
  },
  {
    "id" : "8cb9b144-c5a3-438c-becc-ddd94d49c8c7",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "8d9313aa-e326-44d0-9da3-f73205b6c2d2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Make `ldr` a `T.Text` and\r\n```suggestion\r\n            filter (not . T.isPrefixOf ldr) (workspace oldPackageJson)\r\n```",
        "createdAt" : "2020-03-04T19:54:21Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5b9ca2b8-df0f-4802-886b-fe6e4e42e6cc",
        "parentId" : "8d9313aa-e326-44d0-9da3-f73205b6c2d2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-03-04T21:25:23Z",
        "updatedAt" : "2020-03-04T21:25:24Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a78618fc-6dc1-465b-916f-3e3cf2705cbe",
        "parentId" : "8d9313aa-e326-44d0-9da3-f73205b6c2d2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4859",
        "createdAt" : "2020-03-05T18:26:25Z",
        "updatedAt" : "2020-03-05T18:26:25Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 502,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++\n+    [\"  },\"\n+    , \"  \\\"scripts\\\": {\"\n+    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n+    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n+    , \"  },\"\n+    , \"  \\\"devDependencies\\\": {\"\n+    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n+    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n+    , \"  }\"\n+    , \"}\"\n+    ])\n+  where\n+    packageName =  packageNameOfPackageDir packageDir\n+    dependencies = withCommas [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> packageVersion <> \"\\\"\"\n+                              | d <- depends\n+                              , let pkg = scope ++ \"/\" ++ undependency d\n+                              ]\n+\n+    withCommas :: [String] -> [String]\n+    withCommas [] = []\n+    withCommas ms = reverse (head ms' : map (++\",\") (tail ms')) where ms' = reverse ms\n+\n+-- This type describes the format of a \"top-level\" 'package.json'. We\n+-- expect such files to have the format\n+-- {\n+--   \"private\": true,\n+--   \"workspaces: [\n+--      \"path/to/foo\",\n+--      \"path/to/bar\",\n+--      ...\n+--   ]\n+-- }\n+data PackageJson = PackageJson\n+  {  private :: Bool\n+  ,  workspaces :: [T.Text]\n+  } deriving Show\n+-- Explicitly provide instances to avoid relying on restricted\n+-- extension 'DeriveGeneric'.\n+instance FromJSON PackageJson where\n+  parseJSON (Object v) = PackageJson\n+      <$> v .: \"private\"\n+      <*> v .: \"workspaces\"\n+  parseJSON _ = mzero\n+instance ToJSON PackageJson where\n+  toJSON (PackageJson private workspaces) =\n+    object [ \"private\" .= private\n+           , \"workspaces\" .= workspaces\n+           ]\n+\n+-- Read the provided 'package.json'; transform it to include the\n+-- provided workspaces; write it back to disk.\n+writeTopLevelPackageJson :: FilePath -> [(String, String, [Dependency])] -> FilePath -> IO ()\n+writeTopLevelPackageJson optOutputDir dependencies file = do\n+  let (g, nodeFromVertex) = graphFromEdges'\n+        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\n+      ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n+        -- Topologically order our packages.\n+      ldr = fromJust (stripPrefix \"@\" (unscope (scopeOfScopeDir optOutputDir)))\n+        -- 'ldr' we expect to be something like \"daml2ts/\".\n+  let ourPackages = map (T.pack . ((ldr ++ \"/\") ++)) ps\n+  bytes <- BSL.readFile file\n+  maybe\n+    (fail $ \"Error decoding JSON from '\" <> file <> \"'\")\n+    (transformAndWrite ourPackages ldr)\n+    (decode bytes :: Maybe PackageJson)\n+  where\n+    transformAndWrite :: [T.Text] -> String -> PackageJson -> IO ()\n+    transformAndWrite ourPackages ldr oldPackageJson = do\n+      let damlTypes = [T.pack \"daml-types\"]\n+      --   * Old versions of our packages should be removed;\n+          keepPackages =\n+            [ T.pack x\n+            | x <- [T.unpack y | y <- workspaces oldPackageJson]\n+            , isNothing $ stripPrefix ldr x\n+            ]"
  },
  {
    "id" : "7f13dffe-efdc-4275-8321-2fe1800b1251",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "9791057d-ef88-478e-af92-70daa16ab53b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why do you hate `case ... of` so much?",
        "createdAt" : "2020-03-04T19:55:23Z",
        "updatedAt" : "2020-03-04T19:56:00Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "efd1a50e-27fd-486e-8f42-cd62b836cd60",
        "parentId" : "9791057d-ef88-478e-af92-70daa16ab53b",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok, I got the message.",
        "createdAt" : "2020-03-04T21:26:10Z",
        "updatedAt" : "2020-03-04T21:42:41Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5ef282a3-5827-4960-a562-8a35292eb82a",
        "parentId" : "9791057d-ef88-478e-af92-70daa16ab53b",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-03-05T13:51:23Z",
        "updatedAt" : "2020-03-05T13:51:24Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 505,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++\n+    [\"  },\"\n+    , \"  \\\"scripts\\\": {\"\n+    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n+    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n+    , \"  },\"\n+    , \"  \\\"devDependencies\\\": {\"\n+    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n+    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n+    , \"  }\"\n+    , \"}\"\n+    ])\n+  where\n+    packageName =  packageNameOfPackageDir packageDir\n+    dependencies = withCommas [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> packageVersion <> \"\\\"\"\n+                              | d <- depends\n+                              , let pkg = scope ++ \"/\" ++ undependency d\n+                              ]\n+\n+    withCommas :: [String] -> [String]\n+    withCommas [] = []\n+    withCommas ms = reverse (head ms' : map (++\",\") (tail ms')) where ms' = reverse ms\n+\n+-- This type describes the format of a \"top-level\" 'package.json'. We\n+-- expect such files to have the format\n+-- {\n+--   \"private\": true,\n+--   \"workspaces: [\n+--      \"path/to/foo\",\n+--      \"path/to/bar\",\n+--      ...\n+--   ]\n+-- }\n+data PackageJson = PackageJson\n+  {  private :: Bool\n+  ,  workspaces :: [T.Text]\n+  } deriving Show\n+-- Explicitly provide instances to avoid relying on restricted\n+-- extension 'DeriveGeneric'.\n+instance FromJSON PackageJson where\n+  parseJSON (Object v) = PackageJson\n+      <$> v .: \"private\"\n+      <*> v .: \"workspaces\"\n+  parseJSON _ = mzero\n+instance ToJSON PackageJson where\n+  toJSON (PackageJson private workspaces) =\n+    object [ \"private\" .= private\n+           , \"workspaces\" .= workspaces\n+           ]\n+\n+-- Read the provided 'package.json'; transform it to include the\n+-- provided workspaces; write it back to disk.\n+writeTopLevelPackageJson :: FilePath -> [(String, String, [Dependency])] -> FilePath -> IO ()\n+writeTopLevelPackageJson optOutputDir dependencies file = do\n+  let (g, nodeFromVertex) = graphFromEdges'\n+        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\n+      ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n+        -- Topologically order our packages.\n+      ldr = fromJust (stripPrefix \"@\" (unscope (scopeOfScopeDir optOutputDir)))\n+        -- 'ldr' we expect to be something like \"daml2ts/\".\n+  let ourPackages = map (T.pack . ((ldr ++ \"/\") ++)) ps\n+  bytes <- BSL.readFile file\n+  maybe\n+    (fail $ \"Error decoding JSON from '\" <> file <> \"'\")\n+    (transformAndWrite ourPackages ldr)\n+    (decode bytes :: Maybe PackageJson)\n+  where\n+    transformAndWrite :: [T.Text] -> String -> PackageJson -> IO ()\n+    transformAndWrite ourPackages ldr oldPackageJson = do\n+      let damlTypes = [T.pack \"daml-types\"]\n+      --   * Old versions of our packages should be removed;\n+          keepPackages =\n+            [ T.pack x\n+            | x <- [T.unpack y | y <- workspaces oldPackageJson]\n+            , isNothing $ stripPrefix ldr x\n+            ]\n+      --  * Our packages need to come after 'daml-types' if it exists;\n+      --  * Our packages need to come before any other existing packages.\n+          allPackages = maybe"
  },
  {
    "id" : "ce6951fb-3981-44bd-b9c7-7420c10c7e7f",
    "prId" : 4799,
    "comments" : [
      {
        "id" : "80756789-2d40-4203-b85b-cdbb02f24570",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We can remove the special case for `daml-types`, which is actually `@daml/types` once https://github.com/digital-asset/daml/pull/4820 has landed. The only reason why you would need this is when you don't get `@daml/types` from npmjs.com but rather have it somehow local, as we do in our tests. However, we can also use the `resolutions` field in the workspace `package.json` to point to our local version of `@daml/types`, as in https://github.com/digital-asset/daml/pull/4820.",
        "createdAt" : "2020-03-05T00:18:49Z",
        "updatedAt" : "2020-03-05T00:18:49Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8de13f0b-13eb-4fee-bf1b-2e09254609c8",
        "parentId" : "80756789-2d40-4203-b85b-cdbb02f24570",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "In other words, the packages generated by `daml2ts` go first, everything else comes afterwards. This should simplify the code here quite a bit.",
        "createdAt" : "2020-03-05T00:20:05Z",
        "updatedAt" : "2020-03-05T00:20:05Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3255c81e-a718-4464-a487-5f98bd2e6215",
        "parentId" : "80756789-2d40-4203-b85b-cdbb02f24570",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yes, got it. Will implement.",
        "createdAt" : "2020-03-05T00:33:21Z",
        "updatedAt" : "2020-03-05T00:33:21Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "df11af9e-5641-45ab-ab0d-a2c64cfe1299",
        "parentId" : "80756789-2d40-4203-b85b-cdbb02f24570",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "https://github.com/digital-asset/daml/pull/4859",
        "createdAt" : "2020-03-05T18:24:16Z",
        "updatedAt" : "2020-03-05T18:24:17Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "516a9a33965e2db029a67edd5bcf173e1f360b77",
    "line" : 503,
    "diffHunk" : "@@ -421,10 +525,155 @@ genModuleRef (pkgRef, modName) = case pkgRef of\n onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n-    x:xs -> f x:xs\n+    x : xs -> f x : xs\n \n onLast :: (a -> a) -> [a] -> [a]\n onLast f = \\case\n     [] -> []\n     [l] -> [f l]\n     x : xs -> x : onLast f xs\n+\n+writeTsConfig :: FilePath -> IO ()\n+writeTsConfig dir = writeFileUTF8 (dir </> \"tsconfig.json\") $ unlines\n+    [ \"{\"\n+    , \"  \\\"compilerOptions\\\": {\"\n+    , \"    \\\"target\\\": \\\"es5\\\",\"\n+    , \"    \\\"lib\\\": [\"\n+    , \"      \\\"dom\\\",\"\n+    , \"      \\\"es2015\\\"\"\n+    , \"     ],\"\n+    , \"    \\\"strict\\\": true,\"\n+    , \"    \\\"noUnusedLocals\\\": true,\"\n+    , \"    \\\"noUnusedParameters\\\": false,\"\n+    , \"    \\\"noImplicitReturns\\\": true,\"\n+    , \"    \\\"noFallthroughCasesInSwitch\\\": true,\"\n+    , \"    \\\"outDir\\\": \\\"lib\\\",\"\n+    , \"    \\\"module\\\": \\\"commonjs\\\",\"\n+    , \"    \\\"declaration\\\": true,\"\n+    , \"    \\\"sourceMap\\\": true\"\n+    , \"    },\"\n+    , \"  \\\"include\\\": [\\\"src/**/*.ts\\\"],\"\n+    , \"}\"\n+    ]\n+\n+writeEsLintConfig :: FilePath -> IO ()\n+writeEsLintConfig dir = writeFileUTF8 (dir </> \".eslintrc.json\") $ unlines\n+  [ \"{\"\n+  , \"  \\\"parser\\\": \\\"@typescript-eslint/parser\\\",\"\n+  , \"  \\\"parserOptions\\\": {\"\n+  , \"    \\\"project\\\": \\\"./tsconfig.json\\\"\"\n+  , \"  },\"\n+  , \"  \\\"plugins\\\": [\"\n+  , \"    \\\"@typescript-eslint\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"extends\\\": [\"\n+  , \"    \\\"eslint:recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/eslint-recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended\\\",\"\n+  , \"    \\\"plugin:@typescript-eslint/recommended-requiring-type-checking\\\"\"\n+  , \"  ],\"\n+  , \"  \\\"rules\\\": {\"\n+  , \"    \\\"@typescript-eslint/explicit-function-return-type\\\": \\\"off\\\",\"\n+  , \"    \\\"@typescript-eslint/no-inferrable-types\\\": \\\"off\\\"\"\n+  , \"  }\"\n+  , \"}\"\n+  ]\n+\n+writePackageJson :: FilePath -> String -> String -> Scope -> [Dependency] -> IO ()\n+writePackageJson packageDir damlTypesVersion packageVersion (Scope scope) depends =\n+  writeFileUTF8 (packageDir </> \"package.json\") $ unlines\n+  ([\"{\"\n+   , \"  \\\"private\\\": true,\"\n+   , \"  \\\"name\\\": \\\"\" <> packageName <> \"\\\",\"\n+   , \"  \\\"version\\\": \\\"\" <> packageVersion <> \"\\\",\"\n+   , \"  \\\"description\\\": \\\"Produced by daml2ts\\\",\"\n+   , \"  \\\"license\\\": \\\"Apache-2.0\\\",\"\n+   , \"  \\\"dependencies\\\": {\"\n+   , \"    \\\"@daml/types\\\": \\\"\" <> damlTypesVersion <> \"\\\",\"\n+   , \"    \\\"@mojotech/json-type-validation\\\": \\\"^3.1.0\\\"\" ++ if not $ null dependencies then \", \" else \"\"\n+   ] ++ dependencies ++\n+    [\"  },\"\n+    , \"  \\\"scripts\\\": {\"\n+    , \"    \\\"build\\\": \\\"tsc --build\\\",\"\n+    , \"    \\\"lint\\\": \\\"eslint --ext .ts src/ --max-warnings 0\\\"\"\n+    , \"  },\"\n+    , \"  \\\"devDependencies\\\": {\"\n+    , \"    \\\"@typescript-eslint/eslint-plugin\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"@typescript-eslint/parser\\\": \\\"^2.11.0\\\",\"\n+    , \"    \\\"eslint\\\": \\\"^6.7.2\\\",\"\n+    , \"    \\\"typescript\\\": \\\"~3.7.3\\\"\"\n+    , \"  }\"\n+    , \"}\"\n+    ])\n+  where\n+    packageName =  packageNameOfPackageDir packageDir\n+    dependencies = withCommas [ \"    \\\"\" <> pkg <> \"\\\": \\\"\" <> packageVersion <> \"\\\"\"\n+                              | d <- depends\n+                              , let pkg = scope ++ \"/\" ++ undependency d\n+                              ]\n+\n+    withCommas :: [String] -> [String]\n+    withCommas [] = []\n+    withCommas ms = reverse (head ms' : map (++\",\") (tail ms')) where ms' = reverse ms\n+\n+-- This type describes the format of a \"top-level\" 'package.json'. We\n+-- expect such files to have the format\n+-- {\n+--   \"private\": true,\n+--   \"workspaces: [\n+--      \"path/to/foo\",\n+--      \"path/to/bar\",\n+--      ...\n+--   ]\n+-- }\n+data PackageJson = PackageJson\n+  {  private :: Bool\n+  ,  workspaces :: [T.Text]\n+  } deriving Show\n+-- Explicitly provide instances to avoid relying on restricted\n+-- extension 'DeriveGeneric'.\n+instance FromJSON PackageJson where\n+  parseJSON (Object v) = PackageJson\n+      <$> v .: \"private\"\n+      <*> v .: \"workspaces\"\n+  parseJSON _ = mzero\n+instance ToJSON PackageJson where\n+  toJSON (PackageJson private workspaces) =\n+    object [ \"private\" .= private\n+           , \"workspaces\" .= workspaces\n+           ]\n+\n+-- Read the provided 'package.json'; transform it to include the\n+-- provided workspaces; write it back to disk.\n+writeTopLevelPackageJson :: FilePath -> [(String, String, [Dependency])] -> FilePath -> IO ()\n+writeTopLevelPackageJson optOutputDir dependencies file = do\n+  let (g, nodeFromVertex) = graphFromEdges'\n+        (map (\\(a, b, ds) -> (a, b, map undependency ds)) dependencies)\n+      ps = map (fst3 . nodeFromVertex) $ reverse (topSort g)\n+        -- Topologically order our packages.\n+      ldr = fromJust (stripPrefix \"@\" (unscope (scopeOfScopeDir optOutputDir)))\n+        -- 'ldr' we expect to be something like \"daml2ts/\".\n+  let ourPackages = map (T.pack . ((ldr ++ \"/\") ++)) ps\n+  bytes <- BSL.readFile file\n+  maybe\n+    (fail $ \"Error decoding JSON from '\" <> file <> \"'\")\n+    (transformAndWrite ourPackages ldr)\n+    (decode bytes :: Maybe PackageJson)\n+  where\n+    transformAndWrite :: [T.Text] -> String -> PackageJson -> IO ()\n+    transformAndWrite ourPackages ldr oldPackageJson = do\n+      let damlTypes = [T.pack \"daml-types\"]\n+      --   * Old versions of our packages should be removed;\n+          keepPackages =\n+            [ T.pack x\n+            | x <- [T.unpack y | y <- workspaces oldPackageJson]\n+            , isNothing $ stripPrefix ldr x\n+            ]\n+      --  * Our packages need to come after 'daml-types' if it exists;"
  },
  {
    "id" : "988be20b-c401-41ab-9e70-0865992259f4",
    "prId" : 4677,
    "comments" : [
      {
        "id" : "d6a3e001-4b84-4b77-ab72-dfc8b477db65",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Might be slightly simpler if you go for `Either Text` and then do the conversion at the call site (or just use `Data.Text.IO.putStrLn`).",
        "createdAt" : "2020-02-24T18:48:15Z",
        "updatedAt" : "2020-02-24T19:01:44Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7bbbff0e-37c5-4a6e-a46a-4d2dffabf0b7",
        "parentId" : "d6a3e001-4b84-4b77-ab72-dfc8b477db65",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ever so slightly. Did that.",
        "createdAt" : "2020-02-24T19:00:21Z",
        "updatedAt" : "2020-02-24T19:01:44Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3b9d969a823c3ba1d5837388aabcf5f3624625ee",
    "line" : null,
    "diffHunk" : "@@ -47,36 +47,38 @@ optionsParserInfo = info (optionsParser <**> helper)\n     <> progDesc \"Generate TypeScript bindings from a DAR\"\n     )\n \n-readPackages :: [FilePath] -> IO [(PackageId, (Package, Maybe String))]\n+readPackages :: [FilePath] -> IO [(PackageId, (Package, Maybe PackageName))]\n readPackages dars = concatMapM readPackage dars\n   where\n+    readPackage :: FilePath -> IO [(PackageId, (Package, Maybe PackageName))]\n     readPackage dar = do\n       dar <- B.readFile dar\n       let archive = Zip.toArchive $ BSL.fromStrict dar\n       dalfs <- either fail pure $ DAR.readDalfs archive\n       DAR.DalfManifest{packageName} <- either fail pure $ DAR.readDalfManifest archive\n+      packageName <- pure (PackageName . T.pack <$> packageName)\n       forM ((DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)) $\n         \\(dalf, mbPkgName) -> do\n           (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n           pure (pkgId, (pkg, mbPkgName))\n \n-mergePackageMap :: [(PackageId, (Package, Maybe String))] -> Either String (Map.Map PackageId (Maybe String, Package))\n+mergePackageMap :: [(PackageId, (Package, Maybe PackageName))] -> Either String (Map.Map PackageId (Maybe PackageName, Package))"
  },
  {
    "id" : "8308a088-08aa-403d-9d65-dd108c993fd6",
    "prId" : 4677,
    "comments" : [
      {
        "id" : "aad53997-bc30-498f-b98b-9a75dc7cb381",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why did you remove the `let`s? OCaml's `let x = ... in let y = ... in ...` is superior to Haskell's `let { x = ...; y = ... } in ...`, which is basically a huge footgun.",
        "createdAt" : "2020-02-24T19:16:57Z",
        "updatedAt" : "2020-02-24T19:17:10Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7de349ac-a465-4601-abb0-24e65c4b7065",
        "parentId" : "aad53997-bc30-498f-b98b-9a75dc7cb381",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "We had,\r\n```haskell\r\n  let x = ...\r\n  let y = ...\r\n  ...\r\n```\r\nin a monadic context. I replaced with,\r\n```haskell\r\nlet x = ...\r\n      y = ...\r\n      ...\r\n```\r\nas I believed it to be more idiomatic? You want I restore it?\r\n",
        "createdAt" : "2020-02-24T19:18:59Z",
        "updatedAt" : "2020-02-24T19:22:16Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "56932ff4-6f14-4d56-90fc-e49673ae63a2",
        "parentId" : "aad53997-bc30-498f-b98b-9a75dc7cb381",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Let me know if so and I'll do so in a follow up PR!",
        "createdAt" : "2020-02-24T19:28:08Z",
        "updatedAt" : "2020-02-24T19:28:09Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4f5f4dcd-36e7-4e83-9c7c-8fa8c23af89c",
        "parentId" : "aad53997-bc30-498f-b98b-9a75dc7cb381",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't know which one is more idiomatic. Let's go with the safer version then, i.e., the old version.",
        "createdAt" : "2020-02-25T13:01:51Z",
        "updatedAt" : "2020-02-25T13:01:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3b9d969a823c3ba1d5837388aabcf5f3624625ee",
    "line" : 56,
    "diffHunk" : "@@ -85,19 +87,19 @@ main = do\n     opts@Options{..} <- execParser optionsParserInfo\n     ps <- readPackages optInputDars\n     case mergePackageMap ps of\n-      Left err -> fail err\n+      Left err -> fail . T.unpack $ err\n       Right pm ->\n         forM_ (Map.toList pm) $\n         \\(pkgId, (mbPkgName, pkg)) -> do\n           let id = show $ unPackageId pkgId\n-          let name = fromMaybe id mbPkgName\n-          let asName = if name == id then \"itself\" else name\n+              name = maybe id (T.unpack . unPackageName) mbPkgName"
  },
  {
    "id" : "31900dac-caa7-438c-a9e6-7891d3d50b0e",
    "prId" : 4658,
    "comments" : [
      {
        "id" : "af85493f-b3d1-4a5b-8136-e02abbec66db",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’m confused, how did this compile before? Was this not a redundant import?",
        "createdAt" : "2020-02-21T18:21:30Z",
        "updatedAt" : "2020-02-22T00:57:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "61046b2c-7119-49f2-be39-36d9816295d1",
        "parentId" : "af85493f-b3d1-4a5b-8136-e02abbec66db",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "We have `Control.Monad.Extra` and I introduced `Control.Monad` sort of accidentally in a prior commit. I'm fixing that. No, it didn't get flagged as redundant.",
        "createdAt" : "2020-02-21T18:36:40Z",
        "updatedAt" : "2020-02-22T00:57:51Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ab34a62c-b9d3-47f2-aaa1-7a973d9ffc19",
        "parentId" : "af85493f-b3d1-4a5b-8136-e02abbec66db",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Hm, interesting. Not sure why GHC did not detect this.",
        "createdAt" : "2020-02-21T18:39:33Z",
        "updatedAt" : "2020-02-22T00:57:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "2fe5f13e0244d38e16379868ab482be336171b59",
    "line" : 4,
    "diffHunk" : "@@ -14,7 +14,6 @@ import qualified Data.Text.Extended as T\n import qualified \"zip-archive\" Codec.Archive.Zip as Zip\n import qualified Data.Map as Map\n \n-import Control.Monad"
  },
  {
    "id" : "36b4321a-377b-464a-980e-cbcee4f55ea0",
    "prId" : 4641,
    "comments" : [
      {
        "id" : "23005197-592c-4112-ad4a-f688b2573453",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You are still trying to do multiple things at once. As suggested before I would split this up:\r\n1. First read each DAR independently. This requires IO but it should be just a `mapM` or something like that.\r\n2. Then merge the info you got from reading the DARs and detect things like name collisions. This does not require IO.\r\n3. Then either print the errors and exit or run the codegen.",
        "createdAt" : "2020-02-21T07:35:46Z",
        "updatedAt" : "2020-02-21T13:03:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6043f6d0-f7e6-49f4-b974-6895ccf054c1",
        "parentId" : "23005197-592c-4112-ad4a-f688b2573453",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-02-21T12:08:12Z",
        "updatedAt" : "2020-02-21T13:03:12Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6212f8d24de0d54ef0b34ec38df863b13baad205",
    "line" : null,
    "diffHunk" : "@@ -47,63 +47,66 @@ optionsParserInfo = info (optionsParser <**> helper)\n     <> progDesc \"Generate TypeScript bindings from a DAR\"\n     )\n \n+-- Each package has a unique ID and is perhaps ascribed a symbolic\n+-- name (that is, if a given package has been determined to be the\n+-- \"main-package\" of some DAR).\n+type PackageMap = Map.Map PackageId (Maybe String, Package)\n+\n+-- Merge a DAR into a package map (two DARs may have one or more\n+-- packages in common). Merging fails and an IO exception is raised\n+-- if:\n+--   * Two packages are ascribed the same symbolic name;\n+--   * A single package is ascribed two different names.\n+mergePackageMap :: PackageMap -> FilePath -> IO PackageMap"
  },
  {
    "id" : "7d5d53cc-b545-481c-b12c-aa86c4007f44",
    "prId" : 4641,
    "comments" : [
      {
        "id" : "5e3050e9-fba8-4fec-9d80-d4cc1460d9c5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I find this part very hard to read. `maybe (pure ()) f mb ` should be equivalent to `whenJust mb f` but this might just be easier to read with a pattern match.",
        "createdAt" : "2020-02-21T07:40:09Z",
        "updatedAt" : "2020-02-21T13:03:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e5b58c87-9520-4a53-b5dd-5c8f5bfe532e",
        "parentId" : "5e3050e9-fba8-4fec-9d80-d4cc1460d9c5",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-02-21T12:08:18Z",
        "updatedAt" : "2020-02-21T13:03:12Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6212f8d24de0d54ef0b34ec38df863b13baad205",
    "line" : null,
    "diffHunk" : "@@ -47,63 +47,66 @@ optionsParserInfo = info (optionsParser <**> helper)\n     <> progDesc \"Generate TypeScript bindings from a DAR\"\n     )\n \n+-- Each package has a unique ID and is perhaps ascribed a symbolic\n+-- name (that is, if a given package has been determined to be the\n+-- \"main-package\" of some DAR).\n+type PackageMap = Map.Map PackageId (Maybe String, Package)\n+\n+-- Merge a DAR into a package map (two DARs may have one or more\n+-- packages in common). Merging fails and an IO exception is raised\n+-- if:\n+--   * Two packages are ascribed the same symbolic name;\n+--   * A single package is ascribed two different names.\n+mergePackageMap :: PackageMap -> FilePath -> IO PackageMap\n+mergePackageMap pkgs dar = do\n+  dar <- B.readFile dar\n+  let archive = Zip.toArchive $ BSL.fromStrict dar\n+  dalfs <- either fail pure $ DAR.readDalfs archive\n+  DAR.DalfManifest{packageName} <- either fail pure $ DAR.readDalfManifest archive\n+  let allDalfsInDar = (DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)\n+  foldM merge pkgs allDalfsInDar\n+  where\n+    merge :: PackageMap -> (BSL.ByteString, Maybe String) -> IO PackageMap\n+    merge pkgs (dalf, mbPkgName) = do\n+      (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n+      -- Check for errors.\n+      let pkgNames = mapMaybe fst (Map.elems pkgs)\n+      maybe (maybe (pure ())"
  },
  {
    "id" : "18579c10-d2ed-43cb-9c73-048a7ef58472",
    "prId" : 4641,
    "comments" : [
      {
        "id" : "2aef55ca-5ec7-408b-a9f9-3509b59d59f6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I find these kind of type synonyms to be more confusing than helpful. Either turn it into a newtype or inline it.",
        "createdAt" : "2020-02-21T07:41:29Z",
        "updatedAt" : "2020-02-21T13:03:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "421e9b44-305a-41db-ae95-473f0855ea07",
        "parentId" : "2aef55ca-5ec7-408b-a9f9-3509b59d59f6",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok",
        "createdAt" : "2020-02-21T12:08:25Z",
        "updatedAt" : "2020-02-21T13:03:12Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6212f8d24de0d54ef0b34ec38df863b13baad205",
    "line" : null,
    "diffHunk" : "@@ -47,63 +47,66 @@ optionsParserInfo = info (optionsParser <**> helper)\n     <> progDesc \"Generate TypeScript bindings from a DAR\"\n     )\n \n+-- Each package has a unique ID and is perhaps ascribed a symbolic\n+-- name (that is, if a given package has been determined to be the\n+-- \"main-package\" of some DAR).\n+type PackageMap = Map.Map PackageId (Maybe String, Package)"
  },
  {
    "id" : "783172e3-9ad9-4831-8fa4-bea67b92e1e7",
    "prId" : 4641,
    "comments" : [
      {
        "id" : "1cbded89-d36e-48cb-9506-9bc400ff5c15",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think this is still way more complex and harder to read than it needs to be, how about the following:\r\n\r\n```haskell\r\nmergePackageMap :: [(PackageId, (Package, Maybe String))] -> Either String (Map.Map PackageId (Maybe String, Package))\r\nmergePackageMap ps = foldlM merge Map.empty ps\r\n  where\r\n    merge :: Map.Map PackageId (Maybe String, Package) -> (PackageId, (Package, Maybe String)) -> Either String (Map.Map PackageId (Maybe String, Package))\r\n    merge pkgs (pkgId, (pkg, mbPkgName)) = do\r\n        let pkgNames = mapMaybe fst (Map.elems pkgs)\r\n        -- Check if there is a package with the same name but a different package id.\r\n        whenJust mbPkgName $ \\name -> when (pkgId `Map.notMember` pkgs && name `elem` pkgNames) $\r\n            Left $ \"Duplicate name '\" <> name <> \"' for different packages detected\"\r\n        let update mbOld = case mbOld of\r\n                Nothing -> pure (Just (mbPkgName, pkg))\r\n                Just (mbOldPkgName, _) -> do\r\n                    -- Check if we have colliding names for the same package\r\n                    whenJust (liftA2 (,) mbOldPkgName mbPkgName) $ \\(name1, name2) ->\r\n                        when (name1 /= name2) $ Left $ \"Different names ('\" <> name1 <> \"' and '\" <> name2 <> \"') for the same package detected\"\r\n                    pure (Just (mbOldPkgName <|> mbPkgName, pkg))\r\n        Map.alterF update pkgId pkgs\r\n```",
        "createdAt" : "2020-02-21T12:44:10Z",
        "updatedAt" : "2020-02-21T13:03:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "95405d3a-2ee1-46b6-9a60-f21a804dbbed",
        "parentId" : "1cbded89-d36e-48cb-9506-9bc400ff5c15",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Very nice. Virtuoso code.",
        "createdAt" : "2020-02-21T13:04:02Z",
        "updatedAt" : "2020-02-21T13:04:03Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6212f8d24de0d54ef0b34ec38df863b13baad205",
    "line" : null,
    "diffHunk" : "@@ -47,63 +47,75 @@ optionsParserInfo = info (optionsParser <**> helper)\n     <> progDesc \"Generate TypeScript bindings from a DAR\"\n     )\n \n+readPackages :: [FilePath] -> IO [(PackageId, (Package, Maybe String))]\n+readPackages dars = concatMapM readPackage dars\n+  where\n+    readPackage dar = do\n+      dar <- B.readFile dar\n+      let archive = Zip.toArchive $ BSL.fromStrict dar\n+      dalfs <- either fail pure $ DAR.readDalfs archive\n+      DAR.DalfManifest{packageName} <- either fail pure $ DAR.readDalfManifest archive\n+      forM ((DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)) $\n+        \\(dalf, mbPkgName) -> do\n+          (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n+          pure (pkgId, (pkg, mbPkgName))\n+\n+mergePackageMap :: [(PackageId, (Package, Maybe String))] -> Either String (Map.Map PackageId (Maybe String, Package))\n+mergePackageMap ps = foldl' merge (Right Map.empty) ps"
  },
  {
    "id" : "881c2335-b52c-4b77-9896-1338a10c51a1",
    "prId" : 4589,
    "comments" : [
      {
        "id" : "b97f21a5-e12e-4313-8408-8470172737dd",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I always get confused by nested folds and I think this is also sensitive to the order which is probably not intended: If I first see `a.dar` which has a dependency on `$pkgid1` and afterwards `b.dar` where the main dalf has `$pkgid1` I’m not going to pick up the name for `$pkgid1`. If I put `b.dar` first I will pick up the name. \r\n\r\nI would suggest to do this in two steps instead:\r\n\r\n1. Take a list of DARs and build up a list of `Map.Map PackageId ([String], Archive)`. This basically consist of a function `FilePath -> Map.Map PackageId ([String], Archive)` that you apply to each DAR and then throw something like `Map.unionsWith (\\(names1, archive), (names2, _) -> (names1 <> names2, archive)` at it to merge them (a bit more complex if you want to detect duplicate package names).\r\n2. Check for errors, if there are none iterate over the map and generate typescript.",
        "createdAt" : "2020-02-18T20:03:01Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fe158aae-910b-4896-9021-b95572777f48",
        "parentId" : "b97f21a5-e12e-4313-8408-8470172737dd",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "> I always get confused by nested folds and I think this is also sensitive to the order which is probably not intended: If I first see a.dar which has a dependency on $pkgid1 and afterwards b.dar where the main dalf has $pkgid1 I’m not going to pick up the name for $pkgid1. If I put b.dar first I will pick up the name.\r\n\r\nI'm not sure about that.\r\n\r\nIf you see `a.dar` and it depends on `$pkgid1`, then ts will be generated for `$pkgid1` (against its hash). If later you see `b.dar` where the main dalf has `$pkgid1`, it will generate again this time against its package name (unless the package name is missing in which case it won't regenerate).",
        "createdAt" : "2020-02-18T20:28:07Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b7e0c68c-470c-4241-b28e-75d0c019019d",
        "parentId" : "b97f21a5-e12e-4313-8408-8470172737dd",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh I see, you will actually call `daml2ts` twice. That’s not what I would have expected. I would have expected that we always generate once per package id. If we can somehow infer a name for that package id we use it (assuming it’s unique, otherwise we error out). If there is no name we generate it without a name.",
        "createdAt" : "2020-02-18T20:48:04Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a1f2f266-f193-42ee-850f-02c9c73bbd5d",
        "parentId" : "b97f21a5-e12e-4313-8408-8470172737dd",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Cool. I hear you. This might not be the end game but yes, the scheme implemented here in some cases ~will~ might result in some duplicated packages (1.a  of https://github.com/digital-asset/daml/issues/4585). Thanks for looking at that somewhat tricky logic Moritz!",
        "createdAt" : "2020-02-18T20:52:27Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bebcbf0e-8489-43e6-9ceb-c9e0688341dd",
        "parentId" : "b97f21a5-e12e-4313-8408-8470172737dd",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I could live with the duplicates for now but ultimately they'll have to go. What @cocreature describes would solve that problem _and_ most likely be easier to understand since it separates the conflict detection from the code generation.\r\n\r\nI would suggest to build an intermediate structure of type `Map PackageId (Archive, Maybe String)`, where the `Maybe String` part is an optional name for a package. If we see a second name, we can fail immediately. We can build this intermediate structure in one big `foldl'` over _all_ DALFs and their potential names.",
        "createdAt" : "2020-02-18T20:59:09Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4cfa57d959142aacb99b2e6fbc3d865de3c11999",
    "line" : 53,
    "diffHunk" : "@@ -55,14 +50,46 @@ optionsParserInfo = info (optionsParser <**> helper)\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n-    dar <- B.readFile optInputDar\n-    let archive = Zip.toArchive $ BSL.fromStrict dar\n-    dalfs <- either fail pure $ DAR.readDalfs archive\n-    DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n-    packageName <- pure $ optMainPackageName <|> packageName\n-    forM_ ((DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)) $ \\(dalf, mbPkgName) -> do\n-        (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n-        daml2ts opts pkgId pkg mbPkgName\n+    foldM_ (processDar opts) Map.empty optInputDars"
  },
  {
    "id" : "57d449b3-cad1-4d65-a575-6b19c6eedd24",
    "prId" : 4589,
    "comments" : [
      {
        "id" : "612879a5-e2ae-4df4-a340-a5290571c5d5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Either remove it or leave it in but commenting it out seems weird.",
        "createdAt" : "2020-02-18T20:04:24Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c653dca5-7e1f-491a-b17a-4665dc767a7c",
        "parentId" : "612879a5-e2ae-4df4-a340-a5290571c5d5",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Sure. Will do.",
        "createdAt" : "2020-02-18T20:29:04Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cfa57d959142aacb99b2e6fbc3d865de3c11999",
    "line" : null,
    "diffHunk" : "@@ -73,7 +100,7 @@ daml2ts Options{..} pkgId pkg mbPkgName = do\n     forM_ (packageModules pkg) $ \\mod -> do\n         whenJust (genModule pkgId mod) $ \\modTxt -> do\n             let outputFile = outputDir </> joinPath (map T.unpack (unModuleName (moduleName mod))) FP.<.> \"ts\"\n-            putStrLn $ \"Generating \" ++ outputFile\n+            -- putStrLn $ \"Generating \" ++ outputFile"
  },
  {
    "id" : "24c7aa61-0628-4490-a65e-284a14b1d259",
    "prId" : 4589,
    "comments" : [
      {
        "id" : "721e8dd2-658e-46a6-bdee-5210210cd8e2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What does an empty string mean in this context? Does it make sense to have them at all? I prefer `Maybe String` over `String` with a special meaning for `\"\"`. But I suppose we don't need then here at all.",
        "createdAt" : "2020-02-18T20:42:00Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9b0a75f6-f39f-45bd-a001-4e3699ad9393",
        "parentId" : "721e8dd2-658e-46a6-bdee-5210210cd8e2",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "They are easily eliminated. I'll do that.",
        "createdAt" : "2020-02-18T21:40:37Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cfa57d959142aacb99b2e6fbc3d865de3c11999",
    "line" : null,
    "diffHunk" : "@@ -55,14 +50,46 @@ optionsParserInfo = info (optionsParser <**> helper)\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n-    dar <- B.readFile optInputDar\n-    let archive = Zip.toArchive $ BSL.fromStrict dar\n-    dalfs <- either fail pure $ DAR.readDalfs archive\n-    DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n-    packageName <- pure $ optMainPackageName <|> packageName\n-    forM_ ((DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)) $ \\(dalf, mbPkgName) -> do\n-        (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n-        daml2ts opts pkgId pkg mbPkgName\n+    foldM_ (processDar opts) Map.empty optInputDars\n+      where\n+        -- Generate the ts for a single DAR. 'processed' is a map of\n+        -- package ids of processed DALFs (the same package can appear\n+        -- in multiple DARS - avoid regenerating them where possible).\n+        processDar :: Options -> Map.Map PackageId [String] -> FilePath -> IO (Map.Map PackageId [String])\n+        processDar opts processed dar = do\n+          dar <- B.readFile dar\n+          let archive = Zip.toArchive $ BSL.fromStrict dar\n+          dalfs <- either fail pure $ DAR.readDalfs archive\n+          DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n+          let allDalfsInDar = (DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)\n+          foldM (processDalf opts) processed allDalfsInDar\n+\n+        -- Generate the ts for a single DALF. Avoid generating it\n+        -- multiple times where possible.\n+        processDalf :: Options -> Map.Map PackageId [String] -> (BSL.ByteString, Maybe String) -> IO (Map.Map PackageId [String])\n+        processDalf opts pkgs (dalf, mbPkgName) = do\n+          (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n+          let mainPkgNames = [x | x <- concat (Map.elems pkgs), not $ null x]"
  },
  {
    "id" : "20ca1858-604f-45bd-9c03-0b73de2b53bf",
    "prId" : 4589,
    "comments" : [
      {
        "id" : "5def9614-14e7-4381-8426-5088ef7db605",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This is not OCaml. You don't need the `..`. 😉",
        "createdAt" : "2020-02-18T20:42:29Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ff53e116-aa46-423a-b23d-1f2341f8d01a",
        "parentId" : "5def9614-14e7-4381-8426-5088ef7db605",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Yes. Copy paste error.",
        "createdAt" : "2020-02-18T21:41:08Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cfa57d959142aacb99b2e6fbc3d865de3c11999",
    "line" : null,
    "diffHunk" : "@@ -55,14 +50,46 @@ optionsParserInfo = info (optionsParser <**> helper)\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n-    dar <- B.readFile optInputDar\n-    let archive = Zip.toArchive $ BSL.fromStrict dar\n-    dalfs <- either fail pure $ DAR.readDalfs archive\n-    DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n-    packageName <- pure $ optMainPackageName <|> packageName\n-    forM_ ((DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)) $ \\(dalf, mbPkgName) -> do\n-        (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n-        daml2ts opts pkgId pkg mbPkgName\n+    foldM_ (processDar opts) Map.empty optInputDars\n+      where\n+        -- Generate the ts for a single DAR. 'processed' is a map of\n+        -- package ids of processed DALFs (the same package can appear\n+        -- in multiple DARS - avoid regenerating them where possible).\n+        processDar :: Options -> Map.Map PackageId [String] -> FilePath -> IO (Map.Map PackageId [String])\n+        processDar opts processed dar = do\n+          dar <- B.readFile dar\n+          let archive = Zip.toArchive $ BSL.fromStrict dar\n+          dalfs <- either fail pure $ DAR.readDalfs archive\n+          DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive"
  },
  {
    "id" : "076d4aa7-1a4c-4816-a6fb-802e7394a099",
    "prId" : 4589,
    "comments" : [
      {
        "id" : "785d348e-bf3e-4688-81c8-bcec0c67f1cb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`whenJust` is your friend: https://www.stackage.org/haddock/lts-14.6/extra-1.6.18/Control-Monad-Extra.html#v:whenJust",
        "createdAt" : "2020-02-18T20:44:43Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "57bfd133-6535-4bbd-9927-ebb5a0345088",
        "parentId" : "785d348e-bf3e-4688-81c8-bcec0c67f1cb",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "The condition is similar but different depending on the `Just` and `Nothing` cases. Not sure `whenJust` helps here.",
        "createdAt" : "2020-02-18T21:42:14Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e3d06377-01a1-4ece-a5c7-1ebcb92f2c12",
        "parentId" : "785d348e-bf3e-4688-81c8-bcec0c67f1cb",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n              whenJust mbPkgName $ \\name -> when (name `elem` mainPkgNames) $ fail ...\r\n```",
        "createdAt" : "2020-02-18T21:54:39Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4cfa57d959142aacb99b2e6fbc3d865de3c11999",
    "line" : null,
    "diffHunk" : "@@ -55,14 +50,46 @@ optionsParserInfo = info (optionsParser <**> helper)\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n-    dar <- B.readFile optInputDar\n-    let archive = Zip.toArchive $ BSL.fromStrict dar\n-    dalfs <- either fail pure $ DAR.readDalfs archive\n-    DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n-    packageName <- pure $ optMainPackageName <|> packageName\n-    forM_ ((DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)) $ \\(dalf, mbPkgName) -> do\n-        (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n-        daml2ts opts pkgId pkg mbPkgName\n+    foldM_ (processDar opts) Map.empty optInputDars\n+      where\n+        -- Generate the ts for a single DAR. 'processed' is a map of\n+        -- package ids of processed DALFs (the same package can appear\n+        -- in multiple DARS - avoid regenerating them where possible).\n+        processDar :: Options -> Map.Map PackageId [String] -> FilePath -> IO (Map.Map PackageId [String])\n+        processDar opts processed dar = do\n+          dar <- B.readFile dar\n+          let archive = Zip.toArchive $ BSL.fromStrict dar\n+          dalfs <- either fail pure $ DAR.readDalfs archive\n+          DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n+          let allDalfsInDar = (DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)\n+          foldM (processDalf opts) processed allDalfsInDar\n+\n+        -- Generate the ts for a single DALF. Avoid generating it\n+        -- multiple times where possible.\n+        processDalf :: Options -> Map.Map PackageId [String] -> (BSL.ByteString, Maybe String) -> IO (Map.Map PackageId [String])\n+        processDalf opts pkgs (dalf, mbPkgName) = do\n+          (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n+          let mainPkgNames = [x | x <- concat (Map.elems pkgs), not $ null x]\n+          gen <- case Map.lookup pkgId pkgs of\n+            Nothing -> do\n+              maybe (return ()) (\\name -> when (name `elem` mainPkgNames) $"
  },
  {
    "id" : "6a5f2914-abb3-4ab0-8e56-9698145836bc",
    "prId" : 4589,
    "comments" : [
      {
        "id" : "f43bbf1a-d33f-43dc-88c7-a201835a087b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It would be good to have a description of what it means for a `PackageId` to appear as a key of the map. And what it means for a `String` to be contained in the list of a specific `PackageId`.",
        "createdAt" : "2020-02-18T20:51:25Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "19f177c6-ded4-40f5-8249-f9ab59a111fd",
        "parentId" : "f43bbf1a-d33f-43dc-88c7-a201835a087b",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-02-18T21:42:26Z",
        "updatedAt" : "2020-02-18T22:09:01Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4cfa57d959142aacb99b2e6fbc3d865de3c11999",
    "line" : 58,
    "diffHunk" : "@@ -55,14 +50,46 @@ optionsParserInfo = info (optionsParser <**> helper)\n main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n-    dar <- B.readFile optInputDar\n-    let archive = Zip.toArchive $ BSL.fromStrict dar\n-    dalfs <- either fail pure $ DAR.readDalfs archive\n-    DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n-    packageName <- pure $ optMainPackageName <|> packageName\n-    forM_ ((DAR.mainDalf dalfs, packageName) : map (, Nothing) (DAR.dalfs dalfs)) $ \\(dalf, mbPkgName) -> do\n-        (pkgId, pkg) <- either (fail . show)  pure $ Archive.decodeArchive Archive.DecodeAsMain (BSL.toStrict dalf)\n-        daml2ts opts pkgId pkg mbPkgName\n+    foldM_ (processDar opts) Map.empty optInputDars\n+      where\n+        -- Generate the ts for a single DAR. 'processed' is a map of\n+        -- package ids of processed DALFs (the same package can appear\n+        -- in multiple DARS - avoid regenerating them where possible).\n+        processDar :: Options -> Map.Map PackageId [String] -> FilePath -> IO (Map.Map PackageId [String])"
  },
  {
    "id" : "16ea1326-68cc-4386-9571-185acd0ec947",
    "prId" : 4476,
    "comments" : [
      {
        "id" : "5e7e2d75-d7ac-4661-9859-a43947ae3195",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    packageName <- pure $ fromMaybe packageName optMainPackageName\r\n```",
        "createdAt" : "2020-02-11T20:17:31Z",
        "updatedAt" : "2020-02-11T20:35:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e844324a-0d12-40de-a664-0798b67bf4ad",
        "parentId" : "5e7e2d75-d7ac-4661-9859-a43947ae3195",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I don't think that's right. `packageName` is itself a `Maybe`. ",
        "createdAt" : "2020-02-11T20:24:47Z",
        "updatedAt" : "2020-02-11T20:35:52Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f13138e9-e4ef-4c71-a91e-0e231285b767",
        "parentId" : "5e7e2d75-d7ac-4661-9859-a43947ae3195",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Oh good point, you want `optMainPackageName <|> packageName`",
        "createdAt" : "2020-02-11T20:25:46Z",
        "updatedAt" : "2020-02-11T20:35:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "35f53e4e-54af-450b-a7d3-14c97356143c",
        "parentId" : "5e7e2d75-d7ac-4661-9859-a43947ae3195",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ooh! Awesome phrasing. Will adjust!",
        "createdAt" : "2020-02-11T20:27:48Z",
        "updatedAt" : "2020-02-11T20:35:52Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "470a305dbec7ef86ed9a3c742435fc7bcadb9638",
    "line" : null,
    "diffHunk" : "@@ -56,8 +56,11 @@ main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n     dar <- B.readFile optInputDar\n-    dalfs <- either fail pure $ DAR.readDalfs $ Zip.toArchive $ BSL.fromStrict dar\n-    forM_ ((DAR.mainDalf dalfs, optMainPackageName) : map (, Nothing) (DAR.dalfs dalfs)) $ \\(dalf, mbPkgName) -> do\n+    let archive = Zip.toArchive $ BSL.fromStrict dar\n+    dalfs <- either fail pure $ DAR.readDalfs archive\n+    DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n+    packageName <- pure $ maybe packageName (const optMainPackageName) optMainPackageName"
  },
  {
    "id" : "5dc52b62-0809-423c-8352-1481b300c213",
    "prId" : 4476,
    "comments" : [
      {
        "id" : "e3961791-b7ec-40d1-aa84-1d93b9132ed8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Whenever I see this pattern I wish Haskell's `let`s wouldn't be recursive by default. So sad. 😿",
        "createdAt" : "2020-02-11T20:53:07Z",
        "updatedAt" : "2020-02-11T20:53:17Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "470a305dbec7ef86ed9a3c742435fc7bcadb9638",
    "line" : 9,
    "diffHunk" : "@@ -56,8 +56,11 @@ main :: IO ()\n main = do\n     opts@Options{..} <- execParser optionsParserInfo\n     dar <- B.readFile optInputDar\n-    dalfs <- either fail pure $ DAR.readDalfs $ Zip.toArchive $ BSL.fromStrict dar\n-    forM_ ((DAR.mainDalf dalfs, optMainPackageName) : map (, Nothing) (DAR.dalfs dalfs)) $ \\(dalf, mbPkgName) -> do\n+    let archive = Zip.toArchive $ BSL.fromStrict dar\n+    dalfs <- either fail pure $ DAR.readDalfs archive\n+    DAR.DalfManifest{packageName, ..} <- either fail pure $ DAR.readDalfManifest archive\n+    packageName <- pure $ optMainPackageName <|> packageName"
  },
  {
    "id" : "4d5f4d4e-2ee0-476e-8d18-4030bce24f3c",
    "prId" : 4186,
    "comments" : [
      {
        "id" : "8b87944d-e777-4f69-b701-125d5b540a26",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                              [\"  export type Key = \" <> fst (genType (moduleName mod) (tplKeyType key))] ++\r\n```",
        "createdAt" : "2020-01-23T16:36:18Z",
        "updatedAt" : "2020-01-23T16:37:23Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ba23e4fe614a08c3ef5ac8bf5a398e8e42e1d724",
    "line" : 21,
    "diffHunk" : "@@ -250,10 +247,10 @@ genDefDataType curPkgId conName mod tpls def =\n                             ] ++\n                             [\"};\"]\n                         associatedTypes =\n-                          maybe [] (const $\n+                          maybe [] (\\key ->\n                               [ \"// eslint-disable-next-line @typescript-eslint/no-namespace\"\n                               , \"export namespace \" <> conName <> \" {\"] ++\n-                              [\"  export type Key = \" <> keyTypeTs <> \"\"] ++\n+                              [\"  export type Key = \" <> fst (genType (moduleName mod) (tplKeyType key)) <> \"\"] ++"
  },
  {
    "id" : "c7333bbe-ac98-4d76-8d9a-fdbd6ba2b484",
    "prId" : 4079,
    "comments" : [
      {
        "id" : "6f47cfe9-1911-46cb-a1eb-02b34d6d7fbc",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What is this about? Are we adding a comment here? I'm not convinced adding comments to generated code has value.",
        "createdAt" : "2020-01-17T10:47:33Z",
        "updatedAt" : "2020-01-17T11:59:18Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f1d48f72-8142-4c69-b455-bf2e680d79d1",
        "parentId" : "6f47cfe9-1911-46cb-a1eb-02b34d6d7fbc",
        "author" : null,
        "body" : "Oops. Debug detritus. Will remove!",
        "createdAt" : "2020-01-17T11:54:57Z",
        "updatedAt" : "2020-01-17T11:59:18Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3684c5eb9c15efbbc40610a2dae20c4ed5bb2f3b",
    "line" : null,
    "diffHunk" : "@@ -253,7 +255,7 @@ genDefDataType curPkgId conName mod tpls def =\n                             [\"daml.registerTemplate(\" <> conName <> \");\"]\n                         refs = Set.unions (fieldRefs ++ argRefs)\n                     in\n-                    ((makeType typeDesc, dict ++ registrations), refs)\n+                    ((makeType [\"//\" <> conName] ++ typeDesc, dict ++ registrations), refs)"
  },
  {
    "id" : "141adb46-c93d-4f54-ac76-48c32d61f2b6",
    "prId" : 4059,
    "comments" : [
      {
        "id" : "e22fd7a3-8f8a-4b3c-b60b-d0ed1dbb08b6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I don't think this comment really helps. Let's just drop it.",
        "createdAt" : "2020-01-16T10:29:26Z",
        "updatedAt" : "2020-01-16T16:56:32Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a46eed98-c081-4bf6-a207-f320eab7a253",
        "parentId" : "e22fd7a3-8f8a-4b3c-b60b-d0ed1dbb08b6",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "✔️ ",
        "createdAt" : "2020-01-16T16:45:47Z",
        "updatedAt" : "2020-01-16T16:56:32Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7f354d3c44ce32c32bf1664b71dfbb279da9f2cc",
    "line" : null,
    "diffHunk" : "@@ -340,6 +343,7 @@ genType curModName = go\n         TCon _ -> error \"IMPOSSIBLE: lonely type constructor\"\n         TSynApp{} -> error \"IMPOSSIBLE: type synonym not serializable\"\n         t@TApp{} -> error $ \"IMPOSSIBLE: type application not serializable - \" <> DA.Pretty.renderPretty t\n+          -- The above case also handles 'TNumeric a' where 'a' is not a type level nat."
  },
  {
    "id" : "3fd38ed3-6fe7-443a-88f2-747a41d56631",
    "prId" : 4059,
    "comments" : [
      {
        "id" : "91fd214f-44fc-40fe-ac49-d5a3302c558b",
        "parentId" : null,
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Remove comment",
        "createdAt" : "2020-01-16T14:07:21Z",
        "updatedAt" : "2020-01-16T16:56:32Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7f354d3c44ce32c32bf1664b71dfbb279da9f2cc",
    "line" : null,
    "diffHunk" : "@@ -340,6 +343,7 @@ genType curModName = go\n         TCon _ -> error \"IMPOSSIBLE: lonely type constructor\"\n         TSynApp{} -> error \"IMPOSSIBLE: type synonym not serializable\"\n         t@TApp{} -> error $ \"IMPOSSIBLE: type application not serializable - \" <> DA.Pretty.renderPretty t\n+          -- The above case also handles 'TNumeric a' where 'a' is not a type level nat."
  },
  {
    "id" : "643bfc7f-f435-4344-88ed-3b6d8dc2d28e",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "4ff0ab61-7714-47fe-8bfc-9b1f0139702f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why not inline this?",
        "createdAt" : "2020-01-14T19:16:51Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0315df74-e3c9-4647-b620-cd0a5980dfb1",
        "parentId" : "4ff0ab61-7714-47fe-8bfc-9b1f0139702f",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "No deep reason - legacy I'd say. I'll have another look.",
        "createdAt" : "2020-01-14T19:50:14Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -107,31 +111,75 @@ genModule curPkgId mod\n     in\n     Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n   where\n-    serDefs = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n+    serDefs = defDataTypes mod\n+\n+defDataTypes :: Module -> [DefDataType]\n+defDataTypes mod = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n \n-genDataDef :: PackageId -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDataDef curPkgId curModName tpls def = case unTypeConName (dataTypeCon def) of\n+genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDataDef curPkgId mod tpls def = case unTypeConName (dataTypeCon def) of\n     [] -> error \"IMPOSSIBLE: empty type constructor name\"\n     _: _: _: _ -> error \"IMPOSSIBLE: multi-part type constructor of more than two names\"\n-    [conName] -> genDefDataType curPkgId conName curModName tpls def\n-    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, makeNamespace $ map (\"  \" <>) sers), refs)\n+\n+    [conName] -> genDefDataType curPkgId conName mod tpls def\n+    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, []), refs)\n       where\n-        ((typs, sers), refs) = genDefDataType curPkgId c2 curModName tpls def\n-        ns = c1 <> \"_NS\"\n+        ((typs, _), refs) = genDefDataType curPkgId c2 mod tpls def\n+        ns = c1"
  },
  {
    "id" : "60401408-f6ec-446c-ac74-25757dcb2d6a",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "24ddcaf2-0e63-4eaa-8a2f-b62e4c8b2a93",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                  function = onLast (<> \";\")) (makeSer ([\"() => jtv.oneOf<\" <> typ <> \">(\"] ++ sers ++ [\")\"])\r\n```\r\nIf you need parentheses anyway, why bother with the `&`?",
        "createdAt" : "2020-01-14T19:18:33Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b65019f0-6871-4ee2-90bd-464f85351781",
        "parentId" : "24ddcaf2-0e63-4eaa-8a2f-b62e4c8b2a93",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Matter of taste. I did it that way because it reads nicely putting the \";\" at the end as it comes out in the code. Do you feel strongly that it should change?",
        "createdAt" : "2020-01-14T19:49:45Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c5923282-bdb5-4296-abbf-51b160cacb91",
        "parentId" : "24ddcaf2-0e63-4eaa-8a2f-b62e4c8b2a93",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "IMO, not using operators that are not really necessary makes the code more accessible for future Haskell newbies in our team.",
        "createdAt" : "2020-01-14T19:58:41Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8431cf03-b0f3-47d6-aef0-27eb0fd80d7a",
        "parentId" : "24ddcaf2-0e63-4eaa-8a2f-b62e4c8b2a93",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "That is a reasonable argument against. It was cute but I'll drop it's use here.",
        "createdAt" : "2020-01-14T20:10:03Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -107,31 +111,75 @@ genModule curPkgId mod\n     in\n     Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n   where\n-    serDefs = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n+    serDefs = defDataTypes mod\n+\n+defDataTypes :: Module -> [DefDataType]\n+defDataTypes mod = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n \n-genDataDef :: PackageId -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDataDef curPkgId curModName tpls def = case unTypeConName (dataTypeCon def) of\n+genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDataDef curPkgId mod tpls def = case unTypeConName (dataTypeCon def) of\n     [] -> error \"IMPOSSIBLE: empty type constructor name\"\n     _: _: _: _ -> error \"IMPOSSIBLE: multi-part type constructor of more than two names\"\n-    [conName] -> genDefDataType curPkgId conName curModName tpls def\n-    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, makeNamespace $ map (\"  \" <>) sers), refs)\n+\n+    [conName] -> genDefDataType curPkgId conName mod tpls def\n+    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, []), refs)\n       where\n-        ((typs, sers), refs) = genDefDataType curPkgId c2 curModName tpls def\n-        ns = c1 <> \"_NS\"\n+        ((typs, _), refs) = genDefDataType curPkgId c2 mod tpls def\n+        ns = c1\n         makeNamespace stuff =\n           [ \"// eslint-disable-next-line @typescript-eslint/no-namespace\"\n-          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns] ++ [\"\"]\n+          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns]\n \n-genDefDataType :: PackageId -> T.Text -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDefDataType curPkgId conName curModName tpls def =\n+genDefDataType :: PackageId -> T.Text -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDefDataType curPkgId conName mod tpls def =\n     case dataCons def of\n         DataVariant bs ->\n           let\n             (typs, sers) = unzip $ map genBranch bs\n-            typeDesc = [\"\"] ++ typs\n-            serDesc  = [\"() => jtv.oneOf<\" <> conName <> typeParams <> \">(\"] ++ sers ++ [\")\"]\n-          in\n-          ((makeType typeDesc, makeSer serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n+            typeDesc = makeType ([\"\"] ++ typs)\n+            typ = conName <> typeParams -- Type of the variant.\n+            assocDefs = assocDefDataTypes mod conName -- Associated types.\n+            serDesc =\n+              if not $ null paramNames -- Polymorphic type.\n+              then -- Companion function.\n+                let\n+                  -- Any associated serializers.\n+                  assocSers = map\n+                    (\\(n, d) -> serFromDef id n curPkgId mod tpls d)\n+                    assocDefs\n+                  -- The variant deserializer.\n+                  function = (makeSer ( [\"() => jtv.oneOf<\" <> typ <> \">(\"] ++ sers ++ [\")\"]) & onLast (<> \";\"));"
  },
  {
    "id" : "363b52b7-b69c-4007-a9c9-b2fc8c2b3e9d",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "66031817-d0d6-4b14-ab97-ae504deaa663",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\ninfixr <.> -- This is the same fixity as '<>'.\r\n(<.>) :: T.Text -> T.Text -> T.Text\r\n```\r\nIf you defined it like this, you can write\r\n```\r\na <> b <.> c <> d\r\n```\r\ninstead of the more wordy\r\n```\r\na <> (b `dot` c) <> d\r\n```",
        "createdAt" : "2020-01-14T19:22:49Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "f876fc4e-858b-4a25-bac0-13703b3bd638",
        "parentId" : "66031817-d0d6-4b14-ab97-ae504deaa663",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I did write that function but there's a conflict with `Filepath` and we use the definition from that. I could qualify that usage of course. I'll do it.",
        "createdAt" : "2020-01-14T19:51:34Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -76,6 +77,9 @@ daml2ts Options{..} pkgId pkg mbPkgName = do\n dup :: a -> (a, a)\n dup x = (x, x)\n \n+dot :: T.Text -> T.Text -> T.Text"
  },
  {
    "id" : "c5f83ccd-aa44-4866-b2c4-f9a47888a06f",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "361a9441-7b1c-4c4b-8767-3e725fb94500",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Wouldn't it be nicer to put each field on a separate line?",
        "createdAt" : "2020-01-14T19:24:34Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a664b7a7-c869-4d5b-9d42-662c6e55a983",
        "parentId" : "361a9441-7b1c-4c4b-8767-3e725fb94500",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I suppose you are right. I can do that.",
        "createdAt" : "2020-01-14T19:52:40Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2fd59111-6ca4-4296-8837-4e8836847d72",
        "parentId" : "361a9441-7b1c-4c4b-8767-3e725fb94500",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "That's nice 😄 \r\n```haskell\r\n\r\nexport type Quux = \r\n  |  { tag: 'Corge'; value: Quux.Corge }\r\n  |  { tag: 'Grault'; value: Quux.Grault }\r\nexport const Quux:\r\n  daml.Serializable<Quux> & {\r\n    Corge: daml.Serializable<Quux.Corge;\r\n    Grault: daml.Serializable<Quux.Grault\r\n  } = ({\r\n   ...\r\n```",
        "createdAt" : "2020-01-14T21:01:53Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -107,31 +111,75 @@ genModule curPkgId mod\n     in\n     Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n   where\n-    serDefs = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n+    serDefs = defDataTypes mod\n+\n+defDataTypes :: Module -> [DefDataType]\n+defDataTypes mod = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n \n-genDataDef :: PackageId -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDataDef curPkgId curModName tpls def = case unTypeConName (dataTypeCon def) of\n+genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDataDef curPkgId mod tpls def = case unTypeConName (dataTypeCon def) of\n     [] -> error \"IMPOSSIBLE: empty type constructor name\"\n     _: _: _: _ -> error \"IMPOSSIBLE: multi-part type constructor of more than two names\"\n-    [conName] -> genDefDataType curPkgId conName curModName tpls def\n-    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, makeNamespace $ map (\"  \" <>) sers), refs)\n+\n+    [conName] -> genDefDataType curPkgId conName mod tpls def\n+    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, []), refs)\n       where\n-        ((typs, sers), refs) = genDefDataType curPkgId c2 curModName tpls def\n-        ns = c1 <> \"_NS\"\n+        ((typs, _), refs) = genDefDataType curPkgId c2 mod tpls def\n+        ns = c1\n         makeNamespace stuff =\n           [ \"// eslint-disable-next-line @typescript-eslint/no-namespace\"\n-          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns] ++ [\"\"]\n+          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns]\n \n-genDefDataType :: PackageId -> T.Text -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDefDataType curPkgId conName curModName tpls def =\n+genDefDataType :: PackageId -> T.Text -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDefDataType curPkgId conName mod tpls def =\n     case dataCons def of\n         DataVariant bs ->\n           let\n             (typs, sers) = unzip $ map genBranch bs\n-            typeDesc = [\"\"] ++ typs\n-            serDesc  = [\"() => jtv.oneOf<\" <> conName <> typeParams <> \">(\"] ++ sers ++ [\")\"]\n-          in\n-          ((makeType typeDesc, makeSer serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n+            typeDesc = makeType ([\"\"] ++ typs)\n+            typ = conName <> typeParams -- Type of the variant.\n+            assocDefs = assocDefDataTypes mod conName -- Associated types.\n+            serDesc =\n+              if not $ null paramNames -- Polymorphic type.\n+              then -- Companion function.\n+                let\n+                  -- Any associated serializers.\n+                  assocSers = map\n+                    (\\(n, d) -> serFromDef id n curPkgId mod tpls d)\n+                    assocDefs\n+                  -- The variant deserializer.\n+                  function = (makeSer ( [\"() => jtv.oneOf<\" <> typ <> \">(\"] ++ sers ++ [\")\"]) & onLast (<> \";\"));\n+                  props = -- Fix the first and last line of each serializer.\n+                    concatMap (onHead (erase \"export const \") . onLast (<> \";\")) assocSers\n+                  -- The complete definition of the companion function.\n+                  in function ++ props\n+                     -- To-do: Can we formulate a static implements\n+                     -- serializable check that works for companion\n+                     -- functions?\n+              else -- Companion object.\n+                let\n+                  assocNames = map (snd . fst) assocDefs\n+                  -- Any associated serializers, dropping the first line\n+                  -- of each.\n+                  assocSers = map\n+                    (\\(n@(_, c), d) -> (c, serFromDef (drop 1) n curPkgId mod tpls d))\n+                    assocDefs\n+                  -- Type of the companion object.\n+                  typ' = \"daml.Serializable<\" <> conName <> \"> & {\" <>\n+                    T.intercalate \"; \""
  },
  {
    "id" : "36678921-4b96-43b8-996e-1387d8ff4c41",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "9732b1cf-b915-47bd-ae84-3f13d299b870",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why?",
        "createdAt" : "2020-01-14T19:26:11Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "70856440-2e2b-4268-926c-e4598fdeb219",
        "parentId" : "9732b1cf-b915-47bd-ae84-3f13d299b870",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Probably a mistake. Let me check.",
        "createdAt" : "2020-01-14T19:53:25Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "61fb9ce9-66c8-4fa6-a7f1-4c7953a3fe87",
        "parentId" : "9732b1cf-b915-47bd-ae84-3f13d299b870",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "No, not a mistake. We can't assume the result of `makeSer` is going to be in a context where a trailing `;` is right (the variant case has a usage where it's not - the alternative of course is do surgery on it with something like `replace`).\r\n```haskell\r\n  Corge: ({\r\n    decoder: () => jtv.object({\r\n      x: daml.Int.decoder(),\r\n      y: daml.Text.decoder(),\r\n    }),\r\n  });, -- <- here!\r\n```\r\n",
        "createdAt" : "2020-01-14T20:22:09Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ebd76138-7da3-42fe-979e-bba44be394cf",
        "parentId" : "9732b1cf-b915-47bd-ae84-3f13d299b870",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That an explanation makes sense. Happy to change it then.",
        "createdAt" : "2020-01-14T20:25:57Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : 171,
    "diffHunk" : "@@ -225,15 +273,15 @@ genDefDataType curPkgId conName curModName tpls def =\n         makeSer serDesc =\n             [\"export const \" <> conName <> serHeader <> \" ({\"] ++\n             map (\"  \" <>) (onHead (\"decoder: \" <>) serDesc) ++\n-            [\"});\"]\n+            [\"})\"]"
  },
  {
    "id" : "78be271f-9fe8-4e82-a765-bf5e1d45967f",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "42c1c289-3672-4406-9cf9-dcaebbaac1a7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n                    (map (\\n -> n <> \": daml.Serializable<\" <> conName <.> n <> \">\") assocNames) <>\r\n```\r\nif you follow my suggestion above.",
        "createdAt" : "2020-01-14T19:27:08Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -107,31 +111,75 @@ genModule curPkgId mod\n     in\n     Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n   where\n-    serDefs = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n+    serDefs = defDataTypes mod\n+\n+defDataTypes :: Module -> [DefDataType]\n+defDataTypes mod = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n \n-genDataDef :: PackageId -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDataDef curPkgId curModName tpls def = case unTypeConName (dataTypeCon def) of\n+genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDataDef curPkgId mod tpls def = case unTypeConName (dataTypeCon def) of\n     [] -> error \"IMPOSSIBLE: empty type constructor name\"\n     _: _: _: _ -> error \"IMPOSSIBLE: multi-part type constructor of more than two names\"\n-    [conName] -> genDefDataType curPkgId conName curModName tpls def\n-    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, makeNamespace $ map (\"  \" <>) sers), refs)\n+\n+    [conName] -> genDefDataType curPkgId conName mod tpls def\n+    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, []), refs)\n       where\n-        ((typs, sers), refs) = genDefDataType curPkgId c2 curModName tpls def\n-        ns = c1 <> \"_NS\"\n+        ((typs, _), refs) = genDefDataType curPkgId c2 mod tpls def\n+        ns = c1\n         makeNamespace stuff =\n           [ \"// eslint-disable-next-line @typescript-eslint/no-namespace\"\n-          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns] ++ [\"\"]\n+          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns]\n \n-genDefDataType :: PackageId -> T.Text -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDefDataType curPkgId conName curModName tpls def =\n+genDefDataType :: PackageId -> T.Text -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDefDataType curPkgId conName mod tpls def =\n     case dataCons def of\n         DataVariant bs ->\n           let\n             (typs, sers) = unzip $ map genBranch bs\n-            typeDesc = [\"\"] ++ typs\n-            serDesc  = [\"() => jtv.oneOf<\" <> conName <> typeParams <> \">(\"] ++ sers ++ [\")\"]\n-          in\n-          ((makeType typeDesc, makeSer serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n+            typeDesc = makeType ([\"\"] ++ typs)\n+            typ = conName <> typeParams -- Type of the variant.\n+            assocDefs = assocDefDataTypes mod conName -- Associated types.\n+            serDesc =\n+              if not $ null paramNames -- Polymorphic type.\n+              then -- Companion function.\n+                let\n+                  -- Any associated serializers.\n+                  assocSers = map\n+                    (\\(n, d) -> serFromDef id n curPkgId mod tpls d)\n+                    assocDefs\n+                  -- The variant deserializer.\n+                  function = (makeSer ( [\"() => jtv.oneOf<\" <> typ <> \">(\"] ++ sers ++ [\")\"]) & onLast (<> \";\"));\n+                  props = -- Fix the first and last line of each serializer.\n+                    concatMap (onHead (erase \"export const \") . onLast (<> \";\")) assocSers\n+                  -- The complete definition of the companion function.\n+                  in function ++ props\n+                     -- To-do: Can we formulate a static implements\n+                     -- serializable check that works for companion\n+                     -- functions?\n+              else -- Companion object.\n+                let\n+                  assocNames = map (snd . fst) assocDefs\n+                  -- Any associated serializers, dropping the first line\n+                  -- of each.\n+                  assocSers = map\n+                    (\\(n@(_, c), d) -> (c, serFromDef (drop 1) n curPkgId mod tpls d))\n+                    assocDefs\n+                  -- Type of the companion object.\n+                  typ' = \"daml.Serializable<\" <> conName <> \"> & {\" <>\n+                    T.intercalate \"; \"\n+                    (map (\\n -> n <> \": daml.Serializable<\" <> (conName `dot` n) <> \">\") assocNames) <>"
  },
  {
    "id" : "cb84e1f7-dd5b-4717-bada-e947621bc32b",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "56403f5f-89e8-470c-b85a-26ed926a0bbb",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "How does the first line look like? Can we modify it with `onHead` instead?",
        "createdAt" : "2020-01-14T19:30:09Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7bd74a41-be06-46cb-b89b-0ebfc52afb3b",
        "parentId" : "56403f5f-89e8-470c-b85a-26ed926a0bbb",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I recall evaluating that and determining that it was easier to discard the line.",
        "createdAt" : "2020-01-14T20:44:25Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : 101,
    "diffHunk" : "@@ -107,31 +111,75 @@ genModule curPkgId mod\n     in\n     Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n   where\n-    serDefs = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n+    serDefs = defDataTypes mod\n+\n+defDataTypes :: Module -> [DefDataType]\n+defDataTypes mod = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n \n-genDataDef :: PackageId -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDataDef curPkgId curModName tpls def = case unTypeConName (dataTypeCon def) of\n+genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDataDef curPkgId mod tpls def = case unTypeConName (dataTypeCon def) of\n     [] -> error \"IMPOSSIBLE: empty type constructor name\"\n     _: _: _: _ -> error \"IMPOSSIBLE: multi-part type constructor of more than two names\"\n-    [conName] -> genDefDataType curPkgId conName curModName tpls def\n-    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, makeNamespace $ map (\"  \" <>) sers), refs)\n+\n+    [conName] -> genDefDataType curPkgId conName mod tpls def\n+    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, []), refs)\n       where\n-        ((typs, sers), refs) = genDefDataType curPkgId c2 curModName tpls def\n-        ns = c1 <> \"_NS\"\n+        ((typs, _), refs) = genDefDataType curPkgId c2 mod tpls def\n+        ns = c1\n         makeNamespace stuff =\n           [ \"// eslint-disable-next-line @typescript-eslint/no-namespace\"\n-          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns] ++ [\"\"]\n+          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns]\n \n-genDefDataType :: PackageId -> T.Text -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDefDataType curPkgId conName curModName tpls def =\n+genDefDataType :: PackageId -> T.Text -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDefDataType curPkgId conName mod tpls def =\n     case dataCons def of\n         DataVariant bs ->\n           let\n             (typs, sers) = unzip $ map genBranch bs\n-            typeDesc = [\"\"] ++ typs\n-            serDesc  = [\"() => jtv.oneOf<\" <> conName <> typeParams <> \">(\"] ++ sers ++ [\")\"]\n-          in\n-          ((makeType typeDesc, makeSer serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n+            typeDesc = makeType ([\"\"] ++ typs)\n+            typ = conName <> typeParams -- Type of the variant.\n+            assocDefs = assocDefDataTypes mod conName -- Associated types.\n+            serDesc =\n+              if not $ null paramNames -- Polymorphic type.\n+              then -- Companion function.\n+                let\n+                  -- Any associated serializers.\n+                  assocSers = map\n+                    (\\(n, d) -> serFromDef id n curPkgId mod tpls d)\n+                    assocDefs\n+                  -- The variant deserializer.\n+                  function = (makeSer ( [\"() => jtv.oneOf<\" <> typ <> \">(\"] ++ sers ++ [\")\"]) & onLast (<> \";\"));\n+                  props = -- Fix the first and last line of each serializer.\n+                    concatMap (onHead (erase \"export const \") . onLast (<> \";\")) assocSers\n+                  -- The complete definition of the companion function.\n+                  in function ++ props\n+                     -- To-do: Can we formulate a static implements\n+                     -- serializable check that works for companion\n+                     -- functions?\n+              else -- Companion object.\n+                let\n+                  assocNames = map (snd . fst) assocDefs\n+                  -- Any associated serializers, dropping the first line"
  },
  {
    "id" : "4a1e1c82-12d3-46e6-869d-fbcd0a028fc5",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "4797f072-3e62-4d28-b13c-1aeb97839009",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n  [(sub, def) | def <- defDataTypes m\r\n```\r\nThis feels quite \"unnormalized\" to me.",
        "createdAt" : "2020-01-14T19:34:07Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b1998bdc-48c8-4e7a-8d7e-40cc2ca739b4",
        "parentId" : "4797f072-3e62-4d28-b13c-1aeb97839009",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Not sure what you are getting at. There are two uses\r\n```haskell\r\n                  assocSers = map\r\n                    (\\(n, d) -> serFromDef id n curPkgId mod tpls d)\r\n                    assocDefs\r\n```\r\nand\r\n```haskell\r\n                  assocSers = map\r\n                    (\\(n@(_, c), d) -> (c, serFromDef (drop 1) n curPkgId mod tpls d))\r\n                    assocDefs\r\n```\r\nI designed it together with `serFromDef` to play nice. ",
        "createdAt" : "2020-01-14T19:59:54Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "39c6ff13-d012-4b19-902b-0344f7931525",
        "parentId" : "4797f072-3e62-4d28-b13c-1aeb97839009",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The very first element of each list item is the same, namely the second parameter `c`. I suggest we don't return this duplicated information but rather change the call site to explicitly use whatever we passed as the second argument to `assocDefDataTypes` instead.",
        "createdAt" : "2020-01-14T20:06:40Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1ed9875a-c98f-467e-9b43-ec7f1423a661",
        "parentId" : "4797f072-3e62-4d28-b13c-1aeb97839009",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Good reason. Fixed.",
        "createdAt" : "2020-01-14T20:48:01Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -315,3 +362,34 @@ onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n     x:xs -> f x:xs\n+\n+onLast :: (a -> a) -> [a] -> [a]\n+onLast f = \\case\n+  [] -> []\n+  [l] -> [f l]\n+  x : xs -> x : onLast f xs\n+\n+-- A type such as\n+--   data Q = C { x: Int, y: Text }| G { z: Bool }\n+-- has a DAML-LF representation like,\n+--   record Q.C = { x: Int, y: String }\n+--   record Q.G = { z: Bool }\n+--   variant Q = C Q.C | G Q.G\n+-- Use this function to get the definitions of 'Q.C' and 'Q.G' given\n+-- 'Q'.\n+assocDefDataTypes :: Module -> T.Text -> [((T.Text, T.Text), DefDataType)]\n+assocDefDataTypes m c =\n+  [((sup, sub ), def) | def <- defDataTypes m"
  },
  {
    "id" : "b54add5b-5894-4dc0-8bed-5ffc87b2ce9b",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "134ae193-d842-44dc-a4b8-c47660f3b4ed",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This function is so small, I think it would increase readability if we inlined it, including the comment.",
        "createdAt" : "2020-01-14T19:35:02Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "be492596-666e-4f9a-87e4-180422ae15b8",
        "parentId" : "134ae193-d842-44dc-a4b8-c47660f3b4ed",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Ok.",
        "createdAt" : "2020-01-14T19:55:54Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c2da26a0-727e-42a1-bdd5-a8ab169a2bbd",
        "parentId" : "134ae193-d842-44dc-a4b8-c47660f3b4ed",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Well, again, two call sites. I'll move it to the `where` clause as planned for `serFromDef`.",
        "createdAt" : "2020-01-14T20:24:35Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -315,3 +362,34 @@ onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n     x:xs -> f x:xs\n+\n+onLast :: (a -> a) -> [a] -> [a]\n+onLast f = \\case\n+  [] -> []\n+  [l] -> [f l]\n+  x : xs -> x : onLast f xs\n+\n+-- A type such as\n+--   data Q = C { x: Int, y: Text }| G { z: Bool }\n+-- has a DAML-LF representation like,\n+--   record Q.C = { x: Int, y: String }\n+--   record Q.G = { z: Bool }\n+--   variant Q = C Q.C | G Q.G\n+-- Use this function to get the definitions of 'Q.C' and 'Q.G' given\n+-- 'Q'.\n+assocDefDataTypes :: Module -> T.Text -> [((T.Text, T.Text), DefDataType)]"
  },
  {
    "id" : "d684a05b-046a-4cfb-a573-2392e6016aa9",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "d6fe8bfd-1643-4149-9131-8c1c8058022d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we really want to erase all occurrences of `export const` or only strip a prefix? Maybe [`Data.Text.stripPrefix`](https://www.stackage.org/haddock/lts-14.6/text-1.2.3.1/Data-Text.html#v:stripPrefix) is a better fit?",
        "createdAt" : "2020-01-14T19:39:15Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "216c0ce0-1cca-45a1-9ed9-f597f022c006",
        "parentId" : "d6fe8bfd-1643-4149-9131-8c1c8058022d",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm also wondering if `genDefDataType` is returning the wrong thing since we have to do so much mangling on it's result. Maybe we should do some refactoring here.",
        "createdAt" : "2020-01-14T19:45:04Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c6cae1e7-c350-4bef-9fa7-a0acb155cb17",
        "parentId" : "d6fe8bfd-1643-4149-9131-8c1c8058022d",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "(1) Probably doesn't matter but `Data.Text.stripPrefix` better captures my intents.\r\n(2) Maybe.",
        "createdAt" : "2020-01-14T19:57:26Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -107,31 +111,75 @@ genModule curPkgId mod\n     in\n     Just $ T.unlines $ intercalate [\"\"] $ filter (not . null) $ header : imports : defs\n   where\n-    serDefs = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n+    serDefs = defDataTypes mod\n+\n+defDataTypes :: Module -> [DefDataType]\n+defDataTypes mod = filter (getIsSerializable . dataSerializable) (NM.toList (moduleDataTypes mod))\n \n-genDataDef :: PackageId -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDataDef curPkgId curModName tpls def = case unTypeConName (dataTypeCon def) of\n+genDataDef :: PackageId -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDataDef curPkgId mod tpls def = case unTypeConName (dataTypeCon def) of\n     [] -> error \"IMPOSSIBLE: empty type constructor name\"\n     _: _: _: _ -> error \"IMPOSSIBLE: multi-part type constructor of more than two names\"\n-    [conName] -> genDefDataType curPkgId conName curModName tpls def\n-    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, makeNamespace $ map (\"  \" <>) sers), refs)\n+\n+    [conName] -> genDefDataType curPkgId conName mod tpls def\n+    [c1, c2] -> ((makeNamespace $ map (\"  \" <>) typs, []), refs)\n       where\n-        ((typs, sers), refs) = genDefDataType curPkgId c2 curModName tpls def\n-        ns = c1 <> \"_NS\"\n+        ((typs, _), refs) = genDefDataType curPkgId c2 mod tpls def\n+        ns = c1\n         makeNamespace stuff =\n           [ \"// eslint-disable-next-line @typescript-eslint/no-namespace\"\n-          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns] ++ [\"\"]\n+          , \"export namespace \" <> ns <> \" {\"] ++ stuff ++ [\"} //namespace \" <> ns]\n \n-genDefDataType :: PackageId -> T.Text -> ModuleName -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n-genDefDataType curPkgId conName curModName tpls def =\n+genDefDataType :: PackageId -> T.Text -> Module -> NM.NameMap Template -> DefDataType -> (([T.Text], [T.Text]), Set.Set ModuleRef)\n+genDefDataType curPkgId conName mod tpls def =\n     case dataCons def of\n         DataVariant bs ->\n           let\n             (typs, sers) = unzip $ map genBranch bs\n-            typeDesc = [\"\"] ++ typs\n-            serDesc  = [\"() => jtv.oneOf<\" <> conName <> typeParams <> \">(\"] ++ sers ++ [\")\"]\n-          in\n-          ((makeType typeDesc, makeSer serDesc), Set.unions $ map (Set.setOf typeModuleRef . snd) bs)\n+            typeDesc = makeType ([\"\"] ++ typs)\n+            typ = conName <> typeParams -- Type of the variant.\n+            assocDefs = assocDefDataTypes mod conName -- Associated types.\n+            serDesc =\n+              if not $ null paramNames -- Polymorphic type.\n+              then -- Companion function.\n+                let\n+                  -- Any associated serializers.\n+                  assocSers = map\n+                    (\\(n, d) -> serFromDef id n curPkgId mod tpls d)\n+                    assocDefs\n+                  -- The variant deserializer.\n+                  function = (makeSer ( [\"() => jtv.oneOf<\" <> typ <> \">(\"] ++ sers ++ [\")\"]) & onLast (<> \";\"));\n+                  props = -- Fix the first and last line of each serializer.\n+                    concatMap (onHead (erase \"export const \") . onLast (<> \";\")) assocSers"
  },
  {
    "id" : "a11e41c4-8230-4d89-914e-57d08e244f7e",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "f84c5ea0-5a9f-4414-a9fa-bab913494ff9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not a big fan of this layout of type signatures. If you change the name of the function (to a different length) you either get diff noise or ugly code.",
        "createdAt" : "2020-01-14T19:40:41Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a7c57e11-f542-4333-9a27-442108da5e31",
        "parentId" : "f84c5ea0-5a9f-4414-a9fa-bab913494ff9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "I'm generally not either. I'll go linear on it.",
        "createdAt" : "2020-01-14T20:00:35Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "093a4026-46b3-4f38-a9f5-1f3004666d9d",
        "parentId" : "f84c5ea0-5a9f-4414-a9fa-bab913494ff9",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "When it gets too long, I usually write\r\n```\r\nfoo ::\r\n  A ->\r\n  B ->\r\n  C\r\n```\r\nThis is maybe not the most pretty but does not have any of the issues I mentioned above. Others would write\r\n```\r\nfoo\r\n  :: A\r\n  -> B\r\n  -> C\r\n```\r\nbut I don't like that too much because it gets diff-noisy if you want to add a new first parameter.\r\nMy version also has the advantage that you can grep for `foo ::` to find the type of foo.",
        "createdAt" : "2020-01-14T20:11:31Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8fa9eb16-a49b-4c87-989e-e6a0ce457956",
        "parentId" : "f84c5ea0-5a9f-4414-a9fa-bab913494ff9",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Moved to the `where` clause, no signature since no longer top-level.",
        "createdAt" : "2020-01-14T20:34:43Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -315,3 +362,34 @@ onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n     x:xs -> f x:xs\n+\n+onLast :: (a -> a) -> [a] -> [a]\n+onLast f = \\case\n+  [] -> []\n+  [l] -> [f l]\n+  x : xs -> x : onLast f xs\n+\n+-- A type such as\n+--   data Q = C { x: Int, y: Text }| G { z: Bool }\n+-- has a DAML-LF representation like,\n+--   record Q.C = { x: Int, y: String }\n+--   record Q.G = { z: Bool }\n+--   variant Q = C Q.C | G Q.G\n+-- Use this function to get the definitions of 'Q.C' and 'Q.G' given\n+-- 'Q'.\n+assocDefDataTypes :: Module -> T.Text -> [((T.Text, T.Text), DefDataType)]\n+assocDefDataTypes m c =\n+  [((sup, sub ), def) | def <- defDataTypes m\n+    , [sup, sub] <- [unTypeConName (dataTypeCon def)], sup == c]\n+\n+-- Extract the serialization code associated with a data type\n+-- definition.\n+serFromDef :: ([T.Text] -> c)"
  },
  {
    "id" : "5a13da86-fc5e-4281-87a3-64a19f32ffdd",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "e8e368f8-870e-47f6-969e-404941bada30",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This function is so simple, we should inline it, particularly since it's quite hard to come up with a good descriptive name for it.",
        "createdAt" : "2020-01-14T19:41:29Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ae50163f-4f36-4a58-af29-75e8e1c0a49d",
        "parentId" : "e8e368f8-870e-47f6-969e-404941bada30",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "There are two call sites, that's why I factored it out - it's a beast. What I could do is make it local to `genDefDataType`. Would that do?",
        "createdAt" : "2020-01-14T20:01:37Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b94d01ce-3af7-4c21-a3d2-b37bdbe31516",
        "parentId" : "e8e368f8-870e-47f6-969e-404941bada30",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Yes, that would do.",
        "createdAt" : "2020-01-14T20:09:18Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -315,3 +362,34 @@ onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n     x:xs -> f x:xs\n+\n+onLast :: (a -> a) -> [a] -> [a]\n+onLast f = \\case\n+  [] -> []\n+  [l] -> [f l]\n+  x : xs -> x : onLast f xs\n+\n+-- A type such as\n+--   data Q = C { x: Int, y: Text }| G { z: Bool }\n+-- has a DAML-LF representation like,\n+--   record Q.C = { x: Int, y: String }\n+--   record Q.G = { z: Bool }\n+--   variant Q = C Q.C | G Q.G\n+-- Use this function to get the definitions of 'Q.C' and 'Q.G' given\n+-- 'Q'.\n+assocDefDataTypes :: Module -> T.Text -> [((T.Text, T.Text), DefDataType)]\n+assocDefDataTypes m c =\n+  [((sup, sub ), def) | def <- defDataTypes m\n+    , [sup, sub] <- [unTypeConName (dataTypeCon def)], sup == c]\n+\n+-- Extract the serialization code associated with a data type\n+-- definition.\n+serFromDef :: ([T.Text] -> c)\n+           -> (T.Text, T.Text)\n+           -> PackageId -> Module -> NM.NameMap Template\n+           -> DefDataType -> c\n+serFromDef f (c1, c2) curPkgId mod tpls = f . snd . fst . genDefDataType curPkgId (c1 `dot` c2) mod tpls"
  },
  {
    "id" : "5b44d0be-35f5-4424-94b7-39d627122483",
    "prId" : 4047,
    "comments" : [
      {
        "id" : "a9a027c4-a691-4c0d-b4e7-0ed3b39596d7",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This type signature feels weird. We should probably do the packing at the call site. If the string we want to delete is a literal and we have `OverloadedStrings` turned on, then we don't need to do any explicit packing anyway.",
        "createdAt" : "2020-01-14T19:43:07Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "67ceb212-fe2f-469d-a08f-2f968400bf87",
        "parentId" : "a9a027c4-a691-4c0d-b4e7-0ed3b39596d7",
        "author" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "body" : "Packing at the call site obfuscates the code which is why I pulled it out. That said, going to remove `erase` anyway.",
        "createdAt" : "2020-01-14T20:02:48Z",
        "updatedAt" : "2020-01-14T21:12:06Z",
        "lastEditedBy" : {
          "login" : "shayne-fletcher",
          "name" : "Shayne Fletcher",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/1500167?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b53294257221487f2c5abc0f6a00dce9cbe09c9b",
    "line" : null,
    "diffHunk" : "@@ -315,3 +362,34 @@ onHead :: (a -> a) -> [a] -> [a]\n onHead f = \\case\n     [] -> []\n     x:xs -> f x:xs\n+\n+onLast :: (a -> a) -> [a] -> [a]\n+onLast f = \\case\n+  [] -> []\n+  [l] -> [f l]\n+  x : xs -> x : onLast f xs\n+\n+-- A type such as\n+--   data Q = C { x: Int, y: Text }| G { z: Bool }\n+-- has a DAML-LF representation like,\n+--   record Q.C = { x: Int, y: String }\n+--   record Q.G = { z: Bool }\n+--   variant Q = C Q.C | G Q.G\n+-- Use this function to get the definitions of 'Q.C' and 'Q.G' given\n+-- 'Q'.\n+assocDefDataTypes :: Module -> T.Text -> [((T.Text, T.Text), DefDataType)]\n+assocDefDataTypes m c =\n+  [((sup, sub ), def) | def <- defDataTypes m\n+    , [sup, sub] <- [unTypeConName (dataTypeCon def)], sup == c]\n+\n+-- Extract the serialization code associated with a data type\n+-- definition.\n+serFromDef :: ([T.Text] -> c)\n+           -> (T.Text, T.Text)\n+           -> PackageId -> Module -> NM.NameMap Template\n+           -> DefDataType -> c\n+serFromDef f (c1, c2) curPkgId mod tpls = f . snd . fst . genDefDataType curPkgId (c1 `dot` c2) mod tpls\n+\n+-- Erase occurrences of string in text.\n+erase :: String -> T.Text -> T.Text"
  },
  {
    "id" : "47a42c0d-a9fc-416e-bdf5-0883b7bede3b",
    "prId" : 4010,
    "comments" : [
      {
        "id" : "bac729b6-fb92-4f26-b5b3-5b270b7190e5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Looks like somebody burnt his fingers on the `<X<Y>>` vs `<X<Y> >` quirk in C++ in the past. This is not an issue in TypeScript. :)",
        "createdAt" : "2020-01-10T14:41:32Z",
        "updatedAt" : "2020-01-10T14:41:43Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6edc0456-3205-4ca4-8565-512bff3fbdab",
        "parentId" : "bac729b6-fb92-4f26-b5b3-5b270b7190e5",
        "author" : null,
        "body" : "i know. it's like drilled into my brain. it's not even an issue in \"modern\" C++ anymore.",
        "createdAt" : "2020-01-10T14:44:26Z",
        "updatedAt" : "2020-01-10T14:46:37Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "b5284a5a7154b6d90166eefbdae861e0721cd9e1",
    "line" : 4,
    "diffHunk" : "@@ -180,7 +180,7 @@ genDefDataType curPkgId conName curModName tpls def =\n                                 (keyTypeTs, \"() => \" <> keySer <> \".decoder()\")\n                         dict =\n                             [\"export const \" <> conName <> \": daml.Template<\" <> conName <> \", \" <> keyTypeTs <> \"> & {\"] ++\n-                            [\"  \" <> x <> \": daml.Choice<\" <> conName <> \", \" <> t <> \", \" <> rtyp <> \" >;\" | (x, t, rtyp, _) <- chcs] ++"
  },
  {
    "id" : "4f61e061-7713-4a30-ada5-589067747906",
    "prId" : 3988,
    "comments" : [
      {
        "id" : "c5f42c58-416d-4df2-a574-fafdb21a456b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We can put the `|` even before the first case, like in OCaml. Let's do that and avoid the special case.",
        "createdAt" : "2020-01-08T17:19:47Z",
        "updatedAt" : "2020-01-08T17:29:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d63644fb-cc95-43c0-a637-a9cfa50494dc",
        "parentId" : "c5f42c58-416d-4df2-a574-fafdb21a456b",
        "author" : null,
        "body" : "Ooh! Testing. If all good will fix.",
        "createdAt" : "2020-01-08T17:26:32Z",
        "updatedAt" : "2020-01-08T17:29:55Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "619571ce48c764a0df32497d8fb3566eca5eccd9",
    "line" : null,
    "diffHunk" : "@@ -216,6 +222,12 @@ genDefDataType curModName tpls def = case unTypeConName (dataTypeCon def) of\n             ] ++\n             map (\"  \" <>) (onHead (\"export const decoder = \" <>) serDesc) ++\n             [\"}\"]\n+        genBranch ((VariantConName cons, t), i) =\n+          let (typ, ser) = (genType curModName t) in\n+          ( (if i == 0 then \"     \" else \"  |  \") <> \"{ tag: '\" <> cons <> \"'; value: \" <> typ <> \" }\""
  },
  {
    "id" : "5d720fc4-7363-428c-ab13-4ee20aa5a164",
    "prId" : 3988,
    "comments" : [
      {
        "id" : "d33e45ea-7d9a-475f-a677-f68b20f8d90f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we really need this? If so, I'd be more happy to use the form which only turns off the warning for the next line whenever we need it, as we do it with the `no-namespace` warning.",
        "createdAt" : "2020-01-08T17:21:04Z",
        "updatedAt" : "2020-01-08T17:29:55Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8a846ad7-cf65-457a-a23b-eef52a5fb7f5",
        "parentId" : "d33e45ea-7d9a-475f-a677-f68b20f8d90f",
        "author" : null,
        "body" : "Oops, that was left over when I was testing stuff. Will remove!",
        "createdAt" : "2020-01-08T17:24:27Z",
        "updatedAt" : "2020-01-08T17:29:55Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "619571ce48c764a0df32497d8fb3566eca5eccd9",
    "line" : null,
    "diffHunk" : "@@ -90,6 +90,7 @@ genModule mod\n         (defSers, refs) = unzip (map (genDefDataType curModName tpls) serDefs)\n         header =\n             [\"// Generated from \" <> T.intercalate \"/\" (unModuleName curModName) <> \".daml\"\n+            ,\"/* eslint-disable @typescript-eslint/no-unused-vars */\""
  },
  {
    "id" : "75dd8f06-dc6a-438f-bb5d-7c97efcf1836",
    "prId" : 3959,
    "comments" : [
      {
        "id" : "ee7dc6e5-87ae-4d7c-a434-dff3772c736e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This should be an impossible not a TODO since type synonyms are not serializable.",
        "createdAt" : "2020-01-09T19:06:45Z",
        "updatedAt" : "2020-01-10T16:41:51Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "08312672-a1ef-4e76-b6d5-0e04995b6ec9",
        "parentId" : "ee7dc6e5-87ae-4d7c-a434-dff3772c736e",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done",
        "createdAt" : "2020-01-10T10:16:31Z",
        "updatedAt" : "2020-01-10T16:41:51Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6a9feaae0a6921e3c04c93a65e754eca04cc83df",
    "line" : null,
    "diffHunk" : "@@ -261,8 +261,8 @@ genType curModName = go\n                     ( con' <> \"<\" <> T.intercalate \", \" ts' <> \">\"\n                     , ser <> \"(\" <> T.intercalate \", \" sers <> \")\"\n                     )\n-        TSyn _ -> error \"TODO: genType, type synonym\"\n         TCon _ -> error \"IMPOSSIBLE: lonely type constructor\"\n+        TSynApp{} -> error \"TODO: genType, type synonym\""
  },
  {
    "id" : "dec8b0a3-3b88-48b5-bc97-e661fac87078",
    "prId" : 3895,
    "comments" : [
      {
        "id" : "bf3ad308-3bc2-4ad7-ad3b-a6d0b25aee62",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we please spell this out?\r\n```suggestion\r\n                              ,\"    argumentDecoder: \" <> t <> \".decoder,\"\r\n```",
        "createdAt" : "2019-12-20T10:23:57Z",
        "updatedAt" : "2019-12-20T12:56:44Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a63d1a81485323a7fa5c1e1b7822721fa74377e8",
    "line" : null,
    "diffHunk" : "@@ -173,10 +175,20 @@ genDefDataType curModName tpls def = case unTypeConName (dataTypeCon def) of\n                             [ [\"  \" <> x <> \": {\"\n                               ,\"    template: () => \" <> conName <> \",\"\n                               ,\"    choiceName: '\" <> x <> \"',\"\n-                              ,\"    decoder: \" <> t <> \".decoder,\"\n+                              ,\"    argDecoder: \" <> t <> \".decoder,\""
  },
  {
    "id" : "2ddca1b6-7bad-49ba-87ce-e325c31fe06a",
    "prId" : 3895,
    "comments" : [
      {
        "id" : "99b31e41-d88c-4ac7-aef2-67f6260a7f10",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I suppose `rtyp` is the companion object (ie. `Serializable` dictionary) for the return type. I think I've used something like `rser` below. We should find a consistent naming scheme for these. Not necessarily in this PR but soon.",
        "createdAt" : "2019-12-20T10:26:50Z",
        "updatedAt" : "2019-12-20T12:56:44Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b5b826ad-099a-4f23-936d-3b6dd9ba54e2",
        "parentId" : "99b31e41-d88c-4ac7-aef2-67f6260a7f10",
        "author" : null,
        "body" : "Ok",
        "createdAt" : "2019-12-20T11:51:55Z",
        "updatedAt" : "2019-12-20T12:56:44Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "a63d1a81485323a7fa5c1e1b7822721fa74377e8",
    "line" : 5,
    "diffHunk" : "@@ -155,15 +155,17 @@ genDefDataType curModName tpls def = case unTypeConName (dataTypeCon def) of\n                 Nothing -> ((makeType typeDesc, makeSer serDesc), Set.unions fieldRefs)\n                 Just tpl ->\n                     let (chcs, argRefs) = unzip\n-                            [((unChoiceName (chcName chc), t), argRefs)\n+                            [((unChoiceName (chcName chc), t, r, rtyp), argRefs)"
  }
]