[
  {
    "id" : "df9e2b5b-2389-42c9-b231-5af53f4cfba5",
    "prId" : 3487,
    "comments" : [
      {
        "id" : "ccc5cd26-2308-43a8-8c72-ff2253a85693",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      case TypePrim(PT.GenMap, ImmArraySeq(_, _)) =>\r\n```",
        "createdAt" : "2019-11-15T21:09:41Z",
        "updatedAt" : "2019-11-16T17:30:33Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5bd89843a41d4e8caad72189db7f14c327cc6e89",
    "line" : null,
    "diffHunk" : "@@ -107,12 +100,14 @@ final case class LFUtil(\n       case TypePrim(PT.ContractId, ImmArraySeq(typ)) =>\n         val templateType = genTypeToScalaType(typ)\n         q\"$primitiveObject.ContractId[$templateType]\"\n-      case TypePrim(PTOptional, ImmArraySeq(typ)) =>\n+      case TypePrim(PT.Optional, ImmArraySeq(typ)) =>\n         val optType = genTypeToScalaType(typ)\n         q\"$primitiveObject.Optional[$optType]\"\n-      case TypePrim(PTMap, ImmArraySeq(typ)) =>\n+      case TypePrim(PT.Map, ImmArraySeq(typ)) =>\n         val optType = genTypeToScalaType(typ)\n         q\"$primitiveObject.Map[$optType]\"\n+      case TypePrim(PT.GenMap, ImmArraySeq(_)) =>"
  },
  {
    "id" : "4a3476ca-27c9-428a-92f0-18e38123b711",
    "prId" : 2666,
    "comments" : [
      {
        "id" : "64ada547-ac26-48f3-9f2b-67a2ae714ba6",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "`ValuePrimitiveEncoding` should still have a case for `P.Decimal`, which will codec numerics now in accordance with this mapping. Note, you will _properly_ not have access to a value-level scale in that interface. If you want one, we need to represent `Numeric` in Scala codegen with a phantom Nat type parameter on `Primitive.Decimal` (referenced here), which `ValuePrimitiveEncoding` can then reify. Likewise, this doesn't have to be considered in this PR.",
        "createdAt" : "2019-08-27T19:49:45Z",
        "updatedAt" : "2019-09-02T07:14:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8d62b26852e6615fe747f0ba481e7618f14b9eb5",
    "line" : null,
    "diffHunk" : "@@ -121,6 +120,7 @@ final case class LFUtil(\n       case TypeCon(name, typeArgs) =>\n         TypeApply(refTypeToIdent(name), typeArgs.toList map genTypeToScalaType)\n       case TypeVar(name) => toIdent(name)\n+      case TypeNumeric(_) => q\"$primitiveObject.Decimal\""
  }
]