[
  {
    "id" : "bf3fcd32-4b36-4280-9c6f-da85c94f7519",
    "prId" : 1586,
    "comments" : [
      {
        "id" : "698cd3f8-f9e3-4d38-963d-c880f98f50dd",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "You could build up the return statement with something like the following to avoid having to duplicate the statement itself:\r\n```\r\nval names = Vector(idFieldName, dataFieldName, agreementFieldName) ++ maybeContractKeyClassName.map(_ => contractKeyFieldName)\r\nval params = names.map(n => CodeBlock.of(\"$L\", n)).asJava\r\nval allParams = CodeBlock.join(params, \", \")\r\nspec.addStatement(\"return new $T($L)\", className, params)\r\n```",
        "createdAt" : "2019-06-14T11:46:44Z",
        "updatedAt" : "2019-06-14T16:11:37Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c72fe0a0-70bc-4d58-8ea8-35219ff7e9c8",
        "parentId" : "698cd3f8-f9e3-4d38-963d-c880f98f50dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Thanks, both my Scala and my `javapoet` became rusty after the last few months. :slightly_smiling_face: ",
        "createdAt" : "2019-06-14T12:31:32Z",
        "updatedAt" : "2019-06-14T16:11:37Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "02c2f1bb-ef56-47ed-b335-fe191a2caa5e",
        "parentId" : "698cd3f8-f9e3-4d38-963d-c880f98f50dd",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Addressed by https://github.com/digital-asset/daml/pull/1586/commits/42493732637d847f3a881a533ac2d387bd5d14f9",
        "createdAt" : "2019-06-14T13:23:20Z",
        "updatedAt" : "2019-06-14T16:11:37Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20b0f1885b012a4746444d093ee4c22d94978e27",
    "line" : null,
    "diffHunk" : "@@ -62,116 +62,183 @@ private[inner] object TemplateClass extends StrictLogging {\n   private val idFieldName = \"id\"\n   private val dataFieldName = \"data\"\n   private val agreementFieldName = \"agreementText\"\n-  private val contractKeyFieldName = \"contractKey\"\n+  private val contractKeyFieldName = \"key\"\n \n   private val optionalString = ParameterizedTypeName.get(classOf[Optional[_]], classOf[String])\n-  private val optionalValue = ParameterizedTypeName.get(classOf[Optional[_]], classOf[Value])\n+  private def optional(name: TypeName) =\n+    ParameterizedTypeName.get(ClassName.get(classOf[Optional[_]]), name)\n+\n+  private def generateContractClass(\n+      templateClassName: ClassName,\n+      key: Option[Type],\n+      packagePrefixes: Map[PackageId, String]): TypeSpec = {\n \n-  private def generateContractClass(templateClassName: ClassName): TypeSpec = {\n     val contractIdClassName = ClassName.bestGuess(\"ContractId\")\n+    val contractKeyClassName = key.map(toJavaTypeName(_, packagePrefixes))\n+\n     val classBuilder =\n       TypeSpec.classBuilder(\"Contract\").addModifiers(Modifier.STATIC, Modifier.PUBLIC)\n+\n     classBuilder.addField(contractIdClassName, idFieldName, Modifier.PUBLIC, Modifier.FINAL)\n     classBuilder.addField(templateClassName, dataFieldName, Modifier.PUBLIC, Modifier.FINAL)\n     classBuilder.addField(optionalString, agreementFieldName, Modifier.PUBLIC, Modifier.FINAL)\n-    classBuilder.addField(optionalValue, contractKeyFieldName, Modifier.PUBLIC, Modifier.FINAL)\n+\n     classBuilder.addSuperinterface(ClassName.get(classOf[javaapi.data.Contract]))\n+\n     val constructorBuilder = MethodSpec\n       .constructorBuilder()\n       .addModifiers(Modifier.PUBLIC)\n       .addParameter(contractIdClassName, idFieldName)\n       .addParameter(templateClassName, dataFieldName)\n       .addParameter(optionalString, agreementFieldName)\n-      .addParameter(optionalValue, contractKeyFieldName)\n+\n     constructorBuilder.addStatement(\"this.$L = $L\", idFieldName, idFieldName)\n     constructorBuilder.addStatement(\"this.$L = $L\", dataFieldName, dataFieldName)\n     constructorBuilder.addStatement(\"this.$L = $L\", agreementFieldName, agreementFieldName)\n-    constructorBuilder.addStatement(\"this.$L = $L\", contractKeyFieldName, contractKeyFieldName);\n+\n+    contractKeyClassName.foreach { name =>\n+      classBuilder.addField(optional(name), contractKeyFieldName, Modifier.PUBLIC, Modifier.FINAL)\n+      constructorBuilder.addParameter(optional(name), contractKeyFieldName)\n+      constructorBuilder.addStatement(\"this.$L = $L\", contractKeyFieldName, contractKeyFieldName)\n+    }\n+\n     val constructor = constructorBuilder.build()\n \n     classBuilder.addMethod(constructor)\n \n     val contractClassName = ClassName.bestGuess(\"Contract\")\n     val fields = Array(idFieldName, dataFieldName, agreementFieldName)\n     classBuilder\n-      .addMethod(generateFromIdAndRecord(contractClassName, templateClassName, contractIdClassName))\n+      .addMethod(\n+        generateFromIdAndRecord(\n+          contractClassName,\n+          templateClassName,\n+          contractIdClassName,\n+          contractKeyClassName))\n       .addMethod(\n         generateFromIdAndRecordDeprecated(\n           contractClassName,\n           templateClassName,\n-          contractIdClassName))\n+          contractIdClassName,\n+          contractKeyClassName.isDefined))\n       .addMethod(\n-        generateFromCreatedEvent(contractClassName, templateClassName, contractIdClassName))\n+        generateFromCreatedEvent(\n+          contractClassName,\n+          templateClassName,\n+          contractIdClassName,\n+          contractKeyClassName))\n       .addMethods(ObjectMethods(contractClassName, fields, templateClassName).asJava)\n       .build()\n   }\n \n   private[inner] def generateFromIdAndRecord(\n       className: ClassName,\n       templateClassName: ClassName,\n-      idClassName: ClassName): MethodSpec =\n-    MethodSpec\n-      .methodBuilder(\"fromIdAndRecord\")\n-      .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-      .returns(className)\n-      .addParameter(classOf[String], \"contractId\")\n-      .addParameter(classOf[javaapi.data.Record], \"record$\")\n-      .addParameter(optionalString, agreementFieldName)\n-      .addParameter(optionalValue, contractKeyFieldName)\n-      .addStatement(\"$T $L = new $T(contractId)\", idClassName, idFieldName, idClassName)\n-      .addStatement(\n-        \"$T $L = $T.fromValue(record$$)\",\n-        templateClassName,\n-        dataFieldName,\n-        templateClassName)\n-      .addStatement(\n+      idClassName: ClassName,\n+      maybeContractKeyClassName: Option[TypeName]): MethodSpec = {\n+\n+    val params = Iterable(\n+      ParameterSpec.builder(classOf[String], \"contractId\").build(),\n+      ParameterSpec.builder(classOf[javaapi.data.Record], \"record$\").build(),\n+      ParameterSpec.builder(optionalString, agreementFieldName).build()\n+    ) ++ maybeContractKeyClassName\n+      .map(name => ParameterSpec.builder(optional(name), contractKeyFieldName).build)\n+      .toList\n+\n+    val spec =\n+      MethodSpec\n+        .methodBuilder(\"fromIdAndRecord\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+        .returns(className)\n+        .addParameters(params.asJava)\n+        .addStatement(\"$T $L = new $T(contractId)\", idClassName, idFieldName, idClassName)\n+        .addStatement(\n+          \"$T $L = $T.fromValue(record$$)\",\n+          templateClassName,\n+          dataFieldName,\n+          templateClassName)\n+\n+    if (maybeContractKeyClassName.isDefined) {\n+      spec.addStatement(\n         \"return new $T($L, $L, $L, $L)\",\n         className,\n         idFieldName,\n         dataFieldName,\n         agreementFieldName,\n-        contractKeyFieldName\n-      )\n-      .build()\n+        contractKeyFieldName)\n+    } else {\n+      spec.addStatement(\n+        \"return new $T($L, $L, $L)\","
  },
  {
    "id" : "437550bb-3b52-416b-af11-c58927f4d317",
    "prId" : 1586,
    "comments" : [
      {
        "id" : "1d99bea2-e33b-4858-94bb-9a0ea4f1f7f6",
        "parentId" : null,
        "author" : {
          "login" : "jberthold-da",
          "name" : "Jost Berthold",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/28879196?u=41dee6fb7ab2761a566b324e2f4e5ad9b577ae0e&v=4"
        },
        "body" : "Unfortunately this seems to not work as expected when `t` is a `TupleN` for some N.\r\nThe `fromValue` functions for tuples expect additional arguments to convert the components.",
        "createdAt" : "2019-06-18T02:01:13Z",
        "updatedAt" : "2019-06-18T02:01:14Z",
        "lastEditedBy" : {
          "login" : "jberthold-da",
          "name" : "Jost Berthold",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/28879196?u=41dee6fb7ab2761a566b324e2f4e5ad9b577ae0e&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "27626c7c-8547-4534-b59b-009fee476a64",
        "parentId" : "1d99bea2-e33b-4858-94bb-9a0ea4f1f7f6",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Totally right, fixed by #1743, thanks for the detailed report.",
        "createdAt" : "2019-06-18T15:02:26Z",
        "updatedAt" : "2019-06-18T15:02:26Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "20b0f1885b012a4746444d093ee4c22d94978e27",
    "line" : 199,
    "diffHunk" : "@@ -62,109 +62,165 @@ private[inner] object TemplateClass extends StrictLogging {\n   private val idFieldName = \"id\"\n   private val dataFieldName = \"data\"\n   private val agreementFieldName = \"agreementText\"\n+  private val contractKeyFieldName = \"key\"\n \n   private val optionalString = ParameterizedTypeName.get(classOf[Optional[_]], classOf[String])\n+  private def optional(name: TypeName) =\n+    ParameterizedTypeName.get(ClassName.get(classOf[Optional[_]]), name)\n+\n+  private def generateContractClass(\n+      templateClassName: ClassName,\n+      key: Option[Type],\n+      packagePrefixes: Map[PackageId, String]): TypeSpec = {\n \n-  private def generateContractClass(templateClassName: ClassName): TypeSpec = {\n     val contractIdClassName = ClassName.bestGuess(\"ContractId\")\n+    val contractKeyClassName = key.map(toJavaTypeName(_, packagePrefixes))\n+\n     val classBuilder =\n       TypeSpec.classBuilder(\"Contract\").addModifiers(Modifier.STATIC, Modifier.PUBLIC)\n+\n     classBuilder.addField(contractIdClassName, idFieldName, Modifier.PUBLIC, Modifier.FINAL)\n     classBuilder.addField(templateClassName, dataFieldName, Modifier.PUBLIC, Modifier.FINAL)\n     classBuilder.addField(optionalString, agreementFieldName, Modifier.PUBLIC, Modifier.FINAL)\n+\n     classBuilder.addSuperinterface(ClassName.get(classOf[javaapi.data.Contract]))\n+\n     val constructorBuilder = MethodSpec\n       .constructorBuilder()\n       .addModifiers(Modifier.PUBLIC)\n       .addParameter(contractIdClassName, idFieldName)\n       .addParameter(templateClassName, dataFieldName)\n       .addParameter(optionalString, agreementFieldName)\n+\n     constructorBuilder.addStatement(\"this.$L = $L\", idFieldName, idFieldName)\n     constructorBuilder.addStatement(\"this.$L = $L\", dataFieldName, dataFieldName)\n     constructorBuilder.addStatement(\"this.$L = $L\", agreementFieldName, agreementFieldName)\n+\n+    contractKeyClassName.foreach { name =>\n+      classBuilder.addField(optional(name), contractKeyFieldName, Modifier.PUBLIC, Modifier.FINAL)\n+      constructorBuilder.addParameter(optional(name), contractKeyFieldName)\n+      constructorBuilder.addStatement(\"this.$L = $L\", contractKeyFieldName, contractKeyFieldName)\n+    }\n+\n     val constructor = constructorBuilder.build()\n \n     classBuilder.addMethod(constructor)\n \n     val contractClassName = ClassName.bestGuess(\"Contract\")\n     val fields = Array(idFieldName, dataFieldName, agreementFieldName)\n     classBuilder\n-      .addMethod(generateFromIdAndRecord(contractClassName, templateClassName, contractIdClassName))\n+      .addMethod(\n+        generateFromIdAndRecord(\n+          contractClassName,\n+          templateClassName,\n+          contractIdClassName,\n+          contractKeyClassName))\n       .addMethod(\n         generateFromIdAndRecordDeprecated(\n           contractClassName,\n           templateClassName,\n-          contractIdClassName))\n+          contractIdClassName,\n+          contractKeyClassName))\n       .addMethod(\n-        generateFromCreatedEvent(contractClassName, templateClassName, contractIdClassName))\n+        generateFromCreatedEvent(\n+          contractClassName,\n+          templateClassName,\n+          contractIdClassName,\n+          contractKeyClassName))\n       .addMethods(ObjectMethods(contractClassName, fields, templateClassName).asJava)\n       .build()\n   }\n \n   private[inner] def generateFromIdAndRecord(\n       className: ClassName,\n       templateClassName: ClassName,\n-      idClassName: ClassName): MethodSpec =\n-    MethodSpec\n-      .methodBuilder(\"fromIdAndRecord\")\n-      .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-      .returns(className)\n-      .addParameter(classOf[String], \"contractId\")\n-      .addParameter(classOf[javaapi.data.Record], \"record$\")\n-      .addParameter(\n-        ParameterizedTypeName.get(classOf[Optional[_]], classOf[String]),\n-        agreementFieldName)\n-      .addStatement(\"$T $L = new $T(contractId)\", idClassName, idFieldName, idClassName)\n-      .addStatement(\n-        \"$T $L = $T.fromValue(record$$)\",\n-        templateClassName,\n-        dataFieldName,\n-        templateClassName)\n-      .addStatement(\n-        \"return new $T($L, $L, $L)\",\n-        className,\n-        idFieldName,\n-        dataFieldName,\n-        agreementFieldName)\n-      .build()\n+      idClassName: ClassName,\n+      maybeContractKeyClassName: Option[TypeName]): MethodSpec = {\n+\n+    val methodParameters = Iterable(\n+      ParameterSpec.builder(classOf[String], \"contractId\").build(),\n+      ParameterSpec.builder(classOf[javaapi.data.Record], \"record$\").build(),\n+      ParameterSpec.builder(optionalString, agreementFieldName).build()\n+    ) ++ maybeContractKeyClassName\n+      .map(name => ParameterSpec.builder(optional(name), contractKeyFieldName).build)\n+      .toList\n+\n+    val spec =\n+      MethodSpec\n+        .methodBuilder(\"fromIdAndRecord\")\n+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+        .returns(className)\n+        .addParameters(methodParameters.asJava)\n+        .addStatement(\"$T $L = new $T(contractId)\", idClassName, idFieldName, idClassName)\n+        .addStatement(\n+          \"$T $L = $T.fromValue(record$$)\",\n+          templateClassName,\n+          dataFieldName,\n+          templateClassName)\n+\n+    val callParameterNames = Vector(idFieldName, dataFieldName, agreementFieldName) ++ maybeContractKeyClassName\n+      .map(_ => contractKeyFieldName)\n+      .toList\n+    val callParameters = CodeBlock.join(callParameterNames.map(CodeBlock.of(_)).asJava, \", \")\n+    spec.addStatement(\"return new $T($L)\", className, callParameters).build()\n+  }\n+\n+  private val emptyOptional = CodeBlock.of(\"$T.empty()\", classOf[Optional[_]])\n \n   private[inner] def generateFromIdAndRecordDeprecated(\n       className: ClassName,\n       templateClassName: ClassName,\n-      idClassName: ClassName): MethodSpec =\n-    MethodSpec\n-      .methodBuilder(\"fromIdAndRecord\")\n-      .addAnnotation(classOf[Deprecated])\n-      .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n-      .returns(className)\n-      .addParameter(classOf[String], \"contractId\")\n-      .addParameter(classOf[javaapi.data.Record], \"record$\")\n-      .addStatement(\"$T $L = new $T(contractId)\", idClassName, idFieldName, idClassName)\n-      .addStatement(\n-        \"$T $L = $T.fromValue(record$$)\",\n-        templateClassName,\n-        dataFieldName,\n-        templateClassName)\n-      .addStatement(\n-        \"return new $T($L, $L, $T.empty())\",\n-        className,\n-        idFieldName,\n-        dataFieldName,\n-        classOf[Optional[_]])\n+      idClassName: ClassName,\n+      maybeContractKeyClassName: Option[TypeName]): MethodSpec = {\n+    val spec =\n+      MethodSpec\n+        .methodBuilder(\"fromIdAndRecord\")\n+        .addAnnotation(classOf[Deprecated])\n+        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n+        .returns(className)\n+        .addParameter(classOf[String], \"contractId\")\n+        .addParameter(classOf[javaapi.data.Record], \"record$\")\n+        .addStatement(\"$T $L = new $T(contractId)\", idClassName, idFieldName, idClassName)\n+        .addStatement(\n+          \"$T $L = $T.fromValue(record$$)\",\n+          templateClassName,\n+          dataFieldName,\n+          templateClassName)\n+\n+    val callParameters = Vector(\n+      CodeBlock.of(idFieldName),\n+      CodeBlock.of(dataFieldName),\n+      emptyOptional) ++ maybeContractKeyClassName.map(_ => emptyOptional).toList\n+\n+    spec\n+      .addStatement(\"return new $T($L)\", className, CodeBlock.join(callParameters.asJava, \", \"))\n       .build()\n+  }\n+\n+  private val getContractId = CodeBlock.of(\"event.getContractId()\")\n+  private val getArguments = CodeBlock.of(\"event.getArguments()\")\n+  private val getAgreementText = CodeBlock.of(\"event.getAgreementText()\")\n+  private def getContractKey(t: TypeName) =\n+    CodeBlock.of(\"event.getContractKey().map($T::fromValue)\", t)"
  }
]