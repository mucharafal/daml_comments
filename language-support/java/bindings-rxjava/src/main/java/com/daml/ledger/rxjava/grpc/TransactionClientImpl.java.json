[
  {
    "id" : "81bc4852-efee-4886-b688-013a5d7ac036",
    "prId" : 3733,
    "comments" : [
      {
        "id" : "d9396df2-7ee3-46aa-a697-46037c851144",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Is it a common use-case to use different access tokens per calls on this interface? If not, it would be simpler to pass the access token here once. ",
        "createdAt" : "2019-12-05T09:03:13Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "02e70106-af89-48f5-add8-cc9f2c383f28",
        "parentId" : "d9396df2-7ee3-46aa-a697-46037c851144",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "This will come in the following PR that closes the ticket. You need to have the possibility of passing tokens on a per-call basis to be able to work with possibly expiring tokens.",
        "createdAt" : "2019-12-05T09:29:05Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a577264afd2be0e02604a911a7fa44c2fea02a9a",
    "line" : 22,
    "diffHunk" : "@@ -25,110 +27,190 @@\n     public TransactionClientImpl(String ledgerId, Channel channel, ExecutionSequencerFactory sequencerFactory) {"
  },
  {
    "id" : "8587f5b1-3171-4751-8c02-5cf60e0da510",
    "prId" : 3733,
    "comments" : [
      {
        "id" : "0bc177b3-c9c9-485f-8146-80ec6dc08d17",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Putting both of these words into the plural form sounds strange (maybe @SamirTalwar could comment). I'd suggest naming this method as `getTransactionTrees` as you are retrieving multiple trees that are made up of transactions.",
        "createdAt" : "2019-12-05T09:05:04Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bce5c65e-e177-4560-9b5b-af4f581abe0e",
        "parentId" : "0bc177b3-c9c9-485f-8146-80ec6dc08d17",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I agree that the naming is wrong, but I prefer being wrong and consistent with the existing naming than breaking user code.",
        "createdAt" : "2019-12-05T09:30:12Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9d444f83-273c-4907-86e6-81c0d0cc5001",
        "parentId" : "0bc177b3-c9c9-485f-8146-80ec6dc08d17",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Agree, it's called `TransactionTrees` everywhere else.",
        "createdAt" : "2019-12-05T09:32:58Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a577264afd2be0e02604a911a7fa44c2fea02a9a",
    "line" : 94,
    "diffHunk" : "@@ -25,110 +27,190 @@\n     public TransactionClientImpl(String ledgerId, Channel channel, ExecutionSequencerFactory sequencerFactory) {\n         this.ledgerId = ledgerId;\n         this.sequencerFactory = sequencerFactory;\n-        serviceStub = TransactionServiceGrpc.newStub(channel);\n-        serviceFutureStub = TransactionServiceGrpc.newFutureStub(channel);\n+        this.serviceStub = TransactionServiceGrpc.newStub(channel);\n+        this.serviceFutureStub = TransactionServiceGrpc.newFutureStub(channel);\n     }\n \n-    @Override\n-    public Flowable<Transaction> getTransactions(LedgerOffset begin, LedgerOffset end, TransactionFilter filter, boolean verbose) {\n+    private Flowable<Transaction> extractTransactions(TransactionServiceOuterClass.GetTransactionsRequest request, Optional<String> accessToken) {\n+        return ClientPublisherFlowable\n+                .create(request, StubHelper.authenticating(this.serviceStub, accessToken)::getTransactions, sequencerFactory)\n+                .map(GetTransactionsResponse::fromProto)\n+                .concatMapIterable(GetTransactionsResponse::getTransactions);\n+    }\n+\n+    private Flowable<Transaction> getTransactions(LedgerOffset begin, LedgerOffset end, TransactionFilter filter, boolean verbose, Optional<String> accessToken) {\n         TransactionServiceOuterClass.GetTransactionsRequest request = new GetTransactionsRequest(ledgerId, begin, end, filter, verbose).toProto();\n-        return extractTransactions(request);\n+        return extractTransactions(request, accessToken);\n     }\n \n     @Override\n-    public Flowable<Transaction> getTransactions(LedgerOffset begin, TransactionFilter filter, boolean verbose) {\n-        TransactionServiceOuterClass.GetTransactionsRequest request = new GetTransactionsRequest(ledgerId, begin, filter, verbose).toProto();\n-        return extractTransactions(request);\n+    public Flowable<Transaction> getTransactions(LedgerOffset begin, LedgerOffset end, TransactionFilter filter, boolean verbose) {\n+        return getTransactions(begin, end, filter, verbose, Optional.empty());\n     }\n \n-    private Flowable<Transaction> extractTransactions(TransactionServiceOuterClass.GetTransactionsRequest request) {\n-        return ClientPublisherFlowable\n-                .create(request, serviceStub::getTransactions, sequencerFactory)\n-                .map(GetTransactionsResponse::fromProto)\n-                .concatMapIterable(GetTransactionsResponse::getTransactions);\n+    @Override\n+    public Flowable<Transaction> getTransactions(LedgerOffset begin, LedgerOffset end, TransactionFilter filter, boolean verbose, String accessToken) {\n+        return getTransactions(begin, end, filter, verbose, Optional.of(accessToken));\n     }\n \n+    private Flowable<Transaction> getTransactions(LedgerOffset begin, TransactionFilter filter, boolean verbose, Optional<String> accessToken) {\n+        TransactionServiceOuterClass.GetTransactionsRequest request = new GetTransactionsRequest(ledgerId, begin, filter, verbose).toProto();\n+        return extractTransactions(request, accessToken);\n+    }\n \n     @Override\n-    public Flowable<TransactionTree> getTransactionsTrees(LedgerOffset begin, LedgerOffset end, TransactionFilter filter, boolean verbose) {\n-        TransactionServiceOuterClass.GetTransactionsRequest request = new GetTransactionsRequest(ledgerId, begin, end, filter, verbose).toProto();\n-        return extractTransactionTrees(request);\n+    public Flowable<Transaction> getTransactions(LedgerOffset begin, TransactionFilter filter, boolean verbose) {\n+        return getTransactions(begin, filter, verbose, Optional.empty());\n     }\n \n     @Override\n-    public Flowable<TransactionTree> getTransactionsTrees(LedgerOffset begin, TransactionFilter filter, boolean verbose) {\n-        TransactionServiceOuterClass.GetTransactionsRequest request = new GetTransactionsRequest(ledgerId, begin, filter, verbose).toProto();\n-        return extractTransactionTrees(request);\n+    public Flowable<Transaction> getTransactions(LedgerOffset begin, TransactionFilter filter, boolean verbose, String accessToken) {\n+        return getTransactions(begin, filter, verbose, Optional.of(accessToken));\n     }\n \n-    private Flowable<TransactionTree> extractTransactionTrees(TransactionServiceOuterClass.GetTransactionsRequest request) {\n+    private Flowable<TransactionTree> extractTransactionTrees(TransactionServiceOuterClass.GetTransactionsRequest request, Optional<String> accessToken) {\n         return ClientPublisherFlowable\n-                .create(request, serviceStub::getTransactionTrees, sequencerFactory)\n+                .create(request, StubHelper.authenticating(this.serviceStub, accessToken)::getTransactionTrees, sequencerFactory)\n                 .map(GetTransactionTreesResponse::fromProto)\n                 .concatMapIterable(GetTransactionTreesResponse::getTransactions);\n     }\n \n+    private Flowable<TransactionTree> getTransactionsTrees(LedgerOffset begin, TransactionFilter filter, boolean verbose, Optional<String> accessToken) {"
  }
]