[
  {
    "id" : "2af10864-082f-478b-b0bf-8b2c8b80bf87",
    "prId" : 3733,
    "comments" : [
      {
        "id" : "3e549e57-d35f-473e-af68-f68f82da4232",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "What does this comment mean? Isn't this simply an empty response?\r\nThis is definitely not a mock as it does not record calls (according to nomenclature e.g. https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da).",
        "createdAt" : "2019-12-05T09:12:00Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f48999fb-8ea1-4c60-9ba6-39ee8b673ac1",
        "parentId" : "3e549e57-d35f-473e-af68-f68f82da4232",
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "`lastTransactionByEventIdRequest.set(request)` - it records it in the line above, no?",
        "createdAt" : "2019-12-05T09:44:05Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "dee2c0de-654d-4629-a8ee-ecd59e8c7a2b",
        "parentId" : "3e549e57-d35f-473e-af68-f68f82da4232",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Isn't that what the line above this one does?\r\n```scala\r\n    lastTransactionByEventIdRequest.set(request)\r\n```",
        "createdAt" : "2019-12-05T09:44:33Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4a9b2b65-07de-4eb6-8ed8-b427128832db",
        "parentId" : "3e549e57-d35f-473e-af68-f68f82da4232",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "You're right -- this is indeed a very simple mock.",
        "createdAt" : "2019-12-05T10:04:25Z",
        "updatedAt" : "2019-12-05T10:04:40Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a577264afd2be0e02604a911a7fa44c2fea02a9a",
    "line" : 61,
    "diffHunk" : "@@ -66,61 +71,50 @@ class TransactionServiceImpl(ledgerContent: Observable[LedgerItem]) extends Tran\n       request: GetTransactionsRequest,\n       responseObserver: StreamObserver[GetTransactionTreesResponse]): Unit = {\n     lastTransactionsTreesRequest.set(request)\n-//  TODO DEL-6007\n-//    ledgerContent\n-//      .map(t => GetTransactionTreesResponse(List(t.toTransactionTree)))\n-//      .foreach(responseObserver.onNext)\n-\n     responseObserver.onCompleted()\n   }\n \n   override def getTransactionByEventId(\n-      request: GetTransactionByEventIdRequest): Future[GetTransactionResponse] =\n-    Future.failed[GetTransactionResponse] {\n-      lastTransactionByEventIdRequest.set(request)\n-      //  TODO DEL-6007\n-      new StatusRuntimeException(Status.UNIMPLEMENTED.withDescription(\"Pending\"))\n-    }\n+      request: GetTransactionByEventIdRequest): Future[GetTransactionResponse] = {\n+    lastTransactionByEventIdRequest.set(request)\n+    Future.successful(new GetTransactionResponse(None)) // just a mock, not intended for consumption"
  },
  {
    "id" : "510ffade-dd6c-4c82-b932-a28c2d4cd1fd",
    "prId" : 3733,
    "comments" : [
      {
        "id" : "9eb2ba03-de70-46a7-9aa0-50c8d8715b09",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "We may want to add tests for this as the below logic does not seem to be trivial (I understand you just reformatted this method).",
        "createdAt" : "2019-12-05T09:18:50Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "662cfaa5-c3a9-44a0-89bd-deecd01a8588",
        "parentId" : "9eb2ba03-de70-46a7-9aa0-50c8d8715b09",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Sure, can you open a ticket for this? This is beyond the scope of the work done in this PR.",
        "createdAt" : "2019-12-05T09:42:10Z",
        "updatedAt" : "2019-12-05T09:48:38Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "94dd9316-9f34-4e29-8b60-6f334510d93e",
        "parentId" : "9eb2ba03-de70-46a7-9aa0-50c8d8715b09",
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "Created #3742 for reusing code for ledger offset ordering as we already have such logic littered around.",
        "createdAt" : "2019-12-05T10:12:34Z",
        "updatedAt" : "2019-12-05T10:12:53Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a577264afd2be0e02604a911a7fa44c2fea02a9a",
    "line" : 186,
    "diffHunk" : "@@ -156,49 +140,38 @@ object TransactionServiceImpl {\n     case Empty => \"\"\n   }\n \n-  def createWithRef(ledgerContent: Observable[LedgerItem])(\n-      implicit ec: ExecutionContext): (ServerServiceDefinition, TransactionServiceImpl) = {\n-    val serviceImpl = new TransactionServiceImpl(ledgerContent)\n-    (TransactionServiceGrpc.bindService(serviceImpl, ec), serviceImpl)\n+  def createWithRef(ledgerContent: Observable[LedgerItem], authorizer: Authorizer)(\n+      implicit ec: ExecutionContext): (ServerServiceDefinition, TransactionsServiceImpl) = {\n+    val impl = new TransactionsServiceImpl(ledgerContent)\n+    val authImpl = new TransactionServiceAuthorization(impl, authorizer)\n+    (TransactionServiceGrpc.bindService(authImpl, ec), impl)\n   }\n \n-  val ledgerOffsetOrdering: Ordering[LedgerOffset] = new Ordering[LedgerOffset] {\n-    override def compare(x: LedgerOffset, y: LedgerOffset): Int = {\n-      if (x.equals(y)) 0\n-      else {\n-        x.getAbsolute match {\n-          case \"\" =>\n-            x.getBoundary match {\n-              case LEDGER_BEGIN => -1\n-              case LEDGER_END => 1\n-              case Unrecognized(value) =>\n-                throw new RuntimeException(\n-                  s\"Found boundary that is neither BEGIN or END (value: $value)\")\n-            }\n-          case xAbs =>\n-            y.getAbsolute match {\n-              case \"\" =>\n-                y.getBoundary match {\n-                  case LEDGER_BEGIN => 1\n-                  case LEDGER_END => -1\n-                  case Unrecognized(value) =>\n-                    throw new RuntimeException(\n-                      s\"Found boundary that is neither BEGIN or END (value: $value)\")\n-                }\n-              case yAbs => xAbs.compareTo(yAbs)\n-            }\n-        }\n+  val ledgerOffsetOrdering: Ordering[LedgerOffset] = (x: LedgerOffset, y: LedgerOffset) => {"
  }
]