[
  {
    "id" : "b31fd639-ffe3-4dd3-a090-ab97d1f7ae0f",
    "prId" : 3736,
    "comments" : [
      {
        "id" : "5296bf29-9455-4f53-87e0-0bb444e04cdb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Please avoid type synonyms for this kind of stuff. Either make it a newtype to make sure that you actually get some safety or use `String`. Making it a type synonym just makes the API harder to use since I still have to look at the definition to figure out what I can pass while not providing any additional safety or readability, e.g., when I see `setToken \"foobar\" ledgerService` I can at best guess what the string is where is if I see `setToken (Token \"foobar\") ledgerService` that’s much clearer.",
        "createdAt" : "2019-12-04T18:30:27Z",
        "updatedAt" : "2019-12-05T08:44:42Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d36c29e380cb356866501127c22a4dccd552d51a",
    "line" : null,
    "diffHunk" : "@@ -4,52 +4,52 @@\n -- Abstraction for LedgerService, which can be composed monadically.\n module DA.Ledger.LedgerService (\n     LedgerService, runLedgerService, makeLedgerService, TimeoutSeconds,\n-    Jwt, setToken,\n+    setToken,\n     askTimeout,\n     ) where\n \n import Control.Monad.Fail (MonadFail)\n import Control.Monad.IO.Class (MonadIO)\n import Control.Monad.Reader (MonadReader,local,asks)\n import Control.Monad.Trans.Reader (ReaderT(..))\n-import DA.Ledger.Jwt (Jwt)\n import DA.Ledger.Retry (ledgerRetry)\n import Network.GRPC.HighLevel.Client(TimeoutSeconds)\n import Network.GRPC.HighLevel.Generated(ClientConfig,MetadataMap(..))\n import UnliftIO(MonadUnliftIO)\n-import qualified DA.Ledger.Jwt as Jwt (toBearerString)\n import qualified Data.ByteString.UTF8 as BSU8\n import qualified Data.Map as Map\n import qualified Data.SortedList as SortedList\n \n data Context = Context\n   { ts :: TimeoutSeconds\n   , cc :: ClientConfig\n-  , jwtMaybe :: Maybe Jwt\n+  , tokMaybe :: Maybe Tok\n   }\n \n+type Tok = String"
  },
  {
    "id" : "395009b4-f7fe-4403-8851-282cc4052f6f",
    "prId" : 3561,
    "comments" : [
      {
        "id" : "8e40f505-df75-48b6-bd01-3cb11fa627af",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think it would be nicer for this to be a record instead of a type synonym for a tuple.",
        "createdAt" : "2019-11-21T08:21:11Z",
        "updatedAt" : "2019-11-21T14:35:55Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5921cf2292c982f7e588e3d1c6fc9f284d4537ea",
    "line" : null,
    "diffHunk" : "@@ -4,27 +4,46 @@\n -- Abstraction for LedgerService, which can be composed monadically.\n module DA.Ledger.LedgerService (\n     LedgerService, runLedgerService, makeLedgerService, TimeoutSeconds,\n+    Jwt, setToken,\n     askTimeout,\n     ) where\n \n import Control.Monad.Fail (MonadFail)\n import Control.Monad.IO.Class (MonadIO)\n-import Control.Monad.Trans.Reader (ReaderT(..),runReaderT,ask)\n+import Control.Monad.Trans.Reader (ReaderT(..),runReaderT,ask,local)\n+import DA.Ledger.Jwt (Jwt)\n import DA.Ledger.Retry (ledgerRetry)\n import Network.GRPC.HighLevel.Client(TimeoutSeconds)\n-import Network.GRPC.HighLevel.Generated(ClientConfig)\n+import Network.GRPC.HighLevel.Generated(ClientConfig,MetadataMap(..))\n import UnliftIO(MonadUnliftIO)\n+import qualified DA.Ledger.Jwt as Jwt (toString)\n+import qualified Data.ByteString.UTF8 as BSU8\n+import qualified Data.Map as Map\n+import qualified Data.SortedList as SortedList\n \n-type Context = (TimeoutSeconds,ClientConfig)\n+type Context = (TimeoutSeconds,ClientConfig,Maybe Jwt)"
  },
  {
    "id" : "55c950b1-5637-4571-919d-139415077192",
    "prId" : 3561,
    "comments" : [
      {
        "id" : "266913de-0108-4a00-920f-37a1f2cc1894",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You can simplifyf this to `makeMdm mbJwt = MetadataMap $ Map.fromList [ (\"authorization\", …) | Just jwt <- mbJwt]`",
        "createdAt" : "2019-11-21T08:24:23Z",
        "updatedAt" : "2019-11-21T14:35:55Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5921cf2292c982f7e588e3d1c6fc9f284d4537ea",
    "line" : 52,
    "diffHunk" : "@@ -4,27 +4,46 @@\n -- Abstraction for LedgerService, which can be composed monadically.\n module DA.Ledger.LedgerService (\n     LedgerService, runLedgerService, makeLedgerService, TimeoutSeconds,\n+    Jwt, setToken,\n     askTimeout,\n     ) where\n \n import Control.Monad.Fail (MonadFail)\n import Control.Monad.IO.Class (MonadIO)\n-import Control.Monad.Trans.Reader (ReaderT(..),runReaderT,ask)\n+import Control.Monad.Trans.Reader (ReaderT(..),runReaderT,ask,local)\n+import DA.Ledger.Jwt (Jwt)\n import DA.Ledger.Retry (ledgerRetry)\n import Network.GRPC.HighLevel.Client(TimeoutSeconds)\n-import Network.GRPC.HighLevel.Generated(ClientConfig)\n+import Network.GRPC.HighLevel.Generated(ClientConfig,MetadataMap(..))\n import UnliftIO(MonadUnliftIO)\n+import qualified DA.Ledger.Jwt as Jwt (toString)\n+import qualified Data.ByteString.UTF8 as BSU8\n+import qualified Data.Map as Map\n+import qualified Data.SortedList as SortedList\n \n-type Context = (TimeoutSeconds,ClientConfig)\n+type Context = (TimeoutSeconds,ClientConfig,Maybe Jwt)\n \n newtype LedgerService a = LedgerService (ReaderT Context IO a)\n     deriving (Functor,Applicative,Monad,MonadFail,MonadIO,MonadUnliftIO)\n \n runLedgerService :: LedgerService a -> TimeoutSeconds -> ClientConfig -> IO a\n-runLedgerService (LedgerService r) ts cc = runReaderT r (ts,cc)\n+runLedgerService (LedgerService r) ts cc = runReaderT r (ts,cc,Nothing)\n \n-makeLedgerService :: (TimeoutSeconds -> ClientConfig -> IO a) -> LedgerService a\n-makeLedgerService f = LedgerService $ ReaderT $ \\(ts,cc) -> ledgerRetry $ f ts cc\n+setToken :: Jwt -> LedgerService a -> LedgerService a\n+setToken jwt (LedgerService r) = LedgerService (local (\\(ts,cc,_) -> (ts,cc,Just jwt)) r)\n+\n+makeLedgerService :: (TimeoutSeconds -> ClientConfig -> MetadataMap -> IO a) -> LedgerService a\n+makeLedgerService f =\n+  LedgerService $ ReaderT $ \\(ts,cc,jwtMaybe) -> ledgerRetry $ f ts cc (makeMdm jwtMaybe)\n+\n+makeMdm :: Maybe Jwt -> MetadataMap\n+makeMdm = \\case"
  },
  {
    "id" : "410e7371-6372-446c-b9b9-22e9a556776c",
    "prId" : 3561,
    "comments" : [
      {
        "id" : "c875858a-94e6-4c29-8362-0613a3e11f1d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "If you make `Context` a record and `LedgerService` an instance of `MonadReader Context`, this is just `asks ctxTimeout`.",
        "createdAt" : "2019-11-21T08:26:11Z",
        "updatedAt" : "2019-11-21T14:35:55Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5921cf2292c982f7e588e3d1c6fc9f284d4537ea",
    "line" : 58,
    "diffHunk" : "@@ -4,27 +4,46 @@\n -- Abstraction for LedgerService, which can be composed monadically.\n module DA.Ledger.LedgerService (\n     LedgerService, runLedgerService, makeLedgerService, TimeoutSeconds,\n+    Jwt, setToken,\n     askTimeout,\n     ) where\n \n import Control.Monad.Fail (MonadFail)\n import Control.Monad.IO.Class (MonadIO)\n-import Control.Monad.Trans.Reader (ReaderT(..),runReaderT,ask)\n+import Control.Monad.Trans.Reader (ReaderT(..),runReaderT,ask,local)\n+import DA.Ledger.Jwt (Jwt)\n import DA.Ledger.Retry (ledgerRetry)\n import Network.GRPC.HighLevel.Client(TimeoutSeconds)\n-import Network.GRPC.HighLevel.Generated(ClientConfig)\n+import Network.GRPC.HighLevel.Generated(ClientConfig,MetadataMap(..))\n import UnliftIO(MonadUnliftIO)\n+import qualified DA.Ledger.Jwt as Jwt (toString)\n+import qualified Data.ByteString.UTF8 as BSU8\n+import qualified Data.Map as Map\n+import qualified Data.SortedList as SortedList\n \n-type Context = (TimeoutSeconds,ClientConfig)\n+type Context = (TimeoutSeconds,ClientConfig,Maybe Jwt)\n \n newtype LedgerService a = LedgerService (ReaderT Context IO a)\n     deriving (Functor,Applicative,Monad,MonadFail,MonadIO,MonadUnliftIO)\n \n runLedgerService :: LedgerService a -> TimeoutSeconds -> ClientConfig -> IO a\n-runLedgerService (LedgerService r) ts cc = runReaderT r (ts,cc)\n+runLedgerService (LedgerService r) ts cc = runReaderT r (ts,cc,Nothing)\n \n-makeLedgerService :: (TimeoutSeconds -> ClientConfig -> IO a) -> LedgerService a\n-makeLedgerService f = LedgerService $ ReaderT $ \\(ts,cc) -> ledgerRetry $ f ts cc\n+setToken :: Jwt -> LedgerService a -> LedgerService a\n+setToken jwt (LedgerService r) = LedgerService (local (\\(ts,cc,_) -> (ts,cc,Just jwt)) r)\n+\n+makeLedgerService :: (TimeoutSeconds -> ClientConfig -> MetadataMap -> IO a) -> LedgerService a\n+makeLedgerService f =\n+  LedgerService $ ReaderT $ \\(ts,cc,jwtMaybe) -> ledgerRetry $ f ts cc (makeMdm jwtMaybe)\n+\n+makeMdm :: Maybe Jwt -> MetadataMap\n+makeMdm = \\case\n+  Nothing -> MetadataMap Map.empty\n+  Just jwt ->\n+    MetadataMap $ Map.fromList\n+    [ (\"authorization\"\n+      , SortedList.toSortedList [ BSU8.fromString $ \"Bearer \" <> Jwt.toString jwt ]\n+      )]\n \n askTimeout :: LedgerService TimeoutSeconds"
  },
  {
    "id" : "0acdd946-a99c-4828-a881-2410586fbacb",
    "prId" : 2096,
    "comments" : [
      {
        "id" : "5c9af70b-72f8-47d4-b973-b7ebfd0301f9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think a better solution here would be to remove this function, make `LedgerService` an instance of `MonadUnliftIO` and then use the generalized exception handling functions in `unliftio`, e.g. [bracket](https://hackage.haskell.org/package/unliftio-0.2.11/docs/UnliftIO-Exception.html#v:bracket).",
        "createdAt" : "2019-07-11T07:29:01Z",
        "updatedAt" : "2019-07-11T12:36:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "98e953c4-4f39-4504-bf53-02b5295777a8",
        "parentId" : "5c9af70b-72f8-47d4-b973-b7ebfd0301f9",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I realised I want `bracket` but not in the `IO` monad. \r\nI discovered `MonadUnliftIO` last night, and it was on my my list to learn about today...",
        "createdAt" : "2019-07-11T08:04:15Z",
        "updatedAt" : "2019-07-11T12:36:08Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e4cee704-13d0-442d-8413-f9ffe6fe680d",
        "parentId" : "5c9af70b-72f8-47d4-b973-b7ebfd0301f9",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "`LedgerService` now an instance of MonadUnliftIO.\r\n`mapIOLedgerService` is gone",
        "createdAt" : "2019-07-11T12:31:16Z",
        "updatedAt" : "2019-07-11T12:36:08Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "638953034e6f609d8a4b38b0e801ac0015e339b4",
    "line" : null,
    "diffHunk" : "@@ -23,3 +25,13 @@ runLedgerService (LedgerService r) ts cc = runReaderT r (ts,cc)\n \n makeLedgerService :: (TimeoutSeconds -> ClientConfig -> IO a) -> LedgerService a\n makeLedgerService f = LedgerService $ ReaderT $ \\(ts,cc) -> ledgerRetry $ f ts cc\n+\n+withTimeout :: LedgerService a -> LedgerService a\n+withTimeout service = do\n+    (ts,cc) <- LedgerService ask\n+    Just x <- liftIO $ timeout (fromIntegral ts) (runLedgerService service ts cc)\n+    return x\n+\n+mapIOLedgerService :: (IO a -> IO b) -> LedgerService a -> LedgerService b"
  },
  {
    "id" : "84a42d15-228a-415c-a0e1-8707d9585734",
    "prId" : 1865,
    "comments" : [
      {
        "id" : "83aa978c-dc45-406a-8f5b-03e0116be225",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd have done `LedgerService (ReaderT (TimeoutSeconds, ClientConfig) IO a)` and let newtype deriving give me all the instances",
        "createdAt" : "2019-06-25T19:53:52Z",
        "updatedAt" : "2019-06-25T19:58:01Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "950a61c6-19ab-4206-a59c-3f08128de710",
        "parentId" : "83aa978c-dc45-406a-8f5b-03e0116be225",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Yes. Much better. Thanks",
        "createdAt" : "2019-06-26T09:23:20Z",
        "updatedAt" : "2019-06-26T09:23:20Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "083986803f9b3170c769c8f1a0c16e4556e24542",
    "line" : 19,
    "diffHunk" : "@@ -0,0 +1,44 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+-- Abstraction for LedgerService, which can be composed monadically.\n+module DA.Ledger.LedgerService (\n+    LedgerService, runLedgerService, makeLedgerService, TimeoutSeconds(..),\n+    ) where\n+\n+import Prelude hiding (fail)\n+import Control.Monad (ap,liftM)\n+import Control.Monad.Fail (MonadFail,fail)\n+import Control.Monad.IO.Class (MonadIO,liftIO)\n+import DA.Ledger.Retry (ledgerRetry)\n+import Network.GRPC.HighLevel.Generated\n+\n+newtype TimeoutSeconds = TimeoutSeconds { unTimeoutSeconds :: Int } deriving Num\n+\n+newtype LedgerService a =\n+    LedgerService { runLedgerService :: TimeoutSeconds -> ClientConfig -> IO a }"
  },
  {
    "id" : "e68730dd-c119-421f-a205-1e41f4d7b77d",
    "prId" : 1865,
    "comments" : [
      {
        "id" : "2003c248-b153-43b4-ba91-0fac3aceb693",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "System.Time.Extra.Seconds?",
        "createdAt" : "2019-06-25T19:54:01Z",
        "updatedAt" : "2019-06-25T19:58:01Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "15b0eae6-df4d-4c88-9f5b-8c8133cb01c4",
        "parentId" : "2003c248-b153-43b4-ba91-0fac3aceb693",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "That's a double, and the GRPC library requires an Int.\r\nBut I changed the code to avoid the newtype wrapper which I dont think was adding anything.",
        "createdAt" : "2019-06-26T09:24:59Z",
        "updatedAt" : "2019-06-26T09:24:59Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "083986803f9b3170c769c8f1a0c16e4556e24542",
    "line" : 16,
    "diffHunk" : "@@ -0,0 +1,44 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+-- Abstraction for LedgerService, which can be composed monadically.\n+module DA.Ledger.LedgerService (\n+    LedgerService, runLedgerService, makeLedgerService, TimeoutSeconds(..),\n+    ) where\n+\n+import Prelude hiding (fail)\n+import Control.Monad (ap,liftM)\n+import Control.Monad.Fail (MonadFail,fail)\n+import Control.Monad.IO.Class (MonadIO,liftIO)\n+import DA.Ledger.Retry (ledgerRetry)\n+import Network.GRPC.HighLevel.Generated\n+\n+newtype TimeoutSeconds = TimeoutSeconds { unTimeoutSeconds :: Int } deriving Num"
  }
]