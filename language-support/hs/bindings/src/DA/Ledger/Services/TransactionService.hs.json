[
  {
    "id" : "63718cb3-d573-4fac-9dbe-985d4ed05c72",
    "prId" : 2029,
    "comments" : [
      {
        "id" : "e06d5d96-f5a2-45a8-b188-874fd49e8ca7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This kind of pattern can be a bit dangerous since if the thread dies (e.g. throws an exception) you will never notice. Also if the main thread of a Haskell application shuts down, all other threads die immediately without even running finalizers which can be quite confusing. Usually something like `withAsync` or one of the other functions in `async` is a better way to handle this. That said, no need to address this before merging especially since this pattern is already used in other parts, just something to keep in mind for a future PR.",
        "createdAt" : "2019-07-05T16:09:42Z",
        "updatedAt" : "2019-07-05T16:14:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "14c18185-a64b-4f32-8756-e794799a3c91",
        "parentId" : "e06d5d96-f5a2-45a8-b188-874fd49e8ca7",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "Yes I agree. We should switch to `async` as you suggest.",
        "createdAt" : "2019-07-08T10:11:20Z",
        "updatedAt" : "2019-07-08T10:11:20Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec9c9d014032efd981e4522a47dfb769819d7c4a",
    "line" : 32,
    "diffHunk" : "@@ -17,7 +25,105 @@ import Network.GRPC.HighLevel.Generated\n import qualified Com.Digitalasset.Ledger.Api.V1.TransactionService as LL\n import qualified Data.Map as Map\n \n--- TODO:: all the other RPCs\n+getTransactions :: GetTransactionsRequest -> LedgerService (Stream Transaction)\n+getTransactions req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $"
  },
  {
    "id" : "166671f4-8f08-4f84-b39b-7dbef52daaf7",
    "prId" : 2029,
    "comments" : [
      {
        "id" : "3db193ed-f687-469d-81b0-204c619bcb7d",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe also add in the error message that it originated from `raiseTransactionTree`.",
        "createdAt" : "2019-07-05T16:11:26Z",
        "updatedAt" : "2019-07-05T16:14:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e4b47ab7-a476-4df8-8e31-cefb728bacbb",
        "parentId" : "3db193ed-f687-469d-81b0-204c619bcb7d",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "What I really want to do is push the handling of Nothing/Just for all RPC response types down into the `raise` functionality of  the `Convert` module. This response field optionality is an artifact of GRPC/proto which it is sad to have repeated in every rpc-wrapper.",
        "createdAt" : "2019-07-08T10:16:48Z",
        "updatedAt" : "2019-07-08T10:16:48Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec9c9d014032efd981e4522a47dfb769819d7c4a",
    "line" : 64,
    "diffHunk" : "@@ -17,7 +25,105 @@ import Network.GRPC.HighLevel.Generated\n import qualified Com.Digitalasset.Ledger.Api.V1.TransactionService as LL\n import qualified Data.Map as Map\n \n--- TODO:: all the other RPCs\n+getTransactions :: GetTransactionsRequest -> LedgerService (Stream Transaction)\n+getTransactions req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactions=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransaction . LL.getTransactionsResponseTransactions\n+\n+getTransactionTrees :: GetTransactionsRequest -> LedgerService (Stream TransactionTree)\n+getTransactionTrees req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactionTrees=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransactionTree . LL.getTransactionTreesResponseTransactions\n+\n+getTransactionByEventId :: LedgerId -> EventId -> [Party] -> LedgerService (Maybe TransactionTree)\n+getTransactionByEventId lid eid parties =\n+    makeLedgerService $ \\timeout config -> do\n+    withGRPCClient config $ \\client -> do\n+        service <- LL.transactionServiceClient client\n+        let LL.TransactionService{transactionServiceGetTransactionByEventId=rpc} = service\n+        rpc (ClientNormalRequest (mkByEventIdRequest lid eid parties) timeout emptyMdm)\n+        >>= \\case\n+            ClientNormalResponse (LL.GetTransactionResponse Nothing) _m1 _m2 _status _details ->\n+                fail \"GetTransactionResponse, transaction field is missing\"\n+            ClientNormalResponse (LL.GetTransactionResponse (Just tx)) _m1 _m2 _status _details ->\n+                case raiseTransactionTree tx of\n+                    Left reason -> fail (show reason)"
  },
  {
    "id" : "f675267a-96b8-4f87-b79f-9850ca5e46f4",
    "prId" : 2029,
    "comments" : [
      {
        "id" : "3da477dd-a70f-4f2f-8aee-5c76c6b4dba6",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe add a comment on when you will get `Nothing` (only if you get a not found message) vs when you get an exception (all other failure cases).",
        "createdAt" : "2019-07-05T16:12:36Z",
        "updatedAt" : "2019-07-05T16:14:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "084974d5-f7f8-47f2-939b-43b08945f5fb",
        "parentId" : "3da477dd-a70f-4f2f-8aee-5c76c6b4dba6",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "I think more generally we need to work out how best to link from the haskell bindings to the documentation which originates in the .proto files\r\n```\r\n// Lookup a transaction by the ID of an event that appears within it.\r\n  // Returns ``NOT_FOUND`` if no such transaction exists.\r\n  rpc GetFlatTransactionByEventId (GetTransactionByEventIdRequest) returns (GetFlatTransactionResponse);\r\n```\r\n\r\nand to document our general scheme of mapping `NOT_FOUND` (at the grpc level) to the `Maybe` type for the haskell binding.\r\n\r\n",
        "createdAt" : "2019-07-08T10:21:35Z",
        "updatedAt" : "2019-07-08T10:21:35Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec9c9d014032efd981e4522a47dfb769819d7c4a",
    "line" : 52,
    "diffHunk" : "@@ -17,7 +25,105 @@ import Network.GRPC.HighLevel.Generated\n import qualified Com.Digitalasset.Ledger.Api.V1.TransactionService as LL\n import qualified Data.Map as Map\n \n--- TODO:: all the other RPCs\n+getTransactions :: GetTransactionsRequest -> LedgerService (Stream Transaction)\n+getTransactions req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactions=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransaction . LL.getTransactionsResponseTransactions\n+\n+getTransactionTrees :: GetTransactionsRequest -> LedgerService (Stream TransactionTree)\n+getTransactionTrees req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactionTrees=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransactionTree . LL.getTransactionTreesResponseTransactions\n+\n+getTransactionByEventId :: LedgerId -> EventId -> [Party] -> LedgerService (Maybe TransactionTree)"
  },
  {
    "id" : "b34d212a-0e4a-429e-b256-c5030e256166",
    "prId" : 2029,
    "comments" : [
      {
        "id" : "47e23c07-a185-4dc5-9184-bebc63422806",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here.",
        "createdAt" : "2019-07-05T16:12:48Z",
        "updatedAt" : "2019-07-05T16:14:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec9c9d014032efd981e4522a47dfb769819d7c4a",
    "line" : 71,
    "diffHunk" : "@@ -17,7 +25,105 @@ import Network.GRPC.HighLevel.Generated\n import qualified Com.Digitalasset.Ledger.Api.V1.TransactionService as LL\n import qualified Data.Map as Map\n \n--- TODO:: all the other RPCs\n+getTransactions :: GetTransactionsRequest -> LedgerService (Stream Transaction)\n+getTransactions req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactions=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransaction . LL.getTransactionsResponseTransactions\n+\n+getTransactionTrees :: GetTransactionsRequest -> LedgerService (Stream TransactionTree)\n+getTransactionTrees req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactionTrees=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransactionTree . LL.getTransactionTreesResponseTransactions\n+\n+getTransactionByEventId :: LedgerId -> EventId -> [Party] -> LedgerService (Maybe TransactionTree)\n+getTransactionByEventId lid eid parties =\n+    makeLedgerService $ \\timeout config -> do\n+    withGRPCClient config $ \\client -> do\n+        service <- LL.transactionServiceClient client\n+        let LL.TransactionService{transactionServiceGetTransactionByEventId=rpc} = service\n+        rpc (ClientNormalRequest (mkByEventIdRequest lid eid parties) timeout emptyMdm)\n+        >>= \\case\n+            ClientNormalResponse (LL.GetTransactionResponse Nothing) _m1 _m2 _status _details ->\n+                fail \"GetTransactionResponse, transaction field is missing\"\n+            ClientNormalResponse (LL.GetTransactionResponse (Just tx)) _m1 _m2 _status _details ->\n+                case raiseTransactionTree tx of\n+                    Left reason -> fail (show reason)\n+                    Right x -> return $ Just x\n+            ClientErrorResponse (ClientIOError (GRPCIOBadStatusCode StatusNotFound _details)) ->\n+                return Nothing\n+            ClientErrorResponse e ->\n+                fail (show e)\n+\n+getTransactionById :: LedgerId -> TransactionId -> [Party] -> LedgerService (Maybe TransactionTree)"
  },
  {
    "id" : "da0260ab-16bb-462b-becf-3124f030492c",
    "prId" : 2029,
    "comments" : [
      {
        "id" : "c183b348-0bec-4717-bdc5-88dc6ff9df2a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here.",
        "createdAt" : "2019-07-05T16:12:55Z",
        "updatedAt" : "2019-07-05T16:14:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec9c9d014032efd981e4522a47dfb769819d7c4a",
    "line" : 90,
    "diffHunk" : "@@ -17,7 +25,105 @@ import Network.GRPC.HighLevel.Generated\n import qualified Com.Digitalasset.Ledger.Api.V1.TransactionService as LL\n import qualified Data.Map as Map\n \n--- TODO:: all the other RPCs\n+getTransactions :: GetTransactionsRequest -> LedgerService (Stream Transaction)\n+getTransactions req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactions=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransaction . LL.getTransactionsResponseTransactions\n+\n+getTransactionTrees :: GetTransactionsRequest -> LedgerService (Stream TransactionTree)\n+getTransactionTrees req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactionTrees=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransactionTree . LL.getTransactionTreesResponseTransactions\n+\n+getTransactionByEventId :: LedgerId -> EventId -> [Party] -> LedgerService (Maybe TransactionTree)\n+getTransactionByEventId lid eid parties =\n+    makeLedgerService $ \\timeout config -> do\n+    withGRPCClient config $ \\client -> do\n+        service <- LL.transactionServiceClient client\n+        let LL.TransactionService{transactionServiceGetTransactionByEventId=rpc} = service\n+        rpc (ClientNormalRequest (mkByEventIdRequest lid eid parties) timeout emptyMdm)\n+        >>= \\case\n+            ClientNormalResponse (LL.GetTransactionResponse Nothing) _m1 _m2 _status _details ->\n+                fail \"GetTransactionResponse, transaction field is missing\"\n+            ClientNormalResponse (LL.GetTransactionResponse (Just tx)) _m1 _m2 _status _details ->\n+                case raiseTransactionTree tx of\n+                    Left reason -> fail (show reason)\n+                    Right x -> return $ Just x\n+            ClientErrorResponse (ClientIOError (GRPCIOBadStatusCode StatusNotFound _details)) ->\n+                return Nothing\n+            ClientErrorResponse e ->\n+                fail (show e)\n+\n+getTransactionById :: LedgerId -> TransactionId -> [Party] -> LedgerService (Maybe TransactionTree)\n+getTransactionById lid trid parties =\n+    makeLedgerService $ \\timeout config -> do\n+    withGRPCClient config $ \\client -> do\n+        service <- LL.transactionServiceClient client\n+        let LL.TransactionService{transactionServiceGetTransactionById=rpc} = service\n+        rpc (ClientNormalRequest (mkByIdRequest lid trid parties) timeout emptyMdm)\n+        >>= \\case\n+            ClientNormalResponse (LL.GetTransactionResponse Nothing) _m1 _m2 _status _details ->\n+                fail \"GetTransactionResponse, transaction field is missing\"\n+            ClientNormalResponse (LL.GetTransactionResponse (Just tx)) _m1 _m2 _status _details ->\n+                case raiseTransactionTree tx of\n+                    Left reason -> fail (show reason)\n+                    Right x -> return $ Just x\n+            ClientErrorResponse (ClientIOError (GRPCIOBadStatusCode StatusNotFound _details)) ->\n+                return Nothing\n+            ClientErrorResponse e ->\n+                fail (show e)\n+\n+getFlatTransactionByEventId :: LedgerId -> EventId -> [Party] -> LedgerService (Maybe Transaction)"
  },
  {
    "id" : "4b3bcbb8-9023-4fd6-96c5-4924b66d924a",
    "prId" : 2029,
    "comments" : [
      {
        "id" : "3159da73-d050-4e17-b1c4-2884ce5af640",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Same here.",
        "createdAt" : "2019-07-05T16:13:04Z",
        "updatedAt" : "2019-07-05T16:14:46Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "ec9c9d014032efd981e4522a47dfb769819d7c4a",
    "line" : 109,
    "diffHunk" : "@@ -17,7 +25,105 @@ import Network.GRPC.HighLevel.Generated\n import qualified Com.Digitalasset.Ledger.Api.V1.TransactionService as LL\n import qualified Data.Map as Map\n \n--- TODO:: all the other RPCs\n+getTransactions :: GetTransactionsRequest -> LedgerService (Stream Transaction)\n+getTransactions req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactions=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransaction . LL.getTransactionsResponseTransactions\n+\n+getTransactionTrees :: GetTransactionsRequest -> LedgerService (Stream TransactionTree)\n+getTransactionTrees req =\n+    makeLedgerService $ \\timeout config -> do\n+    stream <- newStream\n+    _ <- forkIO $\n+        withGRPCClient config $ \\client -> do\n+            service <- LL.transactionServiceClient client\n+            let LL.TransactionService {transactionServiceGetTransactionTrees=rpc} = service\n+            sendToStreamFlat timeout (lowerRequest req) f stream rpc\n+    return stream\n+    where f = raiseList raiseTransactionTree . LL.getTransactionTreesResponseTransactions\n+\n+getTransactionByEventId :: LedgerId -> EventId -> [Party] -> LedgerService (Maybe TransactionTree)\n+getTransactionByEventId lid eid parties =\n+    makeLedgerService $ \\timeout config -> do\n+    withGRPCClient config $ \\client -> do\n+        service <- LL.transactionServiceClient client\n+        let LL.TransactionService{transactionServiceGetTransactionByEventId=rpc} = service\n+        rpc (ClientNormalRequest (mkByEventIdRequest lid eid parties) timeout emptyMdm)\n+        >>= \\case\n+            ClientNormalResponse (LL.GetTransactionResponse Nothing) _m1 _m2 _status _details ->\n+                fail \"GetTransactionResponse, transaction field is missing\"\n+            ClientNormalResponse (LL.GetTransactionResponse (Just tx)) _m1 _m2 _status _details ->\n+                case raiseTransactionTree tx of\n+                    Left reason -> fail (show reason)\n+                    Right x -> return $ Just x\n+            ClientErrorResponse (ClientIOError (GRPCIOBadStatusCode StatusNotFound _details)) ->\n+                return Nothing\n+            ClientErrorResponse e ->\n+                fail (show e)\n+\n+getTransactionById :: LedgerId -> TransactionId -> [Party] -> LedgerService (Maybe TransactionTree)\n+getTransactionById lid trid parties =\n+    makeLedgerService $ \\timeout config -> do\n+    withGRPCClient config $ \\client -> do\n+        service <- LL.transactionServiceClient client\n+        let LL.TransactionService{transactionServiceGetTransactionById=rpc} = service\n+        rpc (ClientNormalRequest (mkByIdRequest lid trid parties) timeout emptyMdm)\n+        >>= \\case\n+            ClientNormalResponse (LL.GetTransactionResponse Nothing) _m1 _m2 _status _details ->\n+                fail \"GetTransactionResponse, transaction field is missing\"\n+            ClientNormalResponse (LL.GetTransactionResponse (Just tx)) _m1 _m2 _status _details ->\n+                case raiseTransactionTree tx of\n+                    Left reason -> fail (show reason)\n+                    Right x -> return $ Just x\n+            ClientErrorResponse (ClientIOError (GRPCIOBadStatusCode StatusNotFound _details)) ->\n+                return Nothing\n+            ClientErrorResponse e ->\n+                fail (show e)\n+\n+getFlatTransactionByEventId :: LedgerId -> EventId -> [Party] -> LedgerService (Maybe Transaction)\n+getFlatTransactionByEventId lid eid parties =\n+    makeLedgerService $ \\timeout config -> do\n+    withGRPCClient config $ \\client -> do\n+        service <- LL.transactionServiceClient client\n+        let LL.TransactionService{transactionServiceGetFlatTransactionByEventId=rpc} = service\n+        rpc (ClientNormalRequest (mkByEventIdRequest lid eid parties) timeout emptyMdm)\n+        >>= \\case\n+            ClientNormalResponse (LL.GetFlatTransactionResponse Nothing) _m1 _m2 _status _details ->\n+                fail \"GetFlatTransactionResponse, transaction field is missing\"\n+            ClientNormalResponse (LL.GetFlatTransactionResponse (Just tx)) _m1 _m2 _status _details ->\n+                case raiseTransaction tx of\n+                    Left reason -> fail (show reason)\n+                    Right x -> return $ Just x\n+            ClientErrorResponse (ClientIOError (GRPCIOBadStatusCode StatusNotFound _details)) ->\n+                return Nothing\n+            ClientErrorResponse e ->\n+                fail (show e)\n+\n+getFlatTransactionById :: LedgerId -> TransactionId -> [Party] -> LedgerService (Maybe Transaction)"
  },
  {
    "id" : "359cafc8-4a2d-49d1-8384-64ce8be4b72e",
    "prId" : 1865,
    "comments" : [
      {
        "id" : "4e3564a1-c04c-48fc-99db-04b45755cf74",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Do we really want Java style naming? Or is this inevitable with autogen stuff?",
        "createdAt" : "2019-06-25T19:55:39Z",
        "updatedAt" : "2019-06-25T19:58:01Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "52a0cf6d-5bed-49b4-8fe9-05b4a1f946be",
        "parentId" : "4e3564a1-c04c-48fc-99db-04b45755cf74",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "These are the names of the services as defined in the .proto files.\r\nFor code discoverability, it's useful to keep the direct name correspondence.",
        "createdAt" : "2019-06-26T09:28:08Z",
        "updatedAt" : "2019-06-26T09:28:09Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "083986803f9b3170c769c8f1a0c16e4556e24542",
    "line" : 9,
    "diffHunk" : "@@ -0,0 +1,72 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+module DA.Ledger.Services.TransactionService (\n+    ledgerEnd,\n+    GetTransactionsRequest(..), getTransactions,\n+    ) where\n+\n+import Com.Digitalasset.Ledger.Api.V1.LedgerOffset"
  }
]