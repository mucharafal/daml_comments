[
  {
    "id" : "4eb6153d-c062-4565-b116-0393e05a24d7",
    "prId" : 1181,
    "comments" : [
      {
        "id" : "ccf7a609-d884-423e-9204-290e0e6c6f70",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Is this function useful? Why not deriving Eq and then do `== Open` when you need this.",
        "createdAt" : "2019-05-16T13:08:42Z",
        "updatedAt" : "2019-05-16T14:23:34Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0b77d552-c203-43db-94c8-cd50960243a1",
        "parentId" : "ccf7a609-d884-423e-9204-290e0e6c6f70",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "ok",
        "createdAt" : "2019-05-16T13:53:27Z",
        "updatedAt" : "2019-05-16T14:23:34Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "0fd09c201af9ab3aa50443135b7098211c156639",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,191 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+\n+\n+module Local(State(..), Onum(..), Gnum(..), initState, applyTransPureSimple, applyTrans,\n+             LCommand(..), externCommand,lookForAnAction,\n+             OpenState, getOpenState,\n+             LTrans,\n+             ) where\n+\n+import Prelude hiding(id)\n+import Control.Monad(when)\n+import qualified Data.List as List(find,concatMap)\n+import Data.List ((\\\\))\n+import Data.Maybe(mapMaybe,listToMaybe)\n+import qualified Data.Map.Strict as Map(toList,lookup,empty,adjust,insert,elems,keys)\n+import Data.Map.Strict (Map)\n+\n+import Domain\n+import External\n+\n+----------------------------------------------------------------------\n+-- local command, map to X in context of state\n+\n+data LCommand\n+    = OfferNewGameToAnyone\n+    | OfferGameL Player\n+    | AcceptOfferL Onum\n+    | MakeMoveL Gnum Move\n+    deriving Show\n+\n+externCommand :: Player -> State -> LCommand -> Maybe XCommand\n+externCommand who state@State{knownPlayers} = \\case\n+    OfferNewGameToAnyone -> do\n+        return $ OfferGame (Offer {from = who, to = knownPlayers \\\\ [who] })\n+    OfferGameL player -> do\n+        return $ OfferGame (Offer {from = who, to = [player] }) --can play self!\n+    AcceptOfferL lid -> do\n+        xid <- externOid state lid\n+        return $ AcceptOffer who xid\n+    MakeMoveL lid move -> do\n+        xid <- externGid state lid\n+        return $ MakeMove who xid move\n+\n+externOid :: State -> Onum -> Maybe Xoid\n+externOid State{offers} low = (fmap fst . List.find (\\(_,(l,_,status)) -> l==low && isOpen status) . Map.toList) offers\n+\n+externGid :: State -> Gnum -> Maybe Xgid\n+externGid State{games} low = (fmap fst . List.find (\\(_,(l,_,status)) -> l==low && isOpen status) . Map.toList) games\n+\n+----------------------------------------------------------------------\n+-- local trans, for reporting what happing in terms of local oid/gid\n+data LTrans\n+    = NewOfferL Onum Offer\n+    | OfferNowUnavailable Onum Offer\n+    | NewGameL Gnum Game\n+    | GameMoveL Gnum Game\n+    deriving Show\n+\n+-- TODO: return list, then caller can make random choice!\n+lookForAnAction :: State -> Maybe LCommand\n+lookForAnAction State{whoami,offers,games} =\n+    listToMaybe $\n+        -- prefer to play a game move..\n+        mapMaybe\n+        (\\(onum,offer,status) ->\n+                if whoami `elem` to offer && isOpen status\n+                then Just $ AcceptOfferL onum\n+                else Nothing\n+        ) (Map.elems offers)\n+        ++\n+        -- otherwise accept any pending offer\n+        List.concatMap\n+        -- randomize move order here !\n+        (\\(gnum,game,status) ->\n+                if whoami == p1 game && isOpen status\n+                then map (MakeMoveL gnum) (legalMovesOfGame game)\n+                else []\n+        ) (Map.elems games)\n+\n+----------------------------------------------------------------------\n+-- local state, accumulates external transitions\n+\n+data State = State {\n+    whoami :: Player,\n+    knownPlayers :: [Player],\n+    offers :: Map Xoid (Onum,Offer,Status),\n+    games :: Map Xgid (Gnum,Game,Status),\n+\n+    -- TODO: share the next number thing for offers and games\n+    -- when an offer is converted to a game, keep the number\n+    -- this mean a X-NewGame wil need to refernce the offer is comes from\n+    nextOfferId :: Onum,\n+    nextGameId :: Gnum\n+    }\n+    deriving (Show)\n+\n+data Status = Open | Closed\n+    deriving (Show)\n+\n+isOpen :: Status -> Bool\n+isOpen = \\case Open -> True; Closed -> False"
  }
]