[
  {
    "id" : "b888b55a-89f0-4d66-a0a2-f5cefde736a5",
    "prId" : 1339,
    "comments" : [
      {
        "id" : "7bddac7f-a7b8-4c84-ad4a-d73a4641b5d7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why is catching and discarding all IOExceptions a good idea here? Would be nice to capture this in a comment.",
        "createdAt" : "2019-05-23T11:22:42Z",
        "updatedAt" : "2019-05-23T14:05:16Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d0c1dd8c-6965-48d2-88c4-121cdf105043",
        "parentId" : "7bddac7f-a7b8-4c84-ad4a-d73a4641b5d7",
        "author" : null,
        "body" : "I'll add a comment",
        "createdAt" : "2019-05-23T11:34:20Z",
        "updatedAt" : "2019-05-23T14:05:16Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "d3a711ef84155acf0b8e25f398231dd2e4238e28",
    "line" : 112,
    "diffHunk" : "@@ -36,63 +37,112 @@ instance Y.FromJSON UpdateCheck where\n     parseJSON (Y.String \"never\") = pure UpdateCheckNever\n     parseJSON y = UpdateCheckEvery <$> Y.parseJSON y\n \n-cacheLatestSdkVersion\n+\n+versionsKey :: CacheKey\n+versionsKey = \"versions.txt\"\n+\n+saveAvailableSdkVersions\n+    :: DamlPath\n+    -> [SdkVersion]\n+    -> IO ()\n+saveAvailableSdkVersions damlPath =\n+    saveToCacheWith damlPath versionsKey serializeVersions\n+\n+cacheAvailableSdkVersions\n     :: DamlPath\n-    -> IO (Maybe SdkVersion)\n-    -> IO (Maybe SdkVersion)\n-cacheLatestSdkVersion damlPath getVersion = do\n+    -> IO [SdkVersion]\n+    -> IO [SdkVersion]\n+cacheAvailableSdkVersions damlPath getVersions = do\n     damlConfigE <- tryConfig $ readDamlConfig damlPath\n     let updateCheckM = join $ eitherToMaybe (queryDamlConfig [\"update-check\"] =<< damlConfigE)\n         defaultUpdateCheck = UpdateCheckEvery (CacheTimeout 86400)\n     case fromMaybe defaultUpdateCheck updateCheckM of\n-        UpdateCheckNever -> pure Nothing\n+        UpdateCheckNever -> do\n+            valueAgeM <- loadFromCacheWith damlPath versionsKey (CacheTimeout 0) deserializeVersions\n+            pure (maybe [] fst valueAgeM)\n+\n         UpdateCheckEvery timeout ->\n-            cacheWith \"latest-sdk-version\" timeout\n-                serializeMaybeSdkVersion deserializeMaybeSdkVersion\n-                damlPath getVersion\n+            cacheWith damlPath versionsKey timeout\n+                serializeVersions deserializeVersions\n+                getVersions\n \n-serializeMaybeSdkVersion :: Maybe SdkVersion -> String\n-serializeMaybeSdkVersion = \\case\n-    Nothing -> \"\"\n-    Just v -> versionToString v\n+serializeVersions :: Serialize [SdkVersion]\n+serializeVersions =\n+    unlines . map versionToString\n \n-deserializeMaybeSdkVersion :: String -> Maybe (Maybe SdkVersion)\n-deserializeMaybeSdkVersion = \\case\n-    \"\" -> Nothing\n-    v  -> fmap Just . eitherToMaybe $ parseVersion (pack v)\n+deserializeVersions :: Deserialize [SdkVersion]\n+deserializeVersions =\n+    Just . mapMaybe (eitherToMaybe . parseVersion . pack) . lines\n \n cacheDirPath :: DamlPath -> FilePath\n cacheDirPath (DamlPath damlPath) = damlPath </> \"cache\"\n \n cacheFilePath :: DamlPath -> CacheKey -> FilePath\n cacheFilePath damlPath (CacheKey key) = cacheDirPath damlPath </> key\n \n+type Serialize t = t -> String\n+type Deserialize t = String -> Maybe t\n+\n cacheWith\n-    :: CacheKey\n+    :: DamlPath\n+    -> CacheKey\n     -> CacheTimeout\n-    -> (t -> String)\n-    -> (String -> Maybe t)\n-    -> DamlPath\n+    -> Serialize t\n+    -> Deserialize t\n     -> IO t\n     -> IO t\n-cacheWith key (CacheTimeout timeout) serialize deserialize damlPath getValue = do\n-    let path = cacheFilePath damlPath key\n+cacheWith damlPath key timeout ser deser getFresh = do\n+    valueAgeM <- loadFromCacheWith damlPath key timeout deser\n+    case valueAgeM of\n+        Just (value, Fresh) -> pure value\n+        Just (value, Stale) -> do\n+            valueE <- tryAny getFresh\n+            case valueE of\n+                Left _ -> pure value\n+                Right value' -> do\n+                    saveToCacheWith damlPath key ser value'\n+                    pure value'\n+        Nothing -> do\n+            value <- getFresh\n+            saveToCacheWith damlPath key ser value\n+            pure value\n \n+-- | A representation of the age of a cache value. We only care if the value is stale or fresh.\n+data CacheAge\n+    = Stale\n+    | Fresh\n+\n+-- | Save value to cache.\n+saveToCache :: DamlPath -> CacheKey -> String -> IO ()\n+saveToCache damlPath key value =\n+    void . tryIO $ do"
  },
  {
    "id" : "42fa73a7-41a5-466a-8e54-576404d2370a",
    "prId" : 1339,
    "comments" : [
      {
        "id" : "b6ef499c-e95f-4fc3-a07c-e637cad9d460",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I would just call this `deserialize`. `deser` seems rather confusing.",
        "createdAt" : "2019-05-23T11:23:53Z",
        "updatedAt" : "2019-05-23T14:05:16Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2e0fd607-f71c-4856-bb29-4a9203c4cb44",
        "parentId" : "b6ef499c-e95f-4fc3-a07c-e637cad9d460",
        "author" : null,
        "body" : ":+1:\r\n",
        "createdAt" : "2019-05-23T11:34:10Z",
        "updatedAt" : "2019-05-23T14:05:16Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d3a711ef84155acf0b8e25f398231dd2e4238e28",
    "line" : null,
    "diffHunk" : "@@ -36,63 +37,112 @@ instance Y.FromJSON UpdateCheck where\n     parseJSON (Y.String \"never\") = pure UpdateCheckNever\n     parseJSON y = UpdateCheckEvery <$> Y.parseJSON y\n \n-cacheLatestSdkVersion\n+\n+versionsKey :: CacheKey\n+versionsKey = \"versions.txt\"\n+\n+saveAvailableSdkVersions\n+    :: DamlPath\n+    -> [SdkVersion]\n+    -> IO ()\n+saveAvailableSdkVersions damlPath =\n+    saveToCacheWith damlPath versionsKey serializeVersions\n+\n+cacheAvailableSdkVersions\n     :: DamlPath\n-    -> IO (Maybe SdkVersion)\n-    -> IO (Maybe SdkVersion)\n-cacheLatestSdkVersion damlPath getVersion = do\n+    -> IO [SdkVersion]\n+    -> IO [SdkVersion]\n+cacheAvailableSdkVersions damlPath getVersions = do\n     damlConfigE <- tryConfig $ readDamlConfig damlPath\n     let updateCheckM = join $ eitherToMaybe (queryDamlConfig [\"update-check\"] =<< damlConfigE)\n         defaultUpdateCheck = UpdateCheckEvery (CacheTimeout 86400)\n     case fromMaybe defaultUpdateCheck updateCheckM of\n-        UpdateCheckNever -> pure Nothing\n+        UpdateCheckNever -> do\n+            valueAgeM <- loadFromCacheWith damlPath versionsKey (CacheTimeout 0) deserializeVersions\n+            pure (maybe [] fst valueAgeM)\n+\n         UpdateCheckEvery timeout ->\n-            cacheWith \"latest-sdk-version\" timeout\n-                serializeMaybeSdkVersion deserializeMaybeSdkVersion\n-                damlPath getVersion\n+            cacheWith damlPath versionsKey timeout\n+                serializeVersions deserializeVersions\n+                getVersions\n \n-serializeMaybeSdkVersion :: Maybe SdkVersion -> String\n-serializeMaybeSdkVersion = \\case\n-    Nothing -> \"\"\n-    Just v -> versionToString v\n+serializeVersions :: Serialize [SdkVersion]\n+serializeVersions =\n+    unlines . map versionToString\n \n-deserializeMaybeSdkVersion :: String -> Maybe (Maybe SdkVersion)\n-deserializeMaybeSdkVersion = \\case\n-    \"\" -> Nothing\n-    v  -> fmap Just . eitherToMaybe $ parseVersion (pack v)\n+deserializeVersions :: Deserialize [SdkVersion]\n+deserializeVersions =\n+    Just . mapMaybe (eitherToMaybe . parseVersion . pack) . lines\n \n cacheDirPath :: DamlPath -> FilePath\n cacheDirPath (DamlPath damlPath) = damlPath </> \"cache\"\n \n cacheFilePath :: DamlPath -> CacheKey -> FilePath\n cacheFilePath damlPath (CacheKey key) = cacheDirPath damlPath </> key\n \n+type Serialize t = t -> String\n+type Deserialize t = String -> Maybe t\n+\n cacheWith\n-    :: CacheKey\n+    :: DamlPath\n+    -> CacheKey\n     -> CacheTimeout\n-    -> (t -> String)\n-    -> (String -> Maybe t)\n-    -> DamlPath\n+    -> Serialize t\n+    -> Deserialize t\n     -> IO t\n     -> IO t\n-cacheWith key (CacheTimeout timeout) serialize deserialize damlPath getValue = do\n-    let path = cacheFilePath damlPath key\n+cacheWith damlPath key timeout ser deser getFresh = do\n+    valueAgeM <- loadFromCacheWith damlPath key timeout deser\n+    case valueAgeM of\n+        Just (value, Fresh) -> pure value\n+        Just (value, Stale) -> do\n+            valueE <- tryAny getFresh\n+            case valueE of\n+                Left _ -> pure value\n+                Right value' -> do\n+                    saveToCacheWith damlPath key ser value'\n+                    pure value'\n+        Nothing -> do\n+            value <- getFresh\n+            saveToCacheWith damlPath key ser value\n+            pure value\n \n+-- | A representation of the age of a cache value. We only care if the value is stale or fresh.\n+data CacheAge\n+    = Stale\n+    | Fresh\n+\n+-- | Save value to cache.\n+saveToCache :: DamlPath -> CacheKey -> String -> IO ()\n+saveToCache damlPath key value =\n+    void . tryIO $ do\n+        let dirPath = cacheDirPath damlPath\n+            filePath = cacheFilePath damlPath key\n+        createDirectoryIfMissing True dirPath\n+        writeFileUTF8 filePath value\n+\n+-- | Save value to cache, with serialization function. Never raises an exception.\n+saveToCacheWith :: DamlPath -> CacheKey -> Serialize t -> t -> IO ()\n+saveToCacheWith damlPath key ser value = saveToCache damlPath key (ser value)\n+\n+-- | Read value from cache, including its age. Never raises an exception.\n+loadFromCache :: DamlPath -> CacheKey -> CacheTimeout -> IO (Maybe (String, CacheAge))\n+loadFromCache damlPath key (CacheTimeout timeout) = do\n+    let path = cacheFilePath damlPath key\n     modTimeE <- tryIO (getModificationTime path)\n     curTimeE <- tryIO getCurrentTime\n-    let useCachedE = liftM2 (\\mt ct -> diffUTCTime ct mt < timeout) modTimeE curTimeE\n-        useCached = fromRight False useCachedE\n-\n-    valueMEM <- whenMaybe useCached $ tryIO $ do\n-        valueStr <- readFileUTF8 path\n-        pure (deserialize valueStr)\n-\n-    case valueMEM of\n-        Just (Right (Just value)) -> pure value\n-        _ -> do\n-            value <- getValue\n-            void . tryIO $ do\n-                createDirectoryIfMissing True (cacheDirPath damlPath)\n-                writeFileUTF8 path (serialize value)\n-            pure value\n+    let isStaleE = liftM2 (\\mt ct -> diffUTCTime ct mt >= timeout) modTimeE curTimeE\n+        isStale  = fromRight True isStaleE\n+        age  = if isStale then Stale else Fresh\n+    valueM <- eitherToMaybe <$> tryIO (readFileUTF8 path)\n+    pure $ fmap (, age) valueM\n+\n+-- | Read value from cache, including its age, with deserialization function.\n+loadFromCacheWith :: DamlPath -> CacheKey -> CacheTimeout -> Deserialize t -> IO (Maybe (t, CacheAge))\n+loadFromCacheWith damlPath key timeout deser = do\n+    valueAgeM <- loadFromCache damlPath key timeout\n+    pure $ do\n+        (valueStr, age) <- valueAgeM\n+        value <- deser valueStr"
  },
  {
    "id" : "2521c131-41be-47b1-b2af-5c988540a60b",
    "prId" : 859,
    "comments" : [
      {
        "id" : "92e72ff4-975f-4a70-9c76-f1a21b7b0b32",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we not just use System.Time.Extra.Seconds as the type here? I find NominalDiffTime a horrible type to work with...",
        "createdAt" : "2019-05-02T22:21:33Z",
        "updatedAt" : "2019-05-02T23:40:17Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d8f0043e-e6ab-4833-863f-c9f501c997e7",
        "parentId" : "92e72ff4-975f-4a70-9c76-f1a21b7b0b32",
        "author" : null,
        "body" : ":+1: \r\n",
        "createdAt" : "2019-05-03T07:46:01Z",
        "updatedAt" : "2019-05-03T07:46:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "5c41807d4a80a44cc98e35ebd290d509b3a70c58",
    "line" : 20,
    "diffHunk" : "@@ -24,13 +26,29 @@ newtype CacheKey = CacheKey String\n newtype CacheTimeout = CacheTimeout NominalDiffTime\n     deriving (Show, Eq, Ord, Y.FromJSON)\n \n+data UpdateCheck\n+    = UpdateCheckNever\n+    | UpdateCheckEvery CacheTimeout"
  },
  {
    "id" : "1d79b6e2-f9f0-4603-b2b0-3a3134466564",
    "prId" : 859,
    "comments" : [
      {
        "id" : "5e3a357c-5fc8-40c3-9550-3e506e97c566",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Generally I like newtypes, but I don't feel this one adds much...",
        "createdAt" : "2019-05-02T22:22:16Z",
        "updatedAt" : "2019-05-02T23:40:17Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5c41807d4a80a44cc98e35ebd290d509b3a70c58",
    "line" : 15,
    "diffHunk" : "@@ -24,13 +26,29 @@ newtype CacheKey = CacheKey String\n newtype CacheTimeout = CacheTimeout NominalDiffTime"
  },
  {
    "id" : "072e7d37-1d82-49e0-854e-c0e9419649b7",
    "prId" : 859,
    "comments" : [
      {
        "id" : "43390554-a675-4926-ac0d-7384e96971cf",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Is this right? I would have expected their to be an explicit `daml update` command (because it's super handy to say check now regardless), and I would expect if someone set UpdateNever then did `daml update` (or merely had ever been on UpdateCheckEvery beforehand) it would next time return the most recent version it had cached, but not check afresh.",
        "createdAt" : "2019-05-02T22:25:23Z",
        "updatedAt" : "2019-05-02T23:40:17Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3b2e0035-7e76-4201-990c-62ed60d406d4",
        "parentId" : "43390554-a675-4926-ac0d-7384e96971cf",
        "author" : null,
        "body" : "That makes sense. Does `daml update` also install the latest version if it finds a new one?",
        "createdAt" : "2019-05-03T07:47:18Z",
        "updatedAt" : "2019-05-03T07:47:18Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "56e47f6f-e8b0-403f-a731-ed7f77dc0d83",
        "parentId" : "43390554-a675-4926-ac0d-7384e96971cf",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Maybe? Not sure. Are you doing to suggest `daml install` already does what I want?",
        "createdAt" : "2019-05-03T09:04:26Z",
        "updatedAt" : "2019-05-03T09:04:27Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "22625959-e646-4bde-b04d-eb6446b4f5b6",
        "parentId" : "43390554-a675-4926-ac0d-7384e96971cf",
        "author" : null,
        "body" : "`daml install latest --activate` will try to install the latest version of the sdk and assistant, regardless of the `update-check` setting.",
        "createdAt" : "2019-05-03T09:13:27Z",
        "updatedAt" : "2019-05-03T09:13:27Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "5c41807d4a80a44cc98e35ebd290d509b3a70c58",
    "line" : 39,
    "diffHunk" : "@@ -24,13 +26,29 @@ newtype CacheKey = CacheKey String\n newtype CacheTimeout = CacheTimeout NominalDiffTime\n     deriving (Show, Eq, Ord, Y.FromJSON)\n \n+data UpdateCheck\n+    = UpdateCheckNever\n+    | UpdateCheckEvery CacheTimeout\n+    deriving (Show, Eq, Ord)\n+\n+instance Y.FromJSON UpdateCheck where\n+    parseJSON (Y.String \"never\") = pure UpdateCheckNever\n+    parseJSON y = UpdateCheckEvery <$> Y.parseJSON y\n+\n cacheLatestSdkVersion\n     :: DamlPath\n     -> IO (Maybe SdkVersion)\n     -> IO (Maybe SdkVersion)\n-cacheLatestSdkVersion =\n-    cacheWith \"latest-sdk-version\" (CacheTimeout 86400)\n-        serializeMaybeSdkVersion deserializeMaybeSdkVersion\n+cacheLatestSdkVersion damlPath getVersion = do\n+    damlConfigE <- try $ readDamlConfig damlPath\n+    let updateCheckM = join $ eitherToMaybe (queryDamlConfig [\"update-check\"] =<< damlConfigE)\n+        defaultUpdateCheck = UpdateCheckEvery (CacheTimeout 86400)\n+    case fromMaybe defaultUpdateCheck updateCheckM of\n+        UpdateCheckNever -> pure Nothing"
  }
]