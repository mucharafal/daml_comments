[
  {
    "id" : "a199f243-714e-4e83-8efa-e683fa2f3fae",
    "prId" : 5400,
    "comments" : [
      {
        "id" : "0e836aa0-b4aa-4334-b66e-8171560af68b",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'd suggest removing this empty line as well. Empty lines are somewhat loud in command line output. :)",
        "createdAt" : "2020-04-03T07:53:08Z",
        "updatedAt" : "2020-04-03T07:55:27Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8a08b9c5-f827-4bc5-96f4-8ff9d0f5e9c4",
        "parentId" : "0e836aa0-b4aa-4334-b66e-8171560af68b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I thought about it but I prefer having this clearly separated from the actual output.",
        "createdAt" : "2020-04-03T07:57:42Z",
        "updatedAt" : "2020-04-03T07:57:43Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "01425cd10bf7b6140dd3f2db3600638452544469",
    "line" : 12,
    "diffHunk" : "@@ -99,9 +99,11 @@ versionChecks Env{..} =\n         -- Project SDK version is outdated.\n         when (not isHead && projectSdkVersionIsOld) $ do\n             hPutStr stderr . unlines $\n-                [ \"WARNING: Using an outdated version of the DAML SDK in project.\"\n-                , \"To migrate to the latest DAML SDK, please set the sdk-version\"\n-                , \"field in daml.yaml to \" <> versionToString latestVersion\n+                [ \"DAML SDK \" <> versionToString latestVersion <> \" has been released!\"\n+                , \"See https://github.com/digital-asset/daml/releases/tag/v\"\n+                  <> versionToString latestVersion <> \" for details.\"\n+                -- Carefully crafted wording to make sure itâ€™s < 80 characters so\n+                -- we do not get a line break.\n                 , \"\""
  },
  {
    "id" : "81792f9e-0498-4186-a2d4-2eb409d4f0e2",
    "prId" : 4506,
    "comments" : [
      {
        "id" : "3ca4c648-03ad-4c69-9430-892480dae020",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Nice, I like that anonimization strategy! Good compromise between not leaking sensitive data while giving us a good deal of information.",
        "createdAt" : "2020-02-13T16:15:02Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d80a5142-1136-4117-bc98-2593257deb32",
        "parentId" : "3ca4c648-03ad-4c69-9430-892480dae020",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'd be more comfortable if we were a bit more aggressive here. I suppose what we're interested in are the commands the flags people are using. If we only keep stuff that matches the regular expression `[a-zA-Z0-9\\-_]*`, we should learn enough.",
        "createdAt" : "2020-02-13T17:35:21Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2cfd2087-331a-4350-aff1-c029f89a8199",
        "parentId" : "3ca4c648-03ad-4c69-9430-892480dae020",
        "author" : null,
        "body" : "@hurryabit That seems reasonable to me. Should we still filter out file names though?",
        "createdAt" : "2020-02-14T10:46:22Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "e3495e4f-a9bf-49ad-8442-f267c0358e0b",
        "parentId" : "3ca4c648-03ad-4c69-9430-892480dae020",
        "author" : null,
        "body" : "Well, I added the extra character set test without removing the filter on existing file paths.",
        "createdAt" : "2020-02-14T11:16:04Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "f69aa1bb-1058-4a90-bce9-c4f18cf09209",
        "parentId" : "3ca4c648-03ad-4c69-9430-892480dae020",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I think having both is good.",
        "createdAt" : "2020-02-14T11:22:19Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "88151152-807a-479f-84b1-79766873cc66",
        "parentId" : "3ca4c648-03ad-4c69-9430-892480dae020",
        "author" : null,
        "body" : "@cocreature & I decided to make it even more aggressive: If it isn't a flag (either `-c` or `--cs` format), or on a whitelist (which I built by going manually through all the commands, and needs to be updated occasionally), it gets filtered out of the telemetry.",
        "createdAt" : "2020-02-14T14:43:27Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "a27bf271bc01ccd6f378a901ed930f5ba85959ce",
    "line" : 187,
    "diffHunk" : "@@ -239,12 +259,60 @@ dispatch env path args = do\n     requiredIO \"Failed to spawn command subprocess.\" $\n         runProcess_ (setEnv dispatchEnv $ proc path args)\n \n-displayErrors :: IO () -> IO ()\n-displayErrors m = m `catches`\n-    [ Handler $ \\ (e :: AssistantError) -> do\n-        hPutStrLn stderr (displayException e)\n-        exitFailure\n-    , Handler $ \\ (e :: ConfigError) -> do\n-        hPutStrLn stderr (displayException e)\n-        exitFailure\n+handleErrors :: forall t. L.Handle IO -> IO t -> IO t\n+handleErrors logger m = m `catches`\n+    [ Handler (go . displayException @AssistantError)\n+    , Handler (go . displayException @ConfigError)\n     ]\n+  where\n+    go :: String -> IO t\n+    go err = do\n+        hPutStrLn stderr err\n+        L.logJson logger L.Error $ mkLogTable\n+            [ (\"event\", \"error\")\n+            , (\"message\", A.String (T.pack err))\n+            ]\n+        exitFailure\n+\n+withLogger :: DamlPath -> (L.Handle IO -> IO ()) -> IO ()\n+withLogger damlPath k = do\n+    let logOfInterest prio = prio `elem` [L.Telemetry, L.Warning, L.Error]\n+        gcpConfig = L.GCPConfig\n+            { gcpConfigTag = \"assistant\"\n+            , gcpConfigDamlPath = Just (unwrapDamlPath damlPath)\n+            }\n+\n+        optedOutPath = unwrapDamlPath damlPath </> \".opted_out\"\n+\n+    isOptedOut <- doesPathExist optedOutPath\n+    if isOptedOut\n+        then\n+            k L.makeNopHandle\n+        else do\n+            L.withGcpLogger gcpConfig logOfInterest L.makeNopHandle $ \\gcpState logger -> do\n+                L.logMetaData gcpState\n+                k logger\n+\n+-- | Get the arguments to `daml` and anonimize all but the first.\n+-- That way, the daml command doesn't get accidentally anonimized.\n+anonimizeArgs :: IO [T.Text]\n+anonimizeArgs = do\n+    args <- getArgs\n+    case args of\n+        [] -> pure []\n+        argsHead : argsTail -> do\n+            argsTail' <- concatMapM (anonimizeArg . T.pack) argsTail\n+            pure (T.pack argsHead : argsTail')\n+\n+-- | Anonimize an argument to `daml`.\n+anonimizeArg :: T.Text -> IO [T.Text]"
  },
  {
    "id" : "a70e3251-f38d-4463-9d08-e804d2746082",
    "prId" : 4506,
    "comments" : [
      {
        "id" : "5acd9406-3dbc-4101-a105-a8a9775831a1",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if it would be good to start writing out a file if users have opted in to not log telemetry before they opted in. It sounds fairly easy to implement and removes any doubt.",
        "createdAt" : "2020-02-13T16:16:58Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "378ec48e-f754-46d1-b6be-d7ac0821b176",
        "parentId" : "5acd9406-3dbc-4101-a105-a8a9775831a1",
        "author" : null,
        "body" : "That sounds good! I implemented a '.opted_in' file that gets created automatically, and I added a check for that in the assistant. I still kept the '.opted_out' check just in case we end up in an inconsistent state.",
        "createdAt" : "2020-02-14T11:15:16Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "c68a88ea-50f5-42a9-9669-39b9351d6242",
        "parentId" : "5acd9406-3dbc-4101-a105-a8a9775831a1",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "looks good :+1:",
        "createdAt" : "2020-02-14T11:30:36Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a27bf271bc01ccd6f378a901ed930f5ba85959ce",
    "line" : 165,
    "diffHunk" : "@@ -239,12 +259,60 @@ dispatch env path args = do\n     requiredIO \"Failed to spawn command subprocess.\" $\n         runProcess_ (setEnv dispatchEnv $ proc path args)\n \n-displayErrors :: IO () -> IO ()\n-displayErrors m = m `catches`\n-    [ Handler $ \\ (e :: AssistantError) -> do\n-        hPutStrLn stderr (displayException e)\n-        exitFailure\n-    , Handler $ \\ (e :: ConfigError) -> do\n-        hPutStrLn stderr (displayException e)\n-        exitFailure\n+handleErrors :: forall t. L.Handle IO -> IO t -> IO t\n+handleErrors logger m = m `catches`\n+    [ Handler (go . displayException @AssistantError)\n+    , Handler (go . displayException @ConfigError)\n     ]\n+  where\n+    go :: String -> IO t\n+    go err = do\n+        hPutStrLn stderr err\n+        L.logJson logger L.Error $ mkLogTable\n+            [ (\"event\", \"error\")\n+            , (\"message\", A.String (T.pack err))\n+            ]\n+        exitFailure\n+\n+withLogger :: DamlPath -> (L.Handle IO -> IO ()) -> IO ()\n+withLogger damlPath k = do\n+    let logOfInterest prio = prio `elem` [L.Telemetry, L.Warning, L.Error]\n+        gcpConfig = L.GCPConfig\n+            { gcpConfigTag = \"assistant\"\n+            , gcpConfigDamlPath = Just (unwrapDamlPath damlPath)\n+            }\n+\n+        optedOutPath = unwrapDamlPath damlPath </> \".opted_out\"\n+\n+    isOptedOut <- doesPathExist optedOutPath"
  },
  {
    "id" : "ba14b7f1-fad1-4f1a-b246-e0cfcae5aefb",
    "prId" : 4506,
    "comments" : [
      {
        "id" : "914bc124-198b-4202-94db-aaaa20e5fe88",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "might be a bit nicer if you map `T.pack` directly over `getArgs`.",
        "createdAt" : "2020-02-13T16:19:03Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d26c103e-6b0e-4d7e-8fff-adde5d8ef01e",
        "parentId" : "914bc124-198b-4202-94db-aaaa20e5fe88",
        "author" : null,
        "body" : "good point, thanks!",
        "createdAt" : "2020-02-14T11:15:10Z",
        "updatedAt" : "2020-02-14T15:06:45Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a27bf271bc01ccd6f378a901ed930f5ba85959ce",
    "line" : null,
    "diffHunk" : "@@ -239,12 +259,60 @@ dispatch env path args = do\n     requiredIO \"Failed to spawn command subprocess.\" $\n         runProcess_ (setEnv dispatchEnv $ proc path args)\n \n-displayErrors :: IO () -> IO ()\n-displayErrors m = m `catches`\n-    [ Handler $ \\ (e :: AssistantError) -> do\n-        hPutStrLn stderr (displayException e)\n-        exitFailure\n-    , Handler $ \\ (e :: ConfigError) -> do\n-        hPutStrLn stderr (displayException e)\n-        exitFailure\n+handleErrors :: forall t. L.Handle IO -> IO t -> IO t\n+handleErrors logger m = m `catches`\n+    [ Handler (go . displayException @AssistantError)\n+    , Handler (go . displayException @ConfigError)\n     ]\n+  where\n+    go :: String -> IO t\n+    go err = do\n+        hPutStrLn stderr err\n+        L.logJson logger L.Error $ mkLogTable\n+            [ (\"event\", \"error\")\n+            , (\"message\", A.String (T.pack err))\n+            ]\n+        exitFailure\n+\n+withLogger :: DamlPath -> (L.Handle IO -> IO ()) -> IO ()\n+withLogger damlPath k = do\n+    let logOfInterest prio = prio `elem` [L.Telemetry, L.Warning, L.Error]\n+        gcpConfig = L.GCPConfig\n+            { gcpConfigTag = \"assistant\"\n+            , gcpConfigDamlPath = Just (unwrapDamlPath damlPath)\n+            }\n+\n+        optedOutPath = unwrapDamlPath damlPath </> \".opted_out\"\n+\n+    isOptedOut <- doesPathExist optedOutPath\n+    if isOptedOut\n+        then\n+            k L.makeNopHandle\n+        else do\n+            L.withGcpLogger gcpConfig logOfInterest L.makeNopHandle $ \\gcpState logger -> do\n+                L.logMetaData gcpState\n+                k logger\n+\n+-- | Get the arguments to `daml` and anonimize all but the first.\n+-- That way, the daml command doesn't get accidentally anonimized.\n+anonimizeArgs :: IO [T.Text]\n+anonimizeArgs = do\n+    args <- getArgs"
  }
]