[
  {
    "id" : "dccd42c6-8bac-46b2-8278-d6dd2c0868f0",
    "prId" : 2285,
    "comments" : [
      {
        "id" : "f97b7b8f-c74f-44e4-a476-0e67a88458cf",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n    let ledgerClientConfig = L.configOfHostAndPort (fromString host) (L.Port port)\r\n```",
        "createdAt" : "2019-07-25T10:40:48Z",
        "updatedAt" : "2019-07-25T10:41:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d5e4a4eab076ab2f3cb8f5143332e6a0450c98b9",
    "line" : 34,
    "diffHunk" : "@@ -671,16 +672,16 @@ runStart sandboxPort (StartNavigator shouldStartNavigator) (OpenBrowser shouldOp\n                   then withNavigator\n                   else (\\_ _ _ f -> f sandboxPh)\n \n-runDeploy :: SandboxPort -> IO ()\n-runDeploy sandboxPort = do\n+runDeploy :: String -> SandboxPort -> IO ()\n+runDeploy host sandboxPort = do\n     darPath <- getDarPath\n     doBuild\n     let SandboxPort port = sandboxPort\n-    putStrLn $ \"Deploying \" <> darPath <> \" to ledger on port \" <> show port\n+    putStrLn $ \"Deploying \" <> darPath <> \" to ledger on \" <> host <> \":\" <> show port\n     bytes <- BS.readFile darPath\n     let ls = L.uploadDarFile bytes\n     let timeout = 30 :: L.TimeoutSeconds\n-    let ledgerClientConfig = L.configOfPort $ L.Port port\n+    let ledgerClientConfig = L.configOfHostAndPort (L.Host $ fromString host) (L.Port port)"
  },
  {
    "id" : "38005c36-2afe-43d6-a667-9e01259b86db",
    "prId" : 2250,
    "comments" : [
      {
        "id" : "07e6c4ac-1a57-4623-9308-ca051299e73c",
        "parentId" : null,
        "author" : null,
        "body" : "The `let` is unnecessary given the previous `let`\r\n\r\n\r\n```suggestion\r\n        projectFilesRel = mapMaybe (stripPrefix targetFolderSep) projectFiles\r\n```",
        "createdAt" : "2019-07-22T16:43:51Z",
        "updatedAt" : "2019-07-22T16:44:20Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0cc266e4-c178-4c38-b3b8-fd0e6a4f8cb7",
        "parentId" : "07e6c4ac-1a57-4623-9308-ca051299e73c",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I disagree. This `let` reduces what's in scope for `targetFolderSep`. It's so easy to accidentally write mutually recursive stuff without any intent. That's a way to break the recursion. In fact, I would encourage you to always add these `let`s in `do` blocks. :)",
        "createdAt" : "2019-07-22T16:55:58Z",
        "updatedAt" : "2019-07-22T16:55:59Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c1f0623f976c5e50f82e5307b387090db0fcc796",
    "line" : 5,
    "diffHunk" : "@@ -393,8 +393,10 @@ runInit targetFolderM = do\n     currentSdkVersion <- getSdkVersion\n \n     projectFiles <- listFilesRecursive targetFolder\n+    let targetFolderSep = addTrailingPathSeparator targetFolder\n+    let projectFilesRel = mapMaybe (stripPrefix targetFolderSep) projectFiles"
  },
  {
    "id" : "47c218d8-43db-4d29-a0c4-35843d3c3c3c",
    "prId" : 2250,
    "comments" : [
      {
        "id" : "541d4c02-2427-40cd-8226-dab01deea291",
        "parentId" : null,
        "author" : null,
        "body" : "Same here.\r\n```suggestion\r\n         isMainDotDaml = (== \"Main.daml\") . takeFileName\r\n```",
        "createdAt" : "2019-07-22T16:44:05Z",
        "updatedAt" : "2019-07-22T16:44:48Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c1f0623f976c5e50f82e5307b387090db0fcc796",
    "line" : 6,
    "diffHunk" : "@@ -393,8 +393,10 @@ runInit targetFolderM = do\n     currentSdkVersion <- getSdkVersion\n \n     projectFiles <- listFilesRecursive targetFolder\n+    let targetFolderSep = addTrailingPathSeparator targetFolder\n+    let projectFilesRel = mapMaybe (stripPrefix targetFolderSep) projectFiles\n     let isMainDotDaml = (== \"Main.daml\") . takeFileName"
  },
  {
    "id" : "577826ad-1dea-4a6f-a591-c5de863f3e03",
    "prId" : 2250,
    "comments" : [
      {
        "id" : "f64dedbd-ac7f-4187-a7d0-d2a1265945c4",
        "parentId" : null,
        "author" : null,
        "body" : "Nice :-)",
        "createdAt" : "2019-07-22T16:44:13Z",
        "updatedAt" : "2019-07-22T16:44:20Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "c1f0623f976c5e50f82e5307b387090db0fcc796",
    "line" : 8,
    "diffHunk" : "@@ -393,8 +393,10 @@ runInit targetFolderM = do\n     currentSdkVersion <- getSdkVersion\n \n     projectFiles <- listFilesRecursive targetFolder\n+    let targetFolderSep = addTrailingPathSeparator targetFolder\n+    let projectFilesRel = mapMaybe (stripPrefix targetFolderSep) projectFiles\n     let isMainDotDaml = (== \"Main.daml\") . takeFileName\n-        sourceM = listToMaybe (filter isMainDotDaml projectFiles)\n+        sourceM = find isMainDotDaml projectFilesRel"
  },
  {
    "id" : "82c5c6a3-b7de-4161-9828-227e46a5ea4e",
    "prId" : 2176,
    "comments" : [
      {
        "id" : "64a50f47-5e17-4b89-9c7e-d952ab0ec6b0",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "We should at least make the port configurable for now given that `daml sandbox` also allows you to change that quite easily. Ofc eventually, we need this to be fully configurable including the host, SSL config, â€¦ but for an initial version the port is good enough imho.",
        "createdAt" : "2019-07-16T17:27:52Z",
        "updatedAt" : "2019-07-17T11:22:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a0a5bd6c-46c2-48be-b27e-60bc59e1a7a6",
        "parentId" : "64a50f47-5e17-4b89-9c7e-d952ab0ec6b0",
        "author" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "body" : "done!\r\nmade sandbox port configurable for deploy (and also start command)",
        "createdAt" : "2019-07-17T11:26:52Z",
        "updatedAt" : "2019-07-17T11:26:53Z",
        "lastEditedBy" : {
          "login" : "nickchapman-da",
          "name" : null,
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/49153372?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "da98b4d49b2aebb66c932d5827800af490486a0b",
    "line" : 56,
    "diffHunk" : "@@ -665,18 +669,43 @@ runStart (StartNavigator shouldStartNavigator) (OpenBrowser shouldOpenBrowser) o\n             when shouldWaitForSignal $\n                 void $ race (waitForProcess navigatorPh) (waitForProcess sandboxPh)\n \n-    where sandboxPort = SandboxPort 6865\n-          navigatorPort = NavigatorPort 7500\n+    where navigatorPort = NavigatorPort 7500\n           withNavigator' sandboxPh =\n               if shouldStartNavigator\n                   then withNavigator\n                   else (\\_ _ _ f -> f sandboxPh)\n \n+runDeploy :: IO ()\n+runDeploy = do\n+    projectName <- getProjectName\n+    let darPath = \".daml\" </> \"dist\" </> projectName <> \".dar\"\n+    assistant <- getDamlAssistant\n+    callCommand (unwords $ assistant : [\"build\"])\n+    let SandboxPort port = sandboxPort"
  },
  {
    "id" : "34e2f4bb-e7a7-4fc7-97a1-6ee9506a6a0f",
    "prId" : 2113,
    "comments" : [
      {
        "id" : "0448c77e-6e07-4ad1-b5ec-900fdcd1f50f",
        "parentId" : null,
        "author" : null,
        "body" : "This doesn't make sense to me, in the context of how the program uses `bundledExtensionName`. It was used in `getInstalledExtensions` (which I have no idea how to actually implement any more, since there isn't any distinction between the vsix package we bundle and the extension coming from the marketplace). I'm in favor of just scrapping that code and rewriting `runDamlStudio`  from scratch to have only the `--replace=never`, `--replace=always`, and `--replace=published` modes. \r\n\r\nIn theory all that has to be done in `daml studio` is:\r\n\r\nFor `--replace=published`:\r\n\r\n    1. install the extension based on the name.\r\n    2. if this fails, install the bundled vsix\r\n    3. if that fails, error.\r\n    4. open code at the current project (or current dir if outside project)\r\n\r\nFor `--replace=always`:\r\n\r\n    1. call `code` to uninstall the existing extension. Ignore exit code -- you don't care if the uninstall failed.\r\n    2. call `code` to install the bundled vsix\r\n    3. if that fails, error\r\n    4. open code at the current project (or current dir if outside project)\r\n\r\nFor `--replace=never`:\r\n \r\n    1. open code at the current project (or current dir if outside project)\r\n\r\n\r\n\r\n----\r\n\r\nI suggest the following 8 step manual test process to make sure everything works:\r\n\r\n1. quit vscode, run `daml studio --replace=always`, go to a daml file and make sure there is syntax highlighting\r\n2. quit vscode, run `daml studio --replace=always`, go to a daml file and make sure there is syntax highlighting (again)\r\n3. quit vscode, run `daml studio`, go to a daml file and make sure there is syntax highlighting\r\n4. quit vscode, run `daml studio`, go to a daml file and make sure there is syntax highlighting (again)\r\n5. turn off your wifi / internet connection\r\n6. quit vscode, run `daml studio`, go to a daml file and make sure there is syntax highlighting\r\n7. quit vscode, run `daml studio`, go to a daml file and make sure there is syntax highlighting (again)\r\n8. turn back on your wifi / internet connection\r\n",
        "createdAt" : "2019-07-11T21:55:38Z",
        "updatedAt" : "2019-07-12T21:01:03Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2c255f41-257e-495f-8bba-b3a3e3362245",
        "parentId" : "0448c77e-6e07-4ad1-b5ec-900fdcd1f50f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The bundled extension is slightly different: We give it a different name to avoid autoupgrades and to be able to figure out where we got the extension from. That said, the name should be `DigitalAssetHoldingsLLC.daml-bundled`. I think rewriting it from scratch is a bit overstating what needs to be done.\r\n\r\nThe logic for installing the published extension should stay the same. The logic for removing the bundled extension in the old format should also mostly stay the same but we need a new case to also remove the bundled extension in the new format.\r\n\r\nSomewhat orthogonal to this PR but we should also add a `--replace=bundled` alias that behaves identically to `--replace=always`.",
        "createdAt" : "2019-07-12T07:05:16Z",
        "updatedAt" : "2019-07-12T21:01:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b34fe776d6ca357e55f939cf9039de5e2127dfef",
    "line" : null,
    "diffHunk" : "@@ -122,7 +121,7 @@ publishedExtensionName = \"DigitalAssetHoldingsLLC.daml\"\n -- | Name of VS Code extension bundled with the SDK. Legacy, but also\n -- useful in a pinch, in case published extension goes bad.\n bundledExtensionName :: String\n-bundledExtensionName = \"da-vscode-daml-extension\"\n+bundledExtensionName = \"daml-bundled\""
  },
  {
    "id" : "fbd3d404-9c01-40ac-a896-6eda9eace77f",
    "prId" : 2113,
    "comments" : [
      {
        "id" : "327f0628-4fe1-4405-bc34-dbfcb9ebe9a7",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        removeOldBundledExtension = whenJust oldBundled removePathForcibly\r\n```",
        "createdAt" : "2019-07-12T19:23:20Z",
        "updatedAt" : "2019-07-12T21:01:03Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b54430ae-5a50-4081-bb36-e8de735e2636",
        "parentId" : "327f0628-4fe1-4405-bc34-dbfcb9ebe9a7",
        "author" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "body" : "Thanks!",
        "createdAt" : "2019-07-12T21:01:10Z",
        "updatedAt" : "2019-07-12T21:01:10Z",
        "lastEditedBy" : {
          "login" : "garyverhaegen-da",
          "name" : "Gary Verhaegen",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/45561385?u=eb17386ea66edbd0cd449e33b2d291bf5a1b51cb&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b34fe776d6ca357e55f939cf9039de5e2127dfef",
    "line" : null,
    "diffHunk" : "@@ -119,69 +116,79 @@ getVsCodeExtensionsDir = fmap (</> \".vscode/extensions\") getHomeDirectory\n publishedExtensionName :: String\n publishedExtensionName = \"DigitalAssetHoldingsLLC.daml\"\n \n--- | Name of VS Code extension bundled with the SDK. Legacy, but also\n--- useful in a pinch, in case published extension goes bad.\n+-- | Name of VS Code extension bundled with older SDKs (up to 0.13.12). Was\n+-- implemented as a symlink to extension files stored under ~/.daml.\n+oldBundledExtensionDirName :: String\n+oldBundledExtensionDirName = \"da-vscode-daml-extension\"\n+\n+-- | Name of VS Code extension bundled with the SDK as a vsix.\n bundledExtensionName :: String\n-bundledExtensionName = \"da-vscode-daml-extension\"\n+bundledExtensionName = \"DigitalAssetHoldingsLLC.daml-bundled\"\n \n -- | Status of installed VS Code extensions.\n data InstalledExtensions = InstalledExtensions\n-    { bundledExtensionVersion :: Maybe SdkVersion\n-        -- ^ bundled extension version, if installed\n+    { oldBundled :: Maybe FilePath\n+        -- ^ bundled extension, if installed (0.13.12 and earlier)\n+    , bundledInstalled :: Bool\n+        -- ^ bundled extension, installed through vsix (0.13.13 and up)\n     , publishedExtensionIsInstalled :: Bool\n         -- ^ true if published extension is installed\n     } deriving (Show, Eq)\n \n -- | Get status of installed VS code extensions.\n getInstalledExtensions :: IO InstalledExtensions\n getInstalledExtensions = do\n-    extensionsDir <- getVsCodeExtensionsDir\n-\n-    let bundledExtensionDir = extensionsDir </> bundledExtensionName\n-    bundledExtensionVersion <- readVersionFile bundledExtensionDir\n-\n-    (_exitCode, extensionsStr, _err) <- runVsCodeCommand [\"--list-extensions\"]\n-    let extensions = lines extensionsStr\n-        publishedExtensionIsInstalled = publishedExtensionName `elem` extensions\n-\n+    oldBundled <- getOldExt\n+    extensions <- getExtensions\n+    let oldBundledIsInstalled = maybe False (\\_ -> True) oldBundled\n+        publishedExtensionIsInstalled = not oldBundledIsInstalled && publishedExtensionName `elem` extensions\n+        bundledInstalled = bundledExtensionName `elem` extensions\n     pure InstalledExtensions {..}\n-\n--- | Read VERSION file in directory. Returns Nothing on failure.\n-readVersionFile :: FilePath -> IO (Maybe SdkVersion)\n-readVersionFile dir = do\n-    versionStrE <- tryIO $ readFileUTF8 (dir </> \"VERSION\")\n-    pure $ do\n-        versionStr <- eitherToMaybe versionStrE\n-        eitherToMaybe . parseVersion . T.strip . T.pack $ versionStr\n+    where getOldExt :: IO (Maybe FilePath)\n+          getOldExt = do\n+              extensionsDir <- getVsCodeExtensionsDir\n+              let oldBundledDir = extensionsDir </> oldBundledExtensionDirName\n+              exists <- Dir.doesPathExist oldBundledDir\n+              pure $ if exists then Just oldBundledDir else Nothing\n+          getExtensions :: IO [String]\n+          getExtensions = do\n+              (_exitCode, extensionsStr, _err) <- runVsCodeCommand [\"--list-extensions\"]\n+              pure $ lines extensionsStr\n \n runDamlStudio :: ReplaceExtension -> [String] -> IO ()\n runDamlStudio replaceExt remainingArguments = do\n     sdkPath <- getSdkPath\n-    vscodeExtensionsDir <- getVsCodeExtensionsDir\n     InstalledExtensions {..} <- getInstalledExtensions\n \n-    let bundledExtensionSource = sdkPath </> \"studio\"\n-        bundledExtensionTarget = vscodeExtensionsDir </> bundledExtensionName\n+    let bundledExtensionVsix = sdkPath </> \"studio/daml-bundled.vsix\"\n+\n+        removeOldBundledExtension = case oldBundled of"
  },
  {
    "id" : "7daa622a-6dd2-4219-bfb5-bba619387753",
    "prId" : 1965,
    "comments" : [
      {
        "id" : "b34520dc-d0b4-4fac-918a-f092a99c0eb4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we need this?",
        "createdAt" : "2019-07-02T06:07:56Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "24d0f649-95cd-4500-94e4-3b6ae4494123",
        "parentId" : "b34520dc-d0b4-4fac-918a-f092a99c0eb4",
        "author" : null,
        "body" : "We've had issues before where `daml studio` sets `DAML_SDK_VERSION` (and other environment variables, but this is the main one), and then this gets stuck in vscode, so when the user subsequently opens another project without closing vscode in between, the extension calls `daml damlc ide` with the wrong environment (i.e. with `DAML_SDK_VERSION` already set). This prevents all of that, letting `daml damlc ide` determine all the relevant variables at a later time.\r\n\r\n(The alternative, I guess, is stripping out any `DAML_*` from the env when calling `daml damlc ide` in vscode.)",
        "createdAt" : "2019-07-02T07:15:24Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "9da99e7c-6dc5-4185-8d00-45df8cd3733c",
        "parentId" : "b34520dc-d0b4-4fac-918a-f092a99c0eb4",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I prefer having it in Haskell than Javascript, so here looks like a good place - but i think your comment deserves to be in the code. I imagine we have a ticket number we could include in the code too?",
        "createdAt" : "2019-07-02T07:35:03Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9faef4fb-9331-4cb4-bd3c-a8012ff51c83",
        "parentId" : "b34520dc-d0b4-4fac-918a-f092a99c0eb4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Perfectly happy to keep the logic here, I had simply forgotten why we needed it. So :+1: for a comment, Iâ€™m sure Iâ€™ll manage to forget it again :slightly_smiling_face: ",
        "createdAt" : "2019-07-02T07:51:01Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f8282fc5-b675-41ec-a805-6b601010585e",
        "parentId" : "b34520dc-d0b4-4fac-918a-f092a99c0eb4",
        "author" : null,
        "body" : "Added a comment and linked to issue #1666 ",
        "createdAt" : "2019-07-02T09:00:14Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "ccdc5ee75d18bf6fce73cadc569e9eda5351052f",
    "line" : 19,
    "diffHunk" : "@@ -84,53 +85,162 @@ data ReplaceExtension\n     -- ^ Replace the extension if the current extension is newer.\n     | ReplaceExtAlways\n     -- ^ Always replace the extension.\n+    | ReplaceExtPublished\n+    -- ^ Replace with published extension (the default).\n \n-runDamlStudio :: ReplaceExtension -> [String] -> IO ()\n-runDamlStudio replaceExt remainingArguments = do\n-    sdkPath <- getSdkPath\n-    vscodeExtensionsDir <- fmap (</> \".vscode/extensions\") getHomeDirectory\n-    let vscodeExtensionName = \"da-vscode-daml-extension\"\n-    let vscodeExtensionSrcDir = sdkPath </> \"studio\"\n-    let vscodeExtensionTargetDir = vscodeExtensionsDir </> vscodeExtensionName\n-    whenM (shouldReplaceExtension replaceExt vscodeExtensionTargetDir) $\n-        removePathForcibly vscodeExtensionTargetDir\n-    installExtension vscodeExtensionSrcDir vscodeExtensionTargetDir\n-    -- Note that it is important that we use `shell` rather than `proc` here as\n-    -- `proc` will look for `code.exe` in PATH which does not exist.\n-    projectPathM <- getProjectPath\n-    let codeCommand\n-            | isMac = \"open -a \\\"Visual Studio Code\\\"\"\n-            | otherwise = \"code\"\n-        path = fromMaybe \".\" projectPathM\n-        command = unwords $ codeCommand : path : remainingArguments\n-\n+-- | Run VS Code command with arguments, returning the exit code, stdout & stderr.\n+runVsCodeCommand :: [String] -> IO (ExitCode, String, String)\n+runVsCodeCommand args = do\n     -- Strip DAML environment variables before calling vscode.\n     originalEnv <- getEnvironment\n     let strippedEnv = filter ((`notElem` damlEnvVars) . fst) originalEnv"
  },
  {
    "id" : "02e2785c-ef3c-4243-a241-77850af078bb",
    "prId" : 1965,
    "comments" : [
      {
        "id" : "6b557867-e968-4b15-812b-4020cd9e033f",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        addMacOSPath env =\r\n```\r\nNot a great name either but at least it makes it clear that it specific to MacOS.",
        "createdAt" : "2019-07-02T06:10:40Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4822dcfc-dbc2-4da2-bc67-1b452561e397",
        "parentId" : "6b557867-e968-4b15-812b-4020cd9e033f",
        "author" : null,
        "body" : "Thanks!",
        "createdAt" : "2019-07-02T07:16:51Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c094a579-9d00-4f5f-b55c-ddbc2eb035f7",
        "parentId" : "6b557867-e968-4b15-812b-4020cd9e033f",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd rather `addCodeToPath` which was a standalone function and had a if mac branch and a normal branch - then it has independent semantics.",
        "createdAt" : "2019-07-02T07:36:02Z",
        "updatedAt" : "2019-07-02T09:29:30Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "42a56922-cd48-4964-9d2b-dbe9fd64fd6d",
        "parentId" : "6b557867-e968-4b15-812b-4020cd9e033f",
        "author" : null,
        "body" : "That made the code cleaner. Thanks!",
        "createdAt" : "2019-07-02T09:30:08Z",
        "updatedAt" : "2019-07-02T09:30:09Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "ccdc5ee75d18bf6fce73cadc569e9eda5351052f",
    "line" : null,
    "diffHunk" : "@@ -84,53 +85,162 @@ data ReplaceExtension\n     -- ^ Replace the extension if the current extension is newer.\n     | ReplaceExtAlways\n     -- ^ Always replace the extension.\n+    | ReplaceExtPublished\n+    -- ^ Replace with published extension (the default).\n \n-runDamlStudio :: ReplaceExtension -> [String] -> IO ()\n-runDamlStudio replaceExt remainingArguments = do\n-    sdkPath <- getSdkPath\n-    vscodeExtensionsDir <- fmap (</> \".vscode/extensions\") getHomeDirectory\n-    let vscodeExtensionName = \"da-vscode-daml-extension\"\n-    let vscodeExtensionSrcDir = sdkPath </> \"studio\"\n-    let vscodeExtensionTargetDir = vscodeExtensionsDir </> vscodeExtensionName\n-    whenM (shouldReplaceExtension replaceExt vscodeExtensionTargetDir) $\n-        removePathForcibly vscodeExtensionTargetDir\n-    installExtension vscodeExtensionSrcDir vscodeExtensionTargetDir\n-    -- Note that it is important that we use `shell` rather than `proc` here as\n-    -- `proc` will look for `code.exe` in PATH which does not exist.\n-    projectPathM <- getProjectPath\n-    let codeCommand\n-            | isMac = \"open -a \\\"Visual Studio Code\\\"\"\n-            | otherwise = \"code\"\n-        path = fromMaybe \".\" projectPathM\n-        command = unwords $ codeCommand : path : remainingArguments\n-\n+-- | Run VS Code command with arguments, returning the exit code, stdout & stderr.\n+runVsCodeCommand :: [String] -> IO (ExitCode, String, String)\n+runVsCodeCommand args = do\n     -- Strip DAML environment variables before calling vscode.\n     originalEnv <- getEnvironment\n     let strippedEnv = filter ((`notElem` damlEnvVars) . fst) originalEnv\n-        process = (shell command) { env = Just strippedEnv }\n+        command = unwords (\"code\" : args)\n+        commandEnv =\n+            if isMac\n+                then updateSearchPath strippedEnv -- can't assume code is in PATH on mac\n+                else strippedEnv\n+        updateSearchPath env ="
  }
]