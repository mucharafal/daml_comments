[
  {
    "id" : "c80149d1-b665-47cc-a42d-3fe3034b91b9",
    "prId" : 1837,
    "comments" : [
      {
        "id" : "ce3561c0-4af3-40d1-8a3e-cd31ffcfcc6b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "What is the usecase for this?",
        "createdAt" : "2019-06-24T10:55:14Z",
        "updatedAt" : "2019-06-24T12:39:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "12bcec52-f327-4d00-9d13-3583ed3c5b87",
        "parentId" : "ce3561c0-4af3-40d1-8a3e-cd31ffcfcc6b",
        "author" : null,
        "body" : "For when you want to run a script using `--on-start` and then quit after the script finishes (e.g. for testing).",
        "createdAt" : "2019-06-24T11:24:44Z",
        "updatedAt" : "2019-06-24T12:39:01Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "38feeccb-8727-43fe-91f7-e8f14515b306",
        "parentId" : "ce3561c0-4af3-40d1-8a3e-cd31ffcfcc6b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thanks, sounds like a reasonable usecase. An alternative worth considering might be to exit if the start script fails with a non-zero exit code but I don’t feel strongly about this so your choice.",
        "createdAt" : "2019-06-24T11:30:34Z",
        "updatedAt" : "2019-06-24T12:39:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "482b42ca-5cba-4408-ad06-9685c5dc82ad",
        "parentId" : "ce3561c0-4af3-40d1-8a3e-cd31ffcfcc6b",
        "author" : null,
        "body" : "Seems reasonable to me to make `daml start` exit with the exit code of the `--on-start` command whenever it's non-zero.",
        "createdAt" : "2019-06-24T13:59:45Z",
        "updatedAt" : "2019-06-24T13:59:46Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "eb8231d2448a81cd780c6ffb476357ba6d8683ef",
    "line" : 19,
    "diffHunk" : "@@ -532,8 +534,14 @@ withNavigator (SandboxPort sandboxPort) navigatorPort config args a = do\n -- | Whether `daml start` should open a browser automatically.\n newtype OpenBrowser = OpenBrowser Bool\n \n-runStart :: OpenBrowser -> IO ()\n-runStart (OpenBrowser shouldOpenBrowser) = withProjectRoot Nothing (ProjectCheck \"daml start\" True) $ \\_ _ -> do\n+-- | Whether `daml start` should start the navigator automatically.\n+newtype StartNavigator = StartNavigator Bool\n+\n+-- | Whether `daml start` should wait for Ctrl+C or interrupt after starting servers.\n+newtype WaitForSignal = WaitForSignal Bool"
  },
  {
    "id" : "3a4bdaf8-1fb4-4057-b4ef-395105f4a883",
    "prId" : 1807,
    "comments" : [
      {
        "id" : "a3da9bad-75b9-469e-9de9-59417a36c480",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why not put this in the first line of `main`?",
        "createdAt" : "2019-06-21T16:59:51Z",
        "updatedAt" : "2019-06-22T15:02:52Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "fff80ac9-6fd0-406f-8e8b-4a68761dc510",
        "parentId" : "a3da9bad-75b9-469e-9de9-59417a36c480",
        "author" : null,
        "body" : "Good idea, I did that.",
        "createdAt" : "2019-06-21T17:39:35Z",
        "updatedAt" : "2019-06-22T15:02:52Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "565f427ea21f5d1aa00f603d9d372ca059240443",
    "line" : null,
    "diffHunk" : "@@ -135,6 +137,7 @@ shouldReplaceExtension replaceExt dir =\n \n runJar :: FilePath -> [String] -> IO ()\n runJar jarPath remainingArguments = do\n+    installSignalHandlers"
  },
  {
    "id" : "d3bdfabf-8e1e-4a7b-94b3-7286c45856f6",
    "prId" : 1212,
    "comments" : [
      {
        "id" : "d2023835-25a2-46f0-9c49-660b388533f2",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Why do we need the `projectName == targetFolder` check here?",
        "createdAt" : "2019-05-17T10:02:33Z",
        "updatedAt" : "2019-05-17T10:30:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bdd445aa-f385-4a79-9b3b-154f820c3cdf",
        "parentId" : "d2023835-25a2-46f0-9c49-660b388533f2",
        "author" : null,
        "body" : "My thinking is that if the user passes a targetFolder that isn't a straight up filename (i.e. contains path separators), then they probably know what they're doing.",
        "createdAt" : "2019-05-17T10:12:42Z",
        "updatedAt" : "2019-05-17T10:30:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "0cf4d573-64d1-46e0-baa1-bb040b131dd0",
        "parentId" : "d2023835-25a2-46f0-9c49-660b388533f2",
        "author" : null,
        "body" : "There's a world of difference between `daml new quickstart-java` and `daml new quickstart-java/` :-)\r\n",
        "createdAt" : "2019-05-17T10:15:22Z",
        "updatedAt" : "2019-05-17T10:30:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a7ebb2a3-7272-46d9-9673-fb555bf45867",
        "parentId" : "d2023835-25a2-46f0-9c49-660b388533f2",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Sounds very reasonable, would be nice to capture this thinking in a comment.",
        "createdAt" : "2019-05-17T10:16:03Z",
        "updatedAt" : "2019-05-17T10:30:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3b51ac63-6ce8-43c4-be66-bd756604fef0",
        "parentId" : "d2023835-25a2-46f0-9c49-660b388533f2",
        "author" : null,
        "body" : "Ok, i'll add it :)",
        "createdAt" : "2019-05-17T10:19:32Z",
        "updatedAt" : "2019-05-17T10:30:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "51ed640157df86a53b0d03ed2732f76d115e8db0",
    "line" : 121,
    "diffHunk" : "@@ -346,45 +324,127 @@ runInit targetFolderM = do\n         yamlConfig :: Y.Config\n         yamlConfig = Y.setConfCompare fieldNameCompare Y.defConfig\n \n-\n-runNew :: FilePath -> String -> IO ()\n-runNew targetFolder templateName = do\n+-- | Create a DAML project in a new directory, based on a project template packaged\n+-- with the SDK. Special care has been taken to avoid:\n+--\n+--   - project name / template name confusion: i.e. when a user passes a\n+--   single argument, it should be the new project folder. But if the user\n+--   passes an existing template name instead, we ask the user to be more\n+--   explicit.\n+--\n+--   - creation of a project inside another project\n+--   - creation of a project inside ano\n+--\n+runNew :: FilePath -> Maybe String -> IO ()\n+runNew targetFolder templateNameM = do\n     templatesFolder <- getTemplatesFolder\n-    let templateFolder = templatesFolder </> templateName\n+    let templateName = fromMaybe defaultProjectTemplate templateNameM\n+        templateFolder = templatesFolder </> templateName\n+        projectName = takeFileName (dropTrailingPathSeparator targetFolder)\n+\n+    -- Ensure template exists.\n     unlessM (doesDirectoryExist templateFolder) $ do\n         hPutStr stderr $ unlines\n             [ \"Template \" <> show templateName <> \" does not exist.\"\n             , \"Use `daml new --list` to see a list of available templates\"\n             ]\n         exitFailure\n+\n+    -- Ensure project directory does not already exist.\n     whenM (doesDirectoryExist targetFolder) $ do\n         hPutStr stderr $ unlines\n             [ \"Directory \" <> show targetFolder <> \" already exists.\"\n-            , \"Please specify a new directory for creating a project.\"\n+            , \"Please specify a new directory, or use 'daml init' instead:\"\n+            , \"\"\n+            , \"    daml init \" <> escapePath targetFolder\n+            , \"\"\n             ]\n         exitFailure\n+\n+    -- Ensure user is not confusing template name with project name.\n+    when (isNothing templateNameM && projectName == targetFolder) $ do"
  },
  {
    "id" : "26563a01-4f99-4f4c-9848-f23edd4fd179",
    "prId" : 1212,
    "comments" : [
      {
        "id" : "86497917-b775-43b9-9240-7680c45cd7f4",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I would probably just enclose it in `'` and ignore the case where `'` is in the project name but your choice :smile:",
        "createdAt" : "2019-05-17T10:05:00Z",
        "updatedAt" : "2019-05-17T10:30:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2dd0b456-08c7-4d1a-9b70-e3003a401e45",
        "parentId" : "86497917-b775-43b9-9240-7680c45cd7f4",
        "author" : null,
        "body" : "I find it annoying when tools add quotation marks around paths when they aren't strictly necessary ... so I'll stick with this for now.",
        "createdAt" : "2019-05-17T10:18:23Z",
        "updatedAt" : "2019-05-17T10:30:12Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "51ed640157df86a53b0d03ed2732f76d115e8db0",
    "line" : 202,
    "diffHunk" : "@@ -346,45 +324,127 @@ runInit targetFolderM = do\n         yamlConfig :: Y.Config\n         yamlConfig = Y.setConfCompare fieldNameCompare Y.defConfig\n \n-\n-runNew :: FilePath -> String -> IO ()\n-runNew targetFolder templateName = do\n+-- | Create a DAML project in a new directory, based on a project template packaged\n+-- with the SDK. Special care has been taken to avoid:\n+--\n+--   - project name / template name confusion: i.e. when a user passes a\n+--   single argument, it should be the new project folder. But if the user\n+--   passes an existing template name instead, we ask the user to be more\n+--   explicit.\n+--\n+--   - creation of a project inside another project\n+--   - creation of a project inside ano\n+--\n+runNew :: FilePath -> Maybe String -> IO ()\n+runNew targetFolder templateNameM = do\n     templatesFolder <- getTemplatesFolder\n-    let templateFolder = templatesFolder </> templateName\n+    let templateName = fromMaybe defaultProjectTemplate templateNameM\n+        templateFolder = templatesFolder </> templateName\n+        projectName = takeFileName (dropTrailingPathSeparator targetFolder)\n+\n+    -- Ensure template exists.\n     unlessM (doesDirectoryExist templateFolder) $ do\n         hPutStr stderr $ unlines\n             [ \"Template \" <> show templateName <> \" does not exist.\"\n             , \"Use `daml new --list` to see a list of available templates\"\n             ]\n         exitFailure\n+\n+    -- Ensure project directory does not already exist.\n     whenM (doesDirectoryExist targetFolder) $ do\n         hPutStr stderr $ unlines\n             [ \"Directory \" <> show targetFolder <> \" already exists.\"\n-            , \"Please specify a new directory for creating a project.\"\n+            , \"Please specify a new directory, or use 'daml init' instead:\"\n+            , \"\"\n+            , \"    daml init \" <> escapePath targetFolder\n+            , \"\"\n             ]\n         exitFailure\n+\n+    -- Ensure user is not confusing template name with project name.\n+    when (isNothing templateNameM && projectName == targetFolder) $ do\n+        whenM (doesDirectoryExist (templatesFolder </> projectName)) $ do\n+            hPutStr stderr $ unlines\n+                [ \"Template name \" <> projectName <> \" was given as project name.\"\n+                , \"Please specify a project name separately, for example:\"\n+                , \"\"\n+                , \"    daml new myproject \" <> projectName\n+                , \"\"\n+                ]\n+            exitFailure\n+\n+    -- Ensure we are not creating a project inside another project.\n+    targetFolderAbs <- makeAbsolute targetFolder\n+\n+    damlRootM <- findDamlProjectRoot targetFolderAbs\n+    whenJust damlRootM $ \\damlRoot -> do\n+        hPutStr stderr $ unlines\n+            [ \"Target directory is inside existing DAML project \" <> show damlRoot\n+            , \"Please specify a new directory outside an existing project.\"\n+            ]\n+        exitFailure\n+\n+    daRootM <- findDaProjectRoot targetFolderAbs\n+    whenJust daRootM $ \\daRoot -> do\n+        hPutStr stderr $ unlines\n+            [ \"Target directory is inside existing DA project \" <> show daRoot\n+            , \"Please convert DA project to DAML using 'daml init':\"\n+            , \"\"\n+            , \"    daml init \" <> escapePath daRoot\n+            , \"\"\n+            , \"Or specify a new directory outside an existing project.\"\n+            ]\n+        exitFailure\n+\n+    -- Copy the template over.\n     copyDirectory templateFolder targetFolder\n     files <- listFilesRecursive targetFolder\n     mapM_ setWritable files\n \n-    -- update daml.yaml\n+    -- Update daml.yaml\n     let configPath = targetFolder </> projectConfigName\n         configTemplatePath = configPath <.> \"template\"\n \n     whenM (doesFileExist configTemplatePath) $ do\n         configTemplate <- readFileUTF8 configTemplatePath\n         sdkVersion <- getSdkVersion\n-        let projectName = takeFileName (dropTrailingPathSeparator targetFolder)\n-            config = replace \"__VERSION__\"  sdkVersion\n+        let config = replace \"__VERSION__\"  sdkVersion\n                    . replace \"__PROJECT_NAME__\" projectName\n                    $ configTemplate\n         writeFileUTF8 configPath config\n         removeFile configTemplatePath\n \n+    -- Done.\n     putStrLn $\n         \"Created a new project in \\\"\" <> targetFolder <>\n         \"\\\" based on the template \\\"\" <> templateName <> \"\\\".\"\n \n+defaultProjectTemplate :: String\n+defaultProjectTemplate = \"skeleton\"\n+\n+legacyConfigName :: FilePath\n+legacyConfigName = \"da.yaml\"\n+\n+findDamlProjectRoot :: FilePath -> IO (Maybe FilePath)\n+findDamlProjectRoot = findAscendantWithFile projectConfigName\n+\n+findDaProjectRoot :: FilePath -> IO (Maybe FilePath)\n+findDaProjectRoot = findAscendantWithFile legacyConfigName\n+\n+findAscendantWithFile :: FilePath -> FilePath -> IO (Maybe FilePath)\n+findAscendantWithFile filename path =\n+    findM (\\p -> doesFileExist (p </> filename)) (ascendants path)\n+\n+-- | Escape special characters in a filepath so they can be used as a shell\n+-- argument when displaying a suggested command to user. Do not use this to\n+-- invoke shell commands directly (there are libraries designed for that).\n+escapePath :: FilePath -> FilePath\n+escapePath p | isWindows = concat [\"\\\"\", p, \"\\\"\"] -- Windows is a mess\n+escapePath p = p >>= \\c ->"
  },
  {
    "id" : "3f004e7a-69dd-4359-8508-060da3a78023",
    "prId" : 1157,
    "comments" : [
      {
        "id" : "45132830-2ece-4858-a822-f015d4534fde",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\n          \" See https://code.visualstudio.com/Download for installation instructions.\"\r\n```",
        "createdAt" : "2019-05-15T14:15:58Z",
        "updatedAt" : "2019-05-15T14:18:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "44207cc5f469e5e0eb943cf56954ec1aea864788",
    "line" : null,
    "diffHunk" : "@@ -99,6 +99,10 @@ runDamlStudio replaceExt remainingArguments = do\n         path = fromMaybe \".\" projectPathM\n         command = unwords $ codeCommand : path : remainingArguments\n     exitCode <- withCreateProcess (shell command) $ \\_ _ _ -> waitForProcess\n+    when (exitCode /= ExitSuccess) $\n+        hPutStrLn stderr $\n+          \"Failed to launch Visual Studio Code.\" <>\n+          \" Take a look at https://code.visualstudio.com/Download for installation instructions.\""
  },
  {
    "id" : "beef65f1-36cb-47fd-9e3a-d6f7349594a4",
    "prId" : 1157,
    "comments" : [
      {
        "id" : "25e691a1-b95b-46a9-a608-4c53e94c3fd5",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Is one reason it didn't start because it's not on their path? does a default install put it on the path? Is there any way to debug them failing for other reasons?",
        "createdAt" : "2019-05-15T14:16:28Z",
        "updatedAt" : "2019-05-15T14:18:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "14ae2bc7-a1db-4eca-8c72-d3139a15aea5",
        "parentId" : "25e691a1-b95b-46a9-a608-4c53e94c3fd5",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "The default install does put it in PATH on Windows and Linux unless you explicitly uncheck it. On MacOS it doesn’t seem to do that but we also launch it differently. It’s somewhat tricky to get more information out of a failed startup since we run it via the shell (we have to at least on Windows since it’s `code.cmd` and not `code`) so we don’t even get an exception on a failed start, just an error from the shell (which is also printed to stderr) and a failed exit code.",
        "createdAt" : "2019-05-15T14:25:08Z",
        "updatedAt" : "2019-05-15T14:25:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "44207cc5f469e5e0eb943cf56954ec1aea864788",
    "line" : null,
    "diffHunk" : "@@ -99,6 +99,10 @@ runDamlStudio replaceExt remainingArguments = do\n         path = fromMaybe \".\" projectPathM\n         command = unwords $ codeCommand : path : remainingArguments\n     exitCode <- withCreateProcess (shell command) $ \\_ _ _ -> waitForProcess\n+    when (exitCode /= ExitSuccess) $\n+        hPutStrLn stderr $\n+          \"Failed to launch Visual Studio Code.\" <>\n+          \" Take a look at https://code.visualstudio.com/Download for installation instructions.\""
  },
  {
    "id" : "a1edbf1f-b4db-44ef-a735-d63f8f23ed09",
    "prId" : 1157,
    "comments" : [
      {
        "id" : "d7e59942-6e58-49d6-81a0-d881aee94ce2",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\n        (\\e -> hPutStrLn stderr \"Failed to start java. Make sure it is installed and in the $PATH.\" *> throwIO e)\r\n```",
        "createdAt" : "2019-05-15T14:16:58Z",
        "updatedAt" : "2019-05-15T14:18:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "44207cc5f469e5e0eb943cf56954ec1aea864788",
    "line" : null,
    "diffHunk" : "@@ -126,7 +130,9 @@ withJar :: FilePath -> [String] -> (ProcessHandle -> IO a) -> IO a\n withJar jarPath args a = do\n     sdkPath <- getSdkPath\n     let absJarPath = sdkPath </> jarPath\n-    withCreateProcess (proc \"java\" (\"-jar\" : absJarPath : args)) $ \\_ _ _ -> a\n+    (withCreateProcess (proc \"java\" (\"-jar\" : absJarPath : args)) $ \\_ _ _ -> a) `catchIO`\n+        (\\e -> hPutStrLn stderr \"Failed to start java. Make sure it is installed and in PATH.\" *> throwIO e)"
  },
  {
    "id" : "42bd157c-f040-45ce-a975-72dbcb525cfe",
    "prId" : 1080,
    "comments" : [
      {
        "id" : "82a43209-9509-4c5d-8432-4e6f4369c5c5",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n        projectConfigRel = normalise $ targetFolderRel </> projectConfigName\r\n```\r\nA comment that this is only for display purposes (afaict) would be nice. I spend a few minutes trying to figure out why this is required :smile:",
        "createdAt" : "2019-05-10T13:10:44Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "07742889-f57f-4111-a1b5-b4afa52cc24a",
        "parentId" : "82a43209-9509-4c5d-8432-4e6f4369c5c5",
        "author" : null,
        "body" : "Thanks!",
        "createdAt" : "2019-05-10T13:28:43Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d6ebc6dbdedfba174e31f1415e5bd64f03b1a6",
    "line" : null,
    "diffHunk" : "@@ -126,6 +130,217 @@ withJar jarPath args a = do\n getTemplatesFolder :: IO FilePath\n getTemplatesFolder = fmap (</> \"templates\") getSdkPath\n \n+-- | Initialize a daml project in the current or specified directory.\n+-- It will do the following (first that applies):\n+--\n+-- 1. If the target folder is actually a file, it will error out.\n+--\n+-- 2. If the target folder does not exist, it will error out and ask\n+-- the user if they meant to use daml new instead.\n+--\n+-- 3. If the target folder is a daml project root, it will do nothing\n+-- and let the user know the target is already a daml project.\n+--\n+-- 4. If the target folder is inside a daml project (transitively) but\n+-- is not the project root, it will do nothing and print out a warning.\n+--\n+-- 5. If the target folder is a da project root, it will create a\n+-- daml.yaml config file from the da.yaml config file, and let the\n+-- user know that it did that.\n+--\n+-- 6. If the target folder is inside a da project (transitively) but\n+-- is not the project root, it will error out with a message that lets\n+-- the user know what the project root is and suggests the user run\n+-- daml init on the project root.\n+--\n+-- 7. If none of the above, it will create a daml.yaml from scratch.\n+-- It will attempt to find a Main.daml source file in the project\n+-- directory tree, but if it does not it will use daml/Main.daml\n+-- as the default.\n+--\n+runInit :: Maybe FilePath -> IO ()\n+runInit targetFolderM = do\n+    currentDir <- getCurrentDirectory\n+    let targetFolder = fromMaybe currentDir targetFolderM\n+        targetFolderRel = makeRelative currentDir targetFolder\n+        projectConfigRel"
  },
  {
    "id" : "8b630f33-c65c-4740-82e4-d288db276c42",
    "prId" : 1080,
    "comments" : [
      {
        "id" : "b3994f07-ed13-4013-9922-90b3a3340314",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n            hPutStr stderr $ unlines\r\n```",
        "createdAt" : "2019-05-10T13:11:24Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2293649c-e291-405a-974f-109581522c2e",
        "parentId" : "b3994f07-ed13-4013-9922-90b3a3340314",
        "author" : null,
        "body" : "Thanks!",
        "createdAt" : "2019-05-10T13:28:35Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d6ebc6dbdedfba174e31f1415e5bd64f03b1a6",
    "line" : null,
    "diffHunk" : "@@ -126,6 +130,217 @@ withJar jarPath args a = do\n getTemplatesFolder :: IO FilePath\n getTemplatesFolder = fmap (</> \"templates\") getSdkPath\n \n+-- | Initialize a daml project in the current or specified directory.\n+-- It will do the following (first that applies):\n+--\n+-- 1. If the target folder is actually a file, it will error out.\n+--\n+-- 2. If the target folder does not exist, it will error out and ask\n+-- the user if they meant to use daml new instead.\n+--\n+-- 3. If the target folder is a daml project root, it will do nothing\n+-- and let the user know the target is already a daml project.\n+--\n+-- 4. If the target folder is inside a daml project (transitively) but\n+-- is not the project root, it will do nothing and print out a warning.\n+--\n+-- 5. If the target folder is a da project root, it will create a\n+-- daml.yaml config file from the da.yaml config file, and let the\n+-- user know that it did that.\n+--\n+-- 6. If the target folder is inside a da project (transitively) but\n+-- is not the project root, it will error out with a message that lets\n+-- the user know what the project root is and suggests the user run\n+-- daml init on the project root.\n+--\n+-- 7. If none of the above, it will create a daml.yaml from scratch.\n+-- It will attempt to find a Main.daml source file in the project\n+-- directory tree, but if it does not it will use daml/Main.daml\n+-- as the default.\n+--\n+runInit :: Maybe FilePath -> IO ()\n+runInit targetFolderM = do\n+    currentDir <- getCurrentDirectory\n+    let targetFolder = fromMaybe currentDir targetFolderM\n+        targetFolderRel = makeRelative currentDir targetFolder\n+        projectConfigRel\n+            | targetFolderRel == \".\" = projectConfigName\n+            | otherwise = targetFolderRel </> projectConfigName\n+\n+    -- case 1 or 2\n+    unlessM (doesDirectoryExist targetFolder) $ do\n+        whenM (doesFileExist targetFolder) $ do\n+            hPutStrLn stderr $ unlines"
  },
  {
    "id" : "9b7e8cd9-a05f-4e32-a9b0-e4021c0d2045",
    "prId" : 1080,
    "comments" : [
      {
        "id" : "5fdeb417-c9ab-4f26-865a-e4d8336e0521",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Great documentation, thank you!",
        "createdAt" : "2019-05-10T13:12:24Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ed623427-7a79-4d5f-9158-1d5d45adc012",
        "parentId" : "5fdeb417-c9ab-4f26-865a-e4d8336e0521",
        "author" : null,
        "body" : "Thanks :-)",
        "createdAt" : "2019-05-10T13:28:57Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "02d6ebc6dbdedfba174e31f1415e5bd64f03b1a6",
    "line" : 33,
    "diffHunk" : "@@ -126,6 +130,217 @@ withJar jarPath args a = do\n getTemplatesFolder :: IO FilePath\n getTemplatesFolder = fmap (</> \"templates\") getSdkPath\n \n+-- | Initialize a daml project in the current or specified directory."
  },
  {
    "id" : "9893da06-4d76-44e4-afeb-037f192b5c06",
    "prId" : 1080,
    "comments" : [
      {
        "id" : "64e957d6-54c7-46d6-818a-16d34bdddf24",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I don’t understand the “cases 1 or 2 above” comment.",
        "createdAt" : "2019-05-10T13:13:00Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "07fbaec3-6c34-49c4-8082-c0abc4854dfa",
        "parentId" : "64e957d6-54c7-46d6-818a-16d34bdddf24",
        "author" : null,
        "body" : "A relic from a bygone era, will remove it. :-)",
        "createdAt" : "2019-05-10T13:24:32Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "02d6ebc6dbdedfba174e31f1415e5bd64f03b1a6",
    "line" : null,
    "diffHunk" : "@@ -126,6 +130,217 @@ withJar jarPath args a = do\n getTemplatesFolder :: IO FilePath\n getTemplatesFolder = fmap (</> \"templates\") getSdkPath\n \n+-- | Initialize a daml project in the current or specified directory.\n+-- It will do the following (first that applies):\n+--\n+-- 1. If the target folder is actually a file, it will error out.\n+--\n+-- 2. If the target folder does not exist, it will error out and ask\n+-- the user if they meant to use daml new instead.\n+--\n+-- 3. If the target folder is a daml project root, it will do nothing\n+-- and let the user know the target is already a daml project.\n+--\n+-- 4. If the target folder is inside a daml project (transitively) but\n+-- is not the project root, it will do nothing and print out a warning.\n+--\n+-- 5. If the target folder is a da project root, it will create a\n+-- daml.yaml config file from the da.yaml config file, and let the\n+-- user know that it did that.\n+--\n+-- 6. If the target folder is inside a da project (transitively) but\n+-- is not the project root, it will error out with a message that lets\n+-- the user know what the project root is and suggests the user run\n+-- daml init on the project root.\n+--\n+-- 7. If none of the above, it will create a daml.yaml from scratch.\n+-- It will attempt to find a Main.daml source file in the project\n+-- directory tree, but if it does not it will use daml/Main.daml\n+-- as the default.\n+--\n+runInit :: Maybe FilePath -> IO ()\n+runInit targetFolderM = do\n+    currentDir <- getCurrentDirectory\n+    let targetFolder = fromMaybe currentDir targetFolderM\n+        targetFolderRel = makeRelative currentDir targetFolder\n+        projectConfigRel\n+            | targetFolderRel == \".\" = projectConfigName\n+            | otherwise = targetFolderRel </> projectConfigName\n+\n+    -- case 1 or 2\n+    unlessM (doesDirectoryExist targetFolder) $ do\n+        whenM (doesFileExist targetFolder) $ do\n+            hPutStrLn stderr $ unlines\n+                [ \"ERROR: daml init target should be a directory, but is a file.\"\n+                , \"    target = \" <> targetFolderRel\n+                ]\n+            exitFailure\n+\n+        hPutStr stderr $ unlines\n+            [ \"ERROR: daml init target does not exist.\"\n+            , \"    target = \" <> targetFolderRel\n+            , \"\"\n+            , \"To create a project directory use daml new instead:\"\n+            , \"    daml new \" <> escapePath targetFolderRel\n+            ]\n+        exitFailure\n+    targetFolderAbs <- makeAbsolute targetFolder -- necessary to find project roots\n+\n+    -- cases 3 or 4\n+    damlProjectRootM <- findDamlProjectRoot targetFolderAbs\n+    whenJust damlProjectRootM $ \\projectRoot -> do -- cases 1 or 2 above"
  },
  {
    "id" : "ea4336b1-5583-4e41-9aa2-d88b78feb548",
    "prId" : 1080,
    "comments" : [
      {
        "id" : "01bf12ae-9426-4721-a5ca-d1c61180113e",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we get a function `upgradeOldProject` and split this logic into a separate individual piece? I imagine you're going to want to write a couple of tests for that piece.",
        "createdAt" : "2019-05-10T15:18:06Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02d6ebc6dbdedfba174e31f1415e5bd64f03b1a6",
    "line" : 104,
    "diffHunk" : "@@ -126,18 +130,227 @@ withJar jarPath args a = do\n getTemplatesFolder :: IO FilePath\n getTemplatesFolder = fmap (</> \"templates\") getSdkPath\n \n+-- | Initialize a daml project in the current or specified directory.\n+-- It will do the following (first that applies):\n+--\n+-- 1. If the target folder is actually a file, it will error out.\n+--\n+-- 2. If the target folder does not exist, it will error out and ask\n+-- the user if they meant to use daml new instead.\n+--\n+-- 3. If the target folder is a daml project root, it will do nothing\n+-- and let the user know the target is already a daml project.\n+--\n+-- 4. If the target folder is inside a daml project (transitively) but\n+-- is not the project root, it will do nothing and print out a warning.\n+--\n+-- 5. If the target folder is a da project root, it will create a\n+-- daml.yaml config file from the da.yaml config file, and let the\n+-- user know that it did that.\n+--\n+-- 6. If the target folder is inside a da project (transitively) but\n+-- is not the project root, it will error out with a message that lets\n+-- the user know what the project root is and suggests the user run\n+-- daml init on the project root.\n+--\n+-- 7. If none of the above, it will create a daml.yaml from scratch.\n+-- It will attempt to find a Main.daml source file in the project\n+-- directory tree, but if it does not it will use daml/Main.daml\n+-- as the default.\n+--\n+runInit :: Maybe FilePath -> IO ()\n+runInit targetFolderM = do\n+    currentDir <- getCurrentDirectory\n+    let targetFolder = fromMaybe currentDir targetFolderM\n+        targetFolderRel = makeRelative currentDir targetFolder\n+        projectConfigRel = normalise (targetFolderRel </> projectConfigName)\n+          -- ^ for display purposes\n+\n+    -- cases 1 or 2\n+    unlessM (doesDirectoryExist targetFolder) $ do\n+        whenM (doesFileExist targetFolder) $ do\n+            hPutStr stderr $ unlines\n+                [ \"ERROR: daml init target should be a directory, but is a file.\"\n+                , \"    target = \" <> targetFolderRel\n+                ]\n+            exitFailure\n+\n+        hPutStr stderr $ unlines\n+            [ \"ERROR: daml init target does not exist.\"\n+            , \"    target = \" <> targetFolderRel\n+            , \"\"\n+            , \"To create a project directory use daml new instead:\"\n+            , \"    daml new \" <> escapePath targetFolderRel\n+            ]\n+        exitFailure\n+    targetFolderAbs <- makeAbsolute targetFolder -- necessary to find project roots\n+\n+    -- cases 3 or 4\n+    damlProjectRootM <- findDamlProjectRoot targetFolderAbs\n+    whenJust damlProjectRootM $ \\projectRoot -> do\n+        let projectRootRel = makeRelative currentDir projectRoot\n+        hPutStrLn stderr $ \"DAML project already initialized at \" <> projectRootRel\n+        when (targetFolderAbs /= projectRoot) $ do\n+            hPutStr stderr $ unlines\n+                [ \"WARNING: daml init target is not the DAML project root.\"\n+                , \"    daml init target  = \" <> targetFolder\n+                , \"    DAML project root = \" <> projectRootRel\n+                ]\n+        exitSuccess\n+\n+    -- cases 5 or 6\n+    daProjectRootM <- findDaProjectRoot targetFolderAbs\n+    whenJust daProjectRootM $ \\projectRoot -> do\n+        when (targetFolderAbs /= projectRoot) $ do"
  },
  {
    "id" : "72372936-6799-4933-9ec6-c76c7f45d7ab",
    "prId" : 1080,
    "comments" : [
      {
        "id" : "cb7ab245-be75-4976-8f4c-ce7068773ca8",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Not sure how I feel about `exitSuccess` as a `return` - feels a bit like exceptions as control flow... I can live with it though, the code is very neat.",
        "createdAt" : "2019-05-10T15:18:58Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02d6ebc6dbdedfba174e31f1415e5bd64f03b1a6",
    "line" : 167,
    "diffHunk" : "@@ -126,18 +130,227 @@ withJar jarPath args a = do\n getTemplatesFolder :: IO FilePath\n getTemplatesFolder = fmap (</> \"templates\") getSdkPath\n \n+-- | Initialize a daml project in the current or specified directory.\n+-- It will do the following (first that applies):\n+--\n+-- 1. If the target folder is actually a file, it will error out.\n+--\n+-- 2. If the target folder does not exist, it will error out and ask\n+-- the user if they meant to use daml new instead.\n+--\n+-- 3. If the target folder is a daml project root, it will do nothing\n+-- and let the user know the target is already a daml project.\n+--\n+-- 4. If the target folder is inside a daml project (transitively) but\n+-- is not the project root, it will do nothing and print out a warning.\n+--\n+-- 5. If the target folder is a da project root, it will create a\n+-- daml.yaml config file from the da.yaml config file, and let the\n+-- user know that it did that.\n+--\n+-- 6. If the target folder is inside a da project (transitively) but\n+-- is not the project root, it will error out with a message that lets\n+-- the user know what the project root is and suggests the user run\n+-- daml init on the project root.\n+--\n+-- 7. If none of the above, it will create a daml.yaml from scratch.\n+-- It will attempt to find a Main.daml source file in the project\n+-- directory tree, but if it does not it will use daml/Main.daml\n+-- as the default.\n+--\n+runInit :: Maybe FilePath -> IO ()\n+runInit targetFolderM = do\n+    currentDir <- getCurrentDirectory\n+    let targetFolder = fromMaybe currentDir targetFolderM\n+        targetFolderRel = makeRelative currentDir targetFolder\n+        projectConfigRel = normalise (targetFolderRel </> projectConfigName)\n+          -- ^ for display purposes\n+\n+    -- cases 1 or 2\n+    unlessM (doesDirectoryExist targetFolder) $ do\n+        whenM (doesFileExist targetFolder) $ do\n+            hPutStr stderr $ unlines\n+                [ \"ERROR: daml init target should be a directory, but is a file.\"\n+                , \"    target = \" <> targetFolderRel\n+                ]\n+            exitFailure\n+\n+        hPutStr stderr $ unlines\n+            [ \"ERROR: daml init target does not exist.\"\n+            , \"    target = \" <> targetFolderRel\n+            , \"\"\n+            , \"To create a project directory use daml new instead:\"\n+            , \"    daml new \" <> escapePath targetFolderRel\n+            ]\n+        exitFailure\n+    targetFolderAbs <- makeAbsolute targetFolder -- necessary to find project roots\n+\n+    -- cases 3 or 4\n+    damlProjectRootM <- findDamlProjectRoot targetFolderAbs\n+    whenJust damlProjectRootM $ \\projectRoot -> do\n+        let projectRootRel = makeRelative currentDir projectRoot\n+        hPutStrLn stderr $ \"DAML project already initialized at \" <> projectRootRel\n+        when (targetFolderAbs /= projectRoot) $ do\n+            hPutStr stderr $ unlines\n+                [ \"WARNING: daml init target is not the DAML project root.\"\n+                , \"    daml init target  = \" <> targetFolder\n+                , \"    DAML project root = \" <> projectRootRel\n+                ]\n+        exitSuccess\n+\n+    -- cases 5 or 6\n+    daProjectRootM <- findDaProjectRoot targetFolderAbs\n+    whenJust daProjectRootM $ \\projectRoot -> do\n+        when (targetFolderAbs /= projectRoot) $ do\n+            let projectRootRel = makeRelative currentDir projectRoot\n+            hPutStr stderr $ unlines\n+                [ \"ERROR: daml init target is not DA project root.\"\n+                , \"    daml init target  = \" <> targetFolder\n+                , \"    DA project root   = \" <> projectRootRel\n+                , \"\"\n+                , \"To proceed with da.yaml migration, please use the project root:\"\n+                , \"    daml init \" <> escapePath projectRootRel\n+                ]\n+            exitFailure\n+\n+        let legacyConfigPath = projectRoot </> legacyConfigName\n+            legacyConfigRel = normalise (targetFolderRel </> legacyConfigName)\n+              -- ^ for display purposes\n+\n+        daYaml <- requiredE (\"Failed to parse \" <> T.pack legacyConfigPath) =<<\n+            Y.decodeFileEither (projectRoot </> legacyConfigName)\n+\n+\n+        putStr $ unlines\n+            [ \"Detected DA project.\"\n+            , \"Migrating \" <> legacyConfigRel <> \" to \" <> projectConfigRel\n+            ]\n+\n+\n+        let getField :: Y.FromJSON t => T.Text -> IO t\n+            getField name =\n+                required (\"Failed to parse project.\" <> name <> \" from \" <> T.pack legacyConfigPath) $\n+                    flip Y.parseMaybe daYaml $ \\y -> do\n+                        p <- y Y..: \"project\"\n+                        p Y..: name\n+\n+        minimumSdkVersion <- getMinimumSdkVersion\n+        projSdkVersion :: SdkVersion <- getField \"sdk-version\"\n+        let newProjSdkVersion = max projSdkVersion minimumSdkVersion\n+\n+        when (projSdkVersion < minimumSdkVersion) $ do\n+            putStr $ unlines\n+                [ \"\"\n+                , \"WARNING: da.yaml SDK version \" <> versionToString projSdkVersion <> \" is too old for the new\"\n+                , \"assistant, so daml.yaml will use SDK version \" <> versionToString newProjSdkVersion <> \" instead.\"\n+                , \"\"\n+                ]\n+\n+        projSource :: T.Text <- getField \"source\"\n+        projParties :: [T.Text] <- getField \"parties\"\n+        projName :: T.Text <- getField \"name\"\n+        projScenario :: T.Text <- getField \"scenario\"\n+\n+        BS.writeFile (projectRoot </> projectConfigName) . Y.encodePretty yamlConfig $ Y.object\n+            [ (\"sdk-version\", Y.String (versionToText newProjSdkVersion))\n+            , (\"name\", Y.String projName)\n+            , (\"source\", Y.String projSource)\n+            , (\"scenario\", Y.String projScenario)\n+            , (\"parties\", Y.array (map Y.String projParties))\n+            , (\"version\", Y.String \"1.0.0\")\n+            , (\"exposed-modules\", Y.array [Y.String \"Main\"])\n+            , (\"dependencies\", Y.array [Y.String \"daml-prim\", Y.String \"daml-stdlib\"])\n+            ]\n+\n+\n+        putStrLn (\"Done! Please verify \" <> projectConfigRel)\n+        exitSuccess"
  },
  {
    "id" : "3d5dbd49-a759-413a-a9a7-dd189d5ac619",
    "prId" : 1080,
    "comments" : [
      {
        "id" : "140032a4-a4ad-4237-8bc1-222c8e0096e8",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I tend to hack it up with `show` and then remove the first/last `\"` characters...",
        "createdAt" : "2019-05-10T15:20:05Z",
        "updatedAt" : "2019-05-10T15:44:24Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "02d6ebc6dbdedfba174e31f1415e5bd64f03b1a6",
    "line" : 213,
    "diffHunk" : "@@ -126,18 +130,227 @@ withJar jarPath args a = do\n getTemplatesFolder :: IO FilePath\n getTemplatesFolder = fmap (</> \"templates\") getSdkPath\n \n+-- | Initialize a daml project in the current or specified directory.\n+-- It will do the following (first that applies):\n+--\n+-- 1. If the target folder is actually a file, it will error out.\n+--\n+-- 2. If the target folder does not exist, it will error out and ask\n+-- the user if they meant to use daml new instead.\n+--\n+-- 3. If the target folder is a daml project root, it will do nothing\n+-- and let the user know the target is already a daml project.\n+--\n+-- 4. If the target folder is inside a daml project (transitively) but\n+-- is not the project root, it will do nothing and print out a warning.\n+--\n+-- 5. If the target folder is a da project root, it will create a\n+-- daml.yaml config file from the da.yaml config file, and let the\n+-- user know that it did that.\n+--\n+-- 6. If the target folder is inside a da project (transitively) but\n+-- is not the project root, it will error out with a message that lets\n+-- the user know what the project root is and suggests the user run\n+-- daml init on the project root.\n+--\n+-- 7. If none of the above, it will create a daml.yaml from scratch.\n+-- It will attempt to find a Main.daml source file in the project\n+-- directory tree, but if it does not it will use daml/Main.daml\n+-- as the default.\n+--\n+runInit :: Maybe FilePath -> IO ()\n+runInit targetFolderM = do\n+    currentDir <- getCurrentDirectory\n+    let targetFolder = fromMaybe currentDir targetFolderM\n+        targetFolderRel = makeRelative currentDir targetFolder\n+        projectConfigRel = normalise (targetFolderRel </> projectConfigName)\n+          -- ^ for display purposes\n+\n+    -- cases 1 or 2\n+    unlessM (doesDirectoryExist targetFolder) $ do\n+        whenM (doesFileExist targetFolder) $ do\n+            hPutStr stderr $ unlines\n+                [ \"ERROR: daml init target should be a directory, but is a file.\"\n+                , \"    target = \" <> targetFolderRel\n+                ]\n+            exitFailure\n+\n+        hPutStr stderr $ unlines\n+            [ \"ERROR: daml init target does not exist.\"\n+            , \"    target = \" <> targetFolderRel\n+            , \"\"\n+            , \"To create a project directory use daml new instead:\"\n+            , \"    daml new \" <> escapePath targetFolderRel\n+            ]\n+        exitFailure\n+    targetFolderAbs <- makeAbsolute targetFolder -- necessary to find project roots\n+\n+    -- cases 3 or 4\n+    damlProjectRootM <- findDamlProjectRoot targetFolderAbs\n+    whenJust damlProjectRootM $ \\projectRoot -> do\n+        let projectRootRel = makeRelative currentDir projectRoot\n+        hPutStrLn stderr $ \"DAML project already initialized at \" <> projectRootRel\n+        when (targetFolderAbs /= projectRoot) $ do\n+            hPutStr stderr $ unlines\n+                [ \"WARNING: daml init target is not the DAML project root.\"\n+                , \"    daml init target  = \" <> targetFolder\n+                , \"    DAML project root = \" <> projectRootRel\n+                ]\n+        exitSuccess\n+\n+    -- cases 5 or 6\n+    daProjectRootM <- findDaProjectRoot targetFolderAbs\n+    whenJust daProjectRootM $ \\projectRoot -> do\n+        when (targetFolderAbs /= projectRoot) $ do\n+            let projectRootRel = makeRelative currentDir projectRoot\n+            hPutStr stderr $ unlines\n+                [ \"ERROR: daml init target is not DA project root.\"\n+                , \"    daml init target  = \" <> targetFolder\n+                , \"    DA project root   = \" <> projectRootRel\n+                , \"\"\n+                , \"To proceed with da.yaml migration, please use the project root:\"\n+                , \"    daml init \" <> escapePath projectRootRel\n+                ]\n+            exitFailure\n+\n+        let legacyConfigPath = projectRoot </> legacyConfigName\n+            legacyConfigRel = normalise (targetFolderRel </> legacyConfigName)\n+              -- ^ for display purposes\n+\n+        daYaml <- requiredE (\"Failed to parse \" <> T.pack legacyConfigPath) =<<\n+            Y.decodeFileEither (projectRoot </> legacyConfigName)\n+\n+\n+        putStr $ unlines\n+            [ \"Detected DA project.\"\n+            , \"Migrating \" <> legacyConfigRel <> \" to \" <> projectConfigRel\n+            ]\n+\n+\n+        let getField :: Y.FromJSON t => T.Text -> IO t\n+            getField name =\n+                required (\"Failed to parse project.\" <> name <> \" from \" <> T.pack legacyConfigPath) $\n+                    flip Y.parseMaybe daYaml $ \\y -> do\n+                        p <- y Y..: \"project\"\n+                        p Y..: name\n+\n+        minimumSdkVersion <- getMinimumSdkVersion\n+        projSdkVersion :: SdkVersion <- getField \"sdk-version\"\n+        let newProjSdkVersion = max projSdkVersion minimumSdkVersion\n+\n+        when (projSdkVersion < minimumSdkVersion) $ do\n+            putStr $ unlines\n+                [ \"\"\n+                , \"WARNING: da.yaml SDK version \" <> versionToString projSdkVersion <> \" is too old for the new\"\n+                , \"assistant, so daml.yaml will use SDK version \" <> versionToString newProjSdkVersion <> \" instead.\"\n+                , \"\"\n+                ]\n+\n+        projSource :: T.Text <- getField \"source\"\n+        projParties :: [T.Text] <- getField \"parties\"\n+        projName :: T.Text <- getField \"name\"\n+        projScenario :: T.Text <- getField \"scenario\"\n+\n+        BS.writeFile (projectRoot </> projectConfigName) . Y.encodePretty yamlConfig $ Y.object\n+            [ (\"sdk-version\", Y.String (versionToText newProjSdkVersion))\n+            , (\"name\", Y.String projName)\n+            , (\"source\", Y.String projSource)\n+            , (\"scenario\", Y.String projScenario)\n+            , (\"parties\", Y.array (map Y.String projParties))\n+            , (\"version\", Y.String \"1.0.0\")\n+            , (\"exposed-modules\", Y.array [Y.String \"Main\"])\n+            , (\"dependencies\", Y.array [Y.String \"daml-prim\", Y.String \"daml-stdlib\"])\n+            ]\n+\n+\n+        putStrLn (\"Done! Please verify \" <> projectConfigRel)\n+        exitSuccess\n+\n+\n+    -- case 7\n+    putStrLn (\"Generating \" <> projectConfigRel)\n+\n+    currentSdkVersion <- getSdkVersion\n+\n+    projectFiles <- listFilesRecursive targetFolder\n+    let isMainDotDaml = (== \"Main.daml\") . takeFileName\n+        sourceM = listToMaybe (filter isMainDotDaml projectFiles)\n+        source = fromMaybe \"daml/Main.daml\" sourceM\n+        name = takeFileName (dropTrailingPathSeparator targetFolderAbs)\n+\n+    BS.writeFile (targetFolder </> projectConfigName) . Y.encodePretty yamlConfig $ Y.object\n+        [ (\"sdk-version\", Y.String (T.pack currentSdkVersion))\n+        , (\"name\", Y.String (T.pack name))\n+        , (\"source\", Y.String (T.pack source))\n+        , (\"scenario\", Y.String \"Main:mainScenario\")\n+        , (\"parties\", Y.array [Y.String \"Alice\", Y.String \"Bob\"])\n+        , (\"version\", Y.String \"1.0.0\")\n+        , (\"exposed-modules\", Y.array [Y.String \"Main\"])\n+        , (\"dependencies\", Y.array [Y.String \"daml-prim\", Y.String \"daml-stdlib\"])\n+        ]\n+\n+    putStr $ unlines\n+        [ \"Initialized project \" <> name\n+        , \"Done! Please verify \" <> projectConfigRel\n+        ]\n+\n+\n+    where\n+        legacyConfigName = \"da.yaml\"\n+\n+        findDamlProjectRoot :: FilePath -> IO (Maybe FilePath)\n+        findDamlProjectRoot = findAscendantWithFile projectConfigName\n+\n+        findDaProjectRoot :: FilePath -> IO (Maybe FilePath)\n+        findDaProjectRoot = findAscendantWithFile legacyConfigName\n+\n+        findAscendantWithFile :: FilePath -> FilePath -> IO (Maybe FilePath)\n+        findAscendantWithFile filename path =\n+            findM (\\p -> doesFileExist (p </> filename)) (ascendants path)\n+\n+        -- why don't any good filepath libraries have something like this?\n+        escapePath :: FilePath -> FilePath\n+        escapePath = concatMap $ \\c ->"
  },
  {
    "id" : "d5dba6fa-611b-41fc-bdf7-ec068da143a3",
    "prId" : 993,
    "comments" : [
      {
        "id" : "9bd29b2b-c14c-4a28-9936-03e2cf40b955",
        "parentId" : null,
        "author" : null,
        "body" : "This is the default output path of `build` even without a `-o` argument. Is there an easy way to just use the same path as `build`? e.g. if we want to make the build location configurable in the future, we currently have to change it here as well to maintain consistency, but it would be nicer if they both got the \".dar\" path from daml-project-config or something.",
        "createdAt" : "2019-05-08T07:54:20Z",
        "updatedAt" : "2019-05-08T07:55:27Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "a8434a19-5466-4882-a97d-33d4609b0f29",
        "parentId" : "9bd29b2b-c14c-4a28-9936-03e2cf40b955",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I guess we could move it to `daml-project-config` but that also feels like the wrong place for it. Not passing `-o` doesn’t really help since we need to pass a path to sandbox and navigator so we still have to specify an explicit path. I’d say we probably change this sufficiently rarely that I don’t see this being a big problem.",
        "createdAt" : "2019-05-08T07:57:05Z",
        "updatedAt" : "2019-05-08T07:57:06Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "47c766e2fbd4107330af35c7ab8380fccd8c796e",
    "line" : 8,
    "diffHunk" : "@@ -210,11 +210,11 @@ runStart = withProjectRoot $ \\_ -> do\n     mbScenario :: Maybe String <-\n         requiredE \"Failed to parse scenario\" $\n         queryProjectConfig [\"scenario\"] projectConfig\n-    let darName = projectName <> \".dar\"\n+    let darPath = \"dist\" </> projectName <> \".dar\"\n     assistant <- getDamlAssistant\n-    callCommand (unwords $ assistant : [\"build\", \"-o\", darName])\n+    callCommand (unwords $ assistant : [\"build\", \"-o\", darPath])"
  },
  {
    "id" : "48a67551-4cdd-4d21-8048-8a2ca939e523",
    "prId" : 935,
    "comments" : [
      {
        "id" : "33741185-204a-4aae-ae32-8a81a2a5784f",
        "parentId" : null,
        "author" : null,
        "body" : "Would be nice to include the template name in the note as well.",
        "createdAt" : "2019-05-06T11:52:06Z",
        "updatedAt" : "2019-05-06T11:54:39Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2d9d58bd-18e4-4f90-a29c-350186665efc",
        "parentId" : "33741185-204a-4aae-ae32-8a81a2a5784f",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Great idea, added!",
        "createdAt" : "2019-05-06T11:54:02Z",
        "updatedAt" : "2019-05-06T11:54:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "483b4ce91aa6de0e7636c32b74b9c7b7cd09762f",
    "line" : null,
    "diffHunk" : "@@ -160,6 +160,8 @@ runNew targetFolder templateName = do\n         writeFileUTF8 configPath config\n         removeFile configTemplatePath\n \n+    putStrLn $ \"Created a new project in \\\"\" <> targetFolder \"\\\".\""
  },
  {
    "id" : "15216c04-69fc-4a5a-b25f-b811189de2a9",
    "prId" : 852,
    "comments" : [
      {
        "id" : "d1278861-2a58-4fa5-8a84-8cdfcbb5091e",
        "parentId" : null,
        "author" : null,
        "body" : "```suggestion\r\n```",
        "createdAt" : "2019-05-02T14:48:39Z",
        "updatedAt" : "2019-05-02T14:48:55Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "20f4a1dfdfd9170d8dc773740b4277417e2337e6",
    "line" : null,
    "diffHunk" : "@@ -87,10 +87,14 @@ runDamlStudio replaceExt remainingArguments = do\n     installExtension vscodeExtensionSrcDir vscodeExtensionTargetDir\n     -- Note that it is important that we use `shell` rather than `proc` here as\n     -- `proc` will look for `code.exe` in PATH which does not exist.\n+    projectPathM <- getProjectPath\n     let codeCommand\n             | isMac = \"open -a \\\"Visual Studio Code\\\"\"\n+            | isWindows = \"cmd /C code\""
  },
  {
    "id" : "5345029a-fd8f-4546-85e4-6342260523b7",
    "prId" : 703,
    "comments" : [
      {
        "id" : "db71b847-901c-43e2-8488-a7093fa20410",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd indent this line on the `$`",
        "createdAt" : "2019-04-25T15:38:59Z",
        "updatedAt" : "2019-04-25T15:45:55Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7156beee-2d15-48ad-8c49-876f9cfe6ca4",
        "parentId" : "db71b847-901c-43e2-8488-a7093fa20410",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good idea, changed",
        "createdAt" : "2019-04-25T15:46:00Z",
        "updatedAt" : "2019-04-25T15:46:00Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "47c6c6f3b51555912b861e3c7b247e011b7ecd91",
    "line" : null,
    "diffHunk" : "@@ -66,20 +67,44 @@ required msg = fromMaybeM (throwIO $ DamlHelperError msg Nothing)\n requiredE :: Exception e => T.Text -> Either e t -> IO t\n requiredE msg = fromRightM (throwIO . DamlHelperError msg . Just . T.pack . displayException)\n \n-runDamlStudio :: Bool -> [String] -> IO ()\n-runDamlStudio overwriteExtension remainingArguments = do\n+data ReplaceExtension\n+    = ReplaceExtNever\n+    -- ^ Never replace an existing extension.\n+    | ReplaceExtNewer\n+    -- ^ Replace the extension if the current extension is newer.\n+    | ReplaceExtAlways\n+    -- ^ Always replace the extension.\n+\n+runDamlStudio :: ReplaceExtension -> [String] -> IO ()\n+runDamlStudio replaceExt remainingArguments = do\n     sdkPath <- getSdkPath\n     vscodeExtensionsDir <- fmap (</> \".vscode/extensions\") getHomeDirectory\n     let vscodeExtensionName = \"da-vscode-daml-extension\"\n     let vscodeExtensionSrcDir = sdkPath </> \"studio\"\n     let vscodeExtensionTargetDir = vscodeExtensionsDir </> vscodeExtensionName\n-    when overwriteExtension $ removePathForcibly vscodeExtensionTargetDir\n+    whenM (shouldReplaceExtension replaceExt vscodeExtensionTargetDir) $ removePathForcibly vscodeExtensionTargetDir"
  },
  {
    "id" : "740f8b7b-d4c6-44ee-b958-c8c8cbdd3600",
    "prId" : 693,
    "comments" : [
      {
        "id" : "826cd5f0-33ef-4c4a-baf0-1476920e4da8",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "The reason is that `code` is really `code.cmd` which can only be run through a shell.",
        "createdAt" : "2019-04-25T11:49:48Z",
        "updatedAt" : "2019-04-25T11:50:22Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "6673ed1ca99d1962f2ca3672c7c9fb1d9d415bc2",
    "line" : 14,
    "diffHunk" : "@@ -75,7 +76,9 @@ runDamlStudio overwriteExtension remainingArguments = do\n     let vscodeExtensionTargetDir = vscodeExtensionsDir </> vscodeExtensionName\n     when overwriteExtension $ removePathForcibly vscodeExtensionTargetDir\n     installExtension vscodeExtensionSrcDir vscodeExtensionTargetDir\n-    exitCode <- withCreateProcess (proc \"code\" (\"-w\" : remainingArguments)) $ \\_ _ _ -> waitForProcess\n+    -- Note that it is important that we use `shell` rather than `proc` here as\n+    -- `proc` will look for `code.exe` in PATH which does not exist."
  },
  {
    "id" : "04ccde56-bbb9-4fef-9478-b23b9e13c7d8",
    "prId" : 652,
    "comments" : [
      {
        "id" : "30057793-a224-4574-b2e8-d922c60d9f7a",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Given that we use `__VERSION__` everywhere else it might be a good idea to use it here as well. In general, I prefer `__SDK_VERSION__` but having two different names seems more confusing than using `__VERSION__` consistently until we change everything.",
        "createdAt" : "2019-04-24T11:04:50Z",
        "updatedAt" : "2019-04-24T20:10:13Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "26d9d892-75ab-45c0-95f5-3fb4d30be8b2",
        "parentId" : "30057793-a224-4574-b2e8-d922c60d9f7a",
        "author" : null,
        "body" : "Ok! Thanks!",
        "createdAt" : "2019-04-24T12:33:52Z",
        "updatedAt" : "2019-04-24T20:10:13Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "fe452219a723565574e0bbe7eda450ec18236655",
    "line" : null,
    "diffHunk" : "@@ -109,6 +110,21 @@ runNew targetFolder templateName = do\n         exitFailure\n     copyDirectory templateFolder targetFolder\n \n+    -- update daml.yaml\n+    let configPath = targetFolder </> projectConfigName\n+        configTemplatePath = configPath <.> \"template\"\n+\n+    whenM (doesFileExist configTemplatePath) $ do\n+        configTemplate <- readFileUTF8 configTemplatePath\n+        sdkVersion <- getSdkVersion\n+        let projectName = takeFileName (dropTrailingPathSeparator targetFolder)\n+            config = replace \"__SDK_VERSION__\"  sdkVersion"
  },
  {
    "id" : "35a51de1-64d1-4821-872b-1877b9dc9530",
    "prId" : 545,
    "comments" : [
      {
        "id" : "f7cd37a4-b3fb-4b3a-8d04-ff908ba5a40a",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Will this always build? Should we add short circuiting to `daml build`?",
        "createdAt" : "2019-04-16T15:02:15Z",
        "updatedAt" : "2019-04-16T15:25:15Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d4baf0e8-f289-4d49-aa05-02f6a7fa531e",
        "parentId" : "f7cd37a4-b3fb-4b3a-8d04-ff908ba5a40a",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "For now it will always build. We should definitely make sure that `daml build` does not always rebuild.",
        "createdAt" : "2019-04-16T15:26:29Z",
        "updatedAt" : "2019-04-16T15:26:30Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c075e92a-d8cf-49d0-8b52-b9373b9da336",
        "parentId" : "f7cd37a4-b3fb-4b3a-8d04-ff908ba5a40a",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Sure. Can we get a ticket to that effect?",
        "createdAt" : "2019-04-16T15:27:47Z",
        "updatedAt" : "2019-04-16T15:27:47Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "29487d65-4486-4fd8-a0ba-f02008adcb10",
        "parentId" : "f7cd37a4-b3fb-4b3a-8d04-ff908ba5a40a",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "https://github.com/digital-asset/daml/issues/550",
        "createdAt" : "2019-04-16T15:31:42Z",
        "updatedAt" : "2019-04-16T15:31:43Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1fa796545cb4db6ebce53863f0a269efae559f20",
    "line" : 15,
    "diffHunk" : "@@ -144,9 +144,16 @@ runSandbox port args = do\n     exitCode <- withSandbox port args waitForProcess\n     exitWith exitCode\n \n-runStart :: FilePath -> IO ()\n-runStart darPath = do\n-    withSandbox sandboxPort [darPath] $ \\sandboxPh -> do\n+runStart :: IO ()\n+runStart = withProjectRoot $ \\_ -> do\n+    projectConfig <- getProjectConfig\n+    projectName :: String <-\n+        requiredE \"Project must have a name\" $\n+        queryProjectConfigRequired [\"name\"] projectConfig\n+    let darName = projectName <> \".dar\"\n+    assistant <- getDamlAssistant\n+    callProcess assistant [\"build\", \"-o\", darName]"
  }
]