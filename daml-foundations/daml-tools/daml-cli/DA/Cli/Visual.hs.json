[
  {
    "id" : "f28a793c-f882-46d5-a664-63fc0a826900",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "48a4ecfa-ff8a-4c84-b495-315467103241",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Do we need the `choiceForTemplate` field here? Isn't the `template` field below enough?",
        "createdAt" : "2019-07-02T18:33:58Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7da88e5b-4364-45b5-9438-b38063a49e39",
        "parentId" : "48a4ecfa-ff8a-4c84-b495-315467103241",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "Probably not. I added it for convenience. will try and remove it",
        "createdAt" : "2019-07-02T19:47:56Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -54,15 +55,18 @@ startFromExpr seen world e = case e of\n startFromChoice :: LF.World -> LF.TemplateChoice -> Set.Set Action\n startFromChoice world chc = startFromExpr Set.empty world (LF.chcUpdate chc)\n \n-templatePossibleUpdates :: LF.World -> LF.Template -> Set.Set Action\n-templatePossibleUpdates world tpl = Set.unions $ map (startFromChoice world) (NM.toList (LF.tplChoices tpl))\n+data ChoiceAndAction = ChoiceAndAction { choiceForTemplate :: LF.Template , choice :: LF.TemplateChoice ,actions :: Set.Set Action }"
  },
  {
    "id" : "8abecc08-a915-4c16-9b43-3b4c2e7fe55b",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "c7a00f20-2670-4bda-8cbe-342b6e179c97",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        retTypess = map (\\t -> TemplateChoiceAction t (templatePossibleUpdates world t)) templates\r\n```\r\nYou're spaces have a tendency to appear in strange places. I suppose this is a result of years of scala format?",
        "createdAt" : "2019-07-02T18:35:37Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d6a17bc8-bc4e-4f3a-bed4-e1161a5eb755",
        "parentId" : "c7a00f20-2670-4bda-8cbe-342b6e179c97",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "bad habits from using intellij auto format thing :( ",
        "createdAt" : "2019-07-02T18:58:02Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -54,15 +55,18 @@ startFromExpr seen world e = case e of\n startFromChoice :: LF.World -> LF.TemplateChoice -> Set.Set Action\n startFromChoice world chc = startFromExpr Set.empty world (LF.chcUpdate chc)\n \n-templatePossibleUpdates :: LF.World -> LF.Template -> Set.Set Action\n-templatePossibleUpdates world tpl = Set.unions $ map (startFromChoice world) (NM.toList (LF.tplChoices tpl))\n+data ChoiceAndAction = ChoiceAndAction { choiceForTemplate :: LF.Template , choice :: LF.TemplateChoice ,actions :: Set.Set Action }\n+data TemplateChoiceAction = TemplateChoiceAction { template :: LF.Template ,choiceAndAction :: [ChoiceAndAction] }\n \n-moduleAndTemplates :: LF.World -> LF.Module -> [(LF.TypeConName, Set.Set Action)]\n+\n+templatePossibleUpdates :: LF.World -> LF.Template -> [ChoiceAndAction]\n+templatePossibleUpdates world tpl = map (\\c -> ChoiceAndAction tpl c (startFromChoice world c)) (NM.toList (LF.tplChoices tpl))\n+\n+moduleAndTemplates :: LF.World -> LF.Module -> [TemplateChoiceAction]\n moduleAndTemplates world mod = retTypess\n     where\n         templates = NM.toList $ LF.moduleTemplates mod\n-        retTypess = map (\\t-> (LF.tplTypeCon t, templatePossibleUpdates world t )) templates\n-\n+        retTypess = map (\\t-> TemplateChoiceAction t (templatePossibleUpdates world t ) ) templates"
  },
  {
    "id" : "19052a07-26e3-407c-96cd-68cf4ede9eb6",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "ba78f866-00a0-44c2-93f9-5f35055a0ffd",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should not `unpack` here but rather return a `Text`. This will make code below simpler as well.",
        "createdAt" : "2019-07-02T18:36:35Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "29fc03aa-c6fc-4f07-bfe0-6584211ad506",
        "parentId" : "ba78f866-00a0-44c2-93f9-5f35055a0ffd",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "Cool thanks that simplified few things ",
        "createdAt" : "2019-07-02T19:21:34Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,60 +78,98 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> String\n+tplName LF.Template {..} = T.unpack $ head (LF.unTypeConName tplTypeCon)"
  },
  {
    "id" : "582e3b5b-1eb4-42d2-8355-72e58982a151",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "d9179794-7330-4ff2-bc0b-5bdd19b1a610",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nhandlechioceAndAction (ChoiceAndAction tpl choice _)\r\n  | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\r\n```\r\nThis operates under the assumption you changed the type of `tplName` as proposed above. You might also need `{-# LANGUAGE OverloadedStrings #-}`.",
        "createdAt" : "2019-07-02T18:39:53Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "69bb7116-a1af-4b95-aea3-9778c172f094",
        "parentId" : "d9179794-7330-4ff2-bc0b-5bdd19b1a610",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "Done :) ",
        "createdAt" : "2019-07-02T19:22:07Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,60 +78,98 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> String\n+tplName LF.Template {..} = T.unpack $ head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handlechioceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handlechioceAndAction (ChoiceAndAction tpl (LF.TemplateChoice _ (LF.ChoiceName \"Create\")  _ _ _ _ _ _) _)  = LF.ChoiceName $ T.pack (tplName tpl ++ \"_Create\")"
  },
  {
    "id" : "8374d3fd-697e-48a3-8219-a939668bb3f0",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "2c3d9776-7401-4e37-acd6-6572269e8b54",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\nhandleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\r\n```\r\nSame below.",
        "createdAt" : "2019-07-02T18:40:21Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d7795fb8-01b3-44cc-ada2-ed91ecdfbab8",
        "parentId" : "2c3d9776-7401-4e37-acd6-6572269e8b54",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : ":(",
        "createdAt" : "2019-07-02T19:22:27Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,60 +78,98 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> String\n+tplName LF.Template {..} = T.unpack $ head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handlechioceAndAction :: ChoiceAndAction -> LF.ChoiceName"
  },
  {
    "id" : "b78a9ec2-50e6-438b-840e-f19619edc34c",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "71ca8a69-78cc-4e6f-9969-df5d7ab74ba2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I smell some duplication with `handleChoiceAndAction` here.",
        "createdAt" : "2019-07-02T18:41:04Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,60 +78,98 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> String\n+tplName LF.Template {..} = T.unpack $ head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handlechioceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handlechioceAndAction (ChoiceAndAction tpl (LF.TemplateChoice _ (LF.ChoiceName \"Create\")  _ _ _ _ _ _) _)  = LF.ChoiceName $ T.pack (tplName tpl ++ \"_Create\")\n+handlechioceAndAction (ChoiceAndAction tpl (LF.TemplateChoice _ (LF.ChoiceName \"Archive\")  _ _ _ _ _ _) _)  = LF.ChoiceName $ T.pack (tplName tpl ++ \"_Archive\")\n+handlechioceAndAction (ChoiceAndAction _ (LF.TemplateChoice _ chc  _ _ _ _ _ _ ) _)  = chc\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice,archiveChoice] ++  map handlechioceAndAction choiceAndAction"
  },
  {
    "id" : "588cec1e-5b7b-4a12-b3a9-0f1d20514c9a",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "6dc349c8-62f6-4fc8-8d66-128a28fa344d",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\nhandleCreateAndArchive TemplateChoiceAction {..} = [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\r\n```",
        "createdAt" : "2019-07-02T20:02:22Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +75,84 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction"
  },
  {
    "id" : "6739d40f-9ae7-45c1-85b5-9fdb1a38cbaa",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "41b10932-b9c8-4bb9-a785-eeda291fa14c",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "Missing camel case in `lookUpdata`. Maybe you can think of a more descriptive name anyway.",
        "createdAt" : "2019-07-02T20:05:25Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +75,84 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions\n \n-actionsForTemplate :: (LF.TypeConName, Set.Set Action) -> [LF.TypeConName]\n-actionsForTemplate (_tplCon, actions) = Set.elems $ Set.map templateInAction actions\n+nodeIdForChoice ::  Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int\n+nodeIdForChoice lookUpdata chc = case Map.lookup chc lookUpdata of"
  },
  {
    "id" : "5df85893-3d86-4a06-8126-c22fb92a3a89",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "1c78dce1-3dc7-4f3f-8c3b-9796e197106a",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\nconstructSubgraphsWithLables lookupData tpla@TemplateChoiceAction {..} = SubGraph nodesWithCreate template\r\n```",
        "createdAt" : "2019-07-02T20:06:37Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +75,84 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions\n \n-actionsForTemplate :: (LF.TypeConName, Set.Set Action) -> [LF.TypeConName]\n-actionsForTemplate (_tplCon, actions) = Set.elems $ Set.map templateInAction actions\n+nodeIdForChoice ::  Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int\n+nodeIdForChoice lookUpdata chc = case Map.lookup chc lookUpdata of\n+  Just node -> node\n+  Nothing -> error \"Template node lookup failed\"\n \n-errorOnLeft :: Show a => String -> Either a b -> IO b\n-errorOnLeft desc = \\case\n-  Left err -> ioError $ userError $ unlines [ desc, show err ]\n-  Right x  -> return x\n+-- probably storing the choice is a better Idea, as we can determine what kind of choice it is.\n+data SubGraph = SubGraph { nodes :: [(LF.ChoiceName ,Int)]\n+                         , clusterTemplate :: LF.Template\n+                         }\n+\n+addCreateChoice :: TemplateChoiceAction -> Map.Map LF.ChoiceName Int -> (LF.ChoiceName ,Int)\n+addCreateChoice TemplateChoiceAction {..} lookupData = (tplNameCreateChoice, nodeIdForChoice lookupData tplNameCreateChoice)\n+    where tplNameCreateChoice = LF.ChoiceName $ T.pack ((DAP.renderPretty $ head (LF.unTypeConName $ LF.tplTypeCon template)) ++ \"_Create\")\n+\n+constructSubgraphsWithLables :: Map.Map LF.ChoiceName Int -> TemplateChoiceAction -> SubGraph\n+constructSubgraphsWithLables lookupData tpla@TemplateChoiceAction {..} = SubGraph  nodesWithCreate template"
  },
  {
    "id" : "e5b0bea4-7167-4046-b080-b73c99798ff4",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "5de76a2b-0b1d-4518-845e-dbe154c48e98",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\n        nodesWithCreate = nodes ++ [addCreateChoice tpla lookupData]\r\n```",
        "createdAt" : "2019-07-02T20:06:49Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +75,84 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions\n \n-actionsForTemplate :: (LF.TypeConName, Set.Set Action) -> [LF.TypeConName]\n-actionsForTemplate (_tplCon, actions) = Set.elems $ Set.map templateInAction actions\n+nodeIdForChoice ::  Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int\n+nodeIdForChoice lookUpdata chc = case Map.lookup chc lookUpdata of\n+  Just node -> node\n+  Nothing -> error \"Template node lookup failed\"\n \n-errorOnLeft :: Show a => String -> Either a b -> IO b\n-errorOnLeft desc = \\case\n-  Left err -> ioError $ userError $ unlines [ desc, show err ]\n-  Right x  -> return x\n+-- probably storing the choice is a better Idea, as we can determine what kind of choice it is.\n+data SubGraph = SubGraph { nodes :: [(LF.ChoiceName ,Int)]\n+                         , clusterTemplate :: LF.Template\n+                         }\n+\n+addCreateChoice :: TemplateChoiceAction -> Map.Map LF.ChoiceName Int -> (LF.ChoiceName ,Int)\n+addCreateChoice TemplateChoiceAction {..} lookupData = (tplNameCreateChoice, nodeIdForChoice lookupData tplNameCreateChoice)\n+    where tplNameCreateChoice = LF.ChoiceName $ T.pack ((DAP.renderPretty $ head (LF.unTypeConName $ LF.tplTypeCon template)) ++ \"_Create\")\n+\n+constructSubgraphsWithLables :: Map.Map LF.ChoiceName Int -> TemplateChoiceAction -> SubGraph\n+constructSubgraphsWithLables lookupData tpla@TemplateChoiceAction {..} = SubGraph  nodesWithCreate template\n+  where choicesInTemplete = map handleChoiceAndAction choiceAndAction\n+        nodes = map (\\chc -> (chc, nodeIdForChoice lookupData chc)) choicesInTemplete\n+        nodesWithCreate = nodes ++ [addCreateChoice tpla lookupData ]"
  },
  {
    "id" : "b16e0c80-32e4-4704-845d-1958bbfd6cdd",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "6165d20d-6447-47c3-a9f0-7fca1b37f71a",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\nactionToChoice tpl (AExercise _ (LF.ChoiceName \"Archive\")) = LF.ChoiceName $ tplName tpl <> \"_Archive\"\r\n```",
        "createdAt" : "2019-07-02T20:07:04Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +75,84 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions\n \n-actionsForTemplate :: (LF.TypeConName, Set.Set Action) -> [LF.TypeConName]\n-actionsForTemplate (_tplCon, actions) = Set.elems $ Set.map templateInAction actions\n+nodeIdForChoice ::  Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int\n+nodeIdForChoice lookUpdata chc = case Map.lookup chc lookUpdata of\n+  Just node -> node\n+  Nothing -> error \"Template node lookup failed\"\n \n-errorOnLeft :: Show a => String -> Either a b -> IO b\n-errorOnLeft desc = \\case\n-  Left err -> ioError $ userError $ unlines [ desc, show err ]\n-  Right x  -> return x\n+-- probably storing the choice is a better Idea, as we can determine what kind of choice it is.\n+data SubGraph = SubGraph { nodes :: [(LF.ChoiceName ,Int)]\n+                         , clusterTemplate :: LF.Template\n+                         }\n+\n+addCreateChoice :: TemplateChoiceAction -> Map.Map LF.ChoiceName Int -> (LF.ChoiceName ,Int)\n+addCreateChoice TemplateChoiceAction {..} lookupData = (tplNameCreateChoice, nodeIdForChoice lookupData tplNameCreateChoice)\n+    where tplNameCreateChoice = LF.ChoiceName $ T.pack ((DAP.renderPretty $ head (LF.unTypeConName $ LF.tplTypeCon template)) ++ \"_Create\")\n+\n+constructSubgraphsWithLables :: Map.Map LF.ChoiceName Int -> TemplateChoiceAction -> SubGraph\n+constructSubgraphsWithLables lookupData tpla@TemplateChoiceAction {..} = SubGraph  nodesWithCreate template\n+  where choicesInTemplete = map handleChoiceAndAction choiceAndAction\n+        nodes = map (\\chc -> (chc, nodeIdForChoice lookupData chc)) choicesInTemplete\n+        nodesWithCreate = nodes ++ [addCreateChoice tpla lookupData ]\n+\n+actionToChoice :: LF.Template -> Action -> LF.ChoiceName\n+actionToChoice tpl (ACreate _) = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+actionToChoice tpl (AExercise _ (LF.ChoiceName \"Archive\" )) = LF.ChoiceName $ tplName tpl <> \"_Archive\""
  },
  {
    "id" : "1ab537d7-83da-40d7-8606-b754297ae216",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "d3239638-abbf-4486-857e-1be804ec736a",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\ngraphEdges lookupData tplChcActions = map (\\(chn1, chn2) -> (nodeIdForChoice lookupData chn1, nodeIdForChoice lookupData chn2)) choicePairsForTemplates\r\n```",
        "createdAt" : "2019-07-02T20:07:28Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +75,84 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions\n \n-actionsForTemplate :: (LF.TypeConName, Set.Set Action) -> [LF.TypeConName]\n-actionsForTemplate (_tplCon, actions) = Set.elems $ Set.map templateInAction actions\n+nodeIdForChoice ::  Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int\n+nodeIdForChoice lookUpdata chc = case Map.lookup chc lookUpdata of\n+  Just node -> node\n+  Nothing -> error \"Template node lookup failed\"\n \n-errorOnLeft :: Show a => String -> Either a b -> IO b\n-errorOnLeft desc = \\case\n-  Left err -> ioError $ userError $ unlines [ desc, show err ]\n-  Right x  -> return x\n+-- probably storing the choice is a better Idea, as we can determine what kind of choice it is.\n+data SubGraph = SubGraph { nodes :: [(LF.ChoiceName ,Int)]\n+                         , clusterTemplate :: LF.Template\n+                         }\n+\n+addCreateChoice :: TemplateChoiceAction -> Map.Map LF.ChoiceName Int -> (LF.ChoiceName ,Int)\n+addCreateChoice TemplateChoiceAction {..} lookupData = (tplNameCreateChoice, nodeIdForChoice lookupData tplNameCreateChoice)\n+    where tplNameCreateChoice = LF.ChoiceName $ T.pack ((DAP.renderPretty $ head (LF.unTypeConName $ LF.tplTypeCon template)) ++ \"_Create\")\n+\n+constructSubgraphsWithLables :: Map.Map LF.ChoiceName Int -> TemplateChoiceAction -> SubGraph\n+constructSubgraphsWithLables lookupData tpla@TemplateChoiceAction {..} = SubGraph  nodesWithCreate template\n+  where choicesInTemplete = map handleChoiceAndAction choiceAndAction\n+        nodes = map (\\chc -> (chc, nodeIdForChoice lookupData chc)) choicesInTemplete\n+        nodesWithCreate = nodes ++ [addCreateChoice tpla lookupData ]\n+\n+actionToChoice :: LF.Template -> Action -> LF.ChoiceName\n+actionToChoice tpl (ACreate _) = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+actionToChoice tpl (AExercise _ (LF.ChoiceName \"Archive\" )) = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+actionToChoice _tpl (AExercise _ chc) = chc\n+\n+choiceActionToChoicePairs :: ChoiceAndAction -> [(LF.ChoiceName, LF.ChoiceName)]\n+choiceActionToChoicePairs cha@ChoiceAndAction {..} = pairs\n+    where pairs = map (\\ac -> (handleChoiceAndAction cha, actionToChoice choiceForTemplate ac)) (Set.elems actions)\n+\n+graphEdges :: Map.Map LF.ChoiceName Int -> [TemplateChoiceAction] -> [(Int, Int)]\n+graphEdges lookupData tplChcActions = map (\\(chn1, chn2) -> (nodeIdForChoice lookupData chn1 ,nodeIdForChoice lookupData chn2)) choicePairsForTemplates"
  },
  {
    "id" : "0dfcaadf-8cc5-4d87-b6ae-2d048ea2e86f",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "b09d4d16-ce48-4aad-b89e-0db6c313762c",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\nsubGraphEnd tpl = \"label=\" ++ DAP.renderPretty (LF.tplTypeCon tpl) ++ \";color=\" ++ \"blue\" ++ \"\\n}\"\r\n```",
        "createdAt" : "2019-07-02T20:08:36Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +75,84 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions\n \n-actionsForTemplate :: (LF.TypeConName, Set.Set Action) -> [LF.TypeConName]\n-actionsForTemplate (_tplCon, actions) = Set.elems $ Set.map templateInAction actions\n+nodeIdForChoice ::  Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int\n+nodeIdForChoice lookUpdata chc = case Map.lookup chc lookUpdata of\n+  Just node -> node\n+  Nothing -> error \"Template node lookup failed\"\n \n-errorOnLeft :: Show a => String -> Either a b -> IO b\n-errorOnLeft desc = \\case\n-  Left err -> ioError $ userError $ unlines [ desc, show err ]\n-  Right x  -> return x\n+-- probably storing the choice is a better Idea, as we can determine what kind of choice it is.\n+data SubGraph = SubGraph { nodes :: [(LF.ChoiceName ,Int)]\n+                         , clusterTemplate :: LF.Template\n+                         }\n+\n+addCreateChoice :: TemplateChoiceAction -> Map.Map LF.ChoiceName Int -> (LF.ChoiceName ,Int)\n+addCreateChoice TemplateChoiceAction {..} lookupData = (tplNameCreateChoice, nodeIdForChoice lookupData tplNameCreateChoice)\n+    where tplNameCreateChoice = LF.ChoiceName $ T.pack ((DAP.renderPretty $ head (LF.unTypeConName $ LF.tplTypeCon template)) ++ \"_Create\")\n+\n+constructSubgraphsWithLables :: Map.Map LF.ChoiceName Int -> TemplateChoiceAction -> SubGraph\n+constructSubgraphsWithLables lookupData tpla@TemplateChoiceAction {..} = SubGraph  nodesWithCreate template\n+  where choicesInTemplete = map handleChoiceAndAction choiceAndAction\n+        nodes = map (\\chc -> (chc, nodeIdForChoice lookupData chc)) choicesInTemplete\n+        nodesWithCreate = nodes ++ [addCreateChoice tpla lookupData ]\n+\n+actionToChoice :: LF.Template -> Action -> LF.ChoiceName\n+actionToChoice tpl (ACreate _) = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+actionToChoice tpl (AExercise _ (LF.ChoiceName \"Archive\" )) = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+actionToChoice _tpl (AExercise _ chc) = chc\n+\n+choiceActionToChoicePairs :: ChoiceAndAction -> [(LF.ChoiceName, LF.ChoiceName)]\n+choiceActionToChoicePairs cha@ChoiceAndAction {..} = pairs\n+    where pairs = map (\\ac -> (handleChoiceAndAction cha, actionToChoice choiceForTemplate ac)) (Set.elems actions)\n+\n+graphEdges :: Map.Map LF.ChoiceName Int -> [TemplateChoiceAction] -> [(Int, Int)]\n+graphEdges lookupData tplChcActions = map (\\(chn1, chn2) -> (nodeIdForChoice lookupData chn1 ,nodeIdForChoice lookupData chn2)) choicePairsForTemplates\n+  where chcActionsFromAllTemplates = concatMap choiceAndAction tplChcActions\n+        choicePairsForTemplates = concatMap choiceActionToChoicePairs chcActionsFromAllTemplates\n+\n+subGraphHeader :: LF.Template -> String\n+subGraphHeader tpl = \"subgraph cluster_\" ++ (DAP.renderPretty $ head (LF.unTypeConName $ LF.tplTypeCon tpl)) ++ \"{\\n\"\n \n--- | 'netlistGraph' generates a simple graph from a netlist.\n--- The default implementation does the edeges other way round. The change is on # 143\n-netlistGraph' :: (Ord a)\n-          => (b -> [(String,String)])   -- ^ Attributes for each node\n-          -> (b -> [a])                 -- ^ Out edges leaving each node\n-          -> [(a,b)]                    -- ^ The netlist\n-          -> Dot ()\n-netlistGraph' attrFn outFn assocs = do\n-    let nodes = Set.fromList [a | (a, _) <- assocs]\n-    let outs = Set.fromList [o | (_, b) <- assocs, o <- outFn b]\n-    nodeTab <- sequence\n-                [do nd <- node (attrFn b)\n-                    return (a, nd)\n-                | (a, b) <- assocs]\n-    otherTab <- sequence\n-               [do nd <- node []\n-                   return (o, nd)\n-                | o <- Set.toList outs, o `Set.notMember` nodes]\n-    let fm = M.fromList (nodeTab ++ otherTab)\n-    sequence_\n-        [(fm M.! dst) .->. (fm M.! src) | (dst, b) <- assocs,\n-        src <- outFn b]\n+\n+subGraphBodyLine :: (LF.ChoiceName ,Int) -> String\n+subGraphBodyLine (chc, nodeId) = \"n\" ++ show nodeId ++ \"[label=\" ++ DAP.renderPretty chc ++ \"];\"\n+\n+subGraphEnd :: LF.Template -> String\n+subGraphEnd tpl = \"label=\" ++ (DAP.renderPretty $ LF.tplTypeCon tpl) ++ \";color=\" ++\"blue\" ++ \"\\n}\""
  },
  {
    "id" : "8f09daf1-1ac0-49cf-8886-ebddfb20fc33",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "969f04f9-d953-4a90-9ad9-14d3250e566d",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\n        templatesAndModules = concatMap (moduleAndTemplates world) modules\r\n```",
        "createdAt" : "2019-07-02T20:09:28Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -123,11 +161,17 @@ execVisual darFilePath dotFilePath = do\n     (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive (BSL.toStrict (mainDalfContent manifestData) )\n     let modules = NM.toList $ LF.packageModules lfPkg\n         world = darToWorld manifestData lfPkg\n-        res = concatMap (moduleAndTemplates world) modules\n-        actionEdges = map templatePairs res\n-        dotString = showDot $ netlistGraph' srcLabel actionsForTemplate actionEdges\n+        teamplatesAndModules = concatMap (moduleAndTemplates world) modules"
  },
  {
    "id" : "fa4c5dff-6c2f-4440-99c1-8f6b4881e2f9",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "b0316b6d-2ea4-4312-bfb0-1c97c2806d29",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\n  where choiceActions = concatMap handleCreateAndArchive tplChcActions\r\n```",
        "createdAt" : "2019-07-02T20:11:02Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +78,85 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions"
  },
  {
    "id" : "713dd058-c09d-489b-9e05-f501fa0c03f9",
    "prId" : 1977,
    "comments" : [
      {
        "id" : "d52f3484-cdb5-4e50-b5f2-ef85f5bff29f",
        "parentId" : null,
        "author" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "body" : "```suggestion\r\nnodeIdForChoice :: Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int\r\n```",
        "createdAt" : "2019-07-02T20:11:20Z",
        "updatedAt" : "2019-07-02T20:24:29Z",
        "lastEditedBy" : {
          "login" : "rohanjr",
          "name" : "Rohan Jacob-Rao",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/10836630?u=a30da7f2a9ceeb7c25249d5146f10fce61aeec4e&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3f85032837a73e12a85a85f6b2e5601ad0690f59",
    "line" : null,
    "diffHunk" : "@@ -74,47 +78,85 @@ darToWorld manifest pkg = AST.initWorldSelf pkgs pkg\n     where\n         pkgs = map dalfBytesToPakage (dalfsContent manifest)\n \n+tplName :: LF.Template -> T.Text\n+tplName LF.Template {..} = head (LF.unTypeConName tplTypeCon)\n \n-templateInAction :: Action -> LF.TypeConName\n-templateInAction (ACreate  (LF.Qualified _ _ tpl) ) = tpl\n-templateInAction (AExercise  (LF.Qualified _ _ tpl) _ ) = tpl\n+handleChoiceAndAction :: ChoiceAndAction -> LF.ChoiceName\n+handleChoiceAndAction (ChoiceAndAction tpl choice _)\n+    | LF.chcName choice == LF.ChoiceName \"Create\" = LF.ChoiceName $ tplName tpl <> \"_Create\"\n+    | LF.chcName choice == LF.ChoiceName \"Archive\" = LF.ChoiceName $ tplName tpl <> \"_Archive\"\n+    | otherwise = LF.chcName choice\n \n-srcLabel :: (LF.TypeConName, Set.Set Action) -> [(String, String)]\n-srcLabel (tc, _) = [ (\"shape\",\"none\"),(\"label\",DAP.renderPretty tc) ]\n+-- Making choiceName is very weird\n+handleCreateAndArchive :: TemplateChoiceAction -> [LF.ChoiceName]\n+handleCreateAndArchive TemplateChoiceAction {..} =  [createChoice, archiveChoice] ++ map handleChoiceAndAction choiceAndAction\n+    where archiveChoice = LF.ChoiceName $ tplName template <> \"_Archive\"\n+          createChoice = LF.ChoiceName $ tplName template <> \"_Create\"\n \n-templatePairs :: (LF.TypeConName, Set.Set Action) -> (LF.TypeConName , (LF.TypeConName , Set.Set Action))\n-templatePairs (tc, actions) = (tc , (tc, actions))\n+-- This is used to generate the node ids and use as look up table\n+choiceNameWithId :: [TemplateChoiceAction] -> Map.Map LF.ChoiceName Int\n+choiceNameWithId tplChcActions = Map.fromList $ zip choiceActions [0..]\n+  where choiceActions =  concatMap handleCreateAndArchive tplChcActions\n \n-actionsForTemplate :: (LF.TypeConName, Set.Set Action) -> [LF.TypeConName]\n-actionsForTemplate (_tplCon, actions) = Set.elems $ Set.map templateInAction actions\n+nodeIdForChoice ::  Map.Map LF.ChoiceName Int -> LF.ChoiceName -> Int"
  }
]