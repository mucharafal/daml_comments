[
  {
    "id" : "91e14c7e-ca07-4f0b-9a85-157c0193e4bf",
    "prId" : 1826,
    "comments" : [
      {
        "id" : "28813549-ab5c-40d2-ac65-345d1eb9514f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Is this case really necessary?",
        "createdAt" : "2019-06-25T12:01:40Z",
        "updatedAt" : "2019-06-25T12:01:47Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "8ebe6755019f1a8df2c6be993222a7b7b1590119",
    "line" : 21,
    "diffHunk" : "@@ -45,31 +46,10 @@ startFromExpr seen world e = case e of\n             | ref `Set.member` seen  -> Set.empty\n             | otherwise -> startFromExpr (Set.insert ref seen)  world dvalBody\n         Left _ -> error \"This should not happen\"\n-    LF.EBuiltin _ -> Set.empty\n-    LF.ERecCon _ flds -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) flds\n-    LF.ERecProj _ _ recEx -> startFromExpr seen world recEx\n-    LF.ETupleUpd _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n-    LF.EVariantCon _ _ varg -> startFromExpr seen world varg\n-    LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n-    LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n-    -- Special cases to handle internal calls which do not add an edge to the graph.\n-    LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.EUpdate upd -> startFromUpdate seen world upd"
  },
  {
    "id" : "a29b029b-a4f9-43d6-beb3-7cb0562556da",
    "prId" : 1824,
    "comments" : [
      {
        "id" : "e9ba5102-a73d-4330-bed8-3a3236fd53e3",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Generics required!",
        "createdAt" : "2019-06-22T15:47:44Z",
        "updatedAt" : "2019-06-25T14:10:44Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3d878d2c-fa08-4859-b886-96f6129755b3",
        "parentId" : "e9ba5102-a73d-4330-bed8-3a3236fd53e3",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I guess that's @akalburgi's business. ;)",
        "createdAt" : "2019-06-22T20:38:22Z",
        "updatedAt" : "2019-06-25T14:10:44Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "26d3ad68-0f69-4568-978c-489468f7c00e",
        "parentId" : "e9ba5102-a73d-4330-bed8-3a3236fd53e3",
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Agreed! More a remark for him that the lack of generics is starting to have a cost on other changes. ",
        "createdAt" : "2019-06-23T07:08:09Z",
        "updatedAt" : "2019-06-25T14:10:44Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c28320e6-0574-4936-8166-ae5b7bce4637",
        "parentId" : "e9ba5102-a73d-4330-bed8-3a3236fd53e3",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "Currently working on it",
        "createdAt" : "2019-06-23T11:31:34Z",
        "updatedAt" : "2019-06-25T14:10:44Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ccad103e-b776-4064-afd5-6d551361d73b",
        "parentId" : "e9ba5102-a73d-4330-bed8-3a3236fd53e3",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "@hurryabit using uniplate PR https://github.com/digital-asset/daml/pull/1826 ",
        "createdAt" : "2019-06-23T12:24:43Z",
        "updatedAt" : "2019-06-25T14:10:44Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2146b36439328b158da318771e355850449526dc",
    "line" : null,
    "diffHunk" : "@@ -50,6 +50,7 @@ startFromExpr seen world e = case e of\n     LF.ERecProj _ _ recEx -> startFromExpr seen world recEx\n     LF.ETupleUpd _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n     LF.EVariantCon _ _ varg -> startFromExpr seen world varg"
  },
  {
    "id" : "975e390f-bdec-4b35-8447-d57641abf61e",
    "prId" : 1727,
    "comments" : [
      {
        "id" : "4d4f166b-e27c-4c82-b9c5-4b6237e9481a",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we match on the qualified module name too, to avoid false positives?",
        "createdAt" : "2019-06-19T08:07:18Z",
        "updatedAt" : "2019-06-21T11:47:50Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "01a59a57d14e901916e81ef1eabf16d6bc8e1244",
    "line" : null,
    "diffHunk" : "@@ -59,6 +59,8 @@ startFromExpr seen world e = case e of\n     LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n     LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n     LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.ETmApp (LF.ETyApp (LF.EVal (LF.Qualified _ _ (LF.ExprValName \"fetch\"))) _) _ -> Set.empty"
  },
  {
    "id" : "812f4af0-b8a4-4826-b89f-c4d40231ecb1",
    "prId" : 1727,
    "comments" : [
      {
        "id" : "302846ea-d3dd-45ab-9426-1f67e4cf1c8f",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we get a comment above these two?",
        "createdAt" : "2019-06-21T07:53:15Z",
        "updatedAt" : "2019-06-21T11:47:50Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "01a59a57d14e901916e81ef1eabf16d6bc8e1244",
    "line" : 15,
    "diffHunk" : "@@ -59,6 +59,8 @@ startFromExpr seen world e = case e of\n     LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n     LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n     LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.ETmApp (LF.ETyApp (LF.EVal (LF.Qualified _ (LF.ModuleName [\"DA\",\"Internal\",\"Template\"]) (LF.ExprValName \"fetch\"))) _) _ -> Set.empty"
  },
  {
    "id" : "6ac79812-4895-42ec-9e3f-7384850ffeda",
    "prId" : 1609,
    "comments" : [
      {
        "id" : "600b71c4-5094-4c28-8b0c-7541cd6531d1",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Import this unqualified",
        "createdAt" : "2019-06-12T16:52:47Z",
        "updatedAt" : "2019-06-12T17:32:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4bab041ab2d677006dac805424bd338721c71cb4",
    "line" : null,
    "diffHunk" : "@@ -22,21 +22,18 @@ import qualified Data.ByteString as B\n import Codec.Archive.Zip\n import System.FilePath\n import qualified Data.Map as M\n-import Data.Word\n-import qualified Data.HashMap.Strict as DHM\n-import qualified Data.ByteString.Char8 as CH\n+import qualified Data.HashMap.Strict as Map\n+import qualified Data.ByteString.Char8 as BS\n import qualified Data.List.Split as DLS\n import qualified Data.List as DL\n-import qualified Data.Text as T\n+import qualified Data.List.Extra as DE"
  },
  {
    "id" : "18ff6494-e386-451e-ac7b-f8c41ac7eb80",
    "prId" : 1609,
    "comments" : [
      {
        "id" : "f5f961e3-b462-47fe-973c-14796228f6bc",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Import this unqualified",
        "createdAt" : "2019-06-12T16:53:41Z",
        "updatedAt" : "2019-06-12T17:32:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4bab041ab2d677006dac805424bd338721c71cb4",
    "line" : null,
    "diffHunk" : "@@ -22,21 +22,18 @@ import qualified Data.ByteString as B\n import Codec.Archive.Zip\n import System.FilePath\n import qualified Data.Map as M\n-import Data.Word\n-import qualified Data.HashMap.Strict as DHM\n-import qualified Data.ByteString.Char8 as CH\n+import qualified Data.HashMap.Strict as Map\n+import qualified Data.ByteString.Char8 as BS\n import qualified Data.List.Split as DLS\n import qualified Data.List as DL"
  },
  {
    "id" : "81612a1a-8671-48cc-bebc-4aac98658c4f",
    "prId" : 1609,
    "comments" : [
      {
        "id" : "3d2a4048-b18c-4140-be09-d5151eb1c4bb",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "This return () is redundant",
        "createdAt" : "2019-06-12T16:54:02Z",
        "updatedAt" : "2019-06-12T17:32:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4bab041ab2d677006dac805424bd338721c71cb4",
    "line" : null,
    "diffHunk" : "@@ -144,55 +141,47 @@ netlistGraph' attrFn outFn assocs = do\n         [(fm M.! dst) .->. (fm M.! src) | (dst, b) <- assocs,\n         src <- outFn b]\n \n-\n-\n data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)\n \n-charToWord8 :: Char -> Word8\n-charToWord8 = toEnum . fromEnum\n-\n-cleanString :: String -> String\n-cleanString str = T.unpack (T.strip $ T.pack str)\n-\n lineToKeyValue :: String -> (String, String)\n-lineToKeyValue line = case DLS.splitOn \":\" line of\n-    [l, r] -> (cleanString l , cleanString r)\n-    _ -> (\"malformed\", \"malformed\")            \n-\n+lineToKeyValue line = case DE.splitOn \":\" line of\n+    [l, r] -> (DE.trim l , DE.trim r)\n+    _ -> (\"malformed\", \"malformed\")\n \n-manifestMapToManifest :: DHM.HashMap String String -> Manifest\n+manifestMapToManifest :: Map.HashMap String String -> Manifest\n manifestMapToManifest hash = Manifest mainDalf dependDalfs\n     where\n-        mainDalf = DHM.lookupDefault \"unknown\" \"Main-Dalf\" hash\n-        dependDalfs = map cleanString $ DL.delete mainDalf (DLS.splitOn \",\" (DHM.lookupDefault \"unknown\" \"Dalfs\" hash))\n-\n+        mainDalf = Map.lookupDefault \"unknown\" \"Main-Dalf\" hash\n+        dependDalfs = map DE.trim $ DL.delete mainDalf (DLS.splitOn \",\" (Map.lookupDefault \"unknown\" \"Dalfs\" hash))\n \n manifestDataFromDar :: Archive -> Manifest -> ManifestData\n manifestDataFromDar archive manifest = ManifestData manifestDalfByte dependencyDalfBytes\n     where\n         manifestDalfByte = head [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && eRelativePath e  == mainDalf manifest]\n-        dependencyDalfBytes = [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && DL.elem (cleanString (eRelativePath e))  (dalfs manifest)]\n+        dependencyDalfBytes = [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && DL.elem (DE.trim (eRelativePath e))  (dalfs manifest)]\n \n manifestFromDar :: Archive -> ManifestData\n manifestFromDar dar =  manifestDataFromDar dar manifest\n-    where \n+    where\n         manifestEntry = head [fromEntry e | e <- zEntries dar, \".MF\" `isExtensionOf` eRelativePath e]\n-        lines = BSL.split (charToWord8 '\\n') manifestEntry\n-        linesStr = map (CH.unpack . BSL.toStrict) lines\n-        manifest = manifestMapToManifest $ DHM.fromList $ map lineToKeyValue (filter (\\a -> a /= \"\" ) linesStr)\n+        linesStr = map BS.unpack (BS.lines $ BSL.toStrict manifestEntry)\n+        manifest = manifestMapToManifest $ Map.fromList $ map lineToKeyValue (filter (\\a -> a /= \"\" ) linesStr)\n \n \n-execVisual :: FilePath -> IO ()\n-execVisual darFilePath = do\n+execVisual :: FilePath -> Maybe FilePath -> IO ()\n+execVisual darFilePath dotFilePath = do\n     darBytes <- B.readFile darFilePath\n     let manifestData = manifestFromDar $ ZIPArchive.toArchive (BSL.fromStrict darBytes)\n     (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive (BSL.toStrict (mainDalfContent manifestData) )\n     let modules = NM.toList $ LF.packageModules lfPkg\n         world = darToWorld manifestData lfPkg\n         res = concatMap (moduleAndTemplates world) modules\n-        actionEdges = map templatePairs res        \n-    putStrLn $ showDot $ do \n-        netlistGraph' srcLabel actionsForTemplate actionEdges\n+        actionEdges = map templatePairs res\n+        dotString = showDot $ do netlistGraph' srcLabel actionsForTemplate actionEdges\n+    case dotFilePath of\n+        Just outDotFile -> writeFile outDotFile dotString\n+        Nothing -> putStrLn dotString\n+    return ()"
  },
  {
    "id" : "5b03207b-48cf-4377-9887-aed1dee47e03",
    "prId" : 1609,
    "comments" : [
      {
        "id" : "1a1aaa0c-1b32-4c50-891b-492f51faddd5",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "This do is redundant",
        "createdAt" : "2019-06-12T16:54:09Z",
        "updatedAt" : "2019-06-12T17:32:29Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4bab041ab2d677006dac805424bd338721c71cb4",
    "line" : null,
    "diffHunk" : "@@ -144,55 +141,47 @@ netlistGraph' attrFn outFn assocs = do\n         [(fm M.! dst) .->. (fm M.! src) | (dst, b) <- assocs,\n         src <- outFn b]\n \n-\n-\n data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)\n \n-charToWord8 :: Char -> Word8\n-charToWord8 = toEnum . fromEnum\n-\n-cleanString :: String -> String\n-cleanString str = T.unpack (T.strip $ T.pack str)\n-\n lineToKeyValue :: String -> (String, String)\n-lineToKeyValue line = case DLS.splitOn \":\" line of\n-    [l, r] -> (cleanString l , cleanString r)\n-    _ -> (\"malformed\", \"malformed\")            \n-\n+lineToKeyValue line = case DE.splitOn \":\" line of\n+    [l, r] -> (DE.trim l , DE.trim r)\n+    _ -> (\"malformed\", \"malformed\")\n \n-manifestMapToManifest :: DHM.HashMap String String -> Manifest\n+manifestMapToManifest :: Map.HashMap String String -> Manifest\n manifestMapToManifest hash = Manifest mainDalf dependDalfs\n     where\n-        mainDalf = DHM.lookupDefault \"unknown\" \"Main-Dalf\" hash\n-        dependDalfs = map cleanString $ DL.delete mainDalf (DLS.splitOn \",\" (DHM.lookupDefault \"unknown\" \"Dalfs\" hash))\n-\n+        mainDalf = Map.lookupDefault \"unknown\" \"Main-Dalf\" hash\n+        dependDalfs = map DE.trim $ DL.delete mainDalf (DLS.splitOn \",\" (Map.lookupDefault \"unknown\" \"Dalfs\" hash))\n \n manifestDataFromDar :: Archive -> Manifest -> ManifestData\n manifestDataFromDar archive manifest = ManifestData manifestDalfByte dependencyDalfBytes\n     where\n         manifestDalfByte = head [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && eRelativePath e  == mainDalf manifest]\n-        dependencyDalfBytes = [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && DL.elem (cleanString (eRelativePath e))  (dalfs manifest)]\n+        dependencyDalfBytes = [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && DL.elem (DE.trim (eRelativePath e))  (dalfs manifest)]\n \n manifestFromDar :: Archive -> ManifestData\n manifestFromDar dar =  manifestDataFromDar dar manifest\n-    where \n+    where\n         manifestEntry = head [fromEntry e | e <- zEntries dar, \".MF\" `isExtensionOf` eRelativePath e]\n-        lines = BSL.split (charToWord8 '\\n') manifestEntry\n-        linesStr = map (CH.unpack . BSL.toStrict) lines\n-        manifest = manifestMapToManifest $ DHM.fromList $ map lineToKeyValue (filter (\\a -> a /= \"\" ) linesStr)\n+        linesStr = map BS.unpack (BS.lines $ BSL.toStrict manifestEntry)\n+        manifest = manifestMapToManifest $ Map.fromList $ map lineToKeyValue (filter (\\a -> a /= \"\" ) linesStr)\n \n \n-execVisual :: FilePath -> IO ()\n-execVisual darFilePath = do\n+execVisual :: FilePath -> Maybe FilePath -> IO ()\n+execVisual darFilePath dotFilePath = do\n     darBytes <- B.readFile darFilePath\n     let manifestData = manifestFromDar $ ZIPArchive.toArchive (BSL.fromStrict darBytes)\n     (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive (BSL.toStrict (mainDalfContent manifestData) )\n     let modules = NM.toList $ LF.packageModules lfPkg\n         world = darToWorld manifestData lfPkg\n         res = concatMap (moduleAndTemplates world) modules\n-        actionEdges = map templatePairs res        \n-    putStrLn $ showDot $ do \n-        netlistGraph' srcLabel actionsForTemplate actionEdges\n+        actionEdges = map templatePairs res\n+        dotString = showDot $ do netlistGraph' srcLabel actionsForTemplate actionEdges"
  },
  {
    "id" : "24d37cfa-269c-400d-809d-342cc9360b06",
    "prId" : 1609,
    "comments" : [
      {
        "id" : "0c86aff5-9b1c-41e2-829b-4ad24216f251",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "There's no need to import `Data.List` when you import `Data.List.Extra` since the latter re-exports the former.",
        "createdAt" : "2019-06-12T17:23:15Z",
        "updatedAt" : "2019-06-12T17:32:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "19ef7938-2a7a-4fc0-bd0a-b78a381e47c7",
        "parentId" : "0c86aff5-9b1c-41e2-829b-4ad24216f251",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "I am surprised that Hlint did catch that. ",
        "createdAt" : "2019-06-12T17:33:04Z",
        "updatedAt" : "2019-06-12T17:33:04Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c3ada866-9a5a-4387-b071-327dbc4342f2",
        "parentId" : "0c86aff5-9b1c-41e2-829b-4ad24216f251",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "https://github.com/ndmitchell/hlint/issues/672",
        "createdAt" : "2019-06-12T17:57:59Z",
        "updatedAt" : "2019-06-12T17:57:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4bab041ab2d677006dac805424bd338721c71cb4",
    "line" : null,
    "diffHunk" : "@@ -22,21 +22,18 @@ import qualified Data.ByteString as B\n import Codec.Archive.Zip\n import System.FilePath\n import qualified Data.Map as M\n-import Data.Word\n-import qualified Data.HashMap.Strict as DHM\n-import qualified Data.ByteString.Char8 as CH\n+import qualified Data.HashMap.Strict as Map\n+import qualified Data.ByteString.Char8 as BS\n import qualified Data.List.Split as DLS\n-import qualified Data.List as DL\n-import qualified Data.Text as T\n+import Data.List"
  },
  {
    "id" : "f254792b-97a5-42ec-9a23-982f4107e6c8",
    "prId" : 1589,
    "comments" : [
      {
        "id" : "0b823959-cdd0-44a3-8c0e-5c88bc480624",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Usually imported as BS",
        "createdAt" : "2019-06-11T22:25:56Z",
        "updatedAt" : "2019-06-11T22:31:06Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "082c68d7a67a3de59912b2908dd799b28708c7af",
    "line" : 13,
    "diffHunk" : "@@ -16,12 +16,21 @@ import qualified Data.NameMap as NM\n import qualified Data.Set as Set\n import qualified DA.Pretty as DAP\n import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Codec.Archive.Zip as ZIPArchive\n import qualified Data.ByteString.Lazy as BSL\n import Text.Dot\n import qualified Data.ByteString as B\n import Codec.Archive.Zip\n import System.FilePath\n import qualified Data.Map as M\n+import Data.Word\n+import qualified Data.HashMap.Strict as DHM\n+import qualified Data.ByteString.Char8 as CH"
  },
  {
    "id" : "822efd20-82b4-4932-ba98-920e4b2f79fe",
    "prId" : 1589,
    "comments" : [
      {
        "id" : "316022b7-af1f-491a-9d3a-90eb98e2643f",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Usually imported as Map or HMS",
        "createdAt" : "2019-06-11T22:26:15Z",
        "updatedAt" : "2019-06-11T22:31:06Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "082c68d7a67a3de59912b2908dd799b28708c7af",
    "line" : 12,
    "diffHunk" : "@@ -16,12 +16,21 @@ import qualified Data.NameMap as NM\n import qualified Data.Set as Set\n import qualified DA.Pretty as DAP\n import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Codec.Archive.Zip as ZIPArchive\n import qualified Data.ByteString.Lazy as BSL\n import Text.Dot\n import qualified Data.ByteString as B\n import Codec.Archive.Zip\n import System.FilePath\n import qualified Data.Map as M\n+import Data.Word\n+import qualified Data.HashMap.Strict as DHM"
  },
  {
    "id" : "d4c263b9-a887-4b19-95f6-220cef3469a9",
    "prId" : 1589,
    "comments" : [
      {
        "id" : "03a35d62-5cd6-4bd4-85d8-933173390247",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Why not versionDev? I don't want another place to change on each upgrade",
        "createdAt" : "2019-06-11T22:27:04Z",
        "updatedAt" : "2019-06-11T22:31:06Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9dc083c9-be89-4326-ad64-8ee130c580bf",
        "parentId" : "03a35d62-5cd6-4bd4-85d8-933173390247",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The version parameter should have never been there in the first place https://github.com/digital-asset/daml/pull/1601 will remove it.",
        "createdAt" : "2019-06-12T11:11:36Z",
        "updatedAt" : "2019-06-12T11:11:36Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "082c68d7a67a3de59912b2908dd799b28708c7af",
    "line" : 41,
    "diffHunk" : "@@ -82,20 +91,17 @@ moduleAndTemplates world mod = retTypess\n         templates = NM.toList $ LF.moduleTemplates mod\n         retTypess = map (\\t-> (LF.tplTypeCon t, templatePossibleUpdates world t )) templates\n \n-dalfsInDar :: Archive -> [BSL.ByteString]\n-dalfsInDar dar = [fromEntry e | e <- zEntries dar, \".dalf\" `isExtensionOf` eRelativePath e]\n \n dalfBytesToPakage :: BSL.ByteString -> (LF.PackageId, LF.Package)\n dalfBytesToPakage bytes = case Archive.decodeArchive $ BSL.toStrict bytes of\n     Right a -> a\n     Left err -> error (show err)\n \n-darToWorld :: FilePath -> LF.Package -> IO LF.World\n-darToWorld darFilePath pkg = do\n-    bytes <- B.readFile darFilePath\n-    let dalfs = dalfsInDar (toArchive $ BSL.fromStrict bytes)\n-        pkgs = map dalfBytesToPakage dalfs\n-    return (AST.initWorldSelf pkgs version1_4 pkg) \n+darToWorld :: ManifestData -> LF.Package -> LF.World\n+darToWorld manifest pkg = AST.initWorldSelf pkgs version1_4 pkg"
  },
  {
    "id" : "e18a172e-a92a-4c26-9480-e5545988be41",
    "prId" : 1589,
    "comments" : [
      {
        "id" : "d17286db-281f-4b69-a09d-27fcf4e96c3d",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Just use extra library splitOn",
        "createdAt" : "2019-06-11T22:27:54Z",
        "updatedAt" : "2019-06-11T22:31:06Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "082c68d7a67a3de59912b2908dd799b28708c7af",
    "line" : 78,
    "diffHunk" : "@@ -143,14 +147,52 @@ netlistGraph' attrFn outFn assocs = do\n \n \n \n-execVisual :: FilePath -> FilePath -> IO ()\n-execVisual darFilePath dalfFile = do\n-    bytes <- B.readFile dalfFile\n-    (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive bytes \n-    world <- darToWorld darFilePath lfPkg\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)\n+\n+charToWord8 :: Char -> Word8\n+charToWord8 = toEnum . fromEnum\n+\n+cleanString :: String -> String\n+cleanString str = T.unpack (T.strip $ T.pack str)\n+\n+lineToKeyValue :: String -> (String, String)\n+lineToKeyValue line = case DLS.splitOn \":\" line of"
  },
  {
    "id" : "6ca74852-65f7-47bc-998f-0a900c6ff225",
    "prId" : 1589,
    "comments" : [
      {
        "id" : "618cb8ca-85e9-443e-9ffe-0152eb004c69",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "THis is just trim in the extra library. ",
        "createdAt" : "2019-06-11T22:28:35Z",
        "updatedAt" : "2019-06-11T22:31:06Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "082c68d7a67a3de59912b2908dd799b28708c7af",
    "line" : 75,
    "diffHunk" : "@@ -143,14 +147,52 @@ netlistGraph' attrFn outFn assocs = do\n \n \n \n-execVisual :: FilePath -> FilePath -> IO ()\n-execVisual darFilePath dalfFile = do\n-    bytes <- B.readFile dalfFile\n-    (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive bytes \n-    world <- darToWorld darFilePath lfPkg\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)\n+\n+charToWord8 :: Char -> Word8\n+charToWord8 = toEnum . fromEnum\n+\n+cleanString :: String -> String\n+cleanString str = T.unpack (T.strip $ T.pack str)"
  },
  {
    "id" : "f799e8fd-bf5f-428d-bfd6-b5cf8804dd3e",
    "prId" : 1589,
    "comments" : [
      {
        "id" : "9e52714c-0fe7-4409-a3a9-b901a1054a06",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Set your editor to remove trailing white space on save. ",
        "createdAt" : "2019-06-11T22:29:25Z",
        "updatedAt" : "2019-06-11T22:31:06Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e538ff25-e9c8-4ce7-8afa-1e341011858e",
        "parentId" : "9e52714c-0fe7-4409-a3a9-b901a1054a06",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Yes, please.",
        "createdAt" : "2019-06-12T11:08:34Z",
        "updatedAt" : "2019-06-12T11:08:34Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2e47642f-ed1d-44b2-8942-1706afa49b17",
        "parentId" : "9e52714c-0fe7-4409-a3a9-b901a1054a06",
        "author" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "body" : "Sorry, Will do",
        "createdAt" : "2019-06-12T14:12:20Z",
        "updatedAt" : "2019-06-12T14:12:20Z",
        "lastEditedBy" : {
          "login" : "akalburgi",
          "name" : "Anup Kalburgi",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/42743833?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "082c68d7a67a3de59912b2908dd799b28708c7af",
    "line" : 114,
    "diffHunk" : "@@ -143,14 +147,52 @@ netlistGraph' attrFn outFn assocs = do\n \n \n \n-execVisual :: FilePath -> FilePath -> IO ()\n-execVisual darFilePath dalfFile = do\n-    bytes <- B.readFile dalfFile\n-    (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive bytes \n-    world <- darToWorld darFilePath lfPkg\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)\n+\n+charToWord8 :: Char -> Word8\n+charToWord8 = toEnum . fromEnum\n+\n+cleanString :: String -> String\n+cleanString str = T.unpack (T.strip $ T.pack str)\n+\n+lineToKeyValue :: String -> (String, String)\n+lineToKeyValue line = case DLS.splitOn \":\" line of\n+    [l, r] -> (cleanString l , cleanString r)\n+    _ -> (\"malformed\", \"malformed\")            \n+\n+\n+manifestMapToManifest :: DHM.HashMap String String -> Manifest\n+manifestMapToManifest hash = Manifest mainDalf dependDalfs\n+    where\n+        mainDalf = DHM.lookupDefault \"unknown\" \"Main-Dalf\" hash\n+        dependDalfs = map cleanString $ DL.delete mainDalf (DLS.splitOn \",\" (DHM.lookupDefault \"unknown\" \"Dalfs\" hash))\n+\n+\n+manifestDataFromDar :: Archive -> Manifest -> ManifestData\n+manifestDataFromDar archive manifest = ManifestData manifestDalfByte dependencyDalfBytes\n+    where\n+        manifestDalfByte = head [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && eRelativePath e  == mainDalf manifest]\n+        dependencyDalfBytes = [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && DL.elem (cleanString (eRelativePath e))  (dalfs manifest)]\n+\n+manifestFromDar :: Archive -> ManifestData\n+manifestFromDar dar =  manifestDataFromDar dar manifest\n+    where \n+        manifestEntry = head [fromEntry e | e <- zEntries dar, \".MF\" `isExtensionOf` eRelativePath e]\n+        lines = BSL.split (charToWord8 '\\n') manifestEntry\n+        linesStr = map (CH.unpack . BSL.toStrict) lines\n+        manifest = manifestMapToManifest $ DHM.fromList $ map lineToKeyValue (filter (\\a -> a /= \"\" ) linesStr)\n+\n+\n+execVisual :: FilePath -> IO ()\n+execVisual darFilePath = do\n+    darBytes <- B.readFile darFilePath\n+    let manifestData = manifestFromDar $ ZIPArchive.toArchive (BSL.fromStrict darBytes)\n+    (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive (BSL.toStrict (mainDalfContent manifestData) )\n     let modules = NM.toList $ LF.packageModules lfPkg\n+        world = darToWorld manifestData lfPkg\n         res = concatMap (moduleAndTemplates world) modules\n-        actionEdges = map templatePairs res\n+        actionEdges = map templatePairs res        "
  },
  {
    "id" : "ca1705a2-8ab1-4593-a429-1f474ffff785",
    "prId" : 1589,
    "comments" : [
      {
        "id" : "f7002eec-2b16-4879-b9f0-5558d28fe37d",
        "parentId" : null,
        "author" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "body" : "Use Data.ByteString.Char8 to avoid having to convert at all. Also use the ByteString lines function. ",
        "createdAt" : "2019-06-11T22:30:54Z",
        "updatedAt" : "2019-06-11T22:31:06Z",
        "lastEditedBy" : {
          "login" : "ndmitchell",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1651197?u=2a7f401a0bc6c1e722d5fbecc923715861c4567c&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "082c68d7a67a3de59912b2908dd799b28708c7af",
    "line" : 102,
    "diffHunk" : "@@ -143,14 +147,52 @@ netlistGraph' attrFn outFn assocs = do\n \n \n \n-execVisual :: FilePath -> FilePath -> IO ()\n-execVisual darFilePath dalfFile = do\n-    bytes <- B.readFile dalfFile\n-    (_, lfPkg) <- errorOnLeft \"Cannot decode package\" $ Archive.decodeArchive bytes \n-    world <- darToWorld darFilePath lfPkg\n+data Manifest = Manifest { mainDalf :: FilePath , dalfs :: [FilePath] } deriving (Show)\n+data ManifestData = ManifestData { mainDalfContent :: BSL.ByteString , dalfsCotent :: [BSL.ByteString] } deriving (Show)\n+\n+charToWord8 :: Char -> Word8\n+charToWord8 = toEnum . fromEnum\n+\n+cleanString :: String -> String\n+cleanString str = T.unpack (T.strip $ T.pack str)\n+\n+lineToKeyValue :: String -> (String, String)\n+lineToKeyValue line = case DLS.splitOn \":\" line of\n+    [l, r] -> (cleanString l , cleanString r)\n+    _ -> (\"malformed\", \"malformed\")            \n+\n+\n+manifestMapToManifest :: DHM.HashMap String String -> Manifest\n+manifestMapToManifest hash = Manifest mainDalf dependDalfs\n+    where\n+        mainDalf = DHM.lookupDefault \"unknown\" \"Main-Dalf\" hash\n+        dependDalfs = map cleanString $ DL.delete mainDalf (DLS.splitOn \",\" (DHM.lookupDefault \"unknown\" \"Dalfs\" hash))\n+\n+\n+manifestDataFromDar :: Archive -> Manifest -> ManifestData\n+manifestDataFromDar archive manifest = ManifestData manifestDalfByte dependencyDalfBytes\n+    where\n+        manifestDalfByte = head [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && eRelativePath e  == mainDalf manifest]\n+        dependencyDalfBytes = [fromEntry e | e <- zEntries archive, \".dalf\" `isExtensionOf` eRelativePath e  && DL.elem (cleanString (eRelativePath e))  (dalfs manifest)]\n+\n+manifestFromDar :: Archive -> ManifestData\n+manifestFromDar dar =  manifestDataFromDar dar manifest\n+    where \n+        manifestEntry = head [fromEntry e | e <- zEntries dar, \".MF\" `isExtensionOf` eRelativePath e]\n+        lines = BSL.split (charToWord8 '\\n') manifestEntry\n+        linesStr = map (CH.unpack . BSL.toStrict) lines\n+        manifest = manifestMapToManifest $ DHM.fromList $ map lineToKeyValue (filter (\\a -> a /= \"\" ) linesStr)"
  },
  {
    "id" : "83c499a5-2d15-4a1d-a38c-e35ec85a87b6",
    "prId" : 1552,
    "comments" : [
      {
        "id" : "b2670a5f-ad83-4ef9-9d04-53a6f1129f9c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We should remove this function and inline it on all call sites.",
        "createdAt" : "2019-06-07T14:58:19Z",
        "updatedAt" : "2019-06-07T21:57:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3ec3bf9852acf408563efda9362b6ebf167c3b86",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,158 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+{-# LANGUAGE OverloadedStrings   #-}\n+{-# LANGUAGE ApplicativeDo       #-}\n+\n+-- | Main entry-point of the DAML compiler\n+module DA.Cli.Visual\n+  ( execVisual\n+  ) where\n+\n+\n+import qualified DA.Daml.LF.Ast as LF\n+import DA.Daml.LF.Ast.World as AST \n+import DA.Daml.LF.Ast.Version\n+import qualified Data.NameMap as NM\n+-- import Debug.Trace\n+import qualified Data.Set as Set\n+import qualified DA.Pretty as DAP\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import Text.Dot\n+import qualified Data.ByteString as B\n+import Control.Monad.Except\n+import Codec.Archive.Zip\n+import System.FilePath\n+\n+\n+\n+data Action = ACreate (LF.Qualified LF.TypeConName) \n+            | AExercise (LF.Qualified LF.TypeConName) LF.ChoiceName deriving (Eq, Ord, Show )\n+\n+\n+startFromUpdate :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World -> LF.Update -> Set.Set Action\n+startFromUpdate seen world update = case update of \n+    LF.UPure _ e -> startFromExpr seen world e\n+    LF.UBind (LF.Binding _ e1) e2 -> startFromExpr seen world e1 `Set.union` startFromExpr seen world e2\n+    LF.UCreate tpl e -> Set.singleton (ACreate tpl) `Set.union` startFromExpr seen world e\n+    LF.UExercise tpl chc e1 e2 e3 -> Set.singleton (AExercise tpl chc) `Set.union` startFromExpr seen world e1 `Set.union` maybe Set.empty (startFromExpr seen world) e2 `Set.union` startFromExpr seen world e3\n+    LF.UFetch _ ctIdEx -> startFromExpr seen world ctIdEx\n+    LF.UGetTime -> Set.empty\n+    LF.UEmbedExpr _ upEx -> startFromExpr seen world upEx\n+    LF.ULookupByKey _ -> Set.empty\n+    LF.UFetchByKey _ -> Set.empty\n+\n+startFromExpr :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World  -> LF.Expr -> Set.Set Action\n+startFromExpr seen world e = case e of\n+    LF.EVar _ -> Set.empty\n+    LF.EVal ref->  case LF.lookupValue ref world of \n+        Right LF.DefValue{..}  \n+            | ref `Set.member` seen  -> Set.empty\n+            | otherwise -> startFromExpr (Set.insert ref seen)  world dvalBody\n+        Left _ -> error \"This should not happen\"\n+    LF.EBuiltin _ -> Set.empty\n+    LF.ERecCon _ flds -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) flds\n+    LF.ERecProj _ _ recEx -> startFromExpr seen world recEx\n+    LF.ETupleUpd _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.EVariantCon _ _ varg -> startFromExpr seen world varg\n+    LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n+    LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n+    LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.ETmApp tmExpr tmpArg -> startFromExpr seen world tmExpr `Set.union` startFromExpr seen world tmpArg\n+    LF.ETyApp tAppExpr _ -> startFromExpr seen world tAppExpr\n+    LF.ETmLam _ tmlB -> startFromExpr seen world tmlB\n+    LF.ETyLam _ lambdy -> startFromExpr seen world lambdy\n+    LF.ECase cas casel -> startFromExpr seen world cas `Set.union` Set.unions ( map ( startFromExpr seen world . LF.altExpr ) casel)\n+    LF.ELet (LF.Binding _ e1) e2 -> startFromExpr seen  world e1 `Set.union` startFromExpr seen world e2\n+    LF.ENil _ -> Set.empty\n+    LF.ECons _ consH consT -> startFromExpr seen world consH `Set.union` startFromExpr seen world consT\n+    LF.ESome _ smBdy -> startFromExpr seen world smBdy\n+    LF.ENone _ -> Set.empty\n+    LF.EUpdate upd -> startFromUpdate seen world upd\n+    LF.EScenario _ -> Set.empty\n+    LF.ELocation _ e1 -> startFromExpr seen world e1\n+    -- x -> Set.unions $ map startFromExpr $ children x\n+\n+startFromChoice :: LF.World -> LF.TemplateChoice -> Set.Set Action\n+startFromChoice world chc = startFromExpr Set.empty world (LF.chcUpdate chc)\n+\n+templatePossibleUpdates :: LF.World -> LF.Template -> Set.Set Action\n+templatePossibleUpdates world tpl = Set.unions $ map (startFromChoice world) (NM.toList (LF.tplChoices tpl))\n+\n+moduleAndTemplates :: LF.World -> LF.Module -> [(LF.TypeConName, Set.Set Action)]\n+moduleAndTemplates world mod = retTypess\n+    where \n+        templates = templatesFromModule mod\n+        retTypess = map (\\t-> (LF.tplTypeCon t, templatePossibleUpdates world t )) templates\n+\n+listOfModules :: NM.NameMap LF.Module -> [LF.Module]"
  },
  {
    "id" : "fef0e21a-185a-4131-99d4-9c8296313bf2",
    "prId" : 1552,
    "comments" : [
      {
        "id" : "47dfd949-a7e0-4524-8fc3-9f0a128ff970",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm not convinced this needs its own function.",
        "createdAt" : "2019-06-07T14:58:47Z",
        "updatedAt" : "2019-06-07T21:57:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3ec3bf9852acf408563efda9362b6ebf167c3b86",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,158 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+{-# LANGUAGE OverloadedStrings   #-}\n+{-# LANGUAGE ApplicativeDo       #-}\n+\n+-- | Main entry-point of the DAML compiler\n+module DA.Cli.Visual\n+  ( execVisual\n+  ) where\n+\n+\n+import qualified DA.Daml.LF.Ast as LF\n+import DA.Daml.LF.Ast.World as AST \n+import DA.Daml.LF.Ast.Version\n+import qualified Data.NameMap as NM\n+-- import Debug.Trace\n+import qualified Data.Set as Set\n+import qualified DA.Pretty as DAP\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import Text.Dot\n+import qualified Data.ByteString as B\n+import Control.Monad.Except\n+import Codec.Archive.Zip\n+import System.FilePath\n+\n+\n+\n+data Action = ACreate (LF.Qualified LF.TypeConName) \n+            | AExercise (LF.Qualified LF.TypeConName) LF.ChoiceName deriving (Eq, Ord, Show )\n+\n+\n+startFromUpdate :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World -> LF.Update -> Set.Set Action\n+startFromUpdate seen world update = case update of \n+    LF.UPure _ e -> startFromExpr seen world e\n+    LF.UBind (LF.Binding _ e1) e2 -> startFromExpr seen world e1 `Set.union` startFromExpr seen world e2\n+    LF.UCreate tpl e -> Set.singleton (ACreate tpl) `Set.union` startFromExpr seen world e\n+    LF.UExercise tpl chc e1 e2 e3 -> Set.singleton (AExercise tpl chc) `Set.union` startFromExpr seen world e1 `Set.union` maybe Set.empty (startFromExpr seen world) e2 `Set.union` startFromExpr seen world e3\n+    LF.UFetch _ ctIdEx -> startFromExpr seen world ctIdEx\n+    LF.UGetTime -> Set.empty\n+    LF.UEmbedExpr _ upEx -> startFromExpr seen world upEx\n+    LF.ULookupByKey _ -> Set.empty\n+    LF.UFetchByKey _ -> Set.empty\n+\n+startFromExpr :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World  -> LF.Expr -> Set.Set Action\n+startFromExpr seen world e = case e of\n+    LF.EVar _ -> Set.empty\n+    LF.EVal ref->  case LF.lookupValue ref world of \n+        Right LF.DefValue{..}  \n+            | ref `Set.member` seen  -> Set.empty\n+            | otherwise -> startFromExpr (Set.insert ref seen)  world dvalBody\n+        Left _ -> error \"This should not happen\"\n+    LF.EBuiltin _ -> Set.empty\n+    LF.ERecCon _ flds -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) flds\n+    LF.ERecProj _ _ recEx -> startFromExpr seen world recEx\n+    LF.ETupleUpd _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.EVariantCon _ _ varg -> startFromExpr seen world varg\n+    LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n+    LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n+    LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.ETmApp tmExpr tmpArg -> startFromExpr seen world tmExpr `Set.union` startFromExpr seen world tmpArg\n+    LF.ETyApp tAppExpr _ -> startFromExpr seen world tAppExpr\n+    LF.ETmLam _ tmlB -> startFromExpr seen world tmlB\n+    LF.ETyLam _ lambdy -> startFromExpr seen world lambdy\n+    LF.ECase cas casel -> startFromExpr seen world cas `Set.union` Set.unions ( map ( startFromExpr seen world . LF.altExpr ) casel)\n+    LF.ELet (LF.Binding _ e1) e2 -> startFromExpr seen  world e1 `Set.union` startFromExpr seen world e2\n+    LF.ENil _ -> Set.empty\n+    LF.ECons _ consH consT -> startFromExpr seen world consH `Set.union` startFromExpr seen world consT\n+    LF.ESome _ smBdy -> startFromExpr seen world smBdy\n+    LF.ENone _ -> Set.empty\n+    LF.EUpdate upd -> startFromUpdate seen world upd\n+    LF.EScenario _ -> Set.empty\n+    LF.ELocation _ e1 -> startFromExpr seen world e1\n+    -- x -> Set.unions $ map startFromExpr $ children x\n+\n+startFromChoice :: LF.World -> LF.TemplateChoice -> Set.Set Action\n+startFromChoice world chc = startFromExpr Set.empty world (LF.chcUpdate chc)\n+\n+templatePossibleUpdates :: LF.World -> LF.Template -> Set.Set Action\n+templatePossibleUpdates world tpl = Set.unions $ map (startFromChoice world) (NM.toList (LF.tplChoices tpl))\n+\n+moduleAndTemplates :: LF.World -> LF.Module -> [(LF.TypeConName, Set.Set Action)]\n+moduleAndTemplates world mod = retTypess\n+    where \n+        templates = templatesFromModule mod\n+        retTypess = map (\\t-> (LF.tplTypeCon t, templatePossibleUpdates world t )) templates\n+\n+listOfModules :: NM.NameMap LF.Module -> [LF.Module]\n+listOfModules modules = NM.toList modules\n+\n+templatesFromModule :: LF.Module -> [LF.Template]"
  },
  {
    "id" : "df6c756b-c631-4db4-b41c-1d742be3f027",
    "prId" : 1552,
    "comments" : [
      {
        "id" : "0f997248-1689-4b76-b241-1c3ec0999450",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Why not make this an instance of the `Pretty` class?",
        "createdAt" : "2019-06-07T14:59:43Z",
        "updatedAt" : "2019-06-07T21:57:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ec3bf9852acf408563efda9362b6ebf167c3b86",
    "line" : 103,
    "diffHunk" : "@@ -0,0 +1,158 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+{-# LANGUAGE OverloadedStrings   #-}\n+{-# LANGUAGE ApplicativeDo       #-}\n+\n+-- | Main entry-point of the DAML compiler\n+module DA.Cli.Visual\n+  ( execVisual\n+  ) where\n+\n+\n+import qualified DA.Daml.LF.Ast as LF\n+import DA.Daml.LF.Ast.World as AST \n+import DA.Daml.LF.Ast.Version\n+import qualified Data.NameMap as NM\n+-- import Debug.Trace\n+import qualified Data.Set as Set\n+import qualified DA.Pretty as DAP\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import Text.Dot\n+import qualified Data.ByteString as B\n+import Control.Monad.Except\n+import Codec.Archive.Zip\n+import System.FilePath\n+\n+\n+\n+data Action = ACreate (LF.Qualified LF.TypeConName) \n+            | AExercise (LF.Qualified LF.TypeConName) LF.ChoiceName deriving (Eq, Ord, Show )\n+\n+\n+startFromUpdate :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World -> LF.Update -> Set.Set Action\n+startFromUpdate seen world update = case update of \n+    LF.UPure _ e -> startFromExpr seen world e\n+    LF.UBind (LF.Binding _ e1) e2 -> startFromExpr seen world e1 `Set.union` startFromExpr seen world e2\n+    LF.UCreate tpl e -> Set.singleton (ACreate tpl) `Set.union` startFromExpr seen world e\n+    LF.UExercise tpl chc e1 e2 e3 -> Set.singleton (AExercise tpl chc) `Set.union` startFromExpr seen world e1 `Set.union` maybe Set.empty (startFromExpr seen world) e2 `Set.union` startFromExpr seen world e3\n+    LF.UFetch _ ctIdEx -> startFromExpr seen world ctIdEx\n+    LF.UGetTime -> Set.empty\n+    LF.UEmbedExpr _ upEx -> startFromExpr seen world upEx\n+    LF.ULookupByKey _ -> Set.empty\n+    LF.UFetchByKey _ -> Set.empty\n+\n+startFromExpr :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World  -> LF.Expr -> Set.Set Action\n+startFromExpr seen world e = case e of\n+    LF.EVar _ -> Set.empty\n+    LF.EVal ref->  case LF.lookupValue ref world of \n+        Right LF.DefValue{..}  \n+            | ref `Set.member` seen  -> Set.empty\n+            | otherwise -> startFromExpr (Set.insert ref seen)  world dvalBody\n+        Left _ -> error \"This should not happen\"\n+    LF.EBuiltin _ -> Set.empty\n+    LF.ERecCon _ flds -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) flds\n+    LF.ERecProj _ _ recEx -> startFromExpr seen world recEx\n+    LF.ETupleUpd _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.EVariantCon _ _ varg -> startFromExpr seen world varg\n+    LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n+    LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n+    LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.ETmApp tmExpr tmpArg -> startFromExpr seen world tmExpr `Set.union` startFromExpr seen world tmpArg\n+    LF.ETyApp tAppExpr _ -> startFromExpr seen world tAppExpr\n+    LF.ETmLam _ tmlB -> startFromExpr seen world tmlB\n+    LF.ETyLam _ lambdy -> startFromExpr seen world lambdy\n+    LF.ECase cas casel -> startFromExpr seen world cas `Set.union` Set.unions ( map ( startFromExpr seen world . LF.altExpr ) casel)\n+    LF.ELet (LF.Binding _ e1) e2 -> startFromExpr seen  world e1 `Set.union` startFromExpr seen world e2\n+    LF.ENil _ -> Set.empty\n+    LF.ECons _ consH consT -> startFromExpr seen world consH `Set.union` startFromExpr seen world consT\n+    LF.ESome _ smBdy -> startFromExpr seen world smBdy\n+    LF.ENone _ -> Set.empty\n+    LF.EUpdate upd -> startFromUpdate seen world upd\n+    LF.EScenario _ -> Set.empty\n+    LF.ELocation _ e1 -> startFromExpr seen world e1\n+    -- x -> Set.unions $ map startFromExpr $ children x\n+\n+startFromChoice :: LF.World -> LF.TemplateChoice -> Set.Set Action\n+startFromChoice world chc = startFromExpr Set.empty world (LF.chcUpdate chc)\n+\n+templatePossibleUpdates :: LF.World -> LF.Template -> Set.Set Action\n+templatePossibleUpdates world tpl = Set.unions $ map (startFromChoice world) (NM.toList (LF.tplChoices tpl))\n+\n+moduleAndTemplates :: LF.World -> LF.Module -> [(LF.TypeConName, Set.Set Action)]\n+moduleAndTemplates world mod = retTypess\n+    where \n+        templates = templatesFromModule mod\n+        retTypess = map (\\t-> (LF.tplTypeCon t, templatePossibleUpdates world t )) templates\n+\n+listOfModules :: NM.NameMap LF.Module -> [LF.Module]\n+listOfModules modules = NM.toList modules\n+\n+templatesFromModule :: LF.Module -> [LF.Template]\n+templatesFromModule mod = NM.toList $ LF.moduleTemplates mod\n+\n+dalfsInDar :: Archive -> [BSL.ByteString]\n+dalfsInDar dar = [fromEntry e | e <- zEntries dar, \".dalf\" `isExtensionOf` eRelativePath e]\n+\n+dalfBytesToPakage :: BSL.ByteString -> (LF.PackageId, LF.Package)\n+dalfBytesToPakage bytes = case Archive.decodeArchive $ BSL.toStrict bytes of\n+    Right a -> a\n+    Left err -> error (show err)\n+\n+dalfsToWorld :: [BSL.ByteString] -> LF.Package -> LF.World\n+dalfsToWorld dalfs pkg = AST.initWorldSelf pkgs version1_4 pkg\n+    where \n+        pkgs = map dalfBytesToPakage dalfs\n+\n+darToWorld :: FilePath -> LF.Package -> IO LF.World\n+darToWorld darFilePath pkg = do\n+    bytes <- B.readFile darFilePath\n+    let dalfs = dalfsInDar (toArchive $ BSL.fromStrict bytes)\n+    return (dalfsToWorld dalfs pkg )\n+\n+prettyAction :: Action -> String"
  },
  {
    "id" : "d5b8de1a-5094-463c-af4c-a27d2004b898",
    "prId" : 1552,
    "comments" : [
      {
        "id" : "2ce05ddb-ae76-4278-9187-88d3d65babb1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "If we only call this function once, we should inline it at its call site.",
        "createdAt" : "2019-06-07T15:00:32Z",
        "updatedAt" : "2019-06-07T21:57:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3ec3bf9852acf408563efda9362b6ebf167c3b86",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,158 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+{-# LANGUAGE OverloadedStrings   #-}\n+{-# LANGUAGE ApplicativeDo       #-}\n+\n+-- | Main entry-point of the DAML compiler\n+module DA.Cli.Visual\n+  ( execVisual\n+  ) where\n+\n+\n+import qualified DA.Daml.LF.Ast as LF\n+import DA.Daml.LF.Ast.World as AST \n+import DA.Daml.LF.Ast.Version\n+import qualified Data.NameMap as NM\n+-- import Debug.Trace\n+import qualified Data.Set as Set\n+import qualified DA.Pretty as DAP\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import Text.Dot\n+import qualified Data.ByteString as B\n+import Control.Monad.Except\n+import Codec.Archive.Zip\n+import System.FilePath\n+\n+\n+\n+data Action = ACreate (LF.Qualified LF.TypeConName) \n+            | AExercise (LF.Qualified LF.TypeConName) LF.ChoiceName deriving (Eq, Ord, Show )\n+\n+\n+startFromUpdate :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World -> LF.Update -> Set.Set Action\n+startFromUpdate seen world update = case update of \n+    LF.UPure _ e -> startFromExpr seen world e\n+    LF.UBind (LF.Binding _ e1) e2 -> startFromExpr seen world e1 `Set.union` startFromExpr seen world e2\n+    LF.UCreate tpl e -> Set.singleton (ACreate tpl) `Set.union` startFromExpr seen world e\n+    LF.UExercise tpl chc e1 e2 e3 -> Set.singleton (AExercise tpl chc) `Set.union` startFromExpr seen world e1 `Set.union` maybe Set.empty (startFromExpr seen world) e2 `Set.union` startFromExpr seen world e3\n+    LF.UFetch _ ctIdEx -> startFromExpr seen world ctIdEx\n+    LF.UGetTime -> Set.empty\n+    LF.UEmbedExpr _ upEx -> startFromExpr seen world upEx\n+    LF.ULookupByKey _ -> Set.empty\n+    LF.UFetchByKey _ -> Set.empty\n+\n+startFromExpr :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World  -> LF.Expr -> Set.Set Action\n+startFromExpr seen world e = case e of\n+    LF.EVar _ -> Set.empty\n+    LF.EVal ref->  case LF.lookupValue ref world of \n+        Right LF.DefValue{..}  \n+            | ref `Set.member` seen  -> Set.empty\n+            | otherwise -> startFromExpr (Set.insert ref seen)  world dvalBody\n+        Left _ -> error \"This should not happen\"\n+    LF.EBuiltin _ -> Set.empty\n+    LF.ERecCon _ flds -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) flds\n+    LF.ERecProj _ _ recEx -> startFromExpr seen world recEx\n+    LF.ETupleUpd _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.EVariantCon _ _ varg -> startFromExpr seen world varg\n+    LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n+    LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n+    LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.ETmApp tmExpr tmpArg -> startFromExpr seen world tmExpr `Set.union` startFromExpr seen world tmpArg\n+    LF.ETyApp tAppExpr _ -> startFromExpr seen world tAppExpr\n+    LF.ETmLam _ tmlB -> startFromExpr seen world tmlB\n+    LF.ETyLam _ lambdy -> startFromExpr seen world lambdy\n+    LF.ECase cas casel -> startFromExpr seen world cas `Set.union` Set.unions ( map ( startFromExpr seen world . LF.altExpr ) casel)\n+    LF.ELet (LF.Binding _ e1) e2 -> startFromExpr seen  world e1 `Set.union` startFromExpr seen world e2\n+    LF.ENil _ -> Set.empty\n+    LF.ECons _ consH consT -> startFromExpr seen world consH `Set.union` startFromExpr seen world consT\n+    LF.ESome _ smBdy -> startFromExpr seen world smBdy\n+    LF.ENone _ -> Set.empty\n+    LF.EUpdate upd -> startFromUpdate seen world upd\n+    LF.EScenario _ -> Set.empty\n+    LF.ELocation _ e1 -> startFromExpr seen world e1\n+    -- x -> Set.unions $ map startFromExpr $ children x\n+\n+startFromChoice :: LF.World -> LF.TemplateChoice -> Set.Set Action\n+startFromChoice world chc = startFromExpr Set.empty world (LF.chcUpdate chc)\n+\n+templatePossibleUpdates :: LF.World -> LF.Template -> Set.Set Action\n+templatePossibleUpdates world tpl = Set.unions $ map (startFromChoice world) (NM.toList (LF.tplChoices tpl))\n+\n+moduleAndTemplates :: LF.World -> LF.Module -> [(LF.TypeConName, Set.Set Action)]\n+moduleAndTemplates world mod = retTypess\n+    where \n+        templates = templatesFromModule mod\n+        retTypess = map (\\t-> (LF.tplTypeCon t, templatePossibleUpdates world t )) templates\n+\n+listOfModules :: NM.NameMap LF.Module -> [LF.Module]\n+listOfModules modules = NM.toList modules\n+\n+templatesFromModule :: LF.Module -> [LF.Template]\n+templatesFromModule mod = NM.toList $ LF.moduleTemplates mod\n+\n+dalfsInDar :: Archive -> [BSL.ByteString]\n+dalfsInDar dar = [fromEntry e | e <- zEntries dar, \".dalf\" `isExtensionOf` eRelativePath e]\n+\n+dalfBytesToPakage :: BSL.ByteString -> (LF.PackageId, LF.Package)\n+dalfBytesToPakage bytes = case Archive.decodeArchive $ BSL.toStrict bytes of\n+    Right a -> a\n+    Left err -> error (show err)\n+\n+dalfsToWorld :: [BSL.ByteString] -> LF.Package -> LF.World"
  },
  {
    "id" : "8b87c047-f35d-4295-86b2-e817b4da54df",
    "prId" : 1552,
    "comments" : [
      {
        "id" : "ec8864ef-f547-462a-8b76-a09f98aa518f",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "These `startFromX` functions should get proper names. Maybe `actionsFromX`?",
        "createdAt" : "2019-06-07T15:01:44Z",
        "updatedAt" : "2019-06-07T21:57:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ec3bf9852acf408563efda9362b6ebf167c3b86",
    "line" : 32,
    "diffHunk" : "@@ -0,0 +1,158 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+{-# LANGUAGE OverloadedStrings   #-}\n+{-# LANGUAGE ApplicativeDo       #-}\n+\n+-- | Main entry-point of the DAML compiler\n+module DA.Cli.Visual\n+  ( execVisual\n+  ) where\n+\n+\n+import qualified DA.Daml.LF.Ast as LF\n+import DA.Daml.LF.Ast.World as AST \n+import DA.Daml.LF.Ast.Version\n+import qualified Data.NameMap as NM\n+-- import Debug.Trace\n+import qualified Data.Set as Set\n+import qualified DA.Pretty as DAP\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import Text.Dot\n+import qualified Data.ByteString as B\n+import Control.Monad.Except\n+import Codec.Archive.Zip\n+import System.FilePath\n+\n+\n+\n+data Action = ACreate (LF.Qualified LF.TypeConName) \n+            | AExercise (LF.Qualified LF.TypeConName) LF.ChoiceName deriving (Eq, Ord, Show )\n+\n+\n+startFromUpdate :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World -> LF.Update -> Set.Set Action"
  },
  {
    "id" : "61a75090-87c4-4bc8-bf1b-bf611b1780a7",
    "prId" : 1552,
    "comments" : [
      {
        "id" : "17aacb03-e0aa-4659-9ead-cfd02abb5ae8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We might have this function somewhere else already. Have you checked that?",
        "createdAt" : "2019-06-07T15:03:02Z",
        "updatedAt" : "2019-06-07T21:57:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ec3bf9852acf408563efda9362b6ebf167c3b86",
    "line" : 127,
    "diffHunk" : "@@ -0,0 +1,158 @@\n+-- Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+-- SPDX-License-Identifier: Apache-2.0\n+{-# LANGUAGE OverloadedStrings   #-}\n+{-# LANGUAGE ApplicativeDo       #-}\n+\n+-- | Main entry-point of the DAML compiler\n+module DA.Cli.Visual\n+  ( execVisual\n+  ) where\n+\n+\n+import qualified DA.Daml.LF.Ast as LF\n+import DA.Daml.LF.Ast.World as AST \n+import DA.Daml.LF.Ast.Version\n+import qualified Data.NameMap as NM\n+-- import Debug.Trace\n+import qualified Data.Set as Set\n+import qualified DA.Pretty as DAP\n+import qualified DA.Daml.LF.Proto3.Archive as Archive\n+import qualified Data.ByteString.Lazy as BSL\n+import Text.Dot\n+import qualified Data.ByteString as B\n+import Control.Monad.Except\n+import Codec.Archive.Zip\n+import System.FilePath\n+\n+\n+\n+data Action = ACreate (LF.Qualified LF.TypeConName) \n+            | AExercise (LF.Qualified LF.TypeConName) LF.ChoiceName deriving (Eq, Ord, Show )\n+\n+\n+startFromUpdate :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World -> LF.Update -> Set.Set Action\n+startFromUpdate seen world update = case update of \n+    LF.UPure _ e -> startFromExpr seen world e\n+    LF.UBind (LF.Binding _ e1) e2 -> startFromExpr seen world e1 `Set.union` startFromExpr seen world e2\n+    LF.UCreate tpl e -> Set.singleton (ACreate tpl) `Set.union` startFromExpr seen world e\n+    LF.UExercise tpl chc e1 e2 e3 -> Set.singleton (AExercise tpl chc) `Set.union` startFromExpr seen world e1 `Set.union` maybe Set.empty (startFromExpr seen world) e2 `Set.union` startFromExpr seen world e3\n+    LF.UFetch _ ctIdEx -> startFromExpr seen world ctIdEx\n+    LF.UGetTime -> Set.empty\n+    LF.UEmbedExpr _ upEx -> startFromExpr seen world upEx\n+    LF.ULookupByKey _ -> Set.empty\n+    LF.UFetchByKey _ -> Set.empty\n+\n+startFromExpr :: Set.Set (LF.Qualified LF.ExprValName) -> LF.World  -> LF.Expr -> Set.Set Action\n+startFromExpr seen world e = case e of\n+    LF.EVar _ -> Set.empty\n+    LF.EVal ref->  case LF.lookupValue ref world of \n+        Right LF.DefValue{..}  \n+            | ref `Set.member` seen  -> Set.empty\n+            | otherwise -> startFromExpr (Set.insert ref seen)  world dvalBody\n+        Left _ -> error \"This should not happen\"\n+    LF.EBuiltin _ -> Set.empty\n+    LF.ERecCon _ flds -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) flds\n+    LF.ERecProj _ _ recEx -> startFromExpr seen world recEx\n+    LF.ETupleUpd _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.EVariantCon _ _ varg -> startFromExpr seen world varg\n+    LF.ETupleCon tcon -> Set.unions $ map (\\(_, exp) -> startFromExpr seen world exp) tcon\n+    LF.ETupleProj _ tupExpr -> startFromExpr seen world tupExpr\n+    LF.ERecUpd _ _ recExpr recUpdate -> startFromExpr seen world recExpr `Set.union` startFromExpr seen world recUpdate\n+    LF.ETmApp tmExpr tmpArg -> startFromExpr seen world tmExpr `Set.union` startFromExpr seen world tmpArg\n+    LF.ETyApp tAppExpr _ -> startFromExpr seen world tAppExpr\n+    LF.ETmLam _ tmlB -> startFromExpr seen world tmlB\n+    LF.ETyLam _ lambdy -> startFromExpr seen world lambdy\n+    LF.ECase cas casel -> startFromExpr seen world cas `Set.union` Set.unions ( map ( startFromExpr seen world . LF.altExpr ) casel)\n+    LF.ELet (LF.Binding _ e1) e2 -> startFromExpr seen  world e1 `Set.union` startFromExpr seen world e2\n+    LF.ENil _ -> Set.empty\n+    LF.ECons _ consH consT -> startFromExpr seen world consH `Set.union` startFromExpr seen world consT\n+    LF.ESome _ smBdy -> startFromExpr seen world smBdy\n+    LF.ENone _ -> Set.empty\n+    LF.EUpdate upd -> startFromUpdate seen world upd\n+    LF.EScenario _ -> Set.empty\n+    LF.ELocation _ e1 -> startFromExpr seen world e1\n+    -- x -> Set.unions $ map startFromExpr $ children x\n+\n+startFromChoice :: LF.World -> LF.TemplateChoice -> Set.Set Action\n+startFromChoice world chc = startFromExpr Set.empty world (LF.chcUpdate chc)\n+\n+templatePossibleUpdates :: LF.World -> LF.Template -> Set.Set Action\n+templatePossibleUpdates world tpl = Set.unions $ map (startFromChoice world) (NM.toList (LF.tplChoices tpl))\n+\n+moduleAndTemplates :: LF.World -> LF.Module -> [(LF.TypeConName, Set.Set Action)]\n+moduleAndTemplates world mod = retTypess\n+    where \n+        templates = templatesFromModule mod\n+        retTypess = map (\\t-> (LF.tplTypeCon t, templatePossibleUpdates world t )) templates\n+\n+listOfModules :: NM.NameMap LF.Module -> [LF.Module]\n+listOfModules modules = NM.toList modules\n+\n+templatesFromModule :: LF.Module -> [LF.Template]\n+templatesFromModule mod = NM.toList $ LF.moduleTemplates mod\n+\n+dalfsInDar :: Archive -> [BSL.ByteString]\n+dalfsInDar dar = [fromEntry e | e <- zEntries dar, \".dalf\" `isExtensionOf` eRelativePath e]\n+\n+dalfBytesToPakage :: BSL.ByteString -> (LF.PackageId, LF.Package)\n+dalfBytesToPakage bytes = case Archive.decodeArchive $ BSL.toStrict bytes of\n+    Right a -> a\n+    Left err -> error (show err)\n+\n+dalfsToWorld :: [BSL.ByteString] -> LF.Package -> LF.World\n+dalfsToWorld dalfs pkg = AST.initWorldSelf pkgs version1_4 pkg\n+    where \n+        pkgs = map dalfBytesToPakage dalfs\n+\n+darToWorld :: FilePath -> LF.Package -> IO LF.World\n+darToWorld darFilePath pkg = do\n+    bytes <- B.readFile darFilePath\n+    let dalfs = dalfsInDar (toArchive $ BSL.fromStrict bytes)\n+    return (dalfsToWorld dalfs pkg )\n+\n+prettyAction :: Action -> String\n+prettyAction (ACreate  tpl) = DAP.renderPretty tpl \n+prettyAction (AExercise  tpl chc ) = DAP.renderPretty tpl ++ \":\" ++ (show $ LF.unChoiceName chc)\n+\n+-- prettyTemplateWithAction :: (LF.TypeConName ,DS.Set Action) -> String\n+-- prettyTemplateWithAction (tplCon, actions) =  DAP.renderPretty tplCon ++ \"->\" ++ show(DS.map prettyAction actions)\n+\n+src :: String -> Dot NodeId\n+src label = node [ (\"shape\",\"none\"),(\"label\",label) ]\n+\n+dotGraphTemplateAndActionHelper :: (LF.TypeConName, Set.Set Action) -> (String, [String])\n+dotGraphTemplateAndActionHelper (tplCon, actions) = (tplStr, actionsStrs)\n+    where \n+        tplStr =  DAP.renderPretty tplCon\n+        actionsStrs = Set.elems $ Set.map prettyAction actions\n+\n+nodeToDot :: NodeId -> String -> Dot ()\n+nodeToDot a b = do\n+    n2 <- src b\n+    a .->. n2\n+\n+\n+errorOnLeft :: Show a => String -> Either a b -> IO b"
  }
]