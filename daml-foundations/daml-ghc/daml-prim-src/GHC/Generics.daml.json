[
  {
    "id" : "296972d2-748b-4ad6-b040-2b83e0a4a0cc",
    "prId" : 1276,
    "comments" : [
      {
        "id" : "538770a1-f5db-4860-b69c-ae99ba370a82",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we say at the top where we got it from, so we can track changes upstream easier.",
        "createdAt" : "2019-05-21T09:51:20Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9fe69fc4-0137-48ac-8255-8846c1a64f1b",
        "parentId" : "538770a1-f5db-4860-b69c-ae99ba370a82",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "done.",
        "createdAt" : "2019-05-21T11:03:52Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "154108f2d80e8a6a0655396865f94a7f0d295cc4",
    "line" : 7,
    "diffHunk" : "@@ -0,0 +1,1685 @@\n+{-# LANGUAGE DataKinds                  #-}"
  },
  {
    "id" : "e0be69a0-b900-4e18-b4d2-c633f4fc4638",
    "prId" : 1276,
    "comments" : [
      {
        "id" : "0365f948-d612-4d71-9981-5f3eed81392c",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Why not Functor?",
        "createdAt" : "2019-05-21T09:51:46Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d2225c82-e8fc-451e-afbf-3e29e6094c9e",
        "parentId" : "0365f948-d612-4d71-9981-5f3eed81392c",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "I tried to be as minimal as possible. Deriving functor instances for example is problematic, because the conversion to daml-lf fails for an unhandled coercion (most likely caused by the phantom type in the representation). We might be able to fix this, but I'd rather postpone for later and see if we get the upgradability to work. ",
        "createdAt" : "2019-05-21T10:50:13Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "078b16af-2202-411c-ab02-5727490de4d6",
        "parentId" : "0365f948-d612-4d71-9981-5f3eed81392c",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we get a separate ticket for that? Agree not to do it simultaneously, but worth fixing on its own.",
        "createdAt" : "2019-05-21T11:33:22Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cbca473e-4934-477f-b871-e71053f94d98",
        "parentId" : "0365f948-d612-4d71-9981-5f3eed81392c",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "Done. https://github.com/digital-asset/daml/issues/1344",
        "createdAt" : "2019-05-23T11:37:44Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "154108f2d80e8a6a0655396865f94a7f0d295cc4",
    "line" : 777,
    "diffHunk" : "@@ -0,0 +1,1685 @@\n+{-# LANGUAGE DataKinds                  #-}\n+{-# LANGUAGE DeriveFunctor              #-}\n+{-# LANGUAGE DeriveGeneric              #-}\n+{-# LANGUAGE EmptyDataDeriving          #-}\n+{-# LANGUAGE FlexibleContexts           #-}\n+{-# LANGUAGE FlexibleInstances          #-}\n+{-# LANGUAGE GADTs                      #-}\n+{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n+{-# LANGUAGE KindSignatures             #-}\n+{-# LANGUAGE MagicHash                  #-}\n+{-# LANGUAGE NoImplicitPrelude          #-}\n+{-# LANGUAGE PolyKinds                  #-}\n+{-# LANGUAGE ScopedTypeVariables        #-}\n+{-# LANGUAGE StandaloneDeriving         #-}\n+{-# LANGUAGE Trustworthy                #-}\n+{-# LANGUAGE TypeOperators              #-}\n+{-# LANGUAGE TypeSynonymInstances       #-}\n+{-# LANGUAGE UndecidableInstances       #-}\n+{-# LANGUAGE NoNewColonConvention       #-}\n+\n+daml 1.2\n+-----------------------------------------------------------------------------\n+-- |\n+-- Module      :  GHC.Generics\n+-- Copyright   :  (c) Universiteit Utrecht 2010-2011, University of Oxford 2012-2014\n+-- License     :  see libraries/base/LICENSE\n+--\n+-- Maintainer  :  libraries@haskell.org\n+-- Stability   :  internal\n+-- Portability :  non-portable\n+--\n+-- @since 4.6.0.0\n+--\n+-- If you're using @GHC.Generics@, you should consider using the\n+-- <http://hackage.haskell.org/package/generic-deriving> package, which\n+-- contains many useful generic functions.\n+\n+module GHC.Generics (\n+-- * Introduction\n+--\n+-- |\n+--\n+-- Datatype-generic functions are based on the idea of converting values of\n+-- a datatype @T@ into corresponding values of a (nearly) isomorphic type @'Rep' T@.\n+-- The type @'Rep' T@ is\n+-- built from a limited set of type constructors, all provided by this module. A\n+-- datatype-generic function is then an overloaded function with instances\n+-- for most of these type constructors, together with a wrapper that performs\n+-- the mapping between @T@ and @'Rep' T@. By using this technique, we merely need\n+-- a few generic instances in order to implement functionality that works for any\n+-- representable type.\n+--\n+-- Representable types are collected in the 'Generic' class, which defines the\n+-- associated type 'Rep' as well as conversion functions 'from' and 'to'.\n+-- Typically, you will not define 'Generic' instances by hand, but have the compiler\n+-- derive them for you.\n+\n+-- ** Representing datatypes\n+--\n+-- |\n+--\n+-- The key to defining your own datatype-generic functions is to understand how to\n+-- represent datatypes using the given set of type constructors.\n+--\n+-- Let us look at an example first:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic'\n+-- @\n+--\n+-- The above declaration (which requires the language pragma @DeriveGeneric@)\n+-- causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                 ('Rec0' a))\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))))\n+--   ...\n+-- @\n+--\n+-- /Hint:/ You can obtain information about the code being generated from GHC by passing\n+-- the @-ddump-deriv@ flag. In GHCi, you can expand a type family such as 'Rep' using\n+-- the @:kind!@ command.\n+--\n+-- This is a lot of information! However, most of it is actually merely meta-information\n+-- that makes names of datatypes and constructors and more available on the type level.\n+--\n+-- Here is a reduced representation for @Tree@ with nearly all meta-information removed,\n+-- for now keeping only the most essential aspects:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'Rec0' a\n+--     ':+:'\n+--     ('Rec0' (Tree a) ':*:' 'Rec0' (Tree a))\n+-- @\n+--\n+-- The @Tree@ datatype has two constructors. The representation of individual constructors\n+-- is combined using the binary type constructor ':+:'.\n+--\n+-- The first constructor consists of a single field, which is the parameter @a@. This is\n+-- represented as @'Rec0' a@.\n+--\n+-- The second constructor consists of two fields. Each is a recursive field of type @Tree a@,\n+-- represented as @'Rec0' (Tree a)@. Representations of individual fields are combined using\n+-- the binary type constructor ':*:'.\n+--\n+-- Now let us explain the additional tags being used in the complete representation:\n+--\n+--    * The @'S1' ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness\n+--      'DecidedLazy)@ tag indicates several things. The @'Nothing@ indicates\n+--      that there is no record field selector associated with this field of\n+--      the constructor (if there were, it would have been marked @'Just\n+--      \\\"recordName\\\"@ instead). The other types contain meta-information on\n+--      the field's strictness:\n+--\n+--      * There is no @{\\-\\# UNPACK \\#-\\}@ or @{\\-\\# NOUNPACK \\#-\\}@ annotation\n+--        in the source, so it is tagged with @'NoSourceUnpackedness@.\n+--\n+--      * There is no strictness (@!@) or laziness (@~@) annotation in the\n+--        source, so it is tagged with @'NoSourceStrictness@.\n+--\n+--      * The compiler infers that the field is lazy, so it is tagged with\n+--        @'DecidedLazy@. Bear in mind that what the compiler decides may be\n+--        quite different from what is written in the source. See\n+--        'DecidedStrictness' for a more detailed explanation.\n+--\n+--      The @'MetaSel@ type is also an instance of the type class 'Selector',\n+--      which can be used to obtain information about the field at the value\n+--      level.\n+--\n+--    * The @'C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)@ and\n+--      @'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)@ invocations indicate that the enclosed part is\n+--      the representation of the first and second constructor of datatype @Tree@, respectively.\n+--      Here, the meta-information regarding constructor names, fixity and whether\n+--      it has named fields or not is encoded at the type level. The @'MetaCons@\n+--      type is also an instance of the type class 'Constructor'. This type class can be used\n+--      to obtain information about the constructor at the value level.\n+--\n+--    * The @'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)@ tag\n+--      indicates that the enclosed part is the representation of the\n+--      datatype @Tree@. Again, the meta-information is encoded at the type level.\n+--      The @'MetaData@ type is an instance of class 'Datatype', which\n+--      can be used to obtain the name of a datatype, the module it has been\n+--      defined in, the package it is located under, and whether it has been\n+--      defined using @data@ or @newtype@ at the value level.\n+\n+-- ** Derived and fundamental representation types\n+--\n+-- |\n+--\n+-- There are many datatype-generic functions that do not distinguish between positions that\n+-- are parameters or positions that are recursive calls. There are also many datatype-generic\n+-- functions that do not care about the names of datatypes and constructors at all. To keep\n+-- the number of cases to consider in generic functions in such a situation to a minimum,\n+-- it turns out that many of the type constructors introduced above are actually synonyms,\n+-- defining them to be variants of a smaller set of constructors.\n+\n+-- *** Individual fields of constructors: 'K1'\n+--\n+-- |\n+--\n+-- The type constructor 'Rec0' is a variant of 'K1':\n+--\n+-- @\n+-- type 'Rec0' = 'K1' 'R'\n+-- @\n+--\n+-- Here, 'R' is a type-level proxy that does not have any associated values.\n+--\n+-- There used to be another variant of 'K1' (namely @Par0@), but it has since\n+-- been deprecated.\n+\n+-- *** Meta information: 'M1'\n+--\n+-- |\n+--\n+-- The type constructors 'S1', 'C1' and 'D1' are all variants of 'M1':\n+--\n+-- @\n+-- type 'S1' = 'M1' 'S'\n+-- type 'C1' = 'M1' 'C'\n+-- type 'D1' = 'M1' 'D'\n+-- @\n+--\n+-- The types 'S', 'C' and 'D' are once again type-level proxies, just used to create\n+-- several variants of 'M1'.\n+\n+-- *** Additional generic representation type constructors\n+--\n+-- |\n+--\n+-- Next to 'K1', 'M1', ':+:' and ':*:' there are a few more type constructors that occur\n+-- in the representations of other datatypes.\n+\n+-- **** Empty datatypes: 'V1'\n+--\n+-- |\n+--\n+-- For empty datatypes, 'V1' is used as a representation. For example,\n+--\n+-- @\n+-- data Empty deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' Empty where\n+--   type 'Rep' Empty =\n+--     'D1' ('MetaData \\\"Empty\\\" \\\"Main\\\" \\\"package-name\\\" 'False) 'V1'\n+-- @\n+\n+-- **** Constructors without fields: 'U1'\n+--\n+-- |\n+--\n+-- If a constructor has no arguments, then 'U1' is used as its representation. For example\n+-- the representation of 'Bool' is\n+--\n+-- @\n+-- instance 'Generic' Bool where\n+--   type 'Rep' Bool =\n+--     'D1' ('MetaData \\\"Bool\\\" \\\"Data.Bool\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"False\\\" 'PrefixI 'False) 'U1' ':+:' 'C1' ('MetaCons \\\"True\\\" 'PrefixI 'False) 'U1')\n+-- @\n+\n+-- *** Representation of types with many constructors or many fields\n+--\n+-- |\n+--\n+-- As ':+:' and ':*:' are just binary operators, one might ask what happens if the\n+-- datatype has more than two constructors, or a constructor with more than two\n+-- fields. The answer is simple: the operators are used several times, to combine\n+-- all the constructors and fields as needed. However, users /should not rely on\n+-- a specific nesting strategy/ for ':+:' and ':*:' being used. The compiler is\n+-- free to choose any nesting it prefers. (In practice, the current implementation\n+-- tries to produce a more-or-less balanced nesting, so that the traversal of\n+-- the structure of the datatype from the root to a particular component can be\n+-- performed in logarithmic rather than linear time.)\n+\n+-- ** Defining datatype-generic functions\n+--\n+-- |\n+--\n+-- A datatype-generic function comprises two parts:\n+--\n+--    1. /Generic instances/ for the function, implementing it for most of the representation\n+--       type constructors introduced above.\n+--\n+--    2. A /wrapper/ that for any datatype that is in `Generic`, performs the conversion\n+--       between the original value and its `Rep`-based representation and then invokes the\n+--       generic instances.\n+--\n+-- As an example, let us look at a function @encode@ that produces a naive, but lossless\n+-- bit encoding of values of various datatypes. So we are aiming to define a function\n+--\n+-- @\n+-- encode :: 'Generic' a => a -> [Bool]\n+-- @\n+--\n+-- where we use 'Bool' as our datatype for bits.\n+--\n+-- For part 1, we define a class @Encode'@. Perhaps surprisingly, this class is parameterized\n+-- over a type constructor @f@ of kind @* -> *@. This is a technicality: all the representation\n+-- type constructors operate with kind @* -> *@ as base kind. But the type argument is never\n+-- being used. This may be changed at some point in the future. The class has a single method,\n+-- and we use the type we want our final function to have, but we replace the occurrences of\n+-- the generic type argument @a@ with @f p@ (where the @p@ is any argument; it will not be used).\n+--\n+-- > class Encode' f where\n+-- >   encode' :: f p -> [Bool]\n+--\n+-- With the goal in mind to make @encode@ work on @Tree@ and other datatypes, we now define\n+-- instances for the representation type constructors 'V1', 'U1', ':+:', ':*:', 'K1', and 'M1'.\n+\n+-- *** Definition of the generic representation types\n+--\n+-- |\n+--\n+-- In order to be able to do this, we need to know the actual definitions of these types:\n+--\n+-- @\n+-- data    'V1'        p                       -- lifted version of Empty\n+-- data    'U1'        p = 'U1'                  -- lifted version of ()\n+-- data    (':+:') f g p = 'L1' (f p) | 'R1' (g p) -- lifted version of 'Either'\n+-- data    (':*:') f g p = (f p) ':*:' (g p)     -- lifted version of (,)\n+-- newtype 'K1'    i c p = 'K1' { 'unK1' :: c }    -- a container for a c\n+-- newtype 'M1'  i t f p = 'M1' { 'unM1' :: f p }  -- a wrapper\n+-- @\n+--\n+-- So, 'U1' is just the unit type, ':+:' is just a binary choice like 'Either',\n+-- ':*:' is a binary pair like the pair constructor @(,)@, and 'K1' is a value\n+-- of a specific type @c@, and 'M1' wraps a value of the generic type argument,\n+-- which in the lifted world is an @f p@ (where we do not care about @p@).\n+\n+-- *** Generic instances\n+--\n+-- |\n+--\n+-- The instance for 'V1' is slightly awkward (but also rarely used):\n+--\n+-- @\n+-- instance Encode' 'V1' where\n+--   encode' x = undefined\n+-- @\n+--\n+-- There are no values of type @V1 p@ to pass (except undefined), so this is\n+-- actually impossible. One can ask why it is useful to define an instance for\n+-- 'V1' at all in this case? Well, an empty type can be used as an argument to\n+-- a non-empty type, and you might still want to encode the resulting type.\n+-- As a somewhat contrived example, consider @[Empty]@, which is not an empty\n+-- type, but contains just the empty list. The 'V1' instance ensures that we\n+-- can call the generic function on such types.\n+--\n+-- There is exactly one value of type 'U1', so encoding it requires no\n+-- knowledge, and we can use zero bits:\n+--\n+-- @\n+-- instance Encode' 'U1' where\n+--   encode' 'U1' = []\n+-- @\n+--\n+-- In the case for ':+:', we produce 'False' or 'True' depending on whether\n+-- the constructor of the value provided is located on the left or on the right:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':+:' g) where\n+--   encode' ('L1' x) = False : encode' x\n+--   encode' ('R1' x) = True  : encode' x\n+-- @\n+--\n+-- (Note that this encoding strategy may not be reliable across different\n+-- versions of GHC. Recall that the compiler is free to choose any nesting\n+-- of ':+:' it chooses, so if GHC chooses @(a ':+:' b) ':+:' c@, then the\n+-- encoding for @a@ would be @[False, False]@, @b@ would be @[False, True]@,\n+-- and @c@ would be @[True]@. However, if GHC chooses @a ':+:' (b ':+:' c)@,\n+-- then the encoding for @a@ would be @[False]@, @b@ would be @[True, False]@,\n+-- and @c@ would be @[True, True]@.)\n+--\n+-- In the case for ':*:', we append the encodings of the two subcomponents:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':*:' g) where\n+--   encode' (x ':*:' y) = encode' x ++ encode' y\n+-- @\n+--\n+-- The case for 'K1' is rather interesting. Here, we call the final function\n+-- @encode@ that we yet have to define, recursively. We will use another type\n+-- class @Encode@ for that function:\n+--\n+-- @\n+-- instance (Encode c) => Encode' ('K1' i c) where\n+--   encode' ('K1' x) = encode x\n+-- @\n+--\n+-- Note how we can define a uniform instance for 'M1', because we completely\n+-- disregard all meta-information:\n+--\n+-- @\n+-- instance (Encode' f) => Encode' ('M1' i t f) where\n+--   encode' ('M1' x) = encode' x\n+-- @\n+--\n+-- Unlike in 'K1', the instance for 'M1' refers to @encode'@, not @encode@.\n+\n+-- *** The wrapper and generic default\n+--\n+-- |\n+--\n+-- We now define class @Encode@ for the actual @encode@ function:\n+--\n+-- @\n+-- class Encode a where\n+--   encode :: a -> [Bool]\n+--   default encode :: (Generic a, Encode' (Rep a)) => a -> [Bool]\n+--   encode x = encode' ('from' x)\n+-- @\n+--\n+-- The incoming @x@ is converted using 'from', then we dispatch to the\n+-- generic instances using @encode'@. We use this as a default definition\n+-- for @encode@. We need the @default encode@ signature because ordinary\n+-- Haskell default methods must not introduce additional class constraints,\n+-- but our generic default does.\n+--\n+-- Defining a particular instance is now as simple as saying\n+--\n+-- @\n+-- instance (Encode a) => Encode (Tree a)\n+-- @\n+--\n+-- #if 0\n+-- /TODO:/ Add usage example?\n+--\n+-- #endif\n+-- The generic default is being used. In the future, it will hopefully be\n+-- possible to use @deriving Encode@ as well, but GHC does not yet support\n+-- that syntax for this situation.\n+--\n+-- Having @Encode@ as a class has the advantage that we can define\n+-- non-generic special cases, which is particularly useful for abstract\n+-- datatypes that have no structural representation. For example, given\n+-- a suitable integer encoding function @encodeInt@, we can define\n+--\n+-- @\n+-- instance Encode Int where\n+--   encode = encodeInt\n+-- @\n+\n+-- *** Omitting generic instances\n+--\n+-- |\n+--\n+-- It is not always required to provide instances for all the generic\n+-- representation types, but omitting instances restricts the set of\n+-- datatypes the functions will work for:\n+--\n+--    * If no ':+:' instance is given, the function may still work for\n+--      empty datatypes or datatypes that have a single constructor,\n+--      but will fail on datatypes with more than one constructor.\n+--\n+--    * If no ':*:' instance is given, the function may still work for\n+--      datatypes where each constructor has just zero or one field,\n+--      in particular for enumeration types.\n+--\n+--    * If no 'K1' instance is given, the function may still work for\n+--      enumeration types, where no constructor has any fields.\n+--\n+--    * If no 'V1' instance is given, the function may still work for\n+--      any datatype that is not empty.\n+--\n+--    * If no 'U1' instance is given, the function may still work for\n+--      any datatype where each constructor has at least one field.\n+--\n+-- An 'M1' instance is always required (but it can just ignore the\n+-- meta-information, as is the case for @encode@ above).\n+-- #if 0\n+-- *** Using meta-information\n+--\n+-- |\n+--\n+-- TODO\n+-- #endif\n+-- ** Generic constructor classes\n+--\n+-- |\n+--\n+-- Datatype-generic functions as defined above work for a large class\n+-- of datatypes, including parameterized datatypes. (We have used @Tree@\n+-- as our example above, which is of kind @* -> *@.) However, the\n+-- 'Generic' class ranges over types of kind @*@, and therefore, the\n+-- resulting generic functions (such as @encode@) must be parameterized\n+-- by a generic type argument of kind @*@.\n+--\n+-- What if we want to define generic classes that range over type\n+-- constructors (such as 'Data.Functor.Functor',\n+-- 'Data.Traversable.Traversable', or 'Data.Foldable.Foldable')?\n+\n+-- *** The 'Generic1' class\n+--\n+-- |\n+--\n+-- Like 'Generic', there is a class 'Generic1' that defines a\n+-- representation 'Rep1' and conversion functions 'from1' and 'to1',\n+-- only that 'Generic1' ranges over types of kind @* -> *@. (More generally,\n+-- it can range over types of kind @k -> *@, for any kind @k@, if the\n+-- @PolyKinds@ extension is enabled. More on this later.)\n+-- The 'Generic1' class is also derivable.\n+--\n+-- The representation 'Rep1' is ever so slightly different from 'Rep'.\n+-- Let us look at @Tree@ as an example again:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- The above declaration causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic1' Tree where\n+--   type 'Rep1' Tree =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                'Par1')\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)))\n+--   ...\n+-- @\n+--\n+-- The representation reuses 'D1', 'C1', 'S1' (and thereby 'M1') as well\n+-- as ':+:' and ':*:' from 'Rep'. (This reusability is the reason that we\n+-- carry around the dummy type argument for kind-@*@-types, but there are\n+-- already enough different names involved without duplicating each of\n+-- these.)\n+--\n+-- What's different is that we now use 'Par1' to refer to the parameter\n+-- (and that parameter, which used to be @a@), is not mentioned explicitly\n+-- by name anywhere; and we use 'Rec1' to refer to a recursive use of @Tree a@.\n+\n+-- *** Representation of @* -> *@ types\n+--\n+-- |\n+--\n+-- Unlike 'Rec0', the 'Par1' and 'Rec1' type constructors do not\n+-- map to 'K1'. They are defined directly, as follows:\n+--\n+-- @\n+-- newtype 'Par1'   p = 'Par1' { 'unPar1' ::   p } -- gives access to parameter p\n+-- newtype 'Rec1' f p = 'Rec1' { 'unRec1' :: f p } -- a wrapper\n+-- @\n+--\n+-- In 'Par1', the parameter @p@ is used for the first time, whereas 'Rec1' simply\n+-- wraps an application of @f@ to @p@.\n+--\n+-- Note that 'K1' (in the guise of 'Rec0') can still occur in a 'Rep1' representation,\n+-- namely when the datatype has a field that does not mention the parameter.\n+--\n+-- The declaration\n+--\n+-- @\n+-- data WithInt a = WithInt Int a\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' WithInt where\n+--   type 'Rep1' WithInt =\n+--     'D1' ('MetaData \\\"WithInt\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"WithInt\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               ('Rec0' Int)\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               'Par1'))\n+-- @\n+--\n+-- If the parameter @a@ appears underneath a composition of other type constructors,\n+-- then the representation involves composition, too:\n+--\n+-- @\n+-- data Rose a = Fork a [Rose a]\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' Rose where\n+--   type 'Rep1' Rose =\n+--     'D1' ('MetaData \\\"Rose\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Fork\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'Par1'\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               ([] ':.:' 'Rec1' Rose)))\n+-- @\n+--\n+-- where\n+--\n+-- @\n+-- newtype (':.:') f g p = 'Comp1' { 'unComp1' :: f (g p) }\n+-- @\n+\n+-- *** Representation of @k -> *@ types\n+--\n+-- |\n+--\n+-- The 'Generic1' class can be generalized to range over types of kind\n+-- @k -> *@, for any kind @k@. To do so, derive a 'Generic1' instance with the\n+-- @PolyKinds@ extension enabled. For example, the declaration\n+--\n+-- @\n+-- data Proxy (a :: k) = Proxy deriving 'Generic1'\n+-- @\n+--\n+-- yields a slightly different instance depending on whether @PolyKinds@ is\n+-- enabled. If compiled without @PolyKinds@, then @'Rep1' Proxy :: * -> *@, but\n+-- if compiled with @PolyKinds@, then @'Rep1' Proxy :: k -> *@.\n+\n+-- *** Representation of unlifted types\n+--\n+-- |\n+--\n+-- If one were to attempt to derive a Generic instance for a datatype with an\n+-- unlifted argument (for example, 'Int#'), one might expect the occurrence of\n+-- the 'Int#' argument to be marked with @'Rec0' 'Int#'@. This won't work,\n+-- though, since 'Int#' is of an unlifted kind, and 'Rec0' expects a type of\n+-- kind @*@.\n+--\n+-- One solution would be to represent an occurrence of 'Int#' with 'Rec0 Int'\n+-- instead. With this approach, however, the programmer has no way of knowing\n+-- whether the 'Int' is actually an 'Int#' in disguise.\n+--\n+-- Instead of reusing 'Rec0', a separate data family 'URec' is used to mark\n+-- occurrences of common unlifted types:\n+--\n+-- @\n+-- data family URec a p\n+--\n+-- data instance 'URec' ('Ptr' ()) p = 'UAddr'   { 'uAddr#'   :: 'Addr#'   }\n+-- data instance 'URec' 'Char'     p = 'UChar'   { 'uChar#'   :: 'Char#'   }\n+-- data instance 'URec' 'Double'   p = 'UDouble' { 'uDouble#' :: 'Double#' }\n+-- data instance 'URec' 'Int'      p = 'UFloat'  { 'uFloat#'  :: 'Float#'  }\n+-- data instance 'URec' 'Float'    p = 'UInt'    { 'uInt#'    :: 'Int#'    }\n+-- data instance 'URec' 'Word'     p = 'UWord'   { 'uWord#'   :: 'Word#'   }\n+-- @\n+--\n+-- Several type synonyms are provided for convenience:\n+--\n+-- @\n+-- type 'UAddr'   = 'URec' ('Ptr' ())\n+-- type 'UChar'   = 'URec' 'Char'\n+-- type 'UDouble' = 'URec' 'Double'\n+-- type 'UFloat'  = 'URec' 'Float'\n+-- type 'UInt'    = 'URec' 'Int'\n+-- type 'UWord'   = 'URec' 'Word'\n+-- @\n+--\n+-- The declaration\n+--\n+-- @\n+-- data IntHash = IntHash Int#\n+--   deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' IntHash where\n+--   type 'Rep' IntHash =\n+--     'D1' ('MetaData \\\"IntHash\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"IntHash\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'UInt'))\n+-- @\n+--\n+-- Currently, only the six unlifted types listed above are generated, but this\n+-- may be extended to encompass more unlifted types in the future.\n+-- #if 0\n+-- *** Limitations\n+--\n+-- |\n+--\n+-- /TODO/\n+--\n+-- /TODO:/ Also clear up confusion about 'Rec0' and 'Rec1' not really indicating recursion.\n+--\n+-- #endif\n+-----------------------------------------------------------------------------\n+\n+  -- * Generic representation types\n+    V1, U1(..), Par1(..), Rec1(..), K1(..), M1(..)\n+  , (:+:)(..), (:*:)(..), (:.:)(..)\n+\n+  -- ** Unboxed representation types\n+  --, URec(..)\n+  --, type UAddr, type UChar, type UDouble\n+  --, type UFloat, type UInt, type UWord\n+\n+  -- ** Synonyms for convenience\n+  , Rec0, R\n+  , D1, C1, S1, D, C, S\n+\n+  -- * Meta-information\n+  -- , Datatype(..), Constructor(..), Selector(..)\n+  , Fixity(..), FixityI(..), Associativity(..), prec\n+  , SourceUnpackedness(..), SourceStrictness(..), DecidedStrictness(..)\n+  , Meta(..)\n+\n+  -- * Generic type classes\n+  , Generic(..), Generic1(..)\n+\n+  ) where\n+\n+-- We use some base types\n+-- import Data.Either ( Either (..) )\n+-- import Data.Maybe  ( Maybe(..))\n+-- import Data.Ord    ( Down(..) )\n+-- import GHC.Integer ( Integer, integerToInt )\n+-- import GHC.Prim    ( Addr#, Char#, Double#, Float#, Int#, Word# )\n+-- import GHC.Ptr     ( Ptr )\n+import GHC.Types\n+\n+-- Needed for instances\n+-- import GHC.Arr     ( Ix )\n+-- import GHC.Base    ( Alternative(..), Applicative(..), Functor(..)\n+--                   , Monad(..), MonadPlus(..), NonEmpty(..), String, coerce\n+--                   , Semigroup(..), Monoid(..) )\n+import GHC.Classes ( Eq(..), Ord(..) )\n+import GHC.Enum    ( Bounded, Enum )\n+-- import GHC.Read    ( Read(..) )\n+import GHC.Show    ( Show(..), showString )\n+\n+-- Needed for metadata\n+-- import Data.Proxy   ( Proxy(..) )\n+-- import GHC.TypeLits ( KnownSymbol, KnownNat, symbolVal, natVal )\n+\n+import GHC.CString (fromString)\n+import GHC.Integer.Type (fromInteger)\n+import Control.Exception.Base\n+\n+-- | The kind of types with values. For example @Int :: Type@.\n+-- [DA] copied from ghc-prim/GHC/Types.hs. Usually set to\n+-- type Type = TYPE 'LiftedRep, but we only have one representation.\n+type Type = *\n+\n+ --------------------------------------------------------------------------------\n+-- Representation types\n+--------------------------------------------------------------------------------\n+\n+-- | Void: used for datatypes without constructors\n+data V1 (p :: k)\n+  deriving ( Eq       -- ^ @since 4.9.0.0\n+           , Ord      -- ^ @since 4.9.0.0\n+--           , Read     -- ^ @since 4.9.0.0\n+           , Show     -- ^ @since 4.9.0.0\n+--           , Functor  -- ^ @since 4.9.0.0"
  },
  {
    "id" : "d2b3c3c4-c0f5-47e8-978c-5a2642c9c2d5",
    "prId" : 1276,
    "comments" : [
      {
        "id" : "0d81c24a-8c26-41ce-9acd-012d6d7df2ee",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Why not?",
        "createdAt" : "2019-05-21T09:52:10Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "154108f2d80e8a6a0655396865f94a7f0d295cc4",
    "line" : 784,
    "diffHunk" : "@@ -0,0 +1,1685 @@\n+{-# LANGUAGE DataKinds                  #-}\n+{-# LANGUAGE DeriveFunctor              #-}\n+{-# LANGUAGE DeriveGeneric              #-}\n+{-# LANGUAGE EmptyDataDeriving          #-}\n+{-# LANGUAGE FlexibleContexts           #-}\n+{-# LANGUAGE FlexibleInstances          #-}\n+{-# LANGUAGE GADTs                      #-}\n+{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n+{-# LANGUAGE KindSignatures             #-}\n+{-# LANGUAGE MagicHash                  #-}\n+{-# LANGUAGE NoImplicitPrelude          #-}\n+{-# LANGUAGE PolyKinds                  #-}\n+{-# LANGUAGE ScopedTypeVariables        #-}\n+{-# LANGUAGE StandaloneDeriving         #-}\n+{-# LANGUAGE Trustworthy                #-}\n+{-# LANGUAGE TypeOperators              #-}\n+{-# LANGUAGE TypeSynonymInstances       #-}\n+{-# LANGUAGE UndecidableInstances       #-}\n+{-# LANGUAGE NoNewColonConvention       #-}\n+\n+daml 1.2\n+-----------------------------------------------------------------------------\n+-- |\n+-- Module      :  GHC.Generics\n+-- Copyright   :  (c) Universiteit Utrecht 2010-2011, University of Oxford 2012-2014\n+-- License     :  see libraries/base/LICENSE\n+--\n+-- Maintainer  :  libraries@haskell.org\n+-- Stability   :  internal\n+-- Portability :  non-portable\n+--\n+-- @since 4.6.0.0\n+--\n+-- If you're using @GHC.Generics@, you should consider using the\n+-- <http://hackage.haskell.org/package/generic-deriving> package, which\n+-- contains many useful generic functions.\n+\n+module GHC.Generics (\n+-- * Introduction\n+--\n+-- |\n+--\n+-- Datatype-generic functions are based on the idea of converting values of\n+-- a datatype @T@ into corresponding values of a (nearly) isomorphic type @'Rep' T@.\n+-- The type @'Rep' T@ is\n+-- built from a limited set of type constructors, all provided by this module. A\n+-- datatype-generic function is then an overloaded function with instances\n+-- for most of these type constructors, together with a wrapper that performs\n+-- the mapping between @T@ and @'Rep' T@. By using this technique, we merely need\n+-- a few generic instances in order to implement functionality that works for any\n+-- representable type.\n+--\n+-- Representable types are collected in the 'Generic' class, which defines the\n+-- associated type 'Rep' as well as conversion functions 'from' and 'to'.\n+-- Typically, you will not define 'Generic' instances by hand, but have the compiler\n+-- derive them for you.\n+\n+-- ** Representing datatypes\n+--\n+-- |\n+--\n+-- The key to defining your own datatype-generic functions is to understand how to\n+-- represent datatypes using the given set of type constructors.\n+--\n+-- Let us look at an example first:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic'\n+-- @\n+--\n+-- The above declaration (which requires the language pragma @DeriveGeneric@)\n+-- causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                 ('Rec0' a))\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))))\n+--   ...\n+-- @\n+--\n+-- /Hint:/ You can obtain information about the code being generated from GHC by passing\n+-- the @-ddump-deriv@ flag. In GHCi, you can expand a type family such as 'Rep' using\n+-- the @:kind!@ command.\n+--\n+-- This is a lot of information! However, most of it is actually merely meta-information\n+-- that makes names of datatypes and constructors and more available on the type level.\n+--\n+-- Here is a reduced representation for @Tree@ with nearly all meta-information removed,\n+-- for now keeping only the most essential aspects:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'Rec0' a\n+--     ':+:'\n+--     ('Rec0' (Tree a) ':*:' 'Rec0' (Tree a))\n+-- @\n+--\n+-- The @Tree@ datatype has two constructors. The representation of individual constructors\n+-- is combined using the binary type constructor ':+:'.\n+--\n+-- The first constructor consists of a single field, which is the parameter @a@. This is\n+-- represented as @'Rec0' a@.\n+--\n+-- The second constructor consists of two fields. Each is a recursive field of type @Tree a@,\n+-- represented as @'Rec0' (Tree a)@. Representations of individual fields are combined using\n+-- the binary type constructor ':*:'.\n+--\n+-- Now let us explain the additional tags being used in the complete representation:\n+--\n+--    * The @'S1' ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness\n+--      'DecidedLazy)@ tag indicates several things. The @'Nothing@ indicates\n+--      that there is no record field selector associated with this field of\n+--      the constructor (if there were, it would have been marked @'Just\n+--      \\\"recordName\\\"@ instead). The other types contain meta-information on\n+--      the field's strictness:\n+--\n+--      * There is no @{\\-\\# UNPACK \\#-\\}@ or @{\\-\\# NOUNPACK \\#-\\}@ annotation\n+--        in the source, so it is tagged with @'NoSourceUnpackedness@.\n+--\n+--      * There is no strictness (@!@) or laziness (@~@) annotation in the\n+--        source, so it is tagged with @'NoSourceStrictness@.\n+--\n+--      * The compiler infers that the field is lazy, so it is tagged with\n+--        @'DecidedLazy@. Bear in mind that what the compiler decides may be\n+--        quite different from what is written in the source. See\n+--        'DecidedStrictness' for a more detailed explanation.\n+--\n+--      The @'MetaSel@ type is also an instance of the type class 'Selector',\n+--      which can be used to obtain information about the field at the value\n+--      level.\n+--\n+--    * The @'C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)@ and\n+--      @'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)@ invocations indicate that the enclosed part is\n+--      the representation of the first and second constructor of datatype @Tree@, respectively.\n+--      Here, the meta-information regarding constructor names, fixity and whether\n+--      it has named fields or not is encoded at the type level. The @'MetaCons@\n+--      type is also an instance of the type class 'Constructor'. This type class can be used\n+--      to obtain information about the constructor at the value level.\n+--\n+--    * The @'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)@ tag\n+--      indicates that the enclosed part is the representation of the\n+--      datatype @Tree@. Again, the meta-information is encoded at the type level.\n+--      The @'MetaData@ type is an instance of class 'Datatype', which\n+--      can be used to obtain the name of a datatype, the module it has been\n+--      defined in, the package it is located under, and whether it has been\n+--      defined using @data@ or @newtype@ at the value level.\n+\n+-- ** Derived and fundamental representation types\n+--\n+-- |\n+--\n+-- There are many datatype-generic functions that do not distinguish between positions that\n+-- are parameters or positions that are recursive calls. There are also many datatype-generic\n+-- functions that do not care about the names of datatypes and constructors at all. To keep\n+-- the number of cases to consider in generic functions in such a situation to a minimum,\n+-- it turns out that many of the type constructors introduced above are actually synonyms,\n+-- defining them to be variants of a smaller set of constructors.\n+\n+-- *** Individual fields of constructors: 'K1'\n+--\n+-- |\n+--\n+-- The type constructor 'Rec0' is a variant of 'K1':\n+--\n+-- @\n+-- type 'Rec0' = 'K1' 'R'\n+-- @\n+--\n+-- Here, 'R' is a type-level proxy that does not have any associated values.\n+--\n+-- There used to be another variant of 'K1' (namely @Par0@), but it has since\n+-- been deprecated.\n+\n+-- *** Meta information: 'M1'\n+--\n+-- |\n+--\n+-- The type constructors 'S1', 'C1' and 'D1' are all variants of 'M1':\n+--\n+-- @\n+-- type 'S1' = 'M1' 'S'\n+-- type 'C1' = 'M1' 'C'\n+-- type 'D1' = 'M1' 'D'\n+-- @\n+--\n+-- The types 'S', 'C' and 'D' are once again type-level proxies, just used to create\n+-- several variants of 'M1'.\n+\n+-- *** Additional generic representation type constructors\n+--\n+-- |\n+--\n+-- Next to 'K1', 'M1', ':+:' and ':*:' there are a few more type constructors that occur\n+-- in the representations of other datatypes.\n+\n+-- **** Empty datatypes: 'V1'\n+--\n+-- |\n+--\n+-- For empty datatypes, 'V1' is used as a representation. For example,\n+--\n+-- @\n+-- data Empty deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' Empty where\n+--   type 'Rep' Empty =\n+--     'D1' ('MetaData \\\"Empty\\\" \\\"Main\\\" \\\"package-name\\\" 'False) 'V1'\n+-- @\n+\n+-- **** Constructors without fields: 'U1'\n+--\n+-- |\n+--\n+-- If a constructor has no arguments, then 'U1' is used as its representation. For example\n+-- the representation of 'Bool' is\n+--\n+-- @\n+-- instance 'Generic' Bool where\n+--   type 'Rep' Bool =\n+--     'D1' ('MetaData \\\"Bool\\\" \\\"Data.Bool\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"False\\\" 'PrefixI 'False) 'U1' ':+:' 'C1' ('MetaCons \\\"True\\\" 'PrefixI 'False) 'U1')\n+-- @\n+\n+-- *** Representation of types with many constructors or many fields\n+--\n+-- |\n+--\n+-- As ':+:' and ':*:' are just binary operators, one might ask what happens if the\n+-- datatype has more than two constructors, or a constructor with more than two\n+-- fields. The answer is simple: the operators are used several times, to combine\n+-- all the constructors and fields as needed. However, users /should not rely on\n+-- a specific nesting strategy/ for ':+:' and ':*:' being used. The compiler is\n+-- free to choose any nesting it prefers. (In practice, the current implementation\n+-- tries to produce a more-or-less balanced nesting, so that the traversal of\n+-- the structure of the datatype from the root to a particular component can be\n+-- performed in logarithmic rather than linear time.)\n+\n+-- ** Defining datatype-generic functions\n+--\n+-- |\n+--\n+-- A datatype-generic function comprises two parts:\n+--\n+--    1. /Generic instances/ for the function, implementing it for most of the representation\n+--       type constructors introduced above.\n+--\n+--    2. A /wrapper/ that for any datatype that is in `Generic`, performs the conversion\n+--       between the original value and its `Rep`-based representation and then invokes the\n+--       generic instances.\n+--\n+-- As an example, let us look at a function @encode@ that produces a naive, but lossless\n+-- bit encoding of values of various datatypes. So we are aiming to define a function\n+--\n+-- @\n+-- encode :: 'Generic' a => a -> [Bool]\n+-- @\n+--\n+-- where we use 'Bool' as our datatype for bits.\n+--\n+-- For part 1, we define a class @Encode'@. Perhaps surprisingly, this class is parameterized\n+-- over a type constructor @f@ of kind @* -> *@. This is a technicality: all the representation\n+-- type constructors operate with kind @* -> *@ as base kind. But the type argument is never\n+-- being used. This may be changed at some point in the future. The class has a single method,\n+-- and we use the type we want our final function to have, but we replace the occurrences of\n+-- the generic type argument @a@ with @f p@ (where the @p@ is any argument; it will not be used).\n+--\n+-- > class Encode' f where\n+-- >   encode' :: f p -> [Bool]\n+--\n+-- With the goal in mind to make @encode@ work on @Tree@ and other datatypes, we now define\n+-- instances for the representation type constructors 'V1', 'U1', ':+:', ':*:', 'K1', and 'M1'.\n+\n+-- *** Definition of the generic representation types\n+--\n+-- |\n+--\n+-- In order to be able to do this, we need to know the actual definitions of these types:\n+--\n+-- @\n+-- data    'V1'        p                       -- lifted version of Empty\n+-- data    'U1'        p = 'U1'                  -- lifted version of ()\n+-- data    (':+:') f g p = 'L1' (f p) | 'R1' (g p) -- lifted version of 'Either'\n+-- data    (':*:') f g p = (f p) ':*:' (g p)     -- lifted version of (,)\n+-- newtype 'K1'    i c p = 'K1' { 'unK1' :: c }    -- a container for a c\n+-- newtype 'M1'  i t f p = 'M1' { 'unM1' :: f p }  -- a wrapper\n+-- @\n+--\n+-- So, 'U1' is just the unit type, ':+:' is just a binary choice like 'Either',\n+-- ':*:' is a binary pair like the pair constructor @(,)@, and 'K1' is a value\n+-- of a specific type @c@, and 'M1' wraps a value of the generic type argument,\n+-- which in the lifted world is an @f p@ (where we do not care about @p@).\n+\n+-- *** Generic instances\n+--\n+-- |\n+--\n+-- The instance for 'V1' is slightly awkward (but also rarely used):\n+--\n+-- @\n+-- instance Encode' 'V1' where\n+--   encode' x = undefined\n+-- @\n+--\n+-- There are no values of type @V1 p@ to pass (except undefined), so this is\n+-- actually impossible. One can ask why it is useful to define an instance for\n+-- 'V1' at all in this case? Well, an empty type can be used as an argument to\n+-- a non-empty type, and you might still want to encode the resulting type.\n+-- As a somewhat contrived example, consider @[Empty]@, which is not an empty\n+-- type, but contains just the empty list. The 'V1' instance ensures that we\n+-- can call the generic function on such types.\n+--\n+-- There is exactly one value of type 'U1', so encoding it requires no\n+-- knowledge, and we can use zero bits:\n+--\n+-- @\n+-- instance Encode' 'U1' where\n+--   encode' 'U1' = []\n+-- @\n+--\n+-- In the case for ':+:', we produce 'False' or 'True' depending on whether\n+-- the constructor of the value provided is located on the left or on the right:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':+:' g) where\n+--   encode' ('L1' x) = False : encode' x\n+--   encode' ('R1' x) = True  : encode' x\n+-- @\n+--\n+-- (Note that this encoding strategy may not be reliable across different\n+-- versions of GHC. Recall that the compiler is free to choose any nesting\n+-- of ':+:' it chooses, so if GHC chooses @(a ':+:' b) ':+:' c@, then the\n+-- encoding for @a@ would be @[False, False]@, @b@ would be @[False, True]@,\n+-- and @c@ would be @[True]@. However, if GHC chooses @a ':+:' (b ':+:' c)@,\n+-- then the encoding for @a@ would be @[False]@, @b@ would be @[True, False]@,\n+-- and @c@ would be @[True, True]@.)\n+--\n+-- In the case for ':*:', we append the encodings of the two subcomponents:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':*:' g) where\n+--   encode' (x ':*:' y) = encode' x ++ encode' y\n+-- @\n+--\n+-- The case for 'K1' is rather interesting. Here, we call the final function\n+-- @encode@ that we yet have to define, recursively. We will use another type\n+-- class @Encode@ for that function:\n+--\n+-- @\n+-- instance (Encode c) => Encode' ('K1' i c) where\n+--   encode' ('K1' x) = encode x\n+-- @\n+--\n+-- Note how we can define a uniform instance for 'M1', because we completely\n+-- disregard all meta-information:\n+--\n+-- @\n+-- instance (Encode' f) => Encode' ('M1' i t f) where\n+--   encode' ('M1' x) = encode' x\n+-- @\n+--\n+-- Unlike in 'K1', the instance for 'M1' refers to @encode'@, not @encode@.\n+\n+-- *** The wrapper and generic default\n+--\n+-- |\n+--\n+-- We now define class @Encode@ for the actual @encode@ function:\n+--\n+-- @\n+-- class Encode a where\n+--   encode :: a -> [Bool]\n+--   default encode :: (Generic a, Encode' (Rep a)) => a -> [Bool]\n+--   encode x = encode' ('from' x)\n+-- @\n+--\n+-- The incoming @x@ is converted using 'from', then we dispatch to the\n+-- generic instances using @encode'@. We use this as a default definition\n+-- for @encode@. We need the @default encode@ signature because ordinary\n+-- Haskell default methods must not introduce additional class constraints,\n+-- but our generic default does.\n+--\n+-- Defining a particular instance is now as simple as saying\n+--\n+-- @\n+-- instance (Encode a) => Encode (Tree a)\n+-- @\n+--\n+-- #if 0\n+-- /TODO:/ Add usage example?\n+--\n+-- #endif\n+-- The generic default is being used. In the future, it will hopefully be\n+-- possible to use @deriving Encode@ as well, but GHC does not yet support\n+-- that syntax for this situation.\n+--\n+-- Having @Encode@ as a class has the advantage that we can define\n+-- non-generic special cases, which is particularly useful for abstract\n+-- datatypes that have no structural representation. For example, given\n+-- a suitable integer encoding function @encodeInt@, we can define\n+--\n+-- @\n+-- instance Encode Int where\n+--   encode = encodeInt\n+-- @\n+\n+-- *** Omitting generic instances\n+--\n+-- |\n+--\n+-- It is not always required to provide instances for all the generic\n+-- representation types, but omitting instances restricts the set of\n+-- datatypes the functions will work for:\n+--\n+--    * If no ':+:' instance is given, the function may still work for\n+--      empty datatypes or datatypes that have a single constructor,\n+--      but will fail on datatypes with more than one constructor.\n+--\n+--    * If no ':*:' instance is given, the function may still work for\n+--      datatypes where each constructor has just zero or one field,\n+--      in particular for enumeration types.\n+--\n+--    * If no 'K1' instance is given, the function may still work for\n+--      enumeration types, where no constructor has any fields.\n+--\n+--    * If no 'V1' instance is given, the function may still work for\n+--      any datatype that is not empty.\n+--\n+--    * If no 'U1' instance is given, the function may still work for\n+--      any datatype where each constructor has at least one field.\n+--\n+-- An 'M1' instance is always required (but it can just ignore the\n+-- meta-information, as is the case for @encode@ above).\n+-- #if 0\n+-- *** Using meta-information\n+--\n+-- |\n+--\n+-- TODO\n+-- #endif\n+-- ** Generic constructor classes\n+--\n+-- |\n+--\n+-- Datatype-generic functions as defined above work for a large class\n+-- of datatypes, including parameterized datatypes. (We have used @Tree@\n+-- as our example above, which is of kind @* -> *@.) However, the\n+-- 'Generic' class ranges over types of kind @*@, and therefore, the\n+-- resulting generic functions (such as @encode@) must be parameterized\n+-- by a generic type argument of kind @*@.\n+--\n+-- What if we want to define generic classes that range over type\n+-- constructors (such as 'Data.Functor.Functor',\n+-- 'Data.Traversable.Traversable', or 'Data.Foldable.Foldable')?\n+\n+-- *** The 'Generic1' class\n+--\n+-- |\n+--\n+-- Like 'Generic', there is a class 'Generic1' that defines a\n+-- representation 'Rep1' and conversion functions 'from1' and 'to1',\n+-- only that 'Generic1' ranges over types of kind @* -> *@. (More generally,\n+-- it can range over types of kind @k -> *@, for any kind @k@, if the\n+-- @PolyKinds@ extension is enabled. More on this later.)\n+-- The 'Generic1' class is also derivable.\n+--\n+-- The representation 'Rep1' is ever so slightly different from 'Rep'.\n+-- Let us look at @Tree@ as an example again:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- The above declaration causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic1' Tree where\n+--   type 'Rep1' Tree =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                'Par1')\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)))\n+--   ...\n+-- @\n+--\n+-- The representation reuses 'D1', 'C1', 'S1' (and thereby 'M1') as well\n+-- as ':+:' and ':*:' from 'Rep'. (This reusability is the reason that we\n+-- carry around the dummy type argument for kind-@*@-types, but there are\n+-- already enough different names involved without duplicating each of\n+-- these.)\n+--\n+-- What's different is that we now use 'Par1' to refer to the parameter\n+-- (and that parameter, which used to be @a@), is not mentioned explicitly\n+-- by name anywhere; and we use 'Rec1' to refer to a recursive use of @Tree a@.\n+\n+-- *** Representation of @* -> *@ types\n+--\n+-- |\n+--\n+-- Unlike 'Rec0', the 'Par1' and 'Rec1' type constructors do not\n+-- map to 'K1'. They are defined directly, as follows:\n+--\n+-- @\n+-- newtype 'Par1'   p = 'Par1' { 'unPar1' ::   p } -- gives access to parameter p\n+-- newtype 'Rec1' f p = 'Rec1' { 'unRec1' :: f p } -- a wrapper\n+-- @\n+--\n+-- In 'Par1', the parameter @p@ is used for the first time, whereas 'Rec1' simply\n+-- wraps an application of @f@ to @p@.\n+--\n+-- Note that 'K1' (in the guise of 'Rec0') can still occur in a 'Rep1' representation,\n+-- namely when the datatype has a field that does not mention the parameter.\n+--\n+-- The declaration\n+--\n+-- @\n+-- data WithInt a = WithInt Int a\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' WithInt where\n+--   type 'Rep1' WithInt =\n+--     'D1' ('MetaData \\\"WithInt\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"WithInt\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               ('Rec0' Int)\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               'Par1'))\n+-- @\n+--\n+-- If the parameter @a@ appears underneath a composition of other type constructors,\n+-- then the representation involves composition, too:\n+--\n+-- @\n+-- data Rose a = Fork a [Rose a]\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' Rose where\n+--   type 'Rep1' Rose =\n+--     'D1' ('MetaData \\\"Rose\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Fork\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'Par1'\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               ([] ':.:' 'Rec1' Rose)))\n+-- @\n+--\n+-- where\n+--\n+-- @\n+-- newtype (':.:') f g p = 'Comp1' { 'unComp1' :: f (g p) }\n+-- @\n+\n+-- *** Representation of @k -> *@ types\n+--\n+-- |\n+--\n+-- The 'Generic1' class can be generalized to range over types of kind\n+-- @k -> *@, for any kind @k@. To do so, derive a 'Generic1' instance with the\n+-- @PolyKinds@ extension enabled. For example, the declaration\n+--\n+-- @\n+-- data Proxy (a :: k) = Proxy deriving 'Generic1'\n+-- @\n+--\n+-- yields a slightly different instance depending on whether @PolyKinds@ is\n+-- enabled. If compiled without @PolyKinds@, then @'Rep1' Proxy :: * -> *@, but\n+-- if compiled with @PolyKinds@, then @'Rep1' Proxy :: k -> *@.\n+\n+-- *** Representation of unlifted types\n+--\n+-- |\n+--\n+-- If one were to attempt to derive a Generic instance for a datatype with an\n+-- unlifted argument (for example, 'Int#'), one might expect the occurrence of\n+-- the 'Int#' argument to be marked with @'Rec0' 'Int#'@. This won't work,\n+-- though, since 'Int#' is of an unlifted kind, and 'Rec0' expects a type of\n+-- kind @*@.\n+--\n+-- One solution would be to represent an occurrence of 'Int#' with 'Rec0 Int'\n+-- instead. With this approach, however, the programmer has no way of knowing\n+-- whether the 'Int' is actually an 'Int#' in disguise.\n+--\n+-- Instead of reusing 'Rec0', a separate data family 'URec' is used to mark\n+-- occurrences of common unlifted types:\n+--\n+-- @\n+-- data family URec a p\n+--\n+-- data instance 'URec' ('Ptr' ()) p = 'UAddr'   { 'uAddr#'   :: 'Addr#'   }\n+-- data instance 'URec' 'Char'     p = 'UChar'   { 'uChar#'   :: 'Char#'   }\n+-- data instance 'URec' 'Double'   p = 'UDouble' { 'uDouble#' :: 'Double#' }\n+-- data instance 'URec' 'Int'      p = 'UFloat'  { 'uFloat#'  :: 'Float#'  }\n+-- data instance 'URec' 'Float'    p = 'UInt'    { 'uInt#'    :: 'Int#'    }\n+-- data instance 'URec' 'Word'     p = 'UWord'   { 'uWord#'   :: 'Word#'   }\n+-- @\n+--\n+-- Several type synonyms are provided for convenience:\n+--\n+-- @\n+-- type 'UAddr'   = 'URec' ('Ptr' ())\n+-- type 'UChar'   = 'URec' 'Char'\n+-- type 'UDouble' = 'URec' 'Double'\n+-- type 'UFloat'  = 'URec' 'Float'\n+-- type 'UInt'    = 'URec' 'Int'\n+-- type 'UWord'   = 'URec' 'Word'\n+-- @\n+--\n+-- The declaration\n+--\n+-- @\n+-- data IntHash = IntHash Int#\n+--   deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' IntHash where\n+--   type 'Rep' IntHash =\n+--     'D1' ('MetaData \\\"IntHash\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"IntHash\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'UInt'))\n+-- @\n+--\n+-- Currently, only the six unlifted types listed above are generated, but this\n+-- may be extended to encompass more unlifted types in the future.\n+-- #if 0\n+-- *** Limitations\n+--\n+-- |\n+--\n+-- /TODO/\n+--\n+-- /TODO:/ Also clear up confusion about 'Rec0' and 'Rec1' not really indicating recursion.\n+--\n+-- #endif\n+-----------------------------------------------------------------------------\n+\n+  -- * Generic representation types\n+    V1, U1(..), Par1(..), Rec1(..), K1(..), M1(..)\n+  , (:+:)(..), (:*:)(..), (:.:)(..)\n+\n+  -- ** Unboxed representation types\n+  --, URec(..)\n+  --, type UAddr, type UChar, type UDouble\n+  --, type UFloat, type UInt, type UWord\n+\n+  -- ** Synonyms for convenience\n+  , Rec0, R\n+  , D1, C1, S1, D, C, S\n+\n+  -- * Meta-information\n+  -- , Datatype(..), Constructor(..), Selector(..)\n+  , Fixity(..), FixityI(..), Associativity(..), prec\n+  , SourceUnpackedness(..), SourceStrictness(..), DecidedStrictness(..)\n+  , Meta(..)\n+\n+  -- * Generic type classes\n+  , Generic(..), Generic1(..)\n+\n+  ) where\n+\n+-- We use some base types\n+-- import Data.Either ( Either (..) )\n+-- import Data.Maybe  ( Maybe(..))\n+-- import Data.Ord    ( Down(..) )\n+-- import GHC.Integer ( Integer, integerToInt )\n+-- import GHC.Prim    ( Addr#, Char#, Double#, Float#, Int#, Word# )\n+-- import GHC.Ptr     ( Ptr )\n+import GHC.Types\n+\n+-- Needed for instances\n+-- import GHC.Arr     ( Ix )\n+-- import GHC.Base    ( Alternative(..), Applicative(..), Functor(..)\n+--                   , Monad(..), MonadPlus(..), NonEmpty(..), String, coerce\n+--                   , Semigroup(..), Monoid(..) )\n+import GHC.Classes ( Eq(..), Ord(..) )\n+import GHC.Enum    ( Bounded, Enum )\n+-- import GHC.Read    ( Read(..) )\n+import GHC.Show    ( Show(..), showString )\n+\n+-- Needed for metadata\n+-- import Data.Proxy   ( Proxy(..) )\n+-- import GHC.TypeLits ( KnownSymbol, KnownNat, symbolVal, natVal )\n+\n+import GHC.CString (fromString)\n+import GHC.Integer.Type (fromInteger)\n+import Control.Exception.Base\n+\n+-- | The kind of types with values. For example @Int :: Type@.\n+-- [DA] copied from ghc-prim/GHC/Types.hs. Usually set to\n+-- type Type = TYPE 'LiftedRep, but we only have one representation.\n+type Type = *\n+\n+ --------------------------------------------------------------------------------\n+-- Representation types\n+--------------------------------------------------------------------------------\n+\n+-- | Void: used for datatypes without constructors\n+data V1 (p :: k)\n+  deriving ( Eq       -- ^ @since 4.9.0.0\n+           , Ord      -- ^ @since 4.9.0.0\n+--           , Read     -- ^ @since 4.9.0.0\n+           , Show     -- ^ @since 4.9.0.0\n+--           , Functor  -- ^ @since 4.9.0.0\n+--           , Generic  -- ^ @since 4.9.0.0\n+--           , Generic1 -- ^ @since 4.9.0.0\n+           )\n+\n+-- | @since 4.12.0.0\n+-- instance Semigroup (V1 p) where\n+--   v <> _ = v"
  },
  {
    "id" : "faf30d3a-8ce5-4c96-a547-506f28e0b5a5",
    "prId" : 1276,
    "comments" : [
      {
        "id" : "5e06998e-94ce-48c8-a43d-fe2238b18f75",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Why not?",
        "createdAt" : "2019-05-21T09:52:22Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "154108f2d80e8a6a0655396865f94a7f0d295cc4",
    "line" : 808,
    "diffHunk" : "@@ -0,0 +1,1685 @@\n+{-# LANGUAGE DataKinds                  #-}\n+{-# LANGUAGE DeriveFunctor              #-}\n+{-# LANGUAGE DeriveGeneric              #-}\n+{-# LANGUAGE EmptyDataDeriving          #-}\n+{-# LANGUAGE FlexibleContexts           #-}\n+{-# LANGUAGE FlexibleInstances          #-}\n+{-# LANGUAGE GADTs                      #-}\n+{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n+{-# LANGUAGE KindSignatures             #-}\n+{-# LANGUAGE MagicHash                  #-}\n+{-# LANGUAGE NoImplicitPrelude          #-}\n+{-# LANGUAGE PolyKinds                  #-}\n+{-# LANGUAGE ScopedTypeVariables        #-}\n+{-# LANGUAGE StandaloneDeriving         #-}\n+{-# LANGUAGE Trustworthy                #-}\n+{-# LANGUAGE TypeOperators              #-}\n+{-# LANGUAGE TypeSynonymInstances       #-}\n+{-# LANGUAGE UndecidableInstances       #-}\n+{-# LANGUAGE NoNewColonConvention       #-}\n+\n+daml 1.2\n+-----------------------------------------------------------------------------\n+-- |\n+-- Module      :  GHC.Generics\n+-- Copyright   :  (c) Universiteit Utrecht 2010-2011, University of Oxford 2012-2014\n+-- License     :  see libraries/base/LICENSE\n+--\n+-- Maintainer  :  libraries@haskell.org\n+-- Stability   :  internal\n+-- Portability :  non-portable\n+--\n+-- @since 4.6.0.0\n+--\n+-- If you're using @GHC.Generics@, you should consider using the\n+-- <http://hackage.haskell.org/package/generic-deriving> package, which\n+-- contains many useful generic functions.\n+\n+module GHC.Generics (\n+-- * Introduction\n+--\n+-- |\n+--\n+-- Datatype-generic functions are based on the idea of converting values of\n+-- a datatype @T@ into corresponding values of a (nearly) isomorphic type @'Rep' T@.\n+-- The type @'Rep' T@ is\n+-- built from a limited set of type constructors, all provided by this module. A\n+-- datatype-generic function is then an overloaded function with instances\n+-- for most of these type constructors, together with a wrapper that performs\n+-- the mapping between @T@ and @'Rep' T@. By using this technique, we merely need\n+-- a few generic instances in order to implement functionality that works for any\n+-- representable type.\n+--\n+-- Representable types are collected in the 'Generic' class, which defines the\n+-- associated type 'Rep' as well as conversion functions 'from' and 'to'.\n+-- Typically, you will not define 'Generic' instances by hand, but have the compiler\n+-- derive them for you.\n+\n+-- ** Representing datatypes\n+--\n+-- |\n+--\n+-- The key to defining your own datatype-generic functions is to understand how to\n+-- represent datatypes using the given set of type constructors.\n+--\n+-- Let us look at an example first:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic'\n+-- @\n+--\n+-- The above declaration (which requires the language pragma @DeriveGeneric@)\n+-- causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                 ('Rec0' a))\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))))\n+--   ...\n+-- @\n+--\n+-- /Hint:/ You can obtain information about the code being generated from GHC by passing\n+-- the @-ddump-deriv@ flag. In GHCi, you can expand a type family such as 'Rep' using\n+-- the @:kind!@ command.\n+--\n+-- This is a lot of information! However, most of it is actually merely meta-information\n+-- that makes names of datatypes and constructors and more available on the type level.\n+--\n+-- Here is a reduced representation for @Tree@ with nearly all meta-information removed,\n+-- for now keeping only the most essential aspects:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'Rec0' a\n+--     ':+:'\n+--     ('Rec0' (Tree a) ':*:' 'Rec0' (Tree a))\n+-- @\n+--\n+-- The @Tree@ datatype has two constructors. The representation of individual constructors\n+-- is combined using the binary type constructor ':+:'.\n+--\n+-- The first constructor consists of a single field, which is the parameter @a@. This is\n+-- represented as @'Rec0' a@.\n+--\n+-- The second constructor consists of two fields. Each is a recursive field of type @Tree a@,\n+-- represented as @'Rec0' (Tree a)@. Representations of individual fields are combined using\n+-- the binary type constructor ':*:'.\n+--\n+-- Now let us explain the additional tags being used in the complete representation:\n+--\n+--    * The @'S1' ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness\n+--      'DecidedLazy)@ tag indicates several things. The @'Nothing@ indicates\n+--      that there is no record field selector associated with this field of\n+--      the constructor (if there were, it would have been marked @'Just\n+--      \\\"recordName\\\"@ instead). The other types contain meta-information on\n+--      the field's strictness:\n+--\n+--      * There is no @{\\-\\# UNPACK \\#-\\}@ or @{\\-\\# NOUNPACK \\#-\\}@ annotation\n+--        in the source, so it is tagged with @'NoSourceUnpackedness@.\n+--\n+--      * There is no strictness (@!@) or laziness (@~@) annotation in the\n+--        source, so it is tagged with @'NoSourceStrictness@.\n+--\n+--      * The compiler infers that the field is lazy, so it is tagged with\n+--        @'DecidedLazy@. Bear in mind that what the compiler decides may be\n+--        quite different from what is written in the source. See\n+--        'DecidedStrictness' for a more detailed explanation.\n+--\n+--      The @'MetaSel@ type is also an instance of the type class 'Selector',\n+--      which can be used to obtain information about the field at the value\n+--      level.\n+--\n+--    * The @'C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)@ and\n+--      @'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)@ invocations indicate that the enclosed part is\n+--      the representation of the first and second constructor of datatype @Tree@, respectively.\n+--      Here, the meta-information regarding constructor names, fixity and whether\n+--      it has named fields or not is encoded at the type level. The @'MetaCons@\n+--      type is also an instance of the type class 'Constructor'. This type class can be used\n+--      to obtain information about the constructor at the value level.\n+--\n+--    * The @'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)@ tag\n+--      indicates that the enclosed part is the representation of the\n+--      datatype @Tree@. Again, the meta-information is encoded at the type level.\n+--      The @'MetaData@ type is an instance of class 'Datatype', which\n+--      can be used to obtain the name of a datatype, the module it has been\n+--      defined in, the package it is located under, and whether it has been\n+--      defined using @data@ or @newtype@ at the value level.\n+\n+-- ** Derived and fundamental representation types\n+--\n+-- |\n+--\n+-- There are many datatype-generic functions that do not distinguish between positions that\n+-- are parameters or positions that are recursive calls. There are also many datatype-generic\n+-- functions that do not care about the names of datatypes and constructors at all. To keep\n+-- the number of cases to consider in generic functions in such a situation to a minimum,\n+-- it turns out that many of the type constructors introduced above are actually synonyms,\n+-- defining them to be variants of a smaller set of constructors.\n+\n+-- *** Individual fields of constructors: 'K1'\n+--\n+-- |\n+--\n+-- The type constructor 'Rec0' is a variant of 'K1':\n+--\n+-- @\n+-- type 'Rec0' = 'K1' 'R'\n+-- @\n+--\n+-- Here, 'R' is a type-level proxy that does not have any associated values.\n+--\n+-- There used to be another variant of 'K1' (namely @Par0@), but it has since\n+-- been deprecated.\n+\n+-- *** Meta information: 'M1'\n+--\n+-- |\n+--\n+-- The type constructors 'S1', 'C1' and 'D1' are all variants of 'M1':\n+--\n+-- @\n+-- type 'S1' = 'M1' 'S'\n+-- type 'C1' = 'M1' 'C'\n+-- type 'D1' = 'M1' 'D'\n+-- @\n+--\n+-- The types 'S', 'C' and 'D' are once again type-level proxies, just used to create\n+-- several variants of 'M1'.\n+\n+-- *** Additional generic representation type constructors\n+--\n+-- |\n+--\n+-- Next to 'K1', 'M1', ':+:' and ':*:' there are a few more type constructors that occur\n+-- in the representations of other datatypes.\n+\n+-- **** Empty datatypes: 'V1'\n+--\n+-- |\n+--\n+-- For empty datatypes, 'V1' is used as a representation. For example,\n+--\n+-- @\n+-- data Empty deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' Empty where\n+--   type 'Rep' Empty =\n+--     'D1' ('MetaData \\\"Empty\\\" \\\"Main\\\" \\\"package-name\\\" 'False) 'V1'\n+-- @\n+\n+-- **** Constructors without fields: 'U1'\n+--\n+-- |\n+--\n+-- If a constructor has no arguments, then 'U1' is used as its representation. For example\n+-- the representation of 'Bool' is\n+--\n+-- @\n+-- instance 'Generic' Bool where\n+--   type 'Rep' Bool =\n+--     'D1' ('MetaData \\\"Bool\\\" \\\"Data.Bool\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"False\\\" 'PrefixI 'False) 'U1' ':+:' 'C1' ('MetaCons \\\"True\\\" 'PrefixI 'False) 'U1')\n+-- @\n+\n+-- *** Representation of types with many constructors or many fields\n+--\n+-- |\n+--\n+-- As ':+:' and ':*:' are just binary operators, one might ask what happens if the\n+-- datatype has more than two constructors, or a constructor with more than two\n+-- fields. The answer is simple: the operators are used several times, to combine\n+-- all the constructors and fields as needed. However, users /should not rely on\n+-- a specific nesting strategy/ for ':+:' and ':*:' being used. The compiler is\n+-- free to choose any nesting it prefers. (In practice, the current implementation\n+-- tries to produce a more-or-less balanced nesting, so that the traversal of\n+-- the structure of the datatype from the root to a particular component can be\n+-- performed in logarithmic rather than linear time.)\n+\n+-- ** Defining datatype-generic functions\n+--\n+-- |\n+--\n+-- A datatype-generic function comprises two parts:\n+--\n+--    1. /Generic instances/ for the function, implementing it for most of the representation\n+--       type constructors introduced above.\n+--\n+--    2. A /wrapper/ that for any datatype that is in `Generic`, performs the conversion\n+--       between the original value and its `Rep`-based representation and then invokes the\n+--       generic instances.\n+--\n+-- As an example, let us look at a function @encode@ that produces a naive, but lossless\n+-- bit encoding of values of various datatypes. So we are aiming to define a function\n+--\n+-- @\n+-- encode :: 'Generic' a => a -> [Bool]\n+-- @\n+--\n+-- where we use 'Bool' as our datatype for bits.\n+--\n+-- For part 1, we define a class @Encode'@. Perhaps surprisingly, this class is parameterized\n+-- over a type constructor @f@ of kind @* -> *@. This is a technicality: all the representation\n+-- type constructors operate with kind @* -> *@ as base kind. But the type argument is never\n+-- being used. This may be changed at some point in the future. The class has a single method,\n+-- and we use the type we want our final function to have, but we replace the occurrences of\n+-- the generic type argument @a@ with @f p@ (where the @p@ is any argument; it will not be used).\n+--\n+-- > class Encode' f where\n+-- >   encode' :: f p -> [Bool]\n+--\n+-- With the goal in mind to make @encode@ work on @Tree@ and other datatypes, we now define\n+-- instances for the representation type constructors 'V1', 'U1', ':+:', ':*:', 'K1', and 'M1'.\n+\n+-- *** Definition of the generic representation types\n+--\n+-- |\n+--\n+-- In order to be able to do this, we need to know the actual definitions of these types:\n+--\n+-- @\n+-- data    'V1'        p                       -- lifted version of Empty\n+-- data    'U1'        p = 'U1'                  -- lifted version of ()\n+-- data    (':+:') f g p = 'L1' (f p) | 'R1' (g p) -- lifted version of 'Either'\n+-- data    (':*:') f g p = (f p) ':*:' (g p)     -- lifted version of (,)\n+-- newtype 'K1'    i c p = 'K1' { 'unK1' :: c }    -- a container for a c\n+-- newtype 'M1'  i t f p = 'M1' { 'unM1' :: f p }  -- a wrapper\n+-- @\n+--\n+-- So, 'U1' is just the unit type, ':+:' is just a binary choice like 'Either',\n+-- ':*:' is a binary pair like the pair constructor @(,)@, and 'K1' is a value\n+-- of a specific type @c@, and 'M1' wraps a value of the generic type argument,\n+-- which in the lifted world is an @f p@ (where we do not care about @p@).\n+\n+-- *** Generic instances\n+--\n+-- |\n+--\n+-- The instance for 'V1' is slightly awkward (but also rarely used):\n+--\n+-- @\n+-- instance Encode' 'V1' where\n+--   encode' x = undefined\n+-- @\n+--\n+-- There are no values of type @V1 p@ to pass (except undefined), so this is\n+-- actually impossible. One can ask why it is useful to define an instance for\n+-- 'V1' at all in this case? Well, an empty type can be used as an argument to\n+-- a non-empty type, and you might still want to encode the resulting type.\n+-- As a somewhat contrived example, consider @[Empty]@, which is not an empty\n+-- type, but contains just the empty list. The 'V1' instance ensures that we\n+-- can call the generic function on such types.\n+--\n+-- There is exactly one value of type 'U1', so encoding it requires no\n+-- knowledge, and we can use zero bits:\n+--\n+-- @\n+-- instance Encode' 'U1' where\n+--   encode' 'U1' = []\n+-- @\n+--\n+-- In the case for ':+:', we produce 'False' or 'True' depending on whether\n+-- the constructor of the value provided is located on the left or on the right:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':+:' g) where\n+--   encode' ('L1' x) = False : encode' x\n+--   encode' ('R1' x) = True  : encode' x\n+-- @\n+--\n+-- (Note that this encoding strategy may not be reliable across different\n+-- versions of GHC. Recall that the compiler is free to choose any nesting\n+-- of ':+:' it chooses, so if GHC chooses @(a ':+:' b) ':+:' c@, then the\n+-- encoding for @a@ would be @[False, False]@, @b@ would be @[False, True]@,\n+-- and @c@ would be @[True]@. However, if GHC chooses @a ':+:' (b ':+:' c)@,\n+-- then the encoding for @a@ would be @[False]@, @b@ would be @[True, False]@,\n+-- and @c@ would be @[True, True]@.)\n+--\n+-- In the case for ':*:', we append the encodings of the two subcomponents:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':*:' g) where\n+--   encode' (x ':*:' y) = encode' x ++ encode' y\n+-- @\n+--\n+-- The case for 'K1' is rather interesting. Here, we call the final function\n+-- @encode@ that we yet have to define, recursively. We will use another type\n+-- class @Encode@ for that function:\n+--\n+-- @\n+-- instance (Encode c) => Encode' ('K1' i c) where\n+--   encode' ('K1' x) = encode x\n+-- @\n+--\n+-- Note how we can define a uniform instance for 'M1', because we completely\n+-- disregard all meta-information:\n+--\n+-- @\n+-- instance (Encode' f) => Encode' ('M1' i t f) where\n+--   encode' ('M1' x) = encode' x\n+-- @\n+--\n+-- Unlike in 'K1', the instance for 'M1' refers to @encode'@, not @encode@.\n+\n+-- *** The wrapper and generic default\n+--\n+-- |\n+--\n+-- We now define class @Encode@ for the actual @encode@ function:\n+--\n+-- @\n+-- class Encode a where\n+--   encode :: a -> [Bool]\n+--   default encode :: (Generic a, Encode' (Rep a)) => a -> [Bool]\n+--   encode x = encode' ('from' x)\n+-- @\n+--\n+-- The incoming @x@ is converted using 'from', then we dispatch to the\n+-- generic instances using @encode'@. We use this as a default definition\n+-- for @encode@. We need the @default encode@ signature because ordinary\n+-- Haskell default methods must not introduce additional class constraints,\n+-- but our generic default does.\n+--\n+-- Defining a particular instance is now as simple as saying\n+--\n+-- @\n+-- instance (Encode a) => Encode (Tree a)\n+-- @\n+--\n+-- #if 0\n+-- /TODO:/ Add usage example?\n+--\n+-- #endif\n+-- The generic default is being used. In the future, it will hopefully be\n+-- possible to use @deriving Encode@ as well, but GHC does not yet support\n+-- that syntax for this situation.\n+--\n+-- Having @Encode@ as a class has the advantage that we can define\n+-- non-generic special cases, which is particularly useful for abstract\n+-- datatypes that have no structural representation. For example, given\n+-- a suitable integer encoding function @encodeInt@, we can define\n+--\n+-- @\n+-- instance Encode Int where\n+--   encode = encodeInt\n+-- @\n+\n+-- *** Omitting generic instances\n+--\n+-- |\n+--\n+-- It is not always required to provide instances for all the generic\n+-- representation types, but omitting instances restricts the set of\n+-- datatypes the functions will work for:\n+--\n+--    * If no ':+:' instance is given, the function may still work for\n+--      empty datatypes or datatypes that have a single constructor,\n+--      but will fail on datatypes with more than one constructor.\n+--\n+--    * If no ':*:' instance is given, the function may still work for\n+--      datatypes where each constructor has just zero or one field,\n+--      in particular for enumeration types.\n+--\n+--    * If no 'K1' instance is given, the function may still work for\n+--      enumeration types, where no constructor has any fields.\n+--\n+--    * If no 'V1' instance is given, the function may still work for\n+--      any datatype that is not empty.\n+--\n+--    * If no 'U1' instance is given, the function may still work for\n+--      any datatype where each constructor has at least one field.\n+--\n+-- An 'M1' instance is always required (but it can just ignore the\n+-- meta-information, as is the case for @encode@ above).\n+-- #if 0\n+-- *** Using meta-information\n+--\n+-- |\n+--\n+-- TODO\n+-- #endif\n+-- ** Generic constructor classes\n+--\n+-- |\n+--\n+-- Datatype-generic functions as defined above work for a large class\n+-- of datatypes, including parameterized datatypes. (We have used @Tree@\n+-- as our example above, which is of kind @* -> *@.) However, the\n+-- 'Generic' class ranges over types of kind @*@, and therefore, the\n+-- resulting generic functions (such as @encode@) must be parameterized\n+-- by a generic type argument of kind @*@.\n+--\n+-- What if we want to define generic classes that range over type\n+-- constructors (such as 'Data.Functor.Functor',\n+-- 'Data.Traversable.Traversable', or 'Data.Foldable.Foldable')?\n+\n+-- *** The 'Generic1' class\n+--\n+-- |\n+--\n+-- Like 'Generic', there is a class 'Generic1' that defines a\n+-- representation 'Rep1' and conversion functions 'from1' and 'to1',\n+-- only that 'Generic1' ranges over types of kind @* -> *@. (More generally,\n+-- it can range over types of kind @k -> *@, for any kind @k@, if the\n+-- @PolyKinds@ extension is enabled. More on this later.)\n+-- The 'Generic1' class is also derivable.\n+--\n+-- The representation 'Rep1' is ever so slightly different from 'Rep'.\n+-- Let us look at @Tree@ as an example again:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- The above declaration causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic1' Tree where\n+--   type 'Rep1' Tree =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                'Par1')\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)))\n+--   ...\n+-- @\n+--\n+-- The representation reuses 'D1', 'C1', 'S1' (and thereby 'M1') as well\n+-- as ':+:' and ':*:' from 'Rep'. (This reusability is the reason that we\n+-- carry around the dummy type argument for kind-@*@-types, but there are\n+-- already enough different names involved without duplicating each of\n+-- these.)\n+--\n+-- What's different is that we now use 'Par1' to refer to the parameter\n+-- (and that parameter, which used to be @a@), is not mentioned explicitly\n+-- by name anywhere; and we use 'Rec1' to refer to a recursive use of @Tree a@.\n+\n+-- *** Representation of @* -> *@ types\n+--\n+-- |\n+--\n+-- Unlike 'Rec0', the 'Par1' and 'Rec1' type constructors do not\n+-- map to 'K1'. They are defined directly, as follows:\n+--\n+-- @\n+-- newtype 'Par1'   p = 'Par1' { 'unPar1' ::   p } -- gives access to parameter p\n+-- newtype 'Rec1' f p = 'Rec1' { 'unRec1' :: f p } -- a wrapper\n+-- @\n+--\n+-- In 'Par1', the parameter @p@ is used for the first time, whereas 'Rec1' simply\n+-- wraps an application of @f@ to @p@.\n+--\n+-- Note that 'K1' (in the guise of 'Rec0') can still occur in a 'Rep1' representation,\n+-- namely when the datatype has a field that does not mention the parameter.\n+--\n+-- The declaration\n+--\n+-- @\n+-- data WithInt a = WithInt Int a\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' WithInt where\n+--   type 'Rep1' WithInt =\n+--     'D1' ('MetaData \\\"WithInt\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"WithInt\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               ('Rec0' Int)\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               'Par1'))\n+-- @\n+--\n+-- If the parameter @a@ appears underneath a composition of other type constructors,\n+-- then the representation involves composition, too:\n+--\n+-- @\n+-- data Rose a = Fork a [Rose a]\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' Rose where\n+--   type 'Rep1' Rose =\n+--     'D1' ('MetaData \\\"Rose\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Fork\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'Par1'\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               ([] ':.:' 'Rec1' Rose)))\n+-- @\n+--\n+-- where\n+--\n+-- @\n+-- newtype (':.:') f g p = 'Comp1' { 'unComp1' :: f (g p) }\n+-- @\n+\n+-- *** Representation of @k -> *@ types\n+--\n+-- |\n+--\n+-- The 'Generic1' class can be generalized to range over types of kind\n+-- @k -> *@, for any kind @k@. To do so, derive a 'Generic1' instance with the\n+-- @PolyKinds@ extension enabled. For example, the declaration\n+--\n+-- @\n+-- data Proxy (a :: k) = Proxy deriving 'Generic1'\n+-- @\n+--\n+-- yields a slightly different instance depending on whether @PolyKinds@ is\n+-- enabled. If compiled without @PolyKinds@, then @'Rep1' Proxy :: * -> *@, but\n+-- if compiled with @PolyKinds@, then @'Rep1' Proxy :: k -> *@.\n+\n+-- *** Representation of unlifted types\n+--\n+-- |\n+--\n+-- If one were to attempt to derive a Generic instance for a datatype with an\n+-- unlifted argument (for example, 'Int#'), one might expect the occurrence of\n+-- the 'Int#' argument to be marked with @'Rec0' 'Int#'@. This won't work,\n+-- though, since 'Int#' is of an unlifted kind, and 'Rec0' expects a type of\n+-- kind @*@.\n+--\n+-- One solution would be to represent an occurrence of 'Int#' with 'Rec0 Int'\n+-- instead. With this approach, however, the programmer has no way of knowing\n+-- whether the 'Int' is actually an 'Int#' in disguise.\n+--\n+-- Instead of reusing 'Rec0', a separate data family 'URec' is used to mark\n+-- occurrences of common unlifted types:\n+--\n+-- @\n+-- data family URec a p\n+--\n+-- data instance 'URec' ('Ptr' ()) p = 'UAddr'   { 'uAddr#'   :: 'Addr#'   }\n+-- data instance 'URec' 'Char'     p = 'UChar'   { 'uChar#'   :: 'Char#'   }\n+-- data instance 'URec' 'Double'   p = 'UDouble' { 'uDouble#' :: 'Double#' }\n+-- data instance 'URec' 'Int'      p = 'UFloat'  { 'uFloat#'  :: 'Float#'  }\n+-- data instance 'URec' 'Float'    p = 'UInt'    { 'uInt#'    :: 'Int#'    }\n+-- data instance 'URec' 'Word'     p = 'UWord'   { 'uWord#'   :: 'Word#'   }\n+-- @\n+--\n+-- Several type synonyms are provided for convenience:\n+--\n+-- @\n+-- type 'UAddr'   = 'URec' ('Ptr' ())\n+-- type 'UChar'   = 'URec' 'Char'\n+-- type 'UDouble' = 'URec' 'Double'\n+-- type 'UFloat'  = 'URec' 'Float'\n+-- type 'UInt'    = 'URec' 'Int'\n+-- type 'UWord'   = 'URec' 'Word'\n+-- @\n+--\n+-- The declaration\n+--\n+-- @\n+-- data IntHash = IntHash Int#\n+--   deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' IntHash where\n+--   type 'Rep' IntHash =\n+--     'D1' ('MetaData \\\"IntHash\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"IntHash\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'UInt'))\n+-- @\n+--\n+-- Currently, only the six unlifted types listed above are generated, but this\n+-- may be extended to encompass more unlifted types in the future.\n+-- #if 0\n+-- *** Limitations\n+--\n+-- |\n+--\n+-- /TODO/\n+--\n+-- /TODO:/ Also clear up confusion about 'Rec0' and 'Rec1' not really indicating recursion.\n+--\n+-- #endif\n+-----------------------------------------------------------------------------\n+\n+  -- * Generic representation types\n+    V1, U1(..), Par1(..), Rec1(..), K1(..), M1(..)\n+  , (:+:)(..), (:*:)(..), (:.:)(..)\n+\n+  -- ** Unboxed representation types\n+  --, URec(..)\n+  --, type UAddr, type UChar, type UDouble\n+  --, type UFloat, type UInt, type UWord\n+\n+  -- ** Synonyms for convenience\n+  , Rec0, R\n+  , D1, C1, S1, D, C, S\n+\n+  -- * Meta-information\n+  -- , Datatype(..), Constructor(..), Selector(..)\n+  , Fixity(..), FixityI(..), Associativity(..), prec\n+  , SourceUnpackedness(..), SourceStrictness(..), DecidedStrictness(..)\n+  , Meta(..)\n+\n+  -- * Generic type classes\n+  , Generic(..), Generic1(..)\n+\n+  ) where\n+\n+-- We use some base types\n+-- import Data.Either ( Either (..) )\n+-- import Data.Maybe  ( Maybe(..))\n+-- import Data.Ord    ( Down(..) )\n+-- import GHC.Integer ( Integer, integerToInt )\n+-- import GHC.Prim    ( Addr#, Char#, Double#, Float#, Int#, Word# )\n+-- import GHC.Ptr     ( Ptr )\n+import GHC.Types\n+\n+-- Needed for instances\n+-- import GHC.Arr     ( Ix )\n+-- import GHC.Base    ( Alternative(..), Applicative(..), Functor(..)\n+--                   , Monad(..), MonadPlus(..), NonEmpty(..), String, coerce\n+--                   , Semigroup(..), Monoid(..) )\n+import GHC.Classes ( Eq(..), Ord(..) )\n+import GHC.Enum    ( Bounded, Enum )\n+-- import GHC.Read    ( Read(..) )\n+import GHC.Show    ( Show(..), showString )\n+\n+-- Needed for metadata\n+-- import Data.Proxy   ( Proxy(..) )\n+-- import GHC.TypeLits ( KnownSymbol, KnownNat, symbolVal, natVal )\n+\n+import GHC.CString (fromString)\n+import GHC.Integer.Type (fromInteger)\n+import Control.Exception.Base\n+\n+-- | The kind of types with values. For example @Int :: Type@.\n+-- [DA] copied from ghc-prim/GHC/Types.hs. Usually set to\n+-- type Type = TYPE 'LiftedRep, but we only have one representation.\n+type Type = *\n+\n+ --------------------------------------------------------------------------------\n+-- Representation types\n+--------------------------------------------------------------------------------\n+\n+-- | Void: used for datatypes without constructors\n+data V1 (p :: k)\n+  deriving ( Eq       -- ^ @since 4.9.0.0\n+           , Ord      -- ^ @since 4.9.0.0\n+--           , Read     -- ^ @since 4.9.0.0\n+           , Show     -- ^ @since 4.9.0.0\n+--           , Functor  -- ^ @since 4.9.0.0\n+--           , Generic  -- ^ @since 4.9.0.0\n+--           , Generic1 -- ^ @since 4.9.0.0\n+           )\n+\n+-- | @since 4.12.0.0\n+-- instance Semigroup (V1 p) where\n+--   v <> _ = v\n+\n+-- | Unit: used for constructors without arguments\n+data U1 (p :: k) = U1\n+--  deriving ( Generic  -- ^ @since 4.7.0.0\n+--           , Generic1 -- ^ @since 4.9.0.0\n+--           )\n+\n+-- | @since 4.9.0.0\n+instance Eq (U1 p) where\n+  _ == _ = True\n+\n+-- | @since 4.7.0.0\n+instance Ord (U1 p) where\n+  compare _ _ = EQ\n+\n+-- | @since 4.9.0.0\n+-- deriving instance Read (U1 p)\n+\n+-- | @since 4.9.0.0\n+instance Show (U1 p) where\n+  showsPrec _ _ = showString \"U1\"\n+\n+-- | @since 4.9.0.0\n+-- instance Functor U1 where"
  },
  {
    "id" : "05a5dfb8-8c61-468c-84e0-47a63ba1f583",
    "prId" : 1276,
    "comments" : [
      {
        "id" : "aa5e4131-d47d-43c8-b448-dd5a68832272",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Why not?",
        "createdAt" : "2019-05-21T09:52:28Z",
        "updatedAt" : "2019-05-23T15:51:59Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "154108f2d80e8a6a0655396865f94a7f0d295cc4",
    "line" : 812,
    "diffHunk" : "@@ -0,0 +1,1685 @@\n+{-# LANGUAGE DataKinds                  #-}\n+{-# LANGUAGE DeriveFunctor              #-}\n+{-# LANGUAGE DeriveGeneric              #-}\n+{-# LANGUAGE EmptyDataDeriving          #-}\n+{-# LANGUAGE FlexibleContexts           #-}\n+{-# LANGUAGE FlexibleInstances          #-}\n+{-# LANGUAGE GADTs                      #-}\n+{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n+{-# LANGUAGE KindSignatures             #-}\n+{-# LANGUAGE MagicHash                  #-}\n+{-# LANGUAGE NoImplicitPrelude          #-}\n+{-# LANGUAGE PolyKinds                  #-}\n+{-# LANGUAGE ScopedTypeVariables        #-}\n+{-# LANGUAGE StandaloneDeriving         #-}\n+{-# LANGUAGE Trustworthy                #-}\n+{-# LANGUAGE TypeOperators              #-}\n+{-# LANGUAGE TypeSynonymInstances       #-}\n+{-# LANGUAGE UndecidableInstances       #-}\n+{-# LANGUAGE NoNewColonConvention       #-}\n+\n+daml 1.2\n+-----------------------------------------------------------------------------\n+-- |\n+-- Module      :  GHC.Generics\n+-- Copyright   :  (c) Universiteit Utrecht 2010-2011, University of Oxford 2012-2014\n+-- License     :  see libraries/base/LICENSE\n+--\n+-- Maintainer  :  libraries@haskell.org\n+-- Stability   :  internal\n+-- Portability :  non-portable\n+--\n+-- @since 4.6.0.0\n+--\n+-- If you're using @GHC.Generics@, you should consider using the\n+-- <http://hackage.haskell.org/package/generic-deriving> package, which\n+-- contains many useful generic functions.\n+\n+module GHC.Generics (\n+-- * Introduction\n+--\n+-- |\n+--\n+-- Datatype-generic functions are based on the idea of converting values of\n+-- a datatype @T@ into corresponding values of a (nearly) isomorphic type @'Rep' T@.\n+-- The type @'Rep' T@ is\n+-- built from a limited set of type constructors, all provided by this module. A\n+-- datatype-generic function is then an overloaded function with instances\n+-- for most of these type constructors, together with a wrapper that performs\n+-- the mapping between @T@ and @'Rep' T@. By using this technique, we merely need\n+-- a few generic instances in order to implement functionality that works for any\n+-- representable type.\n+--\n+-- Representable types are collected in the 'Generic' class, which defines the\n+-- associated type 'Rep' as well as conversion functions 'from' and 'to'.\n+-- Typically, you will not define 'Generic' instances by hand, but have the compiler\n+-- derive them for you.\n+\n+-- ** Representing datatypes\n+--\n+-- |\n+--\n+-- The key to defining your own datatype-generic functions is to understand how to\n+-- represent datatypes using the given set of type constructors.\n+--\n+-- Let us look at an example first:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic'\n+-- @\n+--\n+-- The above declaration (which requires the language pragma @DeriveGeneric@)\n+-- causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                 ('Rec0' a))\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec0' (Tree a))))\n+--   ...\n+-- @\n+--\n+-- /Hint:/ You can obtain information about the code being generated from GHC by passing\n+-- the @-ddump-deriv@ flag. In GHCi, you can expand a type family such as 'Rep' using\n+-- the @:kind!@ command.\n+--\n+-- This is a lot of information! However, most of it is actually merely meta-information\n+-- that makes names of datatypes and constructors and more available on the type level.\n+--\n+-- Here is a reduced representation for @Tree@ with nearly all meta-information removed,\n+-- for now keeping only the most essential aspects:\n+--\n+-- @\n+-- instance 'Generic' (Tree a) where\n+--   type 'Rep' (Tree a) =\n+--     'Rec0' a\n+--     ':+:'\n+--     ('Rec0' (Tree a) ':*:' 'Rec0' (Tree a))\n+-- @\n+--\n+-- The @Tree@ datatype has two constructors. The representation of individual constructors\n+-- is combined using the binary type constructor ':+:'.\n+--\n+-- The first constructor consists of a single field, which is the parameter @a@. This is\n+-- represented as @'Rec0' a@.\n+--\n+-- The second constructor consists of two fields. Each is a recursive field of type @Tree a@,\n+-- represented as @'Rec0' (Tree a)@. Representations of individual fields are combined using\n+-- the binary type constructor ':*:'.\n+--\n+-- Now let us explain the additional tags being used in the complete representation:\n+--\n+--    * The @'S1' ('MetaSel 'Nothing 'NoSourceUnpackedness 'NoSourceStrictness\n+--      'DecidedLazy)@ tag indicates several things. The @'Nothing@ indicates\n+--      that there is no record field selector associated with this field of\n+--      the constructor (if there were, it would have been marked @'Just\n+--      \\\"recordName\\\"@ instead). The other types contain meta-information on\n+--      the field's strictness:\n+--\n+--      * There is no @{\\-\\# UNPACK \\#-\\}@ or @{\\-\\# NOUNPACK \\#-\\}@ annotation\n+--        in the source, so it is tagged with @'NoSourceUnpackedness@.\n+--\n+--      * There is no strictness (@!@) or laziness (@~@) annotation in the\n+--        source, so it is tagged with @'NoSourceStrictness@.\n+--\n+--      * The compiler infers that the field is lazy, so it is tagged with\n+--        @'DecidedLazy@. Bear in mind that what the compiler decides may be\n+--        quite different from what is written in the source. See\n+--        'DecidedStrictness' for a more detailed explanation.\n+--\n+--      The @'MetaSel@ type is also an instance of the type class 'Selector',\n+--      which can be used to obtain information about the field at the value\n+--      level.\n+--\n+--    * The @'C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)@ and\n+--      @'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)@ invocations indicate that the enclosed part is\n+--      the representation of the first and second constructor of datatype @Tree@, respectively.\n+--      Here, the meta-information regarding constructor names, fixity and whether\n+--      it has named fields or not is encoded at the type level. The @'MetaCons@\n+--      type is also an instance of the type class 'Constructor'. This type class can be used\n+--      to obtain information about the constructor at the value level.\n+--\n+--    * The @'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)@ tag\n+--      indicates that the enclosed part is the representation of the\n+--      datatype @Tree@. Again, the meta-information is encoded at the type level.\n+--      The @'MetaData@ type is an instance of class 'Datatype', which\n+--      can be used to obtain the name of a datatype, the module it has been\n+--      defined in, the package it is located under, and whether it has been\n+--      defined using @data@ or @newtype@ at the value level.\n+\n+-- ** Derived and fundamental representation types\n+--\n+-- |\n+--\n+-- There are many datatype-generic functions that do not distinguish between positions that\n+-- are parameters or positions that are recursive calls. There are also many datatype-generic\n+-- functions that do not care about the names of datatypes and constructors at all. To keep\n+-- the number of cases to consider in generic functions in such a situation to a minimum,\n+-- it turns out that many of the type constructors introduced above are actually synonyms,\n+-- defining them to be variants of a smaller set of constructors.\n+\n+-- *** Individual fields of constructors: 'K1'\n+--\n+-- |\n+--\n+-- The type constructor 'Rec0' is a variant of 'K1':\n+--\n+-- @\n+-- type 'Rec0' = 'K1' 'R'\n+-- @\n+--\n+-- Here, 'R' is a type-level proxy that does not have any associated values.\n+--\n+-- There used to be another variant of 'K1' (namely @Par0@), but it has since\n+-- been deprecated.\n+\n+-- *** Meta information: 'M1'\n+--\n+-- |\n+--\n+-- The type constructors 'S1', 'C1' and 'D1' are all variants of 'M1':\n+--\n+-- @\n+-- type 'S1' = 'M1' 'S'\n+-- type 'C1' = 'M1' 'C'\n+-- type 'D1' = 'M1' 'D'\n+-- @\n+--\n+-- The types 'S', 'C' and 'D' are once again type-level proxies, just used to create\n+-- several variants of 'M1'.\n+\n+-- *** Additional generic representation type constructors\n+--\n+-- |\n+--\n+-- Next to 'K1', 'M1', ':+:' and ':*:' there are a few more type constructors that occur\n+-- in the representations of other datatypes.\n+\n+-- **** Empty datatypes: 'V1'\n+--\n+-- |\n+--\n+-- For empty datatypes, 'V1' is used as a representation. For example,\n+--\n+-- @\n+-- data Empty deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' Empty where\n+--   type 'Rep' Empty =\n+--     'D1' ('MetaData \\\"Empty\\\" \\\"Main\\\" \\\"package-name\\\" 'False) 'V1'\n+-- @\n+\n+-- **** Constructors without fields: 'U1'\n+--\n+-- |\n+--\n+-- If a constructor has no arguments, then 'U1' is used as its representation. For example\n+-- the representation of 'Bool' is\n+--\n+-- @\n+-- instance 'Generic' Bool where\n+--   type 'Rep' Bool =\n+--     'D1' ('MetaData \\\"Bool\\\" \\\"Data.Bool\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"False\\\" 'PrefixI 'False) 'U1' ':+:' 'C1' ('MetaCons \\\"True\\\" 'PrefixI 'False) 'U1')\n+-- @\n+\n+-- *** Representation of types with many constructors or many fields\n+--\n+-- |\n+--\n+-- As ':+:' and ':*:' are just binary operators, one might ask what happens if the\n+-- datatype has more than two constructors, or a constructor with more than two\n+-- fields. The answer is simple: the operators are used several times, to combine\n+-- all the constructors and fields as needed. However, users /should not rely on\n+-- a specific nesting strategy/ for ':+:' and ':*:' being used. The compiler is\n+-- free to choose any nesting it prefers. (In practice, the current implementation\n+-- tries to produce a more-or-less balanced nesting, so that the traversal of\n+-- the structure of the datatype from the root to a particular component can be\n+-- performed in logarithmic rather than linear time.)\n+\n+-- ** Defining datatype-generic functions\n+--\n+-- |\n+--\n+-- A datatype-generic function comprises two parts:\n+--\n+--    1. /Generic instances/ for the function, implementing it for most of the representation\n+--       type constructors introduced above.\n+--\n+--    2. A /wrapper/ that for any datatype that is in `Generic`, performs the conversion\n+--       between the original value and its `Rep`-based representation and then invokes the\n+--       generic instances.\n+--\n+-- As an example, let us look at a function @encode@ that produces a naive, but lossless\n+-- bit encoding of values of various datatypes. So we are aiming to define a function\n+--\n+-- @\n+-- encode :: 'Generic' a => a -> [Bool]\n+-- @\n+--\n+-- where we use 'Bool' as our datatype for bits.\n+--\n+-- For part 1, we define a class @Encode'@. Perhaps surprisingly, this class is parameterized\n+-- over a type constructor @f@ of kind @* -> *@. This is a technicality: all the representation\n+-- type constructors operate with kind @* -> *@ as base kind. But the type argument is never\n+-- being used. This may be changed at some point in the future. The class has a single method,\n+-- and we use the type we want our final function to have, but we replace the occurrences of\n+-- the generic type argument @a@ with @f p@ (where the @p@ is any argument; it will not be used).\n+--\n+-- > class Encode' f where\n+-- >   encode' :: f p -> [Bool]\n+--\n+-- With the goal in mind to make @encode@ work on @Tree@ and other datatypes, we now define\n+-- instances for the representation type constructors 'V1', 'U1', ':+:', ':*:', 'K1', and 'M1'.\n+\n+-- *** Definition of the generic representation types\n+--\n+-- |\n+--\n+-- In order to be able to do this, we need to know the actual definitions of these types:\n+--\n+-- @\n+-- data    'V1'        p                       -- lifted version of Empty\n+-- data    'U1'        p = 'U1'                  -- lifted version of ()\n+-- data    (':+:') f g p = 'L1' (f p) | 'R1' (g p) -- lifted version of 'Either'\n+-- data    (':*:') f g p = (f p) ':*:' (g p)     -- lifted version of (,)\n+-- newtype 'K1'    i c p = 'K1' { 'unK1' :: c }    -- a container for a c\n+-- newtype 'M1'  i t f p = 'M1' { 'unM1' :: f p }  -- a wrapper\n+-- @\n+--\n+-- So, 'U1' is just the unit type, ':+:' is just a binary choice like 'Either',\n+-- ':*:' is a binary pair like the pair constructor @(,)@, and 'K1' is a value\n+-- of a specific type @c@, and 'M1' wraps a value of the generic type argument,\n+-- which in the lifted world is an @f p@ (where we do not care about @p@).\n+\n+-- *** Generic instances\n+--\n+-- |\n+--\n+-- The instance for 'V1' is slightly awkward (but also rarely used):\n+--\n+-- @\n+-- instance Encode' 'V1' where\n+--   encode' x = undefined\n+-- @\n+--\n+-- There are no values of type @V1 p@ to pass (except undefined), so this is\n+-- actually impossible. One can ask why it is useful to define an instance for\n+-- 'V1' at all in this case? Well, an empty type can be used as an argument to\n+-- a non-empty type, and you might still want to encode the resulting type.\n+-- As a somewhat contrived example, consider @[Empty]@, which is not an empty\n+-- type, but contains just the empty list. The 'V1' instance ensures that we\n+-- can call the generic function on such types.\n+--\n+-- There is exactly one value of type 'U1', so encoding it requires no\n+-- knowledge, and we can use zero bits:\n+--\n+-- @\n+-- instance Encode' 'U1' where\n+--   encode' 'U1' = []\n+-- @\n+--\n+-- In the case for ':+:', we produce 'False' or 'True' depending on whether\n+-- the constructor of the value provided is located on the left or on the right:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':+:' g) where\n+--   encode' ('L1' x) = False : encode' x\n+--   encode' ('R1' x) = True  : encode' x\n+-- @\n+--\n+-- (Note that this encoding strategy may not be reliable across different\n+-- versions of GHC. Recall that the compiler is free to choose any nesting\n+-- of ':+:' it chooses, so if GHC chooses @(a ':+:' b) ':+:' c@, then the\n+-- encoding for @a@ would be @[False, False]@, @b@ would be @[False, True]@,\n+-- and @c@ would be @[True]@. However, if GHC chooses @a ':+:' (b ':+:' c)@,\n+-- then the encoding for @a@ would be @[False]@, @b@ would be @[True, False]@,\n+-- and @c@ would be @[True, True]@.)\n+--\n+-- In the case for ':*:', we append the encodings of the two subcomponents:\n+--\n+-- @\n+-- instance (Encode' f, Encode' g) => Encode' (f ':*:' g) where\n+--   encode' (x ':*:' y) = encode' x ++ encode' y\n+-- @\n+--\n+-- The case for 'K1' is rather interesting. Here, we call the final function\n+-- @encode@ that we yet have to define, recursively. We will use another type\n+-- class @Encode@ for that function:\n+--\n+-- @\n+-- instance (Encode c) => Encode' ('K1' i c) where\n+--   encode' ('K1' x) = encode x\n+-- @\n+--\n+-- Note how we can define a uniform instance for 'M1', because we completely\n+-- disregard all meta-information:\n+--\n+-- @\n+-- instance (Encode' f) => Encode' ('M1' i t f) where\n+--   encode' ('M1' x) = encode' x\n+-- @\n+--\n+-- Unlike in 'K1', the instance for 'M1' refers to @encode'@, not @encode@.\n+\n+-- *** The wrapper and generic default\n+--\n+-- |\n+--\n+-- We now define class @Encode@ for the actual @encode@ function:\n+--\n+-- @\n+-- class Encode a where\n+--   encode :: a -> [Bool]\n+--   default encode :: (Generic a, Encode' (Rep a)) => a -> [Bool]\n+--   encode x = encode' ('from' x)\n+-- @\n+--\n+-- The incoming @x@ is converted using 'from', then we dispatch to the\n+-- generic instances using @encode'@. We use this as a default definition\n+-- for @encode@. We need the @default encode@ signature because ordinary\n+-- Haskell default methods must not introduce additional class constraints,\n+-- but our generic default does.\n+--\n+-- Defining a particular instance is now as simple as saying\n+--\n+-- @\n+-- instance (Encode a) => Encode (Tree a)\n+-- @\n+--\n+-- #if 0\n+-- /TODO:/ Add usage example?\n+--\n+-- #endif\n+-- The generic default is being used. In the future, it will hopefully be\n+-- possible to use @deriving Encode@ as well, but GHC does not yet support\n+-- that syntax for this situation.\n+--\n+-- Having @Encode@ as a class has the advantage that we can define\n+-- non-generic special cases, which is particularly useful for abstract\n+-- datatypes that have no structural representation. For example, given\n+-- a suitable integer encoding function @encodeInt@, we can define\n+--\n+-- @\n+-- instance Encode Int where\n+--   encode = encodeInt\n+-- @\n+\n+-- *** Omitting generic instances\n+--\n+-- |\n+--\n+-- It is not always required to provide instances for all the generic\n+-- representation types, but omitting instances restricts the set of\n+-- datatypes the functions will work for:\n+--\n+--    * If no ':+:' instance is given, the function may still work for\n+--      empty datatypes or datatypes that have a single constructor,\n+--      but will fail on datatypes with more than one constructor.\n+--\n+--    * If no ':*:' instance is given, the function may still work for\n+--      datatypes where each constructor has just zero or one field,\n+--      in particular for enumeration types.\n+--\n+--    * If no 'K1' instance is given, the function may still work for\n+--      enumeration types, where no constructor has any fields.\n+--\n+--    * If no 'V1' instance is given, the function may still work for\n+--      any datatype that is not empty.\n+--\n+--    * If no 'U1' instance is given, the function may still work for\n+--      any datatype where each constructor has at least one field.\n+--\n+-- An 'M1' instance is always required (but it can just ignore the\n+-- meta-information, as is the case for @encode@ above).\n+-- #if 0\n+-- *** Using meta-information\n+--\n+-- |\n+--\n+-- TODO\n+-- #endif\n+-- ** Generic constructor classes\n+--\n+-- |\n+--\n+-- Datatype-generic functions as defined above work for a large class\n+-- of datatypes, including parameterized datatypes. (We have used @Tree@\n+-- as our example above, which is of kind @* -> *@.) However, the\n+-- 'Generic' class ranges over types of kind @*@, and therefore, the\n+-- resulting generic functions (such as @encode@) must be parameterized\n+-- by a generic type argument of kind @*@.\n+--\n+-- What if we want to define generic classes that range over type\n+-- constructors (such as 'Data.Functor.Functor',\n+-- 'Data.Traversable.Traversable', or 'Data.Foldable.Foldable')?\n+\n+-- *** The 'Generic1' class\n+--\n+-- |\n+--\n+-- Like 'Generic', there is a class 'Generic1' that defines a\n+-- representation 'Rep1' and conversion functions 'from1' and 'to1',\n+-- only that 'Generic1' ranges over types of kind @* -> *@. (More generally,\n+-- it can range over types of kind @k -> *@, for any kind @k@, if the\n+-- @PolyKinds@ extension is enabled. More on this later.)\n+-- The 'Generic1' class is also derivable.\n+--\n+-- The representation 'Rep1' is ever so slightly different from 'Rep'.\n+-- Let us look at @Tree@ as an example again:\n+--\n+-- @\n+-- data Tree a = Leaf a | Node (Tree a) (Tree a)\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- The above declaration causes the following representation to be generated:\n+--\n+-- @\n+-- instance 'Generic1' Tree where\n+--   type 'Rep1' Tree =\n+--     'D1' ('MetaData \\\"Tree\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Leaf\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                'Par1')\n+--        ':+:'\n+--        'C1' ('MetaCons \\\"Node\\\" 'PrefixI 'False)\n+--          ('S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)\n+--           ':*:'\n+--           'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--                ('Rec1' Tree)))\n+--   ...\n+-- @\n+--\n+-- The representation reuses 'D1', 'C1', 'S1' (and thereby 'M1') as well\n+-- as ':+:' and ':*:' from 'Rep'. (This reusability is the reason that we\n+-- carry around the dummy type argument for kind-@*@-types, but there are\n+-- already enough different names involved without duplicating each of\n+-- these.)\n+--\n+-- What's different is that we now use 'Par1' to refer to the parameter\n+-- (and that parameter, which used to be @a@), is not mentioned explicitly\n+-- by name anywhere; and we use 'Rec1' to refer to a recursive use of @Tree a@.\n+\n+-- *** Representation of @* -> *@ types\n+--\n+-- |\n+--\n+-- Unlike 'Rec0', the 'Par1' and 'Rec1' type constructors do not\n+-- map to 'K1'. They are defined directly, as follows:\n+--\n+-- @\n+-- newtype 'Par1'   p = 'Par1' { 'unPar1' ::   p } -- gives access to parameter p\n+-- newtype 'Rec1' f p = 'Rec1' { 'unRec1' :: f p } -- a wrapper\n+-- @\n+--\n+-- In 'Par1', the parameter @p@ is used for the first time, whereas 'Rec1' simply\n+-- wraps an application of @f@ to @p@.\n+--\n+-- Note that 'K1' (in the guise of 'Rec0') can still occur in a 'Rep1' representation,\n+-- namely when the datatype has a field that does not mention the parameter.\n+--\n+-- The declaration\n+--\n+-- @\n+-- data WithInt a = WithInt Int a\n+--   deriving 'Generic1'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' WithInt where\n+--   type 'Rep1' WithInt =\n+--     'D1' ('MetaData \\\"WithInt\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"WithInt\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               ('Rec0' Int)\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               'Par1'))\n+-- @\n+--\n+-- If the parameter @a@ appears underneath a composition of other type constructors,\n+-- then the representation involves composition, too:\n+--\n+-- @\n+-- data Rose a = Fork a [Rose a]\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic1' Rose where\n+--   type 'Rep1' Rose =\n+--     'D1' ('MetaData \\\"Rose\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"Fork\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'Par1'\n+--          ':*:'\n+--          'S1' ('MetaSel 'Nothing\n+--                          'NoSourceUnpackedness\n+--                          'NoSourceStrictness\n+--                          'DecidedLazy)\n+--               ([] ':.:' 'Rec1' Rose)))\n+-- @\n+--\n+-- where\n+--\n+-- @\n+-- newtype (':.:') f g p = 'Comp1' { 'unComp1' :: f (g p) }\n+-- @\n+\n+-- *** Representation of @k -> *@ types\n+--\n+-- |\n+--\n+-- The 'Generic1' class can be generalized to range over types of kind\n+-- @k -> *@, for any kind @k@. To do so, derive a 'Generic1' instance with the\n+-- @PolyKinds@ extension enabled. For example, the declaration\n+--\n+-- @\n+-- data Proxy (a :: k) = Proxy deriving 'Generic1'\n+-- @\n+--\n+-- yields a slightly different instance depending on whether @PolyKinds@ is\n+-- enabled. If compiled without @PolyKinds@, then @'Rep1' Proxy :: * -> *@, but\n+-- if compiled with @PolyKinds@, then @'Rep1' Proxy :: k -> *@.\n+\n+-- *** Representation of unlifted types\n+--\n+-- |\n+--\n+-- If one were to attempt to derive a Generic instance for a datatype with an\n+-- unlifted argument (for example, 'Int#'), one might expect the occurrence of\n+-- the 'Int#' argument to be marked with @'Rec0' 'Int#'@. This won't work,\n+-- though, since 'Int#' is of an unlifted kind, and 'Rec0' expects a type of\n+-- kind @*@.\n+--\n+-- One solution would be to represent an occurrence of 'Int#' with 'Rec0 Int'\n+-- instead. With this approach, however, the programmer has no way of knowing\n+-- whether the 'Int' is actually an 'Int#' in disguise.\n+--\n+-- Instead of reusing 'Rec0', a separate data family 'URec' is used to mark\n+-- occurrences of common unlifted types:\n+--\n+-- @\n+-- data family URec a p\n+--\n+-- data instance 'URec' ('Ptr' ()) p = 'UAddr'   { 'uAddr#'   :: 'Addr#'   }\n+-- data instance 'URec' 'Char'     p = 'UChar'   { 'uChar#'   :: 'Char#'   }\n+-- data instance 'URec' 'Double'   p = 'UDouble' { 'uDouble#' :: 'Double#' }\n+-- data instance 'URec' 'Int'      p = 'UFloat'  { 'uFloat#'  :: 'Float#'  }\n+-- data instance 'URec' 'Float'    p = 'UInt'    { 'uInt#'    :: 'Int#'    }\n+-- data instance 'URec' 'Word'     p = 'UWord'   { 'uWord#'   :: 'Word#'   }\n+-- @\n+--\n+-- Several type synonyms are provided for convenience:\n+--\n+-- @\n+-- type 'UAddr'   = 'URec' ('Ptr' ())\n+-- type 'UChar'   = 'URec' 'Char'\n+-- type 'UDouble' = 'URec' 'Double'\n+-- type 'UFloat'  = 'URec' 'Float'\n+-- type 'UInt'    = 'URec' 'Int'\n+-- type 'UWord'   = 'URec' 'Word'\n+-- @\n+--\n+-- The declaration\n+--\n+-- @\n+-- data IntHash = IntHash Int#\n+--   deriving 'Generic'\n+-- @\n+--\n+-- yields\n+--\n+-- @\n+-- instance 'Generic' IntHash where\n+--   type 'Rep' IntHash =\n+--     'D1' ('MetaData \\\"IntHash\\\" \\\"Main\\\" \\\"package-name\\\" 'False)\n+--       ('C1' ('MetaCons \\\"IntHash\\\" 'PrefixI 'False)\n+--         ('S1' ('MetaSel 'Nothing\n+--                         'NoSourceUnpackedness\n+--                         'NoSourceStrictness\n+--                         'DecidedLazy)\n+--               'UInt'))\n+-- @\n+--\n+-- Currently, only the six unlifted types listed above are generated, but this\n+-- may be extended to encompass more unlifted types in the future.\n+-- #if 0\n+-- *** Limitations\n+--\n+-- |\n+--\n+-- /TODO/\n+--\n+-- /TODO:/ Also clear up confusion about 'Rec0' and 'Rec1' not really indicating recursion.\n+--\n+-- #endif\n+-----------------------------------------------------------------------------\n+\n+  -- * Generic representation types\n+    V1, U1(..), Par1(..), Rec1(..), K1(..), M1(..)\n+  , (:+:)(..), (:*:)(..), (:.:)(..)\n+\n+  -- ** Unboxed representation types\n+  --, URec(..)\n+  --, type UAddr, type UChar, type UDouble\n+  --, type UFloat, type UInt, type UWord\n+\n+  -- ** Synonyms for convenience\n+  , Rec0, R\n+  , D1, C1, S1, D, C, S\n+\n+  -- * Meta-information\n+  -- , Datatype(..), Constructor(..), Selector(..)\n+  , Fixity(..), FixityI(..), Associativity(..), prec\n+  , SourceUnpackedness(..), SourceStrictness(..), DecidedStrictness(..)\n+  , Meta(..)\n+\n+  -- * Generic type classes\n+  , Generic(..), Generic1(..)\n+\n+  ) where\n+\n+-- We use some base types\n+-- import Data.Either ( Either (..) )\n+-- import Data.Maybe  ( Maybe(..))\n+-- import Data.Ord    ( Down(..) )\n+-- import GHC.Integer ( Integer, integerToInt )\n+-- import GHC.Prim    ( Addr#, Char#, Double#, Float#, Int#, Word# )\n+-- import GHC.Ptr     ( Ptr )\n+import GHC.Types\n+\n+-- Needed for instances\n+-- import GHC.Arr     ( Ix )\n+-- import GHC.Base    ( Alternative(..), Applicative(..), Functor(..)\n+--                   , Monad(..), MonadPlus(..), NonEmpty(..), String, coerce\n+--                   , Semigroup(..), Monoid(..) )\n+import GHC.Classes ( Eq(..), Ord(..) )\n+import GHC.Enum    ( Bounded, Enum )\n+-- import GHC.Read    ( Read(..) )\n+import GHC.Show    ( Show(..), showString )\n+\n+-- Needed for metadata\n+-- import Data.Proxy   ( Proxy(..) )\n+-- import GHC.TypeLits ( KnownSymbol, KnownNat, symbolVal, natVal )\n+\n+import GHC.CString (fromString)\n+import GHC.Integer.Type (fromInteger)\n+import Control.Exception.Base\n+\n+-- | The kind of types with values. For example @Int :: Type@.\n+-- [DA] copied from ghc-prim/GHC/Types.hs. Usually set to\n+-- type Type = TYPE 'LiftedRep, but we only have one representation.\n+type Type = *\n+\n+ --------------------------------------------------------------------------------\n+-- Representation types\n+--------------------------------------------------------------------------------\n+\n+-- | Void: used for datatypes without constructors\n+data V1 (p :: k)\n+  deriving ( Eq       -- ^ @since 4.9.0.0\n+           , Ord      -- ^ @since 4.9.0.0\n+--           , Read     -- ^ @since 4.9.0.0\n+           , Show     -- ^ @since 4.9.0.0\n+--           , Functor  -- ^ @since 4.9.0.0\n+--           , Generic  -- ^ @since 4.9.0.0\n+--           , Generic1 -- ^ @since 4.9.0.0\n+           )\n+\n+-- | @since 4.12.0.0\n+-- instance Semigroup (V1 p) where\n+--   v <> _ = v\n+\n+-- | Unit: used for constructors without arguments\n+data U1 (p :: k) = U1\n+--  deriving ( Generic  -- ^ @since 4.7.0.0\n+--           , Generic1 -- ^ @since 4.9.0.0\n+--           )\n+\n+-- | @since 4.9.0.0\n+instance Eq (U1 p) where\n+  _ == _ = True\n+\n+-- | @since 4.7.0.0\n+instance Ord (U1 p) where\n+  compare _ _ = EQ\n+\n+-- | @since 4.9.0.0\n+-- deriving instance Read (U1 p)\n+\n+-- | @since 4.9.0.0\n+instance Show (U1 p) where\n+  showsPrec _ _ = showString \"U1\"\n+\n+-- | @since 4.9.0.0\n+-- instance Functor U1 where\n+--   fmap _ _ = U1\n+--\n+-- -- | @since 4.9.0.0\n+-- instance Applicative U1 where"
  }
]