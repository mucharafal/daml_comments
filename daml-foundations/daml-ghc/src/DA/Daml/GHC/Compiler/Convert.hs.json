[
  {
    "id" : "d8fb9d1a-1f70-48f2-a726-07097e370460",
    "prId" : 1191,
    "comments" : [
      {
        "id" : "5630a667-cc00-44e2-887c-bcae55bda913",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I want to know the types of the Coercion. My guess is that given a Coercion `a ~ b` I get a lambda `a -> b` and `b -> a`? If so, can we get that in the docs.",
        "createdAt" : "2019-05-16T13:23:00Z",
        "updatedAt" : "2019-05-16T14:28:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "04373ca2-31b1-427b-84d8-b123a3648092",
        "parentId" : "5630a667-cc00-44e2-887c-bcae55bda913",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "that's correct, I'll put it in the docs.",
        "createdAt" : "2019-05-16T13:38:21Z",
        "updatedAt" : "2019-05-16T14:28:13Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "269161dcb3b991b09fe7a49a8794d16c461ee5da",
    "line" : null,
    "diffHunk" : "@@ -974,7 +977,13 @@ mkProjBindings env recExpr recTyp vsFlds e =\n     , not (isDeadOcc (occInfo (idInfo v)))\n     ]\n \n--- | Convert casts induced by newtype definitions. The definition\n+-- | Convert casts induced by newtype definitions.\n+convertCast :: Env -> LF.Expr -> Coercion -> ConvertM LF.Expr\n+convertCast env expr co = do\n+    (to, _from) <- evalStateT (convertCoercion env co) 0\n+    pure (to `ETmApp` expr)\n+\n+-- Convert a coercion to a pair of lambdas. The definition"
  },
  {
    "id" : "bd973523-6a02-401f-b38a-43f4d6b247ba",
    "prId" : 1191,
    "comments" : [
      {
        "id" : "83a51ee3-d767-45ba-bf9a-3a9fba8be6a8",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Can we please put this back onto a single line. :)",
        "createdAt" : "2019-05-16T13:40:30Z",
        "updatedAt" : "2019-05-16T14:28:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c4c6b5b9-048e-4d30-b5e9-616946d09884",
        "parentId" : "83a51ee3-d767-45ba-bf9a-3a9fba8be6a8",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "`state (dupe . succ)`",
        "createdAt" : "2019-05-16T14:05:51Z",
        "updatedAt" : "2019-05-16T14:28:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "269161dcb3b991b09fe7a49a8794d16c461ee5da",
    "line" : null,
    "diffHunk" : "@@ -990,66 +999,128 @@ mkProjBindings env recExpr recTyp vsFlds e =\n -- Coercions induced by newtypes can also occur deeply nested in function\n -- types or forall quantifications. We handle those cases by recursion into\n -- all sub-coercions.\n-convertCast :: Env -> LF.Expr -> Coercion -> ConvertM LF.Expr\n-convertCast env expr0 co0 = evalStateT (go expr0 co0) 0\n+convertCoercion :: Env -> Coercion -> StateT Int ConvertM (LF.Expr, LF.Expr)\n+convertCoercion env co\n+    | isReflCo co = do\n+        s' <- lift $ convertType env s\n+        t' <- lift $ convertType env t\n+        x <- mkLamBinder\n+        let lamTo = ETmLam (x, s') (EVar x)\n+            lamFrom = ETmLam (x, t') (EVar x)\n+        pure (lamTo, lamFrom)\n+    | Just (xCo, yCo) <- splitFunCo_maybe co = do\n+        let Pair a a' = coercionKind xCo\n+        (aTo, aFrom) <- convertCoercion env xCo\n+        (bTo, bFrom) <- convertCoercion env yCo\n+        sLf <- lift $ convertType env s\n+        tLf <- lift $ convertType env t\n+        aLf <- lift $ convertType env a\n+        a'Lf <- lift $ convertType env a'\n+        f <- mkLamBinder\n+        g <- mkLamBinder\n+        x <- mkLamBinder\n+        y <- mkLamBinder\n+        let lamTo =\n+                ETmLam\n+                    (f, sLf)\n+                    (ETmLam\n+                         (x, a'Lf)\n+                         (bTo `ETmApp` (EVar f `ETmApp` (aFrom `ETmApp` EVar x))))\n+        let lamFrom =\n+                ETmLam\n+                    (g, tLf)\n+                    (ETmLam\n+                         (y, aLf)\n+                         (bFrom `ETmApp` (EVar g `ETmApp` (aTo `ETmApp` EVar y))))\n+        pure (lamTo, lamFrom)\n+    | Just (aGhc, k_co, co') <- splitForAllCo_maybe co\n+    , isReflCo k_co -- TODO (drsk) is this restriction needed?\n+     = do\n+        let Pair _aK a'K = coercionKind k_co\n+        (aTo, aFrom) <- convertCoercion env k_co\n+        (bTo, bFrom) <- convertCoercion env co'\n+        a'KLf <- lift $ convertKind a'K\n+        s' <- lift $ convertType env s\n+        t' <- lift $ convertType env t\n+        f <- mkLamBinder\n+        g <- mkLamBinder\n+        a' <- mkLamBinder\n+        (a, aKLf) <- lift $ convTypeVar aGhc\n+        let lamTo =\n+                ETmLam\n+                    (f, s')\n+                    (ETyLam\n+                         (a', a'KLf)\n+                         (bTo `ETmApp`\n+                          (EVar f `ETmApp` (aFrom `ETyApp` (TVar a')))))\n+        let lamFrom =\n+                ETmLam\n+                    (g, t')\n+                    (ETyLam\n+                         (a, aKLf)\n+                         (bFrom `ETmApp`\n+                          (EVar g `ETmApp` (aTo `ETyApp` (TVar a)))))\n+        pure (lamTo, lamFrom)\n+    -- Case (1) & (2)\n+    | Just (tCon, ts, field, flv) <- isSatNewTyCon s t = do\n+        newtypeCoercion tCon ts field flv s t\n+    | Just (tCon, ts, field, flv) <- isSatNewTyCon t s = do\n+        (to, from) <- swap <$> newtypeCoercion tCon ts field flv t s\n+        pure (to, from)\n+    | SymCo co' <- co = do\n+      swap <$> convertCoercion env co'\n+    | SubCo co' <- co = convertCoercion env co'\n+    | Just (coF, coA) <- splitAppCo_maybe co = do\n+        (fTo, fFrom) <- convertCoercion env coF\n+        (aTo, aFrom) <- convertCoercion env coA\n+        pure (fTo `ETmApp` aTo, fFrom `ETmApp` aFrom)\n+    | otherwise = lift $ unhandled \"Coercion\" co\n   where\n-    go :: LF.Expr -> Coercion -> StateT Int ConvertM LF.Expr\n-    go expr co\n-      | isReflCo co\n-      = pure expr\n-\n-      | Just (xCo, yCo) <- splitFunCo_maybe  co\n-      = do\n-        let Pair _ t = coercionKind xCo\n-        n <- state (\\k -> let l = k+1 in (l, l))\n-        let var = mkVar (\"$cast\" ++ show n)\n-        -- NOTE(MH): We need @mkSymCo xCo@ here because the arrow type is\n-        -- contravariant in its first argument but GHC's coercions\n-        -- don't reflect this fact.\n-        var' <- go (EVar var) (mkSymCo xCo)\n-        t' <- lift (convertType env t)\n-        ETmLam (var, t') <$> go (expr `ETmApp` var') yCo\n-\n-      | Just (x, k_co, co') <- splitForAllCo_maybe co\n-      , isReflCo k_co\n-      = do\n-        (x', kind) <- lift $ convTypeVar x\n-        ETyLam (x', kind) <$> go (expr `ETyApp` TVar x') co'\n-\n-      -- Case (1) & (2)\n-      | Pair s t <- coercionKind co\n-      = lift $ do\n-        mCase1 <- isSatNewTyCon s t\n-        mCase2 <- isSatNewTyCon t s\n-        case (mCase1, mCase2) of\n-          (Just (tcon, field, flv), _) ->\n-            let sanitize x\n+    newtypeCoercion tCon ts field flv s0 t0 = do\n+        sLf <- lift $ convertType env s0\n+        tLf <- lift $ convertType env t0\n+        ts' <- lift $ mapM (convertType env) ts\n+        t' <- lift $ convertQualified env tCon\n+        exprS <- mkLamBinder\n+        exprT <- mkLamBinder\n+        let tcon = TypeConApp t' ts'\n+        let sanitizeTo x\n                   -- NOTE(MH): This is DICTIONARY SANITIZATION step (3).\n-                  | flv == ClassFlavour = ETmLam (mkVar \"_\", TUnit) x\n-                  | otherwise = x\n-            in pure $ ERecCon tcon [(field, sanitize expr)]\n-          (_, Just (tcon, field, flv)) ->\n-            let sanitize x\n+                | flv == ClassFlavour = ETmLam (mkVar \"_\", TUnit) x\n+                | otherwise = x\n+            sanitizeFrom x\n                   -- NOTE(MH): This is DICTIONARY SANITIZATION step (2).\n-                  | flv == ClassFlavour = x `ETmApp` EUnit\n-                  | otherwise = x\n-            in pure $ sanitize (ERecProj tcon field expr)\n-          _ -> unhandled \"Coercion\" co\n-    isSatNewTyCon :: GHC.Type -> GHC.Type -> ConvertM (Maybe (TypeConApp, FieldName, TyConFlavour))\n+                | flv == ClassFlavour = x `ETmApp` EUnit\n+                | otherwise = x\n+\n+        pure $\n+            ( ETmLam\n+                  (exprS, sLf)\n+                  (ERecCon tcon [(field, sanitizeTo (EVar exprS))])\n+            , ETmLam\n+                  (exprT, tLf)\n+                  (sanitizeFrom (ERecProj tcon field (EVar exprT))))\n+\n+    Pair s t = coercionKind co\n+\n+    mkLamBinder = do\n+        n <-\n+            state\n+                (\\k ->\n+                     let l = k + 1\n+                      in (l, l))"
  },
  {
    "id" : "97d54236-8266-4fa5-a529-d430e1dec0ea",
    "prId" : 1191,
    "comments" : [
      {
        "id" : "ef90800b-13f3-45e7-a66f-7cdca68e5658",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This is a sanity check. We don't want to get involved in the business of kind coercions. All ways I can imagine how they pop up just don't work in DAML.",
        "createdAt" : "2019-05-16T13:43:00Z",
        "updatedAt" : "2019-05-16T14:28:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "269161dcb3b991b09fe7a49a8794d16c461ee5da",
    "line" : null,
    "diffHunk" : "@@ -990,66 +999,128 @@ mkProjBindings env recExpr recTyp vsFlds e =\n -- Coercions induced by newtypes can also occur deeply nested in function\n -- types or forall quantifications. We handle those cases by recursion into\n -- all sub-coercions.\n-convertCast :: Env -> LF.Expr -> Coercion -> ConvertM LF.Expr\n-convertCast env expr0 co0 = evalStateT (go expr0 co0) 0\n+convertCoercion :: Env -> Coercion -> StateT Int ConvertM (LF.Expr, LF.Expr)\n+convertCoercion env co\n+    | isReflCo co = do\n+        s' <- lift $ convertType env s\n+        t' <- lift $ convertType env t\n+        x <- mkLamBinder\n+        let lamTo = ETmLam (x, s') (EVar x)\n+            lamFrom = ETmLam (x, t') (EVar x)\n+        pure (lamTo, lamFrom)\n+    | Just (xCo, yCo) <- splitFunCo_maybe co = do\n+        let Pair a a' = coercionKind xCo\n+        (aTo, aFrom) <- convertCoercion env xCo\n+        (bTo, bFrom) <- convertCoercion env yCo\n+        sLf <- lift $ convertType env s\n+        tLf <- lift $ convertType env t\n+        aLf <- lift $ convertType env a\n+        a'Lf <- lift $ convertType env a'\n+        f <- mkLamBinder\n+        g <- mkLamBinder\n+        x <- mkLamBinder\n+        y <- mkLamBinder\n+        let lamTo =\n+                ETmLam\n+                    (f, sLf)\n+                    (ETmLam\n+                         (x, a'Lf)\n+                         (bTo `ETmApp` (EVar f `ETmApp` (aFrom `ETmApp` EVar x))))\n+        let lamFrom =\n+                ETmLam\n+                    (g, tLf)\n+                    (ETmLam\n+                         (y, aLf)\n+                         (bFrom `ETmApp` (EVar g `ETmApp` (aTo `ETmApp` EVar y))))\n+        pure (lamTo, lamFrom)\n+    | Just (aGhc, k_co, co') <- splitForAllCo_maybe co\n+    , isReflCo k_co -- TODO (drsk) is this restriction needed?"
  },
  {
    "id" : "23161b79-268e-4f2a-b46d-9efd5cc4c749",
    "prId" : 1020,
    "comments" : [
      {
        "id" : "973774d3-889b-40ca-9e76-b99bcf8767c6",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\n    [mkField $ \"_d\" <> show i | i <- [1 .. length thetas]] ++ ctorLabels0 flv con\r\n```\r\nRedundant bracket",
        "createdAt" : "2019-05-08T21:25:24Z",
        "updatedAt" : "2019-05-09T11:54:53Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13c1c4566d1e22bcaccafbeb874cdaf168f9555b",
    "line" : null,
    "diffHunk" : "@@ -1209,27 +1209,32 @@ toCtors env t = Ctors (getName t) <$> mapM convTypeVar (tyConTyVars t) <*> cs\n --   unpacking them faster in the current intepreter. Since the constructor\n --   names of newtypes are meant to be meaningless, this is acceptable.\n ctorLabels :: TyConFlavour -> DataCon -> [FieldName]\n-ctorLabels flv con\n-  | flv `elem` [ClassFlavour, TupleFlavour Boxed] || isTupleDataCon con\n-    -- NOTE(MH): The line below is a workaround for ghc issue\n-    -- https://github.com/ghc/ghc/blob/ae4f1033cfe131fca9416e2993bda081e1f8c152/compiler/types/TyCon.hs#L2030\n-    || (is con == \"Unit\" && moduleNameString (GHC.moduleName (nameModule (getName con))) == \"GHC.Tuple\")\n-  = map (mkField . (:) '_' . show) [1..dataConSourceArity con]\n-  | flv == NewtypeFlavour && null lbls\n-  = [mkField \"unpack\"]\n-  | otherwise\n-  = map convFieldName lbls\n-  where lbls = dataConFieldLabels con\n+ctorLabels flv con =\n+    [mkField $ \"_d\" <> show i | i <- [1 .. length thetas]] ++ (ctorLabels0 flv con)"
  },
  {
    "id" : "2d8df264-42bd-4287-8572-46d970364c5f",
    "prId" : 1020,
    "comments" : [
      {
        "id" : "0360566b-109b-4167-9188-bc8f8b072547",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd have just called this `f` or similar. `ctorLabels0` seems an odd name",
        "createdAt" : "2019-05-08T21:25:55Z",
        "updatedAt" : "2019-05-09T11:54:53Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b7d7e1f-545d-49e4-bfe1-2d0a77751870",
        "parentId" : "0360566b-109b-4167-9188-bc8f8b072547",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "renamed it.",
        "createdAt" : "2019-05-09T11:41:52Z",
        "updatedAt" : "2019-05-09T11:54:53Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13c1c4566d1e22bcaccafbeb874cdaf168f9555b",
    "line" : null,
    "diffHunk" : "@@ -1209,27 +1209,32 @@ toCtors env t = Ctors (getName t) <$> mapM convTypeVar (tyConTyVars t) <*> cs\n --   unpacking them faster in the current intepreter. Since the constructor\n --   names of newtypes are meant to be meaningless, this is acceptable.\n ctorLabels :: TyConFlavour -> DataCon -> [FieldName]\n-ctorLabels flv con\n-  | flv `elem` [ClassFlavour, TupleFlavour Boxed] || isTupleDataCon con\n-    -- NOTE(MH): The line below is a workaround for ghc issue\n-    -- https://github.com/ghc/ghc/blob/ae4f1033cfe131fca9416e2993bda081e1f8c152/compiler/types/TyCon.hs#L2030\n-    || (is con == \"Unit\" && moduleNameString (GHC.moduleName (nameModule (getName con))) == \"GHC.Tuple\")\n-  = map (mkField . (:) '_' . show) [1..dataConSourceArity con]\n-  | flv == NewtypeFlavour && null lbls\n-  = [mkField \"unpack\"]\n-  | otherwise\n-  = map convFieldName lbls\n-  where lbls = dataConFieldLabels con\n+ctorLabels flv con =\n+    [mkField $ \"_d\" <> show i | i <- [1 .. length thetas]] ++ (ctorLabels0 flv con)\n+  where\n+  thetas = dataConTheta con\n+  ctorLabels0 flv con"
  },
  {
    "id" : "21073ebf-2708-493d-9c0d-a750290edd70",
    "prId" : 1020,
    "comments" : [
      {
        "id" : "001314cd-4683-44da-aab7-7c90cad5e61c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This will cause trouble when there's already a field of name `f1`. I propose we name those fields `$dict1` and so on. Users can't put a `$` in the name themselves.",
        "createdAt" : "2019-05-09T11:47:47Z",
        "updatedAt" : "2019-05-09T11:54:53Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ac69b990-4194-4757-b582-785be799d79f",
        "parentId" : "001314cd-4683-44da-aab7-7c90cad5e61c",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "renamed.",
        "createdAt" : "2019-05-09T12:39:55Z",
        "updatedAt" : "2019-05-09T12:39:55Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13c1c4566d1e22bcaccafbeb874cdaf168f9555b",
    "line" : null,
    "diffHunk" : "@@ -1208,28 +1208,35 @@ toCtors env t = Ctors (getName t) <$> mapM convTypeVar (tyConTyVars t) <*> cs\n --   this would considerably complicate converting coercions. Second, it makes\n --   unpacking them faster in the current intepreter. Since the constructor\n --   names of newtypes are meant to be meaningless, this is acceptable.\n+--\n+-- * We add a field for every constraint containt in the thetas.\n ctorLabels :: TyConFlavour -> DataCon -> [FieldName]\n-ctorLabels flv con\n-  | flv `elem` [ClassFlavour, TupleFlavour Boxed] || isTupleDataCon con\n-    -- NOTE(MH): The line below is a workaround for ghc issue\n-    -- https://github.com/ghc/ghc/blob/ae4f1033cfe131fca9416e2993bda081e1f8c152/compiler/types/TyCon.hs#L2030\n-    || (is con == \"Unit\" && moduleNameString (GHC.moduleName (nameModule (getName con))) == \"GHC.Tuple\")\n-  = map (mkField . (:) '_' . show) [1..dataConSourceArity con]\n-  | flv == NewtypeFlavour && null lbls\n-  = [mkField \"unpack\"]\n-  | otherwise\n-  = map convFieldName lbls\n-  where lbls = dataConFieldLabels con\n+ctorLabels flv con =\n+    [mkField $ \"f\" <> show i | i <- [1 .. length thetas]] ++ conFields flv con"
  },
  {
    "id" : "2b7dfb67-e6c3-4b89-abc0-aacee1abfb38",
    "prId" : 1020,
    "comments" : [
      {
        "id" : "e7b1228b-6364-4099-9df6-874447efaea9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n  let (_, thetas, tys,_) = dataConSig con\r\n```\r\nand remove the next line. This does _exactly_ the same we do now.",
        "createdAt" : "2019-05-09T11:50:08Z",
        "updatedAt" : "2019-05-09T11:54:53Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b91e93d7-9741-4aff-b643-ce01e6c9dcca",
        "parentId" : "e7b1228b-6364-4099-9df6-874447efaea9",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "done.",
        "createdAt" : "2019-05-09T12:39:48Z",
        "updatedAt" : "2019-05-09T12:39:49Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "13c1c4566d1e22bcaccafbeb874cdaf168f9555b",
    "line" : null,
    "diffHunk" : "@@ -1208,28 +1208,35 @@ toCtors env t = Ctors (getName t) <$> mapM convTypeVar (tyConTyVars t) <*> cs\n --   this would considerably complicate converting coercions. Second, it makes\n --   unpacking them faster in the current intepreter. Since the constructor\n --   names of newtypes are meant to be meaningless, this is acceptable.\n+--\n+-- * We add a field for every constraint containt in the thetas.\n ctorLabels :: TyConFlavour -> DataCon -> [FieldName]\n-ctorLabels flv con\n-  | flv `elem` [ClassFlavour, TupleFlavour Boxed] || isTupleDataCon con\n-    -- NOTE(MH): The line below is a workaround for ghc issue\n-    -- https://github.com/ghc/ghc/blob/ae4f1033cfe131fca9416e2993bda081e1f8c152/compiler/types/TyCon.hs#L2030\n-    || (is con == \"Unit\" && moduleNameString (GHC.moduleName (nameModule (getName con))) == \"GHC.Tuple\")\n-  = map (mkField . (:) '_' . show) [1..dataConSourceArity con]\n-  | flv == NewtypeFlavour && null lbls\n-  = [mkField \"unpack\"]\n-  | otherwise\n-  = map convFieldName lbls\n-  where lbls = dataConFieldLabels con\n+ctorLabels flv con =\n+    [mkField $ \"f\" <> show i | i <- [1 .. length thetas]] ++ conFields flv con\n+  where\n+  thetas = dataConTheta con\n+  conFields flv con\n+    | flv `elem` [ClassFlavour, TupleFlavour Boxed] || isTupleDataCon con\n+      -- NOTE(MH): The line below is a workaround for ghc issue\n+      -- https://github.com/ghc/ghc/blob/ae4f1033cfe131fca9416e2993bda081e1f8c152/compiler/types/TyCon.hs#L2030\n+      || (is con == \"Unit\" && moduleNameString (GHC.moduleName (nameModule (getName con))) == \"GHC.Tuple\")\n+    = map (mkField . (:) '_' . show) [1..dataConSourceArity con]\n+    | flv == NewtypeFlavour && null lbls\n+    = [mkField \"unpack\"]\n+    | otherwise\n+    = map convFieldName lbls\n+  lbls = dataConFieldLabels con\n \n toCtor :: Env -> DataCon -> ConvertM Ctor\n toCtor env con =\n-  let (_,_,tys,_) = dataConSig con\n+  let (_,_, tys,_) = dataConSig con"
  },
  {
    "id" : "2c7580b3-a1fb-43ae-982a-c20e48873ee6",
    "prId" : 907,
    "comments" : [
      {
        "id" : "a8ec7872-32c7-4c28-873d-0f3bd2ee6862",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Not a fan of arbitrarily commented out code",
        "createdAt" : "2019-05-03T20:43:42Z",
        "updatedAt" : "2019-05-03T21:35:52Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2551572c-38d6-4a15-a12b-7d9a63f95617",
        "parentId" : "a8ec7872-32c7-4c28-873d-0f3bd2ee6862",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "That was an accident. Removed.",
        "createdAt" : "2019-05-03T20:47:17Z",
        "updatedAt" : "2019-05-03T21:35:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f696f3debcb25634f7556e777bae64fedb1e53ac",
    "line" : null,
    "diffHunk" : "@@ -757,13 +757,14 @@ convertExpr env0 e = do\n         -- work. Constructor workers are not handled (yet).\n         | Just m <- nameModule_maybe $ varName x\n         , Just con <- isDataConId_maybe x\n-        , not (\"$W\" `isPrefixOf` is x)\n+        -- , not (\"$W\" `isPrefixOf` is x)"
  },
  {
    "id" : "63fc2bc4-f405-4cd5-8b5d-9a9d57b2572c",
    "prId" : 866,
    "comments" : [
      {
        "id" : "606d1d16-9cc6-4446-af33-983f179c0562",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'd rather these functions had a newline before them, and I think I'd even prefer if they were at the top level. They seem generic combinators with general properties.",
        "createdAt" : "2019-05-02T20:02:05Z",
        "updatedAt" : "2019-05-02T20:57:08Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "07ca9e58afcac8accddd5dc1be531934534d5cb7",
    "line" : null,
    "diffHunk" : "@@ -891,6 +877,20 @@ convertExpr env0 e = do\n     convertArg env = \\case\n         Type t -> TyArg <$> convertType env t\n         e -> TmArg <$> convertExpr env e\n+    withTyArg :: Env -> (LF.TypeVarName, LF.Kind) -> [LArg Var] -> (LF.Type -> [LArg Var] -> ConvertM (LF.Expr, [LArg Var])) -> ConvertM (LF.Expr, [LArg Var])"
  },
  {
    "id" : "7916d09b-267b-4640-9c10-810970a80756",
    "prId" : 647,
    "comments" : [
      {
        "id" : "eeeac7f7-40bf-4451-8bd5-8f51040970b9",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I kind of liked having the logic for this in a separate function. Maybe add something like `mkTupleType :: [(FieldName, LF.Type)] -> ConvertM LF.Type` that only contains the type logic of `mkRepackStruct`.",
        "createdAt" : "2019-04-24T08:51:09Z",
        "updatedAt" : "2019-04-24T09:44:14Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3695140f-7a73-4d3b-a8bc-102adc1fbc51",
        "parentId" : "eeeac7f7-40bf-4451-8bd5-8f51040970b9",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "In reality it looks less nice than I imagined. I'll leave it as is.",
        "createdAt" : "2019-04-24T08:58:28Z",
        "updatedAt" : "2019-04-24T09:44:14Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "91783220ed54e5468c1a92cdb1450daab699b8f6",
    "line" : 49,
    "diffHunk" : "@@ -591,39 +591,28 @@ convertExpr env0 e = do\n         pure $\n             ETmLam (varV1, TList TParty) $ ETmLam (varV2, TContractId t') $\n             EUpdate $ UExercise tmpl' (mkChoiceName \"Archive\") (EVar varV2) (EVar varV1) mkEUnit\n-    go env (VarIs \"$dminternalFetchByKey\") (LType t@(TypeCon tmpl []) : LType key : _dict : args)\n-        = fmap (, args) $ do\n-        key' <- convertType env key\n-        tmpl' <- convertQualified env tmpl\n-        let contractType = TConApp tmpl' []\n-        let cidType = TContractId contractType\n-        let fields = [(\"contractId\", cidType), (\"contract\", contractType)]\n-        (repackStruct, tupleType) <- mkRepackStruct env fields varV2\n-        pure $ ETmLam (varV1, key') $\n-          EUpdate $ UBind\n-            (Binding\n-              (varV2, TTuple fields)\n-              (EUpdate (UFetchByKey RetrieveByKey\n-                { retrieveByKeyTemplate = tmpl'\n-                , retrieveByKeyKey = EVar varV1\n-                })))\n-            (EUpdate (UPure tupleType repackStruct))\n-    go env (VarIs \"$dminternalLookupByKey\") (LType t@(TypeCon tmpl []) : LType key : _dict : args)\n-        = fmap (, args) $ do\n-        key' <- convertType env key\n-        tmpl' <- convertQualified env tmpl\n-        pure $ ETmLam (varV1, key') $\n-          EUpdate $ ULookupByKey RetrieveByKey\n-            { retrieveByKeyTemplate = tmpl'\n-            , retrieveByKeyKey = EVar varV1\n-            }\n+    go env (VarIs f) (LType t@(TypeCon tmpl []) : LType key : _dict : args)\n+        | f == \"$dminternalFetchByKey\" = conv UFetchByKey\n+        | f == \"$dminternalLookupByKey\" = conv ULookupByKey\n+        where\n+            conv prim = fmap (, args) $ do\n+                key' <- convertType env key\n+                tmpl' <- convertQualified env tmpl\n+                pure $ ETmLam (varV1, key') $\n+                  EUpdate $ prim RetrieveByKey\n+                    { retrieveByKeyTemplate = tmpl'\n+                    , retrieveByKeyKey = EVar varV1\n+                    }\n     go env (VarIs \"unpackPair\") (LType (StrLitTy f1) : LType (StrLitTy f2) : LType t1 : LType t2 : args)\n         = fmap (, args) $ do\n             t1 <- convertType env t1\n             t2 <- convertType env t2\n             let fields = [(mkField f1, t1), (mkField f2, t2)]\n-            (repackStruct, _) <- mkRepackStruct env fields varV1\n-            pure $ ETmLam (varV1, TTuple fields) repackStruct\n+            tupleTyCon <- qGHC_Tuple env (mkTypeCon [\"Tuple\" ++ show (length fields)])"
  },
  {
    "id" : "6ebba053-bda3-4792-961d-21838687e345",
    "prId" : 574,
    "comments" : [
      {
        "id" : "e1ebf1db-28dc-4fef-acb4-5bf8a5099b86",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we have a proper Enum introduced and return Preconsuming/Postconsuming/Nonconsuming here and then `==` for the tests above.",
        "createdAt" : "2019-04-17T12:28:45Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "269d9961-b14f-4837-862d-436709e1daed",
        "parentId" : "e1ebf1db-28dc-4fef-acb4-5bf8a5099b86",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-04-17T14:36:12Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "825b9042188d04bf812ad2955222e5d8e39d33dc",
    "line" : null,
    "diffHunk" : "@@ -367,11 +396,13 @@ convertChoice env (VarIs \"C:Choice\" `App` Type tmpl `App` Type (TypeCon chc [])\n \n         f i (App a _) = f i a\n         f i (Tick _ e) = f i e\n-        f i (VarIs \"nonconsuming\") = pure False\n-        f i (VarIs \"$dmconsuming\") = pure True -- the default is consuming\n+        f i (VarIs \"$dmconsuming\") = pure (True, False) -- the default is preconsuming"
  },
  {
    "id" : "2f1b28e6-db91-4b4f-92b2-61a2b042e99d",
    "prId" : 574,
    "comments" : [
      {
        "id" : "e6c573c7-2267-4a3d-8c1e-3f8f611bffa4",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I like white space as much as anyone, but I'd put `then pure expr` on one line",
        "createdAt" : "2019-04-17T12:29:10Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6f26e8a5-43d3-4770-be0a-7a39f70f46eb",
        "parentId" : "e6c573c7-2267-4a3d-8c1e-3f8f611bffa4",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-04-17T14:36:03Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "825b9042188d04bf812ad2955222e5d8e39d33dc",
    "line" : null,
    "diffHunk" : "@@ -353,9 +361,30 @@ convertChoice env (VarIs \"C:Choice\" `App` Type tmpl `App` Type (TypeCon chc [])\n             ETmLam thisBndr (ETmLam argBndr body)\n               | fst argBndr `Set.notMember` cata freeVarsStep body ->\n                 ETmLam thisBndr body `ETmApp` thisVar\n-            _ ->\n-                controllerExpr `ETmApp` thisVar `ETmApp` argVar\n-    chcUpdate <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+            _ -> controllerExpr `ETmApp` thisVar `ETmApp` argVar\n+    expr <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+    chcUpdate <-\n+      if not $ postConsuming\n+        then\n+          pure expr"
  },
  {
    "id" : "2d0c91e5-1219-4551-982d-963ae6276cc8",
    "prId" : 574,
    "comments" : [
      {
        "id" : "6dba94f8-e940-40de-9411-18f7ab055b87",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\n      if not postConsuming\r\n```",
        "createdAt" : "2019-04-17T12:29:15Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "825b9042188d04bf812ad2955222e5d8e39d33dc",
    "line" : null,
    "diffHunk" : "@@ -353,9 +361,30 @@ convertChoice env (VarIs \"C:Choice\" `App` Type tmpl `App` Type (TypeCon chc [])\n             ETmLam thisBndr (ETmLam argBndr body)\n               | fst argBndr `Set.notMember` cata freeVarsStep body ->\n                 ETmLam thisBndr body `ETmApp` thisVar\n-            _ ->\n-                controllerExpr `ETmApp` thisVar `ETmApp` argVar\n-    chcUpdate <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+            _ -> controllerExpr `ETmApp` thisVar `ETmApp` argVar\n+    expr <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+    chcUpdate <-\n+      if not $ postConsuming"
  },
  {
    "id" : "45e799bc-a988-4e32-aa12-fc76a7c2a129",
    "prId" : 574,
    "comments" : [
      {
        "id" : "888d488e-3e77-42ef-ae46-e25f6df431c6",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Ditto, `else do` can be one line",
        "createdAt" : "2019-04-17T12:29:25Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9528804e-9d76-4652-b233-1c8c1c6e3f15",
        "parentId" : "888d488e-3e77-42ef-ae46-e25f6df431c6",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-04-17T14:35:55Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "825b9042188d04bf812ad2955222e5d8e39d33dc",
    "line" : null,
    "diffHunk" : "@@ -353,9 +361,30 @@ convertChoice env (VarIs \"C:Choice\" `App` Type tmpl `App` Type (TypeCon chc [])\n             ETmLam thisBndr (ETmLam argBndr body)\n               | fst argBndr `Set.notMember` cata freeVarsStep body ->\n                 ETmLam thisBndr body `ETmApp` thisVar\n-            _ ->\n-                controllerExpr `ETmApp` thisVar `ETmApp` argVar\n-    chcUpdate <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+            _ -> controllerExpr `ETmApp` thisVar `ETmApp` argVar\n+    expr <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+    chcUpdate <-\n+      if not $ postConsuming\n+        then\n+          pure expr\n+      else\n+        do"
  },
  {
    "id" : "64032f33-c9c8-4f7e-8dee-c18bbb97ca3a",
    "prId" : 574,
    "comments" : [
      {
        "id" : "2443443e-8a33-4d65-b220-5d66dcb0c76b",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I find the way you've broken this up in the code a bit odd. I tried doing code golf and got to something more like:\r\n\r\n```\r\nlet callArchive = EUpdate $ UExercise tmplTyCon' (mkChoiceName \"Archive\") selfVar signatories mkEUnit\r\nEUpdate $ UBind (Binding (mkVar \"res\", chcReturnType) expr) $\r\nEUpdate $ UBind (Binding (mkVar \"_\", TUnit) callArchive) $\r\nEUpdate $ UPure chcReturnType (EVar $ mkVar \"res\")\r\n```",
        "createdAt" : "2019-04-17T12:40:05Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "89b0ff88-b57e-4b30-b7a9-c3f9c1024820",
        "parentId" : "2443443e-8a33-4d65-b220-5d66dcb0c76b",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-04-17T14:35:46Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "825b9042188d04bf812ad2955222e5d8e39d33dc",
    "line" : null,
    "diffHunk" : "@@ -353,9 +361,30 @@ convertChoice env (VarIs \"C:Choice\" `App` Type tmpl `App` Type (TypeCon chc [])\n             ETmLam thisBndr (ETmLam argBndr body)\n               | fst argBndr `Set.notMember` cata freeVarsStep body ->\n                 ETmLam thisBndr body `ETmApp` thisVar\n-            _ ->\n-                controllerExpr `ETmApp` thisVar `ETmApp` argVar\n-    chcUpdate <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+            _ -> controllerExpr `ETmApp` thisVar `ETmApp` argVar\n+    expr <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+    chcUpdate <-\n+      if not $ postConsuming\n+        then\n+          pure expr\n+      else\n+        do\n+           -- NOTE(SF): Support for 'postconsuming' choices. The idea\n+           -- is to evaluate the user provided choice body and\n+           -- following that, archive. That is, in pseduo-code, we are\n+           -- going for an expression like this:\n+           --     expr this self arg >>= \\res ->\n+           --     archive signatories self >>= \\_ -> return res\n+          let archive =\n+                EUpdate $\n+                  UExercise tmplTyCon'\n+                            (mkChoiceName \"Archive\")\n+                            selfVar signatories mkEUnit\n+              returnRes = EUpdate $ UPure chcReturnType (EVar $ mkVar \"res\")\n+          pure $\n+            EUpdate $\n+              UBind (Binding (mkVar \"res\", chcReturnType) expr)\n+                    (EUpdate $ UBind (Binding (mkVar \"_\", TUnit) archive) returnRes)"
  },
  {
    "id" : "29054691-495a-4648-ae21-f907fe113f19",
    "prId" : 574,
    "comments" : [
      {
        "id" : "ab881425-75dc-4d70-b6ec-504d3b8f92b2",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "If the EUpdate's aligned beneath each other i would find it more readadble",
        "createdAt" : "2019-04-17T15:27:25Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "4c3a325c-b459-4b23-8064-bbf05b31c4ba",
        "parentId" : "ab881425-75dc-4d70-b6ec-504d3b8f92b2",
        "author" : null,
        "body" : "✔️ ",
        "createdAt" : "2019-04-17T15:33:27Z",
        "updatedAt" : "2019-04-17T18:21:58Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "825b9042188d04bf812ad2955222e5d8e39d33dc",
    "line" : 80,
    "diffHunk" : "@@ -336,26 +336,52 @@ archiveChoice signatories = TemplateChoice{..}\n         chcSelfBinder = mkVar \"self\"\n         chcArgBinder = (mkVar \"arg\", TUnit)\n \n-convertChoice :: Env -> GHC.Expr Var -> ConvertM TemplateChoice\n-convertChoice env (VarIs \"C:Choice\" `App` Type tmpl `App` Type (TypeCon chc []) `App` Type result `App` _templateDict\n-        `App` consuming `App` Var controller `App` choice `App` _exercise) = do\n-    chcConsuming <- f (10 :: Int) consuming\n+data Consuming = PreConsuming\n+               | NonConsuming\n+               | PostConsuming\n+               deriving (Eq)\n+\n+convertChoice :: Env -> LF.Expr -> GHC.Expr Var -> ConvertM TemplateChoice\n+convertChoice env signatories\n+  (VarIs \"C:Choice\" `App`\n+     Type tmpl@(TypeCon tmplTyCon []) `App`\n+       Type (TypeCon chc []) `App`\n+         Type result `App`\n+           _templateDict `App`\n+             consuming `App`\n+               Var controller `App`\n+                 choice `App` _exercise) = do\n+    consumption <- f (10 :: Int) consuming\n+    let chcConsuming = consumption == PreConsuming -- Runtime should auto-archive?\n     argType <- convertType env $ TypeCon chc []\n     let chcArgBinder = (mkVar \"arg\", argType)\n     tmplType <- convertType env tmpl\n+    tmplTyCon' <- convertQualified env tmplTyCon\n     chcReturnType <- convertType env result\n     controllerExpr <- envFindBind env controller >>= convertExpr env\n     let chcControllers = case controllerExpr of\n-            -- NOTE(MH): We drop the second argument to `controllerExpr` when\n-            -- it is unused. This is necessary to make sure that a\n-            -- non-flexible controller expression does not mention the choice\n-            -- argument `argVar`.\n-            ETmLam thisBndr (ETmLam argBndr body)\n-              | fst argBndr `Set.notMember` cata freeVarsStep body ->\n-                ETmLam thisBndr body `ETmApp` thisVar\n-            _ ->\n-                controllerExpr `ETmApp` thisVar `ETmApp` argVar\n-    chcUpdate <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+          -- NOTE(MH): We drop the second argument to `controllerExpr` when\n+          -- it is unused. This is necessary to make sure that a\n+          -- non-flexible controller expression does not mention the choice\n+          -- argument `argVar`.\n+          ETmLam thisBndr (ETmLam argBndr body)\n+            | fst argBndr `Set.notMember` cata freeVarsStep body ->\n+              ETmLam thisBndr body `ETmApp` thisVar\n+          _ -> controllerExpr `ETmApp` thisVar `ETmApp` argVar\n+    expr <- fmap (\\u -> u `ETmApp` thisVar `ETmApp` selfVar `ETmApp` argVar) (convertExpr env choice)\n+    let chcUpdate =\n+          if consumption /= PostConsuming then expr\n+          else\n+            -- NOTE(SF): Support for 'postconsuming' choices. The idea\n+            -- is to evaluate the user provided choice body and\n+            -- following that, archive. That is, in pseduo-code, we are\n+            -- going for an expression like this:\n+            --     expr this self arg >>= \\res ->\n+            --     archive signatories self >>= \\_ -> return res\n+            let archive = EUpdate $ UExercise tmplTyCon' (mkChoiceName \"Archive\") selfVar signatories mkEUnit\n+            in EUpdate $ UBind (Binding (mkVar \"res\", chcReturnType) expr) $"
  },
  {
    "id" : "98143d1d-f194-4f00-acd9-ec3ec1e73b7e",
    "prId" : 514,
    "comments" : [
      {
        "id" : "da81212d-923d-48c8-a325-c9c79b83617e",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "```suggestion\r\n             abs (r * 10 ^ maxPrecision)) <= upperBound128Bit - 1 ->\r\n```",
        "createdAt" : "2019-04-16T08:11:58Z",
        "updatedAt" : "2019-04-16T10:02:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4c3774f8-ad30-4251-bb72-c6ae0289f73d",
        "parentId" : "da81212d-923d-48c8-a325-c9c79b83617e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if this might be cleaner with `integerLog10` and potentially also faster, e.g. `integerLog10 (abs r) < 128 - maxPrecision`.",
        "createdAt" : "2019-04-16T08:21:32Z",
        "updatedAt" : "2019-04-16T10:02:02Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a409b3f7-d069-4174-bfa6-978f74e9c20b",
        "parentId" : "da81212d-923d-48c8-a325-c9c79b83617e",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I find the original (not using logs) clearer and closer to the semantics defined in LF.",
        "createdAt" : "2019-04-16T08:54:50Z",
        "updatedAt" : "2019-04-16T10:02:02Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "828f560794bb945ad47f5e080f31abfcb818a82b",
    "line" : null,
    "diffHunk" : "@@ -240,6 +240,27 @@ convertInt64 x\n     | otherwise =\n         unsupported \"Int literal out of bounds\" (negate x)\n \n+convertRational :: Integer -> Integer -> ConvertM LF.Expr\n+convertRational num denom\n+ =\n+    -- the denominator needs to be a divisor of 10^10.\n+    -- num % denom * 10^10 needs to fit within a 128bit signed number.\n+    -- note that we can also get negative rationals here, hence we ask for upperBound128Bit - 1 as\n+    -- upper limit.\n+    if | 10 ^ maxPrecision `mod` denom == 0 &&\n+             abs (r * 10 ^ (10 :: Integer)) <= upperBound128Bit - 1 ->"
  },
  {
    "id" : "c91e7926-52fc-4fab-b8ca-5af959587b8f",
    "prId" : 508,
    "comments" : [
      {
        "id" : "fbef9655-7501-482a-a589-c9f88edde522",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It looks like this should check the module name similar to the check for `Pair` below.",
        "createdAt" : "2019-04-16T06:22:14Z",
        "updatedAt" : "2019-04-16T06:30:47Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "ad809f52-ca5d-4c41-8621-7bb5a2918fa5",
        "parentId" : "fbef9655-7501-482a-a589-c9f88edde522",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Half our stuff should do that... In general any use of VarIs is wrong.",
        "createdAt" : "2019-04-16T09:17:24Z",
        "updatedAt" : "2019-04-16T09:18:47Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "eaf92b94a01cfef9127618cacb514fc95e11ff03",
    "line" : 22,
    "diffHunk" : "@@ -568,6 +568,13 @@ convertExpr env0 e = do\n             { retrieveByKeyTemplate = tmpl'\n             , retrieveByKeyKey = EVar varV1\n             }\n+    go env (VarIs \"unpackPair\") (LType (StrLitTy f1) : LType (StrLitTy f2) : LType t1 : LType t2 : args)"
  },
  {
    "id" : "68c49d19-eb4f-4dde-9ab1-3571257b0a81",
    "prId" : 508,
    "comments" : [
      {
        "id" : "37b3e0c9-af37-449e-9229-a80f92721f87",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I wonder if we should throw an error if `Pair` is not applied to `StrLitTy` instead of falling into the `otherwise` clause. I don’t think it should matter since users cannot produce use `Pair` anyway but it might make the intention of the code a bit clearer.",
        "createdAt" : "2019-04-16T06:24:43Z",
        "updatedAt" : "2019-04-16T06:30:47Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "108a0255-bffd-4822-a3b3-da949beaee88",
        "parentId" : "37b3e0c9-af37-449e-9229-a80f92721f87",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "We could, but it's more code and makes it harder to read.",
        "createdAt" : "2019-04-16T09:17:53Z",
        "updatedAt" : "2019-04-16T09:18:47Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "eaf92b94a01cfef9127618cacb514fc95e11ff03",
    "line" : 39,
    "diffHunk" : "@@ -1073,6 +1080,13 @@ convertType env o@(TypeCon t ts)\n         if supportsArrowType (envLfVersion env) || length ts' == 2\n           then foldl TApp TArrow <$> traverse (convertType env) ts'\n           else unsupported \"Partial application of (->)\" o\n+    | Just m <- nameModule_maybe (getName t)\n+    , GHC.moduleName m == mkModuleName \"DA.Internal.LF\"\n+    , getOccString t == \"Pair\"\n+    , [StrLitTy f1, StrLitTy f2, t1, t2] <- ts = do"
  },
  {
    "id" : "cf7abc2b-faa7-439b-b96a-409ae6125cab",
    "prId" : 418,
    "comments" : [
      {
        "id" : "f58a9f0f-69a8-4b5c-835c-1cbad42ee294",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Would have been nice to get a little more details about the input structural record invariants in the comment. I assume it's `{_1 : a, _2: b, ...}`?",
        "createdAt" : "2019-04-12T09:06:34Z",
        "updatedAt" : "2019-04-12T09:06:38Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "375508d8-de05-4279-8e98-c11ce2d5f1e8",
        "parentId" : "f58a9f0f-69a8-4b5c-835c-1cbad42ee294",
        "author" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "body" : "I thought that would be obvious from the `[(FieldName, LF.Type)]` part of the type signature. I'll improve it in a followup PR.",
        "createdAt" : "2019-04-12T12:45:37Z",
        "updatedAt" : "2019-04-12T12:45:47Z",
        "lastEditedBy" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a62dbd84-d5b1-4841-8e09-e621108e092d",
        "parentId" : "f58a9f0f-69a8-4b5c-835c-1cbad42ee294",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Maybe it is now I look closer... but I guess i still don't know what the invariants on the field names are.",
        "createdAt" : "2019-04-12T12:47:09Z",
        "updatedAt" : "2019-04-12T12:47:13Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b8a7d3be-a363-45b1-9f4b-d1a2ceb28155",
        "parentId" : "f58a9f0f-69a8-4b5c-835c-1cbad42ee294",
        "author" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "body" : "The fields of the input structural record are put into the tuple in the order they appear in the list. The tuple's fields are name `_1`, `_2`, ... as usual. I'll given an example in the code.",
        "createdAt" : "2019-04-12T13:10:52Z",
        "updatedAt" : "2019-04-12T13:10:52Z",
        "lastEditedBy" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c02fd6e5fcdc3aee7f1a1821c95b2024deca90ac",
    "line" : 31,
    "diffHunk" : "@@ -1270,6 +1267,15 @@ mkPure env monad dict t x = do\n           `ETyApp` t\n           `ETmApp` x\n \n+-- | Turn the structural record referenced by `x` into a tuple from `GHC.Tuple`."
  },
  {
    "id" : "5b3e2f57-824d-48ee-9bb5-84e3226349a4",
    "prId" : 340,
    "comments" : [
      {
        "id" : "a91a1494-d148-4b51-8021-f6aa4c1a9ca0",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Didn't we have a helper function to test if something was a single constructor?",
        "createdAt" : "2019-04-09T17:46:47Z",
        "updatedAt" : "2019-04-09T17:46:55Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "80be345e-26fe-401e-a20c-3531b8423736",
        "parentId" : "a91a1494-d148-4b51-8021-f6aa4c1a9ca0",
        "author" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "body" : "The helper function works on the data constructor level, not the type constructor level.",
        "createdAt" : "2019-04-09T17:54:25Z",
        "updatedAt" : "2019-04-09T17:54:25Z",
        "lastEditedBy" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "380229ce20d9441f07e534534ac25314da8235fa",
    "line" : 9,
    "diffHunk" : "@@ -566,7 +566,11 @@ convertExpr env0 e = do\n     go env (VarIs \"getFieldPrim\") (Type (isStrLitTy -> Just name) : Type record : Type _field : args) = fmap (, args) $ do\n         record' <- convertType env record\n         pure $ ETmLam (varV1, record') $ ERecProj (fromTCon record') (mkField $ unpackFS name) $ EVar varV1\n-    go env (VarIs \"getField\") (Type (isStrLitTy -> Just name) : Type recordType : Type _fieldType : _dict : record : args) = fmap (, args) $ do\n+    -- NOTE(MH): We only inline `getField` for record types. This is required\n+    -- for contract keys. Projections on sum-of-records types have to through\n+    -- the type class for `getField`.\n+    go env (VarIs \"getField\") (Type (isStrLitTy -> Just name) : Type recordType@(TypeCon recordTyCon _) : Type _fieldType : _dict : record : args)\n+        | Just [_] <- tyConDataCons_maybe recordTyCon = fmap (, args) $ do"
  },
  {
    "id" : "eb8b8c5a-fbdb-48a5-bb0a-e5f919f6f6cd",
    "prId" : 336,
    "comments" : [
      {
        "id" : "54005582-e03b-4eb0-826e-bf9e8723b6e8",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\n                then convertLet env bind scrutinee $ \\env -> do\r\n```",
        "createdAt" : "2019-04-09T16:08:26Z",
        "updatedAt" : "2019-04-09T16:49:42Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "47d10443d5adeea56d651d5bdcd88988131d1d5b",
    "line" : null,
    "diffHunk" : "@@ -809,31 +805,24 @@ convertExpr env0 e = do\n           TContractId{} -> asLet\n           TUpdate{} -> asLet\n           TScenario{} -> asLet\n-          tcon0 -> do\n-              ctor <- toCtor env con\n+          tcon -> do\n+              ctor@(Ctor _ fldNames fldTys) <- toCtor env con\n               if not (isRecordCtor ctor)\n-                then do\n+                then convertLet env bind scrutinee $  \\env -> do"
  },
  {
    "id" : "c66faa28-da4d-4246-863f-c7709c1baecc",
    "prId" : 336,
    "comments" : [
      {
        "id" : "58b9740e-a110-4f17-b810-64b93528d88b",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Comment seems to add zero value, since the same comment is in the error message",
        "createdAt" : "2019-04-09T16:09:04Z",
        "updatedAt" : "2019-04-09T16:49:42Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d2710bca-9089-482b-be32-a19f41024457",
        "parentId" : "58b9740e-a110-4f17-b810-64b93528d88b",
        "author" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "body" : "You're right. I removed it.",
        "createdAt" : "2019-04-09T17:15:45Z",
        "updatedAt" : "2019-04-09T17:15:46Z",
        "lastEditedBy" : {
          "login" : "martin-drhu-da",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/31696042?u=5fec5d8a968715bab332fcb4be485319b66a7892&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "47d10443d5adeea56d651d5bdcd88988131d1d5b",
    "line" : null,
    "diffHunk" : "@@ -809,31 +805,24 @@ convertExpr env0 e = do\n           TContractId{} -> asLet\n           TUpdate{} -> asLet\n           TScenario{} -> asLet\n-          tcon0 -> do\n-              ctor <- toCtor env con\n+          tcon -> do\n+              ctor@(Ctor _ fldNames fldTys) <- toCtor env con\n               if not (isRecordCtor ctor)\n-                then do\n+                then convertLet env bind scrutinee $  \\env -> do\n+                  bind' <- convertExpr env (Var bind)\n                   ty <- convertType env $ varType bind\n                   alt' <- convertAlt env ty alt\n-                  bind' <- convVarWithType env bind\n-                  pure $\n-                    ELet (Binding bind' scrutinee') $\n-                    ECase (EVar $ convVar bind) [alt']\n-                else mkProj ctor tcon0 scrutinee'\n+                  pure $ ECase bind' [alt']\n+                -- NOTE(MH): The 'zipExact' below fails for pattern matches on constructors with existentials."
  }
]