[
  {
    "id" : "f9ecab1f-5f0d-4c93-8c40-13ce37e88027",
    "prId" : 1856,
    "comments" : [
      {
        "id" : "a01c4c65-3b3c-400c-b89c-dff2a90e73aa",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not sure duplicating this logic is an improvement.",
        "createdAt" : "2019-06-25T08:23:24Z",
        "updatedAt" : "2019-06-25T08:35:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "72896203-8288-452c-a3a1-ede18b1524a0",
        "parentId" : "a01c4c65-3b3c-400c-b89c-dff2a90e73aa",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "I'm not convinced this pattern should exist anywhere - it should really be fused with whatever is producing it. By making it internal we can do that more easily. I suspect there's a further cleanup to be done here, but was aiming for one step at a time.",
        "createdAt" : "2019-06-25T08:27:54Z",
        "updatedAt" : "2019-06-25T08:35:17Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e3bf7771-3011-4abc-bf35-e659ec501eed",
        "parentId" : "a01c4c65-3b3c-400c-b89c-dff2a90e73aa",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Having operations that can only emit errors but not warnings doesnâ€™t seem that unreasonable to me but I donâ€™t feel particularly strongly about this.",
        "createdAt" : "2019-06-25T08:30:59Z",
        "updatedAt" : "2019-06-25T08:35:17Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0bf1e25d-89d3-4e6c-a94d-43d247f6b809",
        "parentId" : "a01c4c65-3b3c-400c-b89c-dff2a90e73aa",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "OK, I think you've convinced me. I put that bit back. Not sure `toIdeResult` is the right name, but we can solve that in future.",
        "createdAt" : "2019-06-25T08:35:43Z",
        "updatedAt" : "2019-06-25T08:35:44Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7c9eac8e-ba6d-4b4f-9262-62f858e8223a",
        "parentId" : "a01c4c65-3b3c-400c-b89c-dff2a90e73aa",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I full agree that `toIdeResult` is a terrible name, I was actually trying to change it recently but failed to come up with something better.",
        "createdAt" : "2019-06-25T08:53:17Z",
        "updatedAt" : "2019-06-25T08:53:18Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "1366d81730ae2fb1cf5f328b9e968190a8c6a187",
    "line" : null,
    "diffHunk" : "@@ -186,7 +192,7 @@ generateDalfRule =\n         unsimplifiedRawDalf <- use_ GenerateRawDalf file\n         let rawDalf = LF.simplifyModule unsimplifiedRawDalf\n         setPriority PriorityGenerateDalf\n-        pure $ toIdeResult $ do\n+        pure $ either (, Nothing) (([],) . Just) $ do"
  },
  {
    "id" : "7d7528f1-fb9c-41d7-8dc4-35734b9eb80d",
    "prId" : 1787,
    "comments" : [
      {
        "id" : "b72f0a01-616a-4942-a007-94672cf1cac4",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Everything here appears to be `lift`, so can the `runExceptT` and `lift`'s all die? And then we drop `toIdeResults`?",
        "createdAt" : "2019-06-20T19:59:50Z",
        "updatedAt" : "2019-06-20T21:50:12Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a0ca742d-a3da-4f0e-8c0d-8a0f928b8b5f",
        "parentId" : "b72f0a01-616a-4942-a007-94672cf1cac4",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, we still need `toIdeResult` to convert the `Either` to `IdeResult` though but this definitely simplifies things quite a bit.",
        "createdAt" : "2019-06-20T21:42:48Z",
        "updatedAt" : "2019-06-20T21:50:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6c63c3c27ddcd86f48255895209a8c629b2a0651",
    "line" : null,
    "diffHunk" : "@@ -153,14 +152,14 @@ generateRawDalfRule =\n -- Generates and type checks the DALF for a module.\n generateDalfRule :: Rules ()\n generateDalfRule =\n-    define $ \\GenerateDalf file -> fmap toIdeResultNew $ runExceptT $ do\n+    define $ \\GenerateDalf file -> fmap toIdeResult $ runExceptT $ do"
  },
  {
    "id" : "aba31d49-0684-4f14-bac6-b13e1510552a",
    "prId" : 1787,
    "comments" : [
      {
        "id" : "daad6199-c3a5-4f53-91fa-fd0eae5fa412",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Can we not use `use` here, and avoid the `actionToMaybe`?",
        "createdAt" : "2019-06-20T20:01:10Z",
        "updatedAt" : "2019-06-20T21:50:12Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "336b8b0e-c97e-4ec1-83cc-d6f3dce96646",
        "parentId" : "daad6199-c3a5-4f53-91fa-fd0eae5fa412",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good catch, changed.",
        "createdAt" : "2019-06-20T21:42:56Z",
        "updatedAt" : "2019-06-20T21:50:12Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "6c63c3c27ddcd86f48255895209a8c629b2a0651",
    "line" : null,
    "diffHunk" : "@@ -405,10 +404,10 @@ ofInterestRule = do\n         let scenarioFiles = files `Set.union` vrFiles\n         gc scenarioFiles\n         -- compile and notify any errors\n-        let runScenarios file = void $ runExceptT $ do\n-                world <- lift $ worldForFile file\n-                vrs <- useE RunScenarios file\n-                lift $ forM vrs $ \\(vr, res) -> do\n+        let runScenarios file = void $ actionToMaybe $ do\n+                world <- worldForFile file\n+                vrs <- use_ RunScenarios file"
  },
  {
    "id" : "430bbd26-bcbe-46e6-871b-e57341bbdb78",
    "prId" : 1763,
    "comments" : [
      {
        "id" : "76479582-d07e-47e3-bbdb-eb3529a1f46c",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Could you use `use` instead directly - that already returns a Maybe, so you don't have to wrap it in an either, run it in an either monad, then convert to a maybe.",
        "createdAt" : "2019-06-19T12:46:55Z",
        "updatedAt" : "2019-06-19T12:59:09Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2342fd6e-e708-4ff4-a026-977523ccb58c",
        "parentId" : "76479582-d07e-47e3-bbdb-eb3529a1f46c",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Good point, I changed it. We should go through some of the others, e.g., `getDalf` above and change them. The current logic doesnâ€™t make much sense.",
        "createdAt" : "2019-06-19T13:01:35Z",
        "updatedAt" : "2019-06-19T13:01:35Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "59625335-7342-4c08-b3ab-fb5711bd5f5b",
        "parentId" : "76479582-d07e-47e3-bbdb-eb3529a1f46c",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Indeed. `useE` is an odd beast.",
        "createdAt" : "2019-06-19T13:06:37Z",
        "updatedAt" : "2019-06-19T13:06:37Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "30e23927be5a5035de4e469a5aec00317d22d820",
    "line" : null,
    "diffHunk" : "@@ -123,13 +123,16 @@ getDalf :: NormalizedFilePath -> Action (Maybe LF.Package)\n getDalf file = eitherToMaybe <$>\n     (runExceptT $ useE GeneratePackage file)\n \n+getDalfModule :: NormalizedFilePath -> Action (Maybe LF.Module)\n+getDalfModule file = eitherToMaybe <$> (runExceptT $ useE GenerateDalf file)"
  },
  {
    "id" : "3111f7e2-3621-4d6c-81f7-ef5029010de1",
    "prId" : 1546,
    "comments" : [
      {
        "id" : "a8c9a610-a246-4e98-bb84-b2737fb392b1",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Why not just use the ScenarioValidation type here instead of LightValidation Bool?",
        "createdAt" : "2019-06-06T15:46:20Z",
        "updatedAt" : "2019-06-06T15:47:32Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3c1008b9-a154-49d0-b630-23d76f20f33e",
        "parentId" : "a8c9a610-a246-4e98-bb84-b2737fb392b1",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "`ScenarioValidation` is currently in `//daml-foundations/daml-ghc/ghc-compiler` (whether thatâ€™s a good name is another question, there is definitely DAML-specific stuff in there) which does not depend on the scenario service client. On the other hand the scenario service client does not depend on `ghc-compiler`. So using the same type would make the dependency tree less parallel which I was trying to avoid. That said, given that the scenario service client doesnâ€™t change too often it would probably be reasonable to make `ghc-compiler` depend on it but we might want to avoid until we finally reorganize the whole mess in `daml-foundations`.",
        "createdAt" : "2019-06-07T06:25:15Z",
        "updatedAt" : "2019-06-07T06:25:15Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3a092b38-cc86-45d1-b868-1ef672fb164e",
        "parentId" : "a8c9a610-a246-4e98-bb84-b2737fb392b1",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Fair enough. Happy to leave where it is for now.",
        "createdAt" : "2019-06-10T14:11:08Z",
        "updatedAt" : "2019-06-10T14:11:08Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "cd0ad0b9653daa38d98b765c3a776004fc70172e",
    "line" : 19,
    "diffHunk" : "@@ -177,10 +177,14 @@ contextForFile file = do\n     encodedModules <-\n         mapM (\\m -> fmap (\\(hash, bs) -> (hash, (LF.moduleName m, bs))) (encodeModule lfVersion m)) $\n         NM.toList $ LF.packageModules pkg\n+    DamlEnv{..} <- getDamlServiceEnv\n     pure SS.Context\n         { ctxModules = Map.fromList encodedModules\n         , ctxPackages = map (\\(pId, _, p, _) -> (pId, p)) (Map.elems pkgMap)\n         , ctxDamlLfVersion = lfVersion\n+        , ctxLightValidation = case envScenarioValidation of\n+              ScenarioValidationFull -> SS.LightValidation False"
  },
  {
    "id" : "032c4a8d-33ff-46c9-80b7-e3ce5ccd3f9a",
    "prId" : 1348,
    "comments" : [
      {
        "id" : "72752aa1-19fe-45ad-a465-e3ea7c5d564d",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Are you looking for Data.ByteString.UTF8.fromString?",
        "createdAt" : "2019-05-23T14:14:37Z",
        "updatedAt" : "2019-05-23T14:23:49Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c6c899a9-e700-4ed1-882a-ae2a960f3c7a",
        "parentId" : "72752aa1-19fe-45ad-a465-e3ea7c5d564d",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I was trying to avoid adding the dependency on `utf8-string` but 1. we already depend on it transitively and 2. there is really no reason for doing that so changed to `Data.ByteString.UTF8.fromString`.",
        "createdAt" : "2019-05-23T14:25:09Z",
        "updatedAt" : "2019-05-23T14:25:09Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4cee76f7-623a-4545-87b0-24fcd4228bf8",
        "parentId" : "72752aa1-19fe-45ad-a465-e3ea7c5d564d",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "At one point I spent some time optimising it, specifically this function, so keen to make use of it ðŸ˜„",
        "createdAt" : "2019-05-23T14:45:47Z",
        "updatedAt" : "2019-05-23T14:45:47Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c143cc6f26e9415317306b9fe2e89d79cb3f95d0",
    "line" : null,
    "diffHunk" : "@@ -339,6 +335,23 @@ ofInterestRule = do\n               prevCtxRoots <- modifyVar envPreviousScenarioContexts $ \\prevCtxs -> pure (ctxRoots, prevCtxs)\n               when (prevCtxRoots /= ctxRoots) $ void $ SS.gcCtxs scenarioService ctxRoots\n \n+getFilesOfInterestRule :: Rules ()\n+getFilesOfInterestRule = do\n+    defineEarlyCutoff $ \\GetFilesOfInterest _file -> assert (null _file) $ do\n+        alwaysRerun\n+        Env{..} <- getServiceEnv\n+        filesOfInterest <- liftIO $ readVar envOfInterestVar\n+        pure (Just $ T.encodeUtf8 $ T.pack $ show filesOfInterest, ([], Just filesOfInterest))\n+\n+getOpenVirtualResourcesRule :: Rules ()\n+getOpenVirtualResourcesRule = do\n+    defineEarlyCutoff $ \\GetOpenVirtualResources _file -> assert (null _file) $ do\n+        alwaysRerun\n+        DamlEnv{..} <- getDamlServiceEnv\n+        openVRs <- liftIO $ readVar envOpenVirtualResources\n+        pure (Just $ T.encodeUtf8 $ T.pack $ show openVRs, ([], Just openVRs))"
  },
  {
    "id" : "d244c7a2-a6fd-47bf-abcb-e83ca89e3814",
    "prId" : 1331,
    "comments" : [
      {
        "id" : "13c4a9de-c6a0-49bb-b194-043f79e380f6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n        -- between files of interest so we union them separately. (`Map.union` is left-biased.)\r\n```",
        "createdAt" : "2019-05-23T09:26:11Z",
        "updatedAt" : "2019-05-23T09:59:52Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f7856c13f1fa4b5b7074122c6ae3d4bcc1b15b5e",
    "line" : null,
    "diffHunk" : "@@ -251,13 +250,36 @@ runScenariosRule =\n       let (diags, results) = unzip scenarioResults\n       pure (catMaybes diags, Just results)\n \n+lookupScenarioRoot :: FilePath -> Action FilePath\n+lookupScenarioRoot file = do\n+    use_ SetScenarioRoots \"\"\n+    ctxRoots <- liftIO . readVar . envScenarioContextRoots =<< getDamlServiceEnv\n+    liftIO $ maybe (throwIO $ ScenarioRootException file) pure $ Map.lookup file ctxRoots\n+\n encodeModule :: LF.Version -> LF.Module -> Action (SS.Hash, BS.ByteString)\n encodeModule lfVersion m =\n     case LF.moduleSource m of\n       Just file\n         | isAbsolute file -> use_ EncodeModule file\n       _ -> pure $ SS.encodeModule lfVersion m\n \n+setScenarioRootsRule :: Rules ()\n+setScenarioRootsRule =\n+    defineNoFile $ \\SetScenarioRoots -> do\n+        alwaysRerun\n+        Env{..} <- getServiceEnv\n+        DamlEnv{..} <- getDamlServiceEnv\n+        filesOfInterest <- liftIO $ readVar envOfInterestVar\n+        openVRs <- liftIO $ readVar envOpenVirtualResources\n+        let files = Set.toList (filesOfInterest `Set.union` Set.map vrScenarioFile openVRs)\n+        deps <- forP files $ \\file -> do\n+            transitiveDeps <- maybe [] transitiveModuleDeps <$> use GetDependencies file\n+            pure $ Map.fromList [ (f, file) | f <- transitiveDeps ]\n+        -- We want to ensure that files of interest always map to themselves even if there are dependencies\n+        -- between files of interest so we union them separately."
  },
  {
    "id" : "29473f85-36ad-4950-ae64-e40e32531c76",
    "prId" : 1331,
    "comments" : [
      {
        "id" : "ed73cf06-c4b0-4bc7-a551-9c1a64f89a23",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Data.Tuple.Extra.dupe",
        "createdAt" : "2019-05-23T09:51:14Z",
        "updatedAt" : "2019-05-23T09:59:52Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "305cbced-1e4f-4480-9b34-fd3f08490a66",
        "parentId" : "ed73cf06-c4b0-4bc7-a551-9c1a64f89a23",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : ":+1:",
        "createdAt" : "2019-05-23T10:00:00Z",
        "updatedAt" : "2019-05-23T10:00:01Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f7856c13f1fa4b5b7074122c6ae3d4bcc1b15b5e",
    "line" : null,
    "diffHunk" : "@@ -258,6 +258,29 @@ encodeModule lfVersion m =\n         | isAbsolute file -> use_ EncodeModule file\n       _ -> pure $ SS.encodeModule lfVersion m\n \n+getScenarioRootsRule :: Rules ()\n+getScenarioRootsRule =\n+    defineNoFile $ \\GetScenarioRoots -> do\n+        alwaysRerun\n+        Env{..} <- getServiceEnv\n+        DamlEnv{..} <- getDamlServiceEnv\n+        filesOfInterest <- liftIO $ readVar envOfInterestVar\n+        openVRs <- liftIO $ readVar envOpenVirtualResources\n+        let files = Set.toList (filesOfInterest `Set.union` Set.map vrScenarioFile openVRs)\n+        deps <- forP files $ \\file -> do\n+            transitiveDeps <- maybe [] transitiveModuleDeps <$> use GetDependencies file\n+            pure $ Map.fromList [ (f, file) | f <- transitiveDeps ]\n+        -- We want to ensure that files of interest always map to themselves even if there are dependencies\n+        -- between files of interest so we union them separately. (`Map.union` is left-biased.)\n+        pure $ Map.fromList [(f,f) | f <- files] `Map.union` Map.unions deps"
  },
  {
    "id" : "d784b484-2f83-443e-9ac0-7095623190a6",
    "prId" : 1331,
    "comments" : [
      {
        "id" : "b79b5ac0-aba6-4d9e-ac4d-efc8aed65e3e",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "If this is an internal exception just call `fail` or similar.",
        "createdAt" : "2019-05-23T09:52:10Z",
        "updatedAt" : "2019-05-23T09:59:52Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "38acad58-2e09-4802-b2af-ba87ca274046",
        "parentId" : "b79b5ac0-aba6-4d9e-ac4d-efc8aed65e3e",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Changed to `fail`",
        "createdAt" : "2019-05-23T10:00:08Z",
        "updatedAt" : "2019-05-23T10:00:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f7856c13f1fa4b5b7074122c6ae3d4bcc1b15b5e",
    "line" : null,
    "diffHunk" : "@@ -258,6 +258,29 @@ encodeModule lfVersion m =\n         | isAbsolute file -> use_ EncodeModule file\n       _ -> pure $ SS.encodeModule lfVersion m\n \n+getScenarioRootsRule :: Rules ()\n+getScenarioRootsRule =\n+    defineNoFile $ \\GetScenarioRoots -> do\n+        alwaysRerun\n+        Env{..} <- getServiceEnv\n+        DamlEnv{..} <- getDamlServiceEnv\n+        filesOfInterest <- liftIO $ readVar envOfInterestVar\n+        openVRs <- liftIO $ readVar envOpenVirtualResources\n+        let files = Set.toList (filesOfInterest `Set.union` Set.map vrScenarioFile openVRs)\n+        deps <- forP files $ \\file -> do\n+            transitiveDeps <- maybe [] transitiveModuleDeps <$> use GetDependencies file\n+            pure $ Map.fromList [ (f, file) | f <- transitiveDeps ]\n+        -- We want to ensure that files of interest always map to themselves even if there are dependencies\n+        -- between files of interest so we union them separately. (`Map.union` is left-biased.)\n+        pure $ Map.fromList [(f,f) | f <- files] `Map.union` Map.unions deps\n+\n+getScenarioRootRule :: Rules ()\n+getScenarioRootRule =\n+    defineEarlyCutoff $ \\GetScenarioRoot file -> do\n+        ctxRoots <- use_ GetScenarioRoots \"\"\n+        case Map.lookup file ctxRoots of\n+            Nothing -> liftIO $ throwIO $ ScenarioRootException file"
  }
]