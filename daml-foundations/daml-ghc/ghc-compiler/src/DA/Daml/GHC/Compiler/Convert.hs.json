[
  {
    "id" : "d88dd578-5cf7-4cc6-877a-06a3d7db48f6",
    "prId" : 1707,
    "comments" : [
      {
        "id" : "50f31876-73fe-4300-aa96-3596395428ea",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Debug dropping?",
        "createdAt" : "2019-06-17T11:54:15Z",
        "updatedAt" : "2019-06-17T14:05:04Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "db5ae750-44c6-4cab-a43b-2de66c09d2a6",
        "parentId" : "50f31876-73fe-4300-aa96-3596395428ea",
        "author" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "body" : "good catch, will remove.",
        "createdAt" : "2019-06-17T12:01:52Z",
        "updatedAt" : "2019-06-17T14:05:04Z",
        "lastEditedBy" : {
          "login" : "robin-da",
          "name" : "Robin Krom",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/14074936?u=1b47fdbdfd82ea534219fc1b94d646873c56a7d7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "2c4e7e69876be18b89db41c246ef31aad2dcd83d",
    "line" : null,
    "diffHunk" : "@@ -1292,7 +1292,7 @@ convertKind x@(TypeCon t ts)\n     | is t == \"Meta\", null ts = pure KStar\n     | t == funTyCon, [_,_,t1,t2] <- ts = KArrow <$> convertKind t1 <*> convertKind t2\n convertKind (TyVarTy x) = convertKind $ tyVarKind x\n-convertKind x = unhandled \"Kind\" x\n+convertKind x = pprTrace \"convertKind\" (ppr x) $ unhandled \"Kind\" x"
  },
  {
    "id" : "daa507dc-e60a-442d-84a0-e579138593fe",
    "prId" : 1550,
    "comments" : [
      {
        "id" : "015c1489-090d-4fbe-ba0b-26d1d557a47c",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "```suggestion\r\ninternalTypes = [\"Scenario\",\"Update\",\"ContractId\",\"Time\",\"Date\",\"Party\",\"Pair\",\"TextMap\"]\r\n```",
        "createdAt" : "2019-06-06T19:26:42Z",
        "updatedAt" : "2019-06-07T21:36:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1e40aeb40fbf82a851c87a99859d87ecf2a54b5f",
    "line" : 5,
    "diffHunk" : "@@ -636,7 +636,7 @@ convertBind2 env (Rec xs) = concatMapM (\\(a, b) -> convertBind env (NonRec a b))\n -- during conversion to DAML-LF together with their constructors since we\n -- deliberately remove 'GHC.Types.Opaque' as well.\n internalTypes :: [String]\n-internalTypes = [\"Scenario\",\"Update\",\"ContractId\",\"Time\",\"Date\",\"Party\",\"Pair\"]\n+internalTypes = [\"Scenario\",\"Update\",\"ContractId\",\"Time\",\"Date\",\"Party\",\"Pair\", \"TextMap\"]"
  },
  {
    "id" : "84769832-0a61-4d74-a6cf-270fc315c552",
    "prId" : 1550,
    "comments" : [
      {
        "id" : "6fc1c75c-10f3-4a8c-bc50-9cea393a01dc",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Should this optional not be one further up? Isn't it in DA.Internal.LF? Should it be?",
        "createdAt" : "2019-06-06T19:33:33Z",
        "updatedAt" : "2019-06-07T21:36:40Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "bb9f739d-38c8-45ef-83fa-8870f37e490b",
        "parentId" : "6fc1c75c-10f3-4a8c-bc50-9cea393a01dc",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Given that we (should) erase during conversion to DAML-LF as well, it would make sense to have it in `DA.Internal.LF`. I'll move it in a separate PR.",
        "createdAt" : "2019-06-06T21:12:48Z",
        "updatedAt" : "2019-06-07T21:36:40Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1e40aeb40fbf82a851c87a99859d87ecf2a54b5f",
    "line" : 15,
    "diffHunk" : "@@ -1245,9 +1245,9 @@ convertTyCon env t\n             \"Party\" -> pure TParty\n             \"Date\" -> pure TDate\n             \"Time\" -> pure TTimestamp\n+            \"TextMap\" -> pure (TBuiltin BTMap)\n             _ -> defaultTyCon\n     | isBuiltinName \"Optional\" t = pure (TBuiltin BTOptional)"
  },
  {
    "id" : "516b7c1d-c602-4d40-9ba4-346e695c6b01",
    "prId" : 1439,
    "comments" : [
      {
        "id" : "804ac99d-fac9-463d-b3c4-2f91c51d4149",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Adding more and more cases where we donâ€™t at least match on the module name makes me sad. We should really fix this soon or at least do it properly for new code.",
        "createdAt" : "2019-05-29T06:39:10Z",
        "updatedAt" : "2019-05-29T06:45:58Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f3c223e9-75c9-4dff-94ec-e9dafcdd0f47",
        "parentId" : "804ac99d-fac9-463d-b3c4-2f91c51d4149",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I agree in general but I think this place is not particularly scary since the parser will generate these instances and hence it's under our control. At some point I will just kill the `Is` pattern synonym and force every pattern match to be proper.",
        "createdAt" : "2019-05-29T08:04:54Z",
        "updatedAt" : "2019-05-29T08:04:54Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "61cb487540d5ac1ba0bd5213722cdfb44b658e08",
    "line" : 13,
    "diffHunk" : "@@ -349,19 +349,32 @@ convertGenericTemplate env x\n         let tplPrecondition = ETrue\n         let tplAgreement = mkEmptyText\n         let tplKey = Nothing\n+        archive <- convertExpr env (Var archive)\n         let convertGenericChoice :: [Var] -> ConvertM (TemplateChoice, [LF.Expr])\n-            convertGenericChoice [controllers, action, exercise] = do\n+            convertGenericChoice [consumption, controllers, action, exercise] = do\n                 TContractId _ :-> _ :-> argType@(TConApp argTCon _) :-> TUpdate resType <- convertType env (varType action)\n                 let chcLocation = Nothing\n                 let chcName = ChoiceName $ T.intercalate \".\" $ unTypeConName $ qualObject argTCon\n-                let chcConsuming = True\n+                consumptionType <- case varType consumption of\n+                    TypeCon (Is \"NonConsuming\") _ -> pure NonConsuming"
  },
  {
    "id" : "9c222bbd-6639-4910-87a6-902ea6cf0bc7",
    "prId" : 1396,
    "comments" : [
      {
        "id" : "f17c5f03-7706-4d99-ab98-a7266fe962f5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This diff is mostly due to an additional level of indentation. \"Hide whitespace changes\" is your friend here.",
        "createdAt" : "2019-05-27T08:56:19Z",
        "updatedAt" : "2019-05-27T08:56:19Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "61719f027973d0fec992d13efc4d824a5973abf8",
    "line" : 82,
    "diffHunk" : "@@ -1107,36 +1101,39 @@ convertCast env expr co = do\n -- Coercions induced by newtypes can also occur deeply nested in function\n -- types or forall quantifications. We handle those cases by recursion into\n -- all sub-coercions.\n-convertCoercion :: Env -> Coercion -> StateT Int ConvertM (LF.Expr -> LF.Expr, LF.Expr -> LF.Expr)\n-convertCoercion env co@(coercionKind -> Pair s t)\n-    | isReflCo co = pure (id, id)\n-    | Just (aCo, bCo) <- splitFunCo_maybe co = do\n-        let Pair a a' = coercionKind aCo\n-        (aTo, aFrom) <- convertCoercion env aCo\n-        (bTo, bFrom) <- convertCoercion env bCo\n-        a <- lift $ convertType env a\n-        a' <- lift $ convertType env a'\n-        x <- mkLamBinder\n-        let to expr = ETmLam (x, a') $ bTo $ ETmApp expr $ aFrom $ EVar x\n-        let from expr = ETmLam (x, a) $ bFrom $ ETmApp expr $ aTo $ EVar x\n-        pure (to, from)\n-    -- NOTE(MH): This case is commented out because we don't know how to trigger\n-    -- it in a test case yet. In theory it should do the right thing though.\n-    -- | Just (a, k_co, co') <- splitForAllCo_maybe co\n-    -- , isReflCo k_co\n-    -- = do\n-    --     (a, k) <- lift $ convTypeVar a\n-    --     (to', from') <- convertCoercion env co'\n-    --     let to expr = ETyLam (a, k) $ to' $ ETyApp expr $ TVar a\n-    --     let from expr = ETyLam (a, k) $ from' $ ETyApp expr $ TVar a\n-    --     pure (to, from)\n-    -- Case (1) & (2)\n-    | Just (tCon, ts, field, flv) <- isSatNewTyCon s t = newtypeCoercion tCon ts field flv\n-    | Just (tCon, ts, field, flv) <- isSatNewTyCon t s = swap <$> newtypeCoercion tCon ts field flv\n-    | SymCo co' <- co = swap <$> convertCoercion env co'\n-    | SubCo co' <- co = convertCoercion env co'\n-    | otherwise = lift $ unhandled \"Coercion\" co\n+convertCoercion :: Env -> Coercion -> ConvertM (LF.Expr -> LF.Expr, LF.Expr -> LF.Expr)\n+convertCoercion env co = evalStateT (go env co) 0\n   where\n+    go :: Env -> Coercion -> StateT Int ConvertM (LF.Expr -> LF.Expr, LF.Expr -> LF.Expr)"
  },
  {
    "id" : "2f9946e2-ce3b-4d85-a045-fde83913edaa",
    "prId" : 1383,
    "comments" : [
      {
        "id" : "982a9187-2486-429d-a01d-93d502107a22",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Is it worth pushing an Int inside ConvertM? Having a way to find unique values seems like it could crop up in other places, and having those be unique inside a ConvertM seems like it could make things simpler. (That said, state is a fair bit slower than Reader, but I'm not sure how much we go through the monad)",
        "createdAt" : "2019-05-25T08:08:04Z",
        "updatedAt" : "2019-05-25T08:12:56Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9c3b01e1-240a-4ba5-b347-89dec571548b",
        "parentId" : "982a9187-2486-429d-a01d-93d502107a22",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "We definitely should use it elsewhere. There are quite a few places where we use hard coded names instead of fresh names which scare me. I'll do that one day...",
        "createdAt" : "2019-05-25T08:34:09Z",
        "updatedAt" : "2019-05-25T08:34:09Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1244a82574f2beea41d9a43de52cb3bccc7982e0",
    "line" : 87,
    "diffHunk" : "@@ -1022,117 +1022,55 @@ convertCast env expr co = do\n -- Coercions induced by newtypes can also occur deeply nested in function\n -- types or forall quantifications. We handle those cases by recursion into\n -- all sub-coercions.\n-convertCoercion :: Env -> Coercion -> StateT Int ConvertM (LF.Expr, LF.Expr)\n-convertCoercion env co\n-    | isReflCo co = do\n-        s' <- lift $ convertType env s\n-        t' <- lift $ convertType env t\n-        x <- mkVar <$> mkLamBinder\n-        let lamTo = ETmLam (x, s') (EVar x)\n-            lamFrom = ETmLam (x, t') (EVar x)\n-        pure (lamTo, lamFrom)\n-    | Just (xCo, yCo) <- splitFunCo_maybe co = do\n-        let Pair a a' = coercionKind xCo\n-        (aTo, aFrom) <- convertCoercion env xCo\n-        (bTo, bFrom) <- convertCoercion env yCo\n-        sLf <- lift $ convertType env s\n-        tLf <- lift $ convertType env t\n-        aLf <- lift $ convertType env a\n-        a'Lf <- lift $ convertType env a'\n-        f <- mkVar <$> mkLamBinder\n-        g <- mkVar <$> mkLamBinder\n-        x <- mkVar <$> mkLamBinder\n-        y <- mkVar <$> mkLamBinder\n-        let lamTo =\n-                ETmLam\n-                    (f, sLf)\n-                    (ETmLam\n-                         (x, a'Lf)\n-                         (bTo `ETmApp` (EVar f `ETmApp` (aFrom `ETmApp` EVar x))))\n-        let lamFrom =\n-                ETmLam\n-                    (g, tLf)\n-                    (ETmLam\n-                         (y, aLf)\n-                         (bFrom `ETmApp` (EVar g `ETmApp` (aTo `ETmApp` EVar y))))\n-        pure (lamTo, lamFrom)\n-    | Just (aGhc, k_co, co') <- splitForAllCo_maybe co\n-    , isReflCo k_co\n-     = do\n-        let Pair _aK a'K = coercionKind k_co\n-        (aTo, aFrom) <- convertCoercion env k_co\n-        (bTo, bFrom) <- convertCoercion env co'\n-        a'KLf <- lift $ convertKind a'K\n-        s' <- lift $ convertType env s\n-        t' <- lift $ convertType env t\n-        f <- mkVar <$> mkLamBinder\n-        g <- mkVar <$> mkLamBinder\n-        a' <- mkTypeVar <$> mkLamBinder\n-        (a, aKLf) <- lift $ convTypeVar aGhc\n-        let lamTo =\n-                ETmLam\n-                    (f, s')\n-                    (ETyLam\n-                         (a', a'KLf)\n-                         (bTo `ETmApp`\n-                          (EVar f `ETmApp` (aFrom `ETyApp` (TVar a')))))\n-        let lamFrom =\n-                ETmLam\n-                    (g, t')\n-                    (ETyLam\n-                         (a, aKLf)\n-                         (bFrom `ETmApp`\n-                          (EVar g `ETmApp` (aTo `ETyApp` (TVar a)))))\n-        pure (lamTo, lamFrom)\n-    -- Case (1) & (2)\n-    | Just (tCon, ts, field, flv) <- isSatNewTyCon s t = do\n-        newtypeCoercion tCon ts field flv s t\n-    | Just (tCon, ts, field, flv) <- isSatNewTyCon t s = do\n-        (to, from) <- swap <$> newtypeCoercion tCon ts field flv t s\n+convertCoercion :: Env -> Coercion -> StateT Int ConvertM (LF.Expr -> LF.Expr, LF.Expr -> LF.Expr)"
  },
  {
    "id" : "508a49a9-6a89-45e7-9c9a-dc15c15502e6",
    "prId" : 1383,
    "comments" : [
      {
        "id" : "ef336c5b-5cf9-4768-92bf-6a04cace73be",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Do you really need fresh variables here? I would have thought capture rules meant that even if they were named identically they wouldn't conflict? That means we can get rid of the StateT, which would simplify things.",
        "createdAt" : "2019-05-25T08:12:44Z",
        "updatedAt" : "2019-05-25T08:12:56Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "77c1771f-ac3e-45e9-b3c3-94a88f38a1d9",
        "parentId" : "ef336c5b-5cf9-4768-92bf-6a04cace73be",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "You're right, we don't necessarily need fresh names here. I'll remove them for now and consider reintroducing them when we have fresh name generation in `ConvertM`.",
        "createdAt" : "2019-05-25T08:34:42Z",
        "updatedAt" : "2019-05-25T08:34:42Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1244a82574f2beea41d9a43de52cb3bccc7982e0",
    "line" : 97,
    "diffHunk" : "@@ -1022,117 +1022,55 @@ convertCast env expr co = do\n -- Coercions induced by newtypes can also occur deeply nested in function\n -- types or forall quantifications. We handle those cases by recursion into\n -- all sub-coercions.\n-convertCoercion :: Env -> Coercion -> StateT Int ConvertM (LF.Expr, LF.Expr)\n-convertCoercion env co\n-    | isReflCo co = do\n-        s' <- lift $ convertType env s\n-        t' <- lift $ convertType env t\n-        x <- mkVar <$> mkLamBinder\n-        let lamTo = ETmLam (x, s') (EVar x)\n-            lamFrom = ETmLam (x, t') (EVar x)\n-        pure (lamTo, lamFrom)\n-    | Just (xCo, yCo) <- splitFunCo_maybe co = do\n-        let Pair a a' = coercionKind xCo\n-        (aTo, aFrom) <- convertCoercion env xCo\n-        (bTo, bFrom) <- convertCoercion env yCo\n-        sLf <- lift $ convertType env s\n-        tLf <- lift $ convertType env t\n-        aLf <- lift $ convertType env a\n-        a'Lf <- lift $ convertType env a'\n-        f <- mkVar <$> mkLamBinder\n-        g <- mkVar <$> mkLamBinder\n-        x <- mkVar <$> mkLamBinder\n-        y <- mkVar <$> mkLamBinder\n-        let lamTo =\n-                ETmLam\n-                    (f, sLf)\n-                    (ETmLam\n-                         (x, a'Lf)\n-                         (bTo `ETmApp` (EVar f `ETmApp` (aFrom `ETmApp` EVar x))))\n-        let lamFrom =\n-                ETmLam\n-                    (g, tLf)\n-                    (ETmLam\n-                         (y, aLf)\n-                         (bFrom `ETmApp` (EVar g `ETmApp` (aTo `ETmApp` EVar y))))\n-        pure (lamTo, lamFrom)\n-    | Just (aGhc, k_co, co') <- splitForAllCo_maybe co\n-    , isReflCo k_co\n-     = do\n-        let Pair _aK a'K = coercionKind k_co\n-        (aTo, aFrom) <- convertCoercion env k_co\n-        (bTo, bFrom) <- convertCoercion env co'\n-        a'KLf <- lift $ convertKind a'K\n-        s' <- lift $ convertType env s\n-        t' <- lift $ convertType env t\n-        f <- mkVar <$> mkLamBinder\n-        g <- mkVar <$> mkLamBinder\n-        a' <- mkTypeVar <$> mkLamBinder\n-        (a, aKLf) <- lift $ convTypeVar aGhc\n-        let lamTo =\n-                ETmLam\n-                    (f, s')\n-                    (ETyLam\n-                         (a', a'KLf)\n-                         (bTo `ETmApp`\n-                          (EVar f `ETmApp` (aFrom `ETyApp` (TVar a')))))\n-        let lamFrom =\n-                ETmLam\n-                    (g, t')\n-                    (ETyLam\n-                         (a, aKLf)\n-                         (bFrom `ETmApp`\n-                          (EVar g `ETmApp` (aTo `ETyApp` (TVar a)))))\n-        pure (lamTo, lamFrom)\n-    -- Case (1) & (2)\n-    | Just (tCon, ts, field, flv) <- isSatNewTyCon s t = do\n-        newtypeCoercion tCon ts field flv s t\n-    | Just (tCon, ts, field, flv) <- isSatNewTyCon t s = do\n-        (to, from) <- swap <$> newtypeCoercion tCon ts field flv t s\n+convertCoercion :: Env -> Coercion -> StateT Int ConvertM (LF.Expr -> LF.Expr, LF.Expr -> LF.Expr)\n+convertCoercion env co@(coercionKind -> Pair s t)\n+    | isReflCo co = pure (id, id)\n+    | Just (aCo, bCo) <- splitFunCo_maybe co = do\n+        let Pair a a' = coercionKind aCo\n+        (aTo, aFrom) <- convertCoercion env aCo\n+        (bTo, bFrom) <- convertCoercion env bCo\n+        a <- lift $ convertType env a\n+        a' <- lift $ convertType env a'\n+        x <- mkLamBinder\n+        let to expr = ETmLam (x, a') $ bTo $ ETmApp expr $ aFrom $ EVar x"
  },
  {
    "id" : "5290b1c2-378f-4dbb-9b1d-43bafd7b9acd",
    "prId" : 1219,
    "comments" : [
      {
        "id" : "d9802a6c-d278-4bf0-99fb-6100cf164821",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "Is this still right for non-complex keys? How can you change the semantics for the old one? Or do you believe this has identical semantics and is just a refactoring?",
        "createdAt" : "2019-05-17T15:43:32Z",
        "updatedAt" : "2019-05-17T19:10:12Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3faadac3-6339-4730-aafa-ef72072b6370",
        "parentId" : "d9802a6c-d278-4bf0-99fb-6100cf164821",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This function still does the right thing for contract keys obeying the syntactic restriction in DAML-LF 1.3. There's a check in the type checker making sure the restriction is obeyed for DAML-LF 1.3.",
        "createdAt" : "2019-05-17T15:51:10Z",
        "updatedAt" : "2019-05-17T19:10:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f2e9536b-51f3-4d79-a629-6b916442ae09",
        "parentId" : "d9802a6c-d278-4bf0-99fb-6100cf164821",
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "version14 = versionDev for now, then we have a single place to roll. I like that.",
        "createdAt" : "2019-05-17T15:58:47Z",
        "updatedAt" : "2019-05-17T19:10:12Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "6d46ed15-dfec-413b-a9e7-0c18875a2f2a",
        "parentId" : "d9802a6c-d278-4bf0-99fb-6100cf164821",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Done.",
        "createdAt" : "2019-05-17T16:04:27Z",
        "updatedAt" : "2019-05-17T19:10:12Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f61bf61289aec3ad8e0feaddd529f5d9ba7b2dd2",
    "line" : 17,
    "diffHunk" : "@@ -1329,38 +1329,25 @@ isRecordCtor (Ctor _ fldNames fldTys) = not (null fldNames) || null fldTys\n -- then 'maintainer' gets rewritten into\n --\n -- > maintainer = $key._2 ++ $key._1\n-rewriteMaintainer :: LF.Expr -> LF.Expr -> ConvertM LF.Expr\n-rewriteMaintainer key maintainer = do\n-    keyMap <- buildKeyMap key\n-    rewriteThisProjections keyMap maintainer\n+rewriteMaintainer :: Env -> LF.Expr -> LF.Expr -> ConvertM LF.Expr"
  }
]