[
  {
    "id" : "33b5cb98-0dd9-4b09-aa34-400dad710f31",
    "prId" : 1604,
    "comments" : [
      {
        "id" : "44a98f42-cd88-45fe-a926-bca90300e044",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n--   parseDecimal \"+12.0\" == Some 12.0\r\n```\r\nThe `.0` is crucial for the number to be a `Decimal`. Otherwise it would be an `Int`.",
        "createdAt" : "2019-06-12T11:34:39Z",
        "updatedAt" : "2019-06-12T11:39:29Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "4b93f407b1a75fec240d5bf753c73f9229ac421b",
    "line" : 15,
    "diffHunk" : "@@ -300,13 +300,15 @@ legacyParsePositiveDecimal cs =\n   legacyParseIntToDecimal cs = legacyParseInt_ intToDecimal cs 0.0\n \n -- | Attempt to parse a `Decimal` value from a given `Text`.\n--- To get `Some` value, the text must follow the regex '-'?[0-9]+('.'[0-9]+)?\n--- In particular, the shorthands `\".12\"` and `\"12.\"` do not work.\n+-- To get `Some` value, the text must follow the regex\n+-- `(-|\\+)?[0-9]+('.'[0-9]+)?`\n+-- In particular, the shorthands `\".12\"` and `\"12.\"` do not work,\n+-- but the value can be prefixed with `+`.\n -- Leading and trailing zeros are fine, however spaces are not.\n -- Examples:\n -- ```\n --   parseDecimal \"3.14\" == Some 3.14\n---   parseDecimal \"+12.0\" == None\n+--   parseDecimal \"+12.0\" == Some 12"
  },
  {
    "id" : "72283464-0ca1-445f-be29-58687779b1f2",
    "prId" : 1147,
    "comments" : [
      {
        "id" : "cabfbb16-ed41-411a-a307-6c1d4d8ca16f",
        "parentId" : null,
        "author" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "body" : "This comment isn't quite accurate - all the function guarantees is that the length of the fst result is a max of n and the length of the string. It can definitely be shorter.",
        "createdAt" : "2019-05-15T08:59:21Z",
        "updatedAt" : "2019-05-15T11:15:30Z",
        "lastEditedBy" : {
          "login" : "neil-da",
          "name" : "Neil Mitchell",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/35463327?u=0eb1719958bc6e449ec5e7df3a312fa566f5055d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "d596e77ec351a9f976be1f94424181b9a4e442f5",
    "line" : null,
    "diffHunk" : "@@ -187,6 +187,13 @@ splitOn (explode -> s) (explode -> t) =\n   let fixit = if L.isSuffixOf s t then (++ [\"\"]) else identity\n   in fixit $ implode <$> L.repeatedly (fmap (L.dropPrefix s) . L.breakOn s) t\n \n+-- | Split a text before a given position so that\n+-- `length (fst (splitAt n t)) == n`"
  }
]