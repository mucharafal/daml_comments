[
  {
    "id" : "b4494f5f-b59d-4ea0-adfa-e8ca1fddad43",
    "prId" : 3849,
    "comments" : [
      {
        "id" : "9ca7c2dd-7231-43cc-aaaa-39722cda4f11",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    val fields = ImmArray(None -> ValueInt64(0), ...)\r\n```",
        "createdAt" : "2019-12-16T21:32:01Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "03da1554-a527-47b5-9e13-4236e6bc5bf7",
        "parentId" : "9ca7c2dd-7231-43cc-aaaa-39722cda4f11",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done.",
        "createdAt" : "2020-01-14T14:43:16Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "234101313181b0ea39c66a646366bd28d3d2adfd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf\n+package value\n+\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.data._\n+import com.digitalasset.daml.lf.value.Value._\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.language.implicitConversions\n+\n+class ValueHasherSpec extends WordSpec with Matchers {\n+  private[this] def templateId(module: String, name: String) = Identifier(\n+    PackageId.assertFromString(\"package\"),\n+    QualifiedName(\n+      ModuleName.assertFromString(module),\n+      DottedName.assertFromString(name)\n+    )\n+  )\n+\n+  private[this] def complexValue = {\n+    val builder = ImmArray.newBuilder[(Option[Name], Value[AbsoluteContractId])]\n+    builder += None -> ValueInt64(0)\n+    builder += None -> ValueInt64(123456)\n+    builder += None -> ValueInt64(-1)\n+    builder += None -> ValueNumeric(decimal(0))\n+    builder += None -> ValueNumeric(decimal(BigDecimal(\"0.3333333333\")))\n+    builder += None -> ValueTrue\n+    builder += None -> ValueFalse\n+    builder += None -> ValueDate(Time.Date.assertFromDaysSinceEpoch(0))\n+    builder += None -> ValueDate(Time.Date.assertFromDaysSinceEpoch(123456))\n+    builder += None -> ValueTimestamp(Time.Timestamp.assertFromLong(0))\n+    builder += None -> ValueTimestamp(Time.Timestamp.assertFromLong(123456))\n+    builder += None -> ValueText(\"\")\n+    builder += None -> ValueText(\"abcd-äöü€\")\n+    builder += None -> ValueParty(Party.assertFromString(\"Alice\"))\n+    builder += None -> ValueUnit\n+    builder += None -> ValueNone\n+    builder += None -> ValueOptional(Some(ValueText(\"Some\")))\n+    builder += None -> ValueList(FrontStack(ValueText(\"A\"), ValueText(\"B\"), ValueText(\"C\")))\n+    builder += None -> ValueVariant(None, Name.assertFromString(\"Variant\"), ValueInt64(0))\n+    builder += None -> ValueRecord(\n+      None,\n+      ImmArray(\n+        None -> ValueText(\"field1\"),\n+        None -> ValueText(\"field2\")\n+      ))\n+    builder += None -> ValueTextMap(\n+      SortedLookupList(\n+        Map(\n+          \"keyA\" -> ValueText(\"valueA\"),\n+          \"keyB\" -> ValueText(\"valueB\")\n+        )))\n+    val fields = builder.result()"
  },
  {
    "id" : "7079c6b1-7981-4d91-bba3-e2d6f676edf9",
    "prId" : 3849,
    "comments" : [
      {
        "id" : "fa569050-fa4b-4f49-b9f4-f4c400334bc2",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n        VA.list(VA.text).inj(Vector(\"AA\", \"A\"))\r\n      // given import TypedValueGenerators.{ValueAddend => VA}\r\n```\r\n\r\n`ValueAddend` can variously be used to make hand-written (well-typed) `Value`s more obvious in tests. Most of the other collision tests in this file can benefit.",
        "createdAt" : "2019-12-16T21:37:16Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "450ccee7-e32b-4be3-89fe-dbd5775736a6",
        "parentId" : "fa569050-fa4b-4f49-b9f4-f4c400334bc2",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I rewrite the whole test with `ValueAddend`",
        "createdAt" : "2020-01-16T11:37:12Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "234101313181b0ea39c66a646366bd28d3d2adfd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,268 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf\n+package value\n+\n+import com.digitalasset.daml.lf.data.Ref._\n+import com.digitalasset.daml.lf.data._\n+import com.digitalasset.daml.lf.value.Value._\n+import org.scalatest.{Matchers, WordSpec}\n+\n+import scala.language.implicitConversions\n+\n+class ValueHasherSpec extends WordSpec with Matchers {\n+  private[this] def templateId(module: String, name: String) = Identifier(\n+    PackageId.assertFromString(\"package\"),\n+    QualifiedName(\n+      ModuleName.assertFromString(module),\n+      DottedName.assertFromString(name)\n+    )\n+  )\n+\n+  private[this] def complexValue = {\n+    val builder = ImmArray.newBuilder[(Option[Name], Value[AbsoluteContractId])]\n+    builder += None -> ValueInt64(0)\n+    builder += None -> ValueInt64(123456)\n+    builder += None -> ValueInt64(-1)\n+    builder += None -> ValueNumeric(decimal(0))\n+    builder += None -> ValueNumeric(decimal(BigDecimal(\"0.3333333333\")))\n+    builder += None -> ValueTrue\n+    builder += None -> ValueFalse\n+    builder += None -> ValueDate(Time.Date.assertFromDaysSinceEpoch(0))\n+    builder += None -> ValueDate(Time.Date.assertFromDaysSinceEpoch(123456))\n+    builder += None -> ValueTimestamp(Time.Timestamp.assertFromLong(0))\n+    builder += None -> ValueTimestamp(Time.Timestamp.assertFromLong(123456))\n+    builder += None -> ValueText(\"\")\n+    builder += None -> ValueText(\"abcd-äöü€\")\n+    builder += None -> ValueParty(Party.assertFromString(\"Alice\"))\n+    builder += None -> ValueUnit\n+    builder += None -> ValueNone\n+    builder += None -> ValueOptional(Some(ValueText(\"Some\")))\n+    builder += None -> ValueList(FrontStack(ValueText(\"A\"), ValueText(\"B\"), ValueText(\"C\")))\n+    builder += None -> ValueVariant(None, Name.assertFromString(\"Variant\"), ValueInt64(0))\n+    builder += None -> ValueRecord(\n+      None,\n+      ImmArray(\n+        None -> ValueText(\"field1\"),\n+        None -> ValueText(\"field2\")\n+      ))\n+    builder += None -> ValueTextMap(\n+      SortedLookupList(\n+        Map(\n+          \"keyA\" -> ValueText(\"valueA\"),\n+          \"keyB\" -> ValueText(\"valueB\")\n+        )))\n+    val fields = builder.result()\n+\n+    ValueRecord(None, fields)\n+  }\n+\n+  \"hashValue\" should {\n+\n+    import ValueHasher._\n+\n+    \"be stable\" in {\n+      val tmpId = templateId(\"module\", \"name\")\n+      hashValueString(complexValue) shouldBe \"b83cca003b2f90ea4ce9986c5ad1d654d6e2b345f4665474c1567d154412942a\"\n+      hashContractString(tmpId, complexValue) shouldBe \"07e7b5534931dfca8e1b485c105bae4e10808bd13ddc8e897f258015f9d921c5\"\n+      hashContractKeyString(tmpId, complexValue) shouldBe \"59b59ad7a6b6066e77b91ced54b8282f0e24e7089944685cb8f22f32fcbc4e1b\"\n+    }\n+\n+    \"be deterministic and thread safe\" in {\n+      // Compute many hashes in parallel, check that they are all equal\n+      // Note: intentionally does not reuse value instances\n+      val hashes = Vector.fill(1000)(complexValue).par.map(hashValueString)\n+      hashes.toSet.size shouldBe 1\n+    }\n+\n+    \"not produce collision in template id\" in {\n+      // Same value but different template ID should produce a different hash\n+      val value = ValueText(\"A\")\n+\n+      val hashes = Ref.LedgerString.Array(\n+        hashContractString(templateId(\"AA\", \"A\"), value),\n+        hashContractString(templateId(\"A\", \"AA\"), value),\n+        hashContractKeyString(templateId(\"AA\", \"A\"), value),\n+        hashContractKeyString(templateId(\"A\", \"AA\"), value),\n+      )\n+\n+      for {\n+        i <- hashes.indices\n+        j <- hashes.indices\n+        if (i < j)\n+      } hashes(i) shouldNot be(hashes(j))\n+\n+    }\n+\n+    // Note: value version is given by the template ID, this check is not necessary\n+    /*\n+    \"not produce collision in value version\" in {\n+      // Same value but different value version should produce a different hash\n+      val value1 = ValueText(\"A\")\n+      val value2 = ValueText(\"A\")\n+\n+      val tid = templateId(\"module\", \"name\")\n+\n+      val hash1 = KeyHasher.hashValueString(value1, tid)\n+      val hash2 = KeyHasher.hashValueString(value2, tid)\n+\n+      hash1.equals(hash2) shouldBe false\n+    }\n+     */\n+\n+    \"not produce collision in list of text\" in {\n+      // Testing whether strings are delimited: [\"AA\", \"A\"] vs [\"A\", \"AA\"]\n+      val value1 =\n+        ValueList(FrontStack(ValueText(\"AA\"), ValueText(\"A\")))"
  }
]