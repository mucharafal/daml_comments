[
  {
    "id" : "0ce151a1-8aea-46d6-87a6-539a61139551",
    "prId" : 5991,
    "comments" : [
      {
        "id" : "6406644d-c120-44cf-8d7c-b74fcd754a55",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "You might want to change this test name (and others) in this file.",
        "createdAt" : "2020-05-15T14:43:46Z",
        "updatedAt" : "2020-05-25T08:54:03Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9d70cbbf83f8ff0e01b793b887f877d8f61f7294",
    "line" : null,
    "diffHunk" : "@@ -140,8 +116,8 @@ class ValueSpec\n   }\n \n   \"AbsoluteContractId\" - {"
  },
  {
    "id" : "0233b123-cfdb-405d-a4b4-8becf08da926",
    "prId" : 5913,
    "comments" : [
      {
        "id" : "d5c85118-0133-49be-8f07-1a4163f62f15",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    \"rejects too long suffix\" in {\r\n```",
        "createdAt" : "2020-05-08T16:20:09Z",
        "updatedAt" : "2020-05-09T10:32:09Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e43df9442f6e63fbda69ee802d912e0e1699956",
    "line" : null,
    "diffHunk" : "@@ -107,6 +106,24 @@ class ValueSpec\n \n   }\n \n+  \"AbsoluteContractID.V1.build\" - {\n+\n+    \"rejects to long suffix\" in {"
  },
  {
    "id" : "a497fd6c-5ebd-4f04-91f2-cd51caad0a19",
    "prId" : 5913,
    "comments" : [
      {
        "id" : "452de78f-7926-49d6-960c-91b10dc8d85e",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      import AbsoluteContractId.V1.build\r\n      build(hash, suffix(0)) shouldBe 'right\r\n      // ...\r\n```",
        "createdAt" : "2020-05-08T16:20:35Z",
        "updatedAt" : "2020-05-09T10:32:09Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e43df9442f6e63fbda69ee802d912e0e1699956",
    "line" : null,
    "diffHunk" : "@@ -107,6 +106,24 @@ class ValueSpec\n \n   }\n \n+  \"AbsoluteContractID.V1.build\" - {\n+\n+    \"rejects to long suffix\" in {\n+\n+      def suffix(size: Int) =\n+        Bytes.fromByteArray(Array.iterate(0.toByte, size)(b => (b + 1).toByte))\n+\n+      val hash = crypto.Hash.hashPrivateKey(\"some hash\")\n+      AbsoluteContractId.V1.build(hash, suffix(0)) shouldBe 'right"
  },
  {
    "id" : "e80b8667-b9f2-4a32-a7aa-d1e6ab65277d",
    "prId" : 5913,
    "comments" : [
      {
        "id" : "b7624e18-9749-48c4-a105-f06841bcf9dc",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Ha ha very funny, I elided the rest of them\r\n\r\n```suggestion\r\n      build(hash, suffix(94)) shouldBe 'right\r\n      build(hash, suffix(95)) shouldBe 'left\r\n      build(hash, suffix(96)) shouldBe 'left\r\n      build(hash, suffix(127)) shouldBe 'left\r\n```",
        "createdAt" : "2020-05-08T22:15:04Z",
        "updatedAt" : "2020-05-09T10:32:09Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e43df9442f6e63fbda69ee802d912e0e1699956",
    "line" : null,
    "diffHunk" : "@@ -107,6 +106,26 @@ class ValueSpec\n \n   }\n \n+  \"AbsoluteContractID.V1.build\" - {\n+\n+    \"rejects too long suffix\" in {\n+\n+      def suffix(size: Int) =\n+        Bytes.fromByteArray(Array.iterate(0.toByte, size)(b => (b + 1).toByte))\n+\n+      val hash = crypto.Hash.hashPrivateKey(\"some hash\")\n+      import AbsoluteContractId.V1.build\n+      build(hash, suffix(0)) shouldBe 'right\n+      // ...\n+      AbsoluteContractId.V1.build(hash, suffix(94)) shouldBe 'right\n+      AbsoluteContractId.V1.build(hash, suffix(95)) shouldBe 'left\n+      AbsoluteContractId.V1.build(hash, suffix(96)) shouldBe 'left\n+      AbsoluteContractId.V1.build(hash, suffix(127)) shouldBe 'left"
  },
  {
    "id" : "5e74c92d-8429-49b2-8b9d-fc3663144ce4",
    "prId" : 5526,
    "comments" : [
      {
        "id" : "86a6ee22-4e42-4f3f-99bf-2e69bca5d3c6",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "must be some prototyping... should it go?",
        "createdAt" : "2020-04-10T15:12:47Z",
        "updatedAt" : "2020-04-24T20:58:40Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "30a28c78-9758-4560-bc1d-5710acfa286b",
        "parentId" : "86a6ee22-4e42-4f3f-99bf-2e69bca5d3c6",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Hmm...probably.",
        "createdAt" : "2020-04-10T15:32:41Z",
        "updatedAt" : "2020-04-24T20:58:40Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "5e1355a2c792b820752b3f4a7fe7b384b7ef174c",
    "line" : 166,
    "diffHunk" : "@@ -95,13 +114,132 @@ class ValueSpec extends FreeSpec with Matchers with Checkers with GeneratorDrive\n     implicit val arbT: Arbitrary[T] =\n       Arbitrary(versionedValueGen.map(VersionedValue.map1(Unnatural(_))))\n \n-    scalaz.scalacheck.ScalazProperties.equal.laws[T].properties foreach {\n-      case (s, p) => s in check(p)\n-    }\n+    \"obeys Equal laws\" in checkLaws(SzP.equal.laws[T])\n \n     \"results preserve natural == results\" in forAll { (a: T, b: T) =>\n       scalaz.Equal[T].equal(a, b) shouldBe (a == b)\n     }\n   }\n \n+  // XXX can factor like FlatSpecCheckLaws\n+  private def checkLaws(props: org.scalacheck.Properties) =\n+    forEvery(Table((\"law\", \"property\"), props.properties: _*)) { (_, p) =>\n+      check(p, minSuccessful(20))\n+    }\n+\n+  private def checkOrderPreserved[Cid: Arbitrary: Shrink: Order](\n+      va: VA,\n+      scope: Value.LookupVariantEnum) = {\n+    import va.{injord, injarb, injshrink}\n+    implicit val targetOrd: Order[Value[Cid]] = Tag unsubst Value.orderInstance(scope)\n+    forAll(minSuccessful(20)) { (a: va.Inj[Cid], b: va.Inj[Cid]) =>\n+      (a ?|? b) should ===(va.inj(a) ?|? va.inj(b))\n+    }\n+  }\n+\n+  \"Order\" - {\n+    type Cid = Int\n+    type T = Value[Cid]\n+\n+    val FooScope: Value.LookupVariantEnum =\n+      Map(fooVariantId -> ImmArray(\"quux\", \"baz\"), fooEnumId -> ImmArray(\"quux\", \"baz\"))\n+        .transform((_, ns) => ns map Ref.Name.assertFromString)\n+        .lift\n+\n+    \"for primitive, matching types\" - {\n+      val EmptyScope: Value.LookupVariantEnum = _ => None\n+      implicit val ord: Order[T] = Tag unsubst Value.orderInstance(EmptyScope)\n+\n+      \"obeys order laws\" in forAll(genAddend, minSuccessful(100)) { va =>\n+        implicit val arb: Arbitrary[T] = va.injarb[Cid] map (va.inj(_))\n+        checkLaws(SzP.order.laws[T])\n+      }\n+\n+      \"preserves base order\" in forAll(genAddend, minSuccessful(100)) { va =>\n+        checkOrderPreserved[Cid](va, EmptyScope)\n+      }\n+    }\n+\n+    \"for record and variant types\" - {\n+      implicit val ord: Order[T] = Tag unsubst Value.orderInstance(FooScope)\n+      \"obeys order laws\" in forEvery(Table(\"va\", fooRecord, fooVariant)) { va =>\n+        implicit val arb: Arbitrary[T] = va.injarb[Cid] map (va.inj(_))\n+        checkLaws(SzP.order.laws[T])\n+      }\n+\n+      \"matches constructor rank\" in {\n+        val fooCp = shapeless.Coproduct[fooVariant.Inj[Cid]]\n+        val quux = fooCp('quux ->> 42L)\n+        val baz = fooCp('baz ->> 42L)\n+        (fooVariant.inj(quux) ?|? fooVariant.inj(baz)) shouldBe scalaz.Ordering.LT\n+      }\n+\n+      \"preserves base order\" in forEvery(Table(\"va\", fooRecord, fooVariant)) { va =>\n+        checkOrderPreserved[Cid](va, FooScope)\n+      }\n+    }\n+\n+    \"for enum types\" - {\n+      \"obeys order laws\" in forAll(enumDetailsAndScopeGen, minSuccessful(20)) {\n+        case (details, scope) =>\n+          implicit val ord: Order[T] = Tag unsubst Value.orderInstance(scope)\n+          forEvery(Table(\"va\", details.values.toSeq: _*)) { ea =>\n+            implicit val arb: Arbitrary[T] = ea.injarb[Cid] map (ea.inj(_))\n+            checkLaws(SzP.order.laws[T])\n+          }\n+      }\n+\n+      \"matches constructor rank\" in forAll(enumDetailsAndScopeGen, minSuccessful(20)) {\n+        case (details, scope) =>\n+          implicit val ord: Order[T] = Tag unsubst Value.orderInstance(scope)\n+          forEvery(Table(\"va\", details.values.toSeq: _*)) { ea =>\n+            implicit val arb: Arbitrary[T] = ea.injarb[Cid] map (ea.inj(_))\n+            forAll(minSuccessful(20)) { (a: T, b: T) =>\n+              inside((a, b)) {\n+                case (ValueEnum(_, ac), ValueEnum(_, bc)) =>\n+                  (a ?|? b) should ===((ea.values indexOf ac) ?|? (ea.values indexOf bc))\n+              }\n+            }\n+          }\n+      }\n+\n+      \"preserves base order\" in forAll(enumDetailsAndScopeGen, minSuccessful(20)) {\n+        case (details, scope) =>\n+          forEvery(Table(\"va\", details.values.toSeq: _*)) { ea =>\n+            checkOrderPreserved[Cid](ea, scope)\n+          }\n+      }\n+    }\n+  }\n+\n+}\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+object ValueSpec {\n+  private val fooSpec =\n+    'quux ->> VA.int64 :: 'baz ->> VA.int64 :: RNil\n+  private val (_, fooRecord) = VA.record(Identifier assertFromString \"abc:Foo:FooRec\", fooSpec)\n+  private val fooVariantId = Identifier assertFromString \"abc:Foo:FooVar\"\n+  private val (_, fooVariant) = VA.variant(fooVariantId, fooSpec)\n+  private val fooEnumId = Identifier assertFromString \"abc:Foo:FooEnum\"\n+\n+  private[this] val scopeOfEnumsGen: Gen[Map[Identifier, Seq[Name]]] =\n+    Gen.mapOf(Gen.zip(idGen, Gen.nonEmptyContainerOf[Set, Name](nameGen) map (_.toSeq)))\n+\n+  private val enumDetailsAndScopeGen\n+    : Gen[(Map[Identifier, VA.EnumAddend[Seq[Name]]], Value.LookupVariantEnum)] =\n+    scopeOfEnumsGen flatMap { details =>\n+      (\n+        details transform ((name, members) => VA.enum(name, members)._2),\n+        details.transform((_, members) => members.to[ImmArray]).lift)\n+    }\n+  /*"
  }
]