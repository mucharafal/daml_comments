[
  {
    "id" : "74316d7f-4c01-4a9c-a73c-bbbca8277e6e",
    "prId" : 5526,
    "comments" : [
      {
        "id" : "4b2ae071-969b-4a26-a486-1be1a8bf4195",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I am not very sure what implicit is infered there, but if `scalaz.std.VectorOrder` seems to take the size of the compared vectors first, and then compare lexicographically the content. It is not what we want here. Problably `scalaz.std.ListOrder` is better,",
        "createdAt" : "2020-04-14T09:52:34Z",
        "updatedAt" : "2020-04-24T20:58:40Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e1355a2c792b820752b3f4a7fe7b384b7ef174c",
    "line" : null,
    "diffHunk" : "@@ -118,12 +127,17 @@ object TypedValueGenerators {\n       import scalaz.std.vector._\n       type Inj[Cid] = Vector[elt.Inj[Cid]]\n       override val t = TypePrim(PT.List, ImmArraySeq(elt.t))\n-      override def inj[Cid] = elts => ValueList(elts.map(elt.inj).to[FrontStack])\n+      override def inj[Cid: IntroCtx](elts: Inj[Cid]) =\n+        ValueList(elts.map(elt.inj(_)).to[FrontStack])\n       override def prj[Cid] = {\n         case ValueList(v) => v.toImmArray.toSeq.to[Vector] traverse elt.prj\n         case _ => None\n       }\n-      override def injarb[Cid: Arbitrary] = {\n+      override def injord[Cid: Order] = {\n+        implicit val e: Order[elt.Inj[Cid]] = elt.injord\n+        implicitly[Order[Vector[elt.Inj[Cid]]]]"
  },
  {
    "id" : "e0295565-66a6-4d86-9964-67566cbbf568",
    "prId" : 5526,
    "comments" : [
      {
        "id" : "085f3842-239c-4489-b814-89575ec2e084",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "again here, I am not sure it is the order we want.",
        "createdAt" : "2020-04-14T09:53:10Z",
        "updatedAt" : "2020-04-24T20:58:40Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "5e1355a2c792b820752b3f4a7fe7b384b7ef174c",
    "line" : null,
    "diffHunk" : "@@ -172,18 +194,26 @@ object TypedValueGenerators {\n     } = new ValueAddend {\n       type Inj[Cid] = key.Inj[Cid] Map elt.Inj[Cid]\n       override val t = TypePrim(PT.GenMap, ImmArraySeq(key.t, elt.t))\n-      override def inj[Cid] =\n-        (m: key.Inj[Cid] Map elt.Inj[Cid]) =>\n-          ValueGenMap(\n-            m.iterator\n-              .map { case (k, v) => (key.inj(k), elt.inj(v)) }\n-              .to[ImmArray])\n+      override def inj[Cid: IntroCtx](m: key.Inj[Cid] Map elt.Inj[Cid]) =\n+        ValueGenMap {\n+          import key.{injord => keyorder}\n+          implicit val skeyord: math.Ordering[key.Inj[Cid]] = Order[key.Inj[Cid]].toScalaOrdering\n+          m.to[ImmArraySeq]\n+            .sortBy(_._1)\n+            .map { case (k, v) => (key.inj(k), elt.inj(v)) }\n+            .toImmArray\n+        }\n       override def prj[Cid] = {\n         case ValueGenMap(kvs) =>\n           kvs traverse (_ bitraverse (key.prj[Cid], elt.prj[Cid])) map (_.toSeq.toMap)\n         case _ => None\n       }\n-      override def injarb[Cid: Arbitrary] = {\n+      override def injord[Cid: Order] = {\n+        implicit val k: Order[key.Inj[Cid]] = key.injord\n+        implicit val e: Order[elt.Inj[Cid]] = elt.injord\n+        implicitly[Order[key.Inj[Cid] Map elt.Inj[Cid]]]"
  },
  {
    "id" : "206fd43e-e85c-430f-a8cd-206ae914583d",
    "prId" : 3849,
    "comments" : [
      {
        "id" : "40092fef-19ee-41ab-bf95-97c7ca1ffcd5",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I am not sure how to handle this, but properly typed `Numeric` should have the good scale.",
        "createdAt" : "2020-01-16T11:38:35Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "234101313181b0ea39c66a646366bd28d3d2adfd",
    "line" : null,
    "diffHunk" : "@@ -84,7 +84,10 @@ object TypedValueGenerators {\n \n       override def t: Type = TypeNumeric(scale)\n \n-      override def inj[Cid]: Numeric => Value[Cid] = ValueNumeric\n+      override def inj[Cid]: Numeric => Value[Cid] = { n =>\n+        require(n.scale() == scale)"
  },
  {
    "id" : "0e209467-423d-4eab-92d3-34830fe8d7f6",
    "prId" : 3849,
    "comments" : [
      {
        "id" : "770ac187-a757-49d7-8829-7090c6ad0403",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I am not sure how to handle this, but properly typed Numeric must have the good scale.",
        "createdAt" : "2020-01-16T12:25:45Z",
        "updatedAt" : "2020-01-16T15:17:18Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "234101313181b0ea39c66a646366bd28d3d2adfd",
    "line" : null,
    "diffHunk" : "@@ -84,7 +84,10 @@ object TypedValueGenerators {\n \n       override def t: Type = TypeNumeric(scale)\n \n-      override def inj[Cid]: Numeric => Value[Cid] = ValueNumeric\n+      override def inj[Cid]: Numeric => Value[Cid] = { n =>\n+        assert(n.scale() == scale)"
  },
  {
    "id" : "8de9066e-0429-464a-b157-d61147223868",
    "prId" : 2666,
    "comments" : [
      {
        "id" : "7a8f52aa-f8b4-408f-87bd-2ed640c84453",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      type Inj[Cid] = Numeric\r\n```",
        "createdAt" : "2019-08-27T19:37:13Z",
        "updatedAt" : "2019-09-02T07:14:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8d62b26852e6615fe747f0ba481e7618f14b9eb5",
    "line" : null,
    "diffHunk" : "@@ -60,13 +59,32 @@ object TypedValueGenerators {\n     import Value._, ValueGenerators.Implicits._\n     val text = noCid(PT.Text, ValueText) { case ValueText(t) => t }\n     val int64 = noCid(PT.Int64, ValueInt64) { case ValueInt64(i) => i }\n-    val numeric = noCid(PT.Decimal, ValueNumeric) { case ValueNumeric(d) => d }\n     val unit = noCid(PT.Unit, (_: Unit) => ValueUnit) { case ValueUnit => () }\n     val date = noCid(PT.Date, ValueDate) { case ValueDate(d) => d }\n     val timestamp = noCid(PT.Timestamp, ValueTimestamp) { case ValueTimestamp(t) => t }\n     val bool = noCid(PT.Bool, ValueBool) { case ValueBool(b) => b }\n     val party = noCid(PT.Party, ValueParty) { case ValueParty(p) => p }\n \n+    def numeric(scale: Int) = new ValueAddend {\n+      override type Inj[Cid] = Numeric"
  },
  {
    "id" : "9965a983-98de-4122-b4f4-12cc7d3dfcdd",
    "prId" : 2666,
    "comments" : [
      {
        "id" : "fcc1f73c-dbd6-46a4-94d0-4e03b4cecada",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n    def numeric(scale: Int): NoCid[Numeric] = new ValueAddend {\r\n```",
        "createdAt" : "2019-08-27T19:37:57Z",
        "updatedAt" : "2019-09-02T07:14:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8d62b26852e6615fe747f0ba481e7618f14b9eb5",
    "line" : null,
    "diffHunk" : "@@ -60,13 +59,32 @@ object TypedValueGenerators {\n     import Value._, ValueGenerators.Implicits._\n     val text = noCid(PT.Text, ValueText) { case ValueText(t) => t }\n     val int64 = noCid(PT.Int64, ValueInt64) { case ValueInt64(i) => i }\n-    val numeric = noCid(PT.Decimal, ValueNumeric) { case ValueNumeric(d) => d }\n     val unit = noCid(PT.Unit, (_: Unit) => ValueUnit) { case ValueUnit => () }\n     val date = noCid(PT.Date, ValueDate) { case ValueDate(d) => d }\n     val timestamp = noCid(PT.Timestamp, ValueTimestamp) { case ValueTimestamp(t) => t }\n     val bool = noCid(PT.Bool, ValueBool) { case ValueBool(b) => b }\n     val party = noCid(PT.Party, ValueParty) { case ValueParty(p) => p }\n \n+    def numeric(scale: Int) = new ValueAddend {"
  },
  {
    "id" : "a0c60387-6071-4875-aaf1-89da13f9cfa2",
    "prId" : 2666,
    "comments" : [
      {
        "id" : "24bf513d-9ada-42ac-ae7f-9c0581fd2b28",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      override def injshrink[Cid: Shrink]: Shrink[Numeric] =\r\n```",
        "createdAt" : "2019-08-27T19:38:47Z",
        "updatedAt" : "2019-09-02T07:14:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8d62b26852e6615fe747f0ba481e7618f14b9eb5",
    "line" : null,
    "diffHunk" : "@@ -60,13 +59,32 @@ object TypedValueGenerators {\n     import Value._, ValueGenerators.Implicits._\n     val text = noCid(PT.Text, ValueText) { case ValueText(t) => t }\n     val int64 = noCid(PT.Int64, ValueInt64) { case ValueInt64(i) => i }\n-    val numeric = noCid(PT.Decimal, ValueNumeric) { case ValueNumeric(d) => d }\n     val unit = noCid(PT.Unit, (_: Unit) => ValueUnit) { case ValueUnit => () }\n     val date = noCid(PT.Date, ValueDate) { case ValueDate(d) => d }\n     val timestamp = noCid(PT.Timestamp, ValueTimestamp) { case ValueTimestamp(t) => t }\n     val bool = noCid(PT.Bool, ValueBool) { case ValueBool(b) => b }\n     val party = noCid(PT.Party, ValueParty) { case ValueParty(p) => p }\n \n+    def numeric(scale: Int) = new ValueAddend {\n+      override type Inj[Cid] = Numeric\n+\n+      override def t: Type = TypeNumeric(scale)\n+\n+      override def inj[Cid]: Numeric => Value[Cid] = ValueNumeric\n+\n+      override def prj[Cid]: Value[Cid] => Option[Numeric] = {\n+        case ValueNumeric(x) if x.scale <= scale => Some(x)\n+        case _ => None\n+      }\n+\n+      override implicit def injarb[Cid: Arbitrary]: Arbitrary[Numeric] =\n+        Arbitrary(ValueGenerators.numGen(scale))\n+\n+      override implicit def injshrink[Cid: Shrink]: Shrink[Numeric] ="
  },
  {
    "id" : "e01804e9-859b-4495-8aab-146420c9772e",
    "prId" : 2666,
    "comments" : [
      {
        "id" : "a70f355e-b5e3-445c-b530-3501c8cf27c3",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      override def injarb[Cid: Arbitrary]: Arbitrary[Numeric] =\r\n```",
        "createdAt" : "2019-08-27T19:38:52Z",
        "updatedAt" : "2019-09-02T07:14:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8d62b26852e6615fe747f0ba481e7618f14b9eb5",
    "line" : null,
    "diffHunk" : "@@ -60,13 +59,32 @@ object TypedValueGenerators {\n     import Value._, ValueGenerators.Implicits._\n     val text = noCid(PT.Text, ValueText) { case ValueText(t) => t }\n     val int64 = noCid(PT.Int64, ValueInt64) { case ValueInt64(i) => i }\n-    val numeric = noCid(PT.Decimal, ValueNumeric) { case ValueNumeric(d) => d }\n     val unit = noCid(PT.Unit, (_: Unit) => ValueUnit) { case ValueUnit => () }\n     val date = noCid(PT.Date, ValueDate) { case ValueDate(d) => d }\n     val timestamp = noCid(PT.Timestamp, ValueTimestamp) { case ValueTimestamp(t) => t }\n     val bool = noCid(PT.Bool, ValueBool) { case ValueBool(b) => b }\n     val party = noCid(PT.Party, ValueParty) { case ValueParty(p) => p }\n \n+    def numeric(scale: Int) = new ValueAddend {\n+      override type Inj[Cid] = Numeric\n+\n+      override def t: Type = TypeNumeric(scale)\n+\n+      override def inj[Cid]: Numeric => Value[Cid] = ValueNumeric\n+\n+      override def prj[Cid]: Value[Cid] => Option[Numeric] = {\n+        case ValueNumeric(x) if x.scale <= scale => Some(x)\n+        case _ => None\n+      }\n+\n+      override implicit def injarb[Cid: Arbitrary]: Arbitrary[Numeric] ="
  },
  {
    "id" : "6d3c8e33-27cc-4a63-a734-0d96febba831",
    "prId" : 2666,
    "comments" : [
      {
        "id" : "09452fa1-11b1-4366-a202-c5deef58c873",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      (sz max 1, Gen.choose(0, Numeric.maxPrecision).map(ValueAddend.numeric)),\r\n```",
        "createdAt" : "2019-08-27T19:39:20Z",
        "updatedAt" : "2019-09-02T07:14:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "8d62b26852e6615fe747f0ba481e7618f14b9eb5",
    "line" : null,
    "diffHunk" : "@@ -165,6 +182,7 @@ object TypedValueGenerators {\n     Gen.frequency(\n       ((sz max 1) * ValueAddend.leafInstances.length, Gen.oneOf(ValueAddend.leafInstances)),\n       (sz max 1, Gen.const(ValueAddend.contractId)),\n+      (nestSize, Gen.choose(0, Numeric.maxPrecision).map(ValueAddend.numeric)),"
  },
  {
    "id" : "e5c7a30f-4601-4866-b01a-506035502817",
    "prId" : 2136,
    "comments" : [
      {
        "id" : "42ff7263-12a4-40e7-9523-cccb7b3c18a5",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "The name \"addend\" refers to how values of the type will be summed with other values to form a description of possible Values.",
        "createdAt" : "2019-07-16T18:02:07Z",
        "updatedAt" : "2019-07-16T19:07:50Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8b71517f-3668-4662-9ec3-440079a19782",
        "parentId" : "42ff7263-12a4-40e7-9523-cccb7b3c18a5",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "`inj` and `prj` what do they stand for? Injection and what?",
        "createdAt" : "2019-07-16T19:54:32Z",
        "updatedAt" : "2019-07-16T20:05:27Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "31515ec0-f225-4e15-9ea4-ed8964950291",
        "parentId" : "42ff7263-12a4-40e7-9523-cccb7b3c18a5",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Projection",
        "createdAt" : "2019-07-16T20:12:22Z",
        "updatedAt" : "2019-07-16T20:12:23Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "efb2080e2b5a2a0b5eb73e3493af263b896954ca",
    "line" : 30,
    "diffHunk" : "@@ -0,0 +1,171 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf\n+package value\n+\n+import scala.language.higherKinds\n+import data.{Decimal, FrontStack, Ref, SortedLookupList, Time}\n+import data.ImmArray.ImmArraySeq\n+import iface.{PrimType => PT, Type, TypePrim}\n+\n+import scalaz.Id.Id\n+import scalaz.syntax.traverse._\n+import scalaz.std.option._\n+import org.scalacheck.{Arbitrary, Gen, Shrink}\n+import Arbitrary.arbitrary\n+\n+/** [[ValueGenerators]] produce untyped values; for example, if you use the list gen,\n+  * you get a heterogeneous list.  The generation target here, on the other hand, is\n+  * ''a pair of a type and a generator of values of that type''.  For example, you might\n+  * generate the type `[Map Decimal]`, which would be accompanied by a `Gen` that produced\n+  * [[Value]]s each guaranteed to be a list of maps, whose values are all guaranteed to\n+  * be Decimals.\n+  *\n+  * As a user, you will probably be most interested in one of the generators derived\n+  * from `genAddend`; if you need a generator in this theme not already supported by\n+  * one such generator, you can probably derive a new one from `genAddend` yourself.\n+  */\n+object TypedValueGenerators {\n+  sealed abstract class ValueAddend {"
  },
  {
    "id" : "1feb9429-3340-43f7-a477-36ea4287e358",
    "prId" : 2136,
    "comments" : [
      {
        "id" : "e89cb0b2-98aa-4631-9cfb-673a2b7ab2f7",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "what about `PT.List` and `PT.Optional`",
        "createdAt" : "2019-07-16T20:03:22Z",
        "updatedAt" : "2019-07-16T20:05:27Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f36f3a3c-a4fd-4386-822d-34d043a8d246",
        "parentId" : "e89cb0b2-98aa-4631-9cfb-673a2b7ab2f7",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "and also `PT.Map`",
        "createdAt" : "2019-07-16T20:03:51Z",
        "updatedAt" : "2019-07-16T20:05:27Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b17733e7-abef-4d00-a9f6-b25cd7c4c6be",
        "parentId" : "e89cb0b2-98aa-4631-9cfb-673a2b7ab2f7",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Not possible to do with `noCid`, scroll down for support for those three, and also contractId.",
        "createdAt" : "2019-07-16T20:10:30Z",
        "updatedAt" : "2019-07-16T20:10:30Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "efb2080e2b5a2a0b5eb73e3493af263b896954ca",
    "line" : 68,
    "diffHunk" : "@@ -0,0 +1,171 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf\n+package value\n+\n+import scala.language.higherKinds\n+import data.{Decimal, FrontStack, Ref, SortedLookupList, Time}\n+import data.ImmArray.ImmArraySeq\n+import iface.{PrimType => PT, Type, TypePrim}\n+\n+import scalaz.Id.Id\n+import scalaz.syntax.traverse._\n+import scalaz.std.option._\n+import org.scalacheck.{Arbitrary, Gen, Shrink}\n+import Arbitrary.arbitrary\n+\n+/** [[ValueGenerators]] produce untyped values; for example, if you use the list gen,\n+  * you get a heterogeneous list.  The generation target here, on the other hand, is\n+  * ''a pair of a type and a generator of values of that type''.  For example, you might\n+  * generate the type `[Map Decimal]`, which would be accompanied by a `Gen` that produced\n+  * [[Value]]s each guaranteed to be a list of maps, whose values are all guaranteed to\n+  * be Decimals.\n+  *\n+  * As a user, you will probably be most interested in one of the generators derived\n+  * from `genAddend`; if you need a generator in this theme not already supported by\n+  * one such generator, you can probably derive a new one from `genAddend` yourself.\n+  */\n+object TypedValueGenerators {\n+  sealed abstract class ValueAddend {\n+    type Inj[Cid]\n+    def t: Type\n+    def inj[Cid]: Inj[Cid] => Value[Cid]\n+    def prj[Cid]: Value[Cid] => Option[Inj[Cid]]\n+    def injgen[Cid](cid: Gen[Cid]): Gen[Inj[Cid]]\n+    implicit def injshrink[Cid: Shrink]: Shrink[Inj[Cid]]\n+  }\n+\n+  @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+  object ValueAddend extends PrimInstances[Lambda[a => ValueAddend { type Inj[_] = a }]] {\n+    type Aux[Inj0[_]] = ValueAddend {\n+      type Inj[Cid] = Inj0[Cid]\n+    }\n+    type NoCid[Inj0] = ValueAddend {\n+      type Inj[_] = Inj0\n+    }\n+\n+    def noCid[Inj0](pt: PT, inj0: Inj0 => Value[Nothing])(prj0: Value[Any] PartialFunction Inj0)(\n+        implicit arb: Arbitrary[Inj0],\n+        shr: Shrink[Inj0]): NoCid[Inj0] = new ValueAddend {\n+      type Inj[Cid] = Inj0\n+      override val t = TypePrim(pt, ImmArraySeq.empty)\n+      override def inj[Cid] = inj0\n+      override def prj[Cid] = prj0.lift\n+      override def injgen[Cid](cid: Gen[Cid]) = arb.arbitrary\n+      override def injshrink[Cid: Shrink] = shr\n+    }\n+\n+    import Value._, ValueGenerators.Implicits._\n+    val text = noCid(PT.Text, ValueText) { case ValueText(t) => t }\n+    val int64 = noCid(PT.Int64, ValueInt64) { case ValueInt64(i) => i }\n+    val decimal = noCid(PT.Decimal, ValueDecimal) { case ValueDecimal(d) => d }\n+    val unit = noCid(PT.Unit, (_: Unit) => ValueUnit) { case ValueUnit => () }\n+    val date = noCid(PT.Date, ValueDate) { case ValueDate(d) => d }\n+    val timestamp = noCid(PT.Timestamp, ValueTimestamp) { case ValueTimestamp(t) => t }\n+    val bool = noCid(PT.Bool, ValueBool) { case ValueBool(b) => b }\n+    val party = noCid(PT.Party, ValueParty) { case ValueParty(p) => p }\n+"
  }
]