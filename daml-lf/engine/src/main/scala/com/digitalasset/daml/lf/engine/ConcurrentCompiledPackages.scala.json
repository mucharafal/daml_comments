[
  {
    "id" : "58dfad3a-415e-4207-81cd-13a4d440f05a",
    "prId" : 7577,
    "comments" : [
      {
        "id" : "9737be5b-1df6-4f86-a44e-a10461678c5b",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This seems fairly inefficient. You are effectively building up a linear search afaict. Any reason not to throw this stuff in a map?",
        "createdAt" : "2020-10-08T08:44:10Z",
        "updatedAt" : "2020-10-12T12:30:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "a321464d-7e2e-4904-ba8b-41653376578a",
        "parentId" : "9737be5b-1df6-4f86-a44e-a10461678c5b",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```scala\r\nval signatureLookup: PartialFunction[PackageId, PackageSignature] = {\r\n  case `pkgId` => signature\r\n}\r\n```\r\nis syntactic sugar for\r\n```scala\r\nval signatureLookup: PartialFunction[PackageId, PackageSignature] =\r\n  new PartialFunction{\r\n    override def isDefinedAt(x: PackageId): Boolean = \r\n      x match {\r\n        case x if x == pkgId => true \r\n        case _ => false \r\n      }\r\n    override def apply(v1: PackageId): PackageSignature = \r\n      v1 match {\r\n        case v1 if v1 == pkgId => signature\r\n      }\r\n}\r\n```\r\n\r\nI think this is pretty constant\r\n",
        "createdAt" : "2020-10-08T08:59:49Z",
        "updatedAt" : "2020-10-12T12:30:48Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "67be5a2b-b7a7-4aa8-a951-8a275590ff8e",
        "parentId" : "9737be5b-1df6-4f86-a44e-a10461678c5b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Itâ€™s constant for this one but if you are building up the whole function as a chain of `orElse` of this type of partial function, you end up doing a linear search instead of a lookup to see if a package id is in there.",
        "createdAt" : "2020-10-08T09:01:53Z",
        "updatedAt" : "2020-10-12T12:30:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b5e82c15-d006-4f2c-a72c-d258ecd2c4af",
        "parentId" : "9737be5b-1df6-4f86-a44e-a10461678c5b",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "In this case the lookup in  `signatureLookup orElse _signatures` is constant as `_signatures` is a Map (and not a chain of `orElse`).\r\nI prefer to not put the signature of `pkgId` into the mutable map `_signatures` before the compilation succeed. \r\n\r\n ",
        "createdAt" : "2020-10-08T09:21:19Z",
        "updatedAt" : "2020-10-12T12:30:48Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "38b51391-c3c7-4155-bef0-2bebfb8b8123",
        "parentId" : "9737be5b-1df6-4f86-a44e-a10461678c5b",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Ah I see, I missed the fact that `_signatures` was a map. I thought we incrementally build up `_signatures` as a composition of a bunch of partial functions. Makes sense :+1: ",
        "createdAt" : "2020-10-08T09:23:16Z",
        "updatedAt" : "2020-10-12T12:30:48Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d6d8aeac74d12178596915f46b0e6afbe8a23966",
    "line" : 53,
    "diffHunk" : "@@ -83,11 +84,15 @@ private[lf] final class ConcurrentCompiledPackages(compilerConfig: Compiler.Conf\n           // map using 'computeIfAbsent' which will ensure we only compile the\n           // package once. Other concurrent calls to add this package will block\n           // waiting for the first one to finish.\n-          if (!_packages.contains(pkgId)) {\n+          if (!_signatures.contains(pkgId)) {\n+            val signature = AstUtil.toSignature(pkg)\n+            val signatureLookup: PartialFunction[PackageId, PackageSignature] = {\n+              case `pkgId` => signature"
  },
  {
    "id" : "7fdec42b-3ffe-4a06-9756-626ba0eb759d",
    "prId" : 6512,
    "comments" : [
      {
        "id" : "5247ae4e-732e-4d00-8bd8-00da916d9af1",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Why do we use explicit trivial getters and setters instead of a public `var`? Scala should generate them for us.",
        "createdAt" : "2020-06-26T13:55:43Z",
        "updatedAt" : "2020-06-29T12:47:24Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d75df4e4-371a-428a-b784-a3cf7515fa2e",
        "parentId" : "5247ae4e-732e-4d00-8bd8-00da916d9af1",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "`stackTraceMode` is a method from the `CompiledPackages` trait this class implements. It's very unfortunate that Scala's syntax does not make it explicit that I'm overriding a method here. ðŸ˜¦ ",
        "createdAt" : "2020-06-29T11:01:19Z",
        "updatedAt" : "2020-06-29T12:47:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "001d4d73-64ec-4b36-8ec3-1c99e7fba0d5",
        "parentId" : "5247ae4e-732e-4d00-8bd8-00da916d9af1",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Makes sense! You can add `override` as prefix to `def` to make this clear. (And if there isn't a good reason not to, please do.)",
        "createdAt" : "2020-06-29T11:24:37Z",
        "updatedAt" : "2020-06-29T12:47:24Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "57ac7ad3-40f4-44ef-91b7-3e8a3fbac804",
        "parentId" : "5247ae4e-732e-4d00-8bd8-00da916d9af1",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Oh, it looks like you can just do:\r\n\r\n```suggestion\r\n  override var stackTraceMode = _stackTraceMode\r\n```\r\n\r\nThis will add the setter and override the getter.",
        "createdAt" : "2020-06-29T11:26:31Z",
        "updatedAt" : "2020-06-29T12:47:24Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "09a33825-c500-4f9f-9ca6-574d3b3da800",
        "parentId" : "5247ae4e-732e-4d00-8bd8-00da916d9af1",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "The latter fails to compile with\r\n```\r\nerror: variable stackTraceMode overrides nothing\r\n  override var stackTraceMode = _stackTraceMode\r\n```\r\nChanging the `def` to `override def` works though. I'll go with this.",
        "createdAt" : "2020-06-29T11:42:27Z",
        "updatedAt" : "2020-06-29T12:47:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9ec8a59682399aa5dbac069527e4e9a52cdeb4e7",
    "line" : null,
    "diffHunk" : "@@ -23,16 +23,20 @@ final class ConcurrentCompiledPackages extends MutableCompiledPackages {\n   private[this] val _packageDeps: ConcurrentHashMap[PackageId, Set[PackageId]] =\n     new ConcurrentHashMap()\n   private[this] var _profilingMode: speedy.Compiler.ProfilingMode = speedy.Compiler.NoProfile\n+  private[this] var _stackTraceMode: speedy.Compiler.StackTraceMode = speedy.Compiler.FullStackTrace\n \n   def getPackage(pId: PackageId): Option[Package] = _packages.get(pId)\n   def getDefinition(dref: speedy.SExpr.SDefinitionRef): Option[speedy.SExpr] =\n     Option(_defns.get(dref))\n \n-  def stackTraceMode = speedy.Compiler.FullStackTrace\n   def profilingMode = _profilingMode\n   def profilingMode_=(profilingMode: speedy.Compiler.ProfilingMode) = {\n     _profilingMode = profilingMode\n   }\n+  def stackTraceMode = _stackTraceMode\n+  def stackTraceMode_=(stackTraceMode: speedy.Compiler.StackTraceMode) = {\n+    _stackTraceMode = stackTraceMode\n+  }"
  },
  {
    "id" : "d1788b80-4edd-458f-842a-45e81b0e93fb",
    "prId" : 6512,
    "comments" : [
      {
        "id" : "2a14f605-e93c-48c2-aeaa-b5cb57dedc44",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This is unrelated. I've just learnt about from @SamirTalwar-DA in the change below and though it might be a good idea to _immediately_ apply my lesson here as well, given how small the PR is.",
        "createdAt" : "2020-06-29T11:47:17Z",
        "updatedAt" : "2020-06-29T12:47:24Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9ec8a59682399aa5dbac069527e4e9a52cdeb4e7",
    "line" : 12,
    "diffHunk" : "@@ -23,16 +23,20 @@ final class ConcurrentCompiledPackages extends MutableCompiledPackages {\n   private[this] val _packageDeps: ConcurrentHashMap[PackageId, Set[PackageId]] =\n     new ConcurrentHashMap()\n   private[this] var _profilingMode: speedy.Compiler.ProfilingMode = speedy.Compiler.NoProfile\n+  private[this] var _stackTraceMode: speedy.Compiler.StackTraceMode = speedy.Compiler.FullStackTrace\n \n   def getPackage(pId: PackageId): Option[Package] = _packages.get(pId)\n   def getDefinition(dref: speedy.SExpr.SDefinitionRef): Option[speedy.SExpr] =\n     Option(_defns.get(dref))\n \n-  def stackTraceMode = speedy.Compiler.FullStackTrace\n-  def profilingMode = _profilingMode\n+  override def profilingMode = _profilingMode"
  },
  {
    "id" : "bead1b64-dce3-4349-93b9-51a57484d3cc",
    "prId" : 6471,
    "comments" : [
      {
        "id" : "84da0d32-6258-450f-89a5-a1df11000130",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "You might get better type safety if you convert this to a Scala map with `.asScala`.",
        "createdAt" : "2020-06-24T07:22:24Z",
        "updatedAt" : "2020-06-24T07:51:08Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "cce0d9dc-0ea5-4be7-bd35-fa25d79280af",
        "parentId" : "84da0d32-6258-450f-89a5-a1df11000130",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Right see the PR description, happy to make the change if someone tells me this is the right thing to do and has no performance impliciations.",
        "createdAt" : "2020-06-24T07:26:31Z",
        "updatedAt" : "2020-06-24T07:51:08Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "132f001b-6505-4623-b275-959aa1c41c3a",
        "parentId" : "84da0d32-6258-450f-89a5-a1df11000130",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "It's just a thin wrapper; shouldn't have any noticeable impact. The relevant implementation is in [`JMapWrapperLike`](https://github.com/scala/scala/blob/07260fe84557f316308086f2c95532bef173266a/src/library/scala/collection/convert/Wrappers.scala#L261-L294) and [`MapLike`](https://github.com/scala/scala/blob/07260fe84557f316308086f2c95532bef173266a/src/library/scala/collection/MapLike.scala#L153). `contains(x)` calls `get(x).isDefined`, and `get` just calls the underlying Map's `get` and wraps it in an `Option`.",
        "createdAt" : "2020-06-24T07:38:29Z",
        "updatedAt" : "2020-06-24T07:51:08Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "53f11ee8-80b2-4926-882b-c33ebf976be9",
        "parentId" : "84da0d32-6258-450f-89a5-a1df11000130",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "It is probably fine to define _package as follow:\r\n``\r\n  private[this] val _packages: collection.concurrent.Map[PackageId, Package] =\r\n    new ConcurrentHashMap[PackageId, Package]().asScala\r\n``\r\n\r\nThis uses a wrapper over the java collection, which does not change actual complexity. \r\nAnyway, the bug, you discovered, shows that performance is probably not critical here. ",
        "createdAt" : "2020-06-24T07:46:41Z",
        "updatedAt" : "2020-06-24T07:51:08Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8e4dd928-d756-4844-a23e-1123f2ab8b34",
        "parentId" : "84da0d32-6258-450f-89a5-a1df11000130",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Thanks! Iâ€™ve changed it. The Scala API only appears to have a `putIfAbsent` not a `computeIfAbsent` so I had to add an explicit check.",
        "createdAt" : "2020-06-24T07:52:39Z",
        "updatedAt" : "2020-06-24T07:52:39Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "7fd38322da34579ce1dedba06f9f2fc9ef7c6cfa",
    "line" : null,
    "diffHunk" : "@@ -55,7 +55,7 @@ final class ConcurrentCompiledPackages extends MutableCompiledPackages {\n         val pkgId: PackageId = toCompile.head\n         toCompile = toCompile.tail\n \n-        if (!_packages.contains(pkgId)) {\n+        if (!_packages.containsKey(pkgId)) {"
  },
  {
    "id" : "b0b0d5e0-f7cf-466c-9a4c-1a3b7313bf4b",
    "prId" : 6471,
    "comments" : [
      {
        "id" : "34efa73d-b63a-45b4-aa27-eb44ac598dfc",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Cannot you use `putIfAbsent` ?",
        "createdAt" : "2020-06-24T08:06:11Z",
        "updatedAt" : "2020-06-24T08:06:18Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "475ba119-b22e-4045-9f68-4d2217c77997",
        "parentId" : "34efa73d-b63a-45b4-aa27-eb44ac598dfc",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Isnâ€™t `putIfAbsent` strict in the value and will therefore compute all the other stuff even if donâ€™t end up putting?",
        "createdAt" : "2020-06-24T08:07:49Z",
        "updatedAt" : "2020-06-24T08:07:49Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d01dff6d-aee3-400e-a41d-c24c63769fe6",
        "parentId" : "34efa73d-b63a-45b4-aa27-eb44ac598dfc",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Yeah, unfortunately. Java's `Map` has `computeIfAbsent`, which is lazy, but there doesn't seem to be an equivalent in Scala.",
        "createdAt" : "2020-06-24T08:37:27Z",
        "updatedAt" : "2020-06-24T08:37:28Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "3b381312-80a3-4e4b-810c-be825570010a",
        "parentId" : "34efa73d-b63a-45b4-aa27-eb44ac598dfc",
        "author" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "body" : "Oh, I see the original code used just that.",
        "createdAt" : "2020-06-24T08:55:38Z",
        "updatedAt" : "2020-06-24T08:55:38Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar-DA",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/60356447?u=f6cdfccc6ea4254bd7c212099bbac2c27a00a28c&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2cafbe01-980a-4e99-8392-d89ec600bd42",
        "parentId" : "34efa73d-b63a-45b4-aa27-eb44ac598dfc",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Could we not use `getOrElseUpdate` in this case ? ",
        "createdAt" : "2020-06-24T10:01:10Z",
        "updatedAt" : "2020-06-24T10:02:51Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "7fd38322da34579ce1dedba06f9f2fc9ef7c6cfa",
    "line" : 48,
    "diffHunk" : "@@ -83,27 +84,28 @@ final class ConcurrentCompiledPackages extends MutableCompiledPackages {\n           // map using 'computeIfAbsent' which will ensure we only compile the\n           // package once. Other concurrent calls to add this package will block\n           // waiting for the first one to finish.\n-          _packages.computeIfAbsent(\n-            pkgId, { _ =>\n-              // Compile the speedy definitions for this package.\n-              val defns =\n-                speedy\n-                  .Compiler(packages orElse state.packages, stackTraceMode, profilingMode)\n-                  .unsafeCompilePackage(pkgId)\n-              defns.foreach {\n-                case (defnId, defn) => _defns.put(defnId, defn)\n-              }\n-              // Compute the transitive dependencies of the new package. Since we are adding\n-              // packages in dependency order we can just union the dependencies of the\n-              // direct dependencies to get the complete transitive dependencies.\n-              val deps = pkg.directDeps.foldLeft(pkg.directDeps) {\n-                case (deps, dependency) =>\n-                  deps union _packageDeps.get(dependency)\n-              }\n-              _packageDeps.put(pkgId, deps)\n-              pkg\n+          if (!_packages.contains(pkgId)) {"
  },
  {
    "id" : "50945733-a797-447f-9018-e3f8fea8c94f",
    "prId" : 3726,
    "comments" : [
      {
        "id" : "54177fce-8dcc-4f28-a41f-0f6be5a5abba",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "It looks like the error for cyclical dependencies is gone. Is that intentional?",
        "createdAt" : "2019-12-04T09:46:33Z",
        "updatedAt" : "2019-12-04T12:11:21Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f8530066-51e5-4281-a5b8-404729cab5f3",
        "parentId" : "54177fce-8dcc-4f28-a41f-0f6be5a5abba",
        "author" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "body" : "Yes, the cyclic check didn't make sense anymore as we could've easily encountered the same package multiple times (A depends on (B, C), B depends on C). We don't really need to worry about this since we cannot construct cycles as package ids are content hashes.",
        "createdAt" : "2019-12-04T10:49:49Z",
        "updatedAt" : "2019-12-04T12:11:21Z",
        "lastEditedBy" : {
          "login" : "dajmaki",
          "name" : "Jussi MÃ¤ki",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/19684330?u=abb996187e6b472110abdd8dc3c27c4fc0140b92&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "172715cbea18231150b7d6276af1c3f63490bc2f",
    "line" : 48,
    "diffHunk" : "@@ -55,33 +55,49 @@ final class ConcurrentCompiledPackages extends CompiledPackages {\n             case Some(pkg_) => pkg_\n           }\n \n+          // Load dependencies of this package and transitively its dependencies.\n+          for (dependency <- pkg.directDeps) {\n+            if (!_packages.contains(dependency) && !state.seenDependencies.contains(dependency)) {"
  },
  {
    "id" : "4fd94849-e4ec-400b-af9f-767e1c08c94e",
    "prId" : 3726,
    "comments" : [
      {
        "id" : "7658ec18-490a-4698-86c2-712ae3442488",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Nice! Looks even simpler than the code before!",
        "createdAt" : "2019-12-04T12:39:14Z",
        "updatedAt" : "2019-12-04T12:39:19Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "172715cbea18231150b7d6276af1c3f63490bc2f",
    "line" : 83,
    "diffHunk" : "@@ -72,32 +72,28 @@ final class ConcurrentCompiledPackages extends MutableCompiledPackages {\n             }\n           }\n \n-          // Compile the speedy definitions for this package.\n-          val defns =\n-            try {\n-              speedy.Compiler(packages orElse state.packages).compilePackage(pkgId)\n-            } catch {\n-              // A missing package during compilation is means that the dependencies declared\n-              // in the package are wrong.\n-              case speedy.Compiler.PackageNotFound(dependency) =>\n-                return ResultError(Error(\n-                  s\"Internal error: Invalid direct dependencies, package $dependency found missing during compilation\"))\n+          // At this point all dependencies have been loaded. Update the packages\n+          // map using 'computeIfAbsent' which will ensure we only compile the\n+          // package once. Other concurrent calls to add this package will block\n+          // waiting for the first one to finish.\n+          _packages.computeIfAbsent("
  }
]