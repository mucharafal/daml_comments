[
  {
    "id" : "49f1d3f9-f718-4091-ac2c-4756fe4178e1",
    "prId" : 5434,
    "comments" : [
      {
        "id" : "06d269a3-2a79-40f7-8f6a-3c31e87f3e32",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should this also fail for `Node.LookupByKey`?",
        "createdAt" : "2020-04-08T15:36:02Z",
        "updatedAt" : "2020-04-08T19:14:17Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "34ced5d5-f349-42ed-a965-996b3089f876",
        "parentId" : "06d269a3-2a79-40f7-8f6a-3c31e87f3e32",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Good catch ! This is a bug from the original code.",
        "createdAt" : "2020-04-08T19:08:40Z",
        "updatedAt" : "2020-04-08T19:14:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "15d20c06d3a28aa8099fedae3c1eaab0786182ae",
    "line" : 101,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package engine\n+package preprocessing\n+\n+import com.daml.lf.data.ImmArray\n+import com.daml.lf.transaction.{GenTransaction, Node, Transaction}\n+import com.daml.lf.value.Value\n+\n+private[preprocessing] final class TransactionPreprocessor(\n+    compiledPackages: MutableCompiledPackages) {\n+\n+  import Preprocessor._\n+\n+  val commandPreprocessor = new CommandPreprocessor(compiledPackages)\n+\n+  // A cast of a value to a value which uses only absolute contract IDs.\n+  // In particular, the cast will succeed for all values contained in the root nodes of a Transaction produced by submit\n+  @throws[PreprocessorException]\n+  private def unsafeAsValueWithAbsoluteContractIds(\n+      v: Value[Value.ContractId]\n+  ): Value[Value.AbsoluteContractId] =\n+    v.ensureNoRelCid\n+      .fold(rcoid => fail(s\"unexpected relative contract id $rcoid\"), identity)\n+\n+  @throws[PreprocessorException]\n+  private def unsafeAsAbsoluteContractId(coid: Value.ContractId): Value.AbsoluteContractId =\n+    coid match {\n+      case rcoid: Value.RelativeContractId =>\n+        fail(s\"not an absolute contract ID: $rcoid\")\n+      case acoid: Value.AbsoluteContractId =>\n+        acoid\n+    }\n+\n+  @throws[PreprocessorException]\n+  private def unsafeAsValueWithNoContractIds(v: Value[Value.ContractId]): Value[Nothing] =\n+    v.ensureNoCid.fold(\n+      coid => fail(s\"engine: found a contract ID $coid in the given value\"),\n+      identity\n+    )\n+\n+  // Translate a GenNode into an expression re-interpretable by the interpreter\n+  @throws[PreprocessorException]\n+  def unsafeTranslateNode[Cid <: Value.ContractId](\n+      node: Node.GenNode.WithTxValue[Transaction.NodeId, Cid],\n+  ): speedy.Command = {\n+\n+    node match {\n+      case Node.NodeCreate(\n+          nodeSeed @ _,\n+          coid @ _,\n+          coinst,\n+          optLoc @ _,\n+          sigs @ _,\n+          stks @ _,\n+          key @ _) =>\n+        val identifier = coinst.template\n+        val arg = unsafeAsValueWithAbsoluteContractIds(coinst.arg.value)\n+        commandPreprocessor.unsafePreprocessCreate(identifier, arg)\n+\n+      case Node.NodeExercises(\n+          nodeSeed @ _,\n+          coid,\n+          template,\n+          choice,\n+          optLoc @ _,\n+          consuming @ _,\n+          actingParties @ _,\n+          chosenVal,\n+          stakeholders @ _,\n+          signatories @ _,\n+          controllers @ _,\n+          children @ _,\n+          exerciseResult @ _,\n+          key @ _) =>\n+        val templateId = template\n+        val arg = unsafeAsValueWithAbsoluteContractIds(chosenVal.value)\n+        commandPreprocessor.unsafePreprocessExercise(templateId, coid, choice, arg)\n+      case Node.NodeFetch(coid, templateId, _, _, _, _, _) =>\n+        val acoid = unsafeAsAbsoluteContractId(coid)\n+        commandPreprocessor.unsafePreprocessFetch(templateId, acoid)\n+\n+      case Node.NodeLookupByKey(templateId, _, key, _) =>\n+        val keyValue = unsafeAsValueWithNoContractIds(key.key.value)\n+        commandPreprocessor.unsafePreprocessLookupByKey(templateId, keyValue)\n+    }\n+  }\n+\n+  @throws[PreprocessorException]\n+  def unsafeTranslateTransactionRoots[Cid <: Value.ContractId](\n+      tx: GenTransaction.WithTxValue[Transaction.NodeId, Cid],\n+  ): ImmArray[(Transaction.NodeId, speedy.Command)] =\n+    tx.roots.map(id =>\n+      tx.nodes.get(id) match {\n+        case None =>\n+          fail(s\"invalid transaction, root refers to non-existing node $id\")\n+        case Some(node) =>\n+          node match {\n+            case Node.NodeFetch(_, _, _, _, _, _, _) =>"
  },
  {
    "id" : "625fa9d3-cfe9-40f8-b9d1-6e186947b285",
    "prId" : 5361,
    "comments" : [
      {
        "id" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "parentId" : null,
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I'm not really sure why we need this check here. The created contract ID is not really an input to the interpretation, but an output. AFAICS this method is called in `Engine.reinterpret` and `Engine.validate` to translate the nodes into commands. Accordingly, we only need to check freshness of contract IDs that actually make it into the commands and the ID of the created contract will not.\r\n\r\nIn that sense, the created contract ID should be treated the same way as an exercise result: We don't look at the contract IDs in there either.",
        "createdAt" : "2020-04-29T07:09:05Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "47cdb81b-e49c-47bf-8885-c57dc123d33a",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "For Canton, it does not really matter because Canton only uses `reinterpret` and in that case `globalCids` is always empty in this line.",
        "createdAt" : "2020-04-29T07:15:10Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "0a993f84-1360-489f-bb9d-b61b20e7333f",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "The problem is when you have to translate several nodes at the time.\r\nYou need to keep track of the contract create in node, that are used as input in subsequent  nodes. Those cids should not be considered as inputs. \r\n\r\nIn the current state (where we provide only reinterpretation of root nodes or reinterpretation of a single node), the only case where this could happen is for `CreateAndExercise` command.  ",
        "createdAt" : "2020-04-29T08:16:18Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d7da9526-8a4f-47e9-9a2f-5ea739593af2",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "by the way, I use the renaming `global` -> `input`, `local` -> `output`",
        "createdAt" : "2020-04-29T08:16:57Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e4016dec-54a0-4f1b-a3d4-188d4e2f1e04",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "`input` and `output` are already defined in the ledger model. `output` has a slightly different meaning: https://docs.daml.com/concepts/ledger-model/ledger-integrity.html#internal-consistency\r\nThe difference is that if a contract is created and archived in the same transaction, then it's not an output of the transaction.",
        "createdAt" : "2020-04-29T08:24:21Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "095675f8-5499-4849-8904-8ba12f7a1a32",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "`input` also has a different meaning. You use `input` for any referenced contract whereas `input` in the ledger model means that the contract is actually used (fetch/exercise/...) and not just mentioned in one of the values.",
        "createdAt" : "2020-04-29T08:25:29Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "83ef0e49-af60-4052-b05a-98090ebbd163",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "I actually like `global` and `local`. Why do you want to rename them?",
        "createdAt" : "2020-04-29T08:25:58Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "420c051f-344e-4b5e-92bd-e79802934d28",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Thanks. Will revert the change.",
        "createdAt" : "2020-04-29T08:26:24Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5055b45f-437e-4c3c-8cf1-38c6fae3faf1",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "Precisely, I wondered about the case when multiple nodes are translated. There is no guarantee that the contract ID in the create node is the one that will be recomputed. So if someone supplies a wrong contract ID here, then we exclude this contract ID from the freshness check in the subsequent commands. However, during interpretation, we will end up with a different discriminator here, which may actually clash with one of the global contract IDs used in the arguments of one of the commands. Unless I missed it, the current freshness checks do not catch this at the moment. However, this can only happen if we're running `validate` (because `reinterpret` takes only at a single node). Fortunately, `validate` checks that the reconstructed transaction replays the given one and will therefore detect that a different contract ID has been computed.\r\n\r\nTherefore, IMO this check is pointless here. (That's also why I wrote in my summary that this only works because of the constraints how interpretation is used.)",
        "createdAt" : "2020-04-29T08:35:47Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "57821c02-3aa0-4271-a16d-cb86180deb23",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Indeed, the check does not buy you much for the freshness check point of view ifsefl. \r\nHowever, it makes easy to enforce the invariant   `(localCids & globalCids).isEmpty` when folding a list of nodes using `unsafeTranslateNode`. I find having this invariant make the reasoning simpler, and the only cost for that of it is the early rejection of anyway bogus transaction. \r\n",
        "createdAt" : "2020-04-29T09:21:40Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "95bf04e1-60f2-4a0a-ac20-ce3c4d18f180",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "In fact, to be correct we have to ensure the contract IDs created by the transaction generated by the reinterpretation are the local contract IDs computing during the translation of multiple nodes.\r\nAs you say, this is enforces by `replay` check. ",
        "createdAt" : "2020-04-29T09:39:38Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "60ceae33-7d10-4345-a1cf-4a268d16609e",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "body" : "If the invariant helps, then leave the check in. As I wrote, it does not really matter for Canton (and I don't know about Corda). I saw that you replaced the check with `localCids`, which wouldn't enforce this invariant. (Checking for localCids also makes sense, but should equally be caught by DAMLe during re-interpretation.)\r\n\r\nA related observation: The check that the recomputed contract IDs are the same doesn't really play well with suffixing of contract IDs. Basically, one has to validate the nodes before suffixing as otherwise the reinterpreted transaction will miss the suffixes. That's not a big deal, but something to keep in mind. (In Canton we reinterpret suffixed nodes and suffix the reinterpreted transaction again before we compare them.)",
        "createdAt" : "2020-04-29T09:49:47Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "andreaslochbihler-da",
          "name" : "Andreas Lochbihler",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/36634420?u=e4612b8608d57496b2fbe1939276b8b8b04e4d67&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ddd18f38-3c3b-4a91-a074-c305705fdc5c",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Thanks for catching the typo in the check with `localCids` that should be `globalCids`.",
        "createdAt" : "2020-04-29T11:38:58Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7e178dc7-d053-443e-9264-f0ce82a7d1ad",
        "parentId" : "71828692-c0d8-4b86-b3d2-9a8612939eac",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "You are right the replay should be done while ignoring suffix for local contract ID.\r\nI should probably do that in an upcoming PR.",
        "createdAt" : "2020-04-29T11:41:20Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "33e121173bce232d87fb34d60de0cb851f4511a9",
    "line" : null,
    "diffHunk" : "@@ -44,14 +45,26 @@ private[preprocessing] final class TransactionPreprocessor(\n   // Translate a GenNode into an expression re-interpretable by the interpreter\n   @throws[PreprocessorException]\n   def unsafeTranslateNode[Cid <: Value.ContractId](\n-      node: Node.GenNode.WithTxValue[Transaction.NodeId, Cid],\n-  ): speedy.Command = {\n+      acc: (Set[Value.ContractId], Set[Value.AbsoluteContractId]),\n+      node: Node.GenNode.WithTxValue[Transaction.NodeId, Cid]\n+  ): ((Set[Value.ContractId], Set[Value.AbsoluteContractId]), speedy.Command) = {\n+\n+    val (localCids, globalCids) = acc\n \n     node match {\n       case Node.NodeCreate(coid @ _, coinst, optLoc @ _, sigs @ _, stks @ _, key @ _) =>\n         val identifier = coinst.template\n         val arg = unsafeAsValueWithAbsoluteContractIds(coinst.arg.value)\n-        commandPreprocessor.unsafePreprocessCreate(identifier, arg)\n+        coid match {\n+          case acoid: AbsoluteContractId =>\n+            if (globalCids(acoid))\n+              fail(s\"created contract $coid in is not fresh\")\n+          case _ =>\n+        }"
  },
  {
    "id" : "4a1cdd0c-1585-4774-b7a1-c6a4b7c54192",
    "prId" : 5361,
    "comments" : [
      {
        "id" : "20d2a2d0-b6bf-46e3-abcd-f40fb3a2f7b3",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "In other methods we have the tuple reversed like `(Command, Set[ContractId])`.",
        "createdAt" : "2020-04-29T09:29:07Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eade945d-49ed-4002-8ac7-77d5e29df811",
        "parentId" : "20d2a2d0-b6bf-46e3-abcd-f40fb3a2f7b3",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2020-04-29T16:43:17Z",
        "updatedAt" : "2020-04-30T07:34:20Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "33e121173bce232d87fb34d60de0cb851f4511a9",
    "line" : null,
    "diffHunk" : "@@ -44,14 +45,26 @@ private[preprocessing] final class TransactionPreprocessor(\n   // Translate a GenNode into an expression re-interpretable by the interpreter\n   @throws[PreprocessorException]\n   def unsafeTranslateNode[Cid <: Value.ContractId](\n-      node: Node.GenNode.WithTxValue[Transaction.NodeId, Cid],\n-  ): speedy.Command = {\n+      acc: (Set[Value.AbsoluteContractId], Set[Value.ContractId]),\n+      node: Node.GenNode.WithTxValue[Transaction.NodeId, Cid]\n+  ): ((Set[Value.AbsoluteContractId], Set[Value.ContractId]), speedy.Command) = {"
  }
]