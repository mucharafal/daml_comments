[
  {
    "id" : "259d098e-57a0-41e4-8804-c328e5f13e2f",
    "prId" : 7220,
    "comments" : [
      {
        "id" : "c8d9de49-04ff-4631-8cf6-1aa87cd5d3de",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I assume this is faster than what we did before? Doesn’t seem simpler.",
        "createdAt" : "2020-08-25T16:09:57Z",
        "updatedAt" : "2020-08-25T17:10:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "eba1e546-2b0e-4310-a78c-dc07945094c8",
        "parentId" : "c8d9de49-04ff-4631-8cf6-1aa87cd5d3de",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fair enough. ",
        "createdAt" : "2020-08-25T16:16:03Z",
        "updatedAt" : "2020-08-25T17:10:10Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "bd81ff2e34267fdcb710110ff30af3aa4fa0256f",
    "line" : null,
    "diffHunk" : "@@ -49,6 +50,12 @@ object TypeOrdering extends Ordering[Ast.Type] {\n         throw new IllegalArgumentException(s\"cannot compare types $typ\")\n     }\n \n+  private[this] def compareNames(xs: Iterator[FieldName], ys: Iterator[FieldName]) = {"
  },
  {
    "id" : "d56af454-506b-4ef6-a82b-dc6eae55fb2d",
    "prId" : 7204,
    "comments" : [
      {
        "id" : "7d07d468-ea3a-49ca-8808-d9035bfecbeb",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Maybe that’s just me but splitting multi-field structs into single-field structs seems quite convoluted and at least deserves a comment. This is also the only case where you actually make use of the fact that the elements of your stacks are iterators. Not quite sure how to clean it up, is there a reason why we wrote the spec to first compare individual field types before comparing the number of fields? The latter seems more intuitive and would also make the implementation simpler. I guess it’s still in 1.dev so if we want to change it now would be the time.",
        "createdAt" : "2020-08-24T07:14:51Z",
        "updatedAt" : "2020-09-08T12:21:35Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4db7ba63-f682-48bb-bb47-350c58f464e4",
        "parentId" : "7d07d468-ea3a-49ca-8808-d9035bfecbeb",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "changed.",
        "createdAt" : "2020-09-07T08:20:56Z",
        "updatedAt" : "2020-09-08T12:21:35Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c317fab399ab50a2350ce6f5c719ebdaafd9d41a",
    "line" : null,
    "diffHunk" : "@@ -38,52 +29,72 @@ object TypeOrdering extends Ordering[Ast.Type] {\n       Ast.BTScenario\n     ).zipWithIndex.toMap\n \n-  private def typeRank(typ: Ast.Type): Int =\n+  private[this] def typeRank(typ: Ast.Type): Int =\n     typ match {\n       case Ast.TBuiltin(_) => 0\n       case Ast.TTyCon(_) => 1\n       case Ast.TNat(_) => 2\n       case Ast.TStruct(_) => 3\n       case Ast.TApp(_, _) => 4\n       case Ast.TVar(_) | Ast.TForall(_, _) | Ast.TSynApp(_, _) =>\n-        throw new IllegalArgumentException(s\"cannot compare types $typ\")\n+        throw new IllegalArgumentException(s\"$typ is not Comparable\")\n     }\n \n-  @tailrec\n-  // Any two ground types (types without variable nor quantifiers) can be compared.\n-  private[this] def compareType(x: Int, stack0: FrontStack[(Ast.Type, Ast.Type)]): Int =\n-    stack0 match {\n-      case FrontStack() =>\n-        x\n-      case FrontStackCons(tuple, stack) =>\n-        if (x != 0) x\n-        else\n-          tuple match {\n-            case (Ast.TBuiltin(b1), Ast.TBuiltin(b2)) =>\n-              compareType(builtinTypeIdx(b1) compareTo builtinTypeIdx(b2), stack)\n-            case (Ast.TTyCon(con1), Ast.TTyCon(con2)) =>\n-              compareType(con1 compare con2, stack)\n-            case (Ast.TNat(n1), Ast.TNat(n2)) =>\n-              compareType(n1 compareTo n2, stack)\n-            case (Ast.TStruct(fields1), Ast.TStruct(fields2)) =>\n-              compareType(\n-                math.Ordering\n-                  .Iterable[String]\n-                  .compare(fields1.toSeq.map(_._1), fields2.toSeq.map(_._1)),\n-                zipAndPush(fields1.iterator.map(_._2), fields2.iterator.map(_._2), stack)\n-              )\n-            case (Ast.TApp(t11, t12), Ast.TApp(t21, t22)) =>\n-              compareType(0, (t11, t21) +: (t12, t22) +: stack)\n-            case (t1, t2) =>\n-              // This case only occurs when t1 and t2 have different ranks.\n-              val x = typeRank(t1) compareTo typeRank(t2)\n-              assert(x != 0)\n-              x\n-          }\n+  // Stack safe comparison for comparable types, i.e. types that do not contain\n+  // variables, quantifiers, nor synonyms.\n+  @throws[IllegalArgumentException]\n+  def compare(x: Ast.Type, y: Ast.Type): Int = {\n+\n+    var diff = 0\n+    var stackX = List(Iterator.single(x))\n+    var stackY = List(Iterator.single(y))\n+    // invariant: stackX.length == stackY.length\n+\n+    @inline\n+    def push(xs: Iterator[Ast.Type], ys: Iterator[Ast.Type]): Unit = {\n+      stackX = xs :: stackX\n+      stackY = ys :: stackY\n+    }\n+\n+    @inline\n+    def pop(): Unit = {\n+      stackX = stackX.tail\n+      stackY = stackY.tail\n+    }\n+\n+    @inline\n+    def step(tuple: (Ast.Type, Ast.Type)): Unit =\n+      tuple match {\n+        case (Ast.TBuiltin(x), Ast.TBuiltin(y)) =>\n+          diff = builtinTypeRank(x) compare builtinTypeRank(y)\n+        case (Ast.TTyCon(con1), Ast.TTyCon(con2)) =>\n+          diff = con1 compare con2\n+        case (Ast.TNat(x), Ast.TNat(y)) =>\n+          diff = x compare y\n+        case (Ast.TStruct(ImmArray((xField, xType))), Ast.TStruct(ImmArray((yField, yType)))) =>"
  },
  {
    "id" : "2f15185d-e60f-42ba-a6f4-727055aaee9b",
    "prId" : 7204,
    "comments" : [
      {
        "id" : "49bdb2ed-8278-4f28-8e87-f97f0d69701d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n    def compareNamesLexicographically(xs: Iterator[Ref.Name], ys: Iterator[Ref.Name]): Unit = {\r\n```",
        "createdAt" : "2020-09-08T11:21:17Z",
        "updatedAt" : "2020-09-08T12:21:35Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c317fab399ab50a2350ce6f5c719ebdaafd9d41a",
    "line" : null,
    "diffHunk" : "@@ -1,22 +1,71 @@\n // Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n-package com.daml.lf.language\n+package com.daml.lf\n+package language\n \n-import com.daml.lf.data.{FrontStack, FrontStackCons, ImmArray}\n+import Ast._\n+import data.Ref\n \n-import scala.annotation.tailrec\n+object TypeOrdering extends Ordering[Type] {\n \n-object TypeOrdering extends Ordering[Ast.Type] {\n+  @throws[IllegalArgumentException]\n+  def compare(x: Type, y: Type): Int = {\n \n-  private def zipAndPush[X, Y](\n-      xs: Iterator[X],\n-      ys: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    (xs zip ys).to[ImmArray] ++: stack\n+    var diff = 0\n+    var stackX = List(Iterator.single(x))\n+    var stackY = List(Iterator.single(y))\n+    // invariant: stackX.length == stackY.length\n \n-  val builtinTypeIdx =\n+    @inline\n+    def push(xs: Iterator[Type], ys: Iterator[Type]): Unit = {\n+      stackX = xs :: stackX\n+      stackY = ys :: stackY\n+    }\n+\n+    @inline\n+    def pop(): Unit = {\n+      stackX = stackX.tail\n+      stackY = stackY.tail\n+    }\n+\n+    @inline\n+    def compareNames(xs: Iterator[Ref.Name], ys: Iterator[Ref.Name]): Unit = {"
  }
]