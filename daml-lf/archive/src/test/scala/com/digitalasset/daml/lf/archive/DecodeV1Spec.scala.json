[
  {
    "id" : "6682be8b-f169-4bcb-be9a-a47e2567a821",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "94586e8e-47ff-4826-9271-02317c7662e1",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I'm afraid this is prone to breaking when we add a new DAML-LF version. Can't we have a `minInterningVersion = LV.Minor.Stable(\"7\")` instead?",
        "createdAt" : "2020-09-03T10:56:56Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "aaabbe74-f3ef-43d0-aaf5-e87bc39b940e",
        "parentId" : "94586e8e-47ff-4826-9271-02317c7662e1",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "We probably do not want to test all versions. That was in fact the assumption we made when we start to design this test. ",
        "createdAt" : "2020-09-03T12:55:21Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : 14,
    "diffHunk" : "@@ -119,6 +119,18 @@ class DecodeV1Spec\n     List(1, 4, 6, 8).map(i => LV.Minor.Stable(i.toString)): _*\n   )\n \n+  private val preInterningVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Stable(\"6\"),\n+  )\n+\n+  private val postInterningVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Stable(\"7\"),\n+    LV.Minor.Stable(\"8\"),\n+    LV.Minor.Dev,\n+  )"
  },
  {
    "id" : "ea2cc709-bbb5-47b4-a8a3-1684775c0b06",
    "prId" : 7137,
    "comments" : [
      {
        "id" : "c1469f34-5a4c-487b-9ad9-91fc0163df11",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    // FIXME: https://github.com/digital-asset/daml/issues/7139\r\n    // uncomment the following line once LF 1.9 is released\r\n    // LV.Minor.Stable(\"9\"),\r\n    LV.Minor.Dev,\r\n```",
        "createdAt" : "2020-08-14T09:26:04Z",
        "updatedAt" : "2020-08-17T07:36:15Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "83a0ad73a1bdb8d23b0f6b6f0bb846eda1c0ad5e",
    "line" : null,
    "diffHunk" : "@@ -114,6 +114,16 @@ class DecodeV1Spec\n     LV.Minor.Dev,\n   )\n \n+  private val preContractIdTextConversionVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6, 7).map(i => LV.Minor.Stable(i.toString)): _*\n+  )\n+\n+  private val postContractIdTextConversionVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Dev"
  },
  {
    "id" : "031c9724-6b4e-4917-9ad1-8d30c7288887",
    "prId" : 7137,
    "comments" : [
      {
        "id" : "72499f16-d856-4f13-a6ce-d16fb1c9fe7d",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "```suggestion\r\n    List(1, 4, 6, 8).map(i => LV.Minor.Stable(i.toString)): _*\r\n```",
        "createdAt" : "2020-08-14T09:26:16Z",
        "updatedAt" : "2020-08-17T07:36:15Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "83a0ad73a1bdb8d23b0f6b6f0bb846eda1c0ad5e",
    "line" : null,
    "diffHunk" : "@@ -114,6 +114,16 @@ class DecodeV1Spec\n     LV.Minor.Dev,\n   )\n \n+  private val preContractIdTextConversionVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6, 7).map(i => LV.Minor.Stable(i.toString)): _*"
  },
  {
    "id" : "35f3730d-bda8-4123-90a9-5beefc993a45",
    "prId" : 2649,
    "comments" : [
      {
        "id" : "ca421bc8-282d-4e50-a71e-056440f7f1eb",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    val invalidNatTypes = List(Long.MinValue, -100, -2, -1, 39, 40, 200, Long.MaxValue)\r\n```",
        "createdAt" : "2019-08-23T14:35:05Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "433ccf97-5810-4f2d-ba2b-7eaf9d0577a9",
        "parentId" : "ca421bc8-282d-4e50-a71e-056440f7f1eb",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed. Thanks.",
        "createdAt" : "2019-08-23T19:00:22Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b9f86ae2ceecae15c4e5d70035e0989229041d7",
    "line" : null,
    "diffHunk" : "@@ -1,39 +1,412 @@\n-// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n package com.digitalasset.daml.lf.archive\n \n+import java.math.BigDecimal\n+import java.nio.file.{Files, Paths}\n+\n import com.digitalasset.daml.bazeltools.BazelRunfiles._\n-import com.digitalasset.daml.lf.data.Ref\n-import com.digitalasset.daml.lf.language.{Ast, LanguageMajorVersion, LanguageVersion}\n+import com.digitalasset.daml.lf.archive.DecodeV1.BuiltinFunctionInfo\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.data.{ImmArray, Ref}\n+import com.digitalasset.daml.lf.language.Util._\n+import com.digitalasset.daml.lf.language.{Ast, LanguageVersion => LV}\n import com.digitalasset.daml_lf.DamlLf1\n-import com.digitalasset.daml_lf.DamlLf1.PackageRef\n-\n+import org.scalatest.prop.TableDrivenPropertyChecks\n import org.scalatest.{Inside, Matchers, OptionValues, WordSpec}\n \n-import java.nio.file.{Files, Paths}\n-\n import scala.collection.JavaConverters._\n \n @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n-class DecodeV1Spec extends WordSpec with Matchers with Inside with OptionValues {\n+class DecodeV1Spec\n+    extends WordSpec\n+    with Matchers\n+    with Inside\n+    with OptionValues\n+    with TableDrivenPropertyChecks {\n \n-  \"The keys of primTypeTable correspond to Protobuf DamlLf1.PrimType\" in {\n+  \"The entries of primTypeInfos correspond to Protobuf DamlLf1.PrimType\" in {\n \n     (Set(DamlLf1.PrimType.UNRECOGNIZED, DamlLf1.PrimType.DECIMAL) ++\n       DecodeV1.builtinTypeInfos.map(_.proto)) shouldBe\n       DamlLf1.PrimType.values().toSet\n \n   }\n \n-  \"The keys of builtinFunctionMap correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n+  \"The entries of builtinFunctionInfos correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n \n     (Set(DamlLf1.BuiltinFunction.UNRECOGNIZED) ++ DecodeV1.builtinFunctionInfos.map(_.proto)) shouldBe\n       DamlLf1.BuiltinFunction.values().toSet\n+  }\n+\n+  private val dummyModule = DamlLf1.Module\n+    .newBuilder()\n+    .setName(DamlLf1.DottedName.newBuilder().addSegments(\"dummyModule\")) build ()\n+\n+  private def moduleDecoder(minVersion: LV.Minor) =\n+    new DecodeV1(minVersion)\n+      .ModuleDecoder(\n+        Ref.PackageId.assertFromString(\"noPkgId\"),\n+        ImmArray.empty.toSeq,\n+        dummyModule,\n+        onlySerializableDataDefs = false)\n+\n+  private val preNumericMinVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6).map(i => LV.Minor.Stable(i.toString)): _*\n+  )\n+\n+  // FixMe: https://github.com/digital-asset/daml/issues/2289\n+  //        add stable version when numerics are released\n+  private val postNumericMinVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Dev\n+  )\n+\n+  \"decodeKind\" should {\n+\n+    \"reject nat kind if lf version < 1.dev\" in {\n+\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        an[ParseError] shouldBe thrownBy(moduleDecoder(minVersion).decodeKind(input))\n+      }\n+    }\n+\n+    \"accept nat kind if lf version >= 1.dev\" in {\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        moduleDecoder(minVersion).decodeKind(input) shouldBe Ast.KNat\n+      }\n+    }\n+  }\n+\n+  \"decodeType\" should {\n+\n+    import DamlLf1.PrimType._\n+\n+    def buildNat(i: Long) = DamlLf1.Type.newBuilder().setNat(i).build()\n+\n+    val validNatTypes = List(0, 1, 2, 5, 11, 35, 37, 38)\n+    val invlidNatTypes = List(Long.MinValue, -100, -2, -1, 39, 40, 200, Long.MaxValue)"
  },
  {
    "id" : "76c2c95d-8215-40bf-a9af-15223a28200a",
    "prId" : 2649,
    "comments" : [
      {
        "id" : "6c7bd970-46cc-4eee-87c9-0dfbfbd9c95b",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n        Table(\"proto nat type\", (validNatTypes.map(_.toLong) ++ invalidNatTypes).map(buildNat): _*)\r\n```",
        "createdAt" : "2019-08-23T14:35:17Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "feb9e3f8-88db-4d02-9e3e-cd779904ed1d",
        "parentId" : "6c7bd970-46cc-4eee-87c9-0dfbfbd9c95b",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-08-23T19:00:31Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b9f86ae2ceecae15c4e5d70035e0989229041d7",
    "line" : null,
    "diffHunk" : "@@ -1,39 +1,412 @@\n-// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n package com.digitalasset.daml.lf.archive\n \n+import java.math.BigDecimal\n+import java.nio.file.{Files, Paths}\n+\n import com.digitalasset.daml.bazeltools.BazelRunfiles._\n-import com.digitalasset.daml.lf.data.Ref\n-import com.digitalasset.daml.lf.language.{Ast, LanguageMajorVersion, LanguageVersion}\n+import com.digitalasset.daml.lf.archive.DecodeV1.BuiltinFunctionInfo\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.data.{ImmArray, Ref}\n+import com.digitalasset.daml.lf.language.Util._\n+import com.digitalasset.daml.lf.language.{Ast, LanguageVersion => LV}\n import com.digitalasset.daml_lf.DamlLf1\n-import com.digitalasset.daml_lf.DamlLf1.PackageRef\n-\n+import org.scalatest.prop.TableDrivenPropertyChecks\n import org.scalatest.{Inside, Matchers, OptionValues, WordSpec}\n \n-import java.nio.file.{Files, Paths}\n-\n import scala.collection.JavaConverters._\n \n @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n-class DecodeV1Spec extends WordSpec with Matchers with Inside with OptionValues {\n+class DecodeV1Spec\n+    extends WordSpec\n+    with Matchers\n+    with Inside\n+    with OptionValues\n+    with TableDrivenPropertyChecks {\n \n-  \"The keys of primTypeTable correspond to Protobuf DamlLf1.PrimType\" in {\n+  \"The entries of primTypeInfos correspond to Protobuf DamlLf1.PrimType\" in {\n \n     (Set(DamlLf1.PrimType.UNRECOGNIZED, DamlLf1.PrimType.DECIMAL) ++\n       DecodeV1.builtinTypeInfos.map(_.proto)) shouldBe\n       DamlLf1.PrimType.values().toSet\n \n   }\n \n-  \"The keys of builtinFunctionMap correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n+  \"The entries of builtinFunctionInfos correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n \n     (Set(DamlLf1.BuiltinFunction.UNRECOGNIZED) ++ DecodeV1.builtinFunctionInfos.map(_.proto)) shouldBe\n       DamlLf1.BuiltinFunction.values().toSet\n+  }\n+\n+  private val dummyModule = DamlLf1.Module\n+    .newBuilder()\n+    .setName(DamlLf1.DottedName.newBuilder().addSegments(\"dummyModule\")) build ()\n+\n+  private def moduleDecoder(minVersion: LV.Minor) =\n+    new DecodeV1(minVersion)\n+      .ModuleDecoder(\n+        Ref.PackageId.assertFromString(\"noPkgId\"),\n+        ImmArray.empty.toSeq,\n+        dummyModule,\n+        onlySerializableDataDefs = false)\n+\n+  private val preNumericMinVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6).map(i => LV.Minor.Stable(i.toString)): _*\n+  )\n+\n+  // FixMe: https://github.com/digital-asset/daml/issues/2289\n+  //        add stable version when numerics are released\n+  private val postNumericMinVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Dev\n+  )\n+\n+  \"decodeKind\" should {\n+\n+    \"reject nat kind if lf version < 1.dev\" in {\n+\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        an[ParseError] shouldBe thrownBy(moduleDecoder(minVersion).decodeKind(input))\n+      }\n+    }\n+\n+    \"accept nat kind if lf version >= 1.dev\" in {\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        moduleDecoder(minVersion).decodeKind(input) shouldBe Ast.KNat\n+      }\n+    }\n+  }\n+\n+  \"decodeType\" should {\n+\n+    import DamlLf1.PrimType._\n+\n+    def buildNat(i: Long) = DamlLf1.Type.newBuilder().setNat(i).build()\n+\n+    val validNatTypes = List(0, 1, 2, 5, 11, 35, 37, 38)\n+    val invlidNatTypes = List(Long.MinValue, -100, -2, -1, 39, 40, 200, Long.MaxValue)\n+\n+    \"reject nat type if lf version < 1.dev\" in {\n+\n+      val testCases =\n+        Table(\"proto nat type\", (validNatTypes.map(_.toLong) ++ invlidNatTypes).map(buildNat): _*)"
  },
  {
    "id" : "e676d5a7-ec52-41cb-b5e2-3667105d62a3",
    "prId" : 2649,
    "comments" : [
      {
        "id" : "8a263fd6-5999-4582-bd8e-5b48bd22b443",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n      val negativeTestCases = Table(\"proto nat type\", invalidNatTypes.map(buildNat): _*)\r\n```",
        "createdAt" : "2019-08-23T14:35:38Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "8654d7e6-05ef-4793-8187-2af13bf6b8a4",
        "parentId" : "8a263fd6-5999-4582-bd8e-5b48bd22b443",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-08-26T07:19:21Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b9f86ae2ceecae15c4e5d70035e0989229041d7",
    "line" : null,
    "diffHunk" : "@@ -1,39 +1,412 @@\n-// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n package com.digitalasset.daml.lf.archive\n \n+import java.math.BigDecimal\n+import java.nio.file.{Files, Paths}\n+\n import com.digitalasset.daml.bazeltools.BazelRunfiles._\n-import com.digitalasset.daml.lf.data.Ref\n-import com.digitalasset.daml.lf.language.{Ast, LanguageMajorVersion, LanguageVersion}\n+import com.digitalasset.daml.lf.archive.DecodeV1.BuiltinFunctionInfo\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.data.{ImmArray, Ref}\n+import com.digitalasset.daml.lf.language.Util._\n+import com.digitalasset.daml.lf.language.{Ast, LanguageVersion => LV}\n import com.digitalasset.daml_lf.DamlLf1\n-import com.digitalasset.daml_lf.DamlLf1.PackageRef\n-\n+import org.scalatest.prop.TableDrivenPropertyChecks\n import org.scalatest.{Inside, Matchers, OptionValues, WordSpec}\n \n-import java.nio.file.{Files, Paths}\n-\n import scala.collection.JavaConverters._\n \n @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n-class DecodeV1Spec extends WordSpec with Matchers with Inside with OptionValues {\n+class DecodeV1Spec\n+    extends WordSpec\n+    with Matchers\n+    with Inside\n+    with OptionValues\n+    with TableDrivenPropertyChecks {\n \n-  \"The keys of primTypeTable correspond to Protobuf DamlLf1.PrimType\" in {\n+  \"The entries of primTypeInfos correspond to Protobuf DamlLf1.PrimType\" in {\n \n     (Set(DamlLf1.PrimType.UNRECOGNIZED, DamlLf1.PrimType.DECIMAL) ++\n       DecodeV1.builtinTypeInfos.map(_.proto)) shouldBe\n       DamlLf1.PrimType.values().toSet\n \n   }\n \n-  \"The keys of builtinFunctionMap correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n+  \"The entries of builtinFunctionInfos correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n \n     (Set(DamlLf1.BuiltinFunction.UNRECOGNIZED) ++ DecodeV1.builtinFunctionInfos.map(_.proto)) shouldBe\n       DamlLf1.BuiltinFunction.values().toSet\n+  }\n+\n+  private val dummyModule = DamlLf1.Module\n+    .newBuilder()\n+    .setName(DamlLf1.DottedName.newBuilder().addSegments(\"dummyModule\")) build ()\n+\n+  private def moduleDecoder(minVersion: LV.Minor) =\n+    new DecodeV1(minVersion)\n+      .ModuleDecoder(\n+        Ref.PackageId.assertFromString(\"noPkgId\"),\n+        ImmArray.empty.toSeq,\n+        dummyModule,\n+        onlySerializableDataDefs = false)\n+\n+  private val preNumericMinVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6).map(i => LV.Minor.Stable(i.toString)): _*\n+  )\n+\n+  // FixMe: https://github.com/digital-asset/daml/issues/2289\n+  //        add stable version when numerics are released\n+  private val postNumericMinVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Dev\n+  )\n+\n+  \"decodeKind\" should {\n+\n+    \"reject nat kind if lf version < 1.dev\" in {\n+\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        an[ParseError] shouldBe thrownBy(moduleDecoder(minVersion).decodeKind(input))\n+      }\n+    }\n+\n+    \"accept nat kind if lf version >= 1.dev\" in {\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        moduleDecoder(minVersion).decodeKind(input) shouldBe Ast.KNat\n+      }\n+    }\n+  }\n+\n+  \"decodeType\" should {\n+\n+    import DamlLf1.PrimType._\n+\n+    def buildNat(i: Long) = DamlLf1.Type.newBuilder().setNat(i).build()\n+\n+    val validNatTypes = List(0, 1, 2, 5, 11, 35, 37, 38)\n+    val invlidNatTypes = List(Long.MinValue, -100, -2, -1, 39, 40, 200, Long.MaxValue)\n+\n+    \"reject nat type if lf version < 1.dev\" in {\n+\n+      val testCases =\n+        Table(\"proto nat type\", (validNatTypes.map(_.toLong) ++ invlidNatTypes).map(buildNat): _*)\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(testCases) { natType =>\n+          an[ParseError] shouldBe thrownBy(decoder.decodeType(natType))\n+        }\n+      }\n+    }\n+\n+    \"accept only valid nat types if lf version >= 1.dev\" in {\n+      val positiveTestCases =\n+        Table(\"proto nat type\" -> \"nat\", validNatTypes.map(v => buildNat(v.toLong) -> v): _*)\n+      val negativeTestCases = Table(\"proto nat type\", invlidNatTypes.map(buildNat): _*)"
  },
  {
    "id" : "619a2118-1fb1-4938-910d-1b679f4515ec",
    "prId" : 2649,
    "comments" : [
      {
        "id" : "b7b9bb92-827b-4cdd-a4fb-b68d8f848be6",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should this be `>=`?",
        "createdAt" : "2019-08-23T14:37:16Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "dfc1bf1f-be0f-449f-81e2-c0aa8db102a6",
        "parentId" : "b7b9bb92-827b-4cdd-a4fb-b68d8f848be6",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "yes. Thanks. ",
        "createdAt" : "2019-08-23T19:00:43Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b9f86ae2ceecae15c4e5d70035e0989229041d7",
    "line" : null,
    "diffHunk" : "@@ -1,39 +1,412 @@\n-// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n package com.digitalasset.daml.lf.archive\n \n+import java.math.BigDecimal\n+import java.nio.file.{Files, Paths}\n+\n import com.digitalasset.daml.bazeltools.BazelRunfiles._\n-import com.digitalasset.daml.lf.data.Ref\n-import com.digitalasset.daml.lf.language.{Ast, LanguageMajorVersion, LanguageVersion}\n+import com.digitalasset.daml.lf.archive.DecodeV1.BuiltinFunctionInfo\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.data.{ImmArray, Ref}\n+import com.digitalasset.daml.lf.language.Util._\n+import com.digitalasset.daml.lf.language.{Ast, LanguageVersion => LV}\n import com.digitalasset.daml_lf.DamlLf1\n-import com.digitalasset.daml_lf.DamlLf1.PackageRef\n-\n+import org.scalatest.prop.TableDrivenPropertyChecks\n import org.scalatest.{Inside, Matchers, OptionValues, WordSpec}\n \n-import java.nio.file.{Files, Paths}\n-\n import scala.collection.JavaConverters._\n \n @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n-class DecodeV1Spec extends WordSpec with Matchers with Inside with OptionValues {\n+class DecodeV1Spec\n+    extends WordSpec\n+    with Matchers\n+    with Inside\n+    with OptionValues\n+    with TableDrivenPropertyChecks {\n \n-  \"The keys of primTypeTable correspond to Protobuf DamlLf1.PrimType\" in {\n+  \"The entries of primTypeInfos correspond to Protobuf DamlLf1.PrimType\" in {\n \n     (Set(DamlLf1.PrimType.UNRECOGNIZED, DamlLf1.PrimType.DECIMAL) ++\n       DecodeV1.builtinTypeInfos.map(_.proto)) shouldBe\n       DamlLf1.PrimType.values().toSet\n \n   }\n \n-  \"The keys of builtinFunctionMap correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n+  \"The entries of builtinFunctionInfos correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n \n     (Set(DamlLf1.BuiltinFunction.UNRECOGNIZED) ++ DecodeV1.builtinFunctionInfos.map(_.proto)) shouldBe\n       DamlLf1.BuiltinFunction.values().toSet\n+  }\n+\n+  private val dummyModule = DamlLf1.Module\n+    .newBuilder()\n+    .setName(DamlLf1.DottedName.newBuilder().addSegments(\"dummyModule\")) build ()\n+\n+  private def moduleDecoder(minVersion: LV.Minor) =\n+    new DecodeV1(minVersion)\n+      .ModuleDecoder(\n+        Ref.PackageId.assertFromString(\"noPkgId\"),\n+        ImmArray.empty.toSeq,\n+        dummyModule,\n+        onlySerializableDataDefs = false)\n+\n+  private val preNumericMinVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6).map(i => LV.Minor.Stable(i.toString)): _*\n+  )\n+\n+  // FixMe: https://github.com/digital-asset/daml/issues/2289\n+  //        add stable version when numerics are released\n+  private val postNumericMinVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Dev\n+  )\n+\n+  \"decodeKind\" should {\n+\n+    \"reject nat kind if lf version < 1.dev\" in {\n+\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        an[ParseError] shouldBe thrownBy(moduleDecoder(minVersion).decodeKind(input))\n+      }\n+    }\n+\n+    \"accept nat kind if lf version >= 1.dev\" in {\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        moduleDecoder(minVersion).decodeKind(input) shouldBe Ast.KNat\n+      }\n+    }\n+  }\n+\n+  \"decodeType\" should {\n+\n+    import DamlLf1.PrimType._\n+\n+    def buildNat(i: Long) = DamlLf1.Type.newBuilder().setNat(i).build()\n+\n+    val validNatTypes = List(0, 1, 2, 5, 11, 35, 37, 38)\n+    val invlidNatTypes = List(Long.MinValue, -100, -2, -1, 39, 40, 200, Long.MaxValue)\n+\n+    \"reject nat type if lf version < 1.dev\" in {\n+\n+      val testCases =\n+        Table(\"proto nat type\", (validNatTypes.map(_.toLong) ++ invlidNatTypes).map(buildNat): _*)\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(testCases) { natType =>\n+          an[ParseError] shouldBe thrownBy(decoder.decodeType(natType))\n+        }\n+      }\n+    }\n+\n+    \"accept only valid nat types if lf version >= 1.dev\" in {\n+      val positiveTestCases =\n+        Table(\"proto nat type\" -> \"nat\", validNatTypes.map(v => buildNat(v.toLong) -> v): _*)\n+      val negativeTestCases = Table(\"proto nat type\", invlidNatTypes.map(buildNat): _*)\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(positiveTestCases) { (natType, nat) =>\n+          decoder.decodeType(natType) shouldBe Ast.TNat(nat)\n+        }\n+        forEvery(negativeTestCases) { natType =>\n+          an[ParseError] shouldBe thrownBy(decoder.decodeType(natType))\n+        }\n+      }\n+    }\n+\n+    def buildPrimType(primType: DamlLf1.PrimType, args: DamlLf1.Type*) =\n+      DamlLf1.Type\n+        .newBuilder()\n+        .setPrim(DamlLf1.Type.Prim.newBuilder().setPrim(primType).addAllArgs(args.asJava))\n+        .build()\n+\n+    val decimalTestCases = Table(\n+      \"input\" -> \"expected output\",\n+      buildPrimType(DECIMAL) ->\n+        TNumeric(Ast.TNat(10)),\n+      buildPrimType(DECIMAL, buildPrimType(TEXT)) ->\n+        Ast.TApp(TNumeric(Ast.TNat(10)), TText),\n+      buildPrimType(ARROW, buildPrimType(TEXT), buildPrimType(DECIMAL)) ->\n+        TFun(TText, TNumeric(Ast.TNat(10))),\n+    )\n+\n+    val numericTestCases = Table(\n+      \"input\" -> \"expected output\",\n+      buildPrimType(NUMERIC) ->\n+        TNumeric.cons,\n+      buildPrimType(NUMERIC, DamlLf1.Type.newBuilder().setNat(10).build()) ->\n+        TNumeric(Ast.TNat(10)),\n+      buildPrimType(NUMERIC, buildPrimType(TEXT)) ->\n+        Ast.TApp(TNumeric.cons, TText),\n+      buildPrimType(ARROW, buildPrimType(TEXT), buildPrimType(NUMERIC)) ->\n+        TFun(TText, TNumeric.cons),\n+    )\n+\n+    \"translate TDecimal to TApp(TNumeric, TNat(10)) if version =< 1.dev\" in {\n+      forEvery(preNumericMinVersions) { version =>\n+        val decoder = moduleDecoder(version)\n+        forEvery(decimalTestCases) { (input, expectedOutput) =>\n+          decoder.decodeType(input) shouldBe expectedOutput\n+        }\n+      }\n+    }\n+\n+    \"reject Numeric types if version =< 1.dev\" in {\n+      forEvery(preNumericMinVersions) { version =>\n+        val decoder = moduleDecoder(version)\n+        forEvery(numericTestCases) { (input, _) =>\n+          a[ParseError] shouldBe thrownBy(decoder.decodeType(input))\n+        }\n+      }\n+    }\n+\n+    \"translate TNumeric as is if version >= 1.dev\" in {\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(numericTestCases) { (input, expectedOutput) =>\n+          decoder.decodeType(input) shouldBe expectedOutput\n+        }\n+      }\n+    }\n+\n+    // FixMe: https://github.com/digital-asset/daml/issues/2289\n+    //  reactive the test once the decoder is not so lenient\n+    \"reject Decimal types if version =< 1.dev\" ignore {"
  },
  {
    "id" : "de62b962-06e3-45a3-9b83-3e3c3f8df6de",
    "prId" : 2649,
    "comments" : [
      {
        "id" : "959ec19c-37c2-4858-8425-d8b322ca266e",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should this be `<`?",
        "createdAt" : "2019-08-23T14:37:27Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "2a2d5872-62ba-434b-9be0-20a670464bc7",
        "parentId" : "959ec19c-37c2-4858-8425-d8b322ca266e",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed.",
        "createdAt" : "2019-08-23T19:00:53Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b9f86ae2ceecae15c4e5d70035e0989229041d7",
    "line" : null,
    "diffHunk" : "@@ -1,39 +1,412 @@\n-// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n package com.digitalasset.daml.lf.archive\n \n+import java.math.BigDecimal\n+import java.nio.file.{Files, Paths}\n+\n import com.digitalasset.daml.bazeltools.BazelRunfiles._\n-import com.digitalasset.daml.lf.data.Ref\n-import com.digitalasset.daml.lf.language.{Ast, LanguageMajorVersion, LanguageVersion}\n+import com.digitalasset.daml.lf.archive.DecodeV1.BuiltinFunctionInfo\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.data.{ImmArray, Ref}\n+import com.digitalasset.daml.lf.language.Util._\n+import com.digitalasset.daml.lf.language.{Ast, LanguageVersion => LV}\n import com.digitalasset.daml_lf.DamlLf1\n-import com.digitalasset.daml_lf.DamlLf1.PackageRef\n-\n+import org.scalatest.prop.TableDrivenPropertyChecks\n import org.scalatest.{Inside, Matchers, OptionValues, WordSpec}\n \n-import java.nio.file.{Files, Paths}\n-\n import scala.collection.JavaConverters._\n \n @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n-class DecodeV1Spec extends WordSpec with Matchers with Inside with OptionValues {\n+class DecodeV1Spec\n+    extends WordSpec\n+    with Matchers\n+    with Inside\n+    with OptionValues\n+    with TableDrivenPropertyChecks {\n \n-  \"The keys of primTypeTable correspond to Protobuf DamlLf1.PrimType\" in {\n+  \"The entries of primTypeInfos correspond to Protobuf DamlLf1.PrimType\" in {\n \n     (Set(DamlLf1.PrimType.UNRECOGNIZED, DamlLf1.PrimType.DECIMAL) ++\n       DecodeV1.builtinTypeInfos.map(_.proto)) shouldBe\n       DamlLf1.PrimType.values().toSet\n \n   }\n \n-  \"The keys of builtinFunctionMap correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n+  \"The entries of builtinFunctionInfos correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n \n     (Set(DamlLf1.BuiltinFunction.UNRECOGNIZED) ++ DecodeV1.builtinFunctionInfos.map(_.proto)) shouldBe\n       DamlLf1.BuiltinFunction.values().toSet\n+  }\n+\n+  private val dummyModule = DamlLf1.Module\n+    .newBuilder()\n+    .setName(DamlLf1.DottedName.newBuilder().addSegments(\"dummyModule\")) build ()\n+\n+  private def moduleDecoder(minVersion: LV.Minor) =\n+    new DecodeV1(minVersion)\n+      .ModuleDecoder(\n+        Ref.PackageId.assertFromString(\"noPkgId\"),\n+        ImmArray.empty.toSeq,\n+        dummyModule,\n+        onlySerializableDataDefs = false)\n+\n+  private val preNumericMinVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6).map(i => LV.Minor.Stable(i.toString)): _*\n+  )\n+\n+  // FixMe: https://github.com/digital-asset/daml/issues/2289\n+  //        add stable version when numerics are released\n+  private val postNumericMinVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Dev\n+  )\n+\n+  \"decodeKind\" should {\n+\n+    \"reject nat kind if lf version < 1.dev\" in {\n+\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        an[ParseError] shouldBe thrownBy(moduleDecoder(minVersion).decodeKind(input))\n+      }\n+    }\n+\n+    \"accept nat kind if lf version >= 1.dev\" in {\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        moduleDecoder(minVersion).decodeKind(input) shouldBe Ast.KNat\n+      }\n+    }\n+  }\n+\n+  \"decodeType\" should {\n+\n+    import DamlLf1.PrimType._\n+\n+    def buildNat(i: Long) = DamlLf1.Type.newBuilder().setNat(i).build()\n+\n+    val validNatTypes = List(0, 1, 2, 5, 11, 35, 37, 38)\n+    val invlidNatTypes = List(Long.MinValue, -100, -2, -1, 39, 40, 200, Long.MaxValue)\n+\n+    \"reject nat type if lf version < 1.dev\" in {\n+\n+      val testCases =\n+        Table(\"proto nat type\", (validNatTypes.map(_.toLong) ++ invlidNatTypes).map(buildNat): _*)\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(testCases) { natType =>\n+          an[ParseError] shouldBe thrownBy(decoder.decodeType(natType))\n+        }\n+      }\n+    }\n+\n+    \"accept only valid nat types if lf version >= 1.dev\" in {\n+      val positiveTestCases =\n+        Table(\"proto nat type\" -> \"nat\", validNatTypes.map(v => buildNat(v.toLong) -> v): _*)\n+      val negativeTestCases = Table(\"proto nat type\", invlidNatTypes.map(buildNat): _*)\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(positiveTestCases) { (natType, nat) =>\n+          decoder.decodeType(natType) shouldBe Ast.TNat(nat)\n+        }\n+        forEvery(negativeTestCases) { natType =>\n+          an[ParseError] shouldBe thrownBy(decoder.decodeType(natType))\n+        }\n+      }\n+    }\n+\n+    def buildPrimType(primType: DamlLf1.PrimType, args: DamlLf1.Type*) =\n+      DamlLf1.Type\n+        .newBuilder()\n+        .setPrim(DamlLf1.Type.Prim.newBuilder().setPrim(primType).addAllArgs(args.asJava))\n+        .build()\n+\n+    val decimalTestCases = Table(\n+      \"input\" -> \"expected output\",\n+      buildPrimType(DECIMAL) ->\n+        TNumeric(Ast.TNat(10)),\n+      buildPrimType(DECIMAL, buildPrimType(TEXT)) ->\n+        Ast.TApp(TNumeric(Ast.TNat(10)), TText),\n+      buildPrimType(ARROW, buildPrimType(TEXT), buildPrimType(DECIMAL)) ->\n+        TFun(TText, TNumeric(Ast.TNat(10))),\n+    )\n+\n+    val numericTestCases = Table(\n+      \"input\" -> \"expected output\",\n+      buildPrimType(NUMERIC) ->\n+        TNumeric.cons,\n+      buildPrimType(NUMERIC, DamlLf1.Type.newBuilder().setNat(10).build()) ->\n+        TNumeric(Ast.TNat(10)),\n+      buildPrimType(NUMERIC, buildPrimType(TEXT)) ->\n+        Ast.TApp(TNumeric.cons, TText),\n+      buildPrimType(ARROW, buildPrimType(TEXT), buildPrimType(NUMERIC)) ->\n+        TFun(TText, TNumeric.cons),\n+    )\n+\n+    \"translate TDecimal to TApp(TNumeric, TNat(10)) if version =< 1.dev\" in {\n+      forEvery(preNumericMinVersions) { version =>\n+        val decoder = moduleDecoder(version)\n+        forEvery(decimalTestCases) { (input, expectedOutput) =>\n+          decoder.decodeType(input) shouldBe expectedOutput\n+        }\n+      }\n+    }\n+\n+    \"reject Numeric types if version =< 1.dev\" in {"
  },
  {
    "id" : "ab37c6a3-2408-4b03-bd9d-1ad0ab8f0381",
    "prId" : 2649,
    "comments" : [
      {
        "id" : "4d7b6e3a-8772-448e-8130-869b61b9038c",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Should this be `<`?",
        "createdAt" : "2019-08-23T14:37:37Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "7437b6bb-e3f9-4eca-93a7-b66911998679",
        "parentId" : "4d7b6e3a-8772-448e-8130-869b61b9038c",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-08-23T19:01:05Z",
        "updatedAt" : "2019-08-26T11:34:54Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4b9f86ae2ceecae15c4e5d70035e0989229041d7",
    "line" : null,
    "diffHunk" : "@@ -1,39 +1,412 @@\n-// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n package com.digitalasset.daml.lf.archive\n \n+import java.math.BigDecimal\n+import java.nio.file.{Files, Paths}\n+\n import com.digitalasset.daml.bazeltools.BazelRunfiles._\n-import com.digitalasset.daml.lf.data.Ref\n-import com.digitalasset.daml.lf.language.{Ast, LanguageMajorVersion, LanguageVersion}\n+import com.digitalasset.daml.lf.archive.DecodeV1.BuiltinFunctionInfo\n+import com.digitalasset.daml.lf.archive.Reader.ParseError\n+import com.digitalasset.daml.lf.data.{ImmArray, Ref}\n+import com.digitalasset.daml.lf.language.Util._\n+import com.digitalasset.daml.lf.language.{Ast, LanguageVersion => LV}\n import com.digitalasset.daml_lf.DamlLf1\n-import com.digitalasset.daml_lf.DamlLf1.PackageRef\n-\n+import org.scalatest.prop.TableDrivenPropertyChecks\n import org.scalatest.{Inside, Matchers, OptionValues, WordSpec}\n \n-import java.nio.file.{Files, Paths}\n-\n import scala.collection.JavaConverters._\n \n @SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n-class DecodeV1Spec extends WordSpec with Matchers with Inside with OptionValues {\n+class DecodeV1Spec\n+    extends WordSpec\n+    with Matchers\n+    with Inside\n+    with OptionValues\n+    with TableDrivenPropertyChecks {\n \n-  \"The keys of primTypeTable correspond to Protobuf DamlLf1.PrimType\" in {\n+  \"The entries of primTypeInfos correspond to Protobuf DamlLf1.PrimType\" in {\n \n     (Set(DamlLf1.PrimType.UNRECOGNIZED, DamlLf1.PrimType.DECIMAL) ++\n       DecodeV1.builtinTypeInfos.map(_.proto)) shouldBe\n       DamlLf1.PrimType.values().toSet\n \n   }\n \n-  \"The keys of builtinFunctionMap correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n+  \"The entries of builtinFunctionInfos correspond to Protobuf DamlLf1.BuiltinFunction\" in {\n \n     (Set(DamlLf1.BuiltinFunction.UNRECOGNIZED) ++ DecodeV1.builtinFunctionInfos.map(_.proto)) shouldBe\n       DamlLf1.BuiltinFunction.values().toSet\n+  }\n+\n+  private val dummyModule = DamlLf1.Module\n+    .newBuilder()\n+    .setName(DamlLf1.DottedName.newBuilder().addSegments(\"dummyModule\")) build ()\n+\n+  private def moduleDecoder(minVersion: LV.Minor) =\n+    new DecodeV1(minVersion)\n+      .ModuleDecoder(\n+        Ref.PackageId.assertFromString(\"noPkgId\"),\n+        ImmArray.empty.toSeq,\n+        dummyModule,\n+        onlySerializableDataDefs = false)\n+\n+  private val preNumericMinVersions = Table(\n+    \"minVersion\",\n+    List(1, 4, 6).map(i => LV.Minor.Stable(i.toString)): _*\n+  )\n+\n+  // FixMe: https://github.com/digital-asset/daml/issues/2289\n+  //        add stable version when numerics are released\n+  private val postNumericMinVersions = Table(\n+    \"minVersion\",\n+    LV.Minor.Dev\n+  )\n+\n+  \"decodeKind\" should {\n+\n+    \"reject nat kind if lf version < 1.dev\" in {\n+\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        an[ParseError] shouldBe thrownBy(moduleDecoder(minVersion).decodeKind(input))\n+      }\n+    }\n+\n+    \"accept nat kind if lf version >= 1.dev\" in {\n+      val input = DamlLf1.Kind.newBuilder().setNat(DamlLf1.Unit.newBuilder()).build()\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        moduleDecoder(minVersion).decodeKind(input) shouldBe Ast.KNat\n+      }\n+    }\n+  }\n+\n+  \"decodeType\" should {\n+\n+    import DamlLf1.PrimType._\n+\n+    def buildNat(i: Long) = DamlLf1.Type.newBuilder().setNat(i).build()\n+\n+    val validNatTypes = List(0, 1, 2, 5, 11, 35, 37, 38)\n+    val invlidNatTypes = List(Long.MinValue, -100, -2, -1, 39, 40, 200, Long.MaxValue)\n+\n+    \"reject nat type if lf version < 1.dev\" in {\n+\n+      val testCases =\n+        Table(\"proto nat type\", (validNatTypes.map(_.toLong) ++ invlidNatTypes).map(buildNat): _*)\n+\n+      forEvery(preNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(testCases) { natType =>\n+          an[ParseError] shouldBe thrownBy(decoder.decodeType(natType))\n+        }\n+      }\n+    }\n+\n+    \"accept only valid nat types if lf version >= 1.dev\" in {\n+      val positiveTestCases =\n+        Table(\"proto nat type\" -> \"nat\", validNatTypes.map(v => buildNat(v.toLong) -> v): _*)\n+      val negativeTestCases = Table(\"proto nat type\", invlidNatTypes.map(buildNat): _*)\n+\n+      forEvery(postNumericMinVersions) { minVersion =>\n+        val decoder = moduleDecoder(minVersion)\n+        forEvery(positiveTestCases) { (natType, nat) =>\n+          decoder.decodeType(natType) shouldBe Ast.TNat(nat)\n+        }\n+        forEvery(negativeTestCases) { natType =>\n+          an[ParseError] shouldBe thrownBy(decoder.decodeType(natType))\n+        }\n+      }\n+    }\n+\n+    def buildPrimType(primType: DamlLf1.PrimType, args: DamlLf1.Type*) =\n+      DamlLf1.Type\n+        .newBuilder()\n+        .setPrim(DamlLf1.Type.Prim.newBuilder().setPrim(primType).addAllArgs(args.asJava))\n+        .build()\n+\n+    val decimalTestCases = Table(\n+      \"input\" -> \"expected output\",\n+      buildPrimType(DECIMAL) ->\n+        TNumeric(Ast.TNat(10)),\n+      buildPrimType(DECIMAL, buildPrimType(TEXT)) ->\n+        Ast.TApp(TNumeric(Ast.TNat(10)), TText),\n+      buildPrimType(ARROW, buildPrimType(TEXT), buildPrimType(DECIMAL)) ->\n+        TFun(TText, TNumeric(Ast.TNat(10))),\n+    )\n+\n+    val numericTestCases = Table(\n+      \"input\" -> \"expected output\",\n+      buildPrimType(NUMERIC) ->\n+        TNumeric.cons,\n+      buildPrimType(NUMERIC, DamlLf1.Type.newBuilder().setNat(10).build()) ->\n+        TNumeric(Ast.TNat(10)),\n+      buildPrimType(NUMERIC, buildPrimType(TEXT)) ->\n+        Ast.TApp(TNumeric.cons, TText),\n+      buildPrimType(ARROW, buildPrimType(TEXT), buildPrimType(NUMERIC)) ->\n+        TFun(TText, TNumeric.cons),\n+    )\n+\n+    \"translate TDecimal to TApp(TNumeric, TNat(10)) if version =< 1.dev\" in {"
  }
]