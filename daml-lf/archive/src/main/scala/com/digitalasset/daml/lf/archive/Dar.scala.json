[
  {
    "id" : "64cd920a-6d5a-4d1e-92ab-09c19cb1029f",
    "prId" : 366,
    "comments" : [
      {
        "id" : "9e2c656a-3ef8-4588-bcc2-c2bdca62e7fc",
        "parentId" : null,
        "author" : {
          "login" : "stephencompall-DA",
          "name" : "Actually @S11001001 (Stephen Compall)",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/32464278?u=2f0eaeb2500ecacccd6c1af95b27424d5193ad65&v=4"
        },
        "body" : "Move `override def map` into this block and delete `darFunctor`, which overlaps.\r\n\r\nThis is also why it is better not to explicitly refer to the names of `def`s and `val`s holding instances anywhere in Scala; the contract of `Dar` is \"provides a Functor instance\", not \"provides a Functor instance named `darFunctor`\". This permits sensible, even _required_ reorganizations for coherence like the one I suggest in the previous paragraph. Otherwise you must jump through absurd hoops as in scalaz/scalaz#582.",
        "createdAt" : "2019-04-15T04:54:49Z",
        "updatedAt" : "2019-04-15T19:25:09Z",
        "lastEditedBy" : {
          "login" : "stephencompall-DA",
          "name" : "Actually @S11001001 (Stephen Compall)",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/32464278?u=2f0eaeb2500ecacccd6c1af95b27424d5193ad65&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "984b6b19-f067-41b7-ad99-edc764137d9a",
        "parentId" : "9e2c656a-3ef8-4588-bcc2-c2bdca62e7fc",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "yeah, I thought about actually removing the functor completely... `map` can be derived from `traverse`.\r\n\r\nI actually like passing the typeclasses explicitly. More than 1 typeclass instance is possible, right? If we used newtypes for every instance... like you suggested a while ago... I would not mind giving it some obscure name",
        "createdAt" : "2019-04-15T14:04:41Z",
        "updatedAt" : "2019-04-15T19:25:09Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f33e6acf24d0adf2018e2aa0c52a01834a47a100",
    "line" : null,
    "diffHunk" : "@@ -14,4 +16,14 @@ object Dar {\n     override def map[A, B](fa: Dar[A])(f: A => B): Dar[B] =\n       Dar[B](main = f(fa.main), dependencies = fa.dependencies.map(f))\n   }\n+\n+  implicit val darTraverse: Traverse[Dar] = new Traverse[Dar] {"
  },
  {
    "id" : "eafb0aa2-8247-400f-aff1-41e0d8438d85",
    "prId" : 366,
    "comments" : [
      {
        "id" : "7f48614b-e90e-420a-b847-f3d00b4223a8",
        "parentId" : null,
        "author" : {
          "login" : "stephencompall-DA",
          "name" : "Actually @S11001001 (Stephen Compall)",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/32464278?u=2f0eaeb2500ecacccd6c1af95b27424d5193ad65&v=4"
        },
        "body" : "I think the rather extreme similarity to `map` wins out the inlined variant over splitting every step into `val`s. Implicitly resolving typeclass instances doesn't have the same coherence problems as e.g. `ExecutionContext`, as done properly, there can only be one.\r\n\r\n```suggestion\r\n      // needs import scalaz.syntax.apply._, scalaz.syntax.traverse._, scalaz.std.list._\r\n      ^(f(fa.main), fa.dependencies.traverse(f))((b, bs) => Dar(b, bs))\r\n```",
        "createdAt" : "2019-04-15T04:59:00Z",
        "updatedAt" : "2019-04-15T19:25:09Z",
        "lastEditedBy" : {
          "login" : "stephencompall-DA",
          "name" : "Actually @S11001001 (Stephen Compall)",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/32464278?u=2f0eaeb2500ecacccd6c1af95b27424d5193ad65&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3b6d3d7e-aa67-42b5-a67f-8271544fc780",
        "parentId" : "7f48614b-e90e-420a-b847-f3d00b4223a8",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "yeah, I like this. But I would still use `G.apply2` more readable :)",
        "createdAt" : "2019-04-15T14:06:12Z",
        "updatedAt" : "2019-04-15T19:25:09Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f33e6acf24d0adf2018e2aa0c52a01834a47a100",
    "line" : null,
    "diffHunk" : "@@ -14,4 +16,14 @@ object Dar {\n     override def map[A, B](fa: Dar[A])(f: A => B): Dar[B] =\n       Dar[B](main = f(fa.main), dependencies = fa.dependencies.map(f))\n   }\n+\n+  implicit val darTraverse: Traverse[Dar] = new Traverse[Dar] {\n+    override def traverseImpl[G[_]: Applicative, A, B](fa: Dar[A])(f: A => G[B]): G[Dar[B]] = {\n+      val G: Applicative[G] = implicitly\n+      val gb: G[B] = f(fa.main)\n+      val L: Traverse[List] = scalaz.std.list.listInstance\n+      val gbs: G[List[B]] = L.traverse(fa.dependencies)(f)\n+      G.apply2(gb, gbs)((b, bs) => Dar(b, bs))"
  },
  {
    "id" : "2ccd6081-ff1d-4d17-a8e2-9fe1e972f363",
    "prId" : 305,
    "comments" : [
      {
        "id" : "de230b8f-e78b-4f68-b2a5-d8e7117ae11e",
        "parentId" : null,
        "author" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "body" : "this instance is not very good, i think. the main on the right magically becomes a non-main. the functor one is good.",
        "createdAt" : "2019-04-08T21:17:33Z",
        "updatedAt" : "2019-04-09T15:44:09Z",
        "lastEditedBy" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6677fad6-d540-45de-84e8-369988995478",
        "parentId" : "de230b8f-e78b-4f68-b2a5-d8e7117ae11e",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "yep, that by design and it is documented in the test. This should be enough for the `scala/codegen` and I believe `java/codegen` both as of now don't need main.\r\n\r\nThinking about it a bit more... I can change the `Dar` so main semantic does not get lost after the append. Dar will become a variant, something like:\r\n```\r\nsealed trait Dar\r\ncase class Empty extends Dar\r\ncase class DarNode[A](main: A, dependencies: List[A]) extends Dar\r\ncase class DarList(list: NonEmptyList[DarNode])\r\n```\r\nwith `Empty` it can also become a `Monoid`, right?",
        "createdAt" : "2019-04-08T23:16:21Z",
        "updatedAt" : "2019-04-09T15:44:09Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "b746f427-5f78-4eb0-ad5f-8775e50cded5",
        "parentId" : "de230b8f-e78b-4f68-b2a5-d8e7117ae11e",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "but you know, I don't actually need to append `Dar`s. I have a map, I can `map` one `Dar` at a time and generate scala code in a loop. `traverse`/`mapA` maybe useful though.",
        "createdAt" : "2019-04-09T00:47:31Z",
        "updatedAt" : "2019-04-09T15:44:09Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "83eed5a9-7638-401f-9a37-45ec5f3ce966",
        "parentId" : "de230b8f-e78b-4f68-b2a5-d8e7117ae11e",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "so, `Semigroup` is going away.",
        "createdAt" : "2019-04-09T01:13:10Z",
        "updatedAt" : "2019-04-09T15:44:09Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "40f37a5a-6693-4a90-84e8-f9ab067b90d3",
        "parentId" : "de230b8f-e78b-4f68-b2a5-d8e7117ae11e",
        "author" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "body" : "great, can you change the pr to remove it?",
        "createdAt" : "2019-04-09T09:24:07Z",
        "updatedAt" : "2019-04-09T15:44:09Z",
        "lastEditedBy" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a5a83986aa89165d02fa13ec5a8d73cbff3eef92",
    "line" : null,
    "diffHunk" : "@@ -3,6 +3,20 @@\n \n package com.digitalasset.daml.lf\n \n+import scalaz.{Functor, Semigroup}\n+\n case class Dar[A](main: A, dependencies: List[A]) {\n-  def all: List[A] = main :: dependencies\n+  lazy val all: List[A] = main :: dependencies\n+}\n+\n+object Dar {\n+  implicit def darSemigroup[A]: Semigroup[Dar[A]] = new Semigroup[Dar[A]] {"
  }
]