[
  {
    "id" : "ecbb1766-71e6-4243-a706-0b41e3057009",
    "prId" : 4703,
    "comments" : [
      {
        "id" : "43b75795-f36f-4aa1-ad3c-33c34d101dd0",
        "parentId" : null,
        "author" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "body" : "If you simply injected this as a constructor parameter you could simplify your testing efforts immensely (i.e., you would not need to generate a real zip bomb using a Python script plus you could run the test case on all platforms as a simple unit test).",
        "createdAt" : "2020-02-27T10:13:06Z",
        "updatedAt" : "2020-02-27T10:13:06Z",
        "lastEditedBy" : {
          "login" : "miklos-da",
          "name" : "Miklos",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/57664299?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "adbff02d-2dbd-4d9d-bff0-6bbb82e477ea",
        "parentId" : "43b75795-f36f-4aa1-ad3c-33c34d101dd0",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "Good point, thanks.",
        "createdAt" : "2020-02-27T11:13:55Z",
        "updatedAt" : "2020-02-27T11:13:55Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "becea4ce17ce58b1a6d18fa35fdf012e80c54a20",
    "line" : 79,
    "diffHunk" : "@@ -98,6 +109,7 @@ object Errors {\n object DarReader {\n \n   private val ManifestName = \"META-INF/MANIFEST.MF\"\n+  private val EntrySizeThreshold = 1024 * 1024 * 1024 // 1 GB"
  },
  {
    "id" : "9ddb6a01-568b-4a92-8300-055463fa8ab6",
    "prId" : 2005,
    "comments" : [
      {
        "id" : "ecd236dd-058e-462f-9639-613d74fa07ac",
        "parentId" : null,
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "I'd like to remove the `name` from here as it's only used for texts of errors. I think this module should not be aware of any dar files and if we need to log/return an error containing the dar file name, it should be done in the layer where the file is converted to an `InputStream`. What do you think?",
        "createdAt" : "2019-07-04T14:01:21Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b6fa91ef-f001-4041-b6d1-c3e917606350",
        "parentId" : "ecd236dd-058e-462f-9639-613d74fa07ac",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "We agreed with @gerolf-da to leave this for now as it is.",
        "createdAt" : "2019-07-08T08:49:52Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "94c29de8-ec22-432e-8cc9-bffa44bd4a66",
        "parentId" : "ecd236dd-058e-462f-9639-613d74fa07ac",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "There are a lot of use cases for loading a DAR from a disk. I would leave the original `readArchive(darFile: ZipFile): Try[Dar[A]] ` and implement it in terms of `readArchive(name: String, darStream: ZipInputStream): Try[Dar[A]]`:\r\n1. open `ZipInputStream`\r\n2. pass it to `readArchive(name: String, darStream: ZipInputStream): Try[Dar[A]]`\r\n3. close the `ZipInputStream` using `bracket`",
        "createdAt" : "2019-07-08T14:25:22Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ad17e497cfec277fb5878ad7865ec99b598053c",
    "line" : 36,
    "diffHunk" : "@@ -21,98 +22,121 @@ class DarReader[A](\n     // The `Long` is the dalf size in bytes.\n     parseDalf: (Long, InputStream) => Try[A]) {\n \n-  import Errors._\n+  import DarReader._\n \n-  private val manifestEntry = new ZipEntry(\"META-INF/MANIFEST.MF\")\n-\n-  def readArchive(darFile: ZipFile): Try[Dar[A]] =\n+  def readArchive(name: String, darStream: ZipInputStream): Try[Dar[A]] = {"
  },
  {
    "id" : "97520426-d6f4-4676-936e-e5be2adefbf7",
    "prId" : 2005,
    "comments" : [
      {
        "id" : "e20e52a6-3c85-43f4-ac95-7d58f99350ed",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "We would not close the zip entry if `IOUtils.toByteArray(darStream)` throws an exception.\r\nWe should either use `bracket` or call `darStream.closeEntry()` outside of this `Try`. Keep in mind `closeEntry` can also throw.",
        "createdAt" : "2019-07-08T14:45:23Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3ad17e497cfec277fb5878ad7865ec99b598053c",
    "line" : null,
    "diffHunk" : "@@ -21,101 +23,124 @@ class DarReader[A](\n     // The `Long` is the dalf size in bytes.\n     parseDalf: (Long, InputStream) => Try[A]) {\n \n-  import Errors._\n+  import DarReader._\n \n-  private val manifestEntry = new ZipEntry(\"META-INF/MANIFEST.MF\")\n-\n-  def readArchive(darFile: ZipFile): Try[Dar[A]] =\n+  def readArchive(name: String, darStream: ZipInputStream): Try[Dar[A]] = {\n     for {\n-      names <- readDalfNames(darFile): Try[Dar[String]]\n-      main <- parseOne(darFile)(names.main): Try[A]\n-      deps <- parseAll(darFile)(names.dependencies): Try[List[A]]\n+      entries <- loadZipEntries(name, darStream)\n+      names <- entries.readDalfNames(readDalfNamesFromManifest): Try[Dar[String]]\n+      main <- parseOne(entries.getInputStreamFor)(names.main): Try[A]\n+      deps <- parseAll(entries.getInputStreamFor)(names.dependencies): Try[List[A]]\n     } yield Dar(main, deps)\n-\n-  private def readDalfNames(darFile: ZipFile): Try[Dar[String]] =\n-    parseDalfNamesFromManifest(darFile).recoverWith {\n-      case NonFatal(e1) =>\n-        findLegacyDalfNames(darFile).recoverWith {\n-          case NonFatal(_) => Failure(InvalidDar(darFile, e1))\n-        }\n-    }\n-\n-  private def parseDalfNamesFromManifest(darFile: ZipFile): Try[Dar[String]] =\n-    bracket(inputStream(darFile, manifestEntry))(close)\n-      .flatMap(is => readDalfNamesFromManifest(is))\n-\n-  private def inputStream(darFile: ZipFile, entry: ZipEntry): Try[InputStream] = {\n-    // returns null if entry does not exist\n-    Try(Option(darFile.getInputStream(entry))).flatMap {\n-      case Some(x) => Success(x)\n-      case None => Failure(InvalidZipEntry(darFile, entry))\n-    }\n   }\n \n-  // There are three cases:\n-  // 1. if it's only one .dalf, then that's the main one\n-  // 2. if it's two .dalfs, where one of them has -prim in the name, the one without -prim is the main dalf.\n-  // 3. parse error in all other cases\n-  private def findLegacyDalfNames(darFile: ZipFile): Try[Dar[String]] = {\n-    val entries: List[ZipEntry] = darEntries(darFile)\n-    val dalfs: List[String] = entries.filter(isDalf).map(_.getName)\n-    dalfs.partition(isPrimDalf) match {\n-      case (List(prim), List(main)) => Success(Dar(main, List(prim)))\n-      case (List(prim), List()) => Success(Dar(prim, List.empty))\n-      case (List(), List(main)) => Success(Dar(main, List.empty))\n-      case _ => Failure(InvalidLegacyDar(darFile))\n-    }\n+  private def loadZipEntries(name: String, darStream: ZipInputStream): Try[ZipEntries] = {\n+    @tailrec\n+    def go(accT: Try[Map[String, (Long, InputStream)]]): Try[Map[String, (Long, InputStream)]] =\n+      Option(darStream.getNextEntry) match {\n+        case Some(entry) =>\n+          go(\n+            accT.flatMap { acc =>\n+              Try {\n+                val buffer = IOUtils.toByteArray(darStream)\n+                darStream.closeEntry()"
  },
  {
    "id" : "aa76b769-c1bd-40ed-9988-dd5cfd898116",
    "prId" : 2005,
    "comments" : [
      {
        "id" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "parentId" : null,
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "What is the purpose of the type hints here?",
        "createdAt" : "2019-07-10T11:30:17Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "8ed97669-eb9f-4be0-91e3-c8c96ee169b0",
        "parentId" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "what type hints do you mean?",
        "createdAt" : "2019-07-10T11:53:07Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "cdb19f1f-336e-42f1-80bf-333d607017ff",
        "parentId" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "`name: String` and `darInfo(entries): String`",
        "createdAt" : "2019-07-10T11:57:04Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "068a66cd-3d50-4348-bcbd-009bd80acbb5",
        "parentId" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "This diagnostic failure has been already there before. I assume it helps debugging corrupted DAR files.",
        "createdAt" : "2019-07-10T12:03:48Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "e9dd670c-a473-4f5f-ac88-15bc622a5663",
        "parentId" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "author" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "body" : "I was referring to the explicit `: String` after each value in the string interpolation.",
        "createdAt" : "2019-07-10T12:09:40Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "stefanobaghino-da",
          "name" : "Stefano Baghino",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/43749967?v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f0222211-ad98-4658-b8ab-fc9e7a5414cb",
        "parentId" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Oh, sorry. Good point, I don't know actually. @leo-da why do we need them? they indeed seem to be unnecessary. ",
        "createdAt" : "2019-07-10T12:27:56Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "c8f51d6a-05e6-4a40-9721-d293344373b5",
        "parentId" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "It's a safety measure; for example, suppose you change `darInfo`'s signature to return something else alongside the `String` or add some structure like `Option[String]`, or, I don't know, add a case class that wraps it? `toString` gets applied to everything silently and automatically, so your string interpolation just silently becomes wrong. The ascription assures that no type change has happened elsewhere that could have such an impact.\r\n\r\nI'd like to write a replacement macro for `s` or a wart that only permits members of a whitelist of types to be interpolated (`String`, maybe some other safe candidates like `Int`). I'd also like a wart that forbids `toString`, but let's leave that aside for now. In the meantime, `: String` ascription is a good stopgap measure.",
        "createdAt" : "2019-07-10T22:32:30Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "2efd8626-fc8c-40b0-8dc8-1b30615fb95b",
        "parentId" : "ff84ce8a-4765-4490-b6b8-bc94e0c80947",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "Got it. Thanks @stephencompall-DA!",
        "createdAt" : "2019-07-11T07:29:28Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ad17e497cfec277fb5878ad7865ec99b598053c",
    "line" : 150,
    "diffHunk" : "@@ -21,101 +23,127 @@ class DarReader[A](\n     // The `Long` is the dalf size in bytes.\n     parseDalf: (Long, InputStream) => Try[A]) {\n \n-  import Errors._\n+  import DarReader._\n \n-  private val manifestEntry = new ZipEntry(\"META-INF/MANIFEST.MF\")\n+  def readArchiveFromFile(darFile: File) =\n+    readArchive(darFile.getName, new ZipInputStream(new FileInputStream(darFile)))\n \n-  def readArchive(darFile: ZipFile): Try[Dar[A]] =\n+  def readArchive(name: String, darStream: ZipInputStream): Try[Dar[A]] = {\n     for {\n-      names <- readDalfNames(darFile): Try[Dar[String]]\n-      main <- parseOne(darFile)(names.main): Try[A]\n-      deps <- parseAll(darFile)(names.dependencies): Try[List[A]]\n+      entries <- loadZipEntries(name, darStream)\n+      names <- entries.readDalfNames(readDalfNamesFromManifest): Try[Dar[String]]\n+      main <- parseOne(entries.getInputStreamFor)(names.main): Try[A]\n+      deps <- parseAll(entries.getInputStreamFor)(names.dependencies): Try[List[A]]\n     } yield Dar(main, deps)\n-\n-  private def readDalfNames(darFile: ZipFile): Try[Dar[String]] =\n-    parseDalfNamesFromManifest(darFile).recoverWith {\n-      case NonFatal(e1) =>\n-        findLegacyDalfNames(darFile).recoverWith {\n-          case NonFatal(_) => Failure(InvalidDar(darFile, e1))\n-        }\n-    }\n-\n-  private def parseDalfNamesFromManifest(darFile: ZipFile): Try[Dar[String]] =\n-    bracket(inputStream(darFile, manifestEntry))(close)\n-      .flatMap(is => readDalfNamesFromManifest(is))\n-\n-  private def inputStream(darFile: ZipFile, entry: ZipEntry): Try[InputStream] = {\n-    // returns null if entry does not exist\n-    Try(Option(darFile.getInputStream(entry))).flatMap {\n-      case Some(x) => Success(x)\n-      case None => Failure(InvalidZipEntry(darFile, entry))\n-    }\n   }\n \n-  // There are three cases:\n-  // 1. if it's only one .dalf, then that's the main one\n-  // 2. if it's two .dalfs, where one of them has -prim in the name, the one without -prim is the main dalf.\n-  // 3. parse error in all other cases\n-  private def findLegacyDalfNames(darFile: ZipFile): Try[Dar[String]] = {\n-    val entries: List[ZipEntry] = darEntries(darFile)\n-    val dalfs: List[String] = entries.filter(isDalf).map(_.getName)\n-    dalfs.partition(isPrimDalf) match {\n-      case (List(prim), List(main)) => Success(Dar(main, List(prim)))\n-      case (List(prim), List()) => Success(Dar(prim, List.empty))\n-      case (List(), List(main)) => Success(Dar(main, List.empty))\n-      case _ => Failure(InvalidLegacyDar(darFile))\n-    }\n+  private def loadZipEntries(name: String, darStream: ZipInputStream): Try[ZipEntries] = {\n+    @tailrec\n+    def go(accT: Try[Map[String, (Long, InputStream)]]): Try[Map[String, (Long, InputStream)]] =\n+      Option(darStream.getNextEntry) match {\n+        case Some(entry) =>\n+          go(\n+            accT.flatMap { acc =>\n+              bracket[Array[Byte], Unit](Try {\n+                IOUtils.toByteArray(darStream)\n+              })(_ => Try(darStream.closeEntry()))\n+                .map { buffer =>\n+                  val inputStream: InputStream = new ByteArrayInputStream(buffer)\n+                  acc + (entry.getName -> (buffer.length.toLong -> inputStream))\n+                }\n+            }\n+          )\n+        case None => accT\n+      }\n+\n+    go(Success(Map.empty)).map(ZipEntries(name, _))\n   }\n \n-  private def darEntries(darFile: ZipFile): List[ZipEntry] =\n-    darFile.entries.asScala.toList\n-\n-  private def isDalf(e: ZipEntry): Boolean = isDalf(e.getName)\n+  private def parseAll(getInputStreamFor: String => Try[(Long, InputStream)])(\n+      names: List[String]): Try[List[A]] =\n+    sequence(names.map(parseOne(getInputStreamFor)))\n \n-  private def isDalf(s: String): Boolean = s.toLowerCase.endsWith(\".dalf\")\n-\n-  private def isPrimDalf(s: String): Boolean = s.toLowerCase.contains(\"-prim\") && isDalf(s)\n-\n-  private def parseAll(f: ZipFile)(names: List[String]): Try[List[A]] =\n-    sequence(names.map(parseOne(f)))\n-\n-  private def parseOne(f: ZipFile)(s: String): Try[A] =\n-    bracket(getZipEntryInputStream(f, s))({ case (_, is) => close(is) }).flatMap({\n-      case (size, is) => parseDalf(size, is)\n+  private def parseOne(getInputStreamFor: String => Try[(Long, InputStream)])(s: String): Try[A] =\n+    bracket(getInputStreamFor(s))({ case (_, is) => close(is) }).flatMap({\n+      case (size, is) =>\n+        parseDalf(size, is)\n     })\n \n-  private def getZipEntryInputStream(f: ZipFile, name: String): Try[(Long, InputStream)] =\n-    for {\n-      e <- Try(f.getEntry(name))\n-      is <- inputStream(f, e)\n-      bis <- Try(new BufferedInputStream(is))\n-    } yield (e.getSize(), bis)\n-\n-  private def close(is: InputStream): Try[Unit] = Try(is.close())\n }\n \n object Errors {\n-  case class InvalidDar(darFile: ZipFile, cause: Throwable)\n-      extends RuntimeException(s\"Invalid DAR: ${darInfo(darFile): String}\", cause)\n \n-  case class InvalidZipEntry(darFile: ZipFile, zipEntry: ZipEntry)\n+  import DarReader.ZipEntries\n+\n+  case class InvalidDar(entries: ZipEntries, cause: Throwable)\n+      extends RuntimeException(s\"Invalid DAR: ${darInfo(entries): String}\", cause)\n+\n+  case class InvalidZipEntry(name: String, entries: ZipEntries)\n       extends RuntimeException(\n-        s\"Invalid zip entry: ${zipEntry.getName: String}, DAR: ${darInfo(darFile): String}\")\n+        s\"Invalid zip entryName: ${name: String}, DAR: ${darInfo(entries): String}\")"
  },
  {
    "id" : "ae48d121-8ab4-40e8-8097-3a49197864a2",
    "prId" : 2005,
    "comments" : [
      {
        "id" : "96c05ee1-ee83-4aed-94c9-4e2c86553dc6",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@gaboraranyossy-da we are leaking the `ZipInputStream` create here. It should be closed.",
        "createdAt" : "2019-07-11T13:52:59Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "9474a71b-fc51-47ca-bbaa-6bf8cee4d67c",
        "parentId" : "96c05ee1-ee83-4aed-94c9-4e2c86553dc6",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "good spot! it's addressed now.",
        "createdAt" : "2019-07-11T14:56:26Z",
        "updatedAt" : "2019-07-11T14:56:26Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ad17e497cfec277fb5878ad7865ec99b598053c",
    "line" : 32,
    "diffHunk" : "@@ -21,101 +23,127 @@ class DarReader[A](\n     // The `Long` is the dalf size in bytes.\n     parseDalf: (Long, InputStream) => Try[A]) {\n \n-  import Errors._\n+  import DarReader._\n \n-  private val manifestEntry = new ZipEntry(\"META-INF/MANIFEST.MF\")\n+  def readArchiveFromFile(darFile: File) =\n+    readArchive(darFile.getName, new ZipInputStream(new FileInputStream(darFile)))"
  },
  {
    "id" : "db130634-1094-4332-b8c2-0b50b709429c",
    "prId" : 2005,
    "comments" : [
      {
        "id" : "4843ac41-1bf9-41b3-908d-dfae1730b2f3",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "this `close` is not used anywhere. Let's delete it or change it so it closes `Try[(Long, InputStream)]`",
        "createdAt" : "2019-07-11T13:56:26Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "6b079252-3965-4ca7-b22d-cf9faeb64eed",
        "parentId" : "4843ac41-1bf9-41b3-908d-dfae1730b2f3",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "it's actually used in `parseDalfNamesFromManifest` and `parseOne`. Nevertheless I find it to be an overkill so I will just inline them.",
        "createdAt" : "2019-07-11T14:37:35Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "3ad17e497cfec277fb5878ad7865ec99b598053c",
    "line" : null,
    "diffHunk" : "@@ -21,101 +23,127 @@ class DarReader[A](\n     // The `Long` is the dalf size in bytes.\n     parseDalf: (Long, InputStream) => Try[A]) {\n \n-  import Errors._\n+  import DarReader._\n \n-  private val manifestEntry = new ZipEntry(\"META-INF/MANIFEST.MF\")\n+  def readArchiveFromFile(darFile: File) =\n+    readArchive(darFile.getName, new ZipInputStream(new FileInputStream(darFile)))\n \n-  def readArchive(darFile: ZipFile): Try[Dar[A]] =\n+  def readArchive(name: String, darStream: ZipInputStream): Try[Dar[A]] = {\n     for {\n-      names <- readDalfNames(darFile): Try[Dar[String]]\n-      main <- parseOne(darFile)(names.main): Try[A]\n-      deps <- parseAll(darFile)(names.dependencies): Try[List[A]]\n+      entries <- loadZipEntries(name, darStream)\n+      names <- entries.readDalfNames(readDalfNamesFromManifest): Try[Dar[String]]\n+      main <- parseOne(entries.getInputStreamFor)(names.main): Try[A]\n+      deps <- parseAll(entries.getInputStreamFor)(names.dependencies): Try[List[A]]\n     } yield Dar(main, deps)\n-\n-  private def readDalfNames(darFile: ZipFile): Try[Dar[String]] =\n-    parseDalfNamesFromManifest(darFile).recoverWith {\n-      case NonFatal(e1) =>\n-        findLegacyDalfNames(darFile).recoverWith {\n-          case NonFatal(_) => Failure(InvalidDar(darFile, e1))\n-        }\n-    }\n-\n-  private def parseDalfNamesFromManifest(darFile: ZipFile): Try[Dar[String]] =\n-    bracket(inputStream(darFile, manifestEntry))(close)\n-      .flatMap(is => readDalfNamesFromManifest(is))\n-\n-  private def inputStream(darFile: ZipFile, entry: ZipEntry): Try[InputStream] = {\n-    // returns null if entry does not exist\n-    Try(Option(darFile.getInputStream(entry))).flatMap {\n-      case Some(x) => Success(x)\n-      case None => Failure(InvalidZipEntry(darFile, entry))\n-    }\n   }\n \n-  // There are three cases:\n-  // 1. if it's only one .dalf, then that's the main one\n-  // 2. if it's two .dalfs, where one of them has -prim in the name, the one without -prim is the main dalf.\n-  // 3. parse error in all other cases\n-  private def findLegacyDalfNames(darFile: ZipFile): Try[Dar[String]] = {\n-    val entries: List[ZipEntry] = darEntries(darFile)\n-    val dalfs: List[String] = entries.filter(isDalf).map(_.getName)\n-    dalfs.partition(isPrimDalf) match {\n-      case (List(prim), List(main)) => Success(Dar(main, List(prim)))\n-      case (List(prim), List()) => Success(Dar(prim, List.empty))\n-      case (List(), List(main)) => Success(Dar(main, List.empty))\n-      case _ => Failure(InvalidLegacyDar(darFile))\n-    }\n+  private def loadZipEntries(name: String, darStream: ZipInputStream): Try[ZipEntries] = {\n+    @tailrec\n+    def go(accT: Try[Map[String, (Long, InputStream)]]): Try[Map[String, (Long, InputStream)]] =\n+      Option(darStream.getNextEntry) match {\n+        case Some(entry) =>\n+          go(\n+            accT.flatMap { acc =>\n+              bracket[Array[Byte], Unit](Try {\n+                IOUtils.toByteArray(darStream)\n+              })(_ => Try(darStream.closeEntry()))\n+                .map { buffer =>\n+                  val inputStream: InputStream = new ByteArrayInputStream(buffer)\n+                  acc + (entry.getName -> (buffer.length.toLong -> inputStream))\n+                }\n+            }\n+          )\n+        case None => accT\n+      }\n+\n+    go(Success(Map.empty)).map(ZipEntries(name, _))\n   }\n \n-  private def darEntries(darFile: ZipFile): List[ZipEntry] =\n-    darFile.entries.asScala.toList\n-\n-  private def isDalf(e: ZipEntry): Boolean = isDalf(e.getName)\n+  private def parseAll(getInputStreamFor: String => Try[(Long, InputStream)])(\n+      names: List[String]): Try[List[A]] =\n+    sequence(names.map(parseOne(getInputStreamFor)))\n \n-  private def isDalf(s: String): Boolean = s.toLowerCase.endsWith(\".dalf\")\n-\n-  private def isPrimDalf(s: String): Boolean = s.toLowerCase.contains(\"-prim\") && isDalf(s)\n-\n-  private def parseAll(f: ZipFile)(names: List[String]): Try[List[A]] =\n-    sequence(names.map(parseOne(f)))\n-\n-  private def parseOne(f: ZipFile)(s: String): Try[A] =\n-    bracket(getZipEntryInputStream(f, s))({ case (_, is) => close(is) }).flatMap({\n-      case (size, is) => parseDalf(size, is)\n+  private def parseOne(getInputStreamFor: String => Try[(Long, InputStream)])(s: String): Try[A] =\n+    bracket(getInputStreamFor(s))({ case (_, is) => close(is) }).flatMap({\n+      case (size, is) =>\n+        parseDalf(size, is)\n     })\n \n-  private def getZipEntryInputStream(f: ZipFile, name: String): Try[(Long, InputStream)] =\n-    for {\n-      e <- Try(f.getEntry(name))\n-      is <- inputStream(f, e)\n-      bis <- Try(new BufferedInputStream(is))\n-    } yield (e.getSize(), bis)\n-\n-  private def close(is: InputStream): Try[Unit] = Try(is.close())\n }\n \n object Errors {\n-  case class InvalidDar(darFile: ZipFile, cause: Throwable)\n-      extends RuntimeException(s\"Invalid DAR: ${darInfo(darFile): String}\", cause)\n \n-  case class InvalidZipEntry(darFile: ZipFile, zipEntry: ZipEntry)\n+  import DarReader.ZipEntries\n+\n+  case class InvalidDar(entries: ZipEntries, cause: Throwable)\n+      extends RuntimeException(s\"Invalid DAR: ${darInfo(entries): String}\", cause)\n+\n+  case class InvalidZipEntry(name: String, entries: ZipEntries)\n       extends RuntimeException(\n-        s\"Invalid zip entry: ${zipEntry.getName: String}, DAR: ${darInfo(darFile): String}\")\n+        s\"Invalid zip entryName: ${name: String}, DAR: ${darInfo(entries): String}\")\n \n-  case class InvalidLegacyDar(darFile: ZipFile)\n-      extends RuntimeException(s\"Invalid DAR: ${darInfo(darFile): String}\")\n+  case class InvalidLegacyDar(entries: ZipEntries)\n+      extends RuntimeException(s\"Invalid Legacy DAR: ${darInfo(entries)}\")\n \n-  private def darInfo(darFile: ZipFile): String =\n-    s\"${darFile.getName: String}, content: [${darFileNames(darFile).mkString(\", \"): String}}]\"\n+  private def darInfo(entries: ZipEntries): String =\n+    s\"${entries.name}, content: [${darFileNames(entries).mkString(\", \"): String}}]\"\n \n-  private def darFileNames(darFile: ZipFile): List[String] =\n-    darFile.entries.asScala.toList.map(_.getName)\n+  private def darFileNames(entries: ZipEntries): Iterable[String] =\n+    entries.entries.keys\n }\n \n object DarReader {\n+\n+  private val ManifestName = \"META-INF/MANIFEST.MF\"\n+\n+  private[archive] case class ZipEntries(name: String, entries: Map[String, (Long, InputStream)]) {\n+\n+    def getInputStreamFor(entryName: String): Try[(Long, InputStream)] = {\n+      entries.get(entryName) match {\n+        case Some((size, is)) => Success(size -> is)\n+        case None => Failure(InvalidZipEntry(entryName, this))\n+      }\n+    }\n+\n+    def readDalfNames(\n+        readDalfNamesFromManifest: InputStream => Try[Dar[String]]): Try[Dar[String]] =\n+      parseDalfNamesFromManifest(readDalfNamesFromManifest).recoverWith {\n+        case NonFatal(e1) =>\n+          findLegacyDalfNames().recoverWith {\n+            case NonFatal(_) => Failure(InvalidDar(this, e1))\n+          }\n+      }\n+\n+    private def parseDalfNamesFromManifest(\n+        readDalfNamesFromManifest: InputStream => Try[Dar[String]]): Try[Dar[String]] =\n+      bracket(getInputStreamFor(ManifestName)) { case (_, is) => close(is) }\n+        .flatMap { case (_, is) => readDalfNamesFromManifest(is) }\n+\n+    // There are three cases:\n+    // 1. if it's only one .dalf, then that's the main one\n+    // 2. if it's two .dalfs, where one of them has -prim in the name, the one without -prim is the main dalf.\n+    // 3. parse error in all other cases\n+    private def findLegacyDalfNames(): Try[Dar[String]] = {\n+      val dalfs: List[String] = entries.keys.filter(isDalf).toList\n+\n+      dalfs.partition(isPrimDalf) match {\n+        case (List(prim), List(main)) => Success(Dar(main, List(prim)))\n+        case (List(prim), Nil) => Success(Dar(prim, List.empty))\n+        case (Nil, List(main)) => Success(Dar(main, List.empty))\n+        case _ => Failure(InvalidLegacyDar(this))\n+      }\n+    }\n+\n+    private def isDalf(s: String): Boolean = s.toLowerCase.endsWith(\".dalf\")\n+\n+    private def isPrimDalf(s: String): Boolean = s.toLowerCase.contains(\"-prim\") && isDalf(s)\n+  }\n+\n+  private[archive] def close(is: InputStream): Try[Unit] = Try(is.close())"
  },
  {
    "id" : "0374c70f-9e73-4b0c-91ff-195cda179a50",
    "prId" : 309,
    "comments" : [
      {
        "id" : "100c0dca-632d-4cc8-a216-6abf5e918232",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "This won't work for DARs that also contain the stdlib, which is now produced as a separate DALF file next to `daml-prim.dalf` and the DALF file for the actual model. Unless we never want to support a DAR file with no manifest but more than 2 DALF files.",
        "createdAt" : "2019-04-09T07:42:28Z",
        "updatedAt" : "2019-04-09T07:49:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fdf6ccb7-21c5-4b04-8f99-2fd44349f859",
        "parentId" : "100c0dca-632d-4cc8-a216-6abf5e918232",
        "author" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "body" : "> Unless we never want to support a DAR file with no manifest but more than 2 DALF files.\r\n\r\nthat is my assumption here. @robin-da can you comment?",
        "createdAt" : "2019-04-09T08:00:30Z",
        "updatedAt" : "2019-04-09T08:00:37Z",
        "lastEditedBy" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0ed3c2ec-1b96-483e-a594-1734b245c79e",
        "parentId" : "100c0dca-632d-4cc8-a216-6abf5e918232",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@francesco-da legacy DAR only contained main and prim dalfs, no stdlib. But again, specification for the DAR format would be nice to have",
        "createdAt" : "2019-04-09T11:58:30Z",
        "updatedAt" : "2019-04-09T11:58:30Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "5ce3458e-08ac-48d1-bccf-793a1237f82c",
        "parentId" : "100c0dca-632d-4cc8-a216-6abf5e918232",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "```\r\nleo   [42 minutes ago]\r\nYep, that's what I remember. The old dar that didn't have Main-Dalf in the manifest could only have two dalfs, main and prim. So no reason to overcomplicate the dar reader. New dars with stdlib will always have Main-Dalf in the manifest. Am I right? @robin\r\nAnd yeah we need a spec, if format keeps changing (edited)\r\n\r\n\r\nrobin   [36 minutes ago]\r\nyes\r\n```",
        "createdAt" : "2019-04-09T13:19:06Z",
        "updatedAt" : "2019-04-09T13:19:06Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d645bda62fd50580fcb972f7f3ab728cfcfac074",
    "line" : 49,
    "diffHunk" : "@@ -22,15 +24,40 @@ class DarReader[A](\n \n   def readArchive(darFile: ZipFile): Try[Dar[A]] =\n     for {\n-      names <- parseDalfNamesFromManifest(darFile): Try[Dar[String]]\n+      names <- readDalfNames(darFile): Try[Dar[String]]\n       main <- parseOne(darFile)(names.main): Try[A]\n       deps <- parseAll(darFile)(names.dependencies): Try[List[A]]\n     } yield Dar(main, deps)\n \n+  private def readDalfNames(darFile: ZipFile): Try[Dar[String]] =\n+    parseDalfNamesFromManifest(darFile).recoverWith {\n+      case NonFatal(e1) =>\n+        findDalfNames(darFile).recoverWith {\n+          case NonFatal(e2) => Failure(InvalidDar(e1, e2))\n+        }\n+    }\n+\n   private def parseDalfNamesFromManifest(darFile: ZipFile): Try[Dar[String]] =\n     bracket(Try(darFile.getInputStream(manifestEntry)))(close)\n       .flatMap(is => readDalfNamesFromManifest(is))\n \n+  private def findDalfNames(darFile: ZipFile): Try[Dar[String]] = {\n+    val entries: List[ZipEntry] = darFile.entries.asScala.toList\n+    val dalfs: List[String] = entries.filter(isDalf).map(_.getName)\n+    dalfs.partition(isPrimDalf) match {"
  },
  {
    "id" : "aa7bdaff-3dbf-4e25-8797-df770dd82df3",
    "prId" : 309,
    "comments" : [
      {
        "id" : "73934849-2434-461b-a132-da769acefeb9",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I wouldn't mention the legacy mode at all. If both \"modes\" fail to read the DAR file, we should just fail with the error message of the currently expected format (aka DAR with manifest). For most users the legacy mode should never come into action.",
        "createdAt" : "2019-04-09T07:48:58Z",
        "updatedAt" : "2019-04-09T07:49:21Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "0d0f6f3b-b2dc-404c-a193-eacfdb570468",
        "parentId" : "73934849-2434-461b-a132-da769acefeb9",
        "author" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "body" : "i'm happy for @leo-da to adjust the error message, i'll merge this in the meantime.",
        "createdAt" : "2019-04-09T08:34:24Z",
        "updatedAt" : "2019-04-09T08:34:28Z",
        "lastEditedBy" : {
          "login" : "francesco-da",
          "name" : "Francesco Mazzoli",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/25149700?u=1141981d6c61003d54f8e8cd8a3cbd67cbbc1e77&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "749270f7-c95f-44d0-a991-d02109eaa3b0",
        "parentId" : "73934849-2434-461b-a132-da769acefeb9",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "@gerolf-da why? I like the idea of legacy... you are telling your user that they need to upgrade.",
        "createdAt" : "2019-04-09T11:57:10Z",
        "updatedAt" : "2019-04-09T11:57:10Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "d645bda62fd50580fcb972f7f3ab728cfcfac074",
    "line" : 75,
    "diffHunk" : "@@ -46,6 +73,17 @@ class DarReader[A](\n   private def close(is: InputStream): Try[Unit] = Try(is.close())\n }\n \n+case class InvalidLegacyDar(dalfNames: List[String])\n+    extends RuntimeException(\n+      s\"Invalid Legacy DAR. Legacy DAR can contain: one main DALF and an optional *-prim* DALF. \" +\n+        s\"This DAR contains: [${dalfNames.mkString(\", \"): String}]\")\n+\n+case class InvalidDar(cause1: Throwable, cause2: Throwable)"
  }
]