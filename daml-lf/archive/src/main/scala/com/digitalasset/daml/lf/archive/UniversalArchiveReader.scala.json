[
  {
    "id" : "5592cbc9-ed96-4f0d-a5f2-bc1815c34b2b",
    "prId" : 2005,
    "comments" : [
      {
        "id" : "37b0f427-8458-4c97-854c-c6f5511f1550",
        "parentId" : null,
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "I might be missing something, but I believe we are not closing the above `inputStream`. In the original implementation, `bracket` was handling this.",
        "createdAt" : "2019-07-08T14:58:10Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "794a694d-db7a-4c00-99b4-9cd6c0a48330",
        "parentId" : "37b0f427-8458-4c97-854c-c6f5511f1550",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "The only case I can think of which is not handled is when the InputStream is instantiated, the rest should be managed by the numerous decorating layers. I put something to handle issues at instantiation.",
        "createdAt" : "2019-07-09T07:29:07Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f5846309-68b0-4ae6-a231-9f80acfc5db5",
        "parentId" : "37b0f427-8458-4c97-854c-c6f5511f1550",
        "author" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "body" : "You're right, I thought the parseDar/Dalf will eventually close the stream. Also, when the stream blows up at instantiation there is nothing to close.",
        "createdAt" : "2019-07-09T09:24:59Z",
        "updatedAt" : "2019-07-11T14:55:46Z",
        "lastEditedBy" : {
          "login" : "gabor-aranyossy",
          "name" : "Gabor Aranyossy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/29858875?u=03b5eca13ed32e74056ee216f2def12e249bcfed&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "3ad17e497cfec277fb5878ad7865ec99b598053c",
    "line" : 50,
    "diffHunk" : "@@ -17,32 +16,41 @@ import scala.util.{Failure, Success, Try}\n /**\n   * Can parse DARs and DALFs.\n   * See factories:\n-  *   [[com.digitalasset.daml.lf.UniversalArchiveReader]];\n-  *   [[com.digitalasset.daml.lf.UniversalArchiveReaderWithVersion]]\n+  * [[com.digitalasset.daml.lf.UniversalArchiveReader]];\n+  * [[com.digitalasset.daml.lf.UniversalArchiveReaderWithVersion]]\n   *\n   * @param parseDar  function to parse a DAR file.\n   * @param parseDalf function to parse a DALF input stream.\n   * @tparam A type of the result, see factories for more details.\n   */\n class UniversalArchiveReader[A](\n-    parseDar: ZipFile => Try[Dar[A]],\n+    parseDar: (String, ZipInputStream) => Try[Dar[A]],\n     parseDalf: InputStream => Try[A]) {\n-  import SupportedFileType._\n-\n-  def readFile(file: File): Try[Dar[A]] = supportedFileType(file).flatMap {\n-    case DarFile =>\n-      bracket(zipFile(file))(close).flatMap(parseDar)\n-    case DalfFile =>\n-      bracket(inputStream(file))(close).flatMap(parseDalf).map(Dar(_, List.empty))\n-  }\n \n-  private def zipFile(f: File): Try[ZipFile] =\n-    Try(new ZipFile(f))\n+  import SupportedFileType._\n \n-  private def inputStream(f: File): Try[InputStream] =\n+  def readFile(file: File): Try[Dar[A]] =\n+    for {\n+      fileType <- supportedFileType(file)\n+      inputStream <- fileToInputStream(file)"
  },
  {
    "id" : "2c2c378d-a22d-42a5-b380-1482c7c196b5",
    "prId" : 359,
    "comments" : [
      {
        "id" : "e4e758ca-bb9c-4217-b4bb-2a880fa57792",
        "parentId" : null,
        "author" : {
          "login" : "stephencompall-DA",
          "name" : "Actually @S11001001 (Stephen Compall)",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/32464278?u=2f0eaeb2500ecacccd6c1af95b27424d5193ad65&v=4"
        },
        "body" : "Should this check be case-insensitive?",
        "createdAt" : "2019-04-10T14:05:42Z",
        "updatedAt" : "2019-04-10T14:06:11Z",
        "lastEditedBy" : {
          "login" : "stephencompall-DA",
          "name" : "Actually @S11001001 (Stephen Compall)",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/32464278?u=2f0eaeb2500ecacccd6c1af95b27424d5193ad65&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "7bcbdaba-1e04-482b-86db-1585352a958f",
        "parentId" : "e4e758ca-bb9c-4217-b4bb-2a880fa57792",
        "author" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "body" : "it can be... I actually thought about this initially. But I believe our tools create DARs and DALFs with `*.dar` and `*.dalf` extensions and that is how it is supposed to be. But if you think the case is important, it is easy to fix.",
        "createdAt" : "2019-04-10T14:08:27Z",
        "updatedAt" : "2019-04-10T14:09:31Z",
        "lastEditedBy" : {
          "login" : "leo-da",
          "name" : "Leonid Shlyapnikov",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/27688859?u=375a6e2bd1079fec6f7d6d582ac05b5628218384&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "90355c1705aeacdc6ee627081dcdfeadbec76a81",
    "line" : 79,
    "diffHunk" : "@@ -0,0 +1,86 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf\n+import java.io._\n+import java.util.zip.ZipFile\n+\n+import com.digitalasset.daml.lf.archive.{DarReader, LanguageMajorVersion, Reader}\n+import com.digitalasset.daml.lf.data.Ref\n+import com.digitalasset.daml.lf.data.TryOps.Bracket.bracket\n+import com.digitalasset.daml_lf.DamlLf\n+\n+import scala.util.{Failure, Success, Try}\n+\n+/**\n+  * Can parse DARs and DALFs.\n+  * See factories:\n+  *   [[com.digitalasset.daml.lf.UniversalArchiveReader]];\n+  *   [[com.digitalasset.daml.lf.UniversalArchiveReaderWithVersion]]\n+  *\n+  * @param parseDar  function to parse a DAR file.\n+  * @param parseDalf function to parse a DALF input stream.\n+  * @tparam A type of the result, see factories for more details.\n+  */\n+class UniversalArchiveReader[A](\n+    parseDar: ZipFile => Try[Dar[A]],\n+    parseDalf: InputStream => Try[A]) {\n+  import SupportedFileType._\n+\n+  def readArchive(file: File): Try[Dar[A]] = supportedFileType(file).flatMap {\n+    case DarFile =>\n+      bracket(zipFile(file))(close).flatMap(parseDar)\n+    case DalfFile =>\n+      bracket(inputStream(file))(close).flatMap(parseDalf).map(Dar(_, List.empty))\n+  }\n+\n+  private def zipFile(f: File): Try[ZipFile] = Try(new ZipFile(f))\n+\n+  private def inputStream(f: File): Try[InputStream] =\n+    Try(new BufferedInputStream(new FileInputStream(f)))\n+\n+  private def close(f: Closeable): Try[Unit] = Try(f.close())\n+}\n+\n+/**\n+  * Factory for [[com.digitalasset.daml.lf.UniversalArchiveReader]] class.\n+  */\n+object UniversalArchiveReader {\n+  def apply(): UniversalArchiveReader[(Ref.PackageId, DamlLf.ArchivePayload)] =\n+    new UniversalArchiveReader(parseDar(parseDalf), parseDalf)\n+\n+  def apply[A](parseDalf: InputStream => Try[A]): UniversalArchiveReader[A] =\n+    new UniversalArchiveReader[A](parseDar(parseDalf), parseDalf)\n+\n+  private def parseDalf(is: InputStream) = Try(Reader.decodeArchiveFromInputStream(is))\n+\n+  private def parseDar[A](parseDalf: InputStream => Try[A]): ZipFile => Try[Dar[A]] =\n+    DarReader(parseDalf).readArchive\n+}\n+\n+/**\n+  * Factory for [[com.digitalasset.daml.lf.UniversalArchiveReader]] class.\n+  */\n+object UniversalArchiveReaderWithVersion {\n+  def apply()\n+    : UniversalArchiveReader[((Ref.PackageId, DamlLf.ArchivePayload), LanguageMajorVersion)] =\n+    UniversalArchiveReader(parseDalf)\n+\n+  private def parseDalf(is: InputStream) = Try(Reader.readArchiveAndVersion(is))\n+}\n+\n+private[lf] object SupportedFileType {\n+  def supportedFileType(f: File): Try[SupportedFileType] =\n+    if (DarFile.matchesFileExtension(f)) Success(DarFile)\n+    else if (DalfFile.matchesFileExtension(f)) Success(DalfFile)\n+    else Failure(UnsupportedFileExtension(f))\n+\n+  sealed abstract class SupportedFileType(fileExtension: String) extends Serializable with Product {\n+    def matchesFileExtension(f: File): Boolean = f.getName.endsWith(fileExtension)"
  }
]