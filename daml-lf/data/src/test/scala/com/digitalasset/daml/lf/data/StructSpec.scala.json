[
  {
    "id" : "ef857787-2055-496d-b226-ecd03a62c8df",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "04ef02d5-c5d3-40bf-ab80-d20df5530f10",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I assume these are some remains from debugging this?",
        "createdAt" : "2020-09-02T11:03:13Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -10,51 +10,59 @@ class StructSpec extends WordSpec with Matchers with PropertyChecks {\n \n   private[this] val List(f1, f2, f3) = List(\"f1\", \"f2\", \"f3\").map(Ref.Name.assertFromString)\n \n-  \"SortMap.fromSortedImmArray\" should {\n+  \"SortMap.toSeq\" should {\n \n-    \"fail if the input list is not sorted\" in {\n+    \"sort fields\" in {\n \n-      val negativeTestCases =\n+      val testCases =\n         Table(\n           \"list\",\n-          ImmArray.empty,\n-          ImmArray(f1 -> 1),\n-          ImmArray(f1 -> 1, f1 -> 2),\n-          ImmArray(f1 -> 1, f2 -> 2, f3 -> 3),\n+          List(),\n+          List(f1 -> 1),\n+          List(f1 -> 1, f1 -> 2),\n+          List(f1 -> 1, f2 -> 2, f3 -> 3),\n+          List(f1 -> 1, f2 -> 2, f3 -> 3, f1 -> 2),\n+          List(f2 -> 2, f3 -> 3, f1 -> 1),\n         )\n \n-      val positiveTestCases = Table(\n-        \"list\",\n-        ImmArray(f1 -> 1, f2 -> 2, f3 -> 3, f1 -> 2),\n-        ImmArray(f2 -> 2, f3 -> 3, f1 -> 1),\n-      )\n-\n-      forEvery(negativeTestCases)(l => Struct.fromSortedImmArray(l) shouldBe 'right)\n-\n-      forEvery(positiveTestCases)(l => Struct.fromSortedImmArray(l) shouldBe 'left)\n+      forEvery(testCases) { list =>\n+        val struct = Struct.fromSeq(list)\n+        (struct.names zip struct.names.drop(1)).foreach {\n+          case (x, y) => (x: String) shouldBe <(y: String)\n+        }\n+      }\n \n     }\n-  }\n \n-  \"SortMap.apply\" should {\n-    \"sorted fields\" in {\n+    \"\"\"drop duplicate (with \"last wins\" policy).\"\"\" in {\n \n       val testCases =\n         Table(\n           \"list\",\n-          Struct(),\n-          Struct(f1 -> 1),\n-          Struct(f1 -> 1, f1 -> 2),\n-          Struct(f1 -> 1, f2 -> 2, f3 -> 3),\n-          Struct(f1 -> 1, f2 -> 2, f3 -> 3, f1 -> 2),\n-          Struct(f2 -> 2, f3 -> 3, f1 -> 1),\n+          List(),\n+          List(f1 -> 1, f1 -> 1),\n+          List(f1 -> 1, f1 -> 2),\n+          List(f1 -> 1, f2 -> 2, f3 -> 3, f1 -> 2),\n+          List(f2 -> 2, f3 -> 3, f2 -> 1, f3 -> 4, f3 -> 0),\n         )\n \n-      forEvery(testCases) { s =>\n-        s.names.toSeq shouldBe s.names.toSeq.sorted[String]\n+      forEvery(testCases) { list =>\n+        val struct = Struct.fromSeq(list)\n+        val map = list.toMap\n+        remy.log(list -> struct)"
  }
]