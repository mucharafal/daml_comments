[
  {
    "id" : "1ad0de0e-a4da-42ad-a818-2f53e93314e5",
    "prId" : 2053,
    "comments" : [
      {
        "id" : "db410da7-e6d0-45c5-a0eb-f32c5dd46296",
        "parentId" : null,
        "author" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "body" : "Noob Scala question, how does this work? The pattern does not seem exhaustive, and what does `case x =>` (without any value on the right hand side of `=>`) produce?",
        "createdAt" : "2019-07-16T13:31:06Z",
        "updatedAt" : "2019-07-16T13:50:20Z",
        "lastEditedBy" : {
          "login" : "rautenrieth-da",
          "name" : "Robert Autenrieth",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/31539813?u=e5fe17e2c6f986e9ee04c5b9ca5f6a5a90d1c94a&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b3b9042e-6d57-46f6-9244-01c783411a45",
        "parentId" : "db410da7-e6d0-45c5-a0eb-f32c5dd46296",
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "> The pattern does not seem exhaustive\r\n\r\nPattern lists (`{ case pat => expr; ...}`) get two different treatments in the two kinds of lambda context. If the expected type is `T => R`, they get Î·-expanded like `x => x match {...}`, and normal exhaustiveness checking applies.\r\n\r\nHowever, if the expected type is `T PartialFunction R`, exhaustiveness checking _does not_ apply, and the result gets a generated `isDefinedAt` (and compatible `applyOrElse` semantics) that returns true iff some `case` matching the argument is present. So the idiomatic way to write `catMaybes[A]: List[Option[A]] => List[A]` is `_ collect { case Some(x) => x }`.\r\n\r\n`inside` takes a `PartialFunction`; as with `collect`, the inexhaustiveness is deliberate.\r\n\r\n> what does `case x =>` (without any value on the right hand side of `=>`) produce?\r\n\r\n`()`. This is usual for scalatest when you have nothing further to assert, see [`matchPattern` example](http://doc.scalatest.org/3.0.0/org/scalatest/Matchers.html#matchingAPattern).",
        "createdAt" : "2019-07-16T15:05:59Z",
        "updatedAt" : "2019-07-16T15:05:59Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "1699d1a72a141e994b450b4078470a298e34bab3",
    "line" : 29,
    "diffHunk" : "@@ -0,0 +1,33 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import ImmArray.ImmArraySeq\n+\n+import org.scalatest.{Inside, Matchers, WordSpec}\n+import org.scalatest.prop.GeneratorDrivenPropertyChecks\n+\n+@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n+class LawlessTraversalsSpec\n+    extends WordSpec\n+    with Matchers\n+    with Inside\n+    with GeneratorDrivenPropertyChecks {\n+  import LawlessTraversals._\n+\n+  \"traverseEitherStrictly\" should {\n+    \"satisfy identity, elementwise\" in forAll { xs: Seq[Int] =>\n+      xs traverseEitherStrictly (Right(_)) should ===(Right(xs))\n+    }\n+\n+    \"preserve class if the implementation bothered to set it up\" in {\n+      val classySeqs = Seq[Seq[Int]](List(1), Vector(2), ImmArraySeq(3))\n+      // we need to use patmat, not == or shouldBe, because patmat is stricter\n+      inside(classySeqs map (_ traverseEitherStrictly (Right(_)))) {\n+        case Seq(_, Right(List(_)), _) => fail(\"lists are not vectors\")\n+        case Seq(Right(List(1)), Right(Vector(2)), Right(ImmArraySeq(3))) =>"
  }
]