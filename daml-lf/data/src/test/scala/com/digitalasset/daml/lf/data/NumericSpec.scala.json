[
  {
    "id" : "fc09ff0e-6194-4b20-841b-e7147745449a",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "eae9fa32-2f8c-4da0-9446-6fab8246efb7",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    \"fail on too precise inputs\" in {\r\n```",
        "createdAt" : "2019-08-15T11:54:16Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,480 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+\n+import org.scalatest\n+\n+import scala.language.implicitConversions\n+import scala.math.{BigDecimal => BigDec}\n+import scala.util.Random\n+\n+class NumericSpec\n+    extends scalatest.WordSpec\n+    with scalatest.Matchers\n+    with scalatest.prop.TableDrivenPropertyChecks {\n+\n+  \"fromBigDecimal\" should {\n+    implicit def toBigDecimal(s: String): BigDecimal =\n+      new BigDecimal(s)\n+\n+    \"succeed for valid inputs\" in {\n+\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"99999999999999999999999999999999999999.\"),\n+        (0, \"-1.\"),\n+        (0, \"-99999999999999999999999999999999999999.\"),\n+        (5, \"1.00000\"),\n+        (7, \"0.\"),\n+        (10, \"9999999999999999999999999999.9999999999\"),\n+        (37, \"0.0000000000000000000000000000000000001\"),\n+        (38, \"0.99999999999999999999999999999999999999\"),\n+        (38, \"0.00000000000000000000016180339887499677\"),\n+        (38, \"-0.99999999999999999999999999999999999999\")\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe Right(bigDec.setScale(scale))\n+      }\n+    }\n+\n+    \"fail on too Large inputs\" in {\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"100000000000000000000000000000000000000.\"),\n+        (0, \"-100000000000000000000000000000000000000.\"),\n+        (17, \"10000000000000000000000.0000000000000000\"),\n+        (3, \"8284590452353602874713526624977572470.\"),\n+        (38, \"1.00000000000000000000000000000000000000\"),\n+        (38, \"-1.00000000000000000000000000000000000001\"),\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe 'left\n+      }\n+    }\n+\n+    \"fail on too Precise inputs\" in {"
  },
  {
    "id" : "8e9e0714-9907-488d-aa44-883cfeef60fb",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "6ea5c243-6836-4bf5-a99d-c0b694004e94",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "rename `\"numeric\"` to `\"input\"` here and elsewhere.",
        "createdAt" : "2019-08-15T11:56:45Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,480 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+\n+import org.scalatest\n+\n+import scala.language.implicitConversions\n+import scala.math.{BigDecimal => BigDec}\n+import scala.util.Random\n+\n+class NumericSpec\n+    extends scalatest.WordSpec\n+    with scalatest.Matchers\n+    with scalatest.prop.TableDrivenPropertyChecks {\n+\n+  \"fromBigDecimal\" should {\n+    implicit def toBigDecimal(s: String): BigDecimal =\n+      new BigDecimal(s)\n+\n+    \"succeed for valid inputs\" in {\n+\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"99999999999999999999999999999999999999.\"),\n+        (0, \"-1.\"),\n+        (0, \"-99999999999999999999999999999999999999.\"),\n+        (5, \"1.00000\"),\n+        (7, \"0.\"),\n+        (10, \"9999999999999999999999999999.9999999999\"),\n+        (37, \"0.0000000000000000000000000000000000001\"),\n+        (38, \"0.99999999999999999999999999999999999999\"),\n+        (38, \"0.00000000000000000000016180339887499677\"),\n+        (38, \"-0.99999999999999999999999999999999999999\")\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe Right(bigDec.setScale(scale))\n+      }\n+    }\n+\n+    \"fail on too Large inputs\" in {\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"100000000000000000000000000000000000000.\"),\n+        (0, \"-100000000000000000000000000000000000000.\"),\n+        (17, \"10000000000000000000000.0000000000000000\"),\n+        (3, \"8284590452353602874713526624977572470.\"),\n+        (38, \"1.00000000000000000000000000000000000000\"),\n+        (38, \"-1.00000000000000000000000000000000000001\"),\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe 'left\n+      }\n+    }\n+\n+    \"fail on too Precise inputs\" in {\n+      val testCases = Table(\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"0.1\"),\n+        (0, \"-0.1\"),\n+        (17, \"10000000000000000.000000000000000001\"),\n+        (3, \"0.82845\"),\n+        (38, \"0.000000000000000000000000000000000000000\"),\n+        (38, \"-0.000000000000000000000000000000000000001\"),\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe 'left\n+      }\n+    }\n+  }\n+\n+  \"Numeric.add\" should {\n+\n+    import Numeric.add\n+    implicit def toNumeric(s: String): Numeric = Numeric.assertFromString(s)\n+\n+    \"throw an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"99999999999999999999999999999999999999.\", \"1.\"),\n+        (\"-1.\", \"-99999999999999999999999999999999999999.\"),\n+        (\"0.99999999999999999999999999999999999999\", \"0.00000000000000000000000000000000000001\"),\n+        (\"-0.99999999999999999999999999999999999999\", \"-0.00000000000000000000000000000000000001\"),\n+        (\"9999999999999999999999.0000000000000000\", \"1.0000000000000000\"),\n+        (\"5678901234567890.1234567890123456789012\", \"5678901234567890.1234567890123456789012\")\n+      )\n+\n+      add(\"1.0\", \"1.0\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        add(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"add two numerics properly\" in {\n+      val testCases = Table[Numeric, Numeric, Numeric](\n+        (\"numeric\", \"numeric\", \"result\"),"
  },
  {
    "id" : "87813638-0999-4d05-9a86-9d4fef652de6",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "cac189ac-0636-481c-aa21-d8944b1afde2",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    \"multiply two numeric properly\" in {\r\n```",
        "createdAt" : "2019-08-15T11:58:23Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,480 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+\n+import org.scalatest\n+\n+import scala.language.implicitConversions\n+import scala.math.{BigDecimal => BigDec}\n+import scala.util.Random\n+\n+class NumericSpec\n+    extends scalatest.WordSpec\n+    with scalatest.Matchers\n+    with scalatest.prop.TableDrivenPropertyChecks {\n+\n+  \"fromBigDecimal\" should {\n+    implicit def toBigDecimal(s: String): BigDecimal =\n+      new BigDecimal(s)\n+\n+    \"succeed for valid inputs\" in {\n+\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"99999999999999999999999999999999999999.\"),\n+        (0, \"-1.\"),\n+        (0, \"-99999999999999999999999999999999999999.\"),\n+        (5, \"1.00000\"),\n+        (7, \"0.\"),\n+        (10, \"9999999999999999999999999999.9999999999\"),\n+        (37, \"0.0000000000000000000000000000000000001\"),\n+        (38, \"0.99999999999999999999999999999999999999\"),\n+        (38, \"0.00000000000000000000016180339887499677\"),\n+        (38, \"-0.99999999999999999999999999999999999999\")\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe Right(bigDec.setScale(scale))\n+      }\n+    }\n+\n+    \"fail on too Large inputs\" in {\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"100000000000000000000000000000000000000.\"),\n+        (0, \"-100000000000000000000000000000000000000.\"),\n+        (17, \"10000000000000000000000.0000000000000000\"),\n+        (3, \"8284590452353602874713526624977572470.\"),\n+        (38, \"1.00000000000000000000000000000000000000\"),\n+        (38, \"-1.00000000000000000000000000000000000001\"),\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe 'left\n+      }\n+    }\n+\n+    \"fail on too Precise inputs\" in {\n+      val testCases = Table(\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"0.1\"),\n+        (0, \"-0.1\"),\n+        (17, \"10000000000000000.000000000000000001\"),\n+        (3, \"0.82845\"),\n+        (38, \"0.000000000000000000000000000000000000000\"),\n+        (38, \"-0.000000000000000000000000000000000000001\"),\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe 'left\n+      }\n+    }\n+  }\n+\n+  \"Numeric.add\" should {\n+\n+    import Numeric.add\n+    implicit def toNumeric(s: String): Numeric = Numeric.assertFromString(s)\n+\n+    \"throw an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"99999999999999999999999999999999999999.\", \"1.\"),\n+        (\"-1.\", \"-99999999999999999999999999999999999999.\"),\n+        (\"0.99999999999999999999999999999999999999\", \"0.00000000000000000000000000000000000001\"),\n+        (\"-0.99999999999999999999999999999999999999\", \"-0.00000000000000000000000000000000000001\"),\n+        (\"9999999999999999999999.0000000000000000\", \"1.0000000000000000\"),\n+        (\"5678901234567890.1234567890123456789012\", \"5678901234567890.1234567890123456789012\")\n+      )\n+\n+      add(\"1.0\", \"1.0\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        add(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"add two numerics properly\" in {\n+      val testCases = Table[Numeric, Numeric, Numeric](\n+        (\"numeric\", \"numeric\", \"result\"),\n+        (\"0.00000\", \"0.00000\", \"0.00000\"),\n+        (\n+          \"0.99999999999999999999999999999999999999\",\n+          \"-0.00000000000000000000000000000000000001\",\n+          \"0.99999999999999999999999999999999999998\"),\n+        (\n+          \"3.1415926535897932384626433832795028842\",\n+          \"2.7182818284590452353602874713526624978\",\n+          \"5.8598744820488384738229308546321653820\"\n+        ),\n+        (\n+          \"161803398.8749900000\",\n+          \"-161803398.8749900000\",\n+          \"0.0000000000\"\n+        ),\n+        (\n+          \"55555555555555555555555555555555555555.\",\n+          \"44444444444444444444444444444444444444.\",\n+          \"99999999999999999999999999999999999999.\"\n+        )\n+      )\n+\n+      forEvery(testCases) { (x, y, z) =>\n+        add(x, y) shouldBe Right(z)\n+      }\n+\n+    }\n+  }\n+\n+  \"Numeric.subtract\" should {\n+    import Numeric.subtract\n+    implicit def toNumeric(s: String): Numeric =\n+      Numeric.assertFromString(s)\n+\n+    \"throw an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"-99999999999999999999999999999999999999.\", \"1.\"),\n+        (\"-1.\", \"99999999999999999999999999999999999999.\"),\n+        (\"0.99999999999999999999999999999999999999\", \"-0.00000000000000000000000000000000000001\"),\n+        (\"0.99999999999999999999999999999999999999\", \"-0.00000000000000000000000000000000000001\"),\n+        (\"9999999999999999999999.0000000000000000\", \"-1.0000000000000000\"),\n+        (\"567890123456789012345.67890123456789012\", \"-567890123456789012345.67890123456789012\")\n+      )\n+\n+      subtract(\"1.0\", \"1.0\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        subtract(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"subtract two numerics properly\" in {\n+      val testCases = Table[Numeric, Numeric, Numeric](\n+        (\"numeric\", \"numeric\", \"result\"),\n+        (\"0.00000\", \"0.00000\", \"0.00000\"),\n+        (\n+          \"0.99999999999999999999999999999999999999\",\n+          \"0.00000000000000000000000000000000000001\",\n+          \"0.99999999999999999999999999999999999998\"),\n+        (\n+          \"3.1415926535897932384626433832795028842\",\n+          \"2.7182818284590452353602874713526624978\",\n+          \"0.4233108251307480031023559119268403864\"\n+        ),\n+        (\n+          \"161803398.8749900000\",\n+          \"161803398.8749900000\",\n+          \"0.0000000000\"\n+        ),\n+        (\n+          \"55555555555555555555555555555555555555.\",\n+          \"44444444444444444444444444444444444444.\",\n+          \"11111111111111111111111111111111111111.\"\n+        )\n+      )\n+\n+      forEvery(testCases) { (x, y, z) =>\n+        subtract(x, y) shouldBe Right(z)\n+      }\n+\n+    }\n+  }\n+\n+  \"Numeric.multiply\" should {\n+    import Numeric.multiply\n+\n+    implicit def toNumeric(s: String): Numeric =\n+      Numeric.assertFromString(s)\n+\n+    \"throws an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"10000000000000000000.\", \"10000000000000000000.\"),\n+        (\"10000000000000000000.0\", \"-1000000000000000000.0\"),\n+        (\"-1000000000000000000.00\", \"1000000000000000000.00\"),\n+        (\"-100000000000000000.000\", \"-1000000000000000000.000\"),\n+        (\"10.000000000000000000000000000000000000\", \"10.000000000000000000000000000000000000\"),\n+        (\"5678901234567890.12345678901234\", \"-5678901234567890.12345678901234\"),\n+      )\n+\n+      multiply(\"10000000000000000000.\", \"1000000000000000000.\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        multiply(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"add two numeric properly\" in {"
  },
  {
    "id" : "47275459-ca21-4604-b056-041654e3b128",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "9aefd310-a60a-4959-941b-e891b276e7e6",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    \"divide two numeric properly\" in {\r\n```",
        "createdAt" : "2019-08-15T11:59:02Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,480 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+\n+import org.scalatest\n+\n+import scala.language.implicitConversions\n+import scala.math.{BigDecimal => BigDec}\n+import scala.util.Random\n+\n+class NumericSpec\n+    extends scalatest.WordSpec\n+    with scalatest.Matchers\n+    with scalatest.prop.TableDrivenPropertyChecks {\n+\n+  \"fromBigDecimal\" should {\n+    implicit def toBigDecimal(s: String): BigDecimal =\n+      new BigDecimal(s)\n+\n+    \"succeed for valid inputs\" in {\n+\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"99999999999999999999999999999999999999.\"),\n+        (0, \"-1.\"),\n+        (0, \"-99999999999999999999999999999999999999.\"),\n+        (5, \"1.00000\"),\n+        (7, \"0.\"),\n+        (10, \"9999999999999999999999999999.9999999999\"),\n+        (37, \"0.0000000000000000000000000000000000001\"),\n+        (38, \"0.99999999999999999999999999999999999999\"),\n+        (38, \"0.00000000000000000000016180339887499677\"),\n+        (38, \"-0.99999999999999999999999999999999999999\")\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe Right(bigDec.setScale(scale))\n+      }\n+    }\n+\n+    \"fail on too Large inputs\" in {\n+      val testCases = Table[Int, BigDecimal](\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"100000000000000000000000000000000000000.\"),\n+        (0, \"-100000000000000000000000000000000000000.\"),\n+        (17, \"10000000000000000000000.0000000000000000\"),\n+        (3, \"8284590452353602874713526624977572470.\"),\n+        (38, \"1.00000000000000000000000000000000000000\"),\n+        (38, \"-1.00000000000000000000000000000000000001\"),\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe 'left\n+      }\n+    }\n+\n+    \"fail on too Precise inputs\" in {\n+      val testCases = Table(\n+        (\"scale\", \"bigDecimal\"),\n+        (0, \"0.1\"),\n+        (0, \"-0.1\"),\n+        (17, \"10000000000000000.000000000000000001\"),\n+        (3, \"0.82845\"),\n+        (38, \"0.000000000000000000000000000000000000000\"),\n+        (38, \"-0.000000000000000000000000000000000000001\"),\n+      )\n+\n+      forEvery(testCases) { (scale, bigDec) =>\n+        Numeric.fromBigDecimal(scale, bigDec) shouldBe 'left\n+      }\n+    }\n+  }\n+\n+  \"Numeric.add\" should {\n+\n+    import Numeric.add\n+    implicit def toNumeric(s: String): Numeric = Numeric.assertFromString(s)\n+\n+    \"throw an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"99999999999999999999999999999999999999.\", \"1.\"),\n+        (\"-1.\", \"-99999999999999999999999999999999999999.\"),\n+        (\"0.99999999999999999999999999999999999999\", \"0.00000000000000000000000000000000000001\"),\n+        (\"-0.99999999999999999999999999999999999999\", \"-0.00000000000000000000000000000000000001\"),\n+        (\"9999999999999999999999.0000000000000000\", \"1.0000000000000000\"),\n+        (\"5678901234567890.1234567890123456789012\", \"5678901234567890.1234567890123456789012\")\n+      )\n+\n+      add(\"1.0\", \"1.0\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        add(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"add two numerics properly\" in {\n+      val testCases = Table[Numeric, Numeric, Numeric](\n+        (\"numeric\", \"numeric\", \"result\"),\n+        (\"0.00000\", \"0.00000\", \"0.00000\"),\n+        (\n+          \"0.99999999999999999999999999999999999999\",\n+          \"-0.00000000000000000000000000000000000001\",\n+          \"0.99999999999999999999999999999999999998\"),\n+        (\n+          \"3.1415926535897932384626433832795028842\",\n+          \"2.7182818284590452353602874713526624978\",\n+          \"5.8598744820488384738229308546321653820\"\n+        ),\n+        (\n+          \"161803398.8749900000\",\n+          \"-161803398.8749900000\",\n+          \"0.0000000000\"\n+        ),\n+        (\n+          \"55555555555555555555555555555555555555.\",\n+          \"44444444444444444444444444444444444444.\",\n+          \"99999999999999999999999999999999999999.\"\n+        )\n+      )\n+\n+      forEvery(testCases) { (x, y, z) =>\n+        add(x, y) shouldBe Right(z)\n+      }\n+\n+    }\n+  }\n+\n+  \"Numeric.subtract\" should {\n+    import Numeric.subtract\n+    implicit def toNumeric(s: String): Numeric =\n+      Numeric.assertFromString(s)\n+\n+    \"throw an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"-99999999999999999999999999999999999999.\", \"1.\"),\n+        (\"-1.\", \"99999999999999999999999999999999999999.\"),\n+        (\"0.99999999999999999999999999999999999999\", \"-0.00000000000000000000000000000000000001\"),\n+        (\"0.99999999999999999999999999999999999999\", \"-0.00000000000000000000000000000000000001\"),\n+        (\"9999999999999999999999.0000000000000000\", \"-1.0000000000000000\"),\n+        (\"567890123456789012345.67890123456789012\", \"-567890123456789012345.67890123456789012\")\n+      )\n+\n+      subtract(\"1.0\", \"1.0\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        subtract(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"subtract two numerics properly\" in {\n+      val testCases = Table[Numeric, Numeric, Numeric](\n+        (\"numeric\", \"numeric\", \"result\"),\n+        (\"0.00000\", \"0.00000\", \"0.00000\"),\n+        (\n+          \"0.99999999999999999999999999999999999999\",\n+          \"0.00000000000000000000000000000000000001\",\n+          \"0.99999999999999999999999999999999999998\"),\n+        (\n+          \"3.1415926535897932384626433832795028842\",\n+          \"2.7182818284590452353602874713526624978\",\n+          \"0.4233108251307480031023559119268403864\"\n+        ),\n+        (\n+          \"161803398.8749900000\",\n+          \"161803398.8749900000\",\n+          \"0.0000000000\"\n+        ),\n+        (\n+          \"55555555555555555555555555555555555555.\",\n+          \"44444444444444444444444444444444444444.\",\n+          \"11111111111111111111111111111111111111.\"\n+        )\n+      )\n+\n+      forEvery(testCases) { (x, y, z) =>\n+        subtract(x, y) shouldBe Right(z)\n+      }\n+\n+    }\n+  }\n+\n+  \"Numeric.multiply\" should {\n+    import Numeric.multiply\n+\n+    implicit def toNumeric(s: String): Numeric =\n+      Numeric.assertFromString(s)\n+\n+    \"throws an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"10000000000000000000.\", \"10000000000000000000.\"),\n+        (\"10000000000000000000.0\", \"-1000000000000000000.0\"),\n+        (\"-1000000000000000000.00\", \"1000000000000000000.00\"),\n+        (\"-100000000000000000.000\", \"-1000000000000000000.000\"),\n+        (\"10.000000000000000000000000000000000000\", \"10.000000000000000000000000000000000000\"),\n+        (\"5678901234567890.12345678901234\", \"-5678901234567890.12345678901234\"),\n+      )\n+\n+      multiply(\"10000000000000000000.\", \"1000000000000000000.\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        multiply(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"add two numeric properly\" in {\n+      val testCases = Table[Numeric, Numeric, Numeric](\n+        (\"numeric\", \"numeric\", \"result\"),\n+        (\"0.00000\", \"0.00000\", \"0.00000\"),\n+        (\n+          \"0.00000000000000000010000000000000000000\",\n+          \"0.00000000000000000010000000000000000000\",\n+          \"0.00000000000000000000000000000000000001\"\n+        ),\n+        (\n+          \"1.0000000000000000000000000000000000000\",\n+          \"-0.0000000000000000000000000000000000001\",\n+          \"-0.0000000000000000000000000000000000001\"\n+        ),\n+        (\n+          \"-1000000000000000000.000000000000000000\",\n+          \"0.000000000000000001\",\n+          \"-1.000000000000000000\"\n+        ),\n+        (\n+          \"3.1415926535897932384626433832795028842\",\n+          \"2.7182818284590452353602874713526624978\",\n+          \"8.5397342226735670654635508695465744952\"\n+        ),\n+        (\n+          \"0.5\",\n+          \"0.1\",\n+          \"0.0\",\n+        ),\n+        (\n+          \"0.15\",\n+          \"0.10\",\n+          \"0.02\",\n+        ),\n+        (\n+          \"1.006\",\n+          \"0.100\",\n+          \"0.101\"\n+        ),\n+        (\n+          \"2.1003\",\n+          \"0.1000\",\n+          \"0.2100\"\n+        ),\n+        (\n+          \"5555555555555555555.\",\n+          \"4444444444444444444.\",\n+          \"24691358024691358019753086419753086420.\"\n+        )\n+      )\n+\n+      forEvery(testCases) { (x, y, z) =>\n+        multiply(x, y) shouldBe Right(z)\n+      }\n+\n+    }\n+  }\n+\n+  \"Numeric.divide\" should {\n+    import Numeric.divide\n+\n+    implicit def toNumeric(s: String): Numeric = Numeric.assertFromString(s)\n+\n+    \"throws an exception in case of overflow\" in {\n+      val testCases = Table[Numeric, Numeric](\n+        (\"numeric\", \"numeric\"),\n+        (\"1000000000000000000.0000000000\", \"0.0000000001\"),\n+        (\"-1000000000000000000000000000000000000.0\", \"0.1\"),\n+        (\n+          \"0.10000000000000000000000000000000000000\",\n+          \"-0.10000000000000000000000000000000000000\",\n+        ),\n+        (\"5678901234567890.12345678901234\", \"-0.00000000001234\"),\n+      )\n+\n+      divide(\"100000000000000000.0000000000\", \"0.0000000001\") shouldBe 'right\n+\n+      forEvery(testCases) { (x, y) =>\n+        divide(x, y) shouldBe 'left\n+      }\n+    }\n+\n+    \"add two numeric properly\" in {"
  }
]