[
  {
    "id" : "2953841a-b0fb-44b3-a794-66601116543b",
    "prId" : 2958,
    "comments" : [
      {
        "id" : "82a1f8de-06fe-4ede-98a7-d6fdc7b554db",
        "parentId" : null,
        "author" : null,
        "body" : "As discussed, max scale should be 37\r\n\r\n```suggestion\r\n   val maxPrecision = 37\r\n```",
        "createdAt" : "2019-09-18T15:12:50Z",
        "updatedAt" : "2019-09-18T19:06:09Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      },
      {
        "id" : "bb2ee8a5-a422-43d0-afb3-8a329861337f",
        "parentId" : "82a1f8de-06fe-4ede-98a7-d6fdc7b554db",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "`maxPrecision` will remain 38.\r\nI will change the  maximun scale (line 41) in a subsequent PR.  ",
        "createdAt" : "2019-09-18T15:26:24Z",
        "updatedAt" : "2019-09-18T19:06:09Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "f3caa683-3f55-47d3-9c1e-756cf79c9c5a",
        "parentId" : "82a1f8de-06fe-4ede-98a7-d6fdc7b554db",
        "author" : null,
        "body" : "^ ah, I misunderstood. Yes, that's right.",
        "createdAt" : "2019-09-18T15:30:12Z",
        "updatedAt" : "2019-09-18T19:06:09Z",
        "lastEditedBy" : null,
        "tags" : [
        ]
      }
    ],
    "commit" : "f4ae120994218a9914934213c98fd0913dde1067",
    "line" : 2,
    "diffHunk" : "@@ -35,6 +35,15 @@ abstract class NumericModule {\n     */\n   val maxPrecision = 38"
  },
  {
    "id" : "edd2fbac-2cde-43f4-b948-3cf85de02f2e",
    "prId" : 2958,
    "comments" : [
      {
        "id" : "1bf1eeb1-2839-4e26-90ab-657ea21e7540",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    * Use this function to convert BigDecimal with unknown scale.\r\n```",
        "createdAt" : "2019-09-18T16:09:09Z",
        "updatedAt" : "2019-09-18T19:06:09Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f4ae120994218a9914934213c98fd0913dde1067",
    "line" : null,
    "diffHunk" : "@@ -242,10 +250,11 @@ abstract class NumericModule {\n     *\n     * With use this function to convert BigDecimal with unknown scale."
  },
  {
    "id" : "0fcc464c-94ab-4c58-99fe-5f6619a956a9",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "5099b611-d3d1-4161-a246-56c157b5c03b",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    * Multiplies `x` by `y`. The output has the same scale as the inputs. If rounding must be\r\n```",
        "createdAt" : "2019-08-15T11:39:13Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "90570c9e-5764-469e-8ecf-53f7516492d9",
        "parentId" : "5099b611-d3d1-4161-a246-56c157b5c03b",
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "and others.",
        "createdAt" : "2019-08-15T11:39:26Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be"
  },
  {
    "id" : "0eee21bf-3ba5-4d02-b406-b5c5d65d1b9b",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "b0c38d68-4c61-458c-9e5b-03d5f428c688",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    * In case the result does not fit into a long, returns an error message instead.\r\n```",
        "createdAt" : "2019-08-15T11:40:18Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead."
  },
  {
    "id" : "5ffd5b1f-403f-45cf-9887-c1accb09cd2e",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "36295ac7-eee3-4c07-90d9-e32b90d94b71",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Add test.",
        "createdAt" : "2019-08-15T11:40:36Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : 101,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] ="
  },
  {
    "id" : "e87adc68-e766-41e6-b7e4-6708158a98eb",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "883e45f5-d4a5-4d1d-accb-b355bf5ca4a5",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "Rename to `targetScale`.",
        "createdAt" : "2019-08-15T11:41:50Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] ="
  },
  {
    "id" : "7e991a7e-1e03-4a24-b8eb-ce0c09041046",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "a0e446c6-492f-454f-9442-874c50f019a2",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    * The output has the same scale as the input.\r\n```",
        "createdAt" : "2019-08-15T11:42:13Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs."
  },
  {
    "id" : "a17c8ac4-9735-41a5-b4f3-bea67f3c033d",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "380a08fa-048e-463a-975f-e738e723535b",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    * In case scale is not a valid Numeric scale or `x` cannot be represented as a\r\n```",
        "createdAt" : "2019-08-15T11:43:30Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a"
  },
  {
    "id" : "86fbfb8c-9f4e-4bb4-8b0d-df9a1f815177",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "63a48a7a-a9ba-4f8e-81e2-46b45406ee56",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    * `(Numeric scale)` without loss of precision, returns an error message instead.\r\n```",
        "createdAt" : "2019-08-15T11:43:46Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead."
  },
  {
    "id" : "42b7400e-9222-4023-b419-97bde2398e00",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "9684271a-91e9-40c3-bdb1-b7499beff6c6",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n    * Like `fromBigDecimal(Int, BigDecimal)` but with a scala BigDecimal.\r\n```",
        "createdAt" : "2019-08-15T11:45:04Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal."
  },
  {
    "id" : "ce42347d-8db4-41d8-b67f-73f5be8d7396",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "278d9e4d-0087-4aac-a820-6b1bd79d78ab",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n   * - The integral part of `x` without leading '0' if the integral part of `x` is not equal to 0, \"0\" otherwise.\r\n```",
        "createdAt" : "2019-08-15T11:46:29Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDec): Either[String, Numeric] =\n+    fromBigDecimal(scale, x.bigDecimal)\n+\n+  /**\n+    * Like `fromBigDecimal` but throws an exception instead of returning e message in case of error.\n+    */\n+  @throws[IllegalArgumentException]\n+  final def assertFromBigDecimal(scale: Int, x: BigDec): Numeric =\n+    assertRight(fromBigDecimal(scale, x))\n+\n+  private val validFormat = \"\"\"-?([1-9]\\d*|0).(\\d*)\"\"\".r\n+\n+  /*\n+   * Returns a canonical decimal string representation of `x`. The output string consists of (in\n+   * left-to-right order):\n+   * - An optional negative sign (\"-\") to indicate if `x` is strictly negative.\n+   * - The integral part of `x` if `x` without leading '0' if 'x' is not null, \"0\" otherwise."
  },
  {
    "id" : "b5450dc6-d34b-48fd-ad94-5e35418c069c",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "20116b00-158f-4d60-b481-8adbfd177729",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n   * - the decimal point (\".\") to separate the integral part from the decimal part,\r\n```",
        "createdAt" : "2019-08-15T11:48:16Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDec): Either[String, Numeric] =\n+    fromBigDecimal(scale, x.bigDecimal)\n+\n+  /**\n+    * Like `fromBigDecimal` but throws an exception instead of returning e message in case of error.\n+    */\n+  @throws[IllegalArgumentException]\n+  final def assertFromBigDecimal(scale: Int, x: BigDec): Numeric =\n+    assertRight(fromBigDecimal(scale, x))\n+\n+  private val validFormat = \"\"\"-?([1-9]\\d*|0).(\\d*)\"\"\".r\n+\n+  /*\n+   * Returns a canonical decimal string representation of `x`. The output string consists of (in\n+   * left-to-right order):\n+   * - An optional negative sign (\"-\") to indicate if `x` is strictly negative.\n+   * - The integral part of `x` if `x` without leading '0' if 'x' is not null, \"0\" otherwise.\n+   * - the decimal point (\".\") to separated the integral part from the decimal part,"
  },
  {
    "id" : "394b84f7-a578-4ba4-ac57-359271b0aed7",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "d0c20402-16c0-4868-a249-7de949fd7fa8",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n   * - the decimal part of `x` with '0' padded to match the scale. The number of decimal digits must be the same as the scale.\r\n```",
        "createdAt" : "2019-08-15T11:50:14Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDec): Either[String, Numeric] =\n+    fromBigDecimal(scale, x.bigDecimal)\n+\n+  /**\n+    * Like `fromBigDecimal` but throws an exception instead of returning e message in case of error.\n+    */\n+  @throws[IllegalArgumentException]\n+  final def assertFromBigDecimal(scale: Int, x: BigDec): Numeric =\n+    assertRight(fromBigDecimal(scale, x))\n+\n+  private val validFormat = \"\"\"-?([1-9]\\d*|0).(\\d*)\"\"\".r\n+\n+  /*\n+   * Returns a canonical decimal string representation of `x`. The output string consists of (in\n+   * left-to-right order):\n+   * - An optional negative sign (\"-\") to indicate if `x` is strictly negative.\n+   * - The integral part of `x` if `x` without leading '0' if 'x' is not null, \"0\" otherwise.\n+   * - the decimal point (\".\") to separated the integral part from the decimal part,\n+   * - the decimal part of `x` with possibly trailing '0', the number of digits indicating the scale"
  },
  {
    "id" : "56c7a0ba-f694-48f4-9d79-5687e7cd628e",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "5a4a2acf-4a1d-47e1-a1ac-32a8a9d6dfc0",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n```",
        "createdAt" : "2019-08-15T11:50:32Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDec): Either[String, Numeric] =\n+    fromBigDecimal(scale, x.bigDecimal)\n+\n+  /**\n+    * Like `fromBigDecimal` but throws an exception instead of returning e message in case of error.\n+    */\n+  @throws[IllegalArgumentException]\n+  final def assertFromBigDecimal(scale: Int, x: BigDec): Numeric =\n+    assertRight(fromBigDecimal(scale, x))\n+\n+  private val validFormat = \"\"\"-?([1-9]\\d*|0).(\\d*)\"\"\".r\n+\n+  /*\n+   * Returns a canonical decimal string representation of `x`. The output string consists of (in\n+   * left-to-right order):\n+   * - An optional negative sign (\"-\") to indicate if `x` is strictly negative.\n+   * - The integral part of `x` if `x` without leading '0' if 'x' is not null, \"0\" otherwise.\n+   * - the decimal point (\".\") to separated the integral part from the decimal part,\n+   * - the decimal part of `x` with possibly trailing '0', the number of digits indicating the scale\n+   * of `x`."
  },
  {
    "id" : "294d9e86-e11d-49c4-97ff-14268453d6ef",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "ddeb9318-1a8d-43e9-8e6a-0ab8b23dde92",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n   * Given a string representation of a decimal returns the corresponding Numeric, where the number of\r\n```",
        "createdAt" : "2019-08-15T11:51:07Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDec): Either[String, Numeric] =\n+    fromBigDecimal(scale, x.bigDecimal)\n+\n+  /**\n+    * Like `fromBigDecimal` but throws an exception instead of returning e message in case of error.\n+    */\n+  @throws[IllegalArgumentException]\n+  final def assertFromBigDecimal(scale: Int, x: BigDec): Numeric =\n+    assertRight(fromBigDecimal(scale, x))\n+\n+  private val validFormat = \"\"\"-?([1-9]\\d*|0).(\\d*)\"\"\".r\n+\n+  /*\n+   * Returns a canonical decimal string representation of `x`. The output string consists of (in\n+   * left-to-right order):\n+   * - An optional negative sign (\"-\") to indicate if `x` is strictly negative.\n+   * - The integral part of `x` if `x` without leading '0' if 'x' is not null, \"0\" otherwise.\n+   * - the decimal point (\".\") to separated the integral part from the decimal part,\n+   * - the decimal part of `x` with possibly trailing '0', the number of digits indicating the scale\n+   * of `x`.\n+   */\n+  final def toString(x: Numeric): String = {\n+    val s = x.toPlainString\n+    if (x.scale == 0) s + \".\" else s\n+  }\n+\n+  /*\n+   * Given a string representation of a decimal returns the correspond Numeric, where the number of"
  },
  {
    "id" : "59e5cc02-dc9e-4ef5-872f-c004335c6aa1",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "45c83221-019e-41b6-92e7-5ca9db00b3d1",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n   * digits to the right of the decimal point indicates the scale.\r\n```",
        "createdAt" : "2019-08-15T11:51:22Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDec): Either[String, Numeric] =\n+    fromBigDecimal(scale, x.bigDecimal)\n+\n+  /**\n+    * Like `fromBigDecimal` but throws an exception instead of returning e message in case of error.\n+    */\n+  @throws[IllegalArgumentException]\n+  final def assertFromBigDecimal(scale: Int, x: BigDec): Numeric =\n+    assertRight(fromBigDecimal(scale, x))\n+\n+  private val validFormat = \"\"\"-?([1-9]\\d*|0).(\\d*)\"\"\".r\n+\n+  /*\n+   * Returns a canonical decimal string representation of `x`. The output string consists of (in\n+   * left-to-right order):\n+   * - An optional negative sign (\"-\") to indicate if `x` is strictly negative.\n+   * - The integral part of `x` if `x` without leading '0' if 'x' is not null, \"0\" otherwise.\n+   * - the decimal point (\".\") to separated the integral part from the decimal part,\n+   * - the decimal part of `x` with possibly trailing '0', the number of digits indicating the scale\n+   * of `x`.\n+   */\n+  final def toString(x: Numeric): String = {\n+    val s = x.toPlainString\n+    if (x.scale == 0) s + \".\" else s\n+  }\n+\n+  /*\n+   * Given a string representation of a decimal returns the correspond Numeric, where the number of\n+   * digit to the right of te decimal point indicates the scale."
  },
  {
    "id" : "2076def9-9677-4111-8bb9-2107488128d8",
    "prId" : 2556,
    "comments" : [
      {
        "id" : "a48cba05-cc9a-4400-aee3-81c34b1d3e51",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n   * or if the result of the conversion cannot be mapped into a numeric without loss of precision\r\n```",
        "createdAt" : "2019-08-15T11:52:55Z",
        "updatedAt" : "2019-08-15T12:55:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "345fe4def2e17284c6baa0861466c188242ef708",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import java.math.BigDecimal\n+import scala.math.{BigDecimal => BigDec}\n+import BigDecimal.{ROUND_DOWN, ROUND_HALF_EVEN, ROUND_UNNECESSARY}\n+\n+import scala.util.Try\n+\n+abstract class NumericModule {\n+\n+  /**\n+    * Type `Numeric` represents fixed scale BigDecimals, aka Numerics. Scale of\n+    * Numerics can be between `0` and `maxPrecision` (bounds included). For\n+    * any valid scale `s` we denote `(Numeric s)` the set of Numerics of\n+    * scale `s`. Numerics are encoded using java BigDecimal, where the scale\n+    * is the scale of the Numeric.\n+    */\n+  type Numeric <: BigDecimal\n+\n+  /**\n+    * Maximum usable precision for Numerics\n+    */\n+  val maxPrecision = 38\n+\n+  /**\n+    * Cast the BigDecimal `x` to a `(Numeric s)` where `s` is the scale of `x`.\n+    */\n+  @inline\n+  private[data] def cast(x: BigDecimal): Numeric\n+\n+  /**\n+    * Casts `x` to a Numeric if it has a valid precision (<= `maxPrecision`). Returns an error\n+    * message otherwise\n+    *\n+    * ```Assumes the scale of `x` is a valid Numeric scale```\n+    */\n+  private[data] def checkForOverflow(x: BigDecimal): Either[String, Numeric] =\n+    Either.cond(\n+      x.precision() <= maxPrecision,\n+      cast(x),\n+      s\"Out-of-bounds (Numeric ${x.scale}) $x\"\n+    )\n+\n+  /**\n+    * Adds the two Numerics. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def add(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x add y)\n+  }\n+\n+  /**\n+    * Subtracts `y` to `x`. The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def subtract(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x subtract y)\n+  }\n+\n+  /**\n+    * Multiplies `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def multiply(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow((x multiply y).setScale(x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Divides `x` by `y`. The output has the same scale than the inputs. If rounding must be\n+    * performed, the [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]]\n+    * is applied.\n+    * In case of overflow, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def divide(x: Numeric, y: Numeric): Either[String, Numeric] = {\n+    assert(x.scale == y.scale)\n+    checkForOverflow(x.divide(y, x.scale(), ROUND_HALF_EVEN))\n+  }\n+\n+  /**\n+    * Returns the integral part of the given decimal, in other words, rounds towards 0.\n+    * In case of the result does not fit a lonf, returns an error message instead.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def toLong(x: Numeric): Either[String, Long] =\n+    Try(x.setScale(0, ROUND_DOWN).longValueExact()).toEither.left.map(\n+      _ => s\"(Numeric ${x.scale()}) $x does not fit into an Int64\",\n+    )\n+\n+  /**\n+    * Rounds the `x` to the closest multiple of ``10⁻ˢᶜᵃˡᵉ`` using the\n+    * [[https://en.wikipedia.org/wiki/Rounding#Round_half_to_even> banker's rounding convention]].\n+    * The output has the same scale than the inputs.\n+    * In case of overflow, returns an error message instead.\n+    */\n+  final def round(newScale: Long, x: Numeric): Either[String, Numeric] =\n+    if (newScale <= x.scale && x.scale - maxPrecision < newScale)\n+      checkForOverflow(x.setScale(newScale.toInt, ROUND_HALF_EVEN).setScale(x.scale))\n+    else\n+      Left(s\"Bad scale $newScale, must be between ${x.scale - maxPrecision - 1} and ${x.scale}\")\n+\n+  /**\n+    * Returns -1, 0, or 1 as `x` is numerically less than, equal to, or greater than `y`.\n+    *\n+    * ```Requires the scale of `x` and `y` are the same.```\n+    */\n+  final def compare(x: Numeric, y: Numeric): Int = {\n+    assert(x.scale == y.scale)\n+    x compareTo y\n+  }\n+\n+  /**\n+    * Converts the java BigDecimal `x` to a `(Numeric scale)``.\n+    * In case scale is a not a valid Numeric scale or `x` cannot be represented as a\n+    * `(Numeric scale)` without or loss of precision, returns an error message instead.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDecimal): Either[String, Numeric] =\n+    if (!(0 <= scale && scale <= maxPrecision))\n+      Left(s\"Bad scale $scale, must be between 0 and $maxPrecision\")\n+    else if (!(x.scale() <= scale))\n+      Left(s\"Cannot represent $x as (Numeric $scale) without lost of precision\")\n+    else\n+      checkForOverflow(x.setScale(scale, ROUND_UNNECESSARY))\n+\n+  /**\n+    * Like `fromBigDec` but with a scala BigDecimal.\n+    */\n+  final def fromBigDecimal(scale: Int, x: BigDec): Either[String, Numeric] =\n+    fromBigDecimal(scale, x.bigDecimal)\n+\n+  /**\n+    * Like `fromBigDecimal` but throws an exception instead of returning e message in case of error.\n+    */\n+  @throws[IllegalArgumentException]\n+  final def assertFromBigDecimal(scale: Int, x: BigDec): Numeric =\n+    assertRight(fromBigDecimal(scale, x))\n+\n+  private val validFormat = \"\"\"-?([1-9]\\d*|0).(\\d*)\"\"\".r\n+\n+  /*\n+   * Returns a canonical decimal string representation of `x`. The output string consists of (in\n+   * left-to-right order):\n+   * - An optional negative sign (\"-\") to indicate if `x` is strictly negative.\n+   * - The integral part of `x` if `x` without leading '0' if 'x' is not null, \"0\" otherwise.\n+   * - the decimal point (\".\") to separated the integral part from the decimal part,\n+   * - the decimal part of `x` with possibly trailing '0', the number of digits indicating the scale\n+   * of `x`.\n+   */\n+  final def toString(x: Numeric): String = {\n+    val s = x.toPlainString\n+    if (x.scale == 0) s + \".\" else s\n+  }\n+\n+  /*\n+   * Given a string representation of a decimal returns the correspond Numeric, where the number of\n+   * digit to the right of te decimal point indicates the scale.\n+   * If the input does not match\n+   *   `-?([1-9]\\d*|0).(\\d*)`\n+   * or if the result of the conversion cannot be mapped into a numerics without loss of precision"
  }
]