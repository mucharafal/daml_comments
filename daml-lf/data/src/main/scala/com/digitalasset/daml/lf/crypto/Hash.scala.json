[
  {
    "id" : "a2c5a61b-0f16-4bce-ba33-2bcab132b3fe",
    "prId" : 3849,
    "comments" : [
      {
        "id" : "69f5837c-8c52-4d6d-9ed7-0a79d651061f",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "I'd add an algorithm identifier just in case we need to migrate to another hash algorithm.",
        "createdAt" : "2020-01-14T10:50:15Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1c72148d-bb59-4b94-a6c4-10f6181a5b90",
        "parentId" : "69f5837c-8c52-4d6d-9ed7-0a79d651061f",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I am a bit reluctant to add extra information for versioning here. \r\nWe have currently in mind, three use case in daml repo\r\n1 - create the contract discriminator\r\n2 - create the transaction id \r\n3 - create contract key hash. \r\n\r\nFor 1 and 2 leave in the transaction which is already versioned. The transaction will potentially contain a lot of hashed with the same version. \r\n3 will  be used to index contract key in kv util, I am not sure the version gives you anything there. \r\n",
        "createdAt" : "2020-01-14T14:38:45Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ac24b74f-49bc-4c50-a668-d1d0ef14f68b",
        "parentId" : "69f5837c-8c52-4d6d-9ed7-0a79d651061f",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "If we follow your approach, we would also need a version for the way values and other complex structures are traversed. Once again this is subsumes by the transaction version.",
        "createdAt" : "2020-01-14T14:48:07Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "942b7996-a276-4121-9d6a-84287a2d816f",
        "parentId" : "69f5837c-8c52-4d6d-9ed7-0a79d651061f",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Fair enough",
        "createdAt" : "2020-01-14T17:10:17Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "234101313181b0ea39c66a646366bd28d3d2adfd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.crypto\n+\n+import java.nio.ByteBuffer\n+import java.security.MessageDigest\n+import java.util\n+\n+import com.digitalasset.daml.lf.data.{Ref, Utf8}\n+\n+class Hash private (private val bytes: Array[Byte]) {"
  },
  {
    "id" : "4da8e078-dd12-482e-89f2-d0e79b4f7694",
    "prId" : 3849,
    "comments" : [
      {
        "id" : "415c484c-84da-40b3-b468-81eda87bffdf",
        "parentId" : null,
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "This needs documentation on how to use safely. Something like:\r\n\r\n1. a new, globally unique hash purpose must be defined for each type `T` for whose values we want to compute hashes for\r\n2. if `T` is a sum type, it must define, for each variant `V`, a tag that is unique to `V` in the scope of `T` (i.e.,, variant tags may be reused across `T`s), such that (complete the strategy)...\r\n",
        "createdAt" : "2020-01-14T11:06:00Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e284aeed-2327-4623-acc5-ea0947228bc8",
        "parentId" : "415c484c-84da-40b3-b468-81eda87bffdf",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "added. ",
        "createdAt" : "2020-01-14T14:46:02Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "28d4e627-fe96-44bb-bafa-f0322e40b949",
        "parentId" : "415c484c-84da-40b3-b468-81eda87bffdf",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "Well, you didn't complete the strategy :) I wasn't entirely sure how to describe the strategy that you applied.",
        "createdAt" : "2020-01-14T16:50:05Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "ec1fc9f9-345a-49c7-823c-a7e8f55a6d9c",
        "parentId" : "415c484c-84da-40b3-b468-81eda87bffdf",
        "author" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "body" : "(or rather than the strategy, we'd want to have the properties that the usage must fulfill)",
        "createdAt" : "2020-01-14T16:56:48Z",
        "updatedAt" : "2020-01-16T15:17:17Z",
        "lastEditedBy" : {
          "login" : "oggy-",
          "name" : "Ognjen Maric",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/325151?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "234101313181b0ea39c66a646366bd28d3d2adfd",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,108 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.crypto\n+\n+import java.nio.ByteBuffer\n+import java.security.MessageDigest\n+import java.util\n+\n+import com.digitalasset.daml.lf.data.{Ref, Utf8}\n+\n+class Hash private (private val bytes: Array[Byte]) {\n+\n+  def toByteArray: Array[Byte] = bytes.clone()\n+\n+  def toHexa: Ref.LedgerString =\n+    Ref.LedgerString.assertFromString(bytes.map(\"%02x\" format _).mkString)\n+\n+  override def toString: String = s\"Hash($toHexa)\"\n+\n+  override def equals(other: Any): Boolean =\n+    other match {\n+      case otherHash: Hash => util.Arrays.equals(bytes, otherHash.bytes)\n+      case _ => false\n+    }\n+\n+  private var _hashCode: Int = 0\n+\n+  override def hashCode(): Int = {\n+    if (_hashCode == 0) {\n+      val code = util.Arrays.hashCode(bytes)\n+      _hashCode = if (code == 0) 1 else code\n+    }\n+    _hashCode\n+  }\n+\n+}\n+\n+object Hash {\n+\n+  sealed abstract class Builder private[Hash] {\n+\n+    protected def update(a: Array[Byte]): Unit\n+\n+    protected def update(a: ByteBuffer): Unit\n+\n+    protected def update(a: Byte): Unit\n+\n+    final def add(a: Array[Byte]): Builder = {\n+      update(a)\n+      this\n+    }\n+\n+    final def add(a: ByteBuffer): Builder = {\n+      update(a)\n+      this\n+    }\n+\n+    final def add(a: Byte): Builder = {\n+      update(a)\n+      this\n+    }\n+\n+    final def add(a: Hash): Builder =\n+      add(a.bytes)\n+\n+    final def add(s: String): Builder = {\n+      val a = Utf8.getBytes(s)\n+      add(a.length).add(a)\n+    }\n+\n+    private val intBuffer = ByteBuffer.allocate(java.lang.Integer.BYTES)\n+\n+    def add(a: Int): Builder = {\n+      intBuffer.rewind()\n+      add(intBuffer.putInt(a).array())\n+    }\n+\n+    private val longBuffer = ByteBuffer.allocate(java.lang.Long.BYTES)\n+\n+    def add(a: Long): Builder = {\n+      longBuffer.rewind()\n+      add(longBuffer.putLong(a).array())\n+    }\n+\n+    def iterateOver[T](i: Iterator[T], length: Int)(f: (Builder, T) => Builder): Builder =\n+      i.foldLeft(add(length))(f)\n+\n+    def build: Hash\n+  }\n+\n+  def builder(purpose: HashPurpose): Builder = new Builder {"
  }
]