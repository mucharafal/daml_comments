[
  {
    "id" : "f055a320-a6a4-4717-94e4-0347f67e4241",
    "prId" : 5855,
    "comments" : [
      {
        "id" : "145f54c3-396f-4366-b98e-9370ca73881c",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "This adds no value, in fact it contradicts the intended meaning of the interface. IntelliJ is full of it when it comes to these \"warnings\".",
        "createdAt" : "2020-05-05T21:13:58Z",
        "updatedAt" : "2020-05-05T23:18:28Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "4fe248085f1dc8b8e4d1de526aadd59646fce074",
    "line" : null,
    "diffHunk" : "@@ -257,16 +262,16 @@ private[data] final class IdStringImpl extends IdString {\n   // We allow space because the navigator's applicationId used it.\n   override type LedgerString = String\n   override val LedgerString: ConcatenableStringModule[LedgerString, HexString] =\n-    new ConcatenableMatchingStringModule(\"._:-#/ \".contains(_), 255)\n+    new ConcatenableMatchingStringModule(\"DAML LF Ledger String\", \"._:-#/ \".contains(_), 255)\n \n   override type ParticipantId = String\n-  override val ParticipantId = LedgerString\n+  override val ParticipantId: LedgerString.type = LedgerString"
  },
  {
    "id" : "ab177396-575c-45c9-86b8-6beab92c6315",
    "prId" : 4952,
    "comments" : [
      {
        "id" : "94bf074e-8ba5-42cf-89b0-b017f2e34834",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "I think \"Hexadecimal\" is usually abbreviated with just \"Hex\".",
        "createdAt" : "2020-03-12T12:46:15Z",
        "updatedAt" : "2020-03-12T20:04:15Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "81f0de47-8a93-436a-b79c-e1446c425c80",
        "parentId" : "94bf074e-8ba5-42cf-89b0-b017f2e34834",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "change to `HexString`",
        "createdAt" : "2020-03-12T14:33:05Z",
        "updatedAt" : "2020-03-12T20:04:15Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "b1086ca624e78370d46ca8b5487d7254007696b3",
    "line" : null,
    "diffHunk" : "@@ -25,6 +26,14 @@ sealed trait StringModule[T] {\n   def toStringMap[V](map: Map[T, V]): Map[String, V]\n }\n \n+sealed trait HexaStringModule[T <: String] extends StringModule[T] {"
  },
  {
    "id" : "360dfb98-1a2c-4700-beb5-845c2306208c",
    "prId" : 4221,
    "comments" : [
      {
        "id" : "9507ab3f-6995-45b8-9c00-5c979305e04d",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "One can clearly see the source of inspiration for the type parameter names ;)\r\nBut I'd go for `TA` and `TB` (or `U` and `V`) instead of `TV0` and `TV1` respectively.",
        "createdAt" : "2020-01-31T15:12:15Z",
        "updatedAt" : "2020-02-03T21:56:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1535fe7a-cf64-4b72-b56c-de1cf490672c",
        "parentId" : "9507ab3f-6995-45b8-9c00-5c979305e04d",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2020-02-03T10:42:37Z",
        "updatedAt" : "2020-02-03T21:56:31Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "9233a4097ca730ce5db7e0b07a328048ff91a0cc",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,257 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+package com.digitalasset.daml.lf.data\n+\n+import scalaz.Equal\n+\n+sealed trait StringModule[T] {\n+\n+  def fromString(s: String): Either[String, T]\n+\n+  @throws[IllegalArgumentException]\n+  def assertFromString(s: String): T\n+\n+  implicit def equalInstance: Equal[T]\n+\n+  implicit def ordering: Ordering[T]\n+\n+  // We provide the following array factory instead of a ClassTag\n+  // because the latter lets people easily reinterpret any string as a T.\n+  // See\n+  //  * https://github.com/digital-asset/daml/pull/983#discussion_r282513324\n+  //  * https://github.com/scala/bug/issues/9565\n+  val Array: ArrayFactory[T]\n+\n+  def toStringMap[V](map: Map[T, V]): Map[String, V]\n+}\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable and can be generated from numbers without extra checks.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed trait ConcatenableStringModule[T <: String] extends StringModule[T] {\n+\n+  def encode(a: Array[Byte]): T\n+\n+  def fromLong(i: Long): T\n+\n+  def fromInt(i: Int): T\n+\n+  def concat(s: T, ss: T*): T\n+}\n+\n+sealed trait UnionStringModule[T <: String, TV0 <: T, TV1 <: T] extends StringModule[T] {"
  },
  {
    "id" : "a782d5cc-c52a-4638-b818-b795c58c7d0c",
    "prId" : 4221,
    "comments" : [
      {
        "id" : "fe8326ed-38aa-4f3b-95c1-62532c7d6a2a",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n  /** Identifier for a contractIds, union of `ContractIdStringV0` and `ContractIdStringV1` */\r\n```",
        "createdAt" : "2020-01-31T15:14:46Z",
        "updatedAt" : "2020-02-03T21:56:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "b2c03d6b-616a-47d9-a133-4b41a1660350",
        "parentId" : "fe8326ed-38aa-4f3b-95c1-62532c7d6a2a",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2020-02-03T10:43:25Z",
        "updatedAt" : "2020-02-03T21:56:31Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9233a4097ca730ce5db7e0b07a328048ff91a0cc",
    "line" : 233,
    "diffHunk" : "@@ -0,0 +1,257 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+package com.digitalasset.daml.lf.data\n+\n+import scalaz.Equal\n+\n+sealed trait StringModule[T] {\n+\n+  def fromString(s: String): Either[String, T]\n+\n+  @throws[IllegalArgumentException]\n+  def assertFromString(s: String): T\n+\n+  implicit def equalInstance: Equal[T]\n+\n+  implicit def ordering: Ordering[T]\n+\n+  // We provide the following array factory instead of a ClassTag\n+  // because the latter lets people easily reinterpret any string as a T.\n+  // See\n+  //  * https://github.com/digital-asset/daml/pull/983#discussion_r282513324\n+  //  * https://github.com/scala/bug/issues/9565\n+  val Array: ArrayFactory[T]\n+\n+  def toStringMap[V](map: Map[T, V]): Map[String, V]\n+}\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable and can be generated from numbers without extra checks.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed trait ConcatenableStringModule[T <: String] extends StringModule[T] {\n+\n+  def encode(a: Array[Byte]): T\n+\n+  def fromLong(i: Long): T\n+\n+  def fromInt(i: Int): T\n+\n+  def concat(s: T, ss: T*): T\n+}\n+\n+sealed trait UnionStringModule[T <: String, TV0 <: T, TV1 <: T] extends StringModule[T] {\n+\n+  def toEither(s: T): Either[TV0, TV1]\n+\n+  def toV0(s: T): Option[TV0]\n+\n+  def assertToV0(s: T): TV0\n+\n+  def toV1(s: T): Option[TV1]\n+\n+  def assertToV1(s: T): TV1\n+\n+}\n+\n+sealed abstract class IdString {\n+\n+  // We are very restrictive with regards to identifiers, taking inspiration\n+  // from the lexical structure of Java:\n+  // <https://docs.oracle.com/javase/specs/jls/se10/html/jls-3.html#jls-3.8>.\n+  //\n+  // In a language like C# you'll need to use some other unicode char for `$`.\n+  type Name <: String\n+\n+  /** Party identifiers are non-empty US-ASCII strings built from letters, digits, space, colon, minus and,\n+      underscore. We use them to represent [Party] literals. In this way, we avoid\n+      empty identifiers, escaping problems, and other similar pitfalls.\n+    */\n+  type Party <: String\n+\n+  /** Reference to a package via a package identifier. The identifier is the ascii7\n+    * lowercase hex-encoded hash of the package contents found in the DAML LF Archive. */\n+  type PackageId <: String\n+\n+  /**\n+    * Used to reference to leger objects like legacy contractIds, ledgerIds,\n+    * transactionId, ... We use the same type for those ids, because we\n+    * construct some by concatenating the others.\n+    */\n+  type LedgerString <: String\n+\n+  /** Identifier for a contractId */\n+  type ContractIdString <: String\n+\n+  /** Legacy Identifier for a contractId */\n+  type ContractIdStringV0 <: ContractIdString\n+\n+  /**\n+    * New contractId ordered with relative contractIds.\n+    */\n+  type ContractIdStringV1 <: ContractIdString\n+\n+  val Name: StringModule[Name]\n+  val Party: ConcatenableStringModule[Party]\n+  val PackageId: ConcatenableStringModule[PackageId]\n+  val LedgerString: ConcatenableStringModule[LedgerString]\n+  val ContractIdStringV0: StringModule[ContractIdStringV0]\n+  val ContractIdStringV1: StringModule[ContractIdStringV1]\n+  val ContractIdString: UnionStringModule[ContractIdString, ContractIdStringV0, ContractIdStringV1]\n+\n+}\n+\n+private sealed abstract class StringModuleImpl extends StringModule[String] {\n+\n+  type T = String\n+\n+  final implicit def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n+\n+  final val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+  def fromString(str: String): Either[String, String]\n+\n+  final def assertFromString(s: String): String =\n+    assertRight(fromString(s))\n+\n+  final implicit val ordering: Ordering[String] =\n+    _ compareTo _\n+\n+  final def toStringMap[V](map: Map[String, V]): Map[String, V] =\n+    map\n+}\n+\n+private final class MatchingStringModule(string_regex: String) extends StringModuleImpl {\n+\n+  private val regex = string_regex.r\n+  private val pattern = regex.pattern\n+\n+  override def fromString(s: String): Either[String, T] =\n+    Either.cond(pattern.matcher(s).matches(), s, s\"\"\"string \"$s\" does not match regex \"$regex\"\"\"\")\n+\n+}\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable and can be generated from numbers without extra checks.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+private final class ConcatenableMatchingStringModule(\n+    extraAllowedChars: Char => Boolean,\n+    maxLength: Int = Int.MaxValue\n+) extends StringModuleImpl\n+    with ConcatenableStringModule[String] {\n+\n+  override def fromString(s: String): Either[String, T] =\n+    if (s.isEmpty)\n+      Left(s\"\"\"empty string\"\"\")\n+    else if (s.length > maxLength)\n+      Left(s\"\"\"string too long\"\"\")\n+    else\n+      s.find(c => c > 0x7f || !(c.isLetterOrDigit || extraAllowedChars(c)))\n+        .fold[Either[String, T]](Right(s))(c =>\n+          Left(s\"\"\"non expected character 0x${c.toInt.toHexString} in \"$s\"\"\"\"))\n+\n+  override def encode(a: Array[Byte]): String = a.map(\"%02x\" format _).mkString\n+\n+  override def fromLong(i: Long): T = i.toString\n+\n+  override def fromInt(i: Int): T = fromLong(i.toLong)\n+\n+  override def concat(s: T, ss: T*): T = {\n+    val b = StringBuilder.newBuilder\n+    b ++= s\n+    ss.foreach(b ++= _)\n+    b.result()\n+  }\n+\n+}\n+\n+private[data] final class IdStringImpl extends IdString {\n+\n+  // We are very restrictive with regards to identifiers, taking inspiration\n+  // from the lexical structure of Java:\n+  // <https://docs.oracle.com/javase/specs/jls/se10/html/jls-3.html#jls-3.8>.\n+  //\n+  // In a language like C# you'll need to use some other unicode char for `$`.\n+  override type Name = String\n+  override val Name: StringModule[Name] =\n+    new MatchingStringModule(\"\"\"[A-Za-z\\$_][A-Za-z0-9\\$_]*\"\"\")\n+\n+  /** Party identifiers are non-empty US-ASCII strings built from letters, digits, space, colon, minus and,\n+    *underscore. We use them to represent [Party] literals. In this way, we avoid\n+    * empty identifiers, escaping problems, and other similar pitfalls.\n+    */\n+  override type Party = String\n+  override val Party: ConcatenableStringModule[Party] =\n+    new ConcatenableMatchingStringModule(\":-_ \".contains(_))\n+\n+  /** Reference to a package via a package identifier. The identifier is the ascii7\n+    * lowercase hex-encoded hash of the package contents found in the DAML LF Archive. */\n+  override type PackageId = String\n+  override val PackageId: ConcatenableStringModule[PackageId] =\n+    new ConcatenableMatchingStringModule(\"-_ \".contains(_))\n+\n+  /**\n+    * Used to reference to leger objects like contractIds, ledgerIds,\n+    * transactionId, ... We use the same type for those ids, because we\n+    * construct some by concatenating the others.\n+    */\n+  // We allow space because the navigator's applicationId used it.\n+  override type LedgerString = String\n+  override val LedgerString: ConcatenableStringModule[LedgerString] =\n+    new ConcatenableMatchingStringModule(\"._:-#/ \".contains(_), 255)\n+\n+  /**\n+    * Legacy contractIds.\n+    */\n+  override type ContractIdStringV0 = LedgerString\n+  override val ContractIdStringV0: StringModule[LedgerString] = LedgerString\n+\n+  /**\n+    * New contractId ordered with relative contractIds.\n+    */\n+  // Prefixed with \"$0\" which is not a valid substring of ContractIdV0.\n+  override type ContractIdStringV1 = String\n+  override val ContractIdStringV1: StringModule[ContractIdStringV1] =\n+    new MatchingStringModule(\"\"\"\\$0[0-9a-f]{64}[A-Za-z0-9:\\-_]{189}\"\"\")\n+\n+  /** Identifier for a contractIs, union of `ContractIdStringV0` and `ContractIdStringV1` */"
  },
  {
    "id" : "6220cfce-82b6-4ea6-bece-780c3ab62a55",
    "prId" : 4221,
    "comments" : [
      {
        "id" : "34e8161e-15ee-466a-af76-67bc6198d2e0",
        "parentId" : null,
        "author" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "body" : "```suggestion\r\n  /** Identifier for a contractIds, union of `ContractIdStringV0` and `ContractIdStringV1` */\r\n```",
        "createdAt" : "2020-02-03T17:07:12Z",
        "updatedAt" : "2020-02-03T21:56:31Z",
        "lastEditedBy" : {
          "login" : "gerolf-da",
          "name" : "Gerolf Seitz",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/29121423?u=f683aa614e742c653ae8c01b194905dcdef6e974&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "9233a4097ca730ce5db7e0b07a328048ff91a0cc",
    "line" : 233,
    "diffHunk" : "@@ -0,0 +1,262 @@\n+// Copyright (c) 2020 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+package com.digitalasset.daml.lf.data\n+\n+import scalaz.Equal\n+\n+sealed trait StringModule[T] {\n+\n+  def fromString(s: String): Either[String, T]\n+\n+  @throws[IllegalArgumentException]\n+  def assertFromString(s: String): T\n+\n+  implicit def equalInstance: Equal[T]\n+\n+  implicit def ordering: Ordering[T]\n+\n+  // We provide the following array factory instead of a ClassTag\n+  // because the latter lets people easily reinterpret any string as a T.\n+  // See\n+  //  * https://github.com/digital-asset/daml/pull/983#discussion_r282513324\n+  //  * https://github.com/scala/bug/issues/9565\n+  val Array: ArrayFactory[T]\n+\n+  def toStringMap[V](map: Map[T, V]): Map[String, V]\n+}\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable and can be generated from numbers without extra checks.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed trait ConcatenableStringModule[T <: String] extends StringModule[T] {\n+\n+  def encode(a: Array[Byte]): T\n+\n+  def fromLong(i: Long): T\n+\n+  def fromInt(i: Int): T\n+\n+  def concat(s: T, ss: T*): Either[String, T]\n+\n+  def assertConcat(s: T, ss: T*): T\n+}\n+\n+sealed trait UnionStringModule[T <: String, TA <: T, TB <: T] extends StringModule[T] {\n+\n+  def toEither(s: T): Either[TA, TB]\n+\n+  def toA(s: T): Option[TA]\n+\n+  def assertToVA(s: T): TA\n+\n+  def toB(s: T): Option[TB]\n+\n+  def assertToVB(s: T): TB\n+\n+}\n+\n+sealed abstract class IdString {\n+\n+  // We are very restrictive with regards to identifiers, taking inspiration\n+  // from the lexical structure of Java:\n+  // <https://docs.oracle.com/javase/specs/jls/se10/html/jls-3.html#jls-3.8>.\n+  //\n+  // In a language like C# you'll need to use some other unicode char for `$`.\n+  type Name <: String\n+\n+  /** Party identifiers are non-empty US-ASCII strings built from letters, digits, space, colon, minus and,\n+      underscore. We use them to represent [Party] literals. In this way, we avoid\n+      empty identifiers, escaping problems, and other similar pitfalls.\n+    */\n+  type Party <: String\n+\n+  /** Reference to a package via a package identifier. The identifier is the ascii7\n+    * lowercase hex-encoded hash of the package contents found in the DAML LF Archive. */\n+  type PackageId <: String\n+\n+  /**\n+    * Used to reference to leger objects like legacy contractIds, ledgerIds,\n+    * transactionId, ... We use the same type for those ids, because we\n+    * construct some by concatenating the others.\n+    */\n+  type LedgerString <: ContractIdStringV0\n+\n+  /** Identifiers for a contractId */\n+  type ContractIdString <: String\n+\n+  /** Legacy Identifiers for a contractId */\n+  type ContractIdStringV0 <: ContractIdString\n+\n+  /**\n+    * New contractId ordered with relative contractIds.\n+    */\n+  type ContractIdStringV1 <: ContractIdString\n+\n+  val Name: StringModule[Name]\n+  val Party: ConcatenableStringModule[Party]\n+  val PackageId: ConcatenableStringModule[PackageId]\n+  val LedgerString: ConcatenableStringModule[LedgerString]\n+  val ContractIdStringV0: ConcatenableStringModule[ContractIdStringV0]\n+  val ContractIdStringV1: StringModule[ContractIdStringV1]\n+  val ContractIdString: UnionStringModule[ContractIdString, ContractIdStringV0, ContractIdStringV1]\n+\n+}\n+\n+private sealed abstract class StringModuleImpl extends StringModule[String] {\n+\n+  type T = String\n+\n+  final implicit def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n+\n+  final val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+  def fromString(str: String): Either[String, String]\n+\n+  final def assertFromString(s: String): String =\n+    assertRight(fromString(s))\n+\n+  final implicit val ordering: Ordering[String] =\n+    _ compareTo _\n+\n+  final def toStringMap[V](map: Map[String, V]): Map[String, V] =\n+    map\n+}\n+\n+private final class MatchingStringModule(string_regex: String) extends StringModuleImpl {\n+\n+  private val regex = string_regex.r\n+  private val pattern = regex.pattern\n+\n+  override def fromString(s: String): Either[String, T] =\n+    Either.cond(pattern.matcher(s).matches(), s, s\"\"\"string \"$s\" does not match regex \"$regex\"\"\"\")\n+\n+}\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable and can be generated from numbers without extra checks.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+private final class ConcatenableMatchingStringModule(\n+    extraAllowedChars: Char => Boolean,\n+    maxLength: Int = Int.MaxValue\n+) extends StringModuleImpl\n+    with ConcatenableStringModule[String] {\n+\n+  override def fromString(s: String): Either[String, T] =\n+    if (s.isEmpty)\n+      Left(s\"\"\"empty string\"\"\")\n+    else if (s.length > maxLength)\n+      Left(s\"\"\"string too long\"\"\")\n+    else\n+      s.find(c => c > 0x7f || !(c.isLetterOrDigit || extraAllowedChars(c)))\n+        .fold[Either[String, T]](Right(s))(c =>\n+          Left(s\"\"\"non expected character 0x${c.toInt.toHexString} in \"$s\"\"\"\"))\n+\n+  override def encode(a: Array[Byte]): String = a.map(\"%02x\" format _).mkString\n+\n+  override def fromLong(i: Long): T = i.toString\n+\n+  override def fromInt(i: Int): T = fromLong(i.toLong)\n+\n+  override def concat(s: T, ss: T*): Either[String, T] = {\n+    val b = StringBuilder.newBuilder\n+    b ++= s\n+    ss.foreach(b ++= _)\n+    if (b.length <= maxLength) Right(b.result()) else Left(s\"id ${b.result()} too Long\")\n+  }\n+\n+  override def assertConcat(s: T, ss: T*): T =\n+    assertRight(concat(s, ss: _*))\n+\n+}\n+\n+private[data] final class IdStringImpl extends IdString {\n+\n+  // We are very restrictive with regards to identifiers, taking inspiration\n+  // from the lexical structure of Java:\n+  // <https://docs.oracle.com/javase/specs/jls/se10/html/jls-3.html#jls-3.8>.\n+  //\n+  // In a language like C# you'll need to use some other unicode char for `$`.\n+  override type Name = String\n+  override val Name: StringModule[Name] =\n+    new MatchingStringModule(\"\"\"[A-Za-z\\$_][A-Za-z0-9\\$_]*\"\"\")\n+\n+  /** Party identifiers are non-empty US-ASCII strings built from letters, digits, space, colon, minus and,\n+    *underscore. We use them to represent [Party] literals. In this way, we avoid\n+    * empty identifiers, escaping problems, and other similar pitfalls.\n+    */\n+  override type Party = String\n+  override val Party: ConcatenableStringModule[Party] =\n+    new ConcatenableMatchingStringModule(\":-_ \".contains(_))\n+\n+  /** Reference to a package via a package identifier. The identifier is the ascii7\n+    * lowercase hex-encoded hash of the package contents found in the DAML LF Archive. */\n+  override type PackageId = String\n+  override val PackageId: ConcatenableStringModule[PackageId] =\n+    new ConcatenableMatchingStringModule(\"-_ \".contains(_))\n+\n+  /**\n+    * Used to reference to leger objects like contractIds, ledgerIds,\n+    * transactionId, ... We use the same type for those ids, because we\n+    * construct some by concatenating the others.\n+    */\n+  // We allow space because the navigator's applicationId used it.\n+  override type LedgerString = String\n+  override val LedgerString: ConcatenableStringModule[LedgerString] =\n+    new ConcatenableMatchingStringModule(\"._:-#/ \".contains(_), 255)\n+\n+  /**\n+    * Legacy contractIds.\n+    */\n+  override type ContractIdStringV0 = LedgerString\n+  override val ContractIdStringV0: ConcatenableStringModule[LedgerString] = LedgerString\n+\n+  /**\n+    * New contractId ordered with relative contractIds.\n+    */\n+  // Prefixed with \"$0\" which is not a valid substring of ContractIdV0.\n+  override type ContractIdStringV1 = String\n+  override val ContractIdStringV1: StringModule[ContractIdStringV1] =\n+    new MatchingStringModule(\"\"\"\\$0[0-9a-f]{64}[A-Za-z0-9:\\-_]{189}\"\"\")\n+\n+  /** Identifier for a contractIs, union of `ContractIdStringV0` and `ContractIdStringV1` */"
  }
]