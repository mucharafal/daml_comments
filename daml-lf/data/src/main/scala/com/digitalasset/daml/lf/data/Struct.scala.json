[
  {
    "id" : "f4ca172f-b13c-438a-8438-7c22ccd9c906",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "3636cd9e-810a-4efc-9b24-ec9a7fe823ed",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Youâ€™ve changed this to be called `entries`.",
        "createdAt" : "2020-09-02T09:12:21Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bef2624b-6977-4c16-93c1-3b65cc41cd23",
        "parentId" : "3636cd9e-810a-4efc-9b24-ec9a7fe823ed",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "reverted",
        "createdAt" : "2020-09-02T10:39:42Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,82 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val entries: ImmArray[(Ref.Name, X)]) extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /* Invariant:\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+      for {\n+        i <- sortedFields.indices"
  },
  {
    "id" : "f876dcc5-1167-4830-8928-b7ae6118813b",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "f09e7856-29d5-4159-b3df-4225429b63ea",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not sure the formalism is helpful here. â€œmust be sorted by the first element in strictly ascending orderâ€ seems just as precise and at least for me it is easier to parse.",
        "createdAt" : "2020-09-02T09:13:46Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d2c2cfda-19de-4a4d-b86d-0cdc14aa4840",
        "parentId" : "f09e7856-29d5-4159-b3df-4225429b63ea",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "dropped",
        "createdAt" : "2020-09-02T10:39:51Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,82 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val entries: ImmArray[(Ref.Name, X)]) extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /* Invariant:\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+      for {\n+        i <- sortedFields.indices\n+        j <- sortedFields.indices\n+        if (i < j)\n+      } assert((sortedFields(i)._1 compare sortedFields(j)._1) < 0)"
  },
  {
    "id" : "cf50651f-8687-411d-a8a7-9af0f666f15b",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "5c3affe9-eace-4cfb-98d8-ffb75bcdf279",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It makes me sad how Scala makes indexing look like function application. ðŸ˜¿ ",
        "createdAt" : "2020-09-02T10:54:52Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,74 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val sortedFields: ImmArray[(Ref.Name, X)])\n+    extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /** O(n) */\n+  @throws[IndexOutOfBoundsException]\n+  def apply(name: Ref.Name): X = sortedFields.apply(indexOf(name))._2"
  },
  {
    "id" : "3be0eb7c-bf06-428e-9e48-58a0d3b40f76",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What is the rationale for overwriting fields instead of failing? Does the DAML-LF spec allow expressions like `<f = A, f = B>`?",
        "createdAt" : "2020-09-02T10:56:10Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "114e8ab1-0be4-46d1-a1d6-669bd4b01b82",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Probably a bad idea. This makes the Dar decoder swallow duplicate field names. ",
        "createdAt" : "2020-09-03T08:40:11Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c197c367-4346-45f9-a8cd-ea086d1ed157",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What exactly is the bad idea? Overwriting the fields or failing?",
        "createdAt" : "2020-09-03T08:42:39Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "170522e4-849a-436d-8f67-915211418286",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Overwriting the fields was a bad idea. I rewrote the PR to make the builder fail instead. ",
        "createdAt" : "2020-09-03T08:47:32Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e125f252-8e35-42cc-9a70-43f01bbb6e04",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I like it better now. Thanks.",
        "createdAt" : "2020-09-03T11:09:35Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,74 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val sortedFields: ImmArray[(Ref.Name, X)])\n+    extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /** O(n) */\n+  @throws[IndexOutOfBoundsException]\n+  def apply(name: Ref.Name): X = sortedFields.apply(indexOf(name))._2\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+  /** O(n) */\n+  def indexOf(name: Ref.Name): Int = sortedFields.indexWhere(_._1 == name)\n \n+  /** O(n) */\n+  def lookup(name: Ref.Name): Option[X] = sortedFields.find(_._1 == name).map(_._2)\n+\n+  /** O(n) */\n+  def mapValues[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+\n+  /** O(1) */\n   def toImmArray: ImmArray[(Ref.Name, X)] = sortedFields\n \n+  /** O(1) */\n   def names: Iterator[Ref.Name] = iterator.map(_._1)\n \n+  /** O(1) */\n   def values: Iterator[X] = iterator.map(_._2)\n \n+  /** O(1) */\n   def iterator: Iterator[(Ref.Name, X)] = sortedFields.iterator\n \n-  def foreach(f: ((Ref.Name, X)) => Unit): Unit = sortedFields.foreach(f)\n+  /** O(1) */\n+  def size: Int = sortedFields.length\n+\n+  /** O(n) */\n+  override def toString: String = iterator.mkString(\"Struct(\", \",\", \")\")\n \n }\n \n object Struct {\n \n-  def apply[X](fields: (Name, X)*): Struct[X] =\n-    new Struct(fields.sortBy(_._1: String).to[ImmArray])\n-\n-  def apply[X](fields: ImmArray[(Name, X)]): Struct[X] = apply(fields.toSeq: _*)\n-\n-  def fromSortedImmArray[X](fields: ImmArray[(Ref.Name, X)]): Either[String, Struct[X]] = {\n-    val struct = new Struct(fields)\n-    Either.cond(\n-      (struct.names zip struct.names.drop(1)).forall { case (x, y) => (x compare y) <= 0 },\n-      struct,\n-      s\"the list $fields is not sorted by name\"\n-    )\n-  }\n-\n-  private[this] val Emtpy = new Struct(ImmArray.empty)\n-\n-  def empty[X]: Struct[X] = Emtpy.asInstanceOf[Struct[X]]\n+  /** Constructs a Struct.\n+    * Duplicate names are overwritten by later name, similarly as keys in Map."
  },
  {
    "id" : "edb0bdf0-770f-4137-9382-c811e0e04426",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "1e9595af-d87a-4a7b-9731-667ca8d7f1e2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I assume we call this whenever we construct a struct. Thus, I would say this is somewhat performance sensitive. I'm wondering if this code is a bit slower than it needs to be because of all the abstractions? How about something like\r\n```suggestion\r\n    var i = 1\r\n    while (i < sortedFields.lenght) {\r\n      if (sortedFields(i-1)._1 == sortedFields(i)._1) {\r\n        return Left(sortedFields(i)._1)\r\n      }\r\n      i += 1\r\n    }\r\n    Right(Struct(ImmArray(sortedFields)))\r\n```",
        "createdAt" : "2020-09-03T11:07:56Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5e7cc5a3-85d9-44c8-ad0c-3796b29a5a49",
        "parentId" : "1e9595af-d87a-4a7b-9731-667ca8d7f1e2",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "In fact no, we will not call this whenever we construct a Struct.\r\nIn general we will try to use `mapValues` that is O(n) instead O(n log n).\r\n\r\n",
        "createdAt" : "2020-09-03T12:54:26Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,67 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val sortedFields: ImmArray[(Ref.Name, X)])\n+    extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /** O(n) */\n+  @throws[IndexOutOfBoundsException]\n+  def apply(name: Ref.Name): X = sortedFields(indexOf(name))._2\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+  /** O(n) */\n+  def indexOf(name: Ref.Name): Int = sortedFields.indexWhere(_._1 == name)\n \n+  /** O(n) */\n+  def lookup(name: Ref.Name): Option[X] = sortedFields.find(_._1 == name).map(_._2)\n+\n+  /** O(n) */\n+  def mapValues[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+\n+  /** O(1) */\n   def toImmArray: ImmArray[(Ref.Name, X)] = sortedFields\n \n+  /** O(1) */\n   def names: Iterator[Ref.Name] = iterator.map(_._1)\n \n+  /** O(1) */\n   def values: Iterator[X] = iterator.map(_._2)\n \n+  /** O(1) */\n   def iterator: Iterator[(Ref.Name, X)] = sortedFields.iterator\n \n-  def foreach(f: ((Ref.Name, X)) => Unit): Unit = sortedFields.foreach(f)\n+  /** O(1) */\n+  def size: Int = sortedFields.length\n+\n+  /** O(n) */\n+  override def toString: String = iterator.mkString(\"Struct(\", \",\", \")\")\n \n }\n \n object Struct {\n \n-  def apply[X](fields: (Name, X)*): Struct[X] =\n-    new Struct(fields.sortBy(_._1: String).to[ImmArray])\n-\n-  def apply[X](fields: ImmArray[(Name, X)]): Struct[X] = apply(fields.toSeq: _*)\n-\n-  def fromSortedImmArray[X](fields: ImmArray[(Ref.Name, X)]): Either[String, Struct[X]] = {\n-    val struct = new Struct(fields)\n-    Either.cond(\n-      (struct.names zip struct.names.drop(1)).forall { case (x, y) => (x compare y) <= 0 },\n-      struct,\n-      s\"the list $fields is not sorted by name\"\n-    )\n+  /** Constructs a Struct.\n+    * In case one of the field name is duplicated, return it as Left.\n+    * O(n log n)\n+    */\n+  def fromSeq[X](fields: Seq[(Name, X)]): Either[Name, Struct[X]] = {\n+    val sortedFields = fields.sortBy(_._1: String)\n+    (sortedFields.iterator zip sortedFields.iterator.drop(1))\n+      .collectFirst {\n+        case ((name1, _), (name2, _)) if name1 == name2 => name1\n+      }\n+      .toLeft(Struct(ImmArray(sortedFields)))"
  },
  {
    "id" : "658ca39a-9946-48a4-be27-a4aad08da020",
    "prId" : 7220,
    "comments" : [
      {
        "id" : "cc1018a3-6a8e-43e3-8068-1ad4f5240b73",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "reminder to myself and others we used to do the linear lookup before as well.",
        "createdAt" : "2020-08-25T16:04:07Z",
        "updatedAt" : "2020-08-25T17:10:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bd81ff2e34267fdcb710110ff30af3aa4fa0256f",
    "line" : 12,
    "diffHunk" : "@@ -0,0 +1,48 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package data\n+\n+import com.daml.lf.data.Ref.Name\n+\n+final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+\n+  def lookup(name: Ref.Name): Option[X] =\n+    sortedFields.find(_._1 == name).map(_._2)"
  },
  {
    "id" : "882c0aef-a210-4412-8551-f21ba38c78b2",
    "prId" : 7220,
    "comments" : [
      {
        "id" : "85854647-8ad1-4f27-871a-d254bc994148",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This currently doesnâ€™t appear to enforce uniqueness of fields. Given that we rely on this and have a lookup method, should it?",
        "createdAt" : "2020-08-25T16:10:27Z",
        "updatedAt" : "2020-08-25T17:10:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "62e88fb6-fd47-4c49-b0ce-0d1402e5f094",
        "parentId" : "85854647-8ad1-4f27-871a-d254bc994148",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I was also wondering if I should enforce uniqueness. \r\n\r\nI preferred to not do so, in order to have a nicer constructor: `Struct.apply(fields: (Name, X)*): Struct[X]  that does not throw exception nor return an `Either`. \r\n\r\nThe lookup is used only in the type checker that verifies itself that fields are not duplicated.  \r\n",
        "createdAt" : "2020-08-25T16:23:00Z",
        "updatedAt" : "2020-08-25T17:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d3433a68-4444-41ed-8e08-0b774c0ab3de",
        "parentId" : "85854647-8ad1-4f27-871a-d254bc994148",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Iâ€™ll leave it up to you, I donâ€™t feel particularly strongly here.",
        "createdAt" : "2020-08-25T17:20:56Z",
        "updatedAt" : "2020-08-25T17:20:56Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bd81ff2e34267fdcb710110ff30af3aa4fa0256f",
    "line" : 9,
    "diffHunk" : "@@ -0,0 +1,48 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package data\n+\n+import com.daml.lf.data.Ref.Name\n+\n+final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {"
  }
]