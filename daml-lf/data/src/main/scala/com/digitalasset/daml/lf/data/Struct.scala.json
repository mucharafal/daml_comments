[
  {
    "id" : "f4ca172f-b13c-438a-8438-7c22ccd9c906",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "3636cd9e-810a-4efc-9b24-ec9a7fe823ed",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "You’ve changed this to be called `entries`.",
        "createdAt" : "2020-09-02T09:12:21Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "bef2624b-6977-4c16-93c1-3b65cc41cd23",
        "parentId" : "3636cd9e-810a-4efc-9b24-ec9a7fe823ed",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "reverted",
        "createdAt" : "2020-09-02T10:39:42Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,82 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val entries: ImmArray[(Ref.Name, X)]) extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /* Invariant:\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+      for {\n+        i <- sortedFields.indices"
  },
  {
    "id" : "f876dcc5-1167-4830-8928-b7ae6118813b",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "f09e7856-29d5-4159-b3df-4225429b63ea",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "Not sure the formalism is helpful here. “must be sorted by the first element in strictly ascending order” seems just as precise and at least for me it is easier to parse.",
        "createdAt" : "2020-09-02T09:13:46Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d2c2cfda-19de-4a4d-b86d-0cdc14aa4840",
        "parentId" : "f09e7856-29d5-4159-b3df-4225429b63ea",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "dropped",
        "createdAt" : "2020-09-02T10:39:51Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,82 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val entries: ImmArray[(Ref.Name, X)]) extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /* Invariant:\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+      for {\n+        i <- sortedFields.indices\n+        j <- sortedFields.indices\n+        if (i < j)\n+      } assert((sortedFields(i)._1 compare sortedFields(j)._1) < 0)"
  },
  {
    "id" : "cf50651f-8687-411d-a8a7-9af0f666f15b",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "5c3affe9-eace-4cfb-98d8-ffb75bcdf279",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "It makes me sad how Scala makes indexing look like function application. 😿 ",
        "createdAt" : "2020-09-02T10:54:52Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,74 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val sortedFields: ImmArray[(Ref.Name, X)])\n+    extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /** O(n) */\n+  @throws[IndexOutOfBoundsException]\n+  def apply(name: Ref.Name): X = sortedFields.apply(indexOf(name))._2"
  },
  {
    "id" : "3be0eb7c-bf06-428e-9e48-58a0d3b40f76",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What is the rationale for overwriting fields instead of failing? Does the DAML-LF spec allow expressions like `<f = A, f = B>`?",
        "createdAt" : "2020-09-02T10:56:10Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "114e8ab1-0be4-46d1-a1d6-669bd4b01b82",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Probably a bad idea. This makes the Dar decoder swallow duplicate field names. ",
        "createdAt" : "2020-09-03T08:40:11Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "c197c367-4346-45f9-a8cd-ea086d1ed157",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "What exactly is the bad idea? Overwriting the fields or failing?",
        "createdAt" : "2020-09-03T08:42:39Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "170522e4-849a-436d-8f67-915211418286",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Overwriting the fields was a bad idea. I rewrote the PR to make the builder fail instead. ",
        "createdAt" : "2020-09-03T08:47:32Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "e125f252-8e35-42cc-9a70-43f01bbb6e04",
        "parentId" : "3d64cba1-f3ce-4465-bbe7-253c3c2fa5c6",
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I like it better now. Thanks.",
        "createdAt" : "2020-09-03T11:09:35Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,74 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val sortedFields: ImmArray[(Ref.Name, X)])\n+    extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /** O(n) */\n+  @throws[IndexOutOfBoundsException]\n+  def apply(name: Ref.Name): X = sortedFields.apply(indexOf(name))._2\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+  /** O(n) */\n+  def indexOf(name: Ref.Name): Int = sortedFields.indexWhere(_._1 == name)\n \n+  /** O(n) */\n+  def lookup(name: Ref.Name): Option[X] = sortedFields.find(_._1 == name).map(_._2)\n+\n+  /** O(n) */\n+  def mapValues[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+\n+  /** O(1) */\n   def toImmArray: ImmArray[(Ref.Name, X)] = sortedFields\n \n+  /** O(1) */\n   def names: Iterator[Ref.Name] = iterator.map(_._1)\n \n+  /** O(1) */\n   def values: Iterator[X] = iterator.map(_._2)\n \n+  /** O(1) */\n   def iterator: Iterator[(Ref.Name, X)] = sortedFields.iterator\n \n-  def foreach(f: ((Ref.Name, X)) => Unit): Unit = sortedFields.foreach(f)\n+  /** O(1) */\n+  def size: Int = sortedFields.length\n+\n+  /** O(n) */\n+  override def toString: String = iterator.mkString(\"Struct(\", \",\", \")\")\n \n }\n \n object Struct {\n \n-  def apply[X](fields: (Name, X)*): Struct[X] =\n-    new Struct(fields.sortBy(_._1: String).to[ImmArray])\n-\n-  def apply[X](fields: ImmArray[(Name, X)]): Struct[X] = apply(fields.toSeq: _*)\n-\n-  def fromSortedImmArray[X](fields: ImmArray[(Ref.Name, X)]): Either[String, Struct[X]] = {\n-    val struct = new Struct(fields)\n-    Either.cond(\n-      (struct.names zip struct.names.drop(1)).forall { case (x, y) => (x compare y) <= 0 },\n-      struct,\n-      s\"the list $fields is not sorted by name\"\n-    )\n-  }\n-\n-  private[this] val Emtpy = new Struct(ImmArray.empty)\n-\n-  def empty[X]: Struct[X] = Emtpy.asInstanceOf[Struct[X]]\n+  /** Constructs a Struct.\n+    * Duplicate names are overwritten by later name, similarly as keys in Map."
  },
  {
    "id" : "edb0bdf0-770f-4137-9382-c811e0e04426",
    "prId" : 7299,
    "comments" : [
      {
        "id" : "1e9595af-d87a-4a7b-9731-667ca8d7f1e2",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I assume we call this whenever we construct a struct. Thus, I would say this is somewhat performance sensitive. I'm wondering if this code is a bit slower than it needs to be because of all the abstractions? How about something like\r\n```suggestion\r\n    var i = 1\r\n    while (i < sortedFields.lenght) {\r\n      if (sortedFields(i-1)._1 == sortedFields(i)._1) {\r\n        return Left(sortedFields(i)._1)\r\n      }\r\n      i += 1\r\n    }\r\n    Right(Struct(ImmArray(sortedFields)))\r\n```",
        "createdAt" : "2020-09-03T11:07:56Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5e7cc5a3-85d9-44c8-ad0c-3796b29a5a49",
        "parentId" : "1e9595af-d87a-4a7b-9731-667ca8d7f1e2",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "In fact no, we will not call this whenever we construct a Struct.\r\nIn general we will try to use `mapValues` that is O(n) instead O(n log n).\r\n\r\n",
        "createdAt" : "2020-09-03T12:54:26Z",
        "updatedAt" : "2020-09-03T13:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "a892cf4ccfabf76f7971487790c518e83b13e0a5",
    "line" : null,
    "diffHunk" : "@@ -6,43 +6,67 @@ package data\n \n import com.daml.lf.data.Ref.Name\n \n-final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+/** We use this container to describe structural record as sorted flat list in various parts of the codebase.\n+    `entries` are sorted by their first component without duplicate.\n+  */\n+final case class Struct[+X] private (private val sortedFields: ImmArray[(Ref.Name, X)])\n+    extends NoCopy {\n \n-  def lookup(name: Ref.Name): Option[X] =\n-    sortedFields.find(_._1 == name).map(_._2)\n+  /** O(n) */\n+  @throws[IndexOutOfBoundsException]\n+  def apply(name: Ref.Name): X = sortedFields(indexOf(name))._2\n \n-  def mapValue[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+  /** O(n) */\n+  def indexOf(name: Ref.Name): Int = sortedFields.indexWhere(_._1 == name)\n \n+  /** O(n) */\n+  def lookup(name: Ref.Name): Option[X] = sortedFields.find(_._1 == name).map(_._2)\n+\n+  /** O(n) */\n+  def mapValues[Y](f: X => Y) = new Struct(sortedFields.map { case (k, v) => k -> f(v) })\n+\n+  /** O(1) */\n   def toImmArray: ImmArray[(Ref.Name, X)] = sortedFields\n \n+  /** O(1) */\n   def names: Iterator[Ref.Name] = iterator.map(_._1)\n \n+  /** O(1) */\n   def values: Iterator[X] = iterator.map(_._2)\n \n+  /** O(1) */\n   def iterator: Iterator[(Ref.Name, X)] = sortedFields.iterator\n \n-  def foreach(f: ((Ref.Name, X)) => Unit): Unit = sortedFields.foreach(f)\n+  /** O(1) */\n+  def size: Int = sortedFields.length\n+\n+  /** O(n) */\n+  override def toString: String = iterator.mkString(\"Struct(\", \",\", \")\")\n \n }\n \n object Struct {\n \n-  def apply[X](fields: (Name, X)*): Struct[X] =\n-    new Struct(fields.sortBy(_._1: String).to[ImmArray])\n-\n-  def apply[X](fields: ImmArray[(Name, X)]): Struct[X] = apply(fields.toSeq: _*)\n-\n-  def fromSortedImmArray[X](fields: ImmArray[(Ref.Name, X)]): Either[String, Struct[X]] = {\n-    val struct = new Struct(fields)\n-    Either.cond(\n-      (struct.names zip struct.names.drop(1)).forall { case (x, y) => (x compare y) <= 0 },\n-      struct,\n-      s\"the list $fields is not sorted by name\"\n-    )\n+  /** Constructs a Struct.\n+    * In case one of the field name is duplicated, return it as Left.\n+    * O(n log n)\n+    */\n+  def fromSeq[X](fields: Seq[(Name, X)]): Either[Name, Struct[X]] = {\n+    val sortedFields = fields.sortBy(_._1: String)\n+    (sortedFields.iterator zip sortedFields.iterator.drop(1))\n+      .collectFirst {\n+        case ((name1, _), (name2, _)) if name1 == name2 => name1\n+      }\n+      .toLeft(Struct(ImmArray(sortedFields)))"
  },
  {
    "id" : "658ca39a-9946-48a4-be27-a4aad08da020",
    "prId" : 7220,
    "comments" : [
      {
        "id" : "cc1018a3-6a8e-43e3-8068-1ad4f5240b73",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "reminder to myself and others we used to do the linear lookup before as well.",
        "createdAt" : "2020-08-25T16:04:07Z",
        "updatedAt" : "2020-08-25T17:10:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bd81ff2e34267fdcb710110ff30af3aa4fa0256f",
    "line" : 12,
    "diffHunk" : "@@ -0,0 +1,48 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package data\n+\n+import com.daml.lf.data.Ref.Name\n+\n+final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {\n+\n+  def lookup(name: Ref.Name): Option[X] =\n+    sortedFields.find(_._1 == name).map(_._2)"
  },
  {
    "id" : "882c0aef-a210-4412-8551-f21ba38c78b2",
    "prId" : 7220,
    "comments" : [
      {
        "id" : "85854647-8ad1-4f27-871a-d254bc994148",
        "parentId" : null,
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "This currently doesn’t appear to enforce uniqueness of fields. Given that we rely on this and have a lookup method, should it?",
        "createdAt" : "2020-08-25T16:10:27Z",
        "updatedAt" : "2020-08-25T17:10:10Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "62e88fb6-fd47-4c49-b0ce-0d1402e5f094",
        "parentId" : "85854647-8ad1-4f27-871a-d254bc994148",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "I was also wondering if I should enforce uniqueness. \r\n\r\nI preferred to not do so, in order to have a nicer constructor: `Struct.apply(fields: (Name, X)*): Struct[X]  that does not throw exception nor return an `Either`. \r\n\r\nThe lookup is used only in the type checker that verifies itself that fields are not duplicated.  \r\n",
        "createdAt" : "2020-08-25T16:23:00Z",
        "updatedAt" : "2020-08-25T17:16:28Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "d3433a68-4444-41ed-8e08-0b774c0ab3de",
        "parentId" : "85854647-8ad1-4f27-871a-d254bc994148",
        "author" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "body" : "I’ll leave it up to you, I don’t feel particularly strongly here.",
        "createdAt" : "2020-08-25T17:20:56Z",
        "updatedAt" : "2020-08-25T17:20:56Z",
        "lastEditedBy" : {
          "login" : "cocreature",
          "name" : "Moritz Kiefer",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/1313584?u=7864421488a876940b33e865c4b0091925617ca7&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "bd81ff2e34267fdcb710110ff30af3aa4fa0256f",
    "line" : 9,
    "diffHunk" : "@@ -0,0 +1,48 @@\n+// Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.daml.lf\n+package data\n+\n+import com.daml.lf.data.Ref.Name\n+\n+final case class Struct[+X] private (sortedFields: ImmArray[(Ref.Name, X)]) extends NoCopy {"
  }
]