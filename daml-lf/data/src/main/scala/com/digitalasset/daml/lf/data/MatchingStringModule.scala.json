[
  {
    "id" : "bc74cea3-d0c0-4493-88d3-bb78c0ac9891",
    "prId" : 1192,
    "comments" : [
      {
        "id" : "9f01a871-76ba-4df9-a74d-0a522409c9e8",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      override def newBuilder = StringBuilder.newBuilder\r\n```",
        "createdAt" : "2019-05-22T18:55:26Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "77fa5d4e-dc49-4d69-8c23-317359730064",
        "parentId" : "9f01a871-76ba-4df9-a74d-0a522409c9e8",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2019-05-23T08:40:31Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "48b39e1b56daf20f06f1101c44b66334dbb58252",
    "line" : null,
    "diffHunk" : "@@ -39,6 +42,77 @@ object MatchingStringModule extends (Regex => MatchingStringModule) {\n     def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n \n     val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+    def toStringMap[V](map: Map[T, V]): Map[String, V] = map\n   }\n \n }\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable (and can be generate from number) without extra check.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed abstract class ConcatenableMatchingStringModule extends StringModule {\n+\n+  def fromLong(i: Long): T\n+\n+  final def fromInt(i: Int): T = fromLong(i.toLong)\n+\n+  final def concat(s: T, ss: T*): T = {\n+    val b = newBuilder\n+    b += s\n+    ss.foreach(b += _)\n+    b.result()\n+  }\n+\n+  def newBuilder: mutable.Builder[T, T]\n+\n+}\n+\n+object ConcatenableMatchingStringModule {\n+\n+  def apply(\n+      extraAllowedChars: Char => Boolean,\n+      maxLength: Int = Int.MaxValue\n+  ): ConcatenableMatchingStringModule =\n+    new ConcatenableMatchingStringModule {\n+      type T = String\n+\n+      def fromString(s: String): Either[String, T] =\n+        if (s.isEmpty)\n+          Left(s\"\"\"empty string\"\"\")\n+        else if (s.length > maxLength)\n+          Left(s\"\"\"string too long\"\"\")\n+        else\n+          s.find(c => c > '\\u007f' || !(c.isLetterOrDigit || extraAllowedChars(c)))\n+            .fold[Either[String, T]](Right(s))(c =>\n+              Left(s\"\"\"non expected character 0x${c.toInt.toHexString} in \"$s\"\"\"\"))\n+\n+      def fromLong(i: Long): T = i.toString\n+\n+      def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n+\n+      val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+      def toStringMap[V](map: Map[T, V]): Map[String, V] = map\n+\n+      def newBuilder: mutable.ReusableBuilder[T, T] = new mutable.ReusableBuilder[T, T] {"
  },
  {
    "id" : "7142ec22-87b8-4651-b7d0-d829d5266762",
    "prId" : 1192,
    "comments" : [
      {
        "id" : "03e3e9d8-f52b-4143-9e52-8d55eb0715f5",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n  private def newBuilder: mutable.Builder[T, T]\r\n```\r\n\r\nElse you imply the validity of empty string: `Party.newBuilder.result => \"\"`",
        "createdAt" : "2019-05-22T18:58:56Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "171b4a88-19bf-4218-8dcb-e31b5589ebb3",
        "parentId" : "03e3e9d8-f52b-4143-9e52-8d55eb0715f5",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "indeed. Good catch\r\n",
        "createdAt" : "2019-05-23T07:42:22Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "48b39e1b56daf20f06f1101c44b66334dbb58252",
    "line" : null,
    "diffHunk" : "@@ -39,6 +42,77 @@ object MatchingStringModule extends (Regex => MatchingStringModule) {\n     def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n \n     val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+    def toStringMap[V](map: Map[T, V]): Map[String, V] = map\n   }\n \n }\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable (and can be generate from number) without extra check.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed abstract class ConcatenableMatchingStringModule extends StringModule {\n+\n+  def fromLong(i: Long): T\n+\n+  final def fromInt(i: Int): T = fromLong(i.toLong)\n+\n+  final def concat(s: T, ss: T*): T = {\n+    val b = newBuilder\n+    b += s\n+    ss.foreach(b += _)\n+    b.result()\n+  }\n+\n+  def newBuilder: mutable.Builder[T, T]"
  },
  {
    "id" : "95f045cd-4eb0-45a8-89e7-879b2aeba884",
    "prId" : 1192,
    "comments" : [
      {
        "id" : "5694cf2b-c3c5-40dc-86ab-964a63f984c6",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n      override def toStringMap[V](map: Map[T, V]) = map.toMap\r\n```\r\n\r\nFor the same reason as scala/bug#10496, and so we get that fix if it ever arrives.",
        "createdAt" : "2019-05-22T19:00:43Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "1b705641-e0d9-4aa5-af2b-44108294c6ea",
        "parentId" : "5694cf2b-c3c5-40dc-86ab-964a63f984c6",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2019-05-23T08:40:40Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "48b39e1b56daf20f06f1101c44b66334dbb58252",
    "line" : null,
    "diffHunk" : "@@ -39,6 +42,77 @@ object MatchingStringModule extends (Regex => MatchingStringModule) {\n     def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n \n     val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+    def toStringMap[V](map: Map[T, V]): Map[String, V] = map\n   }\n \n }\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable (and can be generate from number) without extra check.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed abstract class ConcatenableMatchingStringModule extends StringModule {\n+\n+  def fromLong(i: Long): T\n+\n+  final def fromInt(i: Int): T = fromLong(i.toLong)\n+\n+  final def concat(s: T, ss: T*): T = {\n+    val b = newBuilder\n+    b += s\n+    ss.foreach(b += _)\n+    b.result()\n+  }\n+\n+  def newBuilder: mutable.Builder[T, T]\n+\n+}\n+\n+object ConcatenableMatchingStringModule {\n+\n+  def apply(\n+      extraAllowedChars: Char => Boolean,\n+      maxLength: Int = Int.MaxValue\n+  ): ConcatenableMatchingStringModule =\n+    new ConcatenableMatchingStringModule {\n+      type T = String\n+\n+      def fromString(s: String): Either[String, T] =\n+        if (s.isEmpty)\n+          Left(s\"\"\"empty string\"\"\")\n+        else if (s.length > maxLength)\n+          Left(s\"\"\"string too long\"\"\")\n+        else\n+          s.find(c => c > '\\u007f' || !(c.isLetterOrDigit || extraAllowedChars(c)))\n+            .fold[Either[String, T]](Right(s))(c =>\n+              Left(s\"\"\"non expected character 0x${c.toInt.toHexString} in \"$s\"\"\"\"))\n+\n+      def fromLong(i: Long): T = i.toString\n+\n+      def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n+\n+      val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+      def toStringMap[V](map: Map[T, V]): Map[String, V] = map"
  },
  {
    "id" : "d2633e89-a86e-41be-a6b5-7a8e34ce3aa8",
    "prId" : 1192,
    "comments" : [
      {
        "id" : "9dc901b7-b74e-43af-8939-bb419f82ec82",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "I suggest always using `override` for every `def` or `val` when defining the structures, because nothing else but the \"overrides nothing\" error tells you when you've forgotten to include something in the signatures.",
        "createdAt" : "2019-05-22T19:02:07Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "828864f8-eefb-474b-92c9-1ff1bb53d66a",
        "parentId" : "9dc901b7-b74e-43af-8939-bb419f82ec82",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "OK",
        "createdAt" : "2019-05-23T09:25:28Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "48b39e1b56daf20f06f1101c44b66334dbb58252",
    "line" : null,
    "diffHunk" : "@@ -39,6 +42,77 @@ object MatchingStringModule extends (Regex => MatchingStringModule) {\n     def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n \n     val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+    def toStringMap[V](map: Map[T, V]): Map[String, V] = map\n   }\n \n }\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable (and can be generate from number) without extra check.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed abstract class ConcatenableMatchingStringModule extends StringModule {\n+\n+  def fromLong(i: Long): T\n+\n+  final def fromInt(i: Int): T = fromLong(i.toLong)\n+\n+  final def concat(s: T, ss: T*): T = {\n+    val b = newBuilder\n+    b += s\n+    ss.foreach(b += _)\n+    b.result()\n+  }\n+\n+  def newBuilder: mutable.Builder[T, T]\n+\n+}\n+\n+object ConcatenableMatchingStringModule {\n+\n+  def apply(\n+      extraAllowedChars: Char => Boolean,\n+      maxLength: Int = Int.MaxValue\n+  ): ConcatenableMatchingStringModule =\n+    new ConcatenableMatchingStringModule {\n+      type T = String\n+\n+      def fromString(s: String): Either[String, T] ="
  },
  {
    "id" : "16ff2276-2170-4a4b-b793-21b6dc8c7903",
    "prId" : 1192,
    "comments" : [
      {
        "id" : "d3071251-91ef-4123-a26c-4a8af46cf38b",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Similarly to the other `toStringMap` here.",
        "createdAt" : "2019-05-23T13:53:54Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "3bebb791-6eb2-465f-a57e-7eb519ddb66a",
        "parentId" : "d3071251-91ef-4123-a26c-4a8af46cf38b",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "done",
        "createdAt" : "2019-05-23T14:57:47Z",
        "updatedAt" : "2019-05-24T09:32:12Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "48b39e1b56daf20f06f1101c44b66334dbb58252",
    "line" : null,
    "diffHunk" : "@@ -24,21 +22,84 @@ sealed abstract class MatchingStringModule {\n   //  * https://github.com/digital-asset/daml/pull/983#discussion_r282513324\n   //  * https://github.com/scala/bug/issues/9565\n   val Array: ArrayFactory[T]\n+\n+  def toStringMap[V](map: Map[T, V]): Map[String, V]\n }\n \n-object MatchingStringModule extends (Regex => MatchingStringModule) {\n+object MatchingStringModule {\n \n-  override def apply(regex: Regex): MatchingStringModule = new MatchingStringModule {\n+  def apply(string_regex: String): StringModule = new StringModule {\n     type T = String\n \n+    private val regex = string_regex.r\n     private val pattern = regex.pattern\n \n-    def fromString(s: String): Either[String, T] =\n+    override def fromString(s: String): Either[String, T] =\n       Either.cond(pattern.matcher(s).matches(), s, s\"\"\"string \"$s\" does not match regex \"$regex\"\"\"\")\n \n-    def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n+    override def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n+\n+    override val Array: ArrayFactory[T] = new ArrayFactory[T]\n \n-    val Array: ArrayFactory[T] = new ArrayFactory[T]\n+    // Do not drop the following `toMap` (See https://github.com/scala/bug/issues/10496)\n+    override def toStringMap[V](map: Map[T, V]): Map[String, V] = map.toMap\n   }\n \n }\n+\n+/** ConcatenableMatchingString are non empty US-ASCII strings built with letters, digits,\n+  * and some other (parameterizable) extra characters.\n+  * We use them to represent identifiers. In this way, we avoid\n+  * empty identifiers, escaping problems, and other similar pitfalls.\n+  *\n+  * ConcatenableMatchingString has the advantage over MatchingStringModule of being\n+  * concatenable (and can be generate from number) without extra check.\n+  * Those properties are heavily use to generate some ids by combining other existing\n+  * ids.\n+  */\n+sealed abstract class ConcatenableMatchingStringModule extends StringModule {\n+\n+  def fromLong(i: Long): T\n+\n+  final def fromInt(i: Int): T = fromLong(i.toLong)\n+\n+  def concat(s: T, ss: T*): T\n+}\n+\n+object ConcatenableMatchingStringModule {\n+\n+  def apply(\n+      extraAllowedChars: Char => Boolean,\n+      maxLength: Int = Int.MaxValue\n+  ): ConcatenableMatchingStringModule =\n+    new ConcatenableMatchingStringModule {\n+      type T = String\n+\n+      override def fromString(s: String): Either[String, T] =\n+        if (s.isEmpty)\n+          Left(s\"\"\"empty string\"\"\")\n+        else if (s.length > maxLength)\n+          Left(s\"\"\"string too long\"\"\")\n+        else\n+          s.find(c => c > '\\u007f' || !(c.isLetterOrDigit || extraAllowedChars(c)))\n+            .fold[Either[String, T]](Right(s))(c =>\n+              Left(s\"\"\"non expected character 0x${c.toInt.toHexString} in \"$s\"\"\"\"))\n+\n+      override def fromLong(i: Long): T = i.toString\n+\n+      override def equalInstance: Equal[T] = scalaz.std.string.stringInstance\n+\n+      override val Array: ArrayFactory[T] = new ArrayFactory[T]\n+\n+      override def toStringMap[V](map: Map[T, V]): Map[String, V] = map"
  },
  {
    "id" : "bbee8204-0931-4a06-ac91-afb0fda2383b",
    "prId" : 983,
    "comments" : [
      {
        "id" : "d31d2f96-efbf-42bd-89a7-7cfefdc959d9",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "```suggestion\r\n```\r\n\r\nThe presence of such a `ClassTag` lets me easily reinterpret any string as a `T` with innocent-looking code:\r\n\r\n```scala\r\n  import Ref.Name.classTag\r\n  \"some bad string #^&*#(*%^&)@\" match {\r\n    case x: Ref.Name => x // this will succeed\r\n  }\r\n```\r\n\r\nInstead, supply explicit array-creation functions in the `MatchingStringModule` signature.\r\n\r\nIncidentally it was a mistake we've dealt with before for the `Array` API to use `ClassTag` directly instead of some weaker array-creation-specific typeclass, as well as the feature above scala/bug#9565.",
        "createdAt" : "2019-05-09T14:31:33Z",
        "updatedAt" : "2019-05-13T10:32:18Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "9721713f-f762-4417-ad41-af1dfa6891f6",
        "parentId" : "d31d2f96-efbf-42bd-89a7-7cfefdc959d9",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Please take a look at the new version of `MatchingStringModule`.",
        "createdAt" : "2019-05-10T08:42:49Z",
        "updatedAt" : "2019-05-13T10:32:19Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "f651a1e798c15873f3499c8b7e583ea010b3d99f",
    "line" : null,
    "diffHunk" : "@@ -11,21 +14,29 @@ sealed abstract class MatchingStringModule {\n   def fromString(s: String): Either[String, T]\n \n   @throws[IllegalArgumentException]\n-  def assertFromString(s: String): T =\n+  final def assertFromString(s: String): T =\n     fromString(s).fold(e => throw new IllegalArgumentException(e), identity)\n \n-  def unapply(x: T): Some[String] = Some(x)\n+  implicit def equalInstance: Equal[T]\n+\n+  implicit def classTag: ClassTag[T]"
  },
  {
    "id" : "27957154-9f09-44fd-8138-f21c0d130bf1",
    "prId" : 983,
    "comments" : [
      {
        "id" : "7129feb8-d4b9-487c-ab72-a39acb226a1a",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Exactly what I had in mind.\r\n\r\nThere is an implication you should be aware of: `null` is generally rejected as an inhabitant of `Name`, in other words `null: Name` fails at type-checking, not wartremover. However, IIUC `ofDim` effectively backdoors a `null` inhabitant. This isn't really enough of a bother to avoid this, necessarily (you can also get a `null` inhabitant by getting the 0th item of an empty java ArrayList), but worth keeping in mind.\r\n\r\nWe might also want to provide a `CanBuildFrom[Array[_], T, Array[T]]` instance, but see my other comment.",
        "createdAt" : "2019-05-13T02:14:23Z",
        "updatedAt" : "2019-05-13T10:32:19Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "f651a1e798c15873f3499c8b7e583ea010b3d99f",
    "line" : 34,
    "diffHunk" : "@@ -11,10 +14,27 @@ sealed abstract class MatchingStringModule {\n   def fromString(s: String): Either[String, T]\n \n   @throws[IllegalArgumentException]\n-  def assertFromString(s: String): T =\n+  final def assertFromString(s: String): T =\n     fromString(s).fold(e => throw new IllegalArgumentException(e), identity)\n \n-  def unapply(x: T): Some[String] = Some(x)\n+  def equalInstance: Equal[T]\n+\n+  // We provide the following array factory instead of a ClassTag\n+  // because the latter lets people easily reinterpret any string as a T.\n+  // See\n+  //  * https://github.com/digital-asset/daml/pull/983#discussion_r282513324\n+  //  * https://github.com/scala/bug/issues/9565\n+  val Array: ArrayFactory[T]\n+\n+}\n+\n+sealed abstract class ArrayFactory[T](implicit classTag: ClassTag[T]) {\n+\n+  def apply(xs: T*): Array[T] = xs.toArray\n+\n+  def ofDim(n: Int): Array[T] = Array.ofDim(n)"
  },
  {
    "id" : "64ad9d3f-db94-4bde-b13e-e9ee898b8df8",
    "prId" : 761,
    "comments" : [
      {
        "id" : "d77f2ae5-1f62-495d-a5e2-82545c4609c8",
        "parentId" : null,
        "author" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "body" : "Totality checking actually understands the implication of this:\r\n\r\n```suggestion\r\n  def unapply(x: T): Some[String] = Some(x)\r\n```",
        "createdAt" : "2019-05-06T16:14:04Z",
        "updatedAt" : "2019-05-06T17:01:29Z",
        "lastEditedBy" : {
          "login" : "S11001001",
          "name" : "Stephen Compall",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/219186?u=7b27ed58a578fe7d4983d1bab28c2f5608ed8739&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "43550e2f-549a-4aeb-a13e-fd2e5cd7f071",
        "parentId" : "d77f2ae5-1f62-495d-a5e2-82545c4609c8",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-05-06T16:52:09Z",
        "updatedAt" : "2019-05-06T17:01:29Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "47aa8737384d1d20c8aabc0ccd0be804a42e3003",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,31 @@\n+// Copyright (c) 2019 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.data\n+\n+import scala.util.matching.Regex\n+\n+sealed abstract class MatchingStringModule {\n+  type T <: String\n+\n+  def fromString(s: String): Either[String, T]\n+\n+  @throws[IllegalArgumentException]\n+  def assertFromString(s: String): T =\n+    fromString(s).fold(e => throw new IllegalArgumentException(e), identity)\n+\n+  def unapply(x: T): Option[String] = Some(x)"
  }
]