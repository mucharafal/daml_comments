[
  {
    "id" : "bd20b456-50ef-46b5-b40d-71af21e9a6b5",
    "prId" : 3474,
    "comments" : [
      {
        "id" : "f6fcd016-687a-4249-b202-32938b22419e",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "Here is the actual fix. ",
        "createdAt" : "2019-11-14T16:30:41Z",
        "updatedAt" : "2019-11-14T16:51:49Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c1c2a7b4334da897e51ecf64f41112df000ed29a",
    "line" : null,
    "diffHunk" : "@@ -45,6 +49,6 @@ object InsertOrdMap {\n   def empty[K, V]: InsertOrdMap[K, V] = Empty.asInstanceOf[InsertOrdMap[K, V]]\n \n   def apply[K, V](entries: (K, V)*): InsertOrdMap[K, V] =\n-    new InsertOrdMap(entries.map(_._1)(breakOut), HashMap(entries: _*))\n+    (empty[K, V] /: entries)(_ + _)"
  },
  {
    "id" : "1e679670-dc00-47d0-934f-262b80245bcc",
    "prId" : 3474,
    "comments" : [
      {
        "id" : "bc718312-bc8f-4820-8368-112bda732c7f",
        "parentId" : null,
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "This is the fix",
        "createdAt" : "2019-11-14T16:36:47Z",
        "updatedAt" : "2019-11-14T16:51:49Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "c1c2a7b4334da897e51ecf64f41112df000ed29a",
    "line" : 55,
    "diffHunk" : "@@ -45,6 +49,6 @@ object InsertOrdMap {\n   def empty[K, V]: InsertOrdMap[K, V] = Empty.asInstanceOf[InsertOrdMap[K, V]]\n \n   def apply[K, V](entries: (K, V)*): InsertOrdMap[K, V] =\n-    new InsertOrdMap(entries.map(_._1)(breakOut), HashMap(entries: _*))\n+    entries.foldLeft(empty[K, V])(_ + _)"
  },
  {
    "id" : "8eecbb3b-fadd-459c-ab13-0df9e37924dc",
    "prId" : 3474,
    "comments" : [
      {
        "id" : "a83f3629-d68d-4de2-a2e8-1d6d0edda92e",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "`/:` is deprecated in Scala 2.12.10 and 2.13; let's use `foldLeft` instead. ðŸ™‚ ",
        "createdAt" : "2019-11-14T16:37:06Z",
        "updatedAt" : "2019-11-14T16:51:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "a20c3fc2-7133-45e3-98d8-028645379913",
        "parentId" : "a83f3629-d68d-4de2-a2e8-1d6d0edda92e",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-11-14T16:41:33Z",
        "updatedAt" : "2019-11-14T16:51:49Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c1c2a7b4334da897e51ecf64f41112df000ed29a",
    "line" : null,
    "diffHunk" : "@@ -45,6 +49,6 @@ object InsertOrdMap {\n   def empty[K, V]: InsertOrdMap[K, V] = Empty.asInstanceOf[InsertOrdMap[K, V]]\n \n   def apply[K, V](entries: (K, V)*): InsertOrdMap[K, V] =\n-    new InsertOrdMap(entries.map(_._1)(breakOut), HashMap(entries: _*))\n+    (empty[K, V] /: entries)(_ + _)"
  },
  {
    "id" : "54f91b86-d57e-4272-a82b-57f9ac00898b",
    "prId" : 3474,
    "comments" : [
      {
        "id" : "f8d7ee95-ff30-4461-91e7-56bdd82fc7a3",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Think you want `V1` here.",
        "createdAt" : "2019-11-14T16:40:06Z",
        "updatedAt" : "2019-11-14T16:51:49Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "93297188-ab29-41ff-ba35-1f48faabbc82",
        "parentId" : "f8d7ee95-ff30-4461-91e7-56bdd82fc7a3",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-11-14T16:41:41Z",
        "updatedAt" : "2019-11-14T16:51:49Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c1c2a7b4334da897e51ecf64f41112df000ed29a",
    "line" : null,
    "diffHunk" : "@@ -15,25 +14,30 @@ import scala.collection.immutable.{HashMap, Map, Queue}\n   *  insert: O(1)\n   *  remove: O(n)\n   */\n-final class InsertOrdMap[Key, +Value] private (\n-    override val keys: Queue[Key],\n-    hashMap: HashMap[Key, Value]\n-) extends Map[Key, Value] {\n+final class InsertOrdMap[K, +V] private (\n+    override val keys: Queue[K],\n+    hashMap: HashMap[K, V]\n+) extends Map[K, V] {\n \n   override def size: Int = hashMap.size\n \n-  override def iterator: Iterator[(Key, Value)] =\n+  override def iterator: Iterator[(K, V)] =\n     keys.iterator.map(k => (k, hashMap(k)))\n \n-  override def get(key: Key): Option[Value] = hashMap.get(key)\n+  override def get(key: K): Option[V] = hashMap.get(key)\n \n-  override def +[V2 >: Value](kv: (Key, V2)): InsertOrdMap[Key, V2] =\n-    if (hashMap.contains(kv._1))\n-      new InsertOrdMap(keys, hashMap + kv)\n+  override def updated[V1 >: V](key: K, value: V1): InsertOrdMap[K, V1] =\n+    if (hashMap.contains(key))\n+      new InsertOrdMap(keys, hashMap.updated(key, value))\n     else\n-      new InsertOrdMap(keys :+ kv._1, hashMap + kv)\n+      new InsertOrdMap(keys :+ key, hashMap.updated(key, value))\n \n-  override def -(k: Key): InsertOrdMap[Key, Value] =\n+  override def +[V >: V](kv: (K, V)): InsertOrdMap[K, V] = {"
  },
  {
    "id" : "645ce092-5d78-4350-b059-9db4d8f394e9",
    "prId" : 3466,
    "comments" : [
      {
        "id" : "fe05075b-947c-43a4-b28b-966661916ff9",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "Did you mean to extend `Map` rather than `immutable.Map`?",
        "createdAt" : "2019-11-14T10:23:03Z",
        "updatedAt" : "2019-11-14T11:12:03Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "4d836433-8738-44ff-8354-383a555f5839",
        "parentId" : "fe05075b-947c-43a4-b28b-966661916ff9",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed",
        "createdAt" : "2019-11-14T11:03:08Z",
        "updatedAt" : "2019-11-14T11:12:03Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "93b627e2c5b6155459742be51d5ecc9d46585532",
    "line" : null,
    "diffHunk" : "@@ -12,57 +15,37 @@ package com.digitalasset.daml.lf.data\n   *  insert: O(1)\n   *  remove: O(n)\n   */\n-import scala.collection.immutable.{HashMap, Map, Queue}\n-\n-sealed abstract class InsertOrdMap[K, +V] extends Map[K, V] {\n-  def _keys: Queue[K]\n-  def _hashMap: Map[K, V]\n+final class InsertOrdMap[Key, +Value] private (\n+    override val keys: Queue[Key],\n+    hashMap: HashMap[Key, Value])\n+    extends Map[Key, Value] {"
  },
  {
    "id" : "d578b8ce-1b1b-460f-84ad-cb48ba4808b2",
    "prId" : 3466,
    "comments" : [
      {
        "id" : "d3b6da06-0d15-4204-80f4-017ba0490dbf",
        "parentId" : null,
        "author" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "body" : "```suggestion\r\n    new InsertOrdMap(entries.map(_._1)(breakOut), HashMap(entries: _*))\r\n```",
        "createdAt" : "2019-11-14T10:28:19Z",
        "updatedAt" : "2019-11-14T11:12:03Z",
        "lastEditedBy" : {
          "login" : "SamirTalwar",
          "name" : "Samir Talwar",
          "avatarUrl" : "https://avatars1.githubusercontent.com/u/47582?v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "93b627e2c5b6155459742be51d5ecc9d46585532",
    "line" : null,
    "diffHunk" : "@@ -12,57 +15,37 @@ package com.digitalasset.daml.lf.data\n   *  insert: O(1)\n   *  remove: O(n)\n   */\n-import scala.collection.immutable.{HashMap, Map, Queue}\n-\n-sealed abstract class InsertOrdMap[K, +V] extends Map[K, V] {\n-  def _keys: Queue[K]\n-  def _hashMap: Map[K, V]\n+final class InsertOrdMap[Key, +Value] private (\n+    override val keys: Queue[Key],\n+    hashMap: HashMap[Key, Value])\n+    extends Map[Key, Value] {\n \n-  override def empty = InsertOrdMap.empty\n+  override def size: Int = hashMap.size\n \n-  override def size: Int = _hashMap.size\n+  override def iterator: Iterator[(Key, Value)] =\n+    keys.iterator.map(k => (k, hashMap(k)))\n \n-  def iterator: Iterator[(K, V)] =\n-    _keys.map(k => (k, _hashMap(k))).reverse.iterator\n+  override def get(key: Key): Option[Value] = hashMap.get(key)\n \n-  def get(key: K): Option[V] = _hashMap.get(key)\n-\n-  def +[V2 >: V](kv: (K, V2)): InsertOrdMap[K, V2] =\n-    if (_hashMap.contains(kv._1))\n-      NonEmptyInsertOrdMap(\n-        _keys,\n-        _hashMap + kv\n-      )\n+  override def +[V2 >: Value](kv: (Key, V2)): InsertOrdMap[Key, V2] =\n+    if (hashMap.contains(kv._1))\n+      new InsertOrdMap(keys, hashMap + kv)\n     else\n-      NonEmptyInsertOrdMap(\n-        kv._1 +: _keys,\n-        _hashMap + kv\n-      )\n+      new InsertOrdMap(keys :+ kv._1, hashMap + kv)\n \n-  def -(k: K): InsertOrdMap[K, V] =\n-    NonEmptyInsertOrdMap(\n-      _keys.filter(k2 => k != k2),\n-      _hashMap - k\n-    )\n-}\n+  override def -(k: Key): InsertOrdMap[Key, Value] =\n+    new InsertOrdMap(keys.filter(_ != k), hashMap - k)\n \n-@SuppressWarnings(Array(\"org.wartremover.warts.Any\"))\n-final case object EmptyInsertOrdMap extends InsertOrdMap[Any, Nothing] {\n-  override def _keys = Queue[Any]()\n-  override def _hashMap = HashMap[Any, Nothing]()\n }\n \n-final case class NonEmptyInsertOrdMap[K, V](\n-    override val _keys: Queue[K],\n-    override val _hashMap: Map[K, V])\n-    extends InsertOrdMap[K, V]\n-\n object InsertOrdMap {\n-  def empty[K, V] = EmptyInsertOrdMap.asInstanceOf[InsertOrdMap[K, V]]\n \n-  def fromMap[K, V](m: Map[K, V]): InsertOrdMap[K, V] =\n-    NonEmptyInsertOrdMap(Queue(m.keys.toSeq: _*), m)\n+  private val Empty: InsertOrdMap[Unit, Nothing] = new InsertOrdMap(Queue.empty, HashMap.empty)\n+\n+  def empty[K, V]: InsertOrdMap[K, V] = Empty.asInstanceOf[InsertOrdMap[K, V]]\n+\n+  def apply[K, V](entries: (K, V)*): InsertOrdMap[K, V] = {\n+    new InsertOrdMap(entries.map(_._1)(breakOut), HashMap.apply(entries: _*))"
  }
]