[
  {
    "id" : "766881c6-ebdd-437d-a164-166dea4cabdd",
    "prId" : 7334,
    "comments" : [
      {
        "id" : "201d2515-ff31-471e-9b52-690f985c1633",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Nice!",
        "createdAt" : "2020-09-08T14:20:53Z",
        "updatedAt" : "2020-09-08T18:04:37Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "b9287729a15d23b6de2b6a2cfb39e2d599b87085",
    "line" : 10,
    "diffHunk" : "@@ -48,14 +48,7 @@ private[lf] object Equality {\n           push(xs.iterator, ys.iterator)\n         case (SOptional(xOpt), SOptional(yOpt)) =>\n           push(xOpt.iterator, yOpt.iterator)\n-        case (STextMap(xMap), STextMap(yMap)) =>\n-          val xKeys = xMap.keys.toSeq.sorted\n-          val yKeys = yMap.keys.toSeq.sorted\n-          push(\n-            new Interlace(xKeys.iterator.map(SText), xKeys.iterator.map(xMap)),\n-            new Interlace(yKeys.iterator.map(SText), yKeys.iterator.map(yMap)),\n-          )"
  },
  {
    "id" : "22b2f6a9-67ee-4e5f-8701-fb065b984816",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "a8e77b47-2c55-4ed9-8dc1-a4bbb929eea9",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Does this comply with the spec? My understanding of the spec is we need to compare the first keys in both maps, then the first values and finally the rest of the maps. Along the lines of\r\n```suggestion\r\n        stack.push(map1.values.iterator, map2.values.iterator)\r\n        stack.push(interleave(map1.keys.iterator, map1.values.iterator), interleave(map2.keys.iterator, map2.values.iterator))\r\n        true\r\n```\r\nRegarding the size comparison, we have the same issue as for lists.",
        "createdAt" : "2020-08-11T18:55:53Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -16,60 +12,81 @@ private[lf] object Equality {\n   // Note it is not reflexive, in other words there is some value `v`\n   // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    var success = true\n+    val stack = new Stack\n+    stack.push(x, y)\n \n-  @tailrec\n-  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n-    stack0.pop match {\n-      case Some((tuple, stack)) =>\n-        tuple match {\n-          case (x: SPrimLit, y: SPrimLit) =>\n-            x == y && equality(stack)\n-          case (SEnum(tyCon1, _, rank1), SEnum(tyCon2, _, rank2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality(stack)\n-          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n-            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n-              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n-          case (SVariant(tyCon1, _, rank1, arg1), SVariant(tyCon2, _, rank2, arg2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality((arg1, arg2) +: stack)\n-          case (SList(lst1), SList(lst2)) =>\n-            lst1.length == lst2.length &&\n-              equality(zipAndPush(lst1.iterator, lst2.iterator, stack))\n-          case (SOptional(None), SOptional(None)) =>\n-            equality(stack)\n-          case (SOptional(Some(v1)), SOptional(Some(v2))) =>\n-            equality((v1, v2) +: stack)\n-          case (STextMap(map1), STextMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SGenMap(map1), SGenMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n-            (fields1 sameElements fields2) && equality(\n-              zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack),\n-            )\n-          case (SAny(t1, v1), SAny(t2, v2)) =>\n-            t1 == t2 && equality((v1, v2) +: stack)\n-          case (STypeRep(t1), STypeRep(t2)) =>\n-            t1 == t2 && equality(stack)\n-          case _ =>\n-            false\n-        }\n-      case _ =>\n+    while (success && stack.nonEmpty) success = stack.pop() match {\n+      case (x: SPrimLit, y: SPrimLit) =>\n+        x == y\n+      case (SEnum(_, _, rank1), SEnum(_, _, rank2)) =>\n+        rank1 == rank2\n+      case (SRecord(_, _, args1), SRecord(_, _, args2)) =>\n+        stack.push(args1.iterator().asScala, args2.iterator().asScala)\n         true\n+      case (SVariant(_, _, rank1, arg1), SVariant(_, _, rank2, arg2)) =>\n+        stack.push(arg1, arg2)\n+        rank1 == rank2\n+      case (SList(lst1), SList(lst2)) =>\n+        stack.push(lst1.iterator, lst2.iterator)\n+        lst1.length == lst2.length\n+      case (SOptional(xs), SOptional(ys)) =>\n+        stack.push(xs.iterator, ys.iterator)\n+        xs.nonEmpty == ys.nonEmpty\n+      case (STextMap(map1), STextMap(map2)) =>\n+        val keys = map1.keys\n+        stack.push(keys.iterator.map(map1), keys.iterator.map(map2))\n+        map1.size == map2.size && keys.forall(map2.keySet.contains)\n+      case (SGenMap(map1), SGenMap(map2)) =>\n+        stack.push(map1.values.iterator, map2.values.iterator)\n+        stack.push(map1.keys.iterator, map2.keys.iterator)\n+        map1.size == map2.size"
  },
  {
    "id" : "c8c829dd-cc1d-402e-b48a-b05e74a3395d",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "41d47fb3-572a-45f3-9663-8bc13b5cc6fe",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This is against the spec, isn't it? Say we had a list containing one function and a list containing two functions. This code would say they are different but the spec says this should raise an exception. We probably need to allow iterators of different lengths in the `Stack` class below.",
        "createdAt" : "2020-08-11T19:00:19Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -16,60 +12,81 @@ private[lf] object Equality {\n   // Note it is not reflexive, in other words there is some value `v`\n   // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    var success = true\n+    val stack = new Stack\n+    stack.push(x, y)\n \n-  @tailrec\n-  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n-    stack0.pop match {\n-      case Some((tuple, stack)) =>\n-        tuple match {\n-          case (x: SPrimLit, y: SPrimLit) =>\n-            x == y && equality(stack)\n-          case (SEnum(tyCon1, _, rank1), SEnum(tyCon2, _, rank2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality(stack)\n-          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n-            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n-              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n-          case (SVariant(tyCon1, _, rank1, arg1), SVariant(tyCon2, _, rank2, arg2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality((arg1, arg2) +: stack)\n-          case (SList(lst1), SList(lst2)) =>\n-            lst1.length == lst2.length &&\n-              equality(zipAndPush(lst1.iterator, lst2.iterator, stack))\n-          case (SOptional(None), SOptional(None)) =>\n-            equality(stack)\n-          case (SOptional(Some(v1)), SOptional(Some(v2))) =>\n-            equality((v1, v2) +: stack)\n-          case (STextMap(map1), STextMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SGenMap(map1), SGenMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n-            (fields1 sameElements fields2) && equality(\n-              zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack),\n-            )\n-          case (SAny(t1, v1), SAny(t2, v2)) =>\n-            t1 == t2 && equality((v1, v2) +: stack)\n-          case (STypeRep(t1), STypeRep(t2)) =>\n-            t1 == t2 && equality(stack)\n-          case _ =>\n-            false\n-        }\n-      case _ =>\n+    while (success && stack.nonEmpty) success = stack.pop() match {\n+      case (x: SPrimLit, y: SPrimLit) =>\n+        x == y\n+      case (SEnum(_, _, rank1), SEnum(_, _, rank2)) =>\n+        rank1 == rank2\n+      case (SRecord(_, _, args1), SRecord(_, _, args2)) =>\n+        stack.push(args1.iterator().asScala, args2.iterator().asScala)\n         true\n+      case (SVariant(_, _, rank1, arg1), SVariant(_, _, rank2, arg2)) =>\n+        stack.push(arg1, arg2)\n+        rank1 == rank2\n+      case (SList(lst1), SList(lst2)) =>\n+        stack.push(lst1.iterator, lst2.iterator)\n+        lst1.length == lst2.length"
  },
  {
    "id" : "d5c3f5b0-bcde-406b-a321-520fc0901924",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "9f0aedab-fde9-4ce1-b1f8-48379969478c",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "This has similar issues to the ones described for generic map below. I would suggest we'll ultimately use the same code as for `SGenMap` with one slight change: We map the `SText` constructor over the iterator for the keys.",
        "createdAt" : "2020-08-11T19:04:28Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -16,60 +12,81 @@ private[lf] object Equality {\n   // Note it is not reflexive, in other words there is some value `v`\n   // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    var success = true\n+    val stack = new Stack\n+    stack.push(x, y)\n \n-  @tailrec\n-  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n-    stack0.pop match {\n-      case Some((tuple, stack)) =>\n-        tuple match {\n-          case (x: SPrimLit, y: SPrimLit) =>\n-            x == y && equality(stack)\n-          case (SEnum(tyCon1, _, rank1), SEnum(tyCon2, _, rank2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality(stack)\n-          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n-            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n-              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n-          case (SVariant(tyCon1, _, rank1, arg1), SVariant(tyCon2, _, rank2, arg2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality((arg1, arg2) +: stack)\n-          case (SList(lst1), SList(lst2)) =>\n-            lst1.length == lst2.length &&\n-              equality(zipAndPush(lst1.iterator, lst2.iterator, stack))\n-          case (SOptional(None), SOptional(None)) =>\n-            equality(stack)\n-          case (SOptional(Some(v1)), SOptional(Some(v2))) =>\n-            equality((v1, v2) +: stack)\n-          case (STextMap(map1), STextMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SGenMap(map1), SGenMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n-            (fields1 sameElements fields2) && equality(\n-              zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack),\n-            )\n-          case (SAny(t1, v1), SAny(t2, v2)) =>\n-            t1 == t2 && equality((v1, v2) +: stack)\n-          case (STypeRep(t1), STypeRep(t2)) =>\n-            t1 == t2 && equality(stack)\n-          case _ =>\n-            false\n-        }\n-      case _ =>\n+    while (success && stack.nonEmpty) success = stack.pop() match {\n+      case (x: SPrimLit, y: SPrimLit) =>\n+        x == y\n+      case (SEnum(_, _, rank1), SEnum(_, _, rank2)) =>\n+        rank1 == rank2\n+      case (SRecord(_, _, args1), SRecord(_, _, args2)) =>\n+        stack.push(args1.iterator().asScala, args2.iterator().asScala)\n         true\n+      case (SVariant(_, _, rank1, arg1), SVariant(_, _, rank2, arg2)) =>\n+        stack.push(arg1, arg2)\n+        rank1 == rank2\n+      case (SList(lst1), SList(lst2)) =>\n+        stack.push(lst1.iterator, lst2.iterator)\n+        lst1.length == lst2.length\n+      case (SOptional(xs), SOptional(ys)) =>\n+        stack.push(xs.iterator, ys.iterator)\n+        xs.nonEmpty == ys.nonEmpty\n+      case (STextMap(map1), STextMap(map2)) =>\n+        val keys = map1.keys\n+        stack.push(keys.iterator.map(map1), keys.iterator.map(map2))\n+        map1.size == map2.size && keys.forall(map2.keySet.contains)"
  },
  {
    "id" : "d3a6f722-f4a8-45ab-b355-6a8688fab8ef",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "16771ffb-b9bc-437d-9905-0280096772f4",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Have we decided if we want the fields to be sorted or not? I don't see any reason why we should identify the types `<a: S, b: T>` and `<b: T, a:S>` since we only use structural records for type class dictionaries, which cannot be compared.",
        "createdAt" : "2020-08-11T19:07:05Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -16,60 +12,81 @@ private[lf] object Equality {\n   // Note it is not reflexive, in other words there is some value `v`\n   // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    var success = true\n+    val stack = new Stack\n+    stack.push(x, y)\n \n-  @tailrec\n-  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n-    stack0.pop match {\n-      case Some((tuple, stack)) =>\n-        tuple match {\n-          case (x: SPrimLit, y: SPrimLit) =>\n-            x == y && equality(stack)\n-          case (SEnum(tyCon1, _, rank1), SEnum(tyCon2, _, rank2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality(stack)\n-          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n-            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n-              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n-          case (SVariant(tyCon1, _, rank1, arg1), SVariant(tyCon2, _, rank2, arg2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality((arg1, arg2) +: stack)\n-          case (SList(lst1), SList(lst2)) =>\n-            lst1.length == lst2.length &&\n-              equality(zipAndPush(lst1.iterator, lst2.iterator, stack))\n-          case (SOptional(None), SOptional(None)) =>\n-            equality(stack)\n-          case (SOptional(Some(v1)), SOptional(Some(v2))) =>\n-            equality((v1, v2) +: stack)\n-          case (STextMap(map1), STextMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SGenMap(map1), SGenMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n-            (fields1 sameElements fields2) && equality(\n-              zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack),\n-            )\n-          case (SAny(t1, v1), SAny(t2, v2)) =>\n-            t1 == t2 && equality((v1, v2) +: stack)\n-          case (STypeRep(t1), STypeRep(t2)) =>\n-            t1 == t2 && equality(stack)\n-          case _ =>\n-            false\n-        }\n-      case _ =>\n+    while (success && stack.nonEmpty) success = stack.pop() match {\n+      case (x: SPrimLit, y: SPrimLit) =>\n+        x == y\n+      case (SEnum(_, _, rank1), SEnum(_, _, rank2)) =>\n+        rank1 == rank2\n+      case (SRecord(_, _, args1), SRecord(_, _, args2)) =>\n+        stack.push(args1.iterator().asScala, args2.iterator().asScala)\n         true\n+      case (SVariant(_, _, rank1, arg1), SVariant(_, _, rank2, arg2)) =>\n+        stack.push(arg1, arg2)\n+        rank1 == rank2\n+      case (SList(lst1), SList(lst2)) =>\n+        stack.push(lst1.iterator, lst2.iterator)\n+        lst1.length == lst2.length\n+      case (SOptional(xs), SOptional(ys)) =>\n+        stack.push(xs.iterator, ys.iterator)\n+        xs.nonEmpty == ys.nonEmpty\n+      case (STextMap(map1), STextMap(map2)) =>\n+        val keys = map1.keys\n+        stack.push(keys.iterator.map(map1), keys.iterator.map(map2))\n+        map1.size == map2.size && keys.forall(map2.keySet.contains)\n+      case (SGenMap(map1), SGenMap(map2)) =>\n+        stack.push(map1.values.iterator, map2.values.iterator)\n+        stack.push(map1.keys.iterator, map2.keys.iterator)\n+        map1.size == map2.size\n+      case (SStruct(fields1, args1), SStruct(fields2, args2)) =>"
  },
  {
    "id" : "58fb9197-8e1f-490e-b74d-77a9a4626b59",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "0efbcd9d-5be9-414d-a031-ecfbeaed22ba",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Doe this take type synonyms into account?",
        "createdAt" : "2020-08-11T19:07:29Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "5cccd72c-0769-4bd2-81c0-8500be430e8c",
        "parentId" : "0efbcd9d-5be9-414d-a031-ecfbeaed22ba",
        "author" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "body" : "TypeReps can't have type synonyms, see the `ExpTypeRep` rule.",
        "createdAt" : "2020-08-12T07:36:51Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "sofiafaro-da",
          "name" : "Sofia Faro",
          "avatarUrl" : "https://avatars3.githubusercontent.com/u/63245722?u=b440e86239cc6cb4a8b4aacdc19fff8f1b61068d&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -16,60 +12,81 @@ private[lf] object Equality {\n   // Note it is not reflexive, in other words there is some value `v`\n   // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    var success = true\n+    val stack = new Stack\n+    stack.push(x, y)\n \n-  @tailrec\n-  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n-    stack0.pop match {\n-      case Some((tuple, stack)) =>\n-        tuple match {\n-          case (x: SPrimLit, y: SPrimLit) =>\n-            x == y && equality(stack)\n-          case (SEnum(tyCon1, _, rank1), SEnum(tyCon2, _, rank2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality(stack)\n-          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n-            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n-              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n-          case (SVariant(tyCon1, _, rank1, arg1), SVariant(tyCon2, _, rank2, arg2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality((arg1, arg2) +: stack)\n-          case (SList(lst1), SList(lst2)) =>\n-            lst1.length == lst2.length &&\n-              equality(zipAndPush(lst1.iterator, lst2.iterator, stack))\n-          case (SOptional(None), SOptional(None)) =>\n-            equality(stack)\n-          case (SOptional(Some(v1)), SOptional(Some(v2))) =>\n-            equality((v1, v2) +: stack)\n-          case (STextMap(map1), STextMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SGenMap(map1), SGenMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n-            (fields1 sameElements fields2) && equality(\n-              zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack),\n-            )\n-          case (SAny(t1, v1), SAny(t2, v2)) =>\n-            t1 == t2 && equality((v1, v2) +: stack)\n-          case (STypeRep(t1), STypeRep(t2)) =>\n-            t1 == t2 && equality(stack)\n-          case _ =>\n-            false\n-        }\n-      case _ =>\n+    while (success && stack.nonEmpty) success = stack.pop() match {\n+      case (x: SPrimLit, y: SPrimLit) =>\n+        x == y\n+      case (SEnum(_, _, rank1), SEnum(_, _, rank2)) =>\n+        rank1 == rank2\n+      case (SRecord(_, _, args1), SRecord(_, _, args2)) =>\n+        stack.push(args1.iterator().asScala, args2.iterator().asScala)\n         true\n+      case (SVariant(_, _, rank1, arg1), SVariant(_, _, rank2, arg2)) =>\n+        stack.push(arg1, arg2)\n+        rank1 == rank2\n+      case (SList(lst1), SList(lst2)) =>\n+        stack.push(lst1.iterator, lst2.iterator)\n+        lst1.length == lst2.length\n+      case (SOptional(xs), SOptional(ys)) =>\n+        stack.push(xs.iterator, ys.iterator)\n+        xs.nonEmpty == ys.nonEmpty\n+      case (STextMap(map1), STextMap(map2)) =>\n+        val keys = map1.keys\n+        stack.push(keys.iterator.map(map1), keys.iterator.map(map2))\n+        map1.size == map2.size && keys.forall(map2.keySet.contains)\n+      case (SGenMap(map1), SGenMap(map2)) =>\n+        stack.push(map1.values.iterator, map2.values.iterator)\n+        stack.push(map1.keys.iterator, map2.keys.iterator)\n+        map1.size == map2.size\n+      case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n+        stack.push(args1.iterator().asScala, args2.iterator().asScala)\n+        fields1 sameElements fields2\n+      case (SAny(t1, v1), SAny(t2, v2)) =>\n+        stack.push(v1, v2)\n+        t1 == t2\n+      case (STypeRep(t1), STypeRep(t2)) =>"
  },
  {
    "id" : "1694bfb5-6a67-43b8-8c80-73c92eb34eed",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "0aefb33e-a7b1-4a7f-b22c-5d3437f8ffb5",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "I would find the following a bit easier to understand but I assume the Scala compiler doesn't compile this into particularly efficient code. Or does it?\r\n```suggestion\r\n      (stackX.head.hasNext, stackY.head.hasNext) match {\r\n        case (true, true) => step((stackX.head.next(), stackY.head.next()))\r\n        case (false, false) => pop()\r\n        case _ => success = false\r\n      }\r\n```",
        "createdAt" : "2020-08-20T09:18:19Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "d62b43a7-8174-4f4a-af50-6b7c35179b48",
        "parentId" : "0aefb33e-a7b1-4a7f-b22c-5d3437f8ffb5",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "The Scala compiler is probably not so clever.\r\nI changed it anyway. ",
        "createdAt" : "2020-08-20T12:35:29Z",
        "updatedAt" : "2020-08-20T12:35:35Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -1,75 +1,103 @@\n // Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n-package com.daml.lf.speedy.svalue\n+package com.daml.lf.speedy\n+package svalue\n+import com.daml.lf.speedy.SError.SErrorCrash\n \n-import com.daml.lf.data.FrontStack\n-import com.daml.lf.speedy.SValue\n-import com.daml.lf.speedy.SValue._\n-\n-import scala.annotation.tailrec\n import scala.collection.JavaConverters._\n \n private[lf] object Equality {\n \n   // Equality between two SValues of same type.\n-  // Note it is not reflexive, in other words there is some value `v`\n-  // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  @throws[SErrorCrash]\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n+\n+    var success = true\n+    var stackX = List(Iterator(x))\n+    var stackY = List(Iterator(y))\n+    // invariant: stackX.length == stackY.length\n+\n+    @inline\n+    def push(xs: Iterator[SValue], ys: Iterator[SValue]) = {\n+      stackX = xs :: stackX\n+      stackY = ys :: stackY\n+    }\n+\n+    @inline\n+    def pop() = {\n+      stackX = stackX.tail\n+      stackY = stackY.tail\n+    }\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    @inline\n+    def step(tuple: (SValue, SValue)) =\n+      tuple match {\n+        case (x: SPrimLit, y: SPrimLit) =>\n+          success = x == y\n+        case (SEnum(_, _, xRank), SEnum(_, _, yRank)) =>\n+          success = xRank == yRank\n+        case (SRecord(_, _, xs), SRecord(_, _, ys)) =>\n+          push(xs.iterator().asScala, ys.iterator().asScala)\n+        case (SVariant(_, _, xRank, x), SVariant(_, _, yRank, y)) =>\n+          push(Iterator(x), Iterator(y))\n+          success = xRank == yRank\n+        case (SList(xs), SList(ys)) =>\n+          push(xs.iterator, ys.iterator)\n+        case (SOptional(xOpt), SOptional(yOpt)) =>\n+          push(xOpt.iterator, yOpt.iterator)\n+        case (STextMap(xMap), STextMap(yMap)) =>\n+          val xKeys = xMap.keys.toSeq.sorted\n+          val yKeys = yMap.keys.toSeq.sorted\n+          push(\n+            new Interlace(xKeys.iterator.map(SText), xKeys.iterator.map(xMap)),\n+            new Interlace(yKeys.iterator.map(SText), yKeys.iterator.map(yMap)),\n+          )\n+        case (SGenMap(xMap), SGenMap(yMap)) =>\n+          push(\n+            new Interlace(xMap.keys.iterator, xMap.values.iterator),\n+            new Interlace(yMap.keys.iterator, yMap.values.iterator),\n+          )\n+        case (SStruct(_, xs), SStruct(_, ys)) =>\n+          push(xs.iterator().asScala, ys.iterator().asScala)\n+        case (SAny(xType, x), SAny(yType, y)) =>\n+          push(Iterator(x), Iterator(y))\n+          success = xType == yType\n+        case (STypeRep(xType), STypeRep(yType)) =>\n+          success = xType == yType\n+        case _ =>\n+          throw SErrorCrash(\"try to compare incomparable type\")\n+      }\n \n-  @tailrec\n-  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n-    stack0.pop match {\n-      case Some((tuple, stack)) =>\n-        tuple match {\n-          case (x: SPrimLit, y: SPrimLit) =>\n-            x == y && equality(stack)\n-          case (SEnum(tyCon1, _, rank1), SEnum(tyCon2, _, rank2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality(stack)\n-          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n-            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n-              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n-          case (SVariant(tyCon1, _, rank1, arg1), SVariant(tyCon2, _, rank2, arg2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality((arg1, arg2) +: stack)\n-          case (SList(lst1), SList(lst2)) =>\n-            lst1.length == lst2.length &&\n-              equality(zipAndPush(lst1.iterator, lst2.iterator, stack))\n-          case (SOptional(None), SOptional(None)) =>\n-            equality(stack)\n-          case (SOptional(Some(v1)), SOptional(Some(v2))) =>\n-            equality((v1, v2) +: stack)\n-          case (STextMap(map1), STextMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SGenMap(map1), SGenMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n-            (fields1 sameElements fields2) && equality(\n-              zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack),\n-            )\n-          case (SAny(t1, v1), SAny(t2, v2)) =>\n-            t1 == t2 && equality((v1, v2) +: stack)\n-          case (STypeRep(t1), STypeRep(t2)) =>\n-            t1 == t2 && equality(stack)\n-          case _ =>\n-            false\n-        }\n-      case _ =>\n-        true\n+    while (success && stackX.nonEmpty) {\n+      if (stackX.head.hasNext != stackY.head.hasNext)\n+        success = false\n+      else if (stackX.head.hasNext)\n+        step((stackX.head.next(), stackY.head.next()))\n+      else\n+        pop()"
  },
  {
    "id" : "b63fb31c-aca8-4cf3-9e3c-bb045f3e7994",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "5ed2343e-e15b-432b-a70f-a19f1e36bb04",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "Maybe we should document that we assume both iterators to be of the same length. Although it will still work if they are not, it's non-trivial to explain what it would actually do then.",
        "createdAt" : "2020-08-20T09:22:48Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
        ]
      },
      {
        "id" : "fd2b7150-6fea-479d-a076-feb07debd9dc",
        "parentId" : "5ed2343e-e15b-432b-a70f-a19f1e36bb04",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : ":+1: ",
        "createdAt" : "2020-08-20T11:39:12Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : 145,
    "diffHunk" : "@@ -1,75 +1,103 @@\n // Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n-package com.daml.lf.speedy.svalue\n+package com.daml.lf.speedy\n+package svalue\n+import com.daml.lf.speedy.SError.SErrorCrash\n \n-import com.daml.lf.data.FrontStack\n-import com.daml.lf.speedy.SValue\n-import com.daml.lf.speedy.SValue._\n-\n-import scala.annotation.tailrec\n import scala.collection.JavaConverters._\n \n private[lf] object Equality {\n \n   // Equality between two SValues of same type.\n-  // Note it is not reflexive, in other words there is some value `v`\n-  // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  @throws[SErrorCrash]\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n+\n+    var success = true\n+    var stackX = List(Iterator(x))\n+    var stackY = List(Iterator(y))\n+    // invariant: stackX.length == stackY.length\n+\n+    @inline\n+    def push(xs: Iterator[SValue], ys: Iterator[SValue]) = {\n+      stackX = xs :: stackX\n+      stackY = ys :: stackY\n+    }\n+\n+    @inline\n+    def pop() = {\n+      stackX = stackX.tail\n+      stackY = stackY.tail\n+    }\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    @inline\n+    def step(tuple: (SValue, SValue)) =\n+      tuple match {\n+        case (x: SPrimLit, y: SPrimLit) =>\n+          success = x == y\n+        case (SEnum(_, _, xRank), SEnum(_, _, yRank)) =>\n+          success = xRank == yRank\n+        case (SRecord(_, _, xs), SRecord(_, _, ys)) =>\n+          push(xs.iterator().asScala, ys.iterator().asScala)\n+        case (SVariant(_, _, xRank, x), SVariant(_, _, yRank, y)) =>\n+          push(Iterator(x), Iterator(y))\n+          success = xRank == yRank\n+        case (SList(xs), SList(ys)) =>\n+          push(xs.iterator, ys.iterator)\n+        case (SOptional(xOpt), SOptional(yOpt)) =>\n+          push(xOpt.iterator, yOpt.iterator)\n+        case (STextMap(xMap), STextMap(yMap)) =>\n+          val xKeys = xMap.keys.toSeq.sorted\n+          val yKeys = yMap.keys.toSeq.sorted\n+          push(\n+            new Interlace(xKeys.iterator.map(SText), xKeys.iterator.map(xMap)),\n+            new Interlace(yKeys.iterator.map(SText), yKeys.iterator.map(yMap)),\n+          )\n+        case (SGenMap(xMap), SGenMap(yMap)) =>\n+          push(\n+            new Interlace(xMap.keys.iterator, xMap.values.iterator),\n+            new Interlace(yMap.keys.iterator, yMap.values.iterator),\n+          )\n+        case (SStruct(_, xs), SStruct(_, ys)) =>\n+          push(xs.iterator().asScala, ys.iterator().asScala)\n+        case (SAny(xType, x), SAny(yType, y)) =>\n+          push(Iterator(x), Iterator(y))\n+          success = xType == yType\n+        case (STypeRep(xType), STypeRep(yType)) =>\n+          success = xType == yType\n+        case _ =>\n+          throw SErrorCrash(\"try to compare incomparable type\")\n+      }\n \n-  @tailrec\n-  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n-    stack0.pop match {\n-      case Some((tuple, stack)) =>\n-        tuple match {\n-          case (x: SPrimLit, y: SPrimLit) =>\n-            x == y && equality(stack)\n-          case (SEnum(tyCon1, _, rank1), SEnum(tyCon2, _, rank2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality(stack)\n-          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n-            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n-              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n-          case (SVariant(tyCon1, _, rank1, arg1), SVariant(tyCon2, _, rank2, arg2)) =>\n-            tyCon1 == tyCon2 && rank1 == rank2 && equality((arg1, arg2) +: stack)\n-          case (SList(lst1), SList(lst2)) =>\n-            lst1.length == lst2.length &&\n-              equality(zipAndPush(lst1.iterator, lst2.iterator, stack))\n-          case (SOptional(None), SOptional(None)) =>\n-            equality(stack)\n-          case (SOptional(Some(v1)), SOptional(Some(v2))) =>\n-            equality((v1, v2) +: stack)\n-          case (STextMap(map1), STextMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SGenMap(map1), SGenMap(map2)) =>\n-            map1.keySet == map2.keySet && {\n-              val keys = map1.keys\n-              equality(zipAndPush(keys.iterator.map(map1), keys.iterator.map(map2), stack))\n-            }\n-          case (SStruct(fields1, args1), SStruct(fields2, args2)) =>\n-            (fields1 sameElements fields2) && equality(\n-              zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack),\n-            )\n-          case (SAny(t1, v1), SAny(t2, v2)) =>\n-            t1 == t2 && equality((v1, v2) +: stack)\n-          case (STypeRep(t1), STypeRep(t2)) =>\n-            t1 == t2 && equality(stack)\n-          case _ =>\n-            false\n-        }\n-      case _ =>\n-        true\n+    while (success && stackX.nonEmpty) {\n+      if (stackX.head.hasNext != stackY.head.hasNext)\n+        success = false\n+      else if (stackX.head.hasNext)\n+        step((stackX.head.next(), stackY.head.next()))\n+      else\n+        pop()\n     }\n+\n+    success\n+  }\n+\n+  private[this] final class Interlace[X](iterLeft: Iterator[X], iterRight: Iterator[X])"
  },
  {
    "id" : "444aa392-c675-4348-b43e-f3e3dd3c61d3",
    "prId" : 7083,
    "comments" : [
      {
        "id" : "4e494b6d-12e7-4736-90bc-3aa236b4052d",
        "parentId" : null,
        "author" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "body" : "```suggestion\r\n          throw SErrorCrash(\"trying to compare incomparable types\")\r\n```",
        "createdAt" : "2020-08-20T09:25:45Z",
        "updatedAt" : "2020-08-20T12:32:13Z",
        "lastEditedBy" : {
          "login" : "hurryabit",
          "name" : "Martin Huschenbett",
          "avatarUrl" : "https://avatars0.githubusercontent.com/u/11665611?u=7dbd00d5e7ea53919ed31dc4200f602ebca91c8f&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      },
      {
        "id" : "42a80aa3-a0be-41d1-8316-a70c0902d9e4",
        "parentId" : "4e494b6d-12e7-4736-90bc-3aa236b4052d",
        "author" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "body" : "fixed.",
        "createdAt" : "2020-08-20T12:35:48Z",
        "updatedAt" : "2020-08-20T12:35:49Z",
        "lastEditedBy" : {
          "login" : "remyhaemmerle-da",
          "name" : "Remy",
          "avatarUrl" : "https://avatars2.githubusercontent.com/u/45566104?u=10d0caf8150a686217852f90e91314a4de3239a9&v=4"
        },
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "885e1e494dc43921d3b7c81feaf4af5ab026a1ba",
    "line" : null,
    "diffHunk" : "@@ -1,75 +1,103 @@\n // Copyright (c) 2020 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n // SPDX-License-Identifier: Apache-2.0\n \n-package com.daml.lf.speedy.svalue\n+package com.daml.lf.speedy\n+package svalue\n+import com.daml.lf.speedy.SError.SErrorCrash\n \n-import com.daml.lf.data.FrontStack\n-import com.daml.lf.speedy.SValue\n-import com.daml.lf.speedy.SValue._\n-\n-import scala.annotation.tailrec\n import scala.collection.JavaConverters._\n \n private[lf] object Equality {\n \n   // Equality between two SValues of same type.\n-  // Note it is not reflexive, in other words there is some value `v`\n-  // such that `areEqual(v, v)` returns `False`).\n   // This follows the equality defined in the daml-lf spec.\n-  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+  @throws[SErrorCrash]\n+  def areEqual(x: SValue, y: SValue): Boolean = {\n+    import SValue._\n+\n+    var success = true\n+    var stackX = List(Iterator(x))\n+    var stackY = List(Iterator(y))\n+    // invariant: stackX.length == stackY.length\n+\n+    @inline\n+    def push(xs: Iterator[SValue], ys: Iterator[SValue]) = {\n+      stackX = xs :: stackX\n+      stackY = ys :: stackY\n+    }\n+\n+    @inline\n+    def pop() = {\n+      stackX = stackX.tail\n+      stackY = stackY.tail\n+    }\n \n-  private[this] def zipAndPush[X, Y](\n-      h1: Iterator[X],\n-      h2: Iterator[Y],\n-      stack: FrontStack[(X, Y)],\n-  ): FrontStack[(X, Y)] =\n-    ((h1 zip h2) foldLeft stack)(_.+:(_))\n+    @inline\n+    def step(tuple: (SValue, SValue)) =\n+      tuple match {\n+        case (x: SPrimLit, y: SPrimLit) =>\n+          success = x == y\n+        case (SEnum(_, _, xRank), SEnum(_, _, yRank)) =>\n+          success = xRank == yRank\n+        case (SRecord(_, _, xs), SRecord(_, _, ys)) =>\n+          push(xs.iterator().asScala, ys.iterator().asScala)\n+        case (SVariant(_, _, xRank, x), SVariant(_, _, yRank, y)) =>\n+          push(Iterator(x), Iterator(y))\n+          success = xRank == yRank\n+        case (SList(xs), SList(ys)) =>\n+          push(xs.iterator, ys.iterator)\n+        case (SOptional(xOpt), SOptional(yOpt)) =>\n+          push(xOpt.iterator, yOpt.iterator)\n+        case (STextMap(xMap), STextMap(yMap)) =>\n+          val xKeys = xMap.keys.toSeq.sorted\n+          val yKeys = yMap.keys.toSeq.sorted\n+          push(\n+            new Interlace(xKeys.iterator.map(SText), xKeys.iterator.map(xMap)),\n+            new Interlace(yKeys.iterator.map(SText), yKeys.iterator.map(yMap)),\n+          )\n+        case (SGenMap(xMap), SGenMap(yMap)) =>\n+          push(\n+            new Interlace(xMap.keys.iterator, xMap.values.iterator),\n+            new Interlace(yMap.keys.iterator, yMap.values.iterator),\n+          )\n+        case (SStruct(_, xs), SStruct(_, ys)) =>\n+          push(xs.iterator().asScala, ys.iterator().asScala)\n+        case (SAny(xType, x), SAny(yType, y)) =>\n+          push(Iterator(x), Iterator(y))\n+          success = xType == yType\n+        case (STypeRep(xType), STypeRep(yType)) =>\n+          success = xType == yType\n+        case _ =>\n+          throw SErrorCrash(\"try to compare incomparable type\")"
  },
  {
    "id" : "3d0e92e1-0a09-4873-a363-d0810af55c14",
    "prId" : 3416,
    "comments" : [
      {
        "id" : "16c0137a-92da-45e7-8643-e81e39379cde",
        "parentId" : null,
        "author" : null,
        "body" : "```suggestion\r\n            lst1.length == lst2.length &&\r\n```",
        "createdAt" : "2019-11-11T17:07:18Z",
        "updatedAt" : "2019-11-12T10:28:32Z",
        "lastEditedBy" : null,
        "tags" : [
          {
            "value" : "outdated"
          }
        ]
      }
    ],
    "commit" : "c66a8518440a160bdac8fa002ff6c9c0aac64311",
    "line" : null,
    "diffHunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2019 The DAML Authors. All rights reserved.\n+// SPDX-License-Identifier: Apache-2.0\n+\n+package com.digitalasset.daml.lf.speedy.svalue\n+\n+import com.digitalasset.daml.lf.data.FrontStack\n+import com.digitalasset.daml.lf.speedy.SValue\n+import com.digitalasset.daml.lf.speedy.SValue._\n+\n+import scala.annotation.tailrec\n+import scala.collection.JavaConverters._\n+\n+// FIXME https://github.com/digital-asset/daml/issues/2256\n+// add extensive tests\n+object Equality {\n+\n+  // Equality between two SValues of same type.\n+  def areEqual(x: SValue, y: SValue): Boolean = equality(FrontStack((x, y)))\n+\n+  private[this] def zipAndPush[X, Y](\n+      h1: Iterator[X],\n+      h2: Iterator[Y],\n+      stack: FrontStack[(X, Y)]): FrontStack[(X, Y)] =\n+    (stack /: (h1 zip h2))(_.+:(_))\n+\n+  @tailrec\n+  private[this] def equality(stack0: FrontStack[(SValue, SValue)]): Boolean = {\n+    stack0.pop match {\n+      case Some((tuple, stack)) =>\n+        tuple match {\n+          case (x: SPrimLit, y: SPrimLit) =>\n+            x == y && equality(stack)\n+          case (SEnum(tyCon1, con1), SEnum(tyCon2, con2)) =>\n+            tyCon1 == tyCon2 && con1 == con2 && equality(stack)\n+          case (SRecord(tyCon1, fields1, args1), SRecord(tyCon2, fields2, args2)) =>\n+            tyCon1 == tyCon2 && (fields1 sameElements fields2) &&\n+              equality(zipAndPush(args1.iterator().asScala, args2.iterator().asScala, stack))\n+          case (SVariant(tyCon1, con1, arg1), SVariant(tyCon2, con2, arg2)) =>\n+            tyCon1 == tyCon2 && con1 == con2 && equality((arg1, arg2) +: stack)\n+          case (SList(lst1), SList(lst2)) =>\n+            lst1.length == lst1.length &&"
  }
]